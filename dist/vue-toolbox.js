(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('moment')) :
  typeof define === 'function' && define.amd ? define(['exports', 'moment'], factory) :
  (factory((global.VueToolbox = {}),global.moment));
}(this, (function (exports,moment) { 'use strict';

  moment = moment && moment.hasOwnProperty('default') ? moment['default'] : moment;

  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */
  function isObject(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
  }

  var isObject_1 = isObject;

  /**
   * Checks if `value` is classified as an `Array` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array, else `false`.
   * @example
   *
   * _.isArray([1, 2, 3]);
   * // => true
   *
   * _.isArray(document.body.children);
   * // => false
   *
   * _.isArray('abc');
   * // => false
   *
   * _.isArray(_.noop);
   * // => false
   */
  var isArray = Array.isArray;

  var isArray_1 = isArray;

  var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

  var _freeGlobal = freeGlobal;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root = _freeGlobal || freeSelf || Function('return this')();

  var _root = root;

  /** Built-in value references. */
  var Symbol$1 = _root.Symbol;

  var _Symbol = Symbol$1;

  /** Used for built-in method references. */
  var objectProto = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty = objectProto.hasOwnProperty;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString = objectProto.toString;

  /** Built-in value references. */
  var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

  /**
   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the raw `toStringTag`.
   */
  function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag),
        tag = value[symToStringTag];

    try {
      value[symToStringTag] = undefined;
      var unmasked = true;
    } catch (e) {}

    var result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }

  var _getRawTag = getRawTag;

  /** Used for built-in method references. */
  var objectProto$1 = Object.prototype;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString$1 = objectProto$1.toString;

  /**
   * Converts `value` to a string using `Object.prototype.toString`.
   *
   * @private
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   */
  function objectToString(value) {
    return nativeObjectToString$1.call(value);
  }

  var _objectToString = objectToString;

  /** `Object#toString` result references. */
  var nullTag = '[object Null]',
      undefinedTag = '[object Undefined]';

  /** Built-in value references. */
  var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;

  /**
   * The base implementation of `getTag` without fallbacks for buggy environments.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }
    return (symToStringTag$1 && symToStringTag$1 in Object(value))
      ? _getRawTag(value)
      : _objectToString(value);
  }

  var _baseGetTag = baseGetTag;

  /** `Object#toString` result references. */
  var asyncTag = '[object AsyncFunction]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      proxyTag = '[object Proxy]';

  /**
   * Checks if `value` is classified as a `Function` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   *
   * _.isFunction(/abc/);
   * // => false
   */
  function isFunction(value) {
    if (!isObject_1(value)) {
      return false;
    }
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.
    var tag = _baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }

  var isFunction_1 = isFunction;

  /** Used to detect overreaching core-js shims. */
  var coreJsData = _root['__core-js_shared__'];

  var _coreJsData = coreJsData;

  /** Used to detect methods masquerading as native. */
  var maskSrcKey = (function() {
    var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || '');
    return uid ? ('Symbol(src)_1.' + uid) : '';
  }());

  /**
   * Checks if `func` has its source masked.
   *
   * @private
   * @param {Function} func The function to check.
   * @returns {boolean} Returns `true` if `func` is masked, else `false`.
   */
  function isMasked(func) {
    return !!maskSrcKey && (maskSrcKey in func);
  }

  var _isMasked = isMasked;

  /** Used for built-in method references. */
  var funcProto = Function.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString = funcProto.toString;

  /**
   * Converts `func` to its source code.
   *
   * @private
   * @param {Function} func The function to convert.
   * @returns {string} Returns the source code.
   */
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {}
      try {
        return (func + '');
      } catch (e) {}
    }
    return '';
  }

  var _toSource = toSource;

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

  /** Used to detect host constructors (Safari). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used for built-in method references. */
  var funcProto$1 = Function.prototype,
      objectProto$2 = Object.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString$1 = funcProto$1.toString;

  /** Used to check objects for own properties. */
  var hasOwnProperty$1 = objectProto$2.hasOwnProperty;

  /** Used to detect if a method is native. */
  var reIsNative = RegExp('^' +
    funcToString$1.call(hasOwnProperty$1).replace(reRegExpChar, '\\$&')
    .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
  );

  /**
   * The base implementation of `_.isNative` without bad shim checks.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a native function,
   *  else `false`.
   */
  function baseIsNative(value) {
    if (!isObject_1(value) || _isMasked(value)) {
      return false;
    }
    var pattern = isFunction_1(value) ? reIsNative : reIsHostCtor;
    return pattern.test(_toSource(value));
  }

  var _baseIsNative = baseIsNative;

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  var _getValue = getValue;

  /**
   * Gets the native function at `key` of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the method to get.
   * @returns {*} Returns the function if it's native, else `undefined`.
   */
  function getNative(object, key) {
    var value = _getValue(object, key);
    return _baseIsNative(value) ? value : undefined;
  }

  var _getNative = getNative;

  var defineProperty = (function() {
    try {
      var func = _getNative(Object, 'defineProperty');
      func({}, '', {});
      return func;
    } catch (e) {}
  }());

  var _defineProperty = defineProperty;

  /**
   * The base implementation of `assignValue` and `assignMergeValue` without
   * value checks.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */
  function baseAssignValue(object, key, value) {
    if (key == '__proto__' && _defineProperty) {
      _defineProperty(object, key, {
        'configurable': true,
        'enumerable': true,
        'value': value,
        'writable': true
      });
    } else {
      object[key] = value;
    }
  }

  var _baseAssignValue = baseAssignValue;

  /**
   * Performs a
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * comparison between two values to determine if they are equivalent.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'a': 1 };
   * var other = { 'a': 1 };
   *
   * _.eq(object, object);
   * // => true
   *
   * _.eq(object, other);
   * // => false
   *
   * _.eq('a', 'a');
   * // => true
   *
   * _.eq('a', Object('a'));
   * // => false
   *
   * _.eq(NaN, NaN);
   * // => true
   */
  function eq(value, other) {
    return value === other || (value !== value && other !== other);
  }

  var eq_1 = eq;

  /** Used for built-in method references. */
  var objectProto$3 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$2 = objectProto$3.hasOwnProperty;

  /**
   * Assigns `value` to `key` of `object` if the existing value is not equivalent
   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * for equality comparisons.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */
  function assignValue(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty$2.call(object, key) && eq_1(objValue, value)) ||
        (value === undefined && !(key in object))) {
      _baseAssignValue(object, key, value);
    }
  }

  var _assignValue = assignValue;

  /**
   * Copies properties of `source` to `object`.
   *
   * @private
   * @param {Object} source The object to copy properties from.
   * @param {Array} props The property identifiers to copy.
   * @param {Object} [object={}] The object to copy properties to.
   * @param {Function} [customizer] The function to customize copied values.
   * @returns {Object} Returns `object`.
   */
  function copyObject(source, props, object, customizer) {
    var isNew = !object;
    object || (object = {});

    var index = -1,
        length = props.length;

    while (++index < length) {
      var key = props[index];

      var newValue = customizer
        ? customizer(object[key], source[key], key, object, source)
        : undefined;

      if (newValue === undefined) {
        newValue = source[key];
      }
      if (isNew) {
        _baseAssignValue(object, key, newValue);
      } else {
        _assignValue(object, key, newValue);
      }
    }
    return object;
  }

  var _copyObject = copyObject;

  /**
   * This method returns the first argument it receives.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Util
   * @param {*} value Any value.
   * @returns {*} Returns `value`.
   * @example
   *
   * var object = { 'a': 1 };
   *
   * console.log(_.identity(object) === object);
   * // => true
   */
  function identity(value) {
    return value;
  }

  var identity_1 = identity;

  /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0: return func.call(thisArg);
      case 1: return func.call(thisArg, args[0]);
      case 2: return func.call(thisArg, args[0], args[1]);
      case 3: return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }

  var _apply = apply;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeMax = Math.max;

  /**
   * A specialized version of `baseRest` which transforms the rest array.
   *
   * @private
   * @param {Function} func The function to apply a rest parameter to.
   * @param {number} [start=func.length-1] The start position of the rest parameter.
   * @param {Function} transform The rest array transform.
   * @returns {Function} Returns the new function.
   */
  function overRest(func, start, transform) {
    start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
    return function() {
      var args = arguments,
          index = -1,
          length = nativeMax(args.length - start, 0),
          array = Array(length);

      while (++index < length) {
        array[index] = args[start + index];
      }
      index = -1;
      var otherArgs = Array(start + 1);
      while (++index < start) {
        otherArgs[index] = args[index];
      }
      otherArgs[start] = transform(array);
      return _apply(func, this, otherArgs);
    };
  }

  var _overRest = overRest;

  /**
   * Creates a function that returns `value`.
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Util
   * @param {*} value The value to return from the new function.
   * @returns {Function} Returns the new constant function.
   * @example
   *
   * var objects = _.times(2, _.constant({ 'a': 1 }));
   *
   * console.log(objects);
   * // => [{ 'a': 1 }, { 'a': 1 }]
   *
   * console.log(objects[0] === objects[1]);
   * // => true
   */
  function constant(value) {
    return function() {
      return value;
    };
  }

  var constant_1 = constant;

  /**
   * The base implementation of `setToString` without support for hot loop shorting.
   *
   * @private
   * @param {Function} func The function to modify.
   * @param {Function} string The `toString` result.
   * @returns {Function} Returns `func`.
   */
  var baseSetToString = !_defineProperty ? identity_1 : function(func, string) {
    return _defineProperty(func, 'toString', {
      'configurable': true,
      'enumerable': false,
      'value': constant_1(string),
      'writable': true
    });
  };

  var _baseSetToString = baseSetToString;

  /** Used to detect hot functions by number of calls within a span of milliseconds. */
  var HOT_COUNT = 800,
      HOT_SPAN = 16;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeNow = Date.now;

  /**
   * Creates a function that'll short out and invoke `identity` instead
   * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
   * milliseconds.
   *
   * @private
   * @param {Function} func The function to restrict.
   * @returns {Function} Returns the new shortable function.
   */
  function shortOut(func) {
    var count = 0,
        lastCalled = 0;

    return function() {
      var stamp = nativeNow(),
          remaining = HOT_SPAN - (stamp - lastCalled);

      lastCalled = stamp;
      if (remaining > 0) {
        if (++count >= HOT_COUNT) {
          return arguments[0];
        }
      } else {
        count = 0;
      }
      return func.apply(undefined, arguments);
    };
  }

  var _shortOut = shortOut;

  /**
   * Sets the `toString` method of `func` to return `string`.
   *
   * @private
   * @param {Function} func The function to modify.
   * @param {Function} string The `toString` result.
   * @returns {Function} Returns `func`.
   */
  var setToString = _shortOut(_baseSetToString);

  var _setToString = setToString;

  /**
   * The base implementation of `_.rest` which doesn't validate or coerce arguments.
   *
   * @private
   * @param {Function} func The function to apply a rest parameter to.
   * @param {number} [start=func.length-1] The start position of the rest parameter.
   * @returns {Function} Returns the new function.
   */
  function baseRest(func, start) {
    return _setToString(_overRest(func, start, identity_1), func + '');
  }

  var _baseRest = baseRest;

  /** Used as references for various `Number` constants. */
  var MAX_SAFE_INTEGER = 9007199254740991;

  /**
   * Checks if `value` is a valid array-like length.
   *
   * **Note:** This method is loosely based on
   * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
   * @example
   *
   * _.isLength(3);
   * // => true
   *
   * _.isLength(Number.MIN_VALUE);
   * // => false
   *
   * _.isLength(Infinity);
   * // => false
   *
   * _.isLength('3');
   * // => false
   */
  function isLength(value) {
    return typeof value == 'number' &&
      value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }

  var isLength_1 = isLength;

  /**
   * Checks if `value` is array-like. A value is considered array-like if it's
   * not a function and has a `value.length` that's an integer greater than or
   * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
   * @example
   *
   * _.isArrayLike([1, 2, 3]);
   * // => true
   *
   * _.isArrayLike(document.body.children);
   * // => true
   *
   * _.isArrayLike('abc');
   * // => true
   *
   * _.isArrayLike(_.noop);
   * // => false
   */
  function isArrayLike(value) {
    return value != null && isLength_1(value.length) && !isFunction_1(value);
  }

  var isArrayLike_1 = isArrayLike;

  /** Used as references for various `Number` constants. */
  var MAX_SAFE_INTEGER$1 = 9007199254740991;

  /** Used to detect unsigned integer values. */
  var reIsUint = /^(?:0|[1-9]\d*)$/;

  /**
   * Checks if `value` is a valid array-like index.
   *
   * @private
   * @param {*} value The value to check.
   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
   */
  function isIndex(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER$1 : length;

    return !!length &&
      (type == 'number' ||
        (type != 'symbol' && reIsUint.test(value))) &&
          (value > -1 && value % 1 == 0 && value < length);
  }

  var _isIndex = isIndex;

  /**
   * Checks if the given arguments are from an iteratee call.
   *
   * @private
   * @param {*} value The potential iteratee value argument.
   * @param {*} index The potential iteratee index or key argument.
   * @param {*} object The potential iteratee object argument.
   * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
   *  else `false`.
   */
  function isIterateeCall(value, index, object) {
    if (!isObject_1(object)) {
      return false;
    }
    var type = typeof index;
    if (type == 'number'
          ? (isArrayLike_1(object) && _isIndex(index, object.length))
          : (type == 'string' && index in object)
        ) {
      return eq_1(object[index], value);
    }
    return false;
  }

  var _isIterateeCall = isIterateeCall;

  /**
   * Creates a function like `_.assign`.
   *
   * @private
   * @param {Function} assigner The function to assign values.
   * @returns {Function} Returns the new assigner function.
   */
  function createAssigner(assigner) {
    return _baseRest(function(object, sources) {
      var index = -1,
          length = sources.length,
          customizer = length > 1 ? sources[length - 1] : undefined,
          guard = length > 2 ? sources[2] : undefined;

      customizer = (assigner.length > 3 && typeof customizer == 'function')
        ? (length--, customizer)
        : undefined;

      if (guard && _isIterateeCall(sources[0], sources[1], guard)) {
        customizer = length < 3 ? undefined : customizer;
        length = 1;
      }
      object = Object(object);
      while (++index < length) {
        var source = sources[index];
        if (source) {
          assigner(object, source, index, customizer);
        }
      }
      return object;
    });
  }

  var _createAssigner = createAssigner;

  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */
  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }

  var _baseTimes = baseTimes;

  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */
  function isObjectLike(value) {
    return value != null && typeof value == 'object';
  }

  var isObjectLike_1 = isObjectLike;

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]';

  /**
   * The base implementation of `_.isArguments`.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   */
  function baseIsArguments(value) {
    return isObjectLike_1(value) && _baseGetTag(value) == argsTag;
  }

  var _baseIsArguments = baseIsArguments;

  /** Used for built-in method references. */
  var objectProto$4 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$3 = objectProto$4.hasOwnProperty;

  /** Built-in value references. */
  var propertyIsEnumerable = objectProto$4.propertyIsEnumerable;

  /**
   * Checks if `value` is likely an `arguments` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   *  else `false`.
   * @example
   *
   * _.isArguments(function() { return arguments; }());
   * // => true
   *
   * _.isArguments([1, 2, 3]);
   * // => false
   */
  var isArguments = _baseIsArguments(function() { return arguments; }()) ? _baseIsArguments : function(value) {
    return isObjectLike_1(value) && hasOwnProperty$3.call(value, 'callee') &&
      !propertyIsEnumerable.call(value, 'callee');
  };

  var isArguments_1 = isArguments;

  /**
   * This method returns `false`.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {boolean} Returns `false`.
   * @example
   *
   * _.times(2, _.stubFalse);
   * // => [false, false]
   */
  function stubFalse() {
    return false;
  }

  var stubFalse_1 = stubFalse;

  var isBuffer_1 = createCommonjsModule(function (module, exports) {
  /** Detect free variable `exports`. */
  var freeExports = 'object' == 'object' && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /** Built-in value references. */
  var Buffer = moduleExports ? _root.Buffer : undefined;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

  /**
   * Checks if `value` is a buffer.
   *
   * @static
   * @memberOf _
   * @since 4.3.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
   * @example
   *
   * _.isBuffer(new Buffer(2));
   * // => true
   *
   * _.isBuffer(new Uint8Array(2));
   * // => false
   */
  var isBuffer = nativeIsBuffer || stubFalse_1;

  module.exports = isBuffer;
  });

  /** `Object#toString` result references. */
  var argsTag$1 = '[object Arguments]',
      arrayTag = '[object Array]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      funcTag$1 = '[object Function]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      objectTag = '[object Object]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      weakMapTag = '[object WeakMap]';

  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
  typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag$1] = typedArrayTags[arrayTag] =
  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
  typedArrayTags[errorTag] = typedArrayTags[funcTag$1] =
  typedArrayTags[mapTag] = typedArrayTags[numberTag] =
  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
  typedArrayTags[setTag] = typedArrayTags[stringTag] =
  typedArrayTags[weakMapTag] = false;

  /**
   * The base implementation of `_.isTypedArray` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   */
  function baseIsTypedArray(value) {
    return isObjectLike_1(value) &&
      isLength_1(value.length) && !!typedArrayTags[_baseGetTag(value)];
  }

  var _baseIsTypedArray = baseIsTypedArray;

  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }

  var _baseUnary = baseUnary;

  var _nodeUtil = createCommonjsModule(function (module, exports) {
  /** Detect free variable `exports`. */
  var freeExports = 'object' == 'object' && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /** Detect free variable `process` from Node.js. */
  var freeProcess = moduleExports && _freeGlobal.process;

  /** Used to access faster Node.js helpers. */
  var nodeUtil = (function() {
    try {
      return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
  }());

  module.exports = nodeUtil;
  });

  /* Node.js helper references. */
  var nodeIsTypedArray = _nodeUtil && _nodeUtil.isTypedArray;

  /**
   * Checks if `value` is classified as a typed array.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   * @example
   *
   * _.isTypedArray(new Uint8Array);
   * // => true
   *
   * _.isTypedArray([]);
   * // => false
   */
  var isTypedArray = nodeIsTypedArray ? _baseUnary(nodeIsTypedArray) : _baseIsTypedArray;

  var isTypedArray_1 = isTypedArray;

  /** Used for built-in method references. */
  var objectProto$5 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$4 = objectProto$5.hasOwnProperty;

  /**
   * Creates an array of the enumerable property names of the array-like `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @param {boolean} inherited Specify returning inherited property names.
   * @returns {Array} Returns the array of property names.
   */
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray_1(value),
        isArg = !isArr && isArguments_1(value),
        isBuff = !isArr && !isArg && isBuffer_1(value),
        isType = !isArr && !isArg && !isBuff && isTypedArray_1(value),
        skipIndexes = isArr || isArg || isBuff || isType,
        result = skipIndexes ? _baseTimes(value.length, String) : [],
        length = result.length;

    for (var key in value) {
      if ((inherited || hasOwnProperty$4.call(value, key)) &&
          !(skipIndexes && (
             // Safari 9 has enumerable `arguments.length` in strict mode.
             key == 'length' ||
             // Node.js 0.10 has enumerable non-index properties on buffers.
             (isBuff && (key == 'offset' || key == 'parent')) ||
             // PhantomJS 2 has enumerable non-index properties on typed arrays.
             (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
             // Skip index properties.
             _isIndex(key, length)
          ))) {
        result.push(key);
      }
    }
    return result;
  }

  var _arrayLikeKeys = arrayLikeKeys;

  /** Used for built-in method references. */
  var objectProto$6 = Object.prototype;

  /**
   * Checks if `value` is likely a prototype object.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
   */
  function isPrototype(value) {
    var Ctor = value && value.constructor,
        proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$6;

    return value === proto;
  }

  var _isPrototype = isPrototype;

  /**
   * This function is like
   * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * except that it includes inherited enumerable properties.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function nativeKeysIn(object) {
    var result = [];
    if (object != null) {
      for (var key in Object(object)) {
        result.push(key);
      }
    }
    return result;
  }

  var _nativeKeysIn = nativeKeysIn;

  /** Used for built-in method references. */
  var objectProto$7 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$5 = objectProto$7.hasOwnProperty;

  /**
   * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function baseKeysIn(object) {
    if (!isObject_1(object)) {
      return _nativeKeysIn(object);
    }
    var isProto = _isPrototype(object),
        result = [];

    for (var key in object) {
      if (!(key == 'constructor' && (isProto || !hasOwnProperty$5.call(object, key)))) {
        result.push(key);
      }
    }
    return result;
  }

  var _baseKeysIn = baseKeysIn;

  /**
   * Creates an array of the own and inherited enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keysIn(new Foo);
   * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
   */
  function keysIn(object) {
    return isArrayLike_1(object) ? _arrayLikeKeys(object, true) : _baseKeysIn(object);
  }

  var keysIn_1 = keysIn;

  /**
   * This method is like `_.assign` except that it iterates over own and
   * inherited source properties.
   *
   * **Note:** This method mutates `object`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @alias extend
   * @category Object
   * @param {Object} object The destination object.
   * @param {...Object} [sources] The source objects.
   * @returns {Object} Returns `object`.
   * @see _.assign
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   * }
   *
   * function Bar() {
   *   this.c = 3;
   * }
   *
   * Foo.prototype.b = 2;
   * Bar.prototype.d = 4;
   *
   * _.assignIn({ 'a': 0 }, new Foo, new Bar);
   * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
   */
  var assignIn = _createAssigner(function(object, source) {
    _copyObject(source, keysIn_1(source), object);
  });

  var assignIn_1 = assignIn;

  var extend = assignIn_1;

  /**
   * Removes all key-value entries from the list cache.
   *
   * @private
   * @name clear
   * @memberOf ListCache
   */
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }

  var _listCacheClear = listCacheClear;

  /**
   * Gets the index at which the `key` is found in `array` of key-value pairs.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} key The key to search for.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq_1(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }

  var _assocIndexOf = assocIndexOf;

  /** Used for built-in method references. */
  var arrayProto = Array.prototype;

  /** Built-in value references. */
  var splice = arrayProto.splice;

  /**
   * Removes `key` and its value from the list cache.
   *
   * @private
   * @name delete
   * @memberOf ListCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function listCacheDelete(key) {
    var data = this.__data__,
        index = _assocIndexOf(data, key);

    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    --this.size;
    return true;
  }

  var _listCacheDelete = listCacheDelete;

  /**
   * Gets the list cache value for `key`.
   *
   * @private
   * @name get
   * @memberOf ListCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function listCacheGet(key) {
    var data = this.__data__,
        index = _assocIndexOf(data, key);

    return index < 0 ? undefined : data[index][1];
  }

  var _listCacheGet = listCacheGet;

  /**
   * Checks if a list cache value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf ListCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function listCacheHas(key) {
    return _assocIndexOf(this.__data__, key) > -1;
  }

  var _listCacheHas = listCacheHas;

  /**
   * Sets the list cache `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf ListCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the list cache instance.
   */
  function listCacheSet(key, value) {
    var data = this.__data__,
        index = _assocIndexOf(data, key);

    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }

  var _listCacheSet = listCacheSet;

  /**
   * Creates an list cache object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function ListCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `ListCache`.
  ListCache.prototype.clear = _listCacheClear;
  ListCache.prototype['delete'] = _listCacheDelete;
  ListCache.prototype.get = _listCacheGet;
  ListCache.prototype.has = _listCacheHas;
  ListCache.prototype.set = _listCacheSet;

  var _ListCache = ListCache;

  /**
   * Removes all key-value entries from the stack.
   *
   * @private
   * @name clear
   * @memberOf Stack
   */
  function stackClear() {
    this.__data__ = new _ListCache;
    this.size = 0;
  }

  var _stackClear = stackClear;

  /**
   * Removes `key` and its value from the stack.
   *
   * @private
   * @name delete
   * @memberOf Stack
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function stackDelete(key) {
    var data = this.__data__,
        result = data['delete'](key);

    this.size = data.size;
    return result;
  }

  var _stackDelete = stackDelete;

  /**
   * Gets the stack value for `key`.
   *
   * @private
   * @name get
   * @memberOf Stack
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function stackGet(key) {
    return this.__data__.get(key);
  }

  var _stackGet = stackGet;

  /**
   * Checks if a stack value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Stack
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function stackHas(key) {
    return this.__data__.has(key);
  }

  var _stackHas = stackHas;

  /* Built-in method references that are verified to be native. */
  var Map$1 = _getNative(_root, 'Map');

  var _Map = Map$1;

  /* Built-in method references that are verified to be native. */
  var nativeCreate = _getNative(Object, 'create');

  var _nativeCreate = nativeCreate;

  /**
   * Removes all key-value entries from the hash.
   *
   * @private
   * @name clear
   * @memberOf Hash
   */
  function hashClear() {
    this.__data__ = _nativeCreate ? _nativeCreate(null) : {};
    this.size = 0;
  }

  var _hashClear = hashClear;

  /**
   * Removes `key` and its value from the hash.
   *
   * @private
   * @name delete
   * @memberOf Hash
   * @param {Object} hash The hash to modify.
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }

  var _hashDelete = hashDelete;

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  /** Used for built-in method references. */
  var objectProto$8 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$6 = objectProto$8.hasOwnProperty;

  /**
   * Gets the hash value for `key`.
   *
   * @private
   * @name get
   * @memberOf Hash
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function hashGet(key) {
    var data = this.__data__;
    if (_nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty$6.call(data, key) ? data[key] : undefined;
  }

  var _hashGet = hashGet;

  /** Used for built-in method references. */
  var objectProto$9 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$7 = objectProto$9.hasOwnProperty;

  /**
   * Checks if a hash value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Hash
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function hashHas(key) {
    var data = this.__data__;
    return _nativeCreate ? (data[key] !== undefined) : hasOwnProperty$7.call(data, key);
  }

  var _hashHas = hashHas;

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

  /**
   * Sets the hash `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Hash
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the hash instance.
   */
  function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = (_nativeCreate && value === undefined) ? HASH_UNDEFINED$1 : value;
    return this;
  }

  var _hashSet = hashSet;

  /**
   * Creates a hash object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Hash(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `Hash`.
  Hash.prototype.clear = _hashClear;
  Hash.prototype['delete'] = _hashDelete;
  Hash.prototype.get = _hashGet;
  Hash.prototype.has = _hashHas;
  Hash.prototype.set = _hashSet;

  var _Hash = Hash;

  /**
   * Removes all key-value entries from the map.
   *
   * @private
   * @name clear
   * @memberOf MapCache
   */
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      'hash': new _Hash,
      'map': new (_Map || _ListCache),
      'string': new _Hash
    };
  }

  var _mapCacheClear = mapCacheClear;

  /**
   * Checks if `value` is suitable for use as unique object key.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
   */
  function isKeyable(value) {
    var type = typeof value;
    return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
      ? (value !== '__proto__')
      : (value === null);
  }

  var _isKeyable = isKeyable;

  /**
   * Gets the data for `map`.
   *
   * @private
   * @param {Object} map The map to query.
   * @param {string} key The reference key.
   * @returns {*} Returns the map data.
   */
  function getMapData(map, key) {
    var data = map.__data__;
    return _isKeyable(key)
      ? data[typeof key == 'string' ? 'string' : 'hash']
      : data.map;
  }

  var _getMapData = getMapData;

  /**
   * Removes `key` and its value from the map.
   *
   * @private
   * @name delete
   * @memberOf MapCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function mapCacheDelete(key) {
    var result = _getMapData(this, key)['delete'](key);
    this.size -= result ? 1 : 0;
    return result;
  }

  var _mapCacheDelete = mapCacheDelete;

  /**
   * Gets the map value for `key`.
   *
   * @private
   * @name get
   * @memberOf MapCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function mapCacheGet(key) {
    return _getMapData(this, key).get(key);
  }

  var _mapCacheGet = mapCacheGet;

  /**
   * Checks if a map value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf MapCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function mapCacheHas(key) {
    return _getMapData(this, key).has(key);
  }

  var _mapCacheHas = mapCacheHas;

  /**
   * Sets the map `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf MapCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the map cache instance.
   */
  function mapCacheSet(key, value) {
    var data = _getMapData(this, key),
        size = data.size;

    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }

  var _mapCacheSet = mapCacheSet;

  /**
   * Creates a map cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function MapCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `MapCache`.
  MapCache.prototype.clear = _mapCacheClear;
  MapCache.prototype['delete'] = _mapCacheDelete;
  MapCache.prototype.get = _mapCacheGet;
  MapCache.prototype.has = _mapCacheHas;
  MapCache.prototype.set = _mapCacheSet;

  var _MapCache = MapCache;

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;

  /**
   * Sets the stack `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Stack
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the stack cache instance.
   */
  function stackSet(key, value) {
    var data = this.__data__;
    if (data instanceof _ListCache) {
      var pairs = data.__data__;
      if (!_Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
        pairs.push([key, value]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new _MapCache(pairs);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
  }

  var _stackSet = stackSet;

  /**
   * Creates a stack cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Stack(entries) {
    var data = this.__data__ = new _ListCache(entries);
    this.size = data.size;
  }

  // Add methods to `Stack`.
  Stack.prototype.clear = _stackClear;
  Stack.prototype['delete'] = _stackDelete;
  Stack.prototype.get = _stackGet;
  Stack.prototype.has = _stackHas;
  Stack.prototype.set = _stackSet;

  var _Stack = Stack;

  /**
   * This function is like `assignValue` except that it doesn't assign
   * `undefined` values.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */
  function assignMergeValue(object, key, value) {
    if ((value !== undefined && !eq_1(object[key], value)) ||
        (value === undefined && !(key in object))) {
      _baseAssignValue(object, key, value);
    }
  }

  var _assignMergeValue = assignMergeValue;

  /**
   * Creates a base function for methods like `_.forIn` and `_.forOwn`.
   *
   * @private
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {Function} Returns the new base function.
   */
  function createBaseFor(fromRight) {
    return function(object, iteratee, keysFunc) {
      var index = -1,
          iterable = Object(object),
          props = keysFunc(object),
          length = props.length;

      while (length--) {
        var key = props[fromRight ? length : ++index];
        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }
      return object;
    };
  }

  var _createBaseFor = createBaseFor;

  /**
   * The base implementation of `baseForOwn` which iterates over `object`
   * properties returned by `keysFunc` and invokes `iteratee` for each property.
   * Iteratee functions may exit iteration early by explicitly returning `false`.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {Function} keysFunc The function to get the keys of `object`.
   * @returns {Object} Returns `object`.
   */
  var baseFor = _createBaseFor();

  var _baseFor = baseFor;

  var _cloneBuffer = createCommonjsModule(function (module, exports) {
  /** Detect free variable `exports`. */
  var freeExports = 'object' == 'object' && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /** Built-in value references. */
  var Buffer = moduleExports ? _root.Buffer : undefined,
      allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

  /**
   * Creates a clone of  `buffer`.
   *
   * @private
   * @param {Buffer} buffer The buffer to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Buffer} Returns the cloned buffer.
   */
  function cloneBuffer(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var length = buffer.length,
        result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

    buffer.copy(result);
    return result;
  }

  module.exports = cloneBuffer;
  });

  /** Built-in value references. */
  var Uint8Array = _root.Uint8Array;

  var _Uint8Array = Uint8Array;

  /**
   * Creates a clone of `arrayBuffer`.
   *
   * @private
   * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
   * @returns {ArrayBuffer} Returns the cloned array buffer.
   */
  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new _Uint8Array(result).set(new _Uint8Array(arrayBuffer));
    return result;
  }

  var _cloneArrayBuffer = cloneArrayBuffer;

  /**
   * Creates a clone of `typedArray`.
   *
   * @private
   * @param {Object} typedArray The typed array to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the cloned typed array.
   */
  function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? _cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  }

  var _cloneTypedArray = cloneTypedArray;

  /**
   * Copies the values of `source` to `array`.
   *
   * @private
   * @param {Array} source The array to copy values from.
   * @param {Array} [array=[]] The array to copy values to.
   * @returns {Array} Returns `array`.
   */
  function copyArray(source, array) {
    var index = -1,
        length = source.length;

    array || (array = Array(length));
    while (++index < length) {
      array[index] = source[index];
    }
    return array;
  }

  var _copyArray = copyArray;

  /** Built-in value references. */
  var objectCreate = Object.create;

  /**
   * The base implementation of `_.create` without support for assigning
   * properties to the created object.
   *
   * @private
   * @param {Object} proto The object to inherit from.
   * @returns {Object} Returns the new object.
   */
  var baseCreate = (function() {
    function object() {}
    return function(proto) {
      if (!isObject_1(proto)) {
        return {};
      }
      if (objectCreate) {
        return objectCreate(proto);
      }
      object.prototype = proto;
      var result = new object;
      object.prototype = undefined;
      return result;
    };
  }());

  var _baseCreate = baseCreate;

  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }

  var _overArg = overArg;

  /** Built-in value references. */
  var getPrototype = _overArg(Object.getPrototypeOf, Object);

  var _getPrototype = getPrototype;

  /**
   * Initializes an object clone.
   *
   * @private
   * @param {Object} object The object to clone.
   * @returns {Object} Returns the initialized clone.
   */
  function initCloneObject(object) {
    return (typeof object.constructor == 'function' && !_isPrototype(object))
      ? _baseCreate(_getPrototype(object))
      : {};
  }

  var _initCloneObject = initCloneObject;

  /**
   * This method is like `_.isArrayLike` except that it also checks if `value`
   * is an object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array-like object,
   *  else `false`.
   * @example
   *
   * _.isArrayLikeObject([1, 2, 3]);
   * // => true
   *
   * _.isArrayLikeObject(document.body.children);
   * // => true
   *
   * _.isArrayLikeObject('abc');
   * // => false
   *
   * _.isArrayLikeObject(_.noop);
   * // => false
   */
  function isArrayLikeObject(value) {
    return isObjectLike_1(value) && isArrayLike_1(value);
  }

  var isArrayLikeObject_1 = isArrayLikeObject;

  /** `Object#toString` result references. */
  var objectTag$1 = '[object Object]';

  /** Used for built-in method references. */
  var funcProto$2 = Function.prototype,
      objectProto$10 = Object.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString$2 = funcProto$2.toString;

  /** Used to check objects for own properties. */
  var hasOwnProperty$8 = objectProto$10.hasOwnProperty;

  /** Used to infer the `Object` constructor. */
  var objectCtorString = funcToString$2.call(Object);

  /**
   * Checks if `value` is a plain object, that is, an object created by the
   * `Object` constructor or one with a `[[Prototype]]` of `null`.
   *
   * @static
   * @memberOf _
   * @since 0.8.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   * }
   *
   * _.isPlainObject(new Foo);
   * // => false
   *
   * _.isPlainObject([1, 2, 3]);
   * // => false
   *
   * _.isPlainObject({ 'x': 0, 'y': 0 });
   * // => true
   *
   * _.isPlainObject(Object.create(null));
   * // => true
   */
  function isPlainObject(value) {
    if (!isObjectLike_1(value) || _baseGetTag(value) != objectTag$1) {
      return false;
    }
    var proto = _getPrototype(value);
    if (proto === null) {
      return true;
    }
    var Ctor = hasOwnProperty$8.call(proto, 'constructor') && proto.constructor;
    return typeof Ctor == 'function' && Ctor instanceof Ctor &&
      funcToString$2.call(Ctor) == objectCtorString;
  }

  var isPlainObject_1 = isPlainObject;

  /**
   * Gets the value at `key`, unless `key` is "__proto__".
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function safeGet(object, key) {
    return key == '__proto__'
      ? undefined
      : object[key];
  }

  var _safeGet = safeGet;

  /**
   * Converts `value` to a plain object flattening inherited enumerable string
   * keyed properties of `value` to own properties of the plain object.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {Object} Returns the converted plain object.
   * @example
   *
   * function Foo() {
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.assign({ 'a': 1 }, new Foo);
   * // => { 'a': 1, 'b': 2 }
   *
   * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
   * // => { 'a': 1, 'b': 2, 'c': 3 }
   */
  function toPlainObject(value) {
    return _copyObject(value, keysIn_1(value));
  }

  var toPlainObject_1 = toPlainObject;

  /**
   * A specialized version of `baseMerge` for arrays and objects which performs
   * deep merges and tracks traversed objects enabling objects with circular
   * references to be merged.
   *
   * @private
   * @param {Object} object The destination object.
   * @param {Object} source The source object.
   * @param {string} key The key of the value to merge.
   * @param {number} srcIndex The index of `source`.
   * @param {Function} mergeFunc The function to merge values.
   * @param {Function} [customizer] The function to customize assigned values.
   * @param {Object} [stack] Tracks traversed source values and their merged
   *  counterparts.
   */
  function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
    var objValue = _safeGet(object, key),
        srcValue = _safeGet(source, key),
        stacked = stack.get(srcValue);

    if (stacked) {
      _assignMergeValue(object, key, stacked);
      return;
    }
    var newValue = customizer
      ? customizer(objValue, srcValue, (key + ''), object, source, stack)
      : undefined;

    var isCommon = newValue === undefined;

    if (isCommon) {
      var isArr = isArray_1(srcValue),
          isBuff = !isArr && isBuffer_1(srcValue),
          isTyped = !isArr && !isBuff && isTypedArray_1(srcValue);

      newValue = srcValue;
      if (isArr || isBuff || isTyped) {
        if (isArray_1(objValue)) {
          newValue = objValue;
        }
        else if (isArrayLikeObject_1(objValue)) {
          newValue = _copyArray(objValue);
        }
        else if (isBuff) {
          isCommon = false;
          newValue = _cloneBuffer(srcValue, true);
        }
        else if (isTyped) {
          isCommon = false;
          newValue = _cloneTypedArray(srcValue, true);
        }
        else {
          newValue = [];
        }
      }
      else if (isPlainObject_1(srcValue) || isArguments_1(srcValue)) {
        newValue = objValue;
        if (isArguments_1(objValue)) {
          newValue = toPlainObject_1(objValue);
        }
        else if (!isObject_1(objValue) || (srcIndex && isFunction_1(objValue))) {
          newValue = _initCloneObject(srcValue);
        }
      }
      else {
        isCommon = false;
      }
    }
    if (isCommon) {
      // Recursively merge objects and arrays (susceptible to call stack limits).
      stack.set(srcValue, newValue);
      mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
      stack['delete'](srcValue);
    }
    _assignMergeValue(object, key, newValue);
  }

  var _baseMergeDeep = baseMergeDeep;

  /**
   * The base implementation of `_.merge` without support for multiple sources.
   *
   * @private
   * @param {Object} object The destination object.
   * @param {Object} source The source object.
   * @param {number} srcIndex The index of `source`.
   * @param {Function} [customizer] The function to customize merged values.
   * @param {Object} [stack] Tracks traversed source values and their merged
   *  counterparts.
   */
  function baseMerge(object, source, srcIndex, customizer, stack) {
    if (object === source) {
      return;
    }
    _baseFor(source, function(srcValue, key) {
      if (isObject_1(srcValue)) {
        stack || (stack = new _Stack);
        _baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
      }
      else {
        var newValue = customizer
          ? customizer(_safeGet(object, key), srcValue, (key + ''), object, source, stack)
          : undefined;

        if (newValue === undefined) {
          newValue = srcValue;
        }
        _assignMergeValue(object, key, newValue);
      }
    }, keysIn_1);
  }

  var _baseMerge = baseMerge;

  /**
   * This method is like `_.assign` except that it recursively merges own and
   * inherited enumerable string keyed properties of source objects into the
   * destination object. Source properties that resolve to `undefined` are
   * skipped if a destination value exists. Array and plain object properties
   * are merged recursively. Other objects and value types are overridden by
   * assignment. Source objects are applied from left to right. Subsequent
   * sources overwrite property assignments of previous sources.
   *
   * **Note:** This method mutates `object`.
   *
   * @static
   * @memberOf _
   * @since 0.5.0
   * @category Object
   * @param {Object} object The destination object.
   * @param {...Object} [sources] The source objects.
   * @returns {Object} Returns `object`.
   * @example
   *
   * var object = {
   *   'a': [{ 'b': 2 }, { 'd': 4 }]
   * };
   *
   * var other = {
   *   'a': [{ 'c': 3 }, { 'e': 5 }]
   * };
   *
   * _.merge(object, other);
   * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
   */
  var merge = _createAssigner(function(object, source, srcIndex) {
    _baseMerge(object, source, srcIndex);
  });

  var merge_1 = merge;

  /**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEach(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }
    return array;
  }

  var _arrayEach = arrayEach;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeKeys = _overArg(Object.keys, Object);

  var _nativeKeys = nativeKeys;

  /** Used for built-in method references. */
  var objectProto$11 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$9 = objectProto$11.hasOwnProperty;

  /**
   * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function baseKeys(object) {
    if (!_isPrototype(object)) {
      return _nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty$9.call(object, key) && key != 'constructor') {
        result.push(key);
      }
    }
    return result;
  }

  var _baseKeys = baseKeys;

  /**
   * Creates an array of the own enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects. See the
   * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * for more details.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keys(new Foo);
   * // => ['a', 'b'] (iteration order is not guaranteed)
   *
   * _.keys('hi');
   * // => ['0', '1']
   */
  function keys(object) {
    return isArrayLike_1(object) ? _arrayLikeKeys(object) : _baseKeys(object);
  }

  var keys_1 = keys;

  /**
   * The base implementation of `_.forOwn` without support for iteratee shorthands.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Object} Returns `object`.
   */
  function baseForOwn(object, iteratee) {
    return object && _baseFor(object, iteratee, keys_1);
  }

  var _baseForOwn = baseForOwn;

  /**
   * Creates a `baseEach` or `baseEachRight` function.
   *
   * @private
   * @param {Function} eachFunc The function to iterate over a collection.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {Function} Returns the new base function.
   */
  function createBaseEach(eachFunc, fromRight) {
    return function(collection, iteratee) {
      if (collection == null) {
        return collection;
      }
      if (!isArrayLike_1(collection)) {
        return eachFunc(collection, iteratee);
      }
      var length = collection.length,
          index = fromRight ? length : -1,
          iterable = Object(collection);

      while ((fromRight ? index-- : ++index < length)) {
        if (iteratee(iterable[index], index, iterable) === false) {
          break;
        }
      }
      return collection;
    };
  }

  var _createBaseEach = createBaseEach;

  /**
   * The base implementation of `_.forEach` without support for iteratee shorthands.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array|Object} Returns `collection`.
   */
  var baseEach = _createBaseEach(_baseForOwn);

  var _baseEach = baseEach;

  /**
   * Casts `value` to `identity` if it's not a function.
   *
   * @private
   * @param {*} value The value to inspect.
   * @returns {Function} Returns cast function.
   */
  function castFunction(value) {
    return typeof value == 'function' ? value : identity_1;
  }

  var _castFunction = castFunction;

  /**
   * Iterates over elements of `collection` and invokes `iteratee` for each element.
   * The iteratee is invoked with three arguments: (value, index|key, collection).
   * Iteratee functions may exit iteration early by explicitly returning `false`.
   *
   * **Note:** As with other "Collections" methods, objects with a "length"
   * property are iterated like arrays. To avoid this behavior use `_.forIn`
   * or `_.forOwn` for object iteration.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @alias each
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} [iteratee=_.identity] The function invoked per iteration.
   * @returns {Array|Object} Returns `collection`.
   * @see _.forEachRight
   * @example
   *
   * _.forEach([1, 2], function(value) {
   *   console.log(value);
   * });
   * // => Logs `1` then `2`.
   *
   * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
   *   console.log(key);
   * });
   * // => Logs 'a' then 'b' (iteration order is not guaranteed).
   */
  function forEach(collection, iteratee) {
    var func = isArray_1(collection) ? _arrayEach : _baseEach;
    return func(collection, _castFunction(iteratee));
  }

  var forEach_1 = forEach;

  var each = forEach_1;

  function MergeClasses (Vue, options) {
    Vue.prototype.mergeClasses = function () {
      var classes = {};

      each([].slice.call(arguments), function (arg) {
        if (isObject_1(arg)) {
          extend(classes, arg);
        } else if (isArray_1(arg)) {
          merge_1(classes, arg);
        } else if (arg) {
          classes[arg] = true;
        }
      });

      return classes;
    };
  }



  var plugins = /*#__PURE__*/Object.freeze({
    MergeClasses: MergeClasses
  });

  /**
   * A specialized version of `_.reduce` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the first element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1,
        length = array == null ? 0 : array.length;

    if (initAccum && length) {
      accumulator = array[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
  }

  var _arrayReduce = arrayReduce;

  /**
   * The base implementation of `_.propertyOf` without support for deep paths.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Function} Returns the new accessor function.
   */
  function basePropertyOf(object) {
    return function(key) {
      return object == null ? undefined : object[key];
    };
  }

  var _basePropertyOf = basePropertyOf;

  /** Used to map Latin Unicode letters to basic Latin letters. */
  var deburredLetters = {
    // Latin-1 Supplement block.
    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
    '\xc7': 'C',  '\xe7': 'c',
    '\xd0': 'D',  '\xf0': 'd',
    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
    '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
    '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
    '\xd1': 'N',  '\xf1': 'n',
    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
    '\xc6': 'Ae', '\xe6': 'ae',
    '\xde': 'Th', '\xfe': 'th',
    '\xdf': 'ss',
    // Latin Extended-A block.
    '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
    '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
    '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
    '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
    '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
    '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
    '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
    '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
    '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
    '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
    '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
    '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
    '\u0134': 'J',  '\u0135': 'j',
    '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
    '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
    '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
    '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
    '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
    '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
    '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
    '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
    '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
    '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
    '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
    '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
    '\u0163': 't',  '\u0165': 't', '\u0167': 't',
    '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
    '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
    '\u0174': 'W',  '\u0175': 'w',
    '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
    '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
    '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
    '\u0132': 'IJ', '\u0133': 'ij',
    '\u0152': 'Oe', '\u0153': 'oe',
    '\u0149': "'n", '\u017f': 's'
  };

  /**
   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
   * letters to basic Latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */
  var deburrLetter = _basePropertyOf(deburredLetters);

  var _deburrLetter = deburrLetter;

  /**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function arrayMap(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length,
        result = Array(length);

    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }

  var _arrayMap = arrayMap;

  /** `Object#toString` result references. */
  var symbolTag = '[object Symbol]';

  /**
   * Checks if `value` is classified as a `Symbol` primitive or object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
   * @example
   *
   * _.isSymbol(Symbol.iterator);
   * // => true
   *
   * _.isSymbol('abc');
   * // => false
   */
  function isSymbol(value) {
    return typeof value == 'symbol' ||
      (isObjectLike_1(value) && _baseGetTag(value) == symbolTag);
  }

  var isSymbol_1 = isSymbol;

  /** Used as references for various `Number` constants. */
  var INFINITY = 1 / 0;

  /** Used to convert symbols to primitives and strings. */
  var symbolProto = _Symbol ? _Symbol.prototype : undefined,
      symbolToString = symbolProto ? symbolProto.toString : undefined;

  /**
   * The base implementation of `_.toString` which doesn't convert nullish
   * values to empty strings.
   *
   * @private
   * @param {*} value The value to process.
   * @returns {string} Returns the string.
   */
  function baseToString(value) {
    // Exit early for strings to avoid a performance hit in some environments.
    if (typeof value == 'string') {
      return value;
    }
    if (isArray_1(value)) {
      // Recursively convert values (susceptible to call stack limits).
      return _arrayMap(value, baseToString) + '';
    }
    if (isSymbol_1(value)) {
      return symbolToString ? symbolToString.call(value) : '';
    }
    var result = (value + '');
    return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
  }

  var _baseToString = baseToString;

  /**
   * Converts `value` to a string. An empty string is returned for `null`
   * and `undefined` values. The sign of `-0` is preserved.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   * @example
   *
   * _.toString(null);
   * // => ''
   *
   * _.toString(-0);
   * // => '-0'
   *
   * _.toString([1, 2, 3]);
   * // => '1,2,3'
   */
  function toString(value) {
    return value == null ? '' : _baseToString(value);
  }

  var toString_1 = toString;

  /** Used to match Latin Unicode letters (excluding mathematical operators). */
  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

  /** Used to compose unicode character classes. */
  var rsComboMarksRange = '\\u0300-\\u036f',
      reComboHalfMarksRange = '\\ufe20-\\ufe2f',
      rsComboSymbolsRange = '\\u20d0-\\u20ff',
      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;

  /** Used to compose unicode capture groups. */
  var rsCombo = '[' + rsComboRange + ']';

  /**
   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
   */
  var reComboMark = RegExp(rsCombo, 'g');

  /**
   * Deburrs `string` by converting
   * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
   * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
   * letters to basic Latin letters and removing
   * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category String
   * @param {string} [string=''] The string to deburr.
   * @returns {string} Returns the deburred string.
   * @example
   *
   * _.deburr('dj vu');
   * // => 'deja vu'
   */
  function deburr(string) {
    string = toString_1(string);
    return string && string.replace(reLatin, _deburrLetter).replace(reComboMark, '');
  }

  var deburr_1 = deburr;

  /** Used to match words composed of alphanumeric characters. */
  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

  /**
   * Splits an ASCII `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function asciiWords(string) {
    return string.match(reAsciiWord) || [];
  }

  var _asciiWords = asciiWords;

  /** Used to detect strings that need a more robust regexp to match words. */
  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

  /**
   * Checks if `string` contains a word composed of Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a word is found, else `false`.
   */
  function hasUnicodeWord(string) {
    return reHasUnicodeWord.test(string);
  }

  var _hasUnicodeWord = hasUnicodeWord;

  /** Used to compose unicode character classes. */
  var rsAstralRange = '\\ud800-\\udfff',
      rsComboMarksRange$1 = '\\u0300-\\u036f',
      reComboHalfMarksRange$1 = '\\ufe20-\\ufe2f',
      rsComboSymbolsRange$1 = '\\u20d0-\\u20ff',
      rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1,
      rsDingbatRange = '\\u2700-\\u27bf',
      rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
      rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
      rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
      rsPunctuationRange = '\\u2000-\\u206f',
      rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
      rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
      rsVarRange = '\\ufe0e\\ufe0f',
      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

  /** Used to compose unicode capture groups. */
  var rsApos = "['\u2019]",
      rsBreak = '[' + rsBreakRange + ']',
      rsCombo$1 = '[' + rsComboRange$1 + ']',
      rsDigits = '\\d+',
      rsDingbat = '[' + rsDingbatRange + ']',
      rsLower = '[' + rsLowerRange + ']',
      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
      rsFitz = '\\ud83c[\\udffb-\\udfff]',
      rsModifier = '(?:' + rsCombo$1 + '|' + rsFitz + ')',
      rsNonAstral = '[^' + rsAstralRange + ']',
      rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
      rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
      rsUpper = '[' + rsUpperRange + ']',
      rsZWJ = '\\u200d';

  /** Used to compose unicode regexes. */
  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
      rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
      rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
      rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
      reOptMod = rsModifier + '?',
      rsOptVar = '[' + rsVarRange + ']?',
      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
      rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
      rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
      rsSeq = rsOptVar + reOptMod + rsOptJoin,
      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq;

  /** Used to match complex or compound words. */
  var reUnicodeWord = RegExp([
    rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
    rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
    rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
    rsUpper + '+' + rsOptContrUpper,
    rsOrdUpper,
    rsOrdLower,
    rsDigits,
    rsEmoji
  ].join('|'), 'g');

  /**
   * Splits a Unicode `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function unicodeWords(string) {
    return string.match(reUnicodeWord) || [];
  }

  var _unicodeWords = unicodeWords;

  /**
   * Splits `string` into an array of its words.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category String
   * @param {string} [string=''] The string to inspect.
   * @param {RegExp|string} [pattern] The pattern to match words.
   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
   * @returns {Array} Returns the words of `string`.
   * @example
   *
   * _.words('fred, barney, & pebbles');
   * // => ['fred', 'barney', 'pebbles']
   *
   * _.words('fred, barney, & pebbles', /[^, ]+/g);
   * // => ['fred', 'barney', '&', 'pebbles']
   */
  function words(string, pattern, guard) {
    string = toString_1(string);
    pattern = guard ? undefined : pattern;

    if (pattern === undefined) {
      return _hasUnicodeWord(string) ? _unicodeWords(string) : _asciiWords(string);
    }
    return string.match(pattern) || [];
  }

  var words_1 = words;

  /** Used to compose unicode capture groups. */
  var rsApos$1 = "['\u2019]";

  /** Used to match apostrophes. */
  var reApos = RegExp(rsApos$1, 'g');

  /**
   * Creates a function like `_.camelCase`.
   *
   * @private
   * @param {Function} callback The function to combine each word.
   * @returns {Function} Returns the new compounder function.
   */
  function createCompounder(callback) {
    return function(string) {
      return _arrayReduce(words_1(deburr_1(string).replace(reApos, '')), callback, '');
    };
  }

  var _createCompounder = createCompounder;

  /**
   * Converts `string` to
   * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category String
   * @param {string} [string=''] The string to convert.
   * @returns {string} Returns the kebab cased string.
   * @example
   *
   * _.kebabCase('Foo Bar');
   * // => 'foo-bar'
   *
   * _.kebabCase('fooBar');
   * // => 'foo-bar'
   *
   * _.kebabCase('__FOO_BAR__');
   * // => 'foo-bar'
   */
  var kebabCase = _createCompounder(function(result, word, index) {
    return result + (index ? '-' : '') + word.toLowerCase();
  });

  var kebabCase_1 = kebabCase;

  var BaseType = {
    render: function render() {
      var _vm = this;

      var _h = _vm.$createElement;

      var _c = _vm._self._c || _h;

      return _c('div', {
        staticClass: "activity-indicator",
        class: _vm.classes
      }, _vm._l(_vm.nodes, function (i) {
        return _c('div');
      }));
    },
    staticRenderFns: [],
    props: {
      nodes: {
        type: Number,
        default: 3
      },
      size: {
        type: String,
        default: ''
      },
      prefix: {
        type: String,
        default: 'activity-indicator-'
      }
    },
    computed: {
      classes: function classes() {
        var classes = {};
        classes[this.$options.name] = !!this.$options.name;
        classes[this.prefix + this.size.replace(this.prefix, '')] = !!this.size;
        return classes;
      }
    }
  };

  var ActivityIndicatorDots = {
    name: 'activity-indicator-dots',
    extends: BaseType
  };

  var ActivityIndicatorSpinner = {
    name: 'activity-indicator-spinner',
    extends: BaseType,
    props: extend({}, BaseType.props, {
      nodes: {
        type: Number,
        default: 12
      }
    })
  };

  var ActivityIndicator = {
    render: function render() {
      var _vm = this;

      var _h = _vm.$createElement;

      var _c = _vm._self._c || _h;

      return _vm.center ? _c('div', {
        staticClass: "center-wrapper"
      }, [_c('div', {
        staticClass: "center-content"
      }, [_c(_vm.component, {
        tag: "component",
        attrs: {
          "size": _vm.size,
          "prefix": _vm.prefix
        }
      })], 1)]) : _c(_vm.component, {
        tag: "component",
        attrs: {
          "size": _vm.size,
          "prefix": _vm.prefix
        }
      });
    },
    staticRenderFns: [],
    name: 'activity-indicator',
    extends: BaseType,
    props: {
      center: {
        type: Boolean,
        default: false
      },
      type: {
        type: String,
        default: 'dots'
      }
    },
    components: {
      ActivityIndicatorDots: ActivityIndicatorDots,
      ActivityIndicatorSpinner: ActivityIndicatorSpinner
    },
    computed: {
      component: function component() {
        return kebabCase_1(this.prefix + this.type.replace(this.prefix, ''));
      }
    }
  };

  var VueInstaller = {
    use: use,
    plugin: plugin,
    plugins: plugins$1,
    component: component,
    components: components,
    directive: directive,
    directives: directives,
    $plugins: {},
    $directives: {},
    $components: {}
  };
  function use(plugin) {
    if (typeof window !== 'undefined' && window.Vue) {
      window.Vue.use(plugin);
    }

    return plugin;
  }
  function plugin(Vue, name, def) {
    if (!VueInstaller.$plugins[name]) {
      Vue.use(VueInstaller.$plugins[name] = def);
    }
  }
  function plugins$1(Vue, plugins) {
    each(plugins, function (def, name) {
      plugin(Vue, name, def);
    });
  }
  function component(Vue, name, def) {
    if (!VueInstaller.$components[name]) {
      Vue.component(name, VueInstaller.$components[name] = def);
    }
  }
  function components(Vue, components) {
    each(components, function (def, name) {
      component(Vue, name, def);
    });
  }
  function directive(Vue, name, def) {
    if (!VueInstaller.$directives[name]) {
      Vue.directive(name, VueInstaller.$directives[name] = def);
    }
  }
  function directives(Vue, directives) {
    each(directives, function (def, name) {
      directive(Vue, name, def);
    });
  }

  var plugin$1 = VueInstaller.use({
    install: function install(Vue, options) {
      VueInstaller.components({
        ActivityIndicator: ActivityIndicator
      });
    }
  });

  var convertAnimationDelayToInt = function convertAnimationDelayToInt(delay) {
    var num = parseFloat(delay, 10);
    var matches = delay.match(/m?s/);
    var unit = matches ? matches[0] : false;
    var milliseconds;

    switch (unit) {
      case "s":
        // seconds
        milliseconds = num * 1000;
        break;

      case "ms":
      default:
        milliseconds = num;
        break;
    }

    return milliseconds || 0;
  };

  var animated = function animated(el, callback) {
    var defaultView = (el.ownerDocument || document).defaultView;
    setTimeout(function () {
      callback.apply();
    }, convertAnimationDelayToInt(defaultView.getComputedStyle(el).animationDuration));
  };

  var ActivityButton = {
    render: function render() {
      var _vm = this;

      var _h = _vm.$createElement;

      var _c = _vm._self._c || _h;

      return _c('button', {
        staticClass: "btn",
        class: _vm.classes,
        attrs: {
          "type": _vm.type
        },
        on: {
          "click": _vm.onClick
        }
      }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))]), _vm._v(" "), _c('activity-indicator', {
        attrs: {
          "type": _vm.indicator
        }
      })], 2);
    },
    staticRenderFns: [],
    name: 'activity-button',
    components: {
      ActivityIndicator: ActivityIndicator
    },
    props: {
      /**
       * Should show the activity indicator inside the button.
       *
       * @property Boolean
       */
      activity: {
        type: Boolean,
        default: false
      },

      /**
       * Should show the button as disabled.
       *
       * @property Boolean
       */
      disabled: {
        type: Boolean,
        default: false
      },

      /**
       * Display the button as block width.
       *
       * @property Boolean
       */
      block: {
        type: Boolean,
        default: false
      },

      /**
       * The size of the button.
       *
       * @property String
       */
      size: {
        type: String,
        default: 'md'
      },

      /**
       * The bootstrap variant of the button.
       *
       * @property String
       */
      variant: {
        type: String,
        default: 'primary'
      },

      /**
       * The `type` attribute for the button.
       *
       * @property String
       */
      type: {
        type: String,
        default: 'button'
      },

      /**
       * The type of activity indicator inside the button.
       *
       * @property String
       */
      indicator: {
        type: String,
        default: 'spinner'
      },

      /**
       * The orientation of the activity button inside the button.
       *
       * @property String
       */
      orientation: {
        type: String,
        default: 'right'
      },

      /**
       * The button label. If not passed as a property, label must be passed
       * inside the element's html.
       *
       * @property String
       */
      label: {
        type: String
      }
    },
    methods: {
      /**
       * Disable the button.
       *
       * @return void
       */
      disable: function disable() {
        this.$el.disabled = true;
      },

      /**
       * Enable the button.
       *
       * @return void
       */
      enable: function enable() {
        this.$el.disabled = false;
      },

      /**
       * Show the activity indicator inside the button.
       *
       * @return void
       */
      showActivity: function showActivity() {
        var _this = this;

        this.disable();
        animated(this.$el, function () {
          _this.$el.classList.add('btn-activity');

          _this.$emit('activity:show');
        });
      },

      /**
       * Hide the activity indicator inside the button.
       *
       * @return void
       */
      hideActivity: function hideActivity() {
        var _this2 = this;

        this.$el.classList.add('btn-hide-activity');
        animated(this.$el, function () {
          _this2.enable();

          _this2.$el.classList.remove('btn-activity', 'btn-hide-activity');

          _this2.$emit('activity:hide');
        });
      },

      /**
       * Disable the button.
       *
       * @return void
       */
      onClick: function onClick(event) {
        this.$emit('click', event, this);
      }
    },
    computed: {
      /**
       * An object of classes to append to the button.
       *
       * @return void
       */
      classes: function classes() {
        var classes = {
          'btn-block': this.block,
          'btn-activity': this.activity
        };
        classes['btn-' + this.size.replace('btn-', '')] = !!this.size;
        classes['btn-' + this.variant.replace('btn-', '')] = !!this.variant;
        classes['btn-activity-' + this.orientation.replace('btn-activity-', '')] = !!this.orientation;
        classes['btn-activity-indicator-' + this.indicator.replace('btn-activity-indicator-', '')] = !!this.indicator;
        return classes;
      }
    },
    watch: {
      activity: function activity(value) {
        if (value) {
          this.showActivity();
        } else {
          this.hideActivity();
        }
      }
    }
  };

  var plugin$2 = VueInstaller.use({
    install: function install(Vue, options) {
      VueInstaller.components({
        ActivityButton: ActivityButton
      });
    }
  });

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

  /**
   * Adds `value` to the array cache.
   *
   * @private
   * @name add
   * @memberOf SetCache
   * @alias push
   * @param {*} value The value to cache.
   * @returns {Object} Returns the cache instance.
   */
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED$2);
    return this;
  }

  var _setCacheAdd = setCacheAdd;

  /**
   * Checks if `value` is in the array cache.
   *
   * @private
   * @name has
   * @memberOf SetCache
   * @param {*} value The value to search for.
   * @returns {number} Returns `true` if `value` is found, else `false`.
   */
  function setCacheHas(value) {
    return this.__data__.has(value);
  }

  var _setCacheHas = setCacheHas;

  /**
   *
   * Creates an array cache object to store unique values.
   *
   * @private
   * @constructor
   * @param {Array} [values] The values to cache.
   */
  function SetCache(values) {
    var index = -1,
        length = values == null ? 0 : values.length;

    this.__data__ = new _MapCache;
    while (++index < length) {
      this.add(values[index]);
    }
  }

  // Add methods to `SetCache`.
  SetCache.prototype.add = SetCache.prototype.push = _setCacheAdd;
  SetCache.prototype.has = _setCacheHas;

  var _SetCache = SetCache;

  /**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */
  function arraySome(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }

  var _arraySome = arraySome;

  /**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function cacheHas(cache, key) {
    return cache.has(key);
  }

  var _cacheHas = cacheHas;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG = 1,
      COMPARE_UNORDERED_FLAG = 2;

  /**
   * A specialized version of `baseIsEqualDeep` for arrays with support for
   * partial deep comparisons.
   *
   * @private
   * @param {Array} array The array to compare.
   * @param {Array} other The other array to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `array` and `other` objects.
   * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
   */
  function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
        arrLength = array.length,
        othLength = other.length;

    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }
    // Assume cyclic values are equal.
    var stacked = stack.get(array);
    if (stacked && stack.get(other)) {
      return stacked == other;
    }
    var index = -1,
        result = true,
        seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new _SetCache : undefined;

    stack.set(array, other);
    stack.set(other, array);

    // Ignore non-index properties.
    while (++index < arrLength) {
      var arrValue = array[index],
          othValue = other[index];

      if (customizer) {
        var compared = isPartial
          ? customizer(othValue, arrValue, index, other, array, stack)
          : customizer(arrValue, othValue, index, array, other, stack);
      }
      if (compared !== undefined) {
        if (compared) {
          continue;
        }
        result = false;
        break;
      }
      // Recursively compare arrays (susceptible to call stack limits).
      if (seen) {
        if (!_arraySome(other, function(othValue, othIndex) {
              if (!_cacheHas(seen, othIndex) &&
                  (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
          result = false;
          break;
        }
      } else if (!(
            arrValue === othValue ||
              equalFunc(arrValue, othValue, bitmask, customizer, stack)
          )) {
        result = false;
        break;
      }
    }
    stack['delete'](array);
    stack['delete'](other);
    return result;
  }

  var _equalArrays = equalArrays;

  /**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */
  function mapToArray(map) {
    var index = -1,
        result = Array(map.size);

    map.forEach(function(value, key) {
      result[++index] = [key, value];
    });
    return result;
  }

  var _mapToArray = mapToArray;

  /**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */
  function setToArray(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }

  var _setToArray = setToArray;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG$1 = 1,
      COMPARE_UNORDERED_FLAG$1 = 2;

  /** `Object#toString` result references. */
  var boolTag$1 = '[object Boolean]',
      dateTag$1 = '[object Date]',
      errorTag$1 = '[object Error]',
      mapTag$1 = '[object Map]',
      numberTag$1 = '[object Number]',
      regexpTag$1 = '[object RegExp]',
      setTag$1 = '[object Set]',
      stringTag$1 = '[object String]',
      symbolTag$1 = '[object Symbol]';

  var arrayBufferTag$1 = '[object ArrayBuffer]',
      dataViewTag$1 = '[object DataView]';

  /** Used to convert symbols to primitives and strings. */
  var symbolProto$1 = _Symbol ? _Symbol.prototype : undefined,
      symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : undefined;

  /**
   * A specialized version of `baseIsEqualDeep` for comparing objects of
   * the same `toStringTag`.
   *
   * **Note:** This function only supports comparing values with tags of
   * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {string} tag The `toStringTag` of the objects to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */
  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
    switch (tag) {
      case dataViewTag$1:
        if ((object.byteLength != other.byteLength) ||
            (object.byteOffset != other.byteOffset)) {
          return false;
        }
        object = object.buffer;
        other = other.buffer;

      case arrayBufferTag$1:
        if ((object.byteLength != other.byteLength) ||
            !equalFunc(new _Uint8Array(object), new _Uint8Array(other))) {
          return false;
        }
        return true;

      case boolTag$1:
      case dateTag$1:
      case numberTag$1:
        // Coerce booleans to `1` or `0` and dates to milliseconds.
        // Invalid dates are coerced to `NaN`.
        return eq_1(+object, +other);

      case errorTag$1:
        return object.name == other.name && object.message == other.message;

      case regexpTag$1:
      case stringTag$1:
        // Coerce regexes to strings and treat strings, primitives and objects,
        // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
        // for more details.
        return object == (other + '');

      case mapTag$1:
        var convert = _mapToArray;

      case setTag$1:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1;
        convert || (convert = _setToArray);

        if (object.size != other.size && !isPartial) {
          return false;
        }
        // Assume cyclic values are equal.
        var stacked = stack.get(object);
        if (stacked) {
          return stacked == other;
        }
        bitmask |= COMPARE_UNORDERED_FLAG$1;

        // Recursively compare objects (susceptible to call stack limits).
        stack.set(object, other);
        var result = _equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
        stack['delete'](object);
        return result;

      case symbolTag$1:
        if (symbolValueOf) {
          return symbolValueOf.call(object) == symbolValueOf.call(other);
        }
    }
    return false;
  }

  var _equalByTag = equalByTag;

  /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */
  function arrayPush(array, values) {
    var index = -1,
        length = values.length,
        offset = array.length;

    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }

  var _arrayPush = arrayPush;

  /**
   * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
   * `keysFunc` and `symbolsFunc` to get the enumerable property names and
   * symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Function} keysFunc The function to get the keys of `object`.
   * @param {Function} symbolsFunc The function to get the symbols of `object`.
   * @returns {Array} Returns the array of property names and symbols.
   */
  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray_1(object) ? result : _arrayPush(result, symbolsFunc(object));
  }

  var _baseGetAllKeys = baseGetAllKeys;

  /**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */
  function arrayFilter(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }

  var _arrayFilter = arrayFilter;

  /**
   * This method returns a new empty array.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {Array} Returns the new empty array.
   * @example
   *
   * var arrays = _.times(2, _.stubArray);
   *
   * console.log(arrays);
   * // => [[], []]
   *
   * console.log(arrays[0] === arrays[1]);
   * // => false
   */
  function stubArray() {
    return [];
  }

  var stubArray_1 = stubArray;

  /** Used for built-in method references. */
  var objectProto$12 = Object.prototype;

  /** Built-in value references. */
  var propertyIsEnumerable$1 = objectProto$12.propertyIsEnumerable;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeGetSymbols = Object.getOwnPropertySymbols;

  /**
   * Creates an array of the own enumerable symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of symbols.
   */
  var getSymbols = !nativeGetSymbols ? stubArray_1 : function(object) {
    if (object == null) {
      return [];
    }
    object = Object(object);
    return _arrayFilter(nativeGetSymbols(object), function(symbol) {
      return propertyIsEnumerable$1.call(object, symbol);
    });
  };

  var _getSymbols = getSymbols;

  /**
   * Creates an array of own enumerable property names and symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names and symbols.
   */
  function getAllKeys(object) {
    return _baseGetAllKeys(object, keys_1, _getSymbols);
  }

  var _getAllKeys = getAllKeys;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG$2 = 1;

  /** Used for built-in method references. */
  var objectProto$13 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$10 = objectProto$13.hasOwnProperty;

  /**
   * A specialized version of `baseIsEqualDeep` for objects with support for
   * partial deep comparisons.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */
  function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2,
        objProps = _getAllKeys(object),
        objLength = objProps.length,
        othProps = _getAllKeys(other),
        othLength = othProps.length;

    if (objLength != othLength && !isPartial) {
      return false;
    }
    var index = objLength;
    while (index--) {
      var key = objProps[index];
      if (!(isPartial ? key in other : hasOwnProperty$10.call(other, key))) {
        return false;
      }
    }
    // Assume cyclic values are equal.
    var stacked = stack.get(object);
    if (stacked && stack.get(other)) {
      return stacked == other;
    }
    var result = true;
    stack.set(object, other);
    stack.set(other, object);

    var skipCtor = isPartial;
    while (++index < objLength) {
      key = objProps[index];
      var objValue = object[key],
          othValue = other[key];

      if (customizer) {
        var compared = isPartial
          ? customizer(othValue, objValue, key, other, object, stack)
          : customizer(objValue, othValue, key, object, other, stack);
      }
      // Recursively compare objects (susceptible to call stack limits).
      if (!(compared === undefined
            ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
            : compared
          )) {
        result = false;
        break;
      }
      skipCtor || (skipCtor = key == 'constructor');
    }
    if (result && !skipCtor) {
      var objCtor = object.constructor,
          othCtor = other.constructor;

      // Non `Object` object instances with different constructors are not equal.
      if (objCtor != othCtor &&
          ('constructor' in object && 'constructor' in other) &&
          !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
            typeof othCtor == 'function' && othCtor instanceof othCtor)) {
        result = false;
      }
    }
    stack['delete'](object);
    stack['delete'](other);
    return result;
  }

  var _equalObjects = equalObjects;

  /* Built-in method references that are verified to be native. */
  var DataView = _getNative(_root, 'DataView');

  var _DataView = DataView;

  /* Built-in method references that are verified to be native. */
  var Promise$1 = _getNative(_root, 'Promise');

  var _Promise = Promise$1;

  /* Built-in method references that are verified to be native. */
  var Set = _getNative(_root, 'Set');

  var _Set = Set;

  /* Built-in method references that are verified to be native. */
  var WeakMap = _getNative(_root, 'WeakMap');

  var _WeakMap = WeakMap;

  /** `Object#toString` result references. */
  var mapTag$2 = '[object Map]',
      objectTag$2 = '[object Object]',
      promiseTag = '[object Promise]',
      setTag$2 = '[object Set]',
      weakMapTag$1 = '[object WeakMap]';

  var dataViewTag$2 = '[object DataView]';

  /** Used to detect maps, sets, and weakmaps. */
  var dataViewCtorString = _toSource(_DataView),
      mapCtorString = _toSource(_Map),
      promiseCtorString = _toSource(_Promise),
      setCtorString = _toSource(_Set),
      weakMapCtorString = _toSource(_WeakMap);

  /**
   * Gets the `toStringTag` of `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  var getTag = _baseGetTag;

  // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
  if ((_DataView && getTag(new _DataView(new ArrayBuffer(1))) != dataViewTag$2) ||
      (_Map && getTag(new _Map) != mapTag$2) ||
      (_Promise && getTag(_Promise.resolve()) != promiseTag) ||
      (_Set && getTag(new _Set) != setTag$2) ||
      (_WeakMap && getTag(new _WeakMap) != weakMapTag$1)) {
    getTag = function(value) {
      var result = _baseGetTag(value),
          Ctor = result == objectTag$2 ? value.constructor : undefined,
          ctorString = Ctor ? _toSource(Ctor) : '';

      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString: return dataViewTag$2;
          case mapCtorString: return mapTag$2;
          case promiseCtorString: return promiseTag;
          case setCtorString: return setTag$2;
          case weakMapCtorString: return weakMapTag$1;
        }
      }
      return result;
    };
  }

  var _getTag = getTag;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG$3 = 1;

  /** `Object#toString` result references. */
  var argsTag$2 = '[object Arguments]',
      arrayTag$1 = '[object Array]',
      objectTag$3 = '[object Object]';

  /** Used for built-in method references. */
  var objectProto$14 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$11 = objectProto$14.hasOwnProperty;

  /**
   * A specialized version of `baseIsEqual` for arrays and objects which performs
   * deep comparisons and tracks traversed objects enabling objects with circular
   * references to be compared.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} [stack] Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */
  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray_1(object),
        othIsArr = isArray_1(other),
        objTag = objIsArr ? arrayTag$1 : _getTag(object),
        othTag = othIsArr ? arrayTag$1 : _getTag(other);

    objTag = objTag == argsTag$2 ? objectTag$3 : objTag;
    othTag = othTag == argsTag$2 ? objectTag$3 : othTag;

    var objIsObj = objTag == objectTag$3,
        othIsObj = othTag == objectTag$3,
        isSameTag = objTag == othTag;

    if (isSameTag && isBuffer_1(object)) {
      if (!isBuffer_1(other)) {
        return false;
      }
      objIsArr = true;
      objIsObj = false;
    }
    if (isSameTag && !objIsObj) {
      stack || (stack = new _Stack);
      return (objIsArr || isTypedArray_1(object))
        ? _equalArrays(object, other, bitmask, customizer, equalFunc, stack)
        : _equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG$3)) {
      var objIsWrapped = objIsObj && hasOwnProperty$11.call(object, '__wrapped__'),
          othIsWrapped = othIsObj && hasOwnProperty$11.call(other, '__wrapped__');

      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object,
            othUnwrapped = othIsWrapped ? other.value() : other;

        stack || (stack = new _Stack);
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
      }
    }
    if (!isSameTag) {
      return false;
    }
    stack || (stack = new _Stack);
    return _equalObjects(object, other, bitmask, customizer, equalFunc, stack);
  }

  var _baseIsEqualDeep = baseIsEqualDeep;

  /**
   * The base implementation of `_.isEqual` which supports partial comparisons
   * and tracks traversed objects.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @param {boolean} bitmask The bitmask flags.
   *  1 - Unordered comparison
   *  2 - Partial comparison
   * @param {Function} [customizer] The function to customize comparisons.
   * @param {Object} [stack] Tracks traversed `value` and `other` objects.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   */
  function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || (!isObjectLike_1(value) && !isObjectLike_1(other))) {
      return value !== value && other !== other;
    }
    return _baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
  }

  var _baseIsEqual = baseIsEqual;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG$4 = 1,
      COMPARE_UNORDERED_FLAG$2 = 2;

  /**
   * The base implementation of `_.isMatch` without support for iteratee shorthands.
   *
   * @private
   * @param {Object} object The object to inspect.
   * @param {Object} source The object of property values to match.
   * @param {Array} matchData The property names, values, and compare flags to match.
   * @param {Function} [customizer] The function to customize comparisons.
   * @returns {boolean} Returns `true` if `object` is a match, else `false`.
   */
  function baseIsMatch(object, source, matchData, customizer) {
    var index = matchData.length,
        length = index,
        noCustomizer = !customizer;

    if (object == null) {
      return !length;
    }
    object = Object(object);
    while (index--) {
      var data = matchData[index];
      if ((noCustomizer && data[2])
            ? data[1] !== object[data[0]]
            : !(data[0] in object)
          ) {
        return false;
      }
    }
    while (++index < length) {
      data = matchData[index];
      var key = data[0],
          objValue = object[key],
          srcValue = data[1];

      if (noCustomizer && data[2]) {
        if (objValue === undefined && !(key in object)) {
          return false;
        }
      } else {
        var stack = new _Stack;
        if (customizer) {
          var result = customizer(objValue, srcValue, key, object, source, stack);
        }
        if (!(result === undefined
              ? _baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$4 | COMPARE_UNORDERED_FLAG$2, customizer, stack)
              : result
            )) {
          return false;
        }
      }
    }
    return true;
  }

  var _baseIsMatch = baseIsMatch;

  /**
   * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` if suitable for strict
   *  equality comparisons, else `false`.
   */
  function isStrictComparable(value) {
    return value === value && !isObject_1(value);
  }

  var _isStrictComparable = isStrictComparable;

  /**
   * Gets the property names, values, and compare flags of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the match data of `object`.
   */
  function getMatchData(object) {
    var result = keys_1(object),
        length = result.length;

    while (length--) {
      var key = result[length],
          value = object[key];

      result[length] = [key, value, _isStrictComparable(value)];
    }
    return result;
  }

  var _getMatchData = getMatchData;

  /**
   * A specialized version of `matchesProperty` for source values suitable
   * for strict equality comparisons, i.e. `===`.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @param {*} srcValue The value to match.
   * @returns {Function} Returns the new spec function.
   */
  function matchesStrictComparable(key, srcValue) {
    return function(object) {
      if (object == null) {
        return false;
      }
      return object[key] === srcValue &&
        (srcValue !== undefined || (key in Object(object)));
    };
  }

  var _matchesStrictComparable = matchesStrictComparable;

  /**
   * The base implementation of `_.matches` which doesn't clone `source`.
   *
   * @private
   * @param {Object} source The object of property values to match.
   * @returns {Function} Returns the new spec function.
   */
  function baseMatches(source) {
    var matchData = _getMatchData(source);
    if (matchData.length == 1 && matchData[0][2]) {
      return _matchesStrictComparable(matchData[0][0], matchData[0][1]);
    }
    return function(object) {
      return object === source || _baseIsMatch(object, source, matchData);
    };
  }

  var _baseMatches = baseMatches;

  /** Used to match property names within property paths. */
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/;

  /**
   * Checks if `value` is a property name and not a property path.
   *
   * @private
   * @param {*} value The value to check.
   * @param {Object} [object] The object to query keys on.
   * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
   */
  function isKey(value, object) {
    if (isArray_1(value)) {
      return false;
    }
    var type = typeof value;
    if (type == 'number' || type == 'symbol' || type == 'boolean' ||
        value == null || isSymbol_1(value)) {
      return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
      (object != null && value in Object(object));
  }

  var _isKey = isKey;

  /** Error message constants. */
  var FUNC_ERROR_TEXT = 'Expected a function';

  /**
   * Creates a function that memoizes the result of `func`. If `resolver` is
   * provided, it determines the cache key for storing the result based on the
   * arguments provided to the memoized function. By default, the first argument
   * provided to the memoized function is used as the map cache key. The `func`
   * is invoked with the `this` binding of the memoized function.
   *
   * **Note:** The cache is exposed as the `cache` property on the memoized
   * function. Its creation may be customized by replacing the `_.memoize.Cache`
   * constructor with one whose instances implement the
   * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
   * method interface of `clear`, `delete`, `get`, `has`, and `set`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to have its output memoized.
   * @param {Function} [resolver] The function to resolve the cache key.
   * @returns {Function} Returns the new memoized function.
   * @example
   *
   * var object = { 'a': 1, 'b': 2 };
   * var other = { 'c': 3, 'd': 4 };
   *
   * var values = _.memoize(_.values);
   * values(object);
   * // => [1, 2]
   *
   * values(other);
   * // => [3, 4]
   *
   * object.a = 2;
   * values(object);
   * // => [1, 2]
   *
   * // Modify the result cache.
   * values.cache.set(object, ['a', 'b']);
   * values(object);
   * // => ['a', 'b']
   *
   * // Replace `_.memoize.Cache`.
   * _.memoize.Cache = WeakMap;
   */
  function memoize(func, resolver) {
    if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    var memoized = function() {
      var args = arguments,
          key = resolver ? resolver.apply(this, args) : args[0],
          cache = memoized.cache;

      if (cache.has(key)) {
        return cache.get(key);
      }
      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result) || cache;
      return result;
    };
    memoized.cache = new (memoize.Cache || _MapCache);
    return memoized;
  }

  // Expose `MapCache`.
  memoize.Cache = _MapCache;

  var memoize_1 = memoize;

  /** Used as the maximum memoize cache size. */
  var MAX_MEMOIZE_SIZE = 500;

  /**
   * A specialized version of `_.memoize` which clears the memoized function's
   * cache when it exceeds `MAX_MEMOIZE_SIZE`.
   *
   * @private
   * @param {Function} func The function to have its output memoized.
   * @returns {Function} Returns the new memoized function.
   */
  function memoizeCapped(func) {
    var result = memoize_1(func, function(key) {
      if (cache.size === MAX_MEMOIZE_SIZE) {
        cache.clear();
      }
      return key;
    });

    var cache = result.cache;
    return result;
  }

  var _memoizeCapped = memoizeCapped;

  /** Used to match property names within property paths. */
  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

  /** Used to match backslashes in property paths. */
  var reEscapeChar = /\\(\\)?/g;

  /**
   * Converts `string` to a property path array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the property path array.
   */
  var stringToPath = _memoizeCapped(function(string) {
    var result = [];
    if (string.charCodeAt(0) === 46 /* . */) {
      result.push('');
    }
    string.replace(rePropName, function(match, number, quote, subString) {
      result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
    });
    return result;
  });

  var _stringToPath = stringToPath;

  /**
   * Casts `value` to a path array if it's not one.
   *
   * @private
   * @param {*} value The value to inspect.
   * @param {Object} [object] The object to query keys on.
   * @returns {Array} Returns the cast property path array.
   */
  function castPath(value, object) {
    if (isArray_1(value)) {
      return value;
    }
    return _isKey(value, object) ? [value] : _stringToPath(toString_1(value));
  }

  var _castPath = castPath;

  /** Used as references for various `Number` constants. */
  var INFINITY$1 = 1 / 0;

  /**
   * Converts `value` to a string key if it's not a string or symbol.
   *
   * @private
   * @param {*} value The value to inspect.
   * @returns {string|symbol} Returns the key.
   */
  function toKey(value) {
    if (typeof value == 'string' || isSymbol_1(value)) {
      return value;
    }
    var result = (value + '');
    return (result == '0' && (1 / value) == -INFINITY$1) ? '-0' : result;
  }

  var _toKey = toKey;

  /**
   * The base implementation of `_.get` without support for default values.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array|string} path The path of the property to get.
   * @returns {*} Returns the resolved value.
   */
  function baseGet(object, path) {
    path = _castPath(path, object);

    var index = 0,
        length = path.length;

    while (object != null && index < length) {
      object = object[_toKey(path[index++])];
    }
    return (index && index == length) ? object : undefined;
  }

  var _baseGet = baseGet;

  /**
   * Gets the value at `path` of `object`. If the resolved value is
   * `undefined`, the `defaultValue` is returned in its place.
   *
   * @static
   * @memberOf _
   * @since 3.7.0
   * @category Object
   * @param {Object} object The object to query.
   * @param {Array|string} path The path of the property to get.
   * @param {*} [defaultValue] The value returned for `undefined` resolved values.
   * @returns {*} Returns the resolved value.
   * @example
   *
   * var object = { 'a': [{ 'b': { 'c': 3 } }] };
   *
   * _.get(object, 'a[0].b.c');
   * // => 3
   *
   * _.get(object, ['a', '0', 'b', 'c']);
   * // => 3
   *
   * _.get(object, 'a.b.c', 'default');
   * // => 'default'
   */
  function get(object, path, defaultValue) {
    var result = object == null ? undefined : _baseGet(object, path);
    return result === undefined ? defaultValue : result;
  }

  var get_1 = get;

  /**
   * The base implementation of `_.hasIn` without support for deep paths.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {Array|string} key The key to check.
   * @returns {boolean} Returns `true` if `key` exists, else `false`.
   */
  function baseHasIn(object, key) {
    return object != null && key in Object(object);
  }

  var _baseHasIn = baseHasIn;

  /**
   * Checks if `path` exists on `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array|string} path The path to check.
   * @param {Function} hasFunc The function to check properties.
   * @returns {boolean} Returns `true` if `path` exists, else `false`.
   */
  function hasPath(object, path, hasFunc) {
    path = _castPath(path, object);

    var index = -1,
        length = path.length,
        result = false;

    while (++index < length) {
      var key = _toKey(path[index]);
      if (!(result = object != null && hasFunc(object, key))) {
        break;
      }
      object = object[key];
    }
    if (result || ++index != length) {
      return result;
    }
    length = object == null ? 0 : object.length;
    return !!length && isLength_1(length) && _isIndex(key, length) &&
      (isArray_1(object) || isArguments_1(object));
  }

  var _hasPath = hasPath;

  /**
   * Checks if `path` is a direct or inherited property of `object`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Object
   * @param {Object} object The object to query.
   * @param {Array|string} path The path to check.
   * @returns {boolean} Returns `true` if `path` exists, else `false`.
   * @example
   *
   * var object = _.create({ 'a': _.create({ 'b': 2 }) });
   *
   * _.hasIn(object, 'a');
   * // => true
   *
   * _.hasIn(object, 'a.b');
   * // => true
   *
   * _.hasIn(object, ['a', 'b']);
   * // => true
   *
   * _.hasIn(object, 'b');
   * // => false
   */
  function hasIn(object, path) {
    return object != null && _hasPath(object, path, _baseHasIn);
  }

  var hasIn_1 = hasIn;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG$5 = 1,
      COMPARE_UNORDERED_FLAG$3 = 2;

  /**
   * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
   *
   * @private
   * @param {string} path The path of the property to get.
   * @param {*} srcValue The value to match.
   * @returns {Function} Returns the new spec function.
   */
  function baseMatchesProperty(path, srcValue) {
    if (_isKey(path) && _isStrictComparable(srcValue)) {
      return _matchesStrictComparable(_toKey(path), srcValue);
    }
    return function(object) {
      var objValue = get_1(object, path);
      return (objValue === undefined && objValue === srcValue)
        ? hasIn_1(object, path)
        : _baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$5 | COMPARE_UNORDERED_FLAG$3);
    };
  }

  var _baseMatchesProperty = baseMatchesProperty;

  /**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */
  function baseProperty(key) {
    return function(object) {
      return object == null ? undefined : object[key];
    };
  }

  var _baseProperty = baseProperty;

  /**
   * A specialized version of `baseProperty` which supports deep paths.
   *
   * @private
   * @param {Array|string} path The path of the property to get.
   * @returns {Function} Returns the new accessor function.
   */
  function basePropertyDeep(path) {
    return function(object) {
      return _baseGet(object, path);
    };
  }

  var _basePropertyDeep = basePropertyDeep;

  /**
   * Creates a function that returns the value at `path` of a given object.
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Util
   * @param {Array|string} path The path of the property to get.
   * @returns {Function} Returns the new accessor function.
   * @example
   *
   * var objects = [
   *   { 'a': { 'b': 2 } },
   *   { 'a': { 'b': 1 } }
   * ];
   *
   * _.map(objects, _.property('a.b'));
   * // => [2, 1]
   *
   * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
   * // => [1, 2]
   */
  function property(path) {
    return _isKey(path) ? _baseProperty(_toKey(path)) : _basePropertyDeep(path);
  }

  var property_1 = property;

  /**
   * The base implementation of `_.iteratee`.
   *
   * @private
   * @param {*} [value=_.identity] The value to convert to an iteratee.
   * @returns {Function} Returns the iteratee.
   */
  function baseIteratee(value) {
    // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
    // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
    if (typeof value == 'function') {
      return value;
    }
    if (value == null) {
      return identity_1;
    }
    if (typeof value == 'object') {
      return isArray_1(value)
        ? _baseMatchesProperty(value[0], value[1])
        : _baseMatches(value);
    }
    return property_1(value);
  }

  var _baseIteratee = baseIteratee;

  /**
   * The opposite of `_.mapValues`; this method creates an object with the
   * same values as `object` and keys generated by running each own enumerable
   * string keyed property of `object` thru `iteratee`. The iteratee is invoked
   * with three arguments: (value, key, object).
   *
   * @static
   * @memberOf _
   * @since 3.8.0
   * @category Object
   * @param {Object} object The object to iterate over.
   * @param {Function} [iteratee=_.identity] The function invoked per iteration.
   * @returns {Object} Returns the new mapped object.
   * @see _.mapValues
   * @example
   *
   * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
   *   return key + value;
   * });
   * // => { 'a1': 1, 'b2': 2 }
   */
  function mapKeys(object, iteratee) {
    var result = {};
    iteratee = _baseIteratee(iteratee, 3);

    _baseForOwn(object, function(value, key, object) {
      _baseAssignValue(result, iteratee(value, key, object), value);
    });
    return result;
  }

  var mapKeys_1 = mapKeys;

  function prefix(subject, prefix) {
    var delimeter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '-';

    var prefixer = function prefixer(value, key) {
      var string = key || value;
      return [prefix, string.replace(new RegExp("^".concat(prefix).concat(delimeter, "?")), '')].join(delimeter);
    };

    if (isObject_1(subject)) {
      return mapKeys_1(subject, prefixer);
    }

    return prefixer(subject);
  }

  var Variant = {
    props: {
      /**
       * The variant attribute
       *
       * @property String
       */
      variant: {
        type: String,
        default: 'primary'
      }
    },
    computed: {
      variantClass: function variantClass() {
        return prefix(this.variant, this.$options.name);
      }
    }
  };

  var Badge = {
    render: function render() {
      var _vm = this;

      var _h = _vm.$createElement;

      var _c = _vm._self._c || _h;

      return _vm.href ? _c('a', {
        staticClass: "badge",
        class: _vm.mergeClasses(_vm.classes, _vm.variantClass),
        attrs: {
          "href": _vm.href
        }
      }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))]), _vm._v(" "), _c('span', {
        staticClass: "sr-only",
        domProps: {
          "innerHTML": _vm._s(_vm.accessibility)
        }
      })], 2) : _c('span', {
        staticClass: "badge",
        class: _vm.mergeClasses(_vm.classes, _vm.variantClass)
      }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))]), _vm._v(" "), _c('span', {
        staticClass: "sr-only",
        domProps: {
          "innerHTML": _vm._s(_vm.accessibility)
        }
      })], 2);
    },
    staticRenderFns: [],
    name: 'badge',
    mixins: [Variant],
    props: {
      /**
       * The screen reader accessibility label.
       *
       * @property String
       */
      accessibility: String,

      /**
       * If an href attribute is passed, the badge becomes an anchor.
       *
       * @property String
       */
      href: String,

      /**
       * The badge appear as pill shaped.
       *
       * @property String
       */
      pill: Boolean,

      /**
       * The badge label.
       *
       * @property String
       */
      label: [Number, String],

      /**
       * The badge appear as secondary in size to the parent element.
       *
       * @property String
       */
      secondary: Boolean
    },
    computed: {
      classes: function classes() {
        return prefix({
          'pill': this.pill,
          'secondary': this.secondary
        }, this.$options.name);
      }
    }
  };

  var plugin$3 = VueInstaller.use({
    install: function install(Vue, options) {
      VueInstaller.components({
        Badge: Badge
      });
    }
  });

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  /**
   * Checks if `value` is `undefined`.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
   * @example
   *
   * _.isUndefined(void 0);
   * // => true
   *
   * _.isUndefined(null);
   * // => false
   */
  function isUndefined(value) {
    return value === undefined;
  }

  var isUndefined_1 = isUndefined;

  /**
   * The base implementation of `_.reduce` and `_.reduceRight`, without support
   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} accumulator The initial value.
   * @param {boolean} initAccum Specify using the first or last element of
   *  `collection` as the initial value.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the accumulated value.
   */
  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
    eachFunc(collection, function(value, index, collection) {
      accumulator = initAccum
        ? (initAccum = false, value)
        : iteratee(accumulator, value, index, collection);
    });
    return accumulator;
  }

  var _baseReduce = baseReduce;

  /**
   * Reduces `collection` to a value which is the accumulated result of running
   * each element in `collection` thru `iteratee`, where each successive
   * invocation is supplied the return value of the previous. If `accumulator`
   * is not given, the first element of `collection` is used as the initial
   * value. The iteratee is invoked with four arguments:
   * (accumulator, value, index|key, collection).
   *
   * Many lodash methods are guarded to work as iteratees for methods like
   * `_.reduce`, `_.reduceRight`, and `_.transform`.
   *
   * The guarded methods are:
   * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
   * and `sortBy`
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} [iteratee=_.identity] The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @returns {*} Returns the accumulated value.
   * @see _.reduceRight
   * @example
   *
   * _.reduce([1, 2], function(sum, n) {
   *   return sum + n;
   * }, 0);
   * // => 3
   *
   * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
   *   (result[value] || (result[value] = [])).push(key);
   *   return result;
   * }, {});
   * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
   */
  function reduce(collection, iteratee, accumulator) {
    var func = isArray_1(collection) ? _arrayReduce : _baseReduce,
        initAccum = arguments.length < 3;

    return func(collection, _baseIteratee(iteratee, 4), accumulator, initAccum, _baseEach);
  }

  var reduce_1 = reduce;

  /**
   * The base implementation of `_.set`.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {Array|string} path The path of the property to set.
   * @param {*} value The value to set.
   * @param {Function} [customizer] The function to customize path creation.
   * @returns {Object} Returns `object`.
   */
  function baseSet(object, path, value, customizer) {
    if (!isObject_1(object)) {
      return object;
    }
    path = _castPath(path, object);

    var index = -1,
        length = path.length,
        lastIndex = length - 1,
        nested = object;

    while (nested != null && ++index < length) {
      var key = _toKey(path[index]),
          newValue = value;

      if (index != lastIndex) {
        var objValue = nested[key];
        newValue = customizer ? customizer(objValue, key, nested) : undefined;
        if (newValue === undefined) {
          newValue = isObject_1(objValue)
            ? objValue
            : (_isIndex(path[index + 1]) ? [] : {});
        }
      }
      _assignValue(nested, key, newValue);
      nested = nested[key];
    }
    return object;
  }

  var _baseSet = baseSet;

  /**
   * The base implementation of  `_.pickBy` without support for iteratee shorthands.
   *
   * @private
   * @param {Object} object The source object.
   * @param {string[]} paths The property paths to pick.
   * @param {Function} predicate The function invoked per property.
   * @returns {Object} Returns the new object.
   */
  function basePickBy(object, paths, predicate) {
    var index = -1,
        length = paths.length,
        result = {};

    while (++index < length) {
      var path = paths[index],
          value = _baseGet(object, path);

      if (predicate(value, path)) {
        _baseSet(result, _castPath(path, object), value);
      }
    }
    return result;
  }

  var _basePickBy = basePickBy;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeGetSymbols$1 = Object.getOwnPropertySymbols;

  /**
   * Creates an array of the own and inherited enumerable symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of symbols.
   */
  var getSymbolsIn = !nativeGetSymbols$1 ? stubArray_1 : function(object) {
    var result = [];
    while (object) {
      _arrayPush(result, _getSymbols(object));
      object = _getPrototype(object);
    }
    return result;
  };

  var _getSymbolsIn = getSymbolsIn;

  /**
   * Creates an array of own and inherited enumerable property names and
   * symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names and symbols.
   */
  function getAllKeysIn(object) {
    return _baseGetAllKeys(object, keysIn_1, _getSymbolsIn);
  }

  var _getAllKeysIn = getAllKeysIn;

  /**
   * Creates an object composed of the `object` properties `predicate` returns
   * truthy for. The predicate is invoked with two arguments: (value, key).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Object
   * @param {Object} object The source object.
   * @param {Function} [predicate=_.identity] The function invoked per property.
   * @returns {Object} Returns the new object.
   * @example
   *
   * var object = { 'a': 1, 'b': '2', 'c': 3 };
   *
   * _.pickBy(object, _.isNumber);
   * // => { 'a': 1, 'c': 3 }
   */
  function pickBy(object, predicate) {
    if (object == null) {
      return {};
    }
    var props = _arrayMap(_getAllKeysIn(object), function(prop) {
      return [prop];
    });
    predicate = _baseIteratee(predicate);
    return _basePickBy(object, props, function(value, path) {
      return predicate(value, path[0]);
    });
  }

  var pickBy_1 = pickBy;

  /**
   * Checks if `value` is `null`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
   * @example
   *
   * _.isNull(null);
   * // => true
   *
   * _.isNull(void 0);
   * // => false
   */
  function isNull(value) {
    return value === null;
  }

  var isNull_1 = isNull;

  /**
   * The base implementation of `_.filter` without support for iteratee shorthands.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */
  function baseFilter(collection, predicate) {
    var result = [];
    _baseEach(collection, function(value, index, collection) {
      if (predicate(value, index, collection)) {
        result.push(value);
      }
    });
    return result;
  }

  var _baseFilter = baseFilter;

  /**
   * Iterates over elements of `collection`, returning an array of all elements
   * `predicate` returns truthy for. The predicate is invoked with three
   * arguments: (value, index|key, collection).
   *
   * **Note:** Unlike `_.remove`, this method returns a new array.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} [predicate=_.identity] The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   * @see _.reject
   * @example
   *
   * var users = [
   *   { 'user': 'barney', 'age': 36, 'active': true },
   *   { 'user': 'fred',   'age': 40, 'active': false }
   * ];
   *
   * _.filter(users, function(o) { return !o.active; });
   * // => objects for ['fred']
   *
   * // The `_.matches` iteratee shorthand.
   * _.filter(users, { 'age': 36, 'active': true });
   * // => objects for ['barney']
   *
   * // The `_.matchesProperty` iteratee shorthand.
   * _.filter(users, ['active', false]);
   * // => objects for ['fred']
   *
   * // The `_.property` iteratee shorthand.
   * _.filter(users, 'active');
   * // => objects for ['barney']
   */
  function filter(collection, predicate) {
    var func = isArray_1(collection) ? _arrayFilter : _baseFilter;
    return func(collection, _baseIteratee(predicate, 3));
  }

  var filter_1 = filter;

  /** `Object#toString` result references. */
  var stringTag$2 = '[object String]';

  /**
   * Checks if `value` is classified as a `String` primitive or object.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a string, else `false`.
   * @example
   *
   * _.isString('abc');
   * // => true
   *
   * _.isString(1);
   * // => false
   */
  function isString(value) {
    return typeof value == 'string' ||
      (!isArray_1(value) && isObjectLike_1(value) && _baseGetTag(value) == stringTag$2);
  }

  var isString_1 = isString;

  /**
   * Gets the size of an ASCII `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */
  var asciiSize = _baseProperty('length');

  var _asciiSize = asciiSize;

  /** Used to compose unicode character classes. */
  var rsAstralRange$1 = '\\ud800-\\udfff',
      rsComboMarksRange$2 = '\\u0300-\\u036f',
      reComboHalfMarksRange$2 = '\\ufe20-\\ufe2f',
      rsComboSymbolsRange$2 = '\\u20d0-\\u20ff',
      rsComboRange$2 = rsComboMarksRange$2 + reComboHalfMarksRange$2 + rsComboSymbolsRange$2,
      rsVarRange$1 = '\\ufe0e\\ufe0f';

  /** Used to compose unicode capture groups. */
  var rsZWJ$1 = '\\u200d';

  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
  var reHasUnicode = RegExp('[' + rsZWJ$1 + rsAstralRange$1  + rsComboRange$2 + rsVarRange$1 + ']');

  /**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */
  function hasUnicode(string) {
    return reHasUnicode.test(string);
  }

  var _hasUnicode = hasUnicode;

  /** Used to compose unicode character classes. */
  var rsAstralRange$2 = '\\ud800-\\udfff',
      rsComboMarksRange$3 = '\\u0300-\\u036f',
      reComboHalfMarksRange$3 = '\\ufe20-\\ufe2f',
      rsComboSymbolsRange$3 = '\\u20d0-\\u20ff',
      rsComboRange$3 = rsComboMarksRange$3 + reComboHalfMarksRange$3 + rsComboSymbolsRange$3,
      rsVarRange$2 = '\\ufe0e\\ufe0f';

  /** Used to compose unicode capture groups. */
  var rsAstral = '[' + rsAstralRange$2 + ']',
      rsCombo$2 = '[' + rsComboRange$3 + ']',
      rsFitz$1 = '\\ud83c[\\udffb-\\udfff]',
      rsModifier$1 = '(?:' + rsCombo$2 + '|' + rsFitz$1 + ')',
      rsNonAstral$1 = '[^' + rsAstralRange$2 + ']',
      rsRegional$1 = '(?:\\ud83c[\\udde6-\\uddff]){2}',
      rsSurrPair$1 = '[\\ud800-\\udbff][\\udc00-\\udfff]',
      rsZWJ$2 = '\\u200d';

  /** Used to compose unicode regexes. */
  var reOptMod$1 = rsModifier$1 + '?',
      rsOptVar$1 = '[' + rsVarRange$2 + ']?',
      rsOptJoin$1 = '(?:' + rsZWJ$2 + '(?:' + [rsNonAstral$1, rsRegional$1, rsSurrPair$1].join('|') + ')' + rsOptVar$1 + reOptMod$1 + ')*',
      rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1,
      rsSymbol = '(?:' + [rsNonAstral$1 + rsCombo$2 + '?', rsCombo$2, rsRegional$1, rsSurrPair$1, rsAstral].join('|') + ')';

  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
  var reUnicode = RegExp(rsFitz$1 + '(?=' + rsFitz$1 + ')|' + rsSymbol + rsSeq$1, 'g');

  /**
   * Gets the size of a Unicode `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */
  function unicodeSize(string) {
    var result = reUnicode.lastIndex = 0;
    while (reUnicode.test(string)) {
      ++result;
    }
    return result;
  }

  var _unicodeSize = unicodeSize;

  /**
   * Gets the number of symbols in `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the string size.
   */
  function stringSize(string) {
    return _hasUnicode(string)
      ? _unicodeSize(string)
      : _asciiSize(string);
  }

  var _stringSize = stringSize;

  /** `Object#toString` result references. */
  var mapTag$3 = '[object Map]',
      setTag$3 = '[object Set]';

  /**
   * Gets the size of `collection` by returning its length for array-like
   * values or the number of own enumerable string keyed properties for objects.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object|string} collection The collection to inspect.
   * @returns {number} Returns the collection size.
   * @example
   *
   * _.size([1, 2, 3]);
   * // => 3
   *
   * _.size({ 'a': 1, 'b': 2 });
   * // => 2
   *
   * _.size('pebbles');
   * // => 7
   */
  function size(collection) {
    if (collection == null) {
      return 0;
    }
    if (isArrayLike_1(collection)) {
      return isString_1(collection) ? _stringSize(collection) : collection.length;
    }
    var tag = _getTag(collection);
    if (tag == mapTag$3 || tag == setTag$3) {
      return collection.size;
    }
    return _baseKeys(collection).length;
  }

  var size_1 = size;

  /**
   * The base implementation of `_.map` without support for iteratee shorthands.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function baseMap(collection, iteratee) {
    var index = -1,
        result = isArrayLike_1(collection) ? Array(collection.length) : [];

    _baseEach(collection, function(value, key, collection) {
      result[++index] = iteratee(value, key, collection);
    });
    return result;
  }

  var _baseMap = baseMap;

  /**
   * Creates an array of values by running each element in `collection` thru
   * `iteratee`. The iteratee is invoked with three arguments:
   * (value, index|key, collection).
   *
   * Many lodash methods are guarded to work as iteratees for methods like
   * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
   *
   * The guarded methods are:
   * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
   * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
   * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
   * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} [iteratee=_.identity] The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   * @example
   *
   * function square(n) {
   *   return n * n;
   * }
   *
   * _.map([4, 8], square);
   * // => [16, 64]
   *
   * _.map({ 'a': 4, 'b': 8 }, square);
   * // => [16, 64] (iteration order is not guaranteed)
   *
   * var users = [
   *   { 'user': 'barney' },
   *   { 'user': 'fred' }
   * ];
   *
   * // The `_.property` iteratee shorthand.
   * _.map(users, 'user');
   * // => ['barney', 'fred']
   */
  function map(collection, iteratee) {
    var func = isArray_1(collection) ? _arrayMap : _baseMap;
    return func(collection, _baseIteratee(iteratee, 3));
  }

  var map_1 = map;

  /**
   * The base implementation of `_.slice` without an iteratee call guard.
   *
   * @private
   * @param {Array} array The array to slice.
   * @param {number} [start=0] The start position.
   * @param {number} [end=array.length] The end position.
   * @returns {Array} Returns the slice of `array`.
   */
  function baseSlice(array, start, end) {
    var index = -1,
        length = array.length;

    if (start < 0) {
      start = -start > length ? 0 : (length + start);
    }
    end = end > length ? length : end;
    if (end < 0) {
      end += length;
    }
    length = start > end ? 0 : ((end - start) >>> 0);
    start >>>= 0;

    var result = Array(length);
    while (++index < length) {
      result[index] = array[index + start];
    }
    return result;
  }

  var _baseSlice = baseSlice;

  /**
   * Casts `array` to a slice if it's needed.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {number} start The start position.
   * @param {number} [end=array.length] The end position.
   * @returns {Array} Returns the cast slice.
   */
  function castSlice(array, start, end) {
    var length = array.length;
    end = end === undefined ? length : end;
    return (!start && end >= length) ? array : _baseSlice(array, start, end);
  }

  var _castSlice = castSlice;

  /**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function asciiToArray(string) {
    return string.split('');
  }

  var _asciiToArray = asciiToArray;

  /** Used to compose unicode character classes. */
  var rsAstralRange$3 = '\\ud800-\\udfff',
      rsComboMarksRange$4 = '\\u0300-\\u036f',
      reComboHalfMarksRange$4 = '\\ufe20-\\ufe2f',
      rsComboSymbolsRange$4 = '\\u20d0-\\u20ff',
      rsComboRange$4 = rsComboMarksRange$4 + reComboHalfMarksRange$4 + rsComboSymbolsRange$4,
      rsVarRange$3 = '\\ufe0e\\ufe0f';

  /** Used to compose unicode capture groups. */
  var rsAstral$1 = '[' + rsAstralRange$3 + ']',
      rsCombo$3 = '[' + rsComboRange$4 + ']',
      rsFitz$2 = '\\ud83c[\\udffb-\\udfff]',
      rsModifier$2 = '(?:' + rsCombo$3 + '|' + rsFitz$2 + ')',
      rsNonAstral$2 = '[^' + rsAstralRange$3 + ']',
      rsRegional$2 = '(?:\\ud83c[\\udde6-\\uddff]){2}',
      rsSurrPair$2 = '[\\ud800-\\udbff][\\udc00-\\udfff]',
      rsZWJ$3 = '\\u200d';

  /** Used to compose unicode regexes. */
  var reOptMod$2 = rsModifier$2 + '?',
      rsOptVar$2 = '[' + rsVarRange$3 + ']?',
      rsOptJoin$2 = '(?:' + rsZWJ$3 + '(?:' + [rsNonAstral$2, rsRegional$2, rsSurrPair$2].join('|') + ')' + rsOptVar$2 + reOptMod$2 + ')*',
      rsSeq$2 = rsOptVar$2 + reOptMod$2 + rsOptJoin$2,
      rsSymbol$1 = '(?:' + [rsNonAstral$2 + rsCombo$3 + '?', rsCombo$3, rsRegional$2, rsSurrPair$2, rsAstral$1].join('|') + ')';

  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
  var reUnicode$1 = RegExp(rsFitz$2 + '(?=' + rsFitz$2 + ')|' + rsSymbol$1 + rsSeq$2, 'g');

  /**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function unicodeToArray(string) {
    return string.match(reUnicode$1) || [];
  }

  var _unicodeToArray = unicodeToArray;

  /**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function stringToArray(string) {
    return _hasUnicode(string)
      ? _unicodeToArray(string)
      : _asciiToArray(string);
  }

  var _stringToArray = stringToArray;

  /**
   * Creates a function like `_.lowerFirst`.
   *
   * @private
   * @param {string} methodName The name of the `String` case method to use.
   * @returns {Function} Returns the new case function.
   */
  function createCaseFirst(methodName) {
    return function(string) {
      string = toString_1(string);

      var strSymbols = _hasUnicode(string)
        ? _stringToArray(string)
        : undefined;

      var chr = strSymbols
        ? strSymbols[0]
        : string.charAt(0);

      var trailing = strSymbols
        ? _castSlice(strSymbols, 1).join('')
        : string.slice(1);

      return chr[methodName]() + trailing;
    };
  }

  var _createCaseFirst = createCaseFirst;

  /**
   * Converts the first character of `string` to upper case.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category String
   * @param {string} [string=''] The string to convert.
   * @returns {string} Returns the converted string.
   * @example
   *
   * _.upperFirst('fred');
   * // => 'Fred'
   *
   * _.upperFirst('FRED');
   * // => 'FRED'
   */
  var upperFirst = _createCaseFirst('toUpperCase');

  var upperFirst_1 = upperFirst;

  /**
   * Converts the first character of `string` to upper case and the remaining
   * to lower case.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category String
   * @param {string} [string=''] The string to capitalize.
   * @returns {string} Returns the capitalized string.
   * @example
   *
   * _.capitalize('FRED');
   * // => 'Fred'
   */
  function capitalize(string) {
    return upperFirst_1(toString_1(string).toLowerCase());
  }

  var capitalize_1 = capitalize;

  /**
   * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category String
   * @param {string} [string=''] The string to convert.
   * @returns {string} Returns the camel cased string.
   * @example
   *
   * _.camelCase('Foo Bar');
   * // => 'fooBar'
   *
   * _.camelCase('--foo-bar--');
   * // => 'fooBar'
   *
   * _.camelCase('__FOO_BAR__');
   * // => 'fooBar'
   */
  var camelCase = _createCompounder(function(result, word, index) {
    word = word.toLowerCase();
    return result + (index ? capitalize_1(word) : word);
  });

  var camelCase_1 = camelCase;

  /** Used to store function metadata. */
  var metaMap = _WeakMap && new _WeakMap;

  var _metaMap = metaMap;

  /**
   * The base implementation of `setData` without support for hot loop shorting.
   *
   * @private
   * @param {Function} func The function to associate metadata with.
   * @param {*} data The metadata.
   * @returns {Function} Returns `func`.
   */
  var baseSetData = !_metaMap ? identity_1 : function(func, data) {
    _metaMap.set(func, data);
    return func;
  };

  var _baseSetData = baseSetData;

  /**
   * Creates a function that produces an instance of `Ctor` regardless of
   * whether it was invoked as part of a `new` expression or by `call` or `apply`.
   *
   * @private
   * @param {Function} Ctor The constructor to wrap.
   * @returns {Function} Returns the new wrapped function.
   */
  function createCtor(Ctor) {
    return function() {
      // Use a `switch` statement to work with class constructors. See
      // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
      // for more details.
      var args = arguments;
      switch (args.length) {
        case 0: return new Ctor;
        case 1: return new Ctor(args[0]);
        case 2: return new Ctor(args[0], args[1]);
        case 3: return new Ctor(args[0], args[1], args[2]);
        case 4: return new Ctor(args[0], args[1], args[2], args[3]);
        case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
        case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
        case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
      }
      var thisBinding = _baseCreate(Ctor.prototype),
          result = Ctor.apply(thisBinding, args);

      // Mimic the constructor's `return` behavior.
      // See https://es5.github.io/#x13.2.2 for more details.
      return isObject_1(result) ? result : thisBinding;
    };
  }

  var _createCtor = createCtor;

  /** Used to compose bitmasks for function metadata. */
  var WRAP_BIND_FLAG = 1;

  /**
   * Creates a function that wraps `func` to invoke it with the optional `this`
   * binding of `thisArg`.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
   * @param {*} [thisArg] The `this` binding of `func`.
   * @returns {Function} Returns the new wrapped function.
   */
  function createBind(func, bitmask, thisArg) {
    var isBind = bitmask & WRAP_BIND_FLAG,
        Ctor = _createCtor(func);

    function wrapper() {
      var fn = (this && this !== _root && this instanceof wrapper) ? Ctor : func;
      return fn.apply(isBind ? thisArg : this, arguments);
    }
    return wrapper;
  }

  var _createBind = createBind;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeMax$1 = Math.max;

  /**
   * Creates an array that is the composition of partially applied arguments,
   * placeholders, and provided arguments into a single array of arguments.
   *
   * @private
   * @param {Array} args The provided arguments.
   * @param {Array} partials The arguments to prepend to those provided.
   * @param {Array} holders The `partials` placeholder indexes.
   * @params {boolean} [isCurried] Specify composing for a curried function.
   * @returns {Array} Returns the new array of composed arguments.
   */
  function composeArgs(args, partials, holders, isCurried) {
    var argsIndex = -1,
        argsLength = args.length,
        holdersLength = holders.length,
        leftIndex = -1,
        leftLength = partials.length,
        rangeLength = nativeMax$1(argsLength - holdersLength, 0),
        result = Array(leftLength + rangeLength),
        isUncurried = !isCurried;

    while (++leftIndex < leftLength) {
      result[leftIndex] = partials[leftIndex];
    }
    while (++argsIndex < holdersLength) {
      if (isUncurried || argsIndex < argsLength) {
        result[holders[argsIndex]] = args[argsIndex];
      }
    }
    while (rangeLength--) {
      result[leftIndex++] = args[argsIndex++];
    }
    return result;
  }

  var _composeArgs = composeArgs;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeMax$2 = Math.max;

  /**
   * This function is like `composeArgs` except that the arguments composition
   * is tailored for `_.partialRight`.
   *
   * @private
   * @param {Array} args The provided arguments.
   * @param {Array} partials The arguments to append to those provided.
   * @param {Array} holders The `partials` placeholder indexes.
   * @params {boolean} [isCurried] Specify composing for a curried function.
   * @returns {Array} Returns the new array of composed arguments.
   */
  function composeArgsRight(args, partials, holders, isCurried) {
    var argsIndex = -1,
        argsLength = args.length,
        holdersIndex = -1,
        holdersLength = holders.length,
        rightIndex = -1,
        rightLength = partials.length,
        rangeLength = nativeMax$2(argsLength - holdersLength, 0),
        result = Array(rangeLength + rightLength),
        isUncurried = !isCurried;

    while (++argsIndex < rangeLength) {
      result[argsIndex] = args[argsIndex];
    }
    var offset = argsIndex;
    while (++rightIndex < rightLength) {
      result[offset + rightIndex] = partials[rightIndex];
    }
    while (++holdersIndex < holdersLength) {
      if (isUncurried || argsIndex < argsLength) {
        result[offset + holders[holdersIndex]] = args[argsIndex++];
      }
    }
    return result;
  }

  var _composeArgsRight = composeArgsRight;

  /**
   * Gets the number of `placeholder` occurrences in `array`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} placeholder The placeholder to search for.
   * @returns {number} Returns the placeholder count.
   */
  function countHolders(array, placeholder) {
    var length = array.length,
        result = 0;

    while (length--) {
      if (array[length] === placeholder) {
        ++result;
      }
    }
    return result;
  }

  var _countHolders = countHolders;

  /**
   * The function whose prototype chain sequence wrappers inherit from.
   *
   * @private
   */
  function baseLodash() {
    // No operation performed.
  }

  var _baseLodash = baseLodash;

  /** Used as references for the maximum length and index of an array. */
  var MAX_ARRAY_LENGTH = 4294967295;

  /**
   * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
   *
   * @private
   * @constructor
   * @param {*} value The value to wrap.
   */
  function LazyWrapper(value) {
    this.__wrapped__ = value;
    this.__actions__ = [];
    this.__dir__ = 1;
    this.__filtered__ = false;
    this.__iteratees__ = [];
    this.__takeCount__ = MAX_ARRAY_LENGTH;
    this.__views__ = [];
  }

  // Ensure `LazyWrapper` is an instance of `baseLodash`.
  LazyWrapper.prototype = _baseCreate(_baseLodash.prototype);
  LazyWrapper.prototype.constructor = LazyWrapper;

  var _LazyWrapper = LazyWrapper;

  /**
   * This method returns `undefined`.
   *
   * @static
   * @memberOf _
   * @since 2.3.0
   * @category Util
   * @example
   *
   * _.times(2, _.noop);
   * // => [undefined, undefined]
   */
  function noop() {
    // No operation performed.
  }

  var noop_1 = noop;

  /**
   * Gets metadata for `func`.
   *
   * @private
   * @param {Function} func The function to query.
   * @returns {*} Returns the metadata for `func`.
   */
  var getData = !_metaMap ? noop_1 : function(func) {
    return _metaMap.get(func);
  };

  var _getData = getData;

  /** Used to lookup unminified function names. */
  var realNames = {};

  var _realNames = realNames;

  /** Used for built-in method references. */
  var objectProto$15 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$12 = objectProto$15.hasOwnProperty;

  /**
   * Gets the name of `func`.
   *
   * @private
   * @param {Function} func The function to query.
   * @returns {string} Returns the function name.
   */
  function getFuncName(func) {
    var result = (func.name + ''),
        array = _realNames[result],
        length = hasOwnProperty$12.call(_realNames, result) ? array.length : 0;

    while (length--) {
      var data = array[length],
          otherFunc = data.func;
      if (otherFunc == null || otherFunc == func) {
        return data.name;
      }
    }
    return result;
  }

  var _getFuncName = getFuncName;

  /**
   * The base constructor for creating `lodash` wrapper objects.
   *
   * @private
   * @param {*} value The value to wrap.
   * @param {boolean} [chainAll] Enable explicit method chain sequences.
   */
  function LodashWrapper(value, chainAll) {
    this.__wrapped__ = value;
    this.__actions__ = [];
    this.__chain__ = !!chainAll;
    this.__index__ = 0;
    this.__values__ = undefined;
  }

  LodashWrapper.prototype = _baseCreate(_baseLodash.prototype);
  LodashWrapper.prototype.constructor = LodashWrapper;

  var _LodashWrapper = LodashWrapper;

  /**
   * Creates a clone of `wrapper`.
   *
   * @private
   * @param {Object} wrapper The wrapper to clone.
   * @returns {Object} Returns the cloned wrapper.
   */
  function wrapperClone(wrapper) {
    if (wrapper instanceof _LazyWrapper) {
      return wrapper.clone();
    }
    var result = new _LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
    result.__actions__ = _copyArray(wrapper.__actions__);
    result.__index__  = wrapper.__index__;
    result.__values__ = wrapper.__values__;
    return result;
  }

  var _wrapperClone = wrapperClone;

  /** Used for built-in method references. */
  var objectProto$16 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$13 = objectProto$16.hasOwnProperty;

  /**
   * Creates a `lodash` object which wraps `value` to enable implicit method
   * chain sequences. Methods that operate on and return arrays, collections,
   * and functions can be chained together. Methods that retrieve a single value
   * or may return a primitive value will automatically end the chain sequence
   * and return the unwrapped value. Otherwise, the value must be unwrapped
   * with `_#value`.
   *
   * Explicit chain sequences, which must be unwrapped with `_#value`, may be
   * enabled using `_.chain`.
   *
   * The execution of chained methods is lazy, that is, it's deferred until
   * `_#value` is implicitly or explicitly called.
   *
   * Lazy evaluation allows several methods to support shortcut fusion.
   * Shortcut fusion is an optimization to merge iteratee calls; this avoids
   * the creation of intermediate arrays and can greatly reduce the number of
   * iteratee executions. Sections of a chain sequence qualify for shortcut
   * fusion if the section is applied to an array and iteratees accept only
   * one argument. The heuristic for whether a section qualifies for shortcut
   * fusion is subject to change.
   *
   * Chaining is supported in custom builds as long as the `_#value` method is
   * directly or indirectly included in the build.
   *
   * In addition to lodash methods, wrappers have `Array` and `String` methods.
   *
   * The wrapper `Array` methods are:
   * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
   *
   * The wrapper `String` methods are:
   * `replace` and `split`
   *
   * The wrapper methods that support shortcut fusion are:
   * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
   * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
   * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
   *
   * The chainable wrapper methods are:
   * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
   * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
   * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
   * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
   * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
   * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
   * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
   * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
   * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
   * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
   * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
   * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
   * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
   * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
   * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
   * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
   * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
   * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
   * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
   * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
   * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
   * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
   * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
   * `zipObject`, `zipObjectDeep`, and `zipWith`
   *
   * The wrapper methods that are **not** chainable by default are:
   * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
   * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
   * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
   * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
   * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
   * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
   * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
   * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
   * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
   * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
   * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
   * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
   * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
   * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
   * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
   * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
   * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
   * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
   * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
   * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
   * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
   * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
   * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
   * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
   * `upperFirst`, `value`, and `words`
   *
   * @name _
   * @constructor
   * @category Seq
   * @param {*} value The value to wrap in a `lodash` instance.
   * @returns {Object} Returns the new `lodash` wrapper instance.
   * @example
   *
   * function square(n) {
   *   return n * n;
   * }
   *
   * var wrapped = _([1, 2, 3]);
   *
   * // Returns an unwrapped value.
   * wrapped.reduce(_.add);
   * // => 6
   *
   * // Returns a wrapped value.
   * var squares = wrapped.map(square);
   *
   * _.isArray(squares);
   * // => false
   *
   * _.isArray(squares.value());
   * // => true
   */
  function lodash(value) {
    if (isObjectLike_1(value) && !isArray_1(value) && !(value instanceof _LazyWrapper)) {
      if (value instanceof _LodashWrapper) {
        return value;
      }
      if (hasOwnProperty$13.call(value, '__wrapped__')) {
        return _wrapperClone(value);
      }
    }
    return new _LodashWrapper(value);
  }

  // Ensure wrappers are instances of `baseLodash`.
  lodash.prototype = _baseLodash.prototype;
  lodash.prototype.constructor = lodash;

  var wrapperLodash = lodash;

  /**
   * Checks if `func` has a lazy counterpart.
   *
   * @private
   * @param {Function} func The function to check.
   * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
   *  else `false`.
   */
  function isLaziable(func) {
    var funcName = _getFuncName(func),
        other = wrapperLodash[funcName];

    if (typeof other != 'function' || !(funcName in _LazyWrapper.prototype)) {
      return false;
    }
    if (func === other) {
      return true;
    }
    var data = _getData(other);
    return !!data && func === data[0];
  }

  var _isLaziable = isLaziable;

  /**
   * Sets metadata for `func`.
   *
   * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
   * period of time, it will trip its breaker and transition to an identity
   * function to avoid garbage collection pauses in V8. See
   * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
   * for more details.
   *
   * @private
   * @param {Function} func The function to associate metadata with.
   * @param {*} data The metadata.
   * @returns {Function} Returns `func`.
   */
  var setData = _shortOut(_baseSetData);

  var _setData = setData;

  /** Used to match wrap detail comments. */
  var reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
      reSplitDetails = /,? & /;

  /**
   * Extracts wrapper details from the `source` body comment.
   *
   * @private
   * @param {string} source The source to inspect.
   * @returns {Array} Returns the wrapper details.
   */
  function getWrapDetails(source) {
    var match = source.match(reWrapDetails);
    return match ? match[1].split(reSplitDetails) : [];
  }

  var _getWrapDetails = getWrapDetails;

  /** Used to match wrap detail comments. */
  var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/;

  /**
   * Inserts wrapper `details` in a comment at the top of the `source` body.
   *
   * @private
   * @param {string} source The source to modify.
   * @returns {Array} details The details to insert.
   * @returns {string} Returns the modified source.
   */
  function insertWrapDetails(source, details) {
    var length = details.length;
    if (!length) {
      return source;
    }
    var lastIndex = length - 1;
    details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
    details = details.join(length > 2 ? ', ' : ' ');
    return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
  }

  var _insertWrapDetails = insertWrapDetails;

  /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length,
        index = fromIndex + (fromRight ? 1 : -1);

    while ((fromRight ? index-- : ++index < length)) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }

  var _baseFindIndex = baseFindIndex;

  /**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */
  function baseIsNaN(value) {
    return value !== value;
  }

  var _baseIsNaN = baseIsNaN;

  /**
   * A specialized version of `_.indexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function strictIndexOf(array, value, fromIndex) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  var _strictIndexOf = strictIndexOf;

  /**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    return value === value
      ? _strictIndexOf(array, value, fromIndex)
      : _baseFindIndex(array, _baseIsNaN, fromIndex);
  }

  var _baseIndexOf = baseIndexOf;

  /**
   * A specialized version of `_.includes` for arrays without support for
   * specifying an index to search from.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludes(array, value) {
    var length = array == null ? 0 : array.length;
    return !!length && _baseIndexOf(array, value, 0) > -1;
  }

  var _arrayIncludes = arrayIncludes;

  /** Used to compose bitmasks for function metadata. */
  var WRAP_BIND_FLAG$1 = 1,
      WRAP_BIND_KEY_FLAG = 2,
      WRAP_CURRY_FLAG = 8,
      WRAP_CURRY_RIGHT_FLAG = 16,
      WRAP_PARTIAL_FLAG = 32,
      WRAP_PARTIAL_RIGHT_FLAG = 64,
      WRAP_ARY_FLAG = 128,
      WRAP_REARG_FLAG = 256,
      WRAP_FLIP_FLAG = 512;

  /** Used to associate wrap methods with their bit flags. */
  var wrapFlags = [
    ['ary', WRAP_ARY_FLAG],
    ['bind', WRAP_BIND_FLAG$1],
    ['bindKey', WRAP_BIND_KEY_FLAG],
    ['curry', WRAP_CURRY_FLAG],
    ['curryRight', WRAP_CURRY_RIGHT_FLAG],
    ['flip', WRAP_FLIP_FLAG],
    ['partial', WRAP_PARTIAL_FLAG],
    ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
    ['rearg', WRAP_REARG_FLAG]
  ];

  /**
   * Updates wrapper `details` based on `bitmask` flags.
   *
   * @private
   * @returns {Array} details The details to modify.
   * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
   * @returns {Array} Returns `details`.
   */
  function updateWrapDetails(details, bitmask) {
    _arrayEach(wrapFlags, function(pair) {
      var value = '_.' + pair[0];
      if ((bitmask & pair[1]) && !_arrayIncludes(details, value)) {
        details.push(value);
      }
    });
    return details.sort();
  }

  var _updateWrapDetails = updateWrapDetails;

  /**
   * Sets the `toString` method of `wrapper` to mimic the source of `reference`
   * with wrapper details in a comment at the top of the source body.
   *
   * @private
   * @param {Function} wrapper The function to modify.
   * @param {Function} reference The reference function.
   * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
   * @returns {Function} Returns `wrapper`.
   */
  function setWrapToString(wrapper, reference, bitmask) {
    var source = (reference + '');
    return _setToString(wrapper, _insertWrapDetails(source, _updateWrapDetails(_getWrapDetails(source), bitmask)));
  }

  var _setWrapToString = setWrapToString;

  /** Used to compose bitmasks for function metadata. */
  var WRAP_BIND_FLAG$2 = 1,
      WRAP_BIND_KEY_FLAG$1 = 2,
      WRAP_CURRY_BOUND_FLAG = 4,
      WRAP_CURRY_FLAG$1 = 8,
      WRAP_PARTIAL_FLAG$1 = 32,
      WRAP_PARTIAL_RIGHT_FLAG$1 = 64;

  /**
   * Creates a function that wraps `func` to continue currying.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
   * @param {Function} wrapFunc The function to create the `func` wrapper.
   * @param {*} placeholder The placeholder value.
   * @param {*} [thisArg] The `this` binding of `func`.
   * @param {Array} [partials] The arguments to prepend to those provided to
   *  the new function.
   * @param {Array} [holders] The `partials` placeholder indexes.
   * @param {Array} [argPos] The argument positions of the new function.
   * @param {number} [ary] The arity cap of `func`.
   * @param {number} [arity] The arity of `func`.
   * @returns {Function} Returns the new wrapped function.
   */
  function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
    var isCurry = bitmask & WRAP_CURRY_FLAG$1,
        newHolders = isCurry ? holders : undefined,
        newHoldersRight = isCurry ? undefined : holders,
        newPartials = isCurry ? partials : undefined,
        newPartialsRight = isCurry ? undefined : partials;

    bitmask |= (isCurry ? WRAP_PARTIAL_FLAG$1 : WRAP_PARTIAL_RIGHT_FLAG$1);
    bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG$1 : WRAP_PARTIAL_FLAG$1);

    if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
      bitmask &= ~(WRAP_BIND_FLAG$2 | WRAP_BIND_KEY_FLAG$1);
    }
    var newData = [
      func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
      newHoldersRight, argPos, ary, arity
    ];

    var result = wrapFunc.apply(undefined, newData);
    if (_isLaziable(func)) {
      _setData(result, newData);
    }
    result.placeholder = placeholder;
    return _setWrapToString(result, func, bitmask);
  }

  var _createRecurry = createRecurry;

  /**
   * Gets the argument placeholder value for `func`.
   *
   * @private
   * @param {Function} func The function to inspect.
   * @returns {*} Returns the placeholder value.
   */
  function getHolder(func) {
    var object = func;
    return object.placeholder;
  }

  var _getHolder = getHolder;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeMin = Math.min;

  /**
   * Reorder `array` according to the specified indexes where the element at
   * the first index is assigned as the first element, the element at
   * the second index is assigned as the second element, and so on.
   *
   * @private
   * @param {Array} array The array to reorder.
   * @param {Array} indexes The arranged array indexes.
   * @returns {Array} Returns `array`.
   */
  function reorder(array, indexes) {
    var arrLength = array.length,
        length = nativeMin(indexes.length, arrLength),
        oldArray = _copyArray(array);

    while (length--) {
      var index = indexes[length];
      array[length] = _isIndex(index, arrLength) ? oldArray[index] : undefined;
    }
    return array;
  }

  var _reorder = reorder;

  /** Used as the internal argument placeholder. */
  var PLACEHOLDER = '__lodash_placeholder__';

  /**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */
  function replaceHolders(array, placeholder) {
    var index = -1,
        length = array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (value === placeholder || value === PLACEHOLDER) {
        array[index] = PLACEHOLDER;
        result[resIndex++] = index;
      }
    }
    return result;
  }

  var _replaceHolders = replaceHolders;

  /** Used to compose bitmasks for function metadata. */
  var WRAP_BIND_FLAG$3 = 1,
      WRAP_BIND_KEY_FLAG$2 = 2,
      WRAP_CURRY_FLAG$2 = 8,
      WRAP_CURRY_RIGHT_FLAG$1 = 16,
      WRAP_ARY_FLAG$1 = 128,
      WRAP_FLIP_FLAG$1 = 512;

  /**
   * Creates a function that wraps `func` to invoke it with optional `this`
   * binding of `thisArg`, partial application, and currying.
   *
   * @private
   * @param {Function|string} func The function or method name to wrap.
   * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
   * @param {*} [thisArg] The `this` binding of `func`.
   * @param {Array} [partials] The arguments to prepend to those provided to
   *  the new function.
   * @param {Array} [holders] The `partials` placeholder indexes.
   * @param {Array} [partialsRight] The arguments to append to those provided
   *  to the new function.
   * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
   * @param {Array} [argPos] The argument positions of the new function.
   * @param {number} [ary] The arity cap of `func`.
   * @param {number} [arity] The arity of `func`.
   * @returns {Function} Returns the new wrapped function.
   */
  function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
    var isAry = bitmask & WRAP_ARY_FLAG$1,
        isBind = bitmask & WRAP_BIND_FLAG$3,
        isBindKey = bitmask & WRAP_BIND_KEY_FLAG$2,
        isCurried = bitmask & (WRAP_CURRY_FLAG$2 | WRAP_CURRY_RIGHT_FLAG$1),
        isFlip = bitmask & WRAP_FLIP_FLAG$1,
        Ctor = isBindKey ? undefined : _createCtor(func);

    function wrapper() {
      var length = arguments.length,
          args = Array(length),
          index = length;

      while (index--) {
        args[index] = arguments[index];
      }
      if (isCurried) {
        var placeholder = _getHolder(wrapper),
            holdersCount = _countHolders(args, placeholder);
      }
      if (partials) {
        args = _composeArgs(args, partials, holders, isCurried);
      }
      if (partialsRight) {
        args = _composeArgsRight(args, partialsRight, holdersRight, isCurried);
      }
      length -= holdersCount;
      if (isCurried && length < arity) {
        var newHolders = _replaceHolders(args, placeholder);
        return _createRecurry(
          func, bitmask, createHybrid, wrapper.placeholder, thisArg,
          args, newHolders, argPos, ary, arity - length
        );
      }
      var thisBinding = isBind ? thisArg : this,
          fn = isBindKey ? thisBinding[func] : func;

      length = args.length;
      if (argPos) {
        args = _reorder(args, argPos);
      } else if (isFlip && length > 1) {
        args.reverse();
      }
      if (isAry && ary < length) {
        args.length = ary;
      }
      if (this && this !== _root && this instanceof wrapper) {
        fn = Ctor || _createCtor(fn);
      }
      return fn.apply(thisBinding, args);
    }
    return wrapper;
  }

  var _createHybrid = createHybrid;

  /**
   * Creates a function that wraps `func` to enable currying.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
   * @param {number} arity The arity of `func`.
   * @returns {Function} Returns the new wrapped function.
   */
  function createCurry(func, bitmask, arity) {
    var Ctor = _createCtor(func);

    function wrapper() {
      var length = arguments.length,
          args = Array(length),
          index = length,
          placeholder = _getHolder(wrapper);

      while (index--) {
        args[index] = arguments[index];
      }
      var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
        ? []
        : _replaceHolders(args, placeholder);

      length -= holders.length;
      if (length < arity) {
        return _createRecurry(
          func, bitmask, _createHybrid, wrapper.placeholder, undefined,
          args, holders, undefined, undefined, arity - length);
      }
      var fn = (this && this !== _root && this instanceof wrapper) ? Ctor : func;
      return _apply(fn, this, args);
    }
    return wrapper;
  }

  var _createCurry = createCurry;

  /** Used to compose bitmasks for function metadata. */
  var WRAP_BIND_FLAG$4 = 1;

  /**
   * Creates a function that wraps `func` to invoke it with the `this` binding
   * of `thisArg` and `partials` prepended to the arguments it receives.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} partials The arguments to prepend to those provided to
   *  the new function.
   * @returns {Function} Returns the new wrapped function.
   */
  function createPartial(func, bitmask, thisArg, partials) {
    var isBind = bitmask & WRAP_BIND_FLAG$4,
        Ctor = _createCtor(func);

    function wrapper() {
      var argsIndex = -1,
          argsLength = arguments.length,
          leftIndex = -1,
          leftLength = partials.length,
          args = Array(leftLength + argsLength),
          fn = (this && this !== _root && this instanceof wrapper) ? Ctor : func;

      while (++leftIndex < leftLength) {
        args[leftIndex] = partials[leftIndex];
      }
      while (argsLength--) {
        args[leftIndex++] = arguments[++argsIndex];
      }
      return _apply(fn, isBind ? thisArg : this, args);
    }
    return wrapper;
  }

  var _createPartial = createPartial;

  /** Used as the internal argument placeholder. */
  var PLACEHOLDER$1 = '__lodash_placeholder__';

  /** Used to compose bitmasks for function metadata. */
  var WRAP_BIND_FLAG$5 = 1,
      WRAP_BIND_KEY_FLAG$3 = 2,
      WRAP_CURRY_BOUND_FLAG$1 = 4,
      WRAP_CURRY_FLAG$3 = 8,
      WRAP_ARY_FLAG$2 = 128,
      WRAP_REARG_FLAG$1 = 256;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeMin$1 = Math.min;

  /**
   * Merges the function metadata of `source` into `data`.
   *
   * Merging metadata reduces the number of wrappers used to invoke a function.
   * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
   * may be applied regardless of execution order. Methods like `_.ary` and
   * `_.rearg` modify function arguments, making the order in which they are
   * executed important, preventing the merging of metadata. However, we make
   * an exception for a safe combined case where curried functions have `_.ary`
   * and or `_.rearg` applied.
   *
   * @private
   * @param {Array} data The destination metadata.
   * @param {Array} source The source metadata.
   * @returns {Array} Returns `data`.
   */
  function mergeData(data, source) {
    var bitmask = data[1],
        srcBitmask = source[1],
        newBitmask = bitmask | srcBitmask,
        isCommon = newBitmask < (WRAP_BIND_FLAG$5 | WRAP_BIND_KEY_FLAG$3 | WRAP_ARY_FLAG$2);

    var isCombo =
      ((srcBitmask == WRAP_ARY_FLAG$2) && (bitmask == WRAP_CURRY_FLAG$3)) ||
      ((srcBitmask == WRAP_ARY_FLAG$2) && (bitmask == WRAP_REARG_FLAG$1) && (data[7].length <= source[8])) ||
      ((srcBitmask == (WRAP_ARY_FLAG$2 | WRAP_REARG_FLAG$1)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG$3));

    // Exit early if metadata can't be merged.
    if (!(isCommon || isCombo)) {
      return data;
    }
    // Use source `thisArg` if available.
    if (srcBitmask & WRAP_BIND_FLAG$5) {
      data[2] = source[2];
      // Set when currying a bound function.
      newBitmask |= bitmask & WRAP_BIND_FLAG$5 ? 0 : WRAP_CURRY_BOUND_FLAG$1;
    }
    // Compose partial arguments.
    var value = source[3];
    if (value) {
      var partials = data[3];
      data[3] = partials ? _composeArgs(partials, value, source[4]) : value;
      data[4] = partials ? _replaceHolders(data[3], PLACEHOLDER$1) : source[4];
    }
    // Compose partial right arguments.
    value = source[5];
    if (value) {
      partials = data[5];
      data[5] = partials ? _composeArgsRight(partials, value, source[6]) : value;
      data[6] = partials ? _replaceHolders(data[5], PLACEHOLDER$1) : source[6];
    }
    // Use source `argPos` if available.
    value = source[7];
    if (value) {
      data[7] = value;
    }
    // Use source `ary` if it's smaller.
    if (srcBitmask & WRAP_ARY_FLAG$2) {
      data[8] = data[8] == null ? source[8] : nativeMin$1(data[8], source[8]);
    }
    // Use source `arity` if one is not provided.
    if (data[9] == null) {
      data[9] = source[9];
    }
    // Use source `func` and merge bitmasks.
    data[0] = source[0];
    data[1] = newBitmask;

    return data;
  }

  var _mergeData = mergeData;

  /** Used as references for various `Number` constants. */
  var NAN = 0 / 0;

  /** Used to match leading and trailing whitespace. */
  var reTrim = /^\s+|\s+$/g;

  /** Used to detect bad signed hexadecimal string values. */
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

  /** Used to detect binary string values. */
  var reIsBinary = /^0b[01]+$/i;

  /** Used to detect octal string values. */
  var reIsOctal = /^0o[0-7]+$/i;

  /** Built-in method references without a dependency on `root`. */
  var freeParseInt = parseInt;

  /**
   * Converts `value` to a number.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to process.
   * @returns {number} Returns the number.
   * @example
   *
   * _.toNumber(3.2);
   * // => 3.2
   *
   * _.toNumber(Number.MIN_VALUE);
   * // => 5e-324
   *
   * _.toNumber(Infinity);
   * // => Infinity
   *
   * _.toNumber('3.2');
   * // => 3.2
   */
  function toNumber(value) {
    if (typeof value == 'number') {
      return value;
    }
    if (isSymbol_1(value)) {
      return NAN;
    }
    if (isObject_1(value)) {
      var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
      value = isObject_1(other) ? (other + '') : other;
    }
    if (typeof value != 'string') {
      return value === 0 ? value : +value;
    }
    value = value.replace(reTrim, '');
    var isBinary = reIsBinary.test(value);
    return (isBinary || reIsOctal.test(value))
      ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
      : (reIsBadHex.test(value) ? NAN : +value);
  }

  var toNumber_1 = toNumber;

  /** Used as references for various `Number` constants. */
  var INFINITY$2 = 1 / 0,
      MAX_INTEGER = 1.7976931348623157e+308;

  /**
   * Converts `value` to a finite number.
   *
   * @static
   * @memberOf _
   * @since 4.12.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {number} Returns the converted number.
   * @example
   *
   * _.toFinite(3.2);
   * // => 3.2
   *
   * _.toFinite(Number.MIN_VALUE);
   * // => 5e-324
   *
   * _.toFinite(Infinity);
   * // => 1.7976931348623157e+308
   *
   * _.toFinite('3.2');
   * // => 3.2
   */
  function toFinite(value) {
    if (!value) {
      return value === 0 ? value : 0;
    }
    value = toNumber_1(value);
    if (value === INFINITY$2 || value === -INFINITY$2) {
      var sign = (value < 0 ? -1 : 1);
      return sign * MAX_INTEGER;
    }
    return value === value ? value : 0;
  }

  var toFinite_1 = toFinite;

  /**
   * Converts `value` to an integer.
   *
   * **Note:** This method is loosely based on
   * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {number} Returns the converted integer.
   * @example
   *
   * _.toInteger(3.2);
   * // => 3
   *
   * _.toInteger(Number.MIN_VALUE);
   * // => 0
   *
   * _.toInteger(Infinity);
   * // => 1.7976931348623157e+308
   *
   * _.toInteger('3.2');
   * // => 3
   */
  function toInteger(value) {
    var result = toFinite_1(value),
        remainder = result % 1;

    return result === result ? (remainder ? result - remainder : result) : 0;
  }

  var toInteger_1 = toInteger;

  /** Error message constants. */
  var FUNC_ERROR_TEXT$1 = 'Expected a function';

  /** Used to compose bitmasks for function metadata. */
  var WRAP_BIND_FLAG$6 = 1,
      WRAP_BIND_KEY_FLAG$4 = 2,
      WRAP_CURRY_FLAG$4 = 8,
      WRAP_CURRY_RIGHT_FLAG$2 = 16,
      WRAP_PARTIAL_FLAG$2 = 32,
      WRAP_PARTIAL_RIGHT_FLAG$2 = 64;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeMax$3 = Math.max;

  /**
   * Creates a function that either curries or invokes `func` with optional
   * `this` binding and partially applied arguments.
   *
   * @private
   * @param {Function|string} func The function or method name to wrap.
   * @param {number} bitmask The bitmask flags.
   *    1 - `_.bind`
   *    2 - `_.bindKey`
   *    4 - `_.curry` or `_.curryRight` of a bound function
   *    8 - `_.curry`
   *   16 - `_.curryRight`
   *   32 - `_.partial`
   *   64 - `_.partialRight`
   *  128 - `_.rearg`
   *  256 - `_.ary`
   *  512 - `_.flip`
   * @param {*} [thisArg] The `this` binding of `func`.
   * @param {Array} [partials] The arguments to be partially applied.
   * @param {Array} [holders] The `partials` placeholder indexes.
   * @param {Array} [argPos] The argument positions of the new function.
   * @param {number} [ary] The arity cap of `func`.
   * @param {number} [arity] The arity of `func`.
   * @returns {Function} Returns the new wrapped function.
   */
  function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
    var isBindKey = bitmask & WRAP_BIND_KEY_FLAG$4;
    if (!isBindKey && typeof func != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT$1);
    }
    var length = partials ? partials.length : 0;
    if (!length) {
      bitmask &= ~(WRAP_PARTIAL_FLAG$2 | WRAP_PARTIAL_RIGHT_FLAG$2);
      partials = holders = undefined;
    }
    ary = ary === undefined ? ary : nativeMax$3(toInteger_1(ary), 0);
    arity = arity === undefined ? arity : toInteger_1(arity);
    length -= holders ? holders.length : 0;

    if (bitmask & WRAP_PARTIAL_RIGHT_FLAG$2) {
      var partialsRight = partials,
          holdersRight = holders;

      partials = holders = undefined;
    }
    var data = isBindKey ? undefined : _getData(func);

    var newData = [
      func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
      argPos, ary, arity
    ];

    if (data) {
      _mergeData(newData, data);
    }
    func = newData[0];
    bitmask = newData[1];
    thisArg = newData[2];
    partials = newData[3];
    holders = newData[4];
    arity = newData[9] = newData[9] === undefined
      ? (isBindKey ? 0 : func.length)
      : nativeMax$3(newData[9] - length, 0);

    if (!arity && bitmask & (WRAP_CURRY_FLAG$4 | WRAP_CURRY_RIGHT_FLAG$2)) {
      bitmask &= ~(WRAP_CURRY_FLAG$4 | WRAP_CURRY_RIGHT_FLAG$2);
    }
    if (!bitmask || bitmask == WRAP_BIND_FLAG$6) {
      var result = _createBind(func, bitmask, thisArg);
    } else if (bitmask == WRAP_CURRY_FLAG$4 || bitmask == WRAP_CURRY_RIGHT_FLAG$2) {
      result = _createCurry(func, bitmask, arity);
    } else if ((bitmask == WRAP_PARTIAL_FLAG$2 || bitmask == (WRAP_BIND_FLAG$6 | WRAP_PARTIAL_FLAG$2)) && !holders.length) {
      result = _createPartial(func, bitmask, thisArg, partials);
    } else {
      result = _createHybrid.apply(undefined, newData);
    }
    var setter = data ? _baseSetData : _setData;
    return _setWrapToString(setter(result, newData), func, bitmask);
  }

  var _createWrap = createWrap;

  /** Used to compose bitmasks for function metadata. */
  var WRAP_BIND_FLAG$7 = 1,
      WRAP_PARTIAL_FLAG$3 = 32;

  /**
   * Creates a function that invokes `func` with the `this` binding of `thisArg`
   * and `partials` prepended to the arguments it receives.
   *
   * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
   * may be used as a placeholder for partially applied arguments.
   *
   * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
   * property of bound functions.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to bind.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {...*} [partials] The arguments to be partially applied.
   * @returns {Function} Returns the new bound function.
   * @example
   *
   * function greet(greeting, punctuation) {
   *   return greeting + ' ' + this.user + punctuation;
   * }
   *
   * var object = { 'user': 'fred' };
   *
   * var bound = _.bind(greet, object, 'hi');
   * bound('!');
   * // => 'hi fred!'
   *
   * // Bound with placeholders.
   * var bound = _.bind(greet, object, _, '!');
   * bound('hi');
   * // => 'hi fred!'
   */
  var bind = _baseRest(function(func, thisArg, partials) {
    var bitmask = WRAP_BIND_FLAG$7;
    if (partials.length) {
      var holders = _replaceHolders(partials, _getHolder(bind));
      bitmask |= WRAP_PARTIAL_FLAG$3;
    }
    return _createWrap(func, bitmask, thisArg, partials, holders);
  });

  // Assign default placeholders.
  bind.placeholder = {};

  var bind_1 = bind;

  var axios = createCommonjsModule(function (module, exports) {
  /* axios v0.18.0 | (c) 2018 by Matt Zabriskie */
  (function webpackUniversalModuleDefinition(root, factory) {
  	module.exports = factory();
  })(commonjsGlobal, function() {
  return /******/ (function(modules) { // webpackBootstrap
  /******/ 	// The module cache
  /******/ 	var installedModules = {};
  /******/
  /******/ 	// The require function
  /******/ 	function __webpack_require__(moduleId) {
  /******/
  /******/ 		// Check if module is in cache
  /******/ 		if(installedModules[moduleId])
  /******/ 			return installedModules[moduleId].exports;
  /******/
  /******/ 		// Create a new module (and put it into the cache)
  /******/ 		var module = installedModules[moduleId] = {
  /******/ 			exports: {},
  /******/ 			id: moduleId,
  /******/ 			loaded: false
  /******/ 		};
  /******/
  /******/ 		// Execute the module function
  /******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
  /******/
  /******/ 		// Flag the module as loaded
  /******/ 		module.loaded = true;
  /******/
  /******/ 		// Return the exports of the module
  /******/ 		return module.exports;
  /******/ 	}
  /******/
  /******/
  /******/ 	// expose the modules object (__webpack_modules__)
  /******/ 	__webpack_require__.m = modules;
  /******/
  /******/ 	// expose the module cache
  /******/ 	__webpack_require__.c = installedModules;
  /******/
  /******/ 	// __webpack_public_path__
  /******/ 	__webpack_require__.p = "";
  /******/
  /******/ 	// Load entry module and return exports
  /******/ 	return __webpack_require__(0);
  /******/ })
  /************************************************************************/
  /******/ ([
  /* 0 */
  /***/ (function(module, exports, __webpack_require__) {

  	module.exports = __webpack_require__(1);

  /***/ }),
  /* 1 */
  /***/ (function(module, exports, __webpack_require__) {
  	
  	var utils = __webpack_require__(2);
  	var bind = __webpack_require__(3);
  	var Axios = __webpack_require__(5);
  	var defaults = __webpack_require__(6);
  	
  	/**
  	 * Create an instance of Axios
  	 *
  	 * @param {Object} defaultConfig The default config for the instance
  	 * @return {Axios} A new instance of Axios
  	 */
  	function createInstance(defaultConfig) {
  	  var context = new Axios(defaultConfig);
  	  var instance = bind(Axios.prototype.request, context);
  	
  	  // Copy axios.prototype to instance
  	  utils.extend(instance, Axios.prototype, context);
  	
  	  // Copy context to instance
  	  utils.extend(instance, context);
  	
  	  return instance;
  	}
  	
  	// Create the default instance to be exported
  	var axios = createInstance(defaults);
  	
  	// Expose Axios class to allow class inheritance
  	axios.Axios = Axios;
  	
  	// Factory for creating new instances
  	axios.create = function create(instanceConfig) {
  	  return createInstance(utils.merge(defaults, instanceConfig));
  	};
  	
  	// Expose Cancel & CancelToken
  	axios.Cancel = __webpack_require__(23);
  	axios.CancelToken = __webpack_require__(24);
  	axios.isCancel = __webpack_require__(20);
  	
  	// Expose all/spread
  	axios.all = function all(promises) {
  	  return Promise.all(promises);
  	};
  	axios.spread = __webpack_require__(25);
  	
  	module.exports = axios;
  	
  	// Allow use of default import syntax in TypeScript
  	module.exports.default = axios;


  /***/ }),
  /* 2 */
  /***/ (function(module, exports, __webpack_require__) {
  	
  	var bind = __webpack_require__(3);
  	var isBuffer = __webpack_require__(4);
  	
  	/*global toString:true*/
  	
  	// utils is a library of generic helper functions non-specific to axios
  	
  	var toString = Object.prototype.toString;
  	
  	/**
  	 * Determine if a value is an Array
  	 *
  	 * @param {Object} val The value to test
  	 * @returns {boolean} True if value is an Array, otherwise false
  	 */
  	function isArray(val) {
  	  return toString.call(val) === '[object Array]';
  	}
  	
  	/**
  	 * Determine if a value is an ArrayBuffer
  	 *
  	 * @param {Object} val The value to test
  	 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
  	 */
  	function isArrayBuffer(val) {
  	  return toString.call(val) === '[object ArrayBuffer]';
  	}
  	
  	/**
  	 * Determine if a value is a FormData
  	 *
  	 * @param {Object} val The value to test
  	 * @returns {boolean} True if value is an FormData, otherwise false
  	 */
  	function isFormData(val) {
  	  return (typeof FormData !== 'undefined') && (val instanceof FormData);
  	}
  	
  	/**
  	 * Determine if a value is a view on an ArrayBuffer
  	 *
  	 * @param {Object} val The value to test
  	 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
  	 */
  	function isArrayBufferView(val) {
  	  var result;
  	  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
  	    result = ArrayBuffer.isView(val);
  	  } else {
  	    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
  	  }
  	  return result;
  	}
  	
  	/**
  	 * Determine if a value is a String
  	 *
  	 * @param {Object} val The value to test
  	 * @returns {boolean} True if value is a String, otherwise false
  	 */
  	function isString(val) {
  	  return typeof val === 'string';
  	}
  	
  	/**
  	 * Determine if a value is a Number
  	 *
  	 * @param {Object} val The value to test
  	 * @returns {boolean} True if value is a Number, otherwise false
  	 */
  	function isNumber(val) {
  	  return typeof val === 'number';
  	}
  	
  	/**
  	 * Determine if a value is undefined
  	 *
  	 * @param {Object} val The value to test
  	 * @returns {boolean} True if the value is undefined, otherwise false
  	 */
  	function isUndefined(val) {
  	  return typeof val === 'undefined';
  	}
  	
  	/**
  	 * Determine if a value is an Object
  	 *
  	 * @param {Object} val The value to test
  	 * @returns {boolean} True if value is an Object, otherwise false
  	 */
  	function isObject(val) {
  	  return val !== null && typeof val === 'object';
  	}
  	
  	/**
  	 * Determine if a value is a Date
  	 *
  	 * @param {Object} val The value to test
  	 * @returns {boolean} True if value is a Date, otherwise false
  	 */
  	function isDate(val) {
  	  return toString.call(val) === '[object Date]';
  	}
  	
  	/**
  	 * Determine if a value is a File
  	 *
  	 * @param {Object} val The value to test
  	 * @returns {boolean} True if value is a File, otherwise false
  	 */
  	function isFile(val) {
  	  return toString.call(val) === '[object File]';
  	}
  	
  	/**
  	 * Determine if a value is a Blob
  	 *
  	 * @param {Object} val The value to test
  	 * @returns {boolean} True if value is a Blob, otherwise false
  	 */
  	function isBlob(val) {
  	  return toString.call(val) === '[object Blob]';
  	}
  	
  	/**
  	 * Determine if a value is a Function
  	 *
  	 * @param {Object} val The value to test
  	 * @returns {boolean} True if value is a Function, otherwise false
  	 */
  	function isFunction(val) {
  	  return toString.call(val) === '[object Function]';
  	}
  	
  	/**
  	 * Determine if a value is a Stream
  	 *
  	 * @param {Object} val The value to test
  	 * @returns {boolean} True if value is a Stream, otherwise false
  	 */
  	function isStream(val) {
  	  return isObject(val) && isFunction(val.pipe);
  	}
  	
  	/**
  	 * Determine if a value is a URLSearchParams object
  	 *
  	 * @param {Object} val The value to test
  	 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
  	 */
  	function isURLSearchParams(val) {
  	  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
  	}
  	
  	/**
  	 * Trim excess whitespace off the beginning and end of a string
  	 *
  	 * @param {String} str The String to trim
  	 * @returns {String} The String freed of excess whitespace
  	 */
  	function trim(str) {
  	  return str.replace(/^\s*/, '').replace(/\s*$/, '');
  	}
  	
  	/**
  	 * Determine if we're running in a standard browser environment
  	 *
  	 * This allows axios to run in a web worker, and react-native.
  	 * Both environments support XMLHttpRequest, but not fully standard globals.
  	 *
  	 * web workers:
  	 *  typeof window -> undefined
  	 *  typeof document -> undefined
  	 *
  	 * react-native:
  	 *  navigator.product -> 'ReactNative'
  	 */
  	function isStandardBrowserEnv() {
  	  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {
  	    return false;
  	  }
  	  return (
  	    typeof window !== 'undefined' &&
  	    typeof document !== 'undefined'
  	  );
  	}
  	
  	/**
  	 * Iterate over an Array or an Object invoking a function for each item.
  	 *
  	 * If `obj` is an Array callback will be called passing
  	 * the value, index, and complete array for each item.
  	 *
  	 * If 'obj' is an Object callback will be called passing
  	 * the value, key, and complete object for each property.
  	 *
  	 * @param {Object|Array} obj The object to iterate
  	 * @param {Function} fn The callback to invoke for each item
  	 */
  	function forEach(obj, fn) {
  	  // Don't bother if no value provided
  	  if (obj === null || typeof obj === 'undefined') {
  	    return;
  	  }
  	
  	  // Force an array if not already something iterable
  	  if (typeof obj !== 'object') {
  	    /*eslint no-param-reassign:0*/
  	    obj = [obj];
  	  }
  	
  	  if (isArray(obj)) {
  	    // Iterate over array values
  	    for (var i = 0, l = obj.length; i < l; i++) {
  	      fn.call(null, obj[i], i, obj);
  	    }
  	  } else {
  	    // Iterate over object keys
  	    for (var key in obj) {
  	      if (Object.prototype.hasOwnProperty.call(obj, key)) {
  	        fn.call(null, obj[key], key, obj);
  	      }
  	    }
  	  }
  	}
  	
  	/**
  	 * Accepts varargs expecting each argument to be an object, then
  	 * immutably merges the properties of each object and returns result.
  	 *
  	 * When multiple objects contain the same key the later object in
  	 * the arguments list will take precedence.
  	 *
  	 * Example:
  	 *
  	 * ```js
  	 * var result = merge({foo: 123}, {foo: 456});
  	 * console.log(result.foo); // outputs 456
  	 * ```
  	 *
  	 * @param {Object} obj1 Object to merge
  	 * @returns {Object} Result of all merge properties
  	 */
  	function merge(/* obj1, obj2, obj3, ... */) {
  	  var result = {};
  	  function assignValue(val, key) {
  	    if (typeof result[key] === 'object' && typeof val === 'object') {
  	      result[key] = merge(result[key], val);
  	    } else {
  	      result[key] = val;
  	    }
  	  }
  	
  	  for (var i = 0, l = arguments.length; i < l; i++) {
  	    forEach(arguments[i], assignValue);
  	  }
  	  return result;
  	}
  	
  	/**
  	 * Extends object a by mutably adding to it the properties of object b.
  	 *
  	 * @param {Object} a The object to be extended
  	 * @param {Object} b The object to copy properties from
  	 * @param {Object} thisArg The object to bind function to
  	 * @return {Object} The resulting value of object a
  	 */
  	function extend(a, b, thisArg) {
  	  forEach(b, function assignValue(val, key) {
  	    if (thisArg && typeof val === 'function') {
  	      a[key] = bind(val, thisArg);
  	    } else {
  	      a[key] = val;
  	    }
  	  });
  	  return a;
  	}
  	
  	module.exports = {
  	  isArray: isArray,
  	  isArrayBuffer: isArrayBuffer,
  	  isBuffer: isBuffer,
  	  isFormData: isFormData,
  	  isArrayBufferView: isArrayBufferView,
  	  isString: isString,
  	  isNumber: isNumber,
  	  isObject: isObject,
  	  isUndefined: isUndefined,
  	  isDate: isDate,
  	  isFile: isFile,
  	  isBlob: isBlob,
  	  isFunction: isFunction,
  	  isStream: isStream,
  	  isURLSearchParams: isURLSearchParams,
  	  isStandardBrowserEnv: isStandardBrowserEnv,
  	  forEach: forEach,
  	  merge: merge,
  	  extend: extend,
  	  trim: trim
  	};


  /***/ }),
  /* 3 */
  /***/ (function(module, exports) {
  	
  	module.exports = function bind(fn, thisArg) {
  	  return function wrap() {
  	    var args = new Array(arguments.length);
  	    for (var i = 0; i < args.length; i++) {
  	      args[i] = arguments[i];
  	    }
  	    return fn.apply(thisArg, args);
  	  };
  	};


  /***/ }),
  /* 4 */
  /***/ (function(module, exports) {

  	/*!
  	 * Determine if an object is a Buffer
  	 *
  	 * @author   Feross Aboukhadijeh <https://feross.org>
  	 * @license  MIT
  	 */
  	
  	// The _isBuffer check is for Safari 5-7 support, because it's missing
  	// Object.prototype.constructor. Remove this eventually
  	module.exports = function (obj) {
  	  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
  	};
  	
  	function isBuffer (obj) {
  	  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
  	}
  	
  	// For Node v0.10 support. Remove this eventually.
  	function isSlowBuffer (obj) {
  	  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
  	}


  /***/ }),
  /* 5 */
  /***/ (function(module, exports, __webpack_require__) {
  	
  	var defaults = __webpack_require__(6);
  	var utils = __webpack_require__(2);
  	var InterceptorManager = __webpack_require__(17);
  	var dispatchRequest = __webpack_require__(18);
  	
  	/**
  	 * Create a new instance of Axios
  	 *
  	 * @param {Object} instanceConfig The default config for the instance
  	 */
  	function Axios(instanceConfig) {
  	  this.defaults = instanceConfig;
  	  this.interceptors = {
  	    request: new InterceptorManager(),
  	    response: new InterceptorManager()
  	  };
  	}
  	
  	/**
  	 * Dispatch a request
  	 *
  	 * @param {Object} config The config specific for this request (merged with this.defaults)
  	 */
  	Axios.prototype.request = function request(config) {
  	  /*eslint no-param-reassign:0*/
  	  // Allow for axios('example/url'[, config]) a la fetch API
  	  if (typeof config === 'string') {
  	    config = utils.merge({
  	      url: arguments[0]
  	    }, arguments[1]);
  	  }
  	
  	  config = utils.merge(defaults, {method: 'get'}, this.defaults, config);
  	  config.method = config.method.toLowerCase();
  	
  	  // Hook up interceptors middleware
  	  var chain = [dispatchRequest, undefined];
  	  var promise = Promise.resolve(config);
  	
  	  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
  	    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  	  });
  	
  	  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
  	    chain.push(interceptor.fulfilled, interceptor.rejected);
  	  });
  	
  	  while (chain.length) {
  	    promise = promise.then(chain.shift(), chain.shift());
  	  }
  	
  	  return promise;
  	};
  	
  	// Provide aliases for supported request methods
  	utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  	  /*eslint func-names:0*/
  	  Axios.prototype[method] = function(url, config) {
  	    return this.request(utils.merge(config || {}, {
  	      method: method,
  	      url: url
  	    }));
  	  };
  	});
  	
  	utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  	  /*eslint func-names:0*/
  	  Axios.prototype[method] = function(url, data, config) {
  	    return this.request(utils.merge(config || {}, {
  	      method: method,
  	      url: url,
  	      data: data
  	    }));
  	  };
  	});
  	
  	module.exports = Axios;


  /***/ }),
  /* 6 */
  /***/ (function(module, exports, __webpack_require__) {
  	
  	var utils = __webpack_require__(2);
  	var normalizeHeaderName = __webpack_require__(7);
  	
  	var DEFAULT_CONTENT_TYPE = {
  	  'Content-Type': 'application/x-www-form-urlencoded'
  	};
  	
  	function setContentTypeIfUnset(headers, value) {
  	  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
  	    headers['Content-Type'] = value;
  	  }
  	}
  	
  	function getDefaultAdapter() {
  	  var adapter;
  	  if (typeof XMLHttpRequest !== 'undefined') {
  	    // For browsers use XHR adapter
  	    adapter = __webpack_require__(8);
  	  } else if (typeof process !== 'undefined') {
  	    // For node use HTTP adapter
  	    adapter = __webpack_require__(8);
  	  }
  	  return adapter;
  	}
  	
  	var defaults = {
  	  adapter: getDefaultAdapter(),
  	
  	  transformRequest: [function transformRequest(data, headers) {
  	    normalizeHeaderName(headers, 'Content-Type');
  	    if (utils.isFormData(data) ||
  	      utils.isArrayBuffer(data) ||
  	      utils.isBuffer(data) ||
  	      utils.isStream(data) ||
  	      utils.isFile(data) ||
  	      utils.isBlob(data)
  	    ) {
  	      return data;
  	    }
  	    if (utils.isArrayBufferView(data)) {
  	      return data.buffer;
  	    }
  	    if (utils.isURLSearchParams(data)) {
  	      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
  	      return data.toString();
  	    }
  	    if (utils.isObject(data)) {
  	      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
  	      return JSON.stringify(data);
  	    }
  	    return data;
  	  }],
  	
  	  transformResponse: [function transformResponse(data) {
  	    /*eslint no-param-reassign:0*/
  	    if (typeof data === 'string') {
  	      try {
  	        data = JSON.parse(data);
  	      } catch (e) { /* Ignore */ }
  	    }
  	    return data;
  	  }],
  	
  	  /**
  	   * A timeout in milliseconds to abort a request. If set to 0 (default) a
  	   * timeout is not created.
  	   */
  	  timeout: 0,
  	
  	  xsrfCookieName: 'XSRF-TOKEN',
  	  xsrfHeaderName: 'X-XSRF-TOKEN',
  	
  	  maxContentLength: -1,
  	
  	  validateStatus: function validateStatus(status) {
  	    return status >= 200 && status < 300;
  	  }
  	};
  	
  	defaults.headers = {
  	  common: {
  	    'Accept': 'application/json, text/plain, */*'
  	  }
  	};
  	
  	utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  	  defaults.headers[method] = {};
  	});
  	
  	utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  	  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
  	});
  	
  	module.exports = defaults;


  /***/ }),
  /* 7 */
  /***/ (function(module, exports, __webpack_require__) {
  	
  	var utils = __webpack_require__(2);
  	
  	module.exports = function normalizeHeaderName(headers, normalizedName) {
  	  utils.forEach(headers, function processHeader(value, name) {
  	    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
  	      headers[normalizedName] = value;
  	      delete headers[name];
  	    }
  	  });
  	};


  /***/ }),
  /* 8 */
  /***/ (function(module, exports, __webpack_require__) {
  	
  	var utils = __webpack_require__(2);
  	var settle = __webpack_require__(9);
  	var buildURL = __webpack_require__(12);
  	var parseHeaders = __webpack_require__(13);
  	var isURLSameOrigin = __webpack_require__(14);
  	var createError = __webpack_require__(10);
  	var btoa = (typeof window !== 'undefined' && window.btoa && window.btoa.bind(window)) || __webpack_require__(15);
  	
  	module.exports = function xhrAdapter(config) {
  	  return new Promise(function dispatchXhrRequest(resolve, reject) {
  	    var requestData = config.data;
  	    var requestHeaders = config.headers;
  	
  	    if (utils.isFormData(requestData)) {
  	      delete requestHeaders['Content-Type']; // Let the browser set it
  	    }
  	
  	    var request = new XMLHttpRequest();
  	    var loadEvent = 'onreadystatechange';
  	    var xDomain = false;
  	
  	    // For IE 8/9 CORS support
  	    // Only supports POST and GET calls and doesn't returns the response headers.
  	    // DON'T do this for testing b/c XMLHttpRequest is mocked, not XDomainRequest.
  	    if (("production") !== 'test' &&
  	        typeof window !== 'undefined' &&
  	        window.XDomainRequest && !('withCredentials' in request) &&
  	        !isURLSameOrigin(config.url)) {
  	      request = new window.XDomainRequest();
  	      loadEvent = 'onload';
  	      xDomain = true;
  	      request.onprogress = function handleProgress() {};
  	      request.ontimeout = function handleTimeout() {};
  	    }
  	
  	    // HTTP basic authentication
  	    if (config.auth) {
  	      var username = config.auth.username || '';
  	      var password = config.auth.password || '';
  	      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
  	    }
  	
  	    request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true);
  	
  	    // Set the request timeout in MS
  	    request.timeout = config.timeout;
  	
  	    // Listen for ready state
  	    request[loadEvent] = function handleLoad() {
  	      if (!request || (request.readyState !== 4 && !xDomain)) {
  	        return;
  	      }
  	
  	      // The request errored out and we didn't get a response, this will be
  	      // handled by onerror instead
  	      // With one exception: request that using file: protocol, most browsers
  	      // will return status as 0 even though it's a successful request
  	      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
  	        return;
  	      }
  	
  	      // Prepare the response
  	      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
  	      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
  	      var response = {
  	        data: responseData,
  	        // IE sends 1223 instead of 204 (https://github.com/axios/axios/issues/201)
  	        status: request.status === 1223 ? 204 : request.status,
  	        statusText: request.status === 1223 ? 'No Content' : request.statusText,
  	        headers: responseHeaders,
  	        config: config,
  	        request: request
  	      };
  	
  	      settle(resolve, reject, response);
  	
  	      // Clean up request
  	      request = null;
  	    };
  	
  	    // Handle low level network errors
  	    request.onerror = function handleError() {
  	      // Real errors are hidden from us by the browser
  	      // onerror should only fire if it's a network error
  	      reject(createError('Network Error', config, null, request));
  	
  	      // Clean up request
  	      request = null;
  	    };
  	
  	    // Handle timeout
  	    request.ontimeout = function handleTimeout() {
  	      reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED',
  	        request));
  	
  	      // Clean up request
  	      request = null;
  	    };
  	
  	    // Add xsrf header
  	    // This is only done if running in a standard browser environment.
  	    // Specifically not if we're in a web worker, or react-native.
  	    if (utils.isStandardBrowserEnv()) {
  	      var cookies = __webpack_require__(16);
  	
  	      // Add xsrf header
  	      var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ?
  	          cookies.read(config.xsrfCookieName) :
  	          undefined;
  	
  	      if (xsrfValue) {
  	        requestHeaders[config.xsrfHeaderName] = xsrfValue;
  	      }
  	    }
  	
  	    // Add headers to the request
  	    if ('setRequestHeader' in request) {
  	      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
  	        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
  	          // Remove Content-Type if data is undefined
  	          delete requestHeaders[key];
  	        } else {
  	          // Otherwise add header to the request
  	          request.setRequestHeader(key, val);
  	        }
  	      });
  	    }
  	
  	    // Add withCredentials to request if needed
  	    if (config.withCredentials) {
  	      request.withCredentials = true;
  	    }
  	
  	    // Add responseType to request if needed
  	    if (config.responseType) {
  	      try {
  	        request.responseType = config.responseType;
  	      } catch (e) {
  	        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
  	        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
  	        if (config.responseType !== 'json') {
  	          throw e;
  	        }
  	      }
  	    }
  	
  	    // Handle progress if needed
  	    if (typeof config.onDownloadProgress === 'function') {
  	      request.addEventListener('progress', config.onDownloadProgress);
  	    }
  	
  	    // Not all browsers support upload events
  	    if (typeof config.onUploadProgress === 'function' && request.upload) {
  	      request.upload.addEventListener('progress', config.onUploadProgress);
  	    }
  	
  	    if (config.cancelToken) {
  	      // Handle cancellation
  	      config.cancelToken.promise.then(function onCanceled(cancel) {
  	        if (!request) {
  	          return;
  	        }
  	
  	        request.abort();
  	        reject(cancel);
  	        // Clean up request
  	        request = null;
  	      });
  	    }
  	
  	    if (requestData === undefined) {
  	      requestData = null;
  	    }
  	
  	    // Send the request
  	    request.send(requestData);
  	  });
  	};


  /***/ }),
  /* 9 */
  /***/ (function(module, exports, __webpack_require__) {
  	
  	var createError = __webpack_require__(10);
  	
  	/**
  	 * Resolve or reject a Promise based on response status.
  	 *
  	 * @param {Function} resolve A function that resolves the promise.
  	 * @param {Function} reject A function that rejects the promise.
  	 * @param {object} response The response.
  	 */
  	module.exports = function settle(resolve, reject, response) {
  	  var validateStatus = response.config.validateStatus;
  	  // Note: status is not exposed by XDomainRequest
  	  if (!response.status || !validateStatus || validateStatus(response.status)) {
  	    resolve(response);
  	  } else {
  	    reject(createError(
  	      'Request failed with status code ' + response.status,
  	      response.config,
  	      null,
  	      response.request,
  	      response
  	    ));
  	  }
  	};


  /***/ }),
  /* 10 */
  /***/ (function(module, exports, __webpack_require__) {
  	
  	var enhanceError = __webpack_require__(11);
  	
  	/**
  	 * Create an Error with the specified message, config, error code, request and response.
  	 *
  	 * @param {string} message The error message.
  	 * @param {Object} config The config.
  	 * @param {string} [code] The error code (for example, 'ECONNABORTED').
  	 * @param {Object} [request] The request.
  	 * @param {Object} [response] The response.
  	 * @returns {Error} The created error.
  	 */
  	module.exports = function createError(message, config, code, request, response) {
  	  var error = new Error(message);
  	  return enhanceError(error, config, code, request, response);
  	};


  /***/ }),
  /* 11 */
  /***/ (function(module, exports) {
  	
  	/**
  	 * Update an Error with the specified config, error code, and response.
  	 *
  	 * @param {Error} error The error to update.
  	 * @param {Object} config The config.
  	 * @param {string} [code] The error code (for example, 'ECONNABORTED').
  	 * @param {Object} [request] The request.
  	 * @param {Object} [response] The response.
  	 * @returns {Error} The error.
  	 */
  	module.exports = function enhanceError(error, config, code, request, response) {
  	  error.config = config;
  	  if (code) {
  	    error.code = code;
  	  }
  	  error.request = request;
  	  error.response = response;
  	  return error;
  	};


  /***/ }),
  /* 12 */
  /***/ (function(module, exports, __webpack_require__) {
  	
  	var utils = __webpack_require__(2);
  	
  	function encode(val) {
  	  return encodeURIComponent(val).
  	    replace(/%40/gi, '@').
  	    replace(/%3A/gi, ':').
  	    replace(/%24/g, '$').
  	    replace(/%2C/gi, ',').
  	    replace(/%20/g, '+').
  	    replace(/%5B/gi, '[').
  	    replace(/%5D/gi, ']');
  	}
  	
  	/**
  	 * Build a URL by appending params to the end
  	 *
  	 * @param {string} url The base of the url (e.g., http://www.google.com)
  	 * @param {object} [params] The params to be appended
  	 * @returns {string} The formatted url
  	 */
  	module.exports = function buildURL(url, params, paramsSerializer) {
  	  /*eslint no-param-reassign:0*/
  	  if (!params) {
  	    return url;
  	  }
  	
  	  var serializedParams;
  	  if (paramsSerializer) {
  	    serializedParams = paramsSerializer(params);
  	  } else if (utils.isURLSearchParams(params)) {
  	    serializedParams = params.toString();
  	  } else {
  	    var parts = [];
  	
  	    utils.forEach(params, function serialize(val, key) {
  	      if (val === null || typeof val === 'undefined') {
  	        return;
  	      }
  	
  	      if (utils.isArray(val)) {
  	        key = key + '[]';
  	      } else {
  	        val = [val];
  	      }
  	
  	      utils.forEach(val, function parseValue(v) {
  	        if (utils.isDate(v)) {
  	          v = v.toISOString();
  	        } else if (utils.isObject(v)) {
  	          v = JSON.stringify(v);
  	        }
  	        parts.push(encode(key) + '=' + encode(v));
  	      });
  	    });
  	
  	    serializedParams = parts.join('&');
  	  }
  	
  	  if (serializedParams) {
  	    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  	  }
  	
  	  return url;
  	};


  /***/ }),
  /* 13 */
  /***/ (function(module, exports, __webpack_require__) {
  	
  	var utils = __webpack_require__(2);
  	
  	// Headers whose duplicates are ignored by node
  	// c.f. https://nodejs.org/api/http.html#http_message_headers
  	var ignoreDuplicateOf = [
  	  'age', 'authorization', 'content-length', 'content-type', 'etag',
  	  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  	  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  	  'referer', 'retry-after', 'user-agent'
  	];
  	
  	/**
  	 * Parse headers into an object
  	 *
  	 * ```
  	 * Date: Wed, 27 Aug 2014 08:58:49 GMT
  	 * Content-Type: application/json
  	 * Connection: keep-alive
  	 * Transfer-Encoding: chunked
  	 * ```
  	 *
  	 * @param {String} headers Headers needing to be parsed
  	 * @returns {Object} Headers parsed into an object
  	 */
  	module.exports = function parseHeaders(headers) {
  	  var parsed = {};
  	  var key;
  	  var val;
  	  var i;
  	
  	  if (!headers) { return parsed; }
  	
  	  utils.forEach(headers.split('\n'), function parser(line) {
  	    i = line.indexOf(':');
  	    key = utils.trim(line.substr(0, i)).toLowerCase();
  	    val = utils.trim(line.substr(i + 1));
  	
  	    if (key) {
  	      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
  	        return;
  	      }
  	      if (key === 'set-cookie') {
  	        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
  	      } else {
  	        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
  	      }
  	    }
  	  });
  	
  	  return parsed;
  	};


  /***/ }),
  /* 14 */
  /***/ (function(module, exports, __webpack_require__) {
  	
  	var utils = __webpack_require__(2);
  	
  	module.exports = (
  	  utils.isStandardBrowserEnv() ?
  	
  	  // Standard browser envs have full support of the APIs needed to test
  	  // whether the request URL is of the same origin as current location.
  	  (function standardBrowserEnv() {
  	    var msie = /(msie|trident)/i.test(navigator.userAgent);
  	    var urlParsingNode = document.createElement('a');
  	    var originURL;
  	
  	    /**
  	    * Parse a URL to discover it's components
  	    *
  	    * @param {String} url The URL to be parsed
  	    * @returns {Object}
  	    */
  	    function resolveURL(url) {
  	      var href = url;
  	
  	      if (msie) {
  	        // IE needs attribute set twice to normalize properties
  	        urlParsingNode.setAttribute('href', href);
  	        href = urlParsingNode.href;
  	      }
  	
  	      urlParsingNode.setAttribute('href', href);
  	
  	      // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
  	      return {
  	        href: urlParsingNode.href,
  	        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
  	        host: urlParsingNode.host,
  	        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
  	        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
  	        hostname: urlParsingNode.hostname,
  	        port: urlParsingNode.port,
  	        pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
  	                  urlParsingNode.pathname :
  	                  '/' + urlParsingNode.pathname
  	      };
  	    }
  	
  	    originURL = resolveURL(window.location.href);
  	
  	    /**
  	    * Determine if a URL shares the same origin as the current location
  	    *
  	    * @param {String} requestURL The URL to test
  	    * @returns {boolean} True if URL shares the same origin, otherwise false
  	    */
  	    return function isURLSameOrigin(requestURL) {
  	      var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
  	      return (parsed.protocol === originURL.protocol &&
  	            parsed.host === originURL.host);
  	    };
  	  })() :
  	
  	  // Non standard browser envs (web workers, react-native) lack needed support.
  	  (function nonStandardBrowserEnv() {
  	    return function isURLSameOrigin() {
  	      return true;
  	    };
  	  })()
  	);


  /***/ }),
  /* 15 */
  /***/ (function(module, exports) {
  	
  	// btoa polyfill for IE<10 courtesy https://github.com/davidchambers/Base64.js
  	
  	var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
  	
  	function E() {
  	  this.message = 'String contains an invalid character';
  	}
  	E.prototype = new Error;
  	E.prototype.code = 5;
  	E.prototype.name = 'InvalidCharacterError';
  	
  	function btoa(input) {
  	  var str = String(input);
  	  var output = '';
  	  for (
  	    // initialize result and counter
  	    var block, charCode, idx = 0, map = chars;
  	    // if the next str index does not exist:
  	    //   change the mapping table to "="
  	    //   check if d has no fractional digits
  	    str.charAt(idx | 0) || (map = '=', idx % 1);
  	    // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
  	    output += map.charAt(63 & block >> 8 - idx % 1 * 8)
  	  ) {
  	    charCode = str.charCodeAt(idx += 3 / 4);
  	    if (charCode > 0xFF) {
  	      throw new E();
  	    }
  	    block = block << 8 | charCode;
  	  }
  	  return output;
  	}
  	
  	module.exports = btoa;


  /***/ }),
  /* 16 */
  /***/ (function(module, exports, __webpack_require__) {
  	
  	var utils = __webpack_require__(2);
  	
  	module.exports = (
  	  utils.isStandardBrowserEnv() ?
  	
  	  // Standard browser envs support document.cookie
  	  (function standardBrowserEnv() {
  	    return {
  	      write: function write(name, value, expires, path, domain, secure) {
  	        var cookie = [];
  	        cookie.push(name + '=' + encodeURIComponent(value));
  	
  	        if (utils.isNumber(expires)) {
  	          cookie.push('expires=' + new Date(expires).toGMTString());
  	        }
  	
  	        if (utils.isString(path)) {
  	          cookie.push('path=' + path);
  	        }
  	
  	        if (utils.isString(domain)) {
  	          cookie.push('domain=' + domain);
  	        }
  	
  	        if (secure === true) {
  	          cookie.push('secure');
  	        }
  	
  	        document.cookie = cookie.join('; ');
  	      },
  	
  	      read: function read(name) {
  	        var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
  	        return (match ? decodeURIComponent(match[3]) : null);
  	      },
  	
  	      remove: function remove(name) {
  	        this.write(name, '', Date.now() - 86400000);
  	      }
  	    };
  	  })() :
  	
  	  // Non standard browser env (web workers, react-native) lack needed support.
  	  (function nonStandardBrowserEnv() {
  	    return {
  	      write: function write() {},
  	      read: function read() { return null; },
  	      remove: function remove() {}
  	    };
  	  })()
  	);


  /***/ }),
  /* 17 */
  /***/ (function(module, exports, __webpack_require__) {
  	
  	var utils = __webpack_require__(2);
  	
  	function InterceptorManager() {
  	  this.handlers = [];
  	}
  	
  	/**
  	 * Add a new interceptor to the stack
  	 *
  	 * @param {Function} fulfilled The function to handle `then` for a `Promise`
  	 * @param {Function} rejected The function to handle `reject` for a `Promise`
  	 *
  	 * @return {Number} An ID used to remove interceptor later
  	 */
  	InterceptorManager.prototype.use = function use(fulfilled, rejected) {
  	  this.handlers.push({
  	    fulfilled: fulfilled,
  	    rejected: rejected
  	  });
  	  return this.handlers.length - 1;
  	};
  	
  	/**
  	 * Remove an interceptor from the stack
  	 *
  	 * @param {Number} id The ID that was returned by `use`
  	 */
  	InterceptorManager.prototype.eject = function eject(id) {
  	  if (this.handlers[id]) {
  	    this.handlers[id] = null;
  	  }
  	};
  	
  	/**
  	 * Iterate over all the registered interceptors
  	 *
  	 * This method is particularly useful for skipping over any
  	 * interceptors that may have become `null` calling `eject`.
  	 *
  	 * @param {Function} fn The function to call for each interceptor
  	 */
  	InterceptorManager.prototype.forEach = function forEach(fn) {
  	  utils.forEach(this.handlers, function forEachHandler(h) {
  	    if (h !== null) {
  	      fn(h);
  	    }
  	  });
  	};
  	
  	module.exports = InterceptorManager;


  /***/ }),
  /* 18 */
  /***/ (function(module, exports, __webpack_require__) {
  	
  	var utils = __webpack_require__(2);
  	var transformData = __webpack_require__(19);
  	var isCancel = __webpack_require__(20);
  	var defaults = __webpack_require__(6);
  	var isAbsoluteURL = __webpack_require__(21);
  	var combineURLs = __webpack_require__(22);
  	
  	/**
  	 * Throws a `Cancel` if cancellation has been requested.
  	 */
  	function throwIfCancellationRequested(config) {
  	  if (config.cancelToken) {
  	    config.cancelToken.throwIfRequested();
  	  }
  	}
  	
  	/**
  	 * Dispatch a request to the server using the configured adapter.
  	 *
  	 * @param {object} config The config that is to be used for the request
  	 * @returns {Promise} The Promise to be fulfilled
  	 */
  	module.exports = function dispatchRequest(config) {
  	  throwIfCancellationRequested(config);
  	
  	  // Support baseURL config
  	  if (config.baseURL && !isAbsoluteURL(config.url)) {
  	    config.url = combineURLs(config.baseURL, config.url);
  	  }
  	
  	  // Ensure headers exist
  	  config.headers = config.headers || {};
  	
  	  // Transform request data
  	  config.data = transformData(
  	    config.data,
  	    config.headers,
  	    config.transformRequest
  	  );
  	
  	  // Flatten headers
  	  config.headers = utils.merge(
  	    config.headers.common || {},
  	    config.headers[config.method] || {},
  	    config.headers || {}
  	  );
  	
  	  utils.forEach(
  	    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
  	    function cleanHeaderConfig(method) {
  	      delete config.headers[method];
  	    }
  	  );
  	
  	  var adapter = config.adapter || defaults.adapter;
  	
  	  return adapter(config).then(function onAdapterResolution(response) {
  	    throwIfCancellationRequested(config);
  	
  	    // Transform response data
  	    response.data = transformData(
  	      response.data,
  	      response.headers,
  	      config.transformResponse
  	    );
  	
  	    return response;
  	  }, function onAdapterRejection(reason) {
  	    if (!isCancel(reason)) {
  	      throwIfCancellationRequested(config);
  	
  	      // Transform response data
  	      if (reason && reason.response) {
  	        reason.response.data = transformData(
  	          reason.response.data,
  	          reason.response.headers,
  	          config.transformResponse
  	        );
  	      }
  	    }
  	
  	    return Promise.reject(reason);
  	  });
  	};


  /***/ }),
  /* 19 */
  /***/ (function(module, exports, __webpack_require__) {
  	
  	var utils = __webpack_require__(2);
  	
  	/**
  	 * Transform the data for a request or a response
  	 *
  	 * @param {Object|String} data The data to be transformed
  	 * @param {Array} headers The headers for the request or response
  	 * @param {Array|Function} fns A single function or Array of functions
  	 * @returns {*} The resulting transformed data
  	 */
  	module.exports = function transformData(data, headers, fns) {
  	  /*eslint no-param-reassign:0*/
  	  utils.forEach(fns, function transform(fn) {
  	    data = fn(data, headers);
  	  });
  	
  	  return data;
  	};


  /***/ }),
  /* 20 */
  /***/ (function(module, exports) {
  	
  	module.exports = function isCancel(value) {
  	  return !!(value && value.__CANCEL__);
  	};


  /***/ }),
  /* 21 */
  /***/ (function(module, exports) {
  	
  	/**
  	 * Determines whether the specified URL is absolute
  	 *
  	 * @param {string} url The URL to test
  	 * @returns {boolean} True if the specified URL is absolute, otherwise false
  	 */
  	module.exports = function isAbsoluteURL(url) {
  	  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  	  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  	  // by any combination of letters, digits, plus, period, or hyphen.
  	  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
  	};


  /***/ }),
  /* 22 */
  /***/ (function(module, exports) {
  	
  	/**
  	 * Creates a new URL by combining the specified URLs
  	 *
  	 * @param {string} baseURL The base URL
  	 * @param {string} relativeURL The relative URL
  	 * @returns {string} The combined URL
  	 */
  	module.exports = function combineURLs(baseURL, relativeURL) {
  	  return relativeURL
  	    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
  	    : baseURL;
  	};


  /***/ }),
  /* 23 */
  /***/ (function(module, exports) {
  	
  	/**
  	 * A `Cancel` is an object that is thrown when an operation is canceled.
  	 *
  	 * @class
  	 * @param {string=} message The message.
  	 */
  	function Cancel(message) {
  	  this.message = message;
  	}
  	
  	Cancel.prototype.toString = function toString() {
  	  return 'Cancel' + (this.message ? ': ' + this.message : '');
  	};
  	
  	Cancel.prototype.__CANCEL__ = true;
  	
  	module.exports = Cancel;


  /***/ }),
  /* 24 */
  /***/ (function(module, exports, __webpack_require__) {
  	
  	var Cancel = __webpack_require__(23);
  	
  	/**
  	 * A `CancelToken` is an object that can be used to request cancellation of an operation.
  	 *
  	 * @class
  	 * @param {Function} executor The executor function.
  	 */
  	function CancelToken(executor) {
  	  if (typeof executor !== 'function') {
  	    throw new TypeError('executor must be a function.');
  	  }
  	
  	  var resolvePromise;
  	  this.promise = new Promise(function promiseExecutor(resolve) {
  	    resolvePromise = resolve;
  	  });
  	
  	  var token = this;
  	  executor(function cancel(message) {
  	    if (token.reason) {
  	      // Cancellation has already been requested
  	      return;
  	    }
  	
  	    token.reason = new Cancel(message);
  	    resolvePromise(token.reason);
  	  });
  	}
  	
  	/**
  	 * Throws a `Cancel` if cancellation has been requested.
  	 */
  	CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  	  if (this.reason) {
  	    throw this.reason;
  	  }
  	};
  	
  	/**
  	 * Returns an object that contains a new `CancelToken` and a function that, when called,
  	 * cancels the `CancelToken`.
  	 */
  	CancelToken.source = function source() {
  	  var cancel;
  	  var token = new CancelToken(function executor(c) {
  	    cancel = c;
  	  });
  	  return {
  	    token: token,
  	    cancel: cancel
  	  };
  	};
  	
  	module.exports = CancelToken;


  /***/ }),
  /* 25 */
  /***/ (function(module, exports) {
  	
  	/**
  	 * Syntactic sugar for invoking a function and expanding an array for arguments.
  	 *
  	 * Common use case would be to use `Function.prototype.apply`.
  	 *
  	 *  ```js
  	 *  function f(x, y, z) {}
  	 *  var args = [1, 2, 3];
  	 *  f.apply(null, args);
  	 *  ```
  	 *
  	 * With `spread` this example can be re-written.
  	 *
  	 *  ```js
  	 *  spread(function(x, y, z) {})([1, 2, 3]);
  	 *  ```
  	 *
  	 * @param {Function} callback
  	 * @returns {Function}
  	 */
  	module.exports = function spread(callback) {
  	  return function wrap(arr) {
  	    return callback.apply(null, arr);
  	  };
  	};


  /***/ })
  /******/ ])
  });

  });

  var PROXY_CONFIG_PROPERTIES = ['headers', 'params', 'data'];
  var PROXY_CONFIG_METHODS = {
    get: function get(prop, context) {
      return function () {
        return context[prop];
      };
    },
    set: function set(prop, context) {
      return function (value) {
        context[prop] = value;
      };
    },
    add: function add(prop, context) {
      return function (key, value) {
        context[prop][key] = value;
      };
    },
    remove: function remove(prop, context) {
      return function (key) {
        delete context[prop][key];
      };
    },
    merge: function merge(prop, context) {
      return function (key, values) {
        extend(context[prop], key);
      };
    }
  };

  var method = function method(action, prop) {
    return camelCase_1([action, prop].join(' '));
  };

  var chainable = function chainable(prop) {
    var _this = this;

    return function (key, value) {
      if (key instanceof FormData) {
        _this[method('set', prop)](key);
      } else if (isObject_1(key)) {
        _this[method('merge', prop)](key);
      } else {
        _this[method('add', prop)](key, value);
      }

      return _this;
    };
  };

  var Request =
  /*#__PURE__*/
  function () {
    function Request(url) {
      var _this2 = this;

      var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, Request);

      this.$config = extend({
        url: url,
        headers: {},
        params: {},
        data: {}
      }, config);

      each(PROXY_CONFIG_METHODS, function (callback, key) {
        _this2[method(key, 'config')] = bind_1(callback)('$config', _this2);
      });

      this['config'] = bind_1(chainable, this)('config');

      each(PROXY_CONFIG_PROPERTIES, function (prop) {
        each(PROXY_CONFIG_METHODS, function (callback, key) {
          _this2[method(key, prop)] = bind_1(callback)(prop, _this2.$config);
        });

        _this2[prop] = bind_1(chainable, _this2)(prop);
      });

      this.reset();
    }

    _createClass(Request, [{
      key: "reset",
      value: function reset() {
        this.$error = null;
        this.$status = null;
        this.$statusText = null;
        this.$response = null;
        this.$requestSentAt = null;
        this.$responseReceivedAt = null;
      }
    }, {
      key: "hasSent",
      value: function hasSent() {
        return !!this.$requestSentAt;
      }
    }, {
      key: "hasResponse",
      value: function hasResponse() {
        return !!this.$responseReceivedAt;
      }
    }, {
      key: "passed",
      value: function passed() {
        return this.hasResponse() && !this.$error;
      }
    }, {
      key: "failed",
      value: function failed() {
        return this.hasResponse() && !!this.$error;
      }
    }, {
      key: "getUrl",
      value: function getUrl() {
        return this.$url;
      }
    }, {
      key: "setUrl",
      value: function setUrl(url) {
        this.$url = url;
      }
    }, {
      key: "get",
      value: function get() {
        var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var headers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        return this.params(params).headers(headers).request('get');
      }
    }, {
      key: "post",
      value: function post() {
        var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var headers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        return this.data(data).headers(headers).request('post');
      }
    }, {
      key: "put",
      value: function put() {
        var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var headers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        return this.data(data).headers(headers).request('put');
      }
    }, {
      key: "delete",
      value: function _delete() {
        var headers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return this.headers(headers).request('delete');
      }
    }, {
      key: "request",
      value: function request(method) {
        var _this3 = this;

        this.reset();
        this.$requestSentAt = moment();
        this.addConfig('method', method);
        var promise = new Promise(function (resolve, reject) {
          axios.request(_this3.$config).then(function (response) {
            _this3.$response = response;
            _this3.$responseReceivedAt = moment();
            _this3.$status = response.status;
            _this3.$statusText = response.statusText;
            resolve(response.data);
          }, function (error) {
            _this3.$error = error;
            _this3.$response = error.response;
            _this3.$responseReceivedAt = moment();
            _this3.$status = error.response.status;
            _this3.$statusText = error.response.statusText;
            reject(error.response.data.errors);
          });
        });
        return promise;
      }
    }]);

    return Request;
  }();

  var Model =
  /*#__PURE__*/
  function () {
    /**
     * Initialize the model instance
     *
     * @param data object
     * @return void
     */
    function Model() {
      var _this = this;

      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, Model);

      this.$changed = {};
      this.$exists = false;
      this.$attributes = {};
      this.$key = this.key();
      this.$files = this.files();
      this.$table = this.table();
      this.$properties = this.properties();
      this.initialize(data);

      each(params, function (value, key) {
        _this[key] = value;
      });

      if (!this.$table) {
        throw new Error('A table must be defined for every model.');
      }

      this.$initialized = true;
    }
    /**
     * Initialize the model with the given data without considering the data
     * as "changed".
     *
     * @param data object
     * @return this
     */


    _createClass(Model, [{
      key: "initialize",
      value: function initialize(data) {
        this.$initialized = false;
        this.fill(data);
        this.$initialized = true;
        return this;
      }
      /**
       * Define the corresponding database table (aka API endpoint slug).
       *
       * @return string
       */

    }, {
      key: "table",
      value: function table() {} //

      /**
       * Define a primary key. This is used to determine if the model exists and
       * which endpoint to use.
       *
       * @return string
       */

    }, {
      key: "key",
      value: function key() {
        return 'id';
      }
      /**
       * Return an array of properties that are sent to the API. If no properties
       * are defined, then all the attributes will be included in the request.
       *
       * @return array
       */

    }, {
      key: "properties",
      value: function properties() {
        return [];
      }
      /**
       * Set the attributes in the model with the data given.
       *
       * @param data object
       * @return this
       */

    }, {
      key: "fill",
      value: function fill(data) {
        this.setAttributes(data);
        return this;
      }
      /**
       * Get one or more attributes from the model.
       *
       * @param data string|array
       * @return array|mixed
       */

    }, {
      key: "get",
      value: function get(key) {
        if (isArray_1(key) || isObject_1(key)) {
          return this.getAttributes().filter(function (value) {
            return data.indexOf(value) !== -1;
          });
        } else {
          return this.getAttribute(key);
        }
      }
      /**
       * Alias for setAttributes() except this method returns `this`. This method
       * also accepts an array of values or key/value pair.
       *
       * @return this
       */

    }, {
      key: "set",
      value: function set(key) {
        var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

        if (isArray_1(key) || isObject_1(key)) {
          this.setAttributes(key);
        } else {
          this.setAttribute(key, value);
        }

        return this;
      }
      /**
       * Get all the defined attributes.
       *
       * @return array
       */

    }, {
      key: "getAttributes",
      value: function getAttributes() {
        return this.$attributes;
      }
      /**
       * Get the changed attributes
       *
       * @return array
       */

    }, {
      key: "getChangedAttributes",
      value: function getChangedAttributes() {
        return keys_1(this.$changed);
      }
      /**
       * Get the changed attributes
       *
       * @return array
       */

    }, {
      key: "getOriginalValue",
      value: function getOriginalValue(key) {
        return this.$changed[key] || this.$attributes[key];
      }
      /**
       * Get the unchanged attributes
       *
       * @return array
       */

    }, {
      key: "getUnchangedAttributes",
      value: function getUnchangedAttributes() {
        var _this2 = this;

        return filter_1(keys_1(this.$attributes), function (key) {
          return !(key in _this2.$changed);
        });
      }
      /**
       * Get an attribute with a given key. If no key is defined
       *
       * @param key string
       * @param default undefined|mixed
       * @return array
       */

    }, {
      key: "getAttribute",
      value: function getAttribute(key) {
        var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
        return this.$attributes[key] || value;
      }
      /**
       * Set an array or object of data as attributes.
       *
       * @param attributes array|object
       * @return void
       */

    }, {
      key: "setAttributes",
      value: function setAttributes(data) {
        var _this3 = this;

        if (!isArray_1(data) && !isObject_1(data)) {
          throw new Error('Attributes must be set with an array or object.');
        }

        each(data, function (value, key) {
          _this3.setAttribute(key, value);
        });
      }
      /**
       * Set an attribute with a given key/value pair. This will track the changes
       * in the model within the `this.$changed` property. If the primary key
       * is set, it will also change the `this.$exists` property.
       *
       * @param key string
       * @param value mixed
       * @return void
       */

    }, {
      key: "setAttribute",
      value: function setAttribute(key, value) {
        if (this.getAttribute(key) !== value) {
          this.handleAttributeChange(key, value);

          if (isUndefined_1(value)) {
            delete this.$attributes[key];
          } else {
            this.$attributes[key] = value;
          }
        }
      }
      /**
       * Revert the model to its original state.
       *
       * @return bool
       */

    }, {
      key: "revert",
      value: function revert() {
        var _this4 = this;

        each(this.$changed, function (value, key) {
          if (!isUndefined_1(value)) {
            _this4.$attributes[key] = value;
          } else {
            delete _this4.$attributes[key];
          }
        });

        this.$changed = {};
      }
      /**
       * Returns if the model has a primary key set.
       *
       * @return bool
       */

    }, {
      key: "exists",
      value: function exists() {
        return !!this.$exists;
      }
      /**
       * Returns the model been changed or not.
       *
       * @return bool
       */

    }, {
      key: "hasChanged",
      value: function hasChanged(key) {
        return !key ? size_1(this.$changed) > 0 : !isUndefined_1(this.$changed[key]);
      }
      /**
       * Does the model have any File objects. If so, need to send as multipart.
       *
       * @return bool
       */

    }, {
      key: "hasFiles",
      value: function hasFiles() {
        function count(files) {
          var total = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
          return reduce_1(files, function (carry, value) {
            if (isArray_1(value)) {
              return carry + count(value, total);
            } else if (value instanceof File || value instanceof FileList) {
              return carry + 1;
            } else {
              return carry;
            }
          }, total);
        }

        return count(this.toJSON()) !== 0;
      }
      /**
       * Handle settings the $changed attributes when an attribute value is set.
       *
       * @param key string
       * @param value mixed
       * @return void
       */

    }, {
      key: "handleAttributeChange",
      value: function handleAttributeChange(key, value) {
        if (this.$initialized) {
          if (this.$changed[key] === value) {
            delete this.$changed[key];
          } else if (!(key in this.$changed)) {
            this.$changed[key] = this.getAttribute(key);
          }
        }

        this.handlePrimaryKeyChange(key, value);
      }
      /**
       * Set an array or object of data as attributes.
       *
       * @param key string
       * @param value mixed
       * @return void
       */

    }, {
      key: "handlePrimaryKeyChange",
      value: function handlePrimaryKeyChange(key, value) {
        if (this.$key === key) {
          this.$exists = !isUndefined_1(value) && !isNull_1(value);
        }
      }
      /**
       * Save the model to the database
       *
       * @param data object
       * @return bool
       */

    }, {
      key: "save",
      value: function save() {
        var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        return this.exists() ? this.create(data, config) : this.update(data, config);
      }
      /**
       * Create a new model
       *
       * @param data object
       * @return bool
       */

    }, {
      key: "create",
      value: function create() {
        var _this5 = this;

        var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (this.exists()) {
          return this.update(data, config);
        }

        this.fill(data);
        var request = this.request("/api/".concat(this.table()), extend({
          data: !this.hasFiles() ? this.toJson() : this.toFormData()
        }, config));
        return request.post().then(function (response) {
          return _this5.fill(response);
        });
      }
      /**
       * Update an existing model
       *
       * @param data object
       * @return bool
       */

    }, {
      key: "update",
      value: function update() {
        var _this6 = this;

        var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (!this.exists()) {
          return this.create(data, config);
        }

        this.fill(data);
        var request = this.request("/api/".concat(this.table(), "/").concat(this.get(this.key())), extend({
          data: !this.hasFiles() ? this.toJson() : this.toFormData()
        }, config));
        return request[this.hasFiles() ? 'post' : 'put']().then(function (response) {
          return _this6.fill(response);
        });
      }
      /**
       * Delete an existing model
       *
       * @param data object
       * @return bool
       */

    }, {
      key: "delete",
      value: function _delete() {
        var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (!this.exists()) {
          throw new Error('The model must have a primary key before it can be delete.');
        }

        this.fill(data);
        return this.request("/api/".concat(this.table(), "/").concat(this.get(this.key())), config).delete();
      }
      /**
       * Find an existing model by id
       *
       * @param data object
       * @return bool
       */

    }, {
      key: "search",
      value: function search() {
        var _this7 = this;

        var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        return new Promise(function (resolve, reject) {
          _this7.request("/api/".concat(_this7.table()), extend({
            params: params
          }, config)).get().then(function (response) {
            resolve(map_1(response.data, function (data) {
              return new _this7.constructor(data);
            }));
          }, function (errors) {
            reject(errors);
          });
        });
      }
      /**
       * Find an existing model by id
       *
       * @param data object
       * @return bool
       */

    }, {
      key: "find",
      value: function find(id) {
        var _this8 = this;

        var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        return new Promise(function (resolve, reject) {
          _this8.request("/api/".concat(_this8.table(), "/").concat(id), config).get().then(function (response) {
            resolve(_this8.initialize(response));
          }, function (errors) {
            reject(errors);
          });
        });
      }
      /**
       * Create a request from the model data
       *
       * @param data object
       * @return bool
       */

    }, {
      key: "request",
      value: function request(url) {
        var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        return new Request(url, config);
      }
      /**
       * Convert the Model instance to a FormData instance
       *
       * @return object
       */

    }, {
      key: "toFormData",
      value: function toFormData() {
        var form = new FormData();

        each(this.toJSON(), function (value, key) {
          if (isArray_1(value)) {
            each(value, function (item) {
              form.append(key.replace(/(.+)(\[.+\]?)$/, '$1') + '[]', item);
            });
          } else {
            form.append(key, value);
          }
        });

        return form;
      }
      /**
       * Convert the instance to JSON payload
       *
       * @return object
       */

    }, {
      key: "toJSON",
      value: function toJSON() {
        var _this9 = this;

        return pickBy_1(this.$attributes, function (value, key) {
          return !_this9.$properties.length || key === _this9.key() || _this9.$properties.indexOf(key) !== -1;
        });
      }
      /**
       * Alias for toJSON
       *
       * @return object
       */

    }, {
      key: "toJson",
      value: function toJson() {
        return this.toJSON();
      }
    }]);

    return Model;
  }();

  var BaseForm = {
    render: function render() {
      var _vm = this;

      var _h = _vm.$createElement;

      var _c = _vm._self._c || _h;

      return _c('form', {
        class: {
          'form-inline': _vm.inline
        },
        attrs: {
          "novalidate": _vm.novalidate
        },
        on: {
          "submit": function submit($event) {
            $event.preventDefault();
            return _vm.onSubmit($event);
          }
        }
      }, [_vm._t("default")], 2);
    },
    staticRenderFns: [],
    props: {
      /**
       * An object of form data
       *
       * @property Object
       */
      data: {
        type: Object,
        default: function _default() {
          return {};
        }
      },

      /**
       * Display the form fields inline
       *
       * @property Object
       */
      model: {
        type: Object,
        validate: function validate(value) {
          return value instanceof Model;
        }
      },

      /**
       * Display the form fields inline
       *
       * @property Boolean
       */
      inline: {
        type: Boolean,
        default: false
      },

      /**
       * A callback function for the `submit` event
       *
       * @property Boolean
       */
      novalidate: {
        type: Boolean,
        default: true
      },

      /**
       * A URI or URL used to redirect user after form submits successfully.
       *
       * @property Function|String
       */
      redirect: [String, Function],

      /**
       * A callback function for the `submit` event
       *
       * @property Function
       */
      onSubmit: {
        type: Function,
        default: function _default(event) {
          var _this = this;

          this.$emit('submit', event);

          if (this.model) {
            console.log('data', this.data);
            this.model.save(this.data, {
              onUploadProgress: function onUploadProgress(event) {
                _this.$emit('submit:progress', event);
              }
            }).then(function (data) {
              _this.onSubmitSuccess(event, data);
            }, function (errors) {
              _this.onSubmitFailed(event, errors);
            });
          }
        }
      },

      /**
       * A callback function for the `submit:success` event
       *
       * @property Function
       */
      onSubmitSuccess: {
        type: Function,
        default: function _default(event, data) {
          this.$emit('submit:success', event, data);
          this.$emit('submit:complete', event, true, data);

          if (this.redirect && isFunction_1(this.redirect)) {
            this.redirect(this);
          } else if (this.redirect) {
            window.location = this.redirect;
          }
        }
      },

      /**
       * A callback function for the `submit:success` event
       *
       * @property Function
       */
      onSubmitFailed: {
        type: Function,
        default: function _default(event, errors) {
          this.$emit('submit:failed', event, errors);
          this.$emit('submit:complete', event, false, errors);
        }
      }
    },
    data: function data() {
      return {
        errors: {}
      };
    }
  };

  var plugin$4 = VueInstaller.use({
    install: function install(Vue, options) {
      VueInstaller.components({
        BaseForm: BaseForm
      });
    }
  });

  function uuid() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
      var r = Math.random() * 16 | 0,
          v = c == 'x' ? r : r & 0x3 | 0x8;
      return v.toString(16);
    });
  }

  var Proxy = {
    methods: {
      proxy: function proxy(callback, event) {
        if (isFunction_1(callback)) {
          callback.apply(this, [].slice.call(arguments).splice(1));
          event.preventDefault();
        }
      }
    }
  };

  var DropdownMenuItem = {
    render: function render() {
      var _vm = this;

      var _h = _vm.$createElement;

      var _c = _vm._self._c || _h;

      return _c('a', {
        staticClass: "dropdown-item",
        class: {
          'active': _vm.active
        },
        attrs: {
          "href": _vm.href || '#'
        },
        on: {
          "click": function click($event) {
            _vm.proxy(_vm.onClick, $event);

            _vm.onClicked($event);
          }
        }
      }, [_vm.icon ? _c('i', {
        class: _vm.icon
      }) : _vm._e(), _vm._v(" "), _vm._t("default", [_vm._v(_vm._s(_vm.label))])], 2);
    },
    staticRenderFns: [],
    mixins: [Proxy],
    props: {
      /**
       * Is the menu item active.
       *
       * @property Object
       */
      active: Boolean,

      /**
       * The `href` attribute.
       *
       * @property Object
       */
      href: String,

      /**
       * The label of the dropdown menu item.
       *
       * @property Object
       */
      label: String,

      /**
       * The icon of the dropdown menu item.
       *
       * @property Object
       */
      icon: String,

      /**
       * A callback function for the `click` event.
       *
       * @property Object
       */
      onClick: Function
    },
    methods: {
      /**
       * A callback function for the `click` event.
       *
       * @property Object
       */
      onClicked: function onClicked(event) {
        if (!this.href) {
          event.preventDefault();
        }

        this.$emit('click', event);
      }
    }
  };

  var DropdownMenuHeader = {
    render: function render() {
      var _vm = this;

      var _h = _vm.$createElement;

      var _c = _vm._self._c || _h;

      return _c('h5', {
        staticClass: "dropdown-header"
      }, [_vm._v(" " + _vm._s(_vm.header) + " "), _vm._t("default")], 2);
    },
    staticRenderFns: [],
    name: 'dropdown-menu-header',
    props: {
      /**
       * The value of the header
       *
       * @property Object
       */
      header: String
    }
  };

  var DropdownMenuDivider = {
    render: function render() {
      var _vm = this;

      var _h = _vm.$createElement;

      var _c = _vm._self._c || _h;

      return _c('div', {
        staticClass: "dropdown-divider"
      });
    },
    staticRenderFns: [],
    name: 'dropdown-menu-divider'
  };

  var DropdownMenu = {
    render: function render() {
      var _vm = this;

      var _h = _vm.$createElement;

      var _c = _vm._self._c || _h;

      return _c('div', {
        staticClass: "dropdown-menu",
        class: {
          'dropdown-menu-right': _vm.align === 'right',
          'show': _vm.show
        },
        attrs: {
          "aria-labelledby": _vm.id
        }
      }, [_vm._t("default", [_vm._l(_vm.items, function (item) {
        return [_c(_vm.prefix(item.type || 'item', 'dropdown-menu'), _vm._b({
          tag: "component",
          on: {
            "click": function click($event) {
              _vm.onClick($event, item);
            }
          }
        }, 'component', item, false))];
      })])], 2);
    },
    staticRenderFns: [],
    components: {
      DropdownMenuItem: DropdownMenuItem,
      DropdownMenuHeader: DropdownMenuHeader,
      DropdownMenuDivider: DropdownMenuDivider
    },
    props: {
      /**
       * The `id` attribute on the toggle button and aria label. If no `id` is
       * defined, then a UUID will be generated instead.
       *
       * @property Object
       */
      id: {
        type: String,
        default: uuid
      },

      /**
       * Display the dropdown menu aligned left or right
       *
       * @property String
       */
      align: {
        type: String,
        default: 'left',
        validate: function validate(value) {
          return ['left', 'right'].indexOf(value.toLowerCase()) !== -1;
        }
      },

      /**
       * The default visibility of the dropdown menu.
       *
       * @property Object
       */
      show: Boolean,

      /**
       * An array of dropdown items. If an key/value pair isn't defined, the
       * default value will be used. If no items are defined, then the slot
       * named "items" can be used to define the options with HTML.
       *
       * [{
       *      type: 'item', // String [item|header|divider]
       *      href: '#', // String
       *      label: 'Some label', // String
       *      onClick: (event) => {} // Function
       * }]
       *
       * @property Array
       */
      items: Array
    },
    methods: {
      prefix: prefix,

      /**
       * A callback function for the `click` event.
       *
       * @param Object event
       * @param Object item
       * @return void
       */
      onClick: function onClick(event, item) {
        this.$emit('item:click', event, item);
        this.$emit('update:show', false);
      }
    }
  };

  var plugin$5 = VueInstaller.use({
    install: function install(Vue, options) {
      VueInstaller.components({
        DropdownMenu: DropdownMenu,
        DropdownMenuDivider: DropdownMenuDivider,
        DropdownMenuHeader: DropdownMenuHeader
      });
    }
  });

  var ButtonDropdown = {
    render: function render() {
      var _vm = this;

      var _h = _vm.$createElement;

      var _c = _vm._self._c || _h;

      return _c('div', {
        staticClass: "btn-group",
        class: {
          'dropup': _vm.dropup,
          'dropright': _vm.dropright,
          'dropleft': _vm.dropleft
        }
      }, [_vm._t("button", [_vm.split ? [_vm.href ? _c('a', {
        class: _vm.actionClasses,
        attrs: {
          "href": _vm.href
        },
        on: {
          "click": _vm.onClick
        }
      }, [_vm._t("label-wrapper", [_vm.icon ? _c('i', {
        class: _vm.icon
      }) : _vm._e(), _vm._v(" "), _vm._t("label", [_vm._v(_vm._s(_vm.label))])])], 2) : _c('button', {
        class: _vm.actionClasses,
        attrs: {
          "type": _vm.type
        },
        on: {
          "click": _vm.onClick
        }
      }, [_vm._t("label-wrapper", [_vm.icon ? _c('i', {
        class: _vm.icon
      }) : _vm._e(), _vm._v(" "), _vm._t("label", [_vm._v(_vm._s(_vm.label))])])], 2), _vm._v(" "), _c('button', {
        class: _vm.toggleClasses,
        attrs: {
          "type": "button",
          "aria-haspopup": "true",
          "aria-expanded": _vm.isDropdownShowing,
          "id": _vm.id
        },
        on: {
          "click": function click($event) {
            $event.preventDefault();
            !_vm.isDropdownShowing ? _vm.showDropdown() : _vm.hideDropdown();
          },
          "blur": _vm.onBlur
        }
      })] : [_c('button', {
        class: _vm.toggleClasses,
        attrs: {
          "aria-haspopup": "true",
          "aria-expanded": _vm.isDropdownShowing,
          "type": _vm.type,
          "id": _vm.id
        },
        on: {
          "click": function click($event) {
            $event.preventDefault();
            !_vm.isDropdownShowing ? _vm.showDropdown() : _vm.hideDropdown();
          },
          "blur": _vm.onBlur
        }
      }, [_vm._t("label-wrapper", [_vm.icon ? _c('i', {
        class: _vm.icon
      }) : _vm._e(), _vm._v(" "), _vm._t("label", [_vm._v(_vm._s(_vm.label))])])], 2)]]), _vm._v(" "), _vm._t("dropdown-menu", [_c('dropdown-menu', {
        directives: [{
          name: "transform-position",
          rawName: "v-transform-position"
        }],
        attrs: {
          "id": _vm.id,
          "items": _vm.items,
          "align": _vm.align,
          "show": _vm.isDropdownShowing
        },
        on: {
          "update:show": function updateShow($event) {
            _vm.isDropdownShowing = $event;
          },
          "item:click": _vm.onItemClick
        }
      }, [_vm._t("default")], 2)])], 2);
    },
    staticRenderFns: [],
    name: 'button-dropdown',
    components: {
      DropdownMenu: DropdownMenu
    },
    directives: {
      transformPosition: {
        update: function update(el, binding, vnode) {
          var left = null,
              right = null,
              x = 0,
              y = 0;
          var offsetElement = getComputedStyle(vnode.context.$el.querySelector(vnode.context.split ? '.btn:not(.dropdown-toggle)' : '.btn.dropdown-toggle')); //if(vnode.context.split) {

          if (vnode.context.split && vnode.context.align === 'left') {
            x = offsetElement.width;
          } else {
            right = 0;
            left = null;
          } //}


          el.style.left = left === null ? 'auto' : left;
          el.style.right = right === null ? 'auto' : right;
          el.style.transform = "translate(".concat(x, ", ").concat(y, ")");
        }
      }
    },
    props: {
      /**
       * An array of dropdown items. If an key/value pair isn't defined, the
       * default value will be used. If no items are defined, then the slot
       * named "items" can be used to define the options with HTML.
       *
       * [{
       *      type: 'item', // String [item|header|divider]
       *      href: '#', // String
       *      label: 'Some label', // String
       *      onClick: (event) => {} // Function
       * }]
       *
       * @property Array
       */
      items: Array,

      /**
       * The `href` attribute on the action button (if a split button).
       *
       * @property String
       */
      href: String,

      /**
       * The button icon that appears before the label.
       *
       * @property String
       */
      icon: String,

      /**
       * The toggle button's label. If not defined as an attribute,
       * you can override with the component's slot (inner html).
       *
       * @property String
       */
      label: String,

      /**
       * The `id` attribute on the toggle button and aria label. If no `id` is
       * defined, then a UUID will be generated instead.
       *
       * @property String
       */
      id: {
        type: String,
        default: uuid
      },

      /**
       * The `type` attribute on the toggle button
       *
       * @property String
       */
      type: {
        type: String,
        default: 'button'
      },

      /**
       * The size class of the toggle button
       *
       * @property String
       */
      size: {
        type: String,
        default: 'md'
      },

      /**
       * The toggle button's variant class.
       *
       * @property String
       */
      variant: {
        type: String,
        default: 'primary'
      },

      /**
       * Display the dropdown menu aligned left or right
       *
       * @property String
       */
      align: {
        type: String,
        default: 'left',
        validate: function validate(value) {
          return ['left', 'right'].indexOf(value.toLowerCase()) !== -1;
        }
      },

      /**
       * Display the dropdown button with a split toggle button.
       *
       * @property Boolean
       */
      split: {
        type: Boolean,
        default: false
      },

      /**
       * Display as a dropup instead of a dropdown.
       *
       * @property Boolean
       */
      dropup: {
        type: Boolean,
        default: false
      },

      /**
       * Display as a dropright instead of a dropdown.
       *
       * @property Boolean
       */
      dropright: {
        type: Boolean,
        default: false
      },

      /**
       * Display as a dropleft instead of a dropdown.
       *
       * @property Boolean
       */
      dropleft: {
        type: Boolean,
        default: false
      }
    },
    methods: {
      /**
       * Show the dropdown menu
       *
       * @return void
       */
      showDropdown: function showDropdown() {
        this.$emit('toggle', this.isDropdownShowing = true);
        this.$emit('show');
      },

      /**
       * Hide the dropdown menu
       *
       * @return void
       */
      hideDropdown: function hideDropdown() {
        this.$emit('toggle', this.isDropdownShowing = false);
        this.$emit('hide');
      },

      /**
       * A callback function for the `click` event for the action button
       *
       * @return void
       */
      onClick: function onClick(event) {
        this.hideDropdown();
        this.$emit('click', event);
      },

      /**
       * A callback function for the `blur` event for the action button
       *
       * @return void
       */
      onBlur: function onBlur(event) {
        if (!this.$el.contains(event.relatedTarget)) {
          this.hideDropdown();
        }
      },

      /**
       * A callback function for the `item:click` event for the action button
       *
       * @return void
       */
      onItemClick: function onItemClick(event, child) {
        this.$emit('item:click', event, child);
      }
    },
    computed: {
      actionClasses: function actionClasses() {
        return ['btn', prefix(this.size, 'btn'), prefix(this.variant, 'btn')].join(' ');
      },
      toggleClasses: function toggleClasses() {
        return ['btn', 'dropdown-toggle', prefix(this.size, 'btn'), prefix(this.variant, 'btn'), this.split ? 'dropdown-toggle-split' : ''].join(' ');
      }
    },
    data: function data() {
      return {
        isDropdownShowing: false
      };
    }
  };

  var plugin$6 = VueInstaller.use({
    install: function install(Vue, options) {
      VueInstaller.components({
        ButtonDropdown: ButtonDropdown
      });
    }
  });

  /** Error message constants. */
  var FUNC_ERROR_TEXT$2 = 'Expected a function';

  /**
   * Creates a function that negates the result of the predicate `func`. The
   * `func` predicate is invoked with the `this` binding and arguments of the
   * created function.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Function
   * @param {Function} predicate The predicate to negate.
   * @returns {Function} Returns the new negated function.
   * @example
   *
   * function isEven(n) {
   *   return n % 2 == 0;
   * }
   *
   * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
   * // => [1, 3, 5]
   */
  function negate(predicate) {
    if (typeof predicate != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT$2);
    }
    return function() {
      var args = arguments;
      switch (args.length) {
        case 0: return !predicate.call(this);
        case 1: return !predicate.call(this, args[0]);
        case 2: return !predicate.call(this, args[0], args[1]);
        case 3: return !predicate.call(this, args[0], args[1], args[2]);
      }
      return !predicate.apply(this, args);
    };
  }

  var negate_1 = negate;

  /**
   * The opposite of `_.pickBy`; this method creates an object composed of
   * the own and inherited enumerable string keyed properties of `object` that
   * `predicate` doesn't return truthy for. The predicate is invoked with two
   * arguments: (value, key).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Object
   * @param {Object} object The source object.
   * @param {Function} [predicate=_.identity] The function invoked per property.
   * @returns {Object} Returns the new object.
   * @example
   *
   * var object = { 'a': 1, 'b': '2', 'c': 3 };
   *
   * _.omitBy(object, _.isNumber);
   * // => { 'b': '2' }
   */
  function omitBy(object, predicate) {
    return pickBy_1(object, negate_1(_baseIteratee(predicate)));
  }

  var omitBy_1 = omitBy;

  var COLORS = ['primary', 'secondary', 'success', 'danger', 'warning', 'info', 'light', 'dark', 'white'];
  var props = {};

  each(['text', 'bg', 'bg-gradient'], function (namespace) {
    each(COLORS, function (color) {
      props[camelCase_1(prefix(color, namespace))] = Boolean;
    });
  });

  function classes(instance, namespace) {
    return filter_1(map_1(COLORS, function (color) {
      return instance[camelCase_1(color = prefix(color, namespace))] ? color : null;
    }));
  }

  var Colorable = {
    props: props,
    methods: {
      textColor: function textColor() {
        return classes(this, 'text');
      },
      bgColor: function bgColor() {
        return classes(this, 'bg');
      },
      bgGradientColor: function bgGradientColor() {
        return classes(this, 'bg-gradient');
      }
    },
    computed: {
      textColorClasses: function textColorClasses() {
        return this.textColor().join(' ').trim() || null;
      },
      bgColorClasses: function bgColorClasses() {
        return this.bgColor().join(' ').trim() || null;
      },
      bgGradientColorClasses: function bgGradientColorClasses() {
        return this.bgGradientColor().join(' ').trim() || null;
      },
      colorableClasses: function colorableClasses() {
        var classes = {};
        classes[this.textColorClasses] = !!this.textColorClasses;
        classes[this.bgColorClasses] = !!this.bgColorClasses;
        classes[this.bgGradientColorClasses] = !!this.bgGradientColorClasses;
        return omitBy_1(classes, function (key, value) {
          return !key || !value;
        });
      }
    }
  };

  var FormControl = {
    props: {
      /**
       * The field id attribute value.
       *
       * @property String
       */
      id: String,

      /**
       * The value of label element. If no value, no label will appear.
       *
       * @property String
       */
      label: String,

      /**
       * The field name attribute value.
       *
       * @property String
       */
      name: String,

      /**
       * The field id attribute value.
       *
       * @property String
       */
      value: {
        default: null
      },

      /**
       * The placeholder attribute value.
       *
       * @property String
       */
      placeholder: String,

      /**
       * Is the field required.
       *
       * @property String
       */
      required: Boolean,

      /**
       * The regex pattern for validation.
       *
       * @property String
       */
      pattern: String,

      /**
       * An inline field validation error.
       *
       * @property String|Boolean
       */
      error: String,

      /**
       * An inline field validation errors passed as object with key/value
       * pairs. If errors passed as an object, the form name will be used for
       * the key.
       *
       * @property Object|Boolean
       */
      errors: [Object, Array],

      /**
       * Some feedback to add to the field once the field is successfully
       * valid.
       *
       * @property String
       */
      feedback: [String, Array],

      /**
       * An array of event names that correlate with callback functions
       *
       * @property Function
       */
      bindEvents: {
        type: Array,
        default: function _default() {
          return ['focus', 'blur', 'change', 'click', 'keyup', 'keydown', 'progress'];
        }
      },

      /**
       * The default class name assigned to the control element
       *
       * @property String
       */
      defaultControlClass: {
        type: String,
        default: 'form-control'
      },

      /**
       * Hide the label for browsers, but leave it for screen readers.
       *
       * @property String
       */
      hideLabel: Boolean,

      /**
       * Additional margin/padding classes for fine control of spacing
       *
       * @property String
       */
      spacing: String,

      /**
       * The size of the form control
       *
       * @property String
       */
      size: {
        type: String,
        default: 'md',
        validate: function validate(value) {
          return ['sm', 'md', 'lg'].indexOf(value) !== -1;
        }
      },

      /**
       * Display the form field inline
       *
       * @property String
       */
      inline: Boolean,

      /**
       * If the form control is readonly, display only as text?
       *
       * @property String
       */
      plaintext: Boolean,

      /**
       * Is the form control readonly?
       *
       * @property String
       */
      readonly: Boolean,

      /**
       * Is the form control disabled?
       *
       * @property String
       */
      disabled: Boolean,

      /**
       * Some instructions to appear under the field label
       *
       * @property String
       */
      helpText: String
    },
    directives: {
      bindEvents: {
        bind: function bind(el, binding, vnode) {
          var events = binding.value || vnode.context.bindEvents;

          each(events, function (name) {
            el.addEventListener(name, function (event) {
              vnode.context.$emit(name, event);
            });
          });
        }
      }
    },
    methods: {
      getInputField: function getInputField() {
        return this.$el.querySelector('.form-control, input, select, textarea');
      },
      getFieldErrors: function getFieldErrors() {
        var errors = this.error || this.errors;

        if (isObject_1(this.errors)) {
          errors = this.errors[this.name || this.id];
        }

        return !errors || isArray_1(errors) || isObject_1(errors) ? errors : [errors];
      },
      updated: function updated(value, event) {
        this.$emit(event || 'input', value);
      }
    },
    computed: {
      callbacks: function callbacks() {
        var _this = this;

        return this.bindEvents.map(function (event) {
          return {
            name: event,
            callback: _this[camelCase_1(['on', event].join(' '))]
          };
        }).filter(function (event) {
          return !isUndefined_1(event.callback);
        });
      },
      invalidFeedback: function invalidFeedback() {
        if (this.error) {
          return this.error;
        }

        var errors = this.getFieldErrors();
        return isArray_1(errors) ? errors.join('<br>') : errors;
      },
      validFeedback: function validFeedback() {
        return isArray_1(this.feedback) ? this.feedback.join('<br>') : this.feedback;
      },
      controlClass: function controlClass() {
        return this.defaultControlClass + (this.plaintext ? '-plaintext' : '');
      },
      controlSizeClass: function controlSizeClass() {
        return prefix(this.size, this.controlClass);
      },
      controlClasses: function controlClasses() {
        return [this.controlClass, this.controlSizeClass, this.spacing || '', this.invalidFeedback ? 'is-invalid' : ''].join(' ');
      }
    }
  };

  var RadioField = {
    render: function render() {
      var _vm = this;

      var _h = _vm.$createElement;

      var _c = _vm._self._c || _h;

      return _c('div', {
        staticClass: "form-check",
        class: _vm.mergeClasses({
          'form-check-inline': _vm.inline
        }, _vm.controlSizeClass)
      }, [_c('label', {
        class: _vm.mergeClasses('form-check-label', _vm.colorableClasses),
        attrs: {
          "for": _vm.id
        }
      }, [_c('input', {
        directives: [{
          name: "bind-events",
          rawName: "v-bind-events",
          value: _vm.bindEvents,
          expression: "bindEvents"
        }],
        class: _vm.mergeClasses(_vm.controlClass, _vm.invalidFeedback ? 'is-invalid' : '', !(_vm.label ? 'position-static' : '')),
        attrs: {
          "type": "radio",
          "name": _vm.name,
          "id": _vm.id,
          "required": _vm.required,
          "disabled": _vm.disabled || _vm.readonly,
          "readonly": _vm.readonly,
          "pattern": _vm.pattern
        },
        domProps: {
          "value": _vm.value,
          "checked": _vm.value === _vm.checked
        },
        on: {
          "change": function change($event) {
            _vm.updated($event.target.value, 'change');
          }
        }
      }), _vm._v(" "), _vm._t("default", [_vm._v(_vm._s(_vm.label))]), _vm._v(" "), _vm._t("feedback", [_vm.validFeedback ? _c('form-feedback', {
        attrs: {
          "valid": ""
        },
        domProps: {
          "innerHTML": _vm._s(_vm.validFeedback)
        }
      }) : _vm._e(), _vm._v(" "), _vm.invalidFeedback ? _c('form-feedback', {
        attrs: {
          "invalid": ""
        },
        domProps: {
          "innerHTML": _vm._s(_vm.invalidFeedback)
        }
      }) : _vm._e()])], 2), _vm._v(" "), _vm._t("help", [_vm.helpText ? _c('help-text', {
        domProps: {
          "innerHTML": _vm._s(_vm.helpText)
        }
      }) : _vm._e()])], 2);
    },
    staticRenderFns: [],
    name: 'radio-field',
    mixins: [Colorable, FormControl],
    model: {
      prop: 'checked',
      event: 'change'
    },
    props: {
      /**
       * Add form-group to the wrapping element
       *
       * @property String
       */
      group: {
        type: Boolean,
        default: false
      },

      /**
       * Display the form field and label inline
       *
       * @property Function
       */
      inline: {
        type: Boolean,
        default: false
      },

      /**
       * The checked values
       *
       * @property String
       */
      checked: [Number, String, Object],

      /**
       * The class name assigned to the control element
       *
       * @property String
       */
      defaultControlClass: {
        type: String,
        default: 'form-check-input'
      }
    },
    computed: {
      controlClass: function controlClass() {
        return this.defaultControlClass;
      },
      controlSizeClass: function controlSizeClass() {
        return prefix(this.size, 'form-control');
      }
    }
  };

  var CheckboxField = {
    render: function render() {
      var _vm = this;

      var _h = _vm.$createElement;

      var _c = _vm._self._c || _h;

      return _c('div', {
        staticClass: "form-check",
        class: _vm.mergeClasses({
          'form-check-inline': _vm.inline
        }, _vm.controlSizeClass)
      }, [_c('label', {
        class: _vm.mergeClasses('form-check-label', _vm.colorableClasses),
        attrs: {
          "for": _vm.id
        }
      }, [_c('input', {
        directives: [{
          name: "bind-events",
          rawName: "v-bind-events",
          value: _vm.bindEvents,
          expression: "bindEvents"
        }],
        class: _vm.mergeClasses(_vm.controlClass, _vm.invalidFeedback ? 'is-invalid' : '', !(_vm.label ? 'position-static' : '')),
        attrs: {
          "type": "checkbox",
          "name": _vm.name,
          "id": _vm.id,
          "required": _vm.required,
          "disabled": _vm.disabled || _vm.readonly,
          "readonly": _vm.readonly,
          "pattern": _vm.pattern
        },
        domProps: {
          "value": _vm.value,
          "checked": _vm.checked.indexOf(_vm.value) !== -1
        },
        on: {
          "change": function change($event) {
            _vm.updated($event.target.value, 'change');
          }
        }
      }), _vm._v(" "), _vm._t("default", [_vm._v(_vm._s(_vm.label))]), _vm._v(" "), _vm._t("feedback", [_vm.validFeedback ? _c('form-feedback', {
        attrs: {
          "valid": ""
        },
        domProps: {
          "innerHTML": _vm._s(_vm.validFeedback)
        }
      }) : _vm._e(), _vm._v(" "), _vm.invalidFeedback ? _c('form-feedback', {
        attrs: {
          "invalid": ""
        },
        domProps: {
          "innerHTML": _vm._s(_vm.invalidFeedback)
        }
      }) : _vm._e()])], 2), _vm._v(" "), _vm._t("help", [_vm.helpText ? _c('help-text', {
        domProps: {
          "innerHTML": _vm._s(_vm.helpText)
        }
      }) : _vm._e()])], 2);
    },
    staticRenderFns: [],
    name: 'checkbox-field',
    extends: RadioField,
    props: {
      /**
       * The checked values
       *
       * @property String
       */
      checked: {
        type: Array,
        default: function _default() {
          return [];
        }
      }
    },
    methods: {
      updated: function updated(value) {
        var checked = this.checked.slice(0);
        var index = this.checked.indexOf(value);

        if (index === -1) {
          checked.push(value);
        } else {
          checked.splice(index, 1);
        }

        this.$emit('change', checked);
      }
    }
  };

  var plugin$7 = VueInstaller.use({
    install: function install(Vue, options) {
      VueInstaller.components({
        CheckboxField: CheckboxField
      });
    }
  });

  var Container = {
    render: function render() {
      var _vm = this;

      var _h = _vm.$createElement;

      var _c = _vm._self._c || _h;

      return _c('div', {
        staticClass: "container"
      }, [_vm._t("default")], 2);
    },
    staticRenderFns: [],
    name: 'container'
  };

  var plugin$8 = VueInstaller.use({
    install: function install(Vue, options) {
      VueInstaller.components({
        Container: Container
      });
    }
  });

  var InputField = {
    render: function render() {
      var _vm = this;

      var _h = _vm.$createElement;

      var _c = _vm._self._c || _h;

      return _c('form-group', [_vm._t("label", [_vm.label ? _c('form-label', {
        attrs: {
          "for": _vm.id
        },
        domProps: {
          "innerHTML": _vm._s(_vm.label)
        }
      }) : _vm._e()]), _vm._v(" "), _vm._t("control", [_c('input', {
        directives: [{
          name: "bind-events",
          rawName: "v-bind-events",
          value: _vm.bindEvents,
          expression: "bindEvents"
        }],
        class: _vm.mergeClasses(_vm.controlClasses, _vm.colorableClasses),
        attrs: {
          "type": _vm.type,
          "id": _vm.id,
          "placeholder": _vm.placeholder,
          "required": _vm.required,
          "disabled": _vm.disabled || _vm.readonly,
          "readonly": _vm.readonly,
          "pattern": _vm.pattern
        },
        domProps: {
          "value": _vm.value
        },
        on: {
          "input": function input($event) {
            _vm.updated($event.target.value);
          }
        }
      })]), _vm._v(" "), _vm._t("help", [_vm.helpText ? _c('help-text', {
        domProps: {
          "innerHTML": _vm._s(_vm.helpText)
        }
      }) : _vm._e()]), _vm._v(" "), _vm._t("feedback", [_vm.validFeedback ? _c('form-feedback', {
        attrs: {
          "valid": ""
        },
        domProps: {
          "innerHTML": _vm._s(_vm.validFeedback)
        }
      }) : _vm._e(), _vm._v(" "), _vm.invalidFeedback ? _c('form-feedback', {
        attrs: {
          "invalid": ""
        },
        domProps: {
          "innerHTML": _vm._s(_vm.invalidFeedback)
        }
      }) : _vm._e()])], 2);
    },
    staticRenderFns: [],
    name: 'input-field',
    mixins: [Colorable, FormControl],
    props: {
      /**
       * The type attribute
       *
       * @property String
       */
      type: {
        type: String,
        default: 'text'
      }
    }
  };

  var FileField = {
    render: function render() {
      var _vm = this;

      var _h = _vm.$createElement;

      var _c = _vm._self._c || _h;

      return _c('form-group', [_vm._t("label", [_vm.label ? _c('form-label', {
        attrs: {
          "for": _vm.id
        },
        domProps: {
          "innerHTML": _vm._s(_vm.label)
        }
      }) : _vm._e()]), _vm._v(" "), _c('div', {
        staticClass: "custom-file"
      }, [_vm._t("placeholder", [_c('form-label', {
        class: _vm.mergeClasses(_vm.colorableClasses, 'custom-file-label'),
        attrs: {
          "for": _vm.id
        },
        domProps: {
          "innerHTML": _vm._s(_vm.placeholder || 'Choose file')
        }
      })]), _vm._v(" "), _c('input', {
        directives: [{
          name: "bind-events",
          rawName: "v-bind-events"
        }],
        class: _vm.controlClasses,
        attrs: {
          "type": "file",
          "id": _vm.id,
          "width": _vm.width,
          "height": _vm.height,
          "required": _vm.required,
          "multiple": _vm.multiple,
          "readonly": _vm.readonly
        },
        on: {
          "change": function change($event) {
            _vm.updated($event.target.files);
          }
        }
      }), _vm._v(" "), _vm._t("help", [_vm.helpText ? _c('help-text', {
        domProps: {
          "innerHTML": _vm._s(_vm.helpText)
        }
      }) : _vm._e()]), _vm._v(" "), _vm._t("feedback", [_vm.validFeedback ? _c('form-feedback', {
        attrs: {
          "valid": ""
        },
        domProps: {
          "innerHTML": _vm._s(_vm.validFeedback)
        }
      }) : _vm._e(), _vm._v(" "), _vm.invalidFeedback ? _c('form-feedback', {
        attrs: {
          "invalid": ""
        },
        domProps: {
          "innerHTML": _vm._s(_vm.invalidFeedback)
        }
      }) : _vm._e()])], 2)], 2);
    },
    staticRenderFns: [],
    name: 'file-field',
    extends: InputField,
    model: {
      event: 'change'
    },
    props: {
      /**
       * The class name assigned to the control element
       *
       * @property String
       */
      defaultControlClass: {
        type: String,
        default: 'custom-file-input'
      },

      /**
       * An array of valid extensions
       *
       * @property String
       */
      extensions: Array,

      /**
       * The type attribute
       *
       * @property String
       */
      multiple: Boolean,

      /**
       * The height attribute for the control element
       *
       * @property String
       */
      height: [Number, String],

      /**
       * The width attribute for the control element
       *
       * @property String
       */
      width: [Number, String]
    }
  };

  var plugin$9 = VueInstaller.use({
    install: function install(Vue, options) {
      VueInstaller.components({
        FileField: FileField
      });
    }
  });

  function readFile(file, progress) {
    return new Promise(function (resolve, reject) {
      var reader = new FileReader();

      reader.onload = function (e) {
        return resolve(e);
      };

      reader.onerror = function (e) {
        return reject(e);
      };

      reader.onabort = function (e) {
        return reject(e);
      };

      reader.onprogress = function (e) {
        return progress(e, reader);
      };

      reader.readAsDataURL(file);
    });
  }

  /** `Object#toString` result references. */
  var numberTag$2 = '[object Number]';

  /**
   * Checks if `value` is classified as a `Number` primitive or object.
   *
   * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
   * classified as numbers, use the `_.isFinite` method.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a number, else `false`.
   * @example
   *
   * _.isNumber(3);
   * // => true
   *
   * _.isNumber(Number.MIN_VALUE);
   * // => true
   *
   * _.isNumber(Infinity);
   * // => true
   *
   * _.isNumber('3');
   * // => false
   */
  function isNumber(value) {
    return typeof value == 'number' ||
      (isObjectLike_1(value) && _baseGetTag(value) == numberTag$2);
  }

  var isNumber_1 = isNumber;

  var ProgressBar = {
    render: function render() {
      var _vm = this;

      var _h = _vm.$createElement;

      var _c = _vm._self._c || _h;

      return _c('div', {
        staticClass: "progress",
        style: {
          'height': _vm.formattedHeight
        }
      }, [_c('div', {
        staticClass: "progress-bar",
        class: _vm.mergeClasses(_vm.progressClasses, _vm.colorableClasses),
        style: {
          'width': _vm.progress + '%'
        },
        attrs: {
          "role": "progressbar",
          "aria-valuenow": _vm.progress,
          "aria-valuemin": "0",
          "aria-valuemax": "100"
        }
      }, [_vm.label ? _c('span', [_vm._v(_vm._s(_vm.progress) + "%")]) : _vm._e()])]);
    },
    staticRenderFns: [],
    name: 'progress-bar',
    mixins: [Colorable],
    props: {
      /**
       * The progress bar percentage value
       *
       * @property String
       */
      progress: {
        type: Number,
        required: true
      },

      /**
       * The height of the progress bar
       *
       * @property String
       */
      height: [Number, String],

      /**
       * Show the progress bar value as a label inside the bar
       *
       * @property String
       */
      label: Boolean,

      /**
       * Should the progress bar appear with stripes
       *
       * @property String
       */
      striped: Boolean,

      /**
       * Should the progress bar appear with animated stripes
       *
       * @property String
       */
      animated: Boolean
    },
    computed: {
      formattedHeight: function formattedHeight() {
        return !this.height ? null : isNumber_1(this.height) ? this.height + 'px' : this.height;
      },
      progressClasses: function progressClasses() {
        return {
          'progress-bar-striped': this.striped,
          'progress-bar-animated': this.animated
        };
      }
    }
  };

  var FilePreview = {
    render: function render() {
      var _vm = this;

      var _h = _vm.$createElement;

      var _c = _vm._self._c || _h;

      return _c('div', {
        staticClass: "file-preview",
        class: {
          'is-image': _vm.isImage
        }
      }, [!_vm.isImage || _vm.image ? _c('a', {
        staticClass: "file-preview-close",
        attrs: {
          "href": "#"
        },
        on: {
          "click": function click($event) {
            $event.preventDefault();

            _vm.$emit('close', _vm.file);
          }
        }
      }, [_c('i', {
        staticClass: "fa fa-times-circle"
      })]) : _vm._e(), _vm._v(" "), _vm.isImage ? _c('div', {
        staticClass: "file-preview-image"
      }, [_vm.image ? _c('img', {
        staticClass: "file-preview-thumbnail",
        attrs: {
          "src": _vm.image
        }
      }) : _c('progress-bar', {
        directives: [{
          name: "ready",
          rawName: "v-ready",
          value: _vm.readFile,
          expression: "readFile"
        }],
        attrs: {
          "progress": _vm.loaded,
          "height": 10
        }
      })], 1) : _c('div', {
        staticClass: "file-preview-icon"
      }, [_c('i', {
        staticClass: "fa fa-file-o"
      })]), _vm._v(" "), _c('div', {
        staticClass: "file-preview-filename",
        domProps: {
          "innerHTML": _vm._s(_vm.name)
        }
      }), _vm._v(" "), _c('div', {
        staticClass: "file-preview-filesize"
      }, [_vm._v("(" + _vm._s(_vm.size) + ")")])]);
    },
    staticRenderFns: [],
    name: 'file-preview',
    components: {
      ProgressBar: ProgressBar
    },
    directives: {
      ready: {
        inserted: function inserted(el, binding) {
          setTimeout(function () {
            if (isFunction_1(binding.value)) {
              binding.value();
            }
          }, 50);
        }
      }
    },
    props: {
      /**
       * The uploaded File object
       *
       * @property Object
       */
      file: {
        type: [Object, File],
        required: true
      },

      /**
       * An array of mime types that should be used to determine if the
       * file is an image.
       *
       * @property Array
       */
      imageMimes: {
        type: Array,
        default: function _default() {
          return ['image/gif', 'image/png', 'image/jpeg', 'image/bmp', 'image/webp'];
        }
      }
    },
    computed: {
      /**
       * Get the file name
       *
       * @property String
       */
      name: function name() {
        return this.file instanceof File ? this.file.name : this.file.orig_filename;
      },

      /**
       * Get the file extension
       *
       * @property String
       */
      extension: function extension() {
        return this.file instanceof File ? this.file.name.split('.').pop().toLowerCase() : this.file.extension;
      },

      /**
       * Get the file formatted size
       *
       * @property String
       */
      size: function size() {
        return this.bytesToSize(this.file instanceof File ? this.file.size : this.file.bytes);
      },

      /**
       * Get the file type
       *
       * @property String
       */
      type: function type() {
        return this.file instanceof File ? this.file.type : this.file.mime;
      },

      /**
       * If the file an image?
       *
       * @property String
       */
      isImage: function isImage() {
        return this.imageMimes.indexOf(this.type) !== -1;
      },

      /**
       * Get the last time the file was modified (as timestamp)
       *
       * @property String
       */
      lastModified: function lastModified() {
        return this.file instanceof File ? this.file.lastModified : null;
      },

      /**
       * Get the last time the file was modified (as Date)
       *
       * @property String
       */
      lastModifiedDate: function lastModifiedDate() {
        return this.file instanceof File ? this.file.lastModifiedDate : null;
      }
    },
    methods: {
      readFile: function readFile$$1() {
        var _this = this;

        if (this.file instanceof File) {
          var start = moment();

          readFile(this.file, function (e) {
            if (e.lengthComputable) {
              _this.loaded = parseInt(e.loaded / e.total * 100, 10);
            }
          }).then(function (e) {
            setTimeout(function () {
              _this.image = e.target.result;
            }, 600 - moment().diff(start));
          });
        }
      },
      bytesToSize: function bytesToSize(bytes) {
        var sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
        if (bytes == 0) return '0 Byte';
        var i = parseInt(Math.floor(Math.log(bytes) / Math.log(1024)));
        return Math.round(bytes / Math.pow(1024, i), 2) + ' ' + sizes[i];
      }
    },
    data: function data() {
      return {
        loaded: 0,
        image: this.file.url
      };
    }
  };

  var plugin$10 = VueInstaller.use({
    install: function install(Vue, options) {
      VueInstaller.components({
        FilePreview: FilePreview
      });
    }
  });

  var FormFeedback = {
    render: function render() {
      var _vm = this;

      var _h = _vm.$createElement;

      var _c = _vm._self._c || _h;

      return _c('div', {
        class: {
          'invalid-feedback': _vm.invalid,
          'valid-feedback': _vm.valid && !_vm.invalid
        }
      }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))])], 2);
    },
    staticRenderFns: [],
    name: 'form-feedback',
    mixins: [Colorable],
    props: {
      /**
       * The value of label element. If no value, no label will appear.
       *
       * @property String
       */
      label: String,

      /**
       * Should the feedback marked as invalid
       *
       * @property String
       */
      invalid: Boolean,

      /**
       * Should the feedback marked as invalid
       *
       * @property String
       */
      valid: Boolean
    }
  };

  var plugin$11 = VueInstaller.use({
    install: function install(Vue, options) {
      VueInstaller.components({
        FormFeedback: FormFeedback
      });
    }
  });

  var FormGroup = {
    render: function render() {
      var _vm = this;

      var _h = _vm.$createElement;

      var _c = _vm._self._c || _h;

      return _c('div', {
        staticClass: "form-group"
      }, [_vm._t("default")], 2);
    },
    staticRenderFns: [],
    name: 'form-group'
  };

  var plugin$12 = VueInstaller.use({
    install: function install(Vue, options) {
      VueInstaller.components({
        FormGroup: FormGroup
      });
    }
  });

  var Screenreaders = {
    props: {
      /**
       * Should show only for screenreaders
       *
       * @property Boolean
       */
      srOnly: Boolean,

      /**
       * Should be focusable for screenreaders
       *
       * @property Boolean
       */
      srOnlyFocusable: Boolean
    },
    computed: {
      screenreaderClasses: function screenreaderClasses() {
        return {
          'sr-only': this.srOnly,
          'sr-only-focusable': this.srOnlyFocusable
        };
      }
    }
  };

  var FormLabel = {
    render: function render() {
      var _vm = this;

      var _h = _vm.$createElement;

      var _c = _vm._self._c || _h;

      return _c('label', {
        class: _vm.classes
      }, [_vm._t("default")], 2);
    },
    staticRenderFns: [],
    name: 'form-label',
    mixins: [Colorable, Screenreaders],
    computed: {
      classes: function classes() {
        return extend({}, this.screenreaderClasses, this.colorableClasses);
      }
    }
  };

  var plugin$13 = VueInstaller.use({
    install: function install(Vue, options) {
      VueInstaller.components({
        FormLabel: FormLabel
      });
    }
  });

  var HelpText = {
    render: function render() {
      var _vm = this;

      var _h = _vm.$createElement;

      var _c = _vm._self._c || _h;

      return _c('small', {
        staticClass: "form-text",
        class: _vm.classes
      }, [_vm._t("default")], 2);
    },
    staticRenderFns: [],
    name: 'help-text',
    mixins: [Colorable, Screenreaders],
    computed: {
      classes: function classes() {
        return extend({}, this.screenreaderClasses, this.colorableClasses);
      }
    }
  };

  var plugin$14 = VueInstaller.use({
    install: function install(Vue, options) {
      VueInstaller.components({
        HelpText: HelpText
      });
    }
  });

  var plugin$15 = VueInstaller.use({
    install: function install(Vue, options) {
      VueInstaller.components({
        InputField: InputField
      });
    }
  });

  var LightSwitchField = {
    render: function render() {
      var _vm = this;

      var _h = _vm.$createElement;

      var _c = _vm._self._c || _h;

      return _c('form-group', [_vm._t("label", [_vm.label ? _c('form-label', {
        attrs: {
          "for": _vm.id
        },
        domProps: {
          "innerHTML": _vm._s(_vm.label)
        }
      }) : _vm._e()]), _vm._v(" "), _c('div', {
        class: _vm.controlClasses,
        attrs: {
          "tabindex": "0"
        },
        on: {
          "click": function click($event) {
            _vm.toggle();
          },
          "keyup": [function ($event) {
            if (!('button' in $event) && $event.keyCode !== 32) {
              return null;
            }

            _vm.toggle();
          }, function ($event) {
            if (!('button' in $event) && $event.keyCode !== 37) {
              return null;
            }

            _vm.toggle(_vm.offValue);
          }, function ($event) {
            if (!('button' in $event) && $event.keyCode !== 39) {
              return null;
            }

            _vm.toggle(_vm.onValue);
          }]
        }
      }, [_c('div', {
        staticClass: "light-switch-handle"
      }), _vm._v(" "), _c('div', {
        staticClass: "light-switch-container"
      }, [_c('div', {
        staticClass: "light-switch-label on-value"
      }), _vm._v(" "), _c('div', {
        staticClass: "light-switch-label off-value"
      })])]), _vm._v(" "), _c('input', {
        staticClass: "form-control d-none",
        attrs: {
          "type": "text",
          "name": _vm.name,
          "id": _vm.id
        },
        domProps: {
          "value": _vm.value
        }
      }), _vm._v(" "), _vm._t("feedback", [_vm.validFeedback ? _c('form-feedback', {
        attrs: {
          "valid": ""
        },
        domProps: {
          "innerHTML": _vm._s(_vm.validFeedback)
        }
      }) : _vm._e(), _vm._v(" "), _vm.invalidFeedback ? _c('form-feedback', {
        attrs: {
          "invalid": ""
        },
        domProps: {
          "innerHTML": _vm._s(_vm.invalidFeedback)
        }
      }) : _vm._e()]), _vm._v(" "), _vm._t("help", [_vm.helpText ? _c('help-text', {
        domProps: {
          "innerHTML": _vm._s(_vm.helpText)
        }
      }) : _vm._e()])], 2);
    },
    staticRenderFns: [],
    name: 'light-switch-field',
    mixins: [FormControl],
    props: {
      /**
       * The class name assigned to the control element
       *
       * @property String
       */
      defaultControlClass: {
        type: String,
        default: 'form-control light-switch'
      },

      /**
       * The class name assigned to the control element
       *
       * @property String
       */
      activeClass: {
        type: String,
        default: 'on'
      },

      /**
       * The class name assigned to the control element
       *
       * @property String
       */
      onValue: {
        default: 1
      },

      /**
       * The class name assigned to the control element
       *
       * @property String
       */
      offValue: {
        default: 0
      }
    },
    computed: {
      isActive: function isActive() {
        return this.value === this.onValue;
      },
      controlClasses: function controlClasses() {
        return [this.controlClass, this.controlSizeClass, this.spacing || '', this.invalidFeedback ? 'is-invalid' : '', this.dragging ? 'is-dragging' : '', this.isActive ? 'is-active' : ''].join(' ');
      }
    },
    methods: {
      getTransitionInMilliseconds: function getTransitionInMilliseconds() {
        var duration = getComputedStyle(this.$el.querySelector('.light-switch-handle')).transitionDuration;
        var numeric = parseFloat(duration, 10);
        var unit = duration.match(/m?s/);

        switch (unit[0]) {
          case 's':
            return numeric * 1000;

          case 'ms':
            return numeric;
        }

        throw new Error("\"".concat(unit[0], "\" is not a valid unit of measure. Unit must be \"s\" (seconds) or \"ms\" (milliseconds)."));
      },
      toggle: function toggle(value) {
        this.$emit('input', !isUndefined_1(value) ? value : this.isActive ? this.offValue : this.onValue);
      }
    },
    watch: {
      value: function value() {
        var _this = this;

        this.dragging = true;
        setTimeout(function () {
          _this.dragging = false;
        }, this.getTransitionInMilliseconds());
      }
    },
    data: function data() {
      return {
        dragging: false
      };
    }
  };

  var plugin$16 = VueInstaller.use({
    install: function install(Vue, options) {
      VueInstaller.components({
        LightSwitchField: LightSwitchField
      });
    }
  });

  var ListGroupItem = {
    render: function render() {
      var _vm = this;

      var _h = _vm.$createElement;

      var _c = _vm._self._c || _h;

      return _vm.href ? _c('a', {
        staticClass: "list-group-item",
        class: _vm.classes,
        attrs: {
          "href": _vm.href
        },
        on: {
          "click": _vm.onClick
        }
      }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))]), _vm._v(" "), _vm.badge ? _c('badge', _vm._b({}, 'badge', _vm.badgeOptions, false)) : _vm._e()], 2) : _vm.action ? _c('a', {
        staticClass: "list-group-item",
        class: _vm.classes,
        attrs: {
          "href": "#"
        },
        on: {
          "click": function click($event) {
            $event.preventDefault();
            return _vm.onClick($event);
          }
        }
      }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))]), _vm._v(" "), _vm.badge ? _c('badge', _vm._b({}, 'badge', _vm.badgeOptions, false)) : _vm._e()], 2) : _c('div', {
        staticClass: "list-group-item",
        class: _vm.classes,
        on: {
          "click": _vm.onClick
        }
      }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))]), _vm._v(" "), _vm.badge ? _c('badge', _vm._b({}, 'badge', _vm.badgeOptions, false)) : _vm._e()], 2);
    },
    staticRenderFns: [],
    components: {
      Badge: Badge
    },
    props: {
      /**
       * The list item label.
       *
       * @property Object
       */
      label: {
        type: [Number, String],
        value: null
      },

      /**
       * The list group item an action, or clickable item.
       *
       * @property Boolean
       */
      action: {
        type: Boolean,
        default: false
      },

      /**
       * The list group item active.
       *
       * @property Boolean
       */
      active: {
        type: Boolean,
        default: false
      },

      /**
       * The list group item disabled.
       *
       * @property Boolean
       */
      disabled: {
        type: Boolean,
        default: false
      },

      /**
       * The list group item variant.
       *
       * @property String
       */
      variant: String,

      /**
       * The list group item href attribute.
       *
       * @property String
       */
      href: String,

      /**
       * The badge label (if number or string) or object of options to pass to
       * the component.
       *
       * @property String|Object
       */
      badge: [Number, String, Object]
    },
    computed: {
      classes: function classes() {
        var classes = prefix({
          'action': this.action
        }, 'list-group-item');
        classes['active'] = this.isActive;
        classes['disabled'] = this.isDisabled;

        if (this.variant) {
          classes[prefix(this.variant, 'list-group-item')] = true;
        }

        return classes;
      },
      badgeOptions: function badgeOptions() {
        return isObject_1(this.badge) ? this.badge : {
          label: this.badge
        };
      }
    },
    methods: {
      /**
       * Toggle the list item's active class.
       *
       * @return void
       */
      toggle: function toggle() {
        this.isActive = !this.isActive;
      },

      /**
       * Activate the list item.
       *
       * @return void
       */
      activate: function activate() {
        this.isActive = true;
      },

      /**
       * Deactivate the list item.
       *
       * @return void
       */
      deactivate: function deactivate() {
        this.isActive = false;
      },

      /**
       * Activate the list item.
       *
       * @return void
       */
      disable: function disable() {
        this.isDisabled = false;
      },

      /**
       * Deactivate the list item.
       *
       * @return void
       */
      enable: function enable() {
        this.isDisabled = false;
      },

      /**
       * The callback function for the `click` event.
       *
       * @return void
       */
      onClick: function onClick(event) {
        this.$emit('click', event, this);
      }
    },
    watch: {
      isActive: function isActive(value, prevValue) {
        this.$emit('update:active', this.isActive);
        this.$emit('toggle', this.isActive, this);
        this.$emit(value ? 'activate' : 'deactivate', this);
      }
    },
    data: function data() {
      return {
        isActive: this.active,
        isDisabled: this.disabled
      };
    }
  };

  var ListGroup = {
    render: function render() {
      var _vm = this;

      var _h = _vm.$createElement;

      var _c = _vm._self._c || _h;

      return _c('div', {
        staticClass: "list-group",
        class: _vm.classes
      }, [_vm._t("default", _vm._l(_vm.items, function (item, key) {
        return _c('list-group-item', _vm._b({
          key: key
        }, 'list-group-item', item, false));
      }))], 2);
    },
    staticRenderFns: [],
    components: {
      ListGroupItem: ListGroupItem
    },
    props: {
      /**
       * An array of list item objects.
       *
       * [{label: 'Some Label', badge: 1}]
       *
       * @property Object
       */
      items: Array,

      /**
       * Can the list items be activated.
       *
       * @property Boolean
       */
      activateable: {
        type: Boolean,
        default: false
      },

      /**
       * The list group appear flush (without some borders).
       *
       * @property Boolean
       */
      flush: {
        type: Boolean,
        default: false
      },

      /**
       * Can activate multiple list items
       *
       * @property Boolean
       */
      multiple: {
        type: Boolean,
        default: false
      }
    },
    computed: {
      classes: function classes() {
        return prefix({
          'flush': this.flush
        }, 'list-group');
      }
    },
    methods: {
      bindEventsToChildren: function bindEventsToChildren() {
        var _this = this;

        each(this.$children, function (child) {
          child.$off('click', _this.onClickChild);
          child.$on('click', _this.onClickChild);
          child.$off('activate', _this.onActivate);
          child.$on('activate', _this.onActivate);
          child.$off('deactivate', _this.onDeactivate);
          child.$on('deactivate', _this.onDeactivate);
        });
      },
      onClickChild: function onClickChild(event, child) {
        if (this.activateable) {
          child.toggle();
        }

        this.$emit('click:child', event, child);
      },
      onActivate: function onActivate(item) {
        if (!this.multiple && this.activeItem !== item) {
          if (this.activeItem) {
            this.activeItem.deactivate();
          }

          this.activeItem = item;
        }
      },
      onDeactivate: function onDeactivate(item) {
        if (!this.multiple && this.activeItem === item) {
          this.activeItem = null;
        }
      }
    },
    data: function data() {
      return {
        activeItem: null
      };
    },
    mounted: function mounted() {
      this.bindEventsToChildren();
    },
    updated: function updated() {
      this.bindEventsToChildren();
    }
  };

  var plugin$17 = VueInstaller.use({
    install: function install(Vue, options) {
      VueInstaller.components({
        ListGroup: ListGroup
      });
    }
  });

  var Overlay = {
    render: function render() {
      var _vm = this;

      var _h = _vm.$createElement;

      var _c = _vm._self._c || _h;

      return _c('div', {
        staticClass: "overlay",
        class: {
          'show': _vm.visible
        },
        style: {
          background: _vm.background
        },
        on: {
          "keyup": function keyup($event) {
            if (!('button' in $event) && _vm._k($event.keyCode, "esc", 27, $event.key, "Escape")) {
              return null;
            }

            return _vm.hide($event);
          }
        }
      }, [_c('button', {
        staticClass: "btn btn-link overlay-close",
        attrs: {
          "type": "button"
        },
        on: {
          "click": _vm.onClickClose
        }
      }, [_c('i', {
        staticClass: "fa fa-times-circle"
      })]), _vm._v(" "), _c('div', {
        staticClass: "overlay-content container"
      }, [_vm._t("default")], 2)]);
    },
    staticRenderFns: [],
    name: 'overlay',
    props: {
      /**
       * The overlay background color.
       *
       * @property String
       */
      background: {
        type: String,
        default: 'rgba(255, 255, 255, .925)'
      },

      /**
       * Is the overlay showing.
       *
       * @property Boolean
       */
      visible: {
        type: Boolean,
        default: true
      }
    },
    watch: {
      visible: function visible(value) {
        if (value) {
          this.focus();
        }
      }
    },
    methods: {
      focus: function focus() {
        var el = this.$el.querySelector('.form-control, input, select, textarea');

        if (el) {
          el.focus();
        }
      },

      /**
       * Show the overlay
       *
       * @return void
       */
      show: function show() {
        this.$mount(document.body.appendChild(document.createElement('div')));
        this.$emit('show');
        this.$emit('update:visible', true);
      },

      /**
       * Hide the overlay
       *
       * @return void
       */
      hide: function hide() {
        this.$emit('hide');
        this.$emit('update:visible', false);
      },

      /**
       * The callback for the `click` event on the close button.
       *
       * @return void
       */
      onClickClose: function onClickClose() {
        this.$emit('click:close');
        this.hide();
      }
    },
    mounted: function mounted() {
      if (this.visible) {
        this.focus();
      }
    }
  };

  var plugin$18 = VueInstaller.use({
    install: function install(Vue, options) {
      VueInstaller.components({
        Overlay: Overlay
      });
    }
  });

  var Pagination = {
    render: function render() {
      var _vm = this;

      var _h = _vm.$createElement;

      var _c = _vm._self._c || _h;

      return _c('nav', {
        attrs: {
          "aria-label": "Page navigation example"
        }
      }, [_c('ul', {
        staticClass: "pagination",
        class: _vm.classes
      }, [_c('li', {
        staticClass: "page-item",
        class: {
          'disabled': _vm.currentPage === 1
        }
      }, [_c('a', {
        staticClass: "page-link",
        attrs: {
          "href": "#",
          "aria-label": "Previous"
        },
        on: {
          "click": function click($event) {
            $event.preventDefault();

            _vm.prev($event);
          }
        }
      }, [_c('span', {
        attrs: {
          "aria-hidden": "true"
        }
      }, [_vm._v("")])])]), _vm._v(" "), _vm._l(_vm.pages, function (item) {
        return _c('li', {
          staticClass: "page-item",
          class: {
            'active': item.page === _vm.currentPage,
            'disabled': !!item.divider
          },
          attrs: {
            "data-page": item.page
          }
        }, [_vm._t("default", [item.divider ? _c('a', {
          staticClass: "page-link"
        }, [_vm._v("")]) : _c('a', {
          staticClass: "page-link",
          class: item.class,
          attrs: {
            "href": "#",
            "data-label": item.label
          },
          on: {
            "click": function click($event) {
              $event.preventDefault();

              _vm.paginate(item.page, $event);
            }
          }
        }, [item.label ? _c('span', {
          attrs: {
            "aria-hidden": "true"
          },
          domProps: {
            "innerHTML": _vm._s(item.label)
          }
        }) : _vm._e(), _vm._v(" "), item.page ? _c('span', {
          attrs: {
            "aria-hidden": "true"
          },
          domProps: {
            "innerHTML": _vm._s(item.page)
          }
        }) : _vm._e()])], {
          item: item
        })], 2);
      }), _vm._v(" "), _c('li', {
        staticClass: "page-item",
        class: {
          'disabled': _vm.currentPage >= _vm.totalPages
        }
      }, [_c('a', {
        staticClass: "page-link",
        attrs: {
          "href": "#",
          "aria-label": "Next"
        },
        on: {
          "click": function click($event) {
            $event.preventDefault();

            _vm.next($event);
          }
        }
      }, [_c('span', {
        attrs: {
          "aria-hidden": "true"
        }
      }, [_vm._v("")])])])], 2)]);
    },
    staticRenderFns: [],
    name: 'pagination',
    props: {
      /**
       * The alignment of the pagination component.
       *
       * @prop String
       */
      align: {
        type: String,
        validate: function validate(value) {
          return ['start', 'end', 'center'].indexOf(value) !== -1;
        }
      },

      /**
       * The page on which the paginator should start.
       *
       * @prop String
       */
      page: {
        type: Number,
        default: 1
      },

      /**
       * The total number of pages in the paginator.
       *
       * @prop String
       */
      totalPages: {
        type: Number,
        default: 1
      },

      /**
       * The number of pages to show when the total number of pages is
       * greater than the number of pages that should be shown.
       *
       * @prop String
       */
      showPages: {
        type: Number,
        default: 6
      },
      onPaginate: Function
    },
    methods: {
      next: function next(event) {
        this.paginate(this.currentPage >= this.totalPages ? this.currentPage : this.currentPage + 1, event);
      },
      prev: function prev(event) {
        this.paginate(this.currentPage <= 1 ? this.currentPage : this.currentPage - 1, event);
      },
      paginate: function paginate(page, event) {
        if (event.currentTarget.parentNode.classList.contains('disabled')) {
          return;
        }

        this.setActivePage(page);

        if (this.onPaginate) {
          this.onPaginate(page, event);
        }

        this.$emit('paginate', page, event);
      },
      setActivePage: function setActivePage(page) {
        if (this.currentPage !== page) {
          this.currentPage = page;
        }
      },
      generate: function generate() {
        var pages = [];
        var showPages = this.showPages % 2 ? this.showPages + 1 : this.showPages;
        var startPage = this.currentPage >= showPages ? this.currentPage - showPages / 2 : 1;
        var startOffset = showPages + startPage;
        var endPage = this.totalPages < startOffset ? this.totalPages : startOffset;
        var diff = startPage - endPage + showPages;
        startPage -= startPage - diff > 0 ? diff : 0;

        if (startPage > 1) {
          pages.push({
            page: 1
          });
        }

        if (startPage > 2) {
          pages.push({
            divider: true
          });
        }

        for (var i = startPage; i < endPage; i++) {
          pages.push({
            page: i
          });
        }

        if (endPage <= this.totalPages) {
          if (this.totalPages - 1 > endPage) {
            pages.push({
              divider: true
            });
          }

          pages.push({
            page: this.totalPages
          });
        }

        return pages;
      }
    },
    computed: {
      pages: function pages() {
        return this.generate();
      },
      classes: function classes() {
        var classes = {};
        classes['justify-content-' + this.align] = true;
        return classes;
      }
    },
    data: function data() {
      return {
        currentPage: this.page
      };
    }
  };

  var plugin$19 = VueInstaller.use({
    install: function install(Vue, options) {
      VueInstaller.components({
        Pagination: Pagination
      });
    }
  });

  var plugin$20 = VueInstaller.use({
    install: function install(Vue, options) {
      VueInstaller.components({
        ProgressBar: ProgressBar
      });
    }
  });

  var plugin$21 = VueInstaller.use({
    install: function install(Vue, options) {
      VueInstaller.components({
        RadioField: RadioField
      });
    }
  });

  //import BaseField from './BaseField';
  var CUSTOM_SELECT_PREFIX = 'custom-select-';
  var SelectField = {
    render: function render() {
      var _vm = this;

      var _h = _vm.$createElement;

      var _c = _vm._self._c || _h;

      return _c('form-group', [_vm._t("label", [_vm.label ? _c('form-label', {
        attrs: {
          "for": _vm.id
        },
        domProps: {
          "innerHTML": _vm._s(_vm.label)
        }
      }) : _vm._e()]), _vm._v(" "), _vm._t("control", [_c('select', {
        class: _vm.mergeClasses(_vm.controlClasses, _vm.colorableClasses),
        attrs: {
          "id": _vm.id,
          "required": _vm.required,
          "disabled": _vm.disabled || _vm.readonly,
          "readonly": _vm.readonly,
          "pattern": _vm.pattern
        },
        domProps: {
          "value": _vm.value
        },
        on: {
          "input": function input($event) {
            _vm.updated($event.target.value);
          }
        }
      }, [_vm._t("default")], 2)]), _vm._v(" "), _vm._t("help", [_vm.helpText ? _c('help-text', {
        domProps: {
          "innerHTML": _vm._s(_vm.helpText)
        }
      }) : _vm._e()]), _vm._v(" "), _vm._t("feedback", [_vm.validFeedback ? _c('form-feedback', {
        attrs: {
          "valid": ""
        },
        domProps: {
          "innerHTML": _vm._s(_vm.validFeedback)
        }
      }) : _vm._e(), _vm._v(" "), _vm.invalidFeedback ? _c('form-feedback', {
        attrs: {
          "invalid": ""
        },
        domProps: {
          "innerHTML": _vm._s(_vm.invalidFeedback)
        }
      }) : _vm._e()])], 2);
    },
    staticRenderFns: [],
    name: 'select-field',
    extends: FormControl,
    mixins: [FormControl, Colorable],
    props: {
      /**
       * Add `custom-select` to the form control if true.
       *
       * @property String
       */
      custom: {
        type: Boolean,
        default: false
      }
    },
    computed: {
      controlClass: function controlClass() {
        var controlClass = this.custom ? 'custom-select' : this.defaultControlClass;
        return this.plaintext ? "".concat(controlClass, "-plaintext") : controlClass;
      },
      customSelectClasses: function customSelectClasses() {
        return [CUSTOM_SELECT_PREFIX.replace(/\-$/, '') + (this.plaintext ? '-plaintext' : ''), this.customSelectSizeClass, this.spacing || ''].join(' ');
      }
    }
  };

  var plugin$22 = VueInstaller.use({
    install: function install(Vue, options) {
      VueInstaller.components({
        SelectField: SelectField
      });
    }
  });

  var Transformer =
  /*#__PURE__*/
  function () {
    /**
     * Initialize the transformer instance using an HTTP response object.
     *
     * @param data object
     * @return void
     */
    function Transformer(response) {
      _classCallCheck(this, Transformer);

      if (!isObject_1(this.$originalResponse = response)) {
        throw new Error('The transformer must be instantiated with a response object.');
      }

      if (!isArray_1(this.$required = this.required()) || !this.$required.length) {
        throw new Error('A transformer must have at least one required property.');
      }

      this.$transformedResponse = this.transform(response);
      this.validate();
      this.initialize();
    }
    /**
     * A method to override to perform logic to finished initializing.
     *
     * @return void
     */


    _createClass(Transformer, [{
      key: "initialize",
      value: function initialize() {} //

      /**
       * Define an array of required propertie with at least one value.
       *
       * @return void
       */

    }, {
      key: "required",
      value: function required() {} //

      /**
       * Tranform the response object
       *
       * @property String
       */

    }, {
      key: "transform",
      value: function transform(response) {
        return response;
      }
      /**
       * Get the tranformed response
       *
       * @property String
       */

    }, {
      key: "response",
      value: function response() {
        return this.$transformedResponse;
      }
      /**
       * Validate the tranformed response.
       *
       * @return void
       */

    }, {
      key: "validate",
      value: function validate() {
        var _this = this;

        if (!isObject_1(this.$transformedResponse)) {
          throw new Error('The transformed response must be an object.');
        }

        each(this.$required, function (key) {
          if (!(key in _this.$transformedResponse)) {
            throw new Error("\"".concat(key, "\" is a required property and does not exist in the tranformed response."));
          }
        });
      }
    }]);

    return Transformer;
  }();

  var TableViewTransformer =
  /*#__PURE__*/
  function (_Transformer) {
    _inherits(TableViewTransformer, _Transformer);

    function TableViewTransformer() {
      _classCallCheck(this, TableViewTransformer);

      return _possibleConstructorReturn(this, (TableViewTransformer.__proto__ || Object.getPrototypeOf(TableViewTransformer)).apply(this, arguments));
    }

    _createClass(TableViewTransformer, [{
      key: "required",
      value: function required() {
        return [// The end of the count of the paginated list.
        'to', // The start of the count of the paginated list.
        'from', // The total number of items (not just included in the pagination)
        'total', // The number of items per page
        'per_page', // The last page number (or total pages)
        'last_page', // The current page number
        'current_page', // The actual response data to appear in the table
        'data'];
      }
    }, {
      key: "data",
      value: function data() {
        return this.$transformedResponse.data;
      }
    }, {
      key: "initialize",
      value: function initialize() {
        if (!isArray_1(this.data())) {
          throw new Error('The data property must be an array.');
        }
      }
    }]);

    return TableViewTransformer;
  }(Transformer);

  var TableView = {
    render: function render() {
      var _vm = this;

      var _h = _vm.$createElement;

      var _c = _vm._self._c || _h;

      return _c('div', {
        staticClass: "table-view"
      }, [_c('div', {
        staticClass: "d-flex justify-content-between align-items-center"
      }, [_vm._t("header", [_c('div', {
        staticClass: "table-view-header"
      }, [_vm._t("heading", [_vm.heading ? _c('h3', {
        domProps: {
          "innerHTML": _vm._s(_vm.heading)
        }
      }) : _vm._e()]), _vm._v(" "), _vm._t("description", [_vm.description ? _c('p', {
        domProps: {
          "innerHTML": _vm._s(_vm.description)
        }
      }) : _vm._e()])], 2)]), _vm._v(" "), _vm._t("buttons", [_vm.buttons.length ? _c('div', {
        staticClass: "buttons-wrapper my-3"
      }, [_c('span', _vm._l(_vm.buttons, function (button, key) {
        return _c('a', {
          class: button.className || 'btn btn-primary',
          attrs: {
            "href": button.href || '#'
          },
          on: {
            "click": function click($event) {
              _vm.proxy(button.onClick, $event);
            }
          }
        }, [button.icon ? _c('i', {
          class: button.icon
        }) : _vm._e(), _vm._v(" "), _c('span', {
          domProps: {
            "innerHTML": _vm._s(button.label)
          }
        })]);
      }))]) : _vm._e()])], 2), _vm._v(" "), _c('table', {
        staticClass: "table",
        class: {
          'table-hover': !_vm.loading
        }
      }, [_vm._t("thead", [_c('thead', [_c('tr', _vm._l(_vm.tableColumns, function (column) {
        return _c('th', {
          attrs: {
            "scope": "col",
            "width": column.width
          }
        }, [column.id ? _c('div', [_c('a', {
          staticClass: "sort",
          attrs: {
            "href": "#",
            "data-id": column.id
          },
          domProps: {
            "innerHTML": _vm._s(column.name || column.id)
          },
          on: {
            "click": function click($event) {
              $event.preventDefault();

              _vm.orderBy(column.id);
            }
          }
        }), _vm._v(" "), _vm.request.params.order === column.id && _vm.request.params.sort === 'asc' ? _c('i', {
          staticClass: "sort-icon fa fa-sort-asc"
        }) : _vm._e(), _vm._v(" "), _vm.request.params.order === column.id && _vm.request.params.sort === 'desc' ? _c('i', {
          staticClass: "sort-icon fa fa-sort-desc"
        }) : _vm._e()]) : _c('div', {
          domProps: {
            "innerHTML": _vm._s(column.name)
          }
        })]);
      }))])]), _vm._v(" "), _vm._t("tbody", [_c('tbody', [_vm.loading ? _c('tr', [_c('td', {
        staticClass: "position-relative",
        style: {
          'height': _vm.height(_vm.minHeight)
        },
        attrs: {
          "colspan": _vm.tableColumns.length
        }
      }, [_c('activity-indicator', {
        attrs: {
          "center": true
        }
      })], 1)]) : _vm._t("default", _vm._l(_vm.data, function (row, i) {
        return _c('tr', _vm._l(_vm.tableColumns, function (column) {
          return _c('td', {
            domProps: {
              "innerHTML": _vm._s(row[column.id] || row[column.name])
            }
          });
        }));
      }), {
        data: _vm.data,
        columns: _vm.tableColumns
      })], 2)]), _vm._v(" "), _vm._t("tfoot", [_c('tfoot', [_c('td', {
        staticClass: "table-view-footer",
        attrs: {
          "colspan": _vm.tableColumns.length
        }
      }, [_vm._t("pagination", [_vm.paginate && _vm.response ? _c('pagination', {
        attrs: {
          "align": "center",
          "page": _vm.response.current_page,
          "total-pages": _vm.response.last_page,
          "on-paginate": _vm.onPaginate
        }
      }) : _vm._e()])], 2)])])], 2)]);
    },
    staticRenderFns: [],
    name: 'table-view',
    mixins: [Proxy],
    components: {
      Pagination: Pagination,
      ActivityIndicator: ActivityIndicator
    },
    props: {
      // (string) A relative or absolute endpoint URL used to fetch data
      url: {
        type: String,
        required: true
      },
      // (integer) The starting page of the table
      page: {
        type: Number,
        default: 1
      },
      // (integer) The total number of results per page
      limit: {
        type: Number,
        default: 20
      },
      // (string) The column used to order the data
      order: String,
      // (string) The sort direction (asc|desc)
      sort: {
        type: String,
        validate: function validate(value) {
          return ['asc', 'desc'].indexOf(value) !== -1;
        }
      },
      // (integer) The minimum height of the row when loading data
      minHeight: {
        type: Number,
        default: 400
      },
      // (array) An array of button objects
      // [{href: 'test-123', label: 'Test 123'}]
      buttons: {
        type: Array,
        default: function _default() {
          return [];
        }
      },
      // (array) An array of table column
      // [{id: 'database_id', name: 'Database id', width: '20%'}]
      columns: {
        type: Array,
        default: function _default() {
          return [];
        }
      },
      // (string) The table heading
      heading: String,
      // (string) The table description
      description: String,
      // (bool) Should show the pagination for this table
      paginate: {
        type: Boolean,
        default: true
      },
      // (object) The HTTP response transformer instance
      transformer: {
        type: Object,
        validate: function validate(value) {
          return value instanceof TableViewTransformer;
        }
      }
    },
    computed: {
      tableColumns: function tableColumns() {
        var columns = this.columns;

        if (!columns || !columns.length) {
          columns = keys_1(this.data[0]);
        }

        return columns.map(function (column) {
          return isObject_1(column) ? column : {
            name: column
          };
        });
      }
    },
    methods: {
      orderBy: function orderBy(order) {
        var defaultSort = 'desc';
        var currentSort = this.getRequestParam('sort');
        var currentOrder = this.getRequestParam('order');
        this.addRequestParam('order', order);
        this.addRequestParam('sort', currentOrder !== order || !currentSort ? defaultSort : currentSort === defaultSort ? 'asc' : null);
        this.fetch();
      },
      getRequestHeader: function getRequestHeader(key, value) {
        return this.request.headers[key] || value;
      },
      addRequestHeader: function addRequestHeader(key, value) {
        if (!this.request.headers) {
          this.request.headers = {};
        }

        this.request.headers[key] = value;
      },
      getRequestParam: function getRequestParam(key, value) {
        return this.request.params[key] || value;
      },
      addRequestParam: function addRequestParam(key, value) {
        if (!this.request.params) {
          this.request.params = {};
        }

        this.request.params[key] = value;
      },
      fetch: function fetch() {
        var _this = this;

        var request = new Request(this.url, this.request);
        this.loading = true;
        return request.get().then(function (response) {
          var transformer = _this.transformer || new TableViewTransformer(response);
          _this.response = transformer.response();
          _this.data = transformer.data();
          _this.loading = false;
        }, function (errors) {
          _this.loading = false;
        });
      },
      height: function height(min) {
        var elements = [// this.$el.querySelector('thead'),
        this.$el.querySelector('tbody')];
        var height = 0;

        each(elements, function (el) {
          height += el.getBoundingClientRect().height;
        });

        return Math.max(min, height) + 'px';
      },
      onPaginate: function onPaginate(page, event) {
        if (!this.request.params) {
          this.request.params = {};
        }

        this.request.params.page = page;
        this.fetch();
      }
    },
    data: function data() {
      return {
        // (array) The dataset for the table
        data: this.$attrs.data || [],
        // (bool) Is the table currently loading data
        loading: false,
        // (null|object) The response object
        response: null,
        // (object) The HTTP request object
        request: extend({
          headers: {},
          params: {
            page: this.page,
            limit: this.limit,
            order: this.order,
            sort: this.sort
          }
        }, this.$attrs.request)
      };
    },
    mounted: function mounted() {
      this.fetch();
    },

    /*
    data() {
        return extend({
            buttons: [],
             columns: [],
             header: false,
             description: false,
             // (bool) Should show the pagination for this table
            paginate: true,
             // (bool) Is the table currently loading data
            loading: false,
             // (object) An object with key/value pairs for components used in the template
            components: {
                // (string) The name of the component used for the table header
                header: 'table-view-header',
                 // (string) The name of the component used for the table row
                row: 'table-view-row',
                 // (string) The name of the component used for the table row
                footer: 'table-view-footer'
            },
             // (int) The starting page
            // page: 1,
             // (string) The order of the date being returned
            // order: null,
             // (string) Either asc or desc sorting order
            // sort: null,
             // (int) The numbers of rows per page
            // limit: 20,
             // (bool) Fetch the data when table is shown
            // fetchOnRender: true,
             // (array) An array of headers appended to the request
            // requestHeaders: [],
             // (array) The default options used to generate the query string
            // defaultRequestDataOptions: [
            //    'page',
            //    'limit',
            //    'order',
            //    'sort'
            // ],
             // (object) An option to pass an object with request data
            // requestData: {},
             // (array) Additional options used to generate the query string
            // requestDataOptions: [],
             // (object) The body view options object
            // bodyViewOptions: false,
             // (object) The pagination view class
            // footerView: 'pagination',
             // (object) The pagination view options object
            // footerViewOptions: false,
             // (string) The table footer class name
            // footerClassName: 'table-header',
             // (string) The table header
            // header: false,
             // (string) The table header tag name
            // headerTagName: 'h3',
             // (string) The table header class name
            // headerClassName: 'table-header',
             // (object) The header view class
            // headerView: false,
             // (object) The header view options object
            // headerViewOptions: false,
             // (string) The table description
            // description: false,
             // (string) The table description tag
            // descriptionTag: 'p',
             // (string) The table description tag
            // descriptionClassName: 'description row col-sm-6',
             // (string) The table class name
            // tableClassName: 'table',
             // (string) The loading class name
            // loadingClassName: 'loading',
             // (string) The name of the property in the model storing the columns
            // childViewColumnsProperty: 'columns',
             // (object) The activity indicator options
            // indicatorOptions: {
            //     indicator: 'small'
            // },
             // (string) The message to display if there are no table rows
            // emptyMessage: 'No rows found',
             // (string) The name of the class appended to the buttons
            // buttonClassName: 'btn btn-default',
        }, this.$attrs);
    },
    */
    beforeDestroy: function beforeDestroy() {
      this.$off();
    }
  };

  var plugin$23 = VueInstaller.use({
    install: function install(Vue, options) {
      VueInstaller.components({
        TableView: TableView
      });
    }
  });

  var TextareaField = {
    render: function render() {
      var _vm = this;

      var _h = _vm.$createElement;

      var _c = _vm._self._c || _h;

      return _c('form-group', [_vm._t("label", [_vm.label ? _c('form-label', {
        attrs: {
          "for": _vm.id
        },
        domProps: {
          "innerHTML": _vm._s(_vm.label)
        }
      }) : _vm._e()]), _vm._v(" "), _vm._t("control", [_c('textarea', {
        directives: [{
          name: "bind-events",
          rawName: "v-bind-events",
          value: _vm.bindEvents,
          expression: "bindEvents"
        }],
        class: _vm.mergeClasses(_vm.controlClasses, _vm.colorableClasses),
        attrs: {
          "id": _vm.id,
          "placeholder": _vm.placeholder,
          "required": _vm.required,
          "disabled": _vm.disabled || _vm.readonly,
          "readonly": _vm.readonly,
          "pattern": _vm.pattern
        },
        domProps: {
          "value": _vm.value
        },
        on: {
          "input": function input($event) {
            _vm.updated($event.target.value);
          }
        }
      })]), _vm._v(" "), _vm._t("help", [_vm.helpText ? _c('help-text', {
        domProps: {
          "innerHTML": _vm._s(_vm.helpText)
        }
      }) : _vm._e()]), _vm._v(" "), _vm._t("feedback", [_vm.validFeedback ? _c('form-feedback', {
        attrs: {
          "valid": ""
        },
        domProps: {
          "innerHTML": _vm._s(_vm.validFeedback)
        }
      }) : _vm._e(), _vm._v(" "), _vm.invalidFeedback ? _c('form-feedback', {
        attrs: {
          "invalid": ""
        },
        domProps: {
          "innerHTML": _vm._s(_vm.invalidFeedback)
        }
      }) : _vm._e()])], 2);
    },
    staticRenderFns: [],
    name: 'textarea-field',
    mixins: [Colorable, FormControl],
    props: {
      /**
       * The type attribute
       *
       * @property String
       */
      type: {
        type: String,
        default: 'text'
      }
    }
  };

  var plugin$24 = VueInstaller.use({
    install: function install(Vue, options) {
      VueInstaller.components({
        TextareaField: TextareaField
      });
    }
  });

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeMax$4 = Math.max;

  /**
   * This method is like `_.find` except that it returns the index of the first
   * element `predicate` returns truthy for instead of the element itself.
   *
   * @static
   * @memberOf _
   * @since 1.1.0
   * @category Array
   * @param {Array} array The array to inspect.
   * @param {Function} [predicate=_.identity] The function invoked per iteration.
   * @param {number} [fromIndex=0] The index to search from.
   * @returns {number} Returns the index of the found element, else `-1`.
   * @example
   *
   * var users = [
   *   { 'user': 'barney',  'active': false },
   *   { 'user': 'fred',    'active': false },
   *   { 'user': 'pebbles', 'active': true }
   * ];
   *
   * _.findIndex(users, function(o) { return o.user == 'barney'; });
   * // => 0
   *
   * // The `_.matches` iteratee shorthand.
   * _.findIndex(users, { 'user': 'fred', 'active': false });
   * // => 1
   *
   * // The `_.matchesProperty` iteratee shorthand.
   * _.findIndex(users, ['active', false]);
   * // => 0
   *
   * // The `_.property` iteratee shorthand.
   * _.findIndex(users, 'active');
   * // => 2
   */
  function findIndex(array, predicate, fromIndex) {
    var length = array == null ? 0 : array.length;
    if (!length) {
      return -1;
    }
    var index = fromIndex == null ? 0 : toInteger_1(fromIndex);
    if (index < 0) {
      index = nativeMax$4(length + index, 0);
    }
    return _baseFindIndex(array, _baseIteratee(predicate, 3), index);
  }

  var findIndex_1 = findIndex;

  /**
   * Gets the last element of `array`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Array
   * @param {Array} array The array to query.
   * @returns {*} Returns the last element of `array`.
   * @example
   *
   * _.last([1, 2, 3]);
   * // => 3
   */
  function last(array) {
    var length = array == null ? 0 : array.length;
    return length ? array[length - 1] : undefined;
  }

  var last_1 = last;

  /**
   * Gets the parent value at `path` of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} path The path to get the parent value of.
   * @returns {*} Returns the parent value.
   */
  function parent(object, path) {
    return path.length < 2 ? object : _baseGet(object, _baseSlice(path, 0, -1));
  }

  var _parent = parent;

  /**
   * The base implementation of `_.unset`.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {Array|string} path The property path to unset.
   * @returns {boolean} Returns `true` if the property is deleted, else `false`.
   */
  function baseUnset(object, path) {
    path = _castPath(path, object);
    object = _parent(object, path);
    return object == null || delete object[_toKey(last_1(path))];
  }

  var _baseUnset = baseUnset;

  /** Used for built-in method references. */
  var arrayProto$1 = Array.prototype;

  /** Built-in value references. */
  var splice$1 = arrayProto$1.splice;

  /**
   * The base implementation of `_.pullAt` without support for individual
   * indexes or capturing the removed elements.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {number[]} indexes The indexes of elements to remove.
   * @returns {Array} Returns `array`.
   */
  function basePullAt(array, indexes) {
    var length = array ? indexes.length : 0,
        lastIndex = length - 1;

    while (length--) {
      var index = indexes[length];
      if (length == lastIndex || index !== previous) {
        var previous = index;
        if (_isIndex(index)) {
          splice$1.call(array, index, 1);
        } else {
          _baseUnset(array, index);
        }
      }
    }
    return array;
  }

  var _basePullAt = basePullAt;

  /**
   * Removes all elements from `array` that `predicate` returns truthy for
   * and returns an array of the removed elements. The predicate is invoked
   * with three arguments: (value, index, array).
   *
   * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
   * to pull elements from an array by value.
   *
   * @static
   * @memberOf _
   * @since 2.0.0
   * @category Array
   * @param {Array} array The array to modify.
   * @param {Function} [predicate=_.identity] The function invoked per iteration.
   * @returns {Array} Returns the new array of removed elements.
   * @example
   *
   * var array = [1, 2, 3, 4];
   * var evens = _.remove(array, function(n) {
   *   return n % 2 == 0;
   * });
   *
   * console.log(array);
   * // => [1, 3]
   *
   * console.log(evens);
   * // => [2, 4]
   */
  function remove(array, predicate) {
    var result = [];
    if (!(array && array.length)) {
      return result;
    }
    var index = -1,
        indexes = [],
        length = array.length;

    predicate = _baseIteratee(predicate, 3);
    while (++index < length) {
      var value = array[index];
      if (predicate(value, index, array)) {
        result.push(value);
        indexes.push(index);
      }
    }
    _basePullAt(array, indexes);
    return result;
  }

  var remove_1 = remove;

  var UploadField = {
    render: function render() {
      var _vm = this;

      var _h = _vm.$createElement;

      var _c = _vm._self._c || _h;

      return _c('form-group', {
        staticClass: "upload-field",
        class: {
          'enable-dropzone': _vm.dropzone
        },
        on: {
          "dragenter": function dragenter($event) {
            $event.preventDefault();
            return _vm.onDragEnter($event);
          },
          "dragover": function dragover($event) {
            $event.preventDefault();
            return _vm.onDragOver($event);
          },
          "dragleave": function dragleave($event) {
            $event.preventDefault();
            return _vm.onDragLeave($event);
          }
        }
      }, [_vm.multiple && (!_vm.maxUploads || _vm.maxUploads > _vm.data.length) || !_vm.multiple && !_vm.data ? _c('file-field', {
        attrs: {
          "name": _vm.name,
          "label": _vm.label,
          "placeholder": _vm.placeholder,
          "help-text": _vm.helpText,
          "multiple": _vm.multiple,
          "width": _vm.width,
          "height": _vm.height,
          "errors": _vm.errors
        },
        on: {
          "change": function change($event) {
            _vm.multiple ? _vm.addFiles($event.target.files) : _vm.addFile($event.target.files[0]);
          }
        }
      }) : _vm._e(), _vm._v(" "), _vm.multiple ? _c('div', {
        staticClass: "upload-field-preview mt-4"
      }, _vm._l(_vm.data, function (file, key) {
        return _c('file-preview', {
          key: [file.name, file.lastModified, file.size].join(''),
          attrs: {
            "file": file
          },
          on: {
            "close": function close($event) {
              _vm.removeFile(file);
            }
          }
        });
      })) : !_vm.multiple && _vm.data ? _c('div', {
        staticClass: "upload-field-preview mt-4"
      }, [_c('file-preview', {
        attrs: {
          "file": _vm.data
        },
        on: {
          "close": function close($event) {
            _vm.removeFile(_vm.data);
          }
        }
      })], 1) : _vm._e(), _vm._v(" "), _vm.showDropElement ? _c('div', {
        staticClass: "upload-field-dropzone",
        style: {
          'min-height': _vm.dropzoneMinHeight
        },
        on: {
          "drop": function drop($event) {
            $event.preventDefault();
            return _vm.onDrop($event);
          }
        }
      }, [_c('i', {
        staticClass: "fa fa-cloud-upload"
      }), _vm._v(" "), _c('div', [_vm._v("Drag and drop files to upload")])]) : _vm._e()], 1);
    },
    staticRenderFns: [],
    name: 'upload-field',
    mixins: [FormControl],
    components: {
      FileField: FileField,
      FilePreview: FilePreview
    },
    model: {
      prop: 'data',
      event: 'change'
    },
    props: {
      /**
       * Is the user dragging a file over the dropzone
       *
       * @property String
       */
      dragging: {
        type: [String, Boolean],
        default: function _default() {
          return undefined;
        }
      },

      /**
       * The maximum number of files that a user can upload
       *
       * @property String
       */
      maxUploads: Number,

      /**
       * The height attribute for the control element
       *
       * @property String
       */
      height: [Number, String],

      /**
       * The width attribute for the control element
       *
       * @property String
       */
      width: [Number, String],

      /**
       * Can user drag/drop files into browser to upload them.
       *
       * @property String
       */
      dropzone: {
        type: Boolean,
        default: true
      },

      /**
       * Can user drag/drop files into browser to upload them.
       *
       * @property String
       */
      dropzoneMinHeight: [Number, String],

      /**
       * Can user upload multiple files
       *
       * @property String
       */
      multiple: {
        type: Boolean,
        default: false
      },

      /**
       * The data attribute
       *
       * @property File|FileList|Array
       */
      data: {
        type: [Object, File, FileList, Array],
        default: function _default() {
          return !this.multiple ? null : [];
        }
      }
    },
    methods: {
      removeFile: function removeFile(data) {
        if (this.multiple) {
          var files = this.data.slice(0);

          remove_1(files, {
            name: data.name,
            size: data.size,
            lastModified: data.lastModified
          });

          this.$emit('change', files);
        } else {
          this.$emit('change', null);
        }
      },
      addFile: function addFile(file, subject) {
        var data = {
          name: file.name,
          lastModified: file.lastModified,
          lastModifiedDate: file.lastModifiedDate,
          size: file.size,
          type: file.type
        };

        if (this.multiple) {
          var files = subject || this.data.slice(0);

          if (!this.maxUploads || this.maxUploads > files.length) {
            if (findIndex_1(files, data) === -1) {
              files.push(file);
            }

            this.$emit('change', files);
          }
        } else {
          this.$emit('change', file);
        }
      },
      addFiles: function addFiles(files) {
        var _this = this;

        var subject = this.data.slice(0);

        each(files, function (file) {
          _this.addFile(file, subject);
        });

        event.target.value = null;
      },

      /**
       * The `dragover` event callback.
       *
       * @property String
       */
      onDragOver: function onDragOver(event) {
        this.isDraggingInside = true;
        this.$emit('update:dragging', true);
        this.$emit('drag:over', event);
      },

      /**
       * The `dragover` event callback.
       *
       * @property String
       */
      onDragEnter: function onDragEnter(event) {
        this.isDraggingInside = true;
        this.$emit('update:dragging', true);
        this.$emit('drag:enter', event);
      },

      /**
       * The `dragleave` event callback.
       *
       * @property String
       */
      onDragLeave: function onDragLeave(event) {
        this.isDraggingInside = false;
        this.$emit('update:dragging', false);
        this.$emit('drag:leave', event);
      },

      /**
       * The `drop` event callback.
       *
       * @property String
       */
      onDrop: function onDrop(event) {
        this.isDraggingInside = false;
        this.addFiles(event.dataTransfer.files);
        this.$emit('update:dragging', false);
        this.$emit('drop', event);
      }
    },
    computed: {
      showDropElement: function showDropElement() {
        return !isUndefined_1(this.dragging) ? this.dragging : this.isDraggingInside;
      }
    },
    data: function data() {
      return {
        isDraggingInside: false
      };
    }
  };

  var plugin$25 = VueInstaller.use({
    install: function install(Vue, options) {
      VueInstaller.components({
        UploadField: UploadField
      });
    }
  });



  var components$1 = /*#__PURE__*/Object.freeze({
    ActivityButton: ActivityButton,
    ActivityIndicator: ActivityIndicator,
    Badge: Badge,
    BaseForm: BaseForm,
    ButtonDropdown: ButtonDropdown,
    CheckboxField: CheckboxField,
    Container: Container,
    DropdownMenu: DropdownMenu,
    DropdownMenuItem: DropdownMenuItem,
    DropdownMenuHeader: DropdownMenuHeader,
    DropdownMenuDivider: DropdownMenuDivider,
    FileField: FileField,
    FilePreview: FilePreview,
    FormFeedback: FormFeedback,
    FormGroup: FormGroup,
    FormLabel: FormLabel,
    HelpText: HelpText,
    InputField: InputField,
    LightSwitchField: LightSwitchField,
    ListGroup: ListGroup,
    ListGroupItem: ListGroupItem,
    Overlay: Overlay,
    Pagination: Pagination,
    ProgressBar: ProgressBar,
    RadioField: RadioField,
    SelectField: SelectField,
    TableView: TableView,
    TextareaField: TextareaField,
    UploadField: UploadField
  });

  var ResponseTransformer = function ResponseTransformer(response) {
    _classCallCheck(this, ResponseTransformer);

    this.$response = response;
  };

  var Sizeable = {
    props: {
      /**
       * The size of the form control
       *
       * @property String
       */
      size: {
        type: String,
        default: 'md',
        validate: function validate(value) {
          return ['sm', 'md', 'lg'].indexOf(value) !== -1;
        }
      }
    },
    computed: {
      sizeableClass: function sizeableClass() {
        return prefix(this.size, this.$options.name);
      }
    }
  };

  function blob(url, progress) {
    return new Promise(function (resolve, reject) {
      var xhr = new XMLHttpRequest();
      xhr.open('GET', url, true);
      xhr.responseType = 'blob';

      if (isFunction_1(progress)) {
        xhr.onprogress = function (e) {
          return progress(e, xhr);
        };
      }

      xhr.onerror = function (e) {
        return reject(e);
      };

      xhr.onabort = function (e) {
        return reject(e);
      };

      xhr.onload = function (e) {
        if (this.status === 200) {
          resolve(this.response);
        } else {
          reject(e);
        }
      };

      xhr.send();
    });
  }

  var main = VueInstaller.use({
    install: function install(Vue) {
      VueInstaller.plugins(Vue, plugins);
      VueInstaller.components(Vue, components$1); //VueInstaller.directives(Vue, directives);
    }
  });

  exports.default = main;
  exports.Model = Model;
  exports.Request = Request;
  exports.ResponseTransformer = ResponseTransformer;
  exports.TableViewTransformer = TableViewTransformer;
  exports.Transformer = Transformer;
  exports.Colorable = Colorable;
  exports.FormControl = FormControl;
  exports.Proxy = Proxy;
  exports.Screenreaders = Screenreaders;
  exports.Sizeable = Sizeable;
  exports.Variant = Variant;
  exports.MergeClasses = MergeClasses;
  exports.ActivityButton = ActivityButton;
  exports.ActivityIndicator = ActivityIndicator;
  exports.Badge = Badge;
  exports.BaseForm = BaseForm;
  exports.ButtonDropdown = ButtonDropdown;
  exports.CheckboxField = CheckboxField;
  exports.Container = Container;
  exports.DropdownMenu = DropdownMenu;
  exports.DropdownMenuItem = DropdownMenuItem;
  exports.DropdownMenuHeader = DropdownMenuHeader;
  exports.DropdownMenuDivider = DropdownMenuDivider;
  exports.FileField = FileField;
  exports.FilePreview = FilePreview;
  exports.FormFeedback = FormFeedback;
  exports.FormGroup = FormGroup;
  exports.FormLabel = FormLabel;
  exports.HelpText = HelpText;
  exports.InputField = InputField;
  exports.LightSwitchField = LightSwitchField;
  exports.ListGroup = ListGroup;
  exports.ListGroupItem = ListGroupItem;
  exports.Overlay = Overlay;
  exports.Pagination = Pagination;
  exports.ProgressBar = ProgressBar;
  exports.RadioField = RadioField;
  exports.SelectField = SelectField;
  exports.TableView = TableView;
  exports.TextareaField = TextareaField;
  exports.UploadField = UploadField;
  exports.blob = blob;
  exports.prefix = prefix;
  exports.readFile = readFile;
  exports.uuid = uuid;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidnVlLXRvb2xib3guanMiLCJzb3VyY2VzIjpbIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3QuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19mcmVlR2xvYmFsLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fcm9vdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1N5bWJvbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFJhd1RhZy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX29iamVjdFRvU3RyaW5nLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUdldFRhZy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNGdW5jdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcmVKc0RhdGEuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc01hc2tlZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3RvU291cmNlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzTmF0aXZlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0VmFsdWUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXROYXRpdmUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19kZWZpbmVQcm9wZXJ0eS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VBc3NpZ25WYWx1ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvZXEuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hc3NpZ25WYWx1ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcHlPYmplY3QuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lkZW50aXR5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXBwbHkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19vdmVyUmVzdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvY29uc3RhbnQuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlU2V0VG9TdHJpbmcuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zaG9ydE91dC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldFRvU3RyaW5nLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVJlc3QuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzTGVuZ3RoLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5TGlrZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzSW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0l0ZXJhdGVlQ2FsbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZUFzc2lnbmVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVRpbWVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc09iamVjdExpa2UuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNBcmd1bWVudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJndW1lbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9zdHViRmFsc2UuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQnVmZmVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzVHlwZWRBcnJheS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VVbmFyeS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX25vZGVVdGlsLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1R5cGVkQXJyYXkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUxpa2VLZXlzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNQcm90b3R5cGUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVLZXlzSW4uanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlS2V5c0luLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9rZXlzSW4uanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL2Fzc2lnbkluLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9leHRlbmQuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVDbGVhci5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Fzc29jSW5kZXhPZi5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZURlbGV0ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUdldC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUhhcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZVNldC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX0xpc3RDYWNoZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrQ2xlYXIuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0RlbGV0ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrR2V0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tIYXMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19NYXAuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVDcmVhdGUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoQ2xlYXIuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoRGVsZXRlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaEdldC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hIYXMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoU2V0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fSGFzaC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlQ2xlYXIuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0tleWFibGUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRNYXBEYXRhLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVEZWxldGUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUdldC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlSGFzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVTZXQuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19NYXBDYWNoZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrU2V0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU3RhY2suanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hc3NpZ25NZXJnZVZhbHVlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlQmFzZUZvci5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VGb3IuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZUJ1ZmZlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1VpbnQ4QXJyYXkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZUFycmF5QnVmZmVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVUeXBlZEFycmF5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY29weUFycmF5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUNyZWF0ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX292ZXJBcmcuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRQcm90b3R5cGUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pbml0Q2xvbmVPYmplY3QuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXlMaWtlT2JqZWN0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1BsYWluT2JqZWN0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc2FmZUdldC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvdG9QbGFpbk9iamVjdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VNZXJnZURlZXAuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlTWVyZ2UuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL21lcmdlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlFYWNoLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbmF0aXZlS2V5cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VLZXlzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9rZXlzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUZvck93bi5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZUJhc2VFYWNoLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUVhY2guanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jYXN0RnVuY3Rpb24uanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL2ZvckVhY2guanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL2VhY2guanMiLCIuLi9zcmMvUGx1Z2lucy9NZXJnZUNsYXNzZXMvTWVyZ2VDbGFzc2VzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlSZWR1Y2UuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlUHJvcGVydHlPZi5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2RlYnVyckxldHRlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5TWFwLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1N5bWJvbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VUb1N0cmluZy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvdG9TdHJpbmcuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL2RlYnVyci5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FzY2lpV29yZHMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNVbmljb2RlV29yZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3VuaWNvZGVXb3Jkcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvd29yZHMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jcmVhdGVDb21wb3VuZGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9rZWJhYkNhc2UuanMiLCIuLi9zcmMvQ29tcG9uZW50cy9BY3Rpdml0eUluZGljYXRvci9UeXBlcy9CYXNlVHlwZS52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9BY3Rpdml0eUluZGljYXRvci9UeXBlcy9Eb3RzLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL0FjdGl2aXR5SW5kaWNhdG9yL1R5cGVzL1NwaW5uZXIudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvQWN0aXZpdHlJbmRpY2F0b3IvQWN0aXZpdHlJbmRpY2F0b3IudnVlIiwiLi4vc3JjL0hlbHBlcnMvVnVlSW5zdGFsbGVyL1Z1ZUluc3RhbGxlci5qcyIsIi4uL3NyYy9Db21wb25lbnRzL0FjdGl2aXR5SW5kaWNhdG9yL2luZGV4LmpzIiwiLi4vc3JjL0NvbXBvbmVudHMvQWN0aXZpdHlCdXR0b24vQWN0aXZpdHlCdXR0b24udnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvQWN0aXZpdHlCdXR0b24vaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zZXRDYWNoZUFkZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldENhY2hlSGFzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU2V0Q2FjaGUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheVNvbWUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jYWNoZUhhcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2VxdWFsQXJyYXlzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwVG9BcnJheS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldFRvQXJyYXkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19lcXVhbEJ5VGFnLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlQdXNoLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUdldEFsbEtleXMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUZpbHRlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvc3R1YkFycmF5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0U3ltYm9scy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldEFsbEtleXMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19lcXVhbE9iamVjdHMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19EYXRhVmlldy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1Byb21pc2UuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19TZXQuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19XZWFrTWFwLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0VGFnLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzRXF1YWxEZWVwLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzRXF1YWwuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNNYXRjaC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzU3RyaWN0Q29tcGFyYWJsZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldE1hdGNoRGF0YS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZU1hdGNoZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0tleS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvbWVtb2l6ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21lbW9pemVDYXBwZWQuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdHJpbmdUb1BhdGguanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jYXN0UGF0aC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3RvS2V5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUdldC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvZ2V0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUhhc0luLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzUGF0aC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaGFzSW4uanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlTWF0Y2hlc1Byb3BlcnR5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVByb3BlcnR5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVByb3BlcnR5RGVlcC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvcHJvcGVydHkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXRlcmF0ZWUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL21hcEtleXMuanMiLCIuLi9zcmMvSGVscGVycy9QcmVmaXgvUHJlZml4LmpzIiwiLi4vc3JjL01peGlucy9WYXJpYW50L1ZhcmlhbnQuanMiLCIuLi9zcmMvQ29tcG9uZW50cy9CYWRnZS9CYWRnZS52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9CYWRnZS9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNVbmRlZmluZWQuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlUmVkdWNlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9yZWR1Y2UuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlU2V0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVBpY2tCeS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFN5bWJvbHNJbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldEFsbEtleXNJbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvcGlja0J5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc051bGwuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRmlsdGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9maWx0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzU3RyaW5nLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXNjaWlTaXplLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzVW5pY29kZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3VuaWNvZGVTaXplLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RyaW5nU2l6ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvc2l6ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VNYXAuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL21hcC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VTbGljZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nhc3RTbGljZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FzY2lpVG9BcnJheS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3VuaWNvZGVUb0FycmF5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RyaW5nVG9BcnJheS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZUNhc2VGaXJzdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvdXBwZXJGaXJzdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvY2FwaXRhbGl6ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvY2FtZWxDYXNlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWV0YU1hcC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VTZXREYXRhLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlQ3Rvci5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZUJpbmQuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jb21wb3NlQXJncy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvbXBvc2VBcmdzUmlnaHQuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3VudEhvbGRlcnMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlTG9kYXNoLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fTGF6eVdyYXBwZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL25vb3AuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXREYXRhLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fcmVhbE5hbWVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0RnVuY05hbWUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19Mb2Rhc2hXcmFwcGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fd3JhcHBlckNsb25lLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC93cmFwcGVyTG9kYXNoLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNMYXppYWJsZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldERhdGEuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRXcmFwRGV0YWlscy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2luc2VydFdyYXBEZXRhaWxzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUZpbmRJbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc05hTi5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0cmljdEluZGV4T2YuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSW5kZXhPZi5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5SW5jbHVkZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL191cGRhdGVXcmFwRGV0YWlscy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldFdyYXBUb1N0cmluZy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZVJlY3VycnkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRIb2xkZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19yZW9yZGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fcmVwbGFjZUhvbGRlcnMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jcmVhdGVIeWJyaWQuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jcmVhdGVDdXJyeS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZVBhcnRpYWwuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tZXJnZURhdGEuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL3RvTnVtYmVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC90b0Zpbml0ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvdG9JbnRlZ2VyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlV3JhcC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvYmluZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9heGlvcy9kaXN0L2F4aW9zLmpzIiwiLi4vc3JjL0h0dHAvUmVxdWVzdC9SZXF1ZXN0LmpzIiwiLi4vc3JjL0h0dHAvTW9kZWwvTW9kZWwuanMiLCIuLi9zcmMvQ29tcG9uZW50cy9CYXNlRm9ybS9CYXNlRm9ybS52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9CYXNlRm9ybS9pbmRleC5qcyIsIi4uL3NyYy9IZWxwZXJzL1V1aWQvVXVpZC5qcyIsIi4uL3NyYy9NaXhpbnMvUHJveHkvUHJveHkuanMiLCIuLi9zcmMvQ29tcG9uZW50cy9Ecm9wZG93bk1lbnUvRHJvcGRvd25NZW51SXRlbS52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9Ecm9wZG93bk1lbnUvRHJvcGRvd25NZW51SGVhZGVyLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL0Ryb3Bkb3duTWVudS9Ecm9wZG93bk1lbnVEaXZpZGVyLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL0Ryb3Bkb3duTWVudS9Ecm9wZG93bk1lbnUudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvRHJvcGRvd25NZW51L2luZGV4LmpzIiwiLi4vc3JjL0NvbXBvbmVudHMvQnV0dG9uRHJvcGRvd24vQnV0dG9uRHJvcGRvd24udnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvQnV0dG9uRHJvcGRvd24vaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL25lZ2F0ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvb21pdEJ5LmpzIiwiLi4vc3JjL01peGlucy9Db2xvcmFibGUvQ29sb3JhYmxlLmpzIiwiLi4vc3JjL01peGlucy9Gb3JtQ29udHJvbC9Gb3JtQ29udHJvbC5qcyIsIi4uL3NyYy9Db21wb25lbnRzL1JhZGlvRmllbGQvUmFkaW9GaWVsZC52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9DaGVja2JveEZpZWxkL0NoZWNrYm94RmllbGQudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvQ2hlY2tib3hGaWVsZC9pbmRleC5qcyIsIi4uL3NyYy9Db21wb25lbnRzL0NvbnRhaW5lci9Db250YWluZXIudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvQ29udGFpbmVyL2luZGV4LmpzIiwiLi4vc3JjL0NvbXBvbmVudHMvSW5wdXRGaWVsZC9JbnB1dEZpZWxkLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL0ZpbGVGaWVsZC9GaWxlRmllbGQudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvRmlsZUZpZWxkL2luZGV4LmpzIiwiLi4vc3JjL0hlbHBlcnMvUmVhZEZpbGUvUmVhZEZpbGUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzTnVtYmVyLmpzIiwiLi4vc3JjL0NvbXBvbmVudHMvUHJvZ3Jlc3NCYXIvUHJvZ3Jlc3NCYXIudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvRmlsZVByZXZpZXcvRmlsZVByZXZpZXcudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvRmlsZVByZXZpZXcvaW5kZXguanMiLCIuLi9zcmMvQ29tcG9uZW50cy9Gb3JtRmVlZGJhY2svRm9ybUZlZWRiYWNrLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL0Zvcm1GZWVkYmFjay9pbmRleC5qcyIsIi4uL3NyYy9Db21wb25lbnRzL0Zvcm1Hcm91cC9Gb3JtR3JvdXAudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvRm9ybUdyb3VwL2luZGV4LmpzIiwiLi4vc3JjL01peGlucy9TY3JlZW5yZWFkZXJzL1NjcmVlbnJlYWRlcnMuanMiLCIuLi9zcmMvQ29tcG9uZW50cy9Gb3JtTGFiZWwvRm9ybUxhYmVsLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL0Zvcm1MYWJlbC9pbmRleC5qcyIsIi4uL3NyYy9Db21wb25lbnRzL0hlbHBUZXh0L0hlbHBUZXh0LnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL0hlbHBUZXh0L2luZGV4LmpzIiwiLi4vc3JjL0NvbXBvbmVudHMvSW5wdXRGaWVsZC9pbmRleC5qcyIsIi4uL3NyYy9Db21wb25lbnRzL0xpZ2h0U3dpdGNoRmllbGQvTGlnaHRTd2l0Y2hGaWVsZC52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9MaWdodFN3aXRjaEZpZWxkL2luZGV4LmpzIiwiLi4vc3JjL0NvbXBvbmVudHMvTGlzdEdyb3VwL0xpc3RHcm91cEl0ZW0udnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvTGlzdEdyb3VwL0xpc3RHcm91cC52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9MaXN0R3JvdXAvaW5kZXguanMiLCIuLi9zcmMvQ29tcG9uZW50cy9PdmVybGF5L092ZXJsYXkudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvT3ZlcmxheS9pbmRleC5qcyIsIi4uL3NyYy9Db21wb25lbnRzL1BhZ2luYXRpb24vUGFnaW5hdGlvbi52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9QYWdpbmF0aW9uL2luZGV4LmpzIiwiLi4vc3JjL0NvbXBvbmVudHMvUHJvZ3Jlc3NCYXIvaW5kZXguanMiLCIuLi9zcmMvQ29tcG9uZW50cy9SYWRpb0ZpZWxkL2luZGV4LmpzIiwiLi4vc3JjL0NvbXBvbmVudHMvU2VsZWN0RmllbGQvU2VsZWN0RmllbGQudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvU2VsZWN0RmllbGQvaW5kZXguanMiLCIuLi9zcmMvSHR0cC9UcmFuc2Zvcm1lci9UcmFuc2Zvcm1lci5qcyIsIi4uL3NyYy9IdHRwL1RhYmxlVmlld1RyYW5zZm9ybWVyL1RhYmxlVmlld1RyYW5zZm9ybWVyLmpzIiwiLi4vc3JjL0NvbXBvbmVudHMvVGFibGVWaWV3L1RhYmxlVmlldy52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9UYWJsZVZpZXcvaW5kZXguanMiLCIuLi9zcmMvQ29tcG9uZW50cy9UZXh0YXJlYUZpZWxkL1RleHRhcmVhRmllbGQudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvVGV4dGFyZWFGaWVsZC9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvZmluZEluZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9sYXN0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fcGFyZW50LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVVuc2V0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVB1bGxBdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvcmVtb3ZlLmpzIiwiLi4vc3JjL0NvbXBvbmVudHMvVXBsb2FkRmllbGQvVXBsb2FkRmllbGQudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvVXBsb2FkRmllbGQvaW5kZXguanMiLCIuLi9zcmMvSHR0cC9SZXNwb25zZVRyYW5zZm9ybWVyL1Jlc3BvbnNlVHJhbnNmb3JtZXIuanMiLCIuLi9zcmMvTWl4aW5zL1NpemVhYmxlL1NpemVhYmxlLmpzIiwiLi4vc3JjL0hlbHBlcnMvQmxvYi9CbG9iLmpzIiwiLi4vc3JjL21haW4uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3Q7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5O1xuIiwiLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxubW9kdWxlLmV4cG9ydHMgPSBmcmVlR2xvYmFsO1xuIiwidmFyIGZyZWVHbG9iYWwgPSByZXF1aXJlKCcuL19mcmVlR2xvYmFsJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxubW9kdWxlLmV4cG9ydHMgPSByb290O1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bWJvbDtcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFJhd1RhZztcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG9iamVjdFRvU3RyaW5nO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGdldFJhd1RhZyA9IHJlcXVpcmUoJy4vX2dldFJhd1RhZycpLFxuICAgIG9iamVjdFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fb2JqZWN0VG9TdHJpbmcnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldFRhZztcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRnVuY3Rpb247XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb3JlSnNEYXRhO1xuIiwidmFyIGNvcmVKc0RhdGEgPSByZXF1aXJlKCcuL19jb3JlSnNEYXRhJyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xufSgpKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNNYXNrZWQ7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAqL1xuZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9Tb3VyY2U7XG4iLCJ2YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzTWFza2VkID0gcmVxdWlyZSgnLi9faXNNYXNrZWQnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICB0b1NvdXJjZSA9IHJlcXVpcmUoJy4vX3RvU291cmNlJyk7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hdGl2ZWAgd2l0aG91dCBiYWQgc2hpbSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gaXNGdW5jdGlvbih2YWx1ZSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICByZXR1cm4gcGF0dGVybi50ZXN0KHRvU291cmNlKHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzTmF0aXZlO1xuIiwiLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VmFsdWU7XG4iLCJ2YXIgYmFzZUlzTmF0aXZlID0gcmVxdWlyZSgnLi9fYmFzZUlzTmF0aXZlJyksXG4gICAgZ2V0VmFsdWUgPSByZXF1aXJlKCcuL19nZXRWYWx1ZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE5hdGl2ZTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKTtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHZhciBmdW5jID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2RlZmluZVByb3BlcnR5Jyk7XG4gICAgZnVuYyh7fSwgJycsIHt9KTtcbiAgICByZXR1cm4gZnVuYztcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmaW5lUHJvcGVydHk7XG4iLCJ2YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19kZWZpbmVQcm9wZXJ0eScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBhc3NpZ25WYWx1ZWAgYW5kIGBhc3NpZ25NZXJnZVZhbHVlYCB3aXRob3V0XG4gKiB2YWx1ZSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5ID09ICdfX3Byb3RvX18nICYmIGRlZmluZVByb3BlcnR5KSB7XG4gICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcbiAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICAgJ2VudW1lcmFibGUnOiB0cnVlLFxuICAgICAgJ3ZhbHVlJzogdmFsdWUsXG4gICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VBc3NpZ25WYWx1ZTtcbiIsIi8qKlxuICogUGVyZm9ybXMgYVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKCdhJywgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKE5hTiwgTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxO1xuIiwidmFyIGJhc2VBc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25WYWx1ZScpLFxuICAgIGVxID0gcmVxdWlyZSgnLi9lcScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEFzc2lnbnMgYHZhbHVlYCB0byBga2V5YCBvZiBgb2JqZWN0YCBpZiB0aGUgZXhpc3RpbmcgdmFsdWUgaXMgbm90IGVxdWl2YWxlbnRcbiAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldO1xuICBpZiAoIShoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBlcShvYmpWYWx1ZSwgdmFsdWUpKSB8fFxuICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc2lnblZhbHVlO1xuIiwidmFyIGFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYXNzaWduVmFsdWUnKSxcbiAgICBiYXNlQXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19iYXNlQXNzaWduVmFsdWUnKTtcblxuLyoqXG4gKiBDb3BpZXMgcHJvcGVydGllcyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzIHRvIGNvcHkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG8uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb3BpZWQgdmFsdWVzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weU9iamVjdChzb3VyY2UsIHByb3BzLCBvYmplY3QsIGN1c3RvbWl6ZXIpIHtcbiAgdmFyIGlzTmV3ID0gIW9iamVjdDtcbiAgb2JqZWN0IHx8IChvYmplY3QgPSB7fSk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuXG4gICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgPyBjdXN0b21pemVyKG9iamVjdFtrZXldLCBzb3VyY2Vba2V5XSwga2V5LCBvYmplY3QsIHNvdXJjZSlcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG5ld1ZhbHVlID0gc291cmNlW2tleV07XG4gICAgfVxuICAgIGlmIChpc05ldykge1xuICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weU9iamVjdDtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaXQgcmVjZWl2ZXMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKlxuICogY29uc29sZS5sb2coXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaWRlbnRpdHk7XG4iLCIvKipcbiAqIEEgZmFzdGVyIGFsdGVybmF0aXZlIHRvIGBGdW5jdGlvbiNhcHBseWAsIHRoaXMgZnVuY3Rpb24gaW52b2tlcyBgZnVuY2BcbiAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGB0aGlzQXJnYCBhbmQgdGhlIGFyZ3VtZW50cyBvZiBgYXJnc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYGZ1bmNgLlxuICovXG5mdW5jdGlvbiBhcHBseShmdW5jLCB0aGlzQXJnLCBhcmdzKSB7XG4gIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZyk7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0pO1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXBwbHk7XG4iLCJ2YXIgYXBwbHkgPSByZXF1aXJlKCcuL19hcHBseScpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXg7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUmVzdGAgd2hpY2ggdHJhbnNmb3JtcyB0aGUgcmVzdCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgcmVzdCBhcnJheSB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlclJlc3QoZnVuYywgc3RhcnQsIHRyYW5zZm9ybSkge1xuICBzdGFydCA9IG5hdGl2ZU1heChzdGFydCA9PT0gdW5kZWZpbmVkID8gKGZ1bmMubGVuZ3RoIC0gMSkgOiBzdGFydCwgMCk7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3MubGVuZ3RoIC0gc3RhcnQsIDApLFxuICAgICAgICBhcnJheSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgYXJyYXlbaW5kZXhdID0gYXJnc1tzdGFydCArIGluZGV4XTtcbiAgICB9XG4gICAgaW5kZXggPSAtMTtcbiAgICB2YXIgb3RoZXJBcmdzID0gQXJyYXkoc3RhcnQgKyAxKTtcbiAgICB3aGlsZSAoKytpbmRleCA8IHN0YXJ0KSB7XG4gICAgICBvdGhlckFyZ3NbaW5kZXhdID0gYXJnc1tpbmRleF07XG4gICAgfVxuICAgIG90aGVyQXJnc1tzdGFydF0gPSB0cmFuc2Zvcm0oYXJyYXkpO1xuICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzLCBvdGhlckFyZ3MpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG92ZXJSZXN0O1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB2YWx1ZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBmcm9tIHRoZSBuZXcgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb25zdGFudCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBfLnRpbWVzKDIsIF8uY29uc3RhbnQoeyAnYSc6IDEgfSkpO1xuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHMpO1xuICogLy8gPT4gW3sgJ2EnOiAxIH0sIHsgJ2EnOiAxIH1dXG4gKlxuICogY29uc29sZS5sb2cob2JqZWN0c1swXSA9PT0gb2JqZWN0c1sxXSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGNvbnN0YW50KHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29uc3RhbnQ7XG4iLCJ2YXIgY29uc3RhbnQgPSByZXF1aXJlKCcuL2NvbnN0YW50JyksXG4gICAgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19kZWZpbmVQcm9wZXJ0eScpLFxuICAgIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBzZXRUb1N0cmluZ2Agd2l0aG91dCBzdXBwb3J0IGZvciBob3QgbG9vcCBzaG9ydGluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gKi9cbnZhciBiYXNlU2V0VG9TdHJpbmcgPSAhZGVmaW5lUHJvcGVydHkgPyBpZGVudGl0eSA6IGZ1bmN0aW9uKGZ1bmMsIHN0cmluZykge1xuICByZXR1cm4gZGVmaW5lUHJvcGVydHkoZnVuYywgJ3RvU3RyaW5nJywge1xuICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICdlbnVtZXJhYmxlJzogZmFsc2UsXG4gICAgJ3ZhbHVlJzogY29uc3RhbnQoc3RyaW5nKSxcbiAgICAnd3JpdGFibGUnOiB0cnVlXG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlU2V0VG9TdHJpbmc7XG4iLCIvKiogVXNlZCB0byBkZXRlY3QgaG90IGZ1bmN0aW9ucyBieSBudW1iZXIgb2YgY2FsbHMgd2l0aGluIGEgc3BhbiBvZiBtaWxsaXNlY29uZHMuICovXG52YXIgSE9UX0NPVU5UID0gODAwLFxuICAgIEhPVF9TUEFOID0gMTY7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVOb3cgPSBEYXRlLm5vdztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCdsbCBzaG9ydCBvdXQgYW5kIGludm9rZSBgaWRlbnRpdHlgIGluc3RlYWRcbiAqIG9mIGBmdW5jYCB3aGVuIGl0J3MgY2FsbGVkIGBIT1RfQ09VTlRgIG9yIG1vcmUgdGltZXMgaW4gYEhPVF9TUEFOYFxuICogbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNob3J0YWJsZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gc2hvcnRPdXQoZnVuYykge1xuICB2YXIgY291bnQgPSAwLFxuICAgICAgbGFzdENhbGxlZCA9IDA7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGFtcCA9IG5hdGl2ZU5vdygpLFxuICAgICAgICByZW1haW5pbmcgPSBIT1RfU1BBTiAtIChzdGFtcCAtIGxhc3RDYWxsZWQpO1xuXG4gICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgICBpZiAoKytjb3VudCA+PSBIT1RfQ09VTlQpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvcnRPdXQ7XG4iLCJ2YXIgYmFzZVNldFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fYmFzZVNldFRvU3RyaW5nJyksXG4gICAgc2hvcnRPdXQgPSByZXF1aXJlKCcuL19zaG9ydE91dCcpO1xuXG4vKipcbiAqIFNldHMgdGhlIGB0b1N0cmluZ2AgbWV0aG9kIG9mIGBmdW5jYCB0byByZXR1cm4gYHN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovXG52YXIgc2V0VG9TdHJpbmcgPSBzaG9ydE91dChiYXNlU2V0VG9TdHJpbmcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNldFRvU3RyaW5nO1xuIiwidmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpLFxuICAgIG92ZXJSZXN0ID0gcmVxdWlyZSgnLi9fb3ZlclJlc3QnKSxcbiAgICBzZXRUb1N0cmluZyA9IHJlcXVpcmUoJy4vX3NldFRvU3RyaW5nJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVzdGAgd2hpY2ggZG9lc24ndCB2YWxpZGF0ZSBvciBjb2VyY2UgYXJndW1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VSZXN0KGZ1bmMsIHN0YXJ0KSB7XG4gIHJldHVybiBzZXRUb1N0cmluZyhvdmVyUmVzdChmdW5jLCBzdGFydCwgaWRlbnRpdHkpLCBmdW5jICsgJycpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VSZXN0O1xuIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTGVuZ3RoO1xuIiwidmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2lzRnVuY3Rpb24nKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheUxpa2U7XG4iLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcblxuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgKHR5cGUgIT0gJ3N5bWJvbCcgJiYgcmVJc1VpbnQudGVzdCh2YWx1ZSkpKSAmJlxuICAgICAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNJbmRleDtcbiIsInZhciBlcSA9IHJlcXVpcmUoJy4vZXEnKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSB2YWx1ZSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gaW5kZXggVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBpbmRleCBvciBrZXkgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIG9iamVjdCBhcmd1bWVudC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHR5cGUgPSB0eXBlb2YgaW5kZXg7XG4gIGlmICh0eXBlID09ICdudW1iZXInXG4gICAgICAgID8gKGlzQXJyYXlMaWtlKG9iamVjdCkgJiYgaXNJbmRleChpbmRleCwgb2JqZWN0Lmxlbmd0aCkpXG4gICAgICAgIDogKHR5cGUgPT0gJ3N0cmluZycgJiYgaW5kZXggaW4gb2JqZWN0KVxuICAgICAgKSB7XG4gICAgcmV0dXJuIGVxKG9iamVjdFtpbmRleF0sIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNJdGVyYXRlZUNhbGw7XG4iLCJ2YXIgYmFzZVJlc3QgPSByZXF1aXJlKCcuL19iYXNlUmVzdCcpLFxuICAgIGlzSXRlcmF0ZWVDYWxsID0gcmVxdWlyZSgnLi9faXNJdGVyYXRlZUNhbGwnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5hc3NpZ25gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25lciBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFzc2lnbmVyIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVBc3NpZ25lcihhc3NpZ25lcikge1xuICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2VzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoLFxuICAgICAgICBjdXN0b21pemVyID0gbGVuZ3RoID4gMSA/IHNvdXJjZXNbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQsXG4gICAgICAgIGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICBjdXN0b21pemVyID0gKGFzc2lnbmVyLmxlbmd0aCA+IDMgJiYgdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJylcbiAgICAgID8gKGxlbmd0aC0tLCBjdXN0b21pemVyKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc291cmNlc1swXSwgc291cmNlc1sxXSwgZ3VhcmQpKSB7XG4gICAgICBjdXN0b21pemVyID0gbGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IGN1c3RvbWl6ZXI7XG4gICAgICBsZW5ndGggPSAxO1xuICAgIH1cbiAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICBhc3NpZ25lcihvYmplY3QsIHNvdXJjZSwgaW5kZXgsIGN1c3RvbWl6ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVBc3NpZ25lcjtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVRpbWVzO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3RMaWtlO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICovXG5mdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNBcmd1bWVudHM7XG4iLCJ2YXIgYmFzZUlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9fYmFzZUlzQXJndW1lbnRzJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID8gYmFzZUlzQXJndW1lbnRzIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcmd1bWVudHM7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R1YkZhbHNlO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290JyksXG4gICAgc3R1YkZhbHNlID0gcmVxdWlyZSgnLi9zdHViRmFsc2UnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlciA/IEJ1ZmZlci5pc0J1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQnVmZmVyO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xudmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG50eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbnR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbnR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbnR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID1cbnR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID1cbnR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbnR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbnR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbnR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbYmFzZUdldFRhZyh2YWx1ZSldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc1R5cGVkQXJyYXk7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVVuYXJ5O1xuIiwidmFyIGZyZWVHbG9iYWwgPSByZXF1aXJlKCcuL19mcmVlR2xvYmFsJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBwcm9jZXNzYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzICYmIGZyZWVHbG9iYWwucHJvY2VzcztcblxuLyoqIFVzZWQgdG8gYWNjZXNzIGZhc3RlciBOb2RlLmpzIGhlbHBlcnMuICovXG52YXIgbm9kZVV0aWwgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBub2RlVXRpbDtcbiIsInZhciBiYXNlSXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9fYmFzZUlzVHlwZWRBcnJheScpLFxuICAgIGJhc2VVbmFyeSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmFyeScpLFxuICAgIG5vZGVVdGlsID0gcmVxdWlyZSgnLi9fbm9kZVV0aWwnKTtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNUeXBlZEFycmF5O1xuIiwidmFyIGJhc2VUaW1lcyA9IHJlcXVpcmUoJy4vX2Jhc2VUaW1lcycpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJy4vaXNCdWZmZXInKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vaXNUeXBlZEFycmF5Jyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKSxcbiAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzKHZhbHVlKSxcbiAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIodmFsdWUpLFxuICAgICAgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheSh2YWx1ZSksXG4gICAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsXG4gICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoXG4gICAgICAgICAgIC8vIFNhZmFyaSA5IGhhcyBlbnVtZXJhYmxlIGBhcmd1bWVudHMubGVuZ3RoYCBpbiBzdHJpY3QgbW9kZS5cbiAgICAgICAgICAga2V5ID09ICdsZW5ndGgnIHx8XG4gICAgICAgICAgIC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuICAgICAgICAgICAoaXNCdWZmICYmIChrZXkgPT0gJ29mZnNldCcgfHwga2V5ID09ICdwYXJlbnQnKSkgfHxcbiAgICAgICAgICAgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuICAgICAgICAgICAoaXNUeXBlICYmIChrZXkgPT0gJ2J1ZmZlcicgfHwga2V5ID09ICdieXRlTGVuZ3RoJyB8fCBrZXkgPT0gJ2J5dGVPZmZzZXQnKSkgfHxcbiAgICAgICAgICAgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICBpc0luZGV4KGtleSwgbGVuZ3RoKVxuICAgICAgICApKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUxpa2VLZXlzO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUHJvdG90eXBlO1xuIiwiLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2VcbiAqIFtgT2JqZWN0LmtleXNgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGV4Y2VwdCB0aGF0IGl0IGluY2x1ZGVzIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIG5hdGl2ZUtleXNJbihvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAob2JqZWN0ICE9IG51bGwpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlS2V5c0luO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKSxcbiAgICBuYXRpdmVLZXlzSW4gPSByZXF1aXJlKCcuL19uYXRpdmVLZXlzSW4nKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzSW5gIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXNJbihvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXNJbihvYmplY3QpO1xuICB9XG4gIHZhciBpc1Byb3RvID0gaXNQcm90b3R5cGUob2JqZWN0KSxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICBpZiAoIShrZXkgPT0gJ2NvbnN0cnVjdG9yJyAmJiAoaXNQcm90byB8fCAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlS2V5c0luO1xuIiwidmFyIGFycmF5TGlrZUtleXMgPSByZXF1aXJlKCcuL19hcnJheUxpa2VLZXlzJyksXG4gICAgYmFzZUtleXNJbiA9IHJlcXVpcmUoJy4vX2Jhc2VLZXlzSW4nKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5c0luKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InLCAnYyddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKi9cbmZ1bmN0aW9uIGtleXNJbihvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCwgdHJ1ZSkgOiBiYXNlS2V5c0luKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5c0luO1xuIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAgY3JlYXRlQXNzaWduZXIgPSByZXF1aXJlKCcuL19jcmVhdGVBc3NpZ25lcicpLFxuICAgIGtleXNJbiA9IHJlcXVpcmUoJy4va2V5c0luJyk7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25gIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgb3duIGFuZFxuICogaW5oZXJpdGVkIHNvdXJjZSBwcm9wZXJ0aWVzLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBhbGlhcyBleHRlbmRcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqIEBzZWUgXy5hc3NpZ25cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogfVxuICpcbiAqIGZ1bmN0aW9uIEJhcigpIHtcbiAqICAgdGhpcy5jID0gMztcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmIgPSAyO1xuICogQmFyLnByb3RvdHlwZS5kID0gNDtcbiAqXG4gKiBfLmFzc2lnbkluKHsgJ2EnOiAwIH0sIG5ldyBGb28sIG5ldyBCYXIpO1xuICogLy8gPT4geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzLCAnZCc6IDQgfVxuICovXG52YXIgYXNzaWduSW4gPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSkge1xuICBjb3B5T2JqZWN0KHNvdXJjZSwga2V5c0luKHNvdXJjZSksIG9iamVjdCk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBhc3NpZ25JbjtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9hc3NpZ25JbicpO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUNsZWFyO1xuIiwidmFyIGVxID0gcmVxdWlyZSgnLi9lcScpO1xuXG4vKipcbiAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc29jSW5kZXhPZjtcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgZGF0YS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gIH1cbiAgLS10aGlzLnNpemU7XG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZURlbGV0ZTtcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVHZXQ7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUhhcztcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICArK3RoaXMuc2l6ZTtcbiAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZVNldDtcbiIsInZhciBsaXN0Q2FjaGVDbGVhciA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUNsZWFyJyksXG4gICAgbGlzdENhY2hlRGVsZXRlID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlRGVsZXRlJyksXG4gICAgbGlzdENhY2hlR2V0ID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlR2V0JyksXG4gICAgbGlzdENhY2hlSGFzID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlSGFzJyksXG4gICAgbGlzdENhY2hlU2V0ID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5MaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbkxpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG5MaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBMaXN0Q2FjaGU7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqL1xuZnVuY3Rpb24gc3RhY2tDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tDbGVhcjtcbiIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICByZXN1bHQgPSBkYXRhWydkZWxldGUnXShrZXkpO1xuXG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0RlbGV0ZTtcbiIsIi8qKlxuICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0dldDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGEgc3RhY2sgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0hhcyhrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tIYXM7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIE1hcCA9IGdldE5hdGl2ZShyb290LCAnTWFwJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUNyZWF0ZTtcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIEhhc2hcbiAqL1xuZnVuY3Rpb24gaGFzaENsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmF0aXZlQ3JlYXRlID8gbmF0aXZlQ3JlYXRlKG51bGwpIDoge307XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaENsZWFyO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoRGVsZXRlO1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChuYXRpdmVDcmVhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICB9XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaEdldDtcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHJldHVybiBuYXRpdmVDcmVhdGUgPyAoZGF0YVtrZXldICE9PSB1bmRlZmluZWQpIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hIYXM7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqXG4gKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaGFzaCBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgdGhpcy5zaXplICs9IHRoaXMuaGFzKGtleSkgPyAwIDogMTtcbiAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hTZXQ7XG4iLCJ2YXIgaGFzaENsZWFyID0gcmVxdWlyZSgnLi9faGFzaENsZWFyJyksXG4gICAgaGFzaERlbGV0ZSA9IHJlcXVpcmUoJy4vX2hhc2hEZWxldGUnKSxcbiAgICBoYXNoR2V0ID0gcmVxdWlyZSgnLi9faGFzaEdldCcpLFxuICAgIGhhc2hIYXMgPSByZXF1aXJlKCcuL19oYXNoSGFzJyksXG4gICAgaGFzaFNldCA9IHJlcXVpcmUoJy4vX2hhc2hTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIEhhc2goZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG5IYXNoLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcbkhhc2gucHJvdG90eXBlWydkZWxldGUnXSA9IGhhc2hEZWxldGU7XG5IYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuSGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbkhhc2gucHJvdG90eXBlLnNldCA9IGhhc2hTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gSGFzaDtcbiIsInZhciBIYXNoID0gcmVxdWlyZSgnLi9fSGFzaCcpLFxuICAgIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuICB0aGlzLnNpemUgPSAwO1xuICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICdoYXNoJzogbmV3IEhhc2gsXG4gICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSksXG4gICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVDbGVhcjtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0tleWFibGU7XG4iLCJ2YXIgaXNLZXlhYmxlID0gcmVxdWlyZSgnLi9faXNLZXlhYmxlJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJlZmVyZW5jZSBrZXkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWFwIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGdldE1hcERhdGEobWFwLCBrZXkpIHtcbiAgdmFyIGRhdGEgPSBtYXAuX19kYXRhX187XG4gIHJldHVybiBpc0tleWFibGUoa2V5KVxuICAgID8gZGF0YVt0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8gJ3N0cmluZycgOiAnaGFzaCddXG4gICAgOiBkYXRhLm1hcDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRNYXBEYXRhO1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlRGVsZXRlO1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUdldDtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlSGFzO1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IGdldE1hcERhdGEodGhpcywga2V5KSxcbiAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSArPSBkYXRhLnNpemUgPT0gc2l6ZSA/IDAgOiAxO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZVNldDtcbiIsInZhciBtYXBDYWNoZUNsZWFyID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVDbGVhcicpLFxuICAgIG1hcENhY2hlRGVsZXRlID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVEZWxldGUnKSxcbiAgICBtYXBDYWNoZUdldCA9IHJlcXVpcmUoJy4vX21hcENhY2hlR2V0JyksXG4gICAgbWFwQ2FjaGVIYXMgPSByZXF1aXJlKCcuL19tYXBDYWNoZUhhcycpLFxuICAgIG1hcENhY2hlU2V0ID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwQ2FjaGU7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyksXG4gICAgTWFwQ2FjaGUgPSByZXF1aXJlKCcuL19NYXBDYWNoZScpO1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKipcbiAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICB2YXIgcGFpcnMgPSBkYXRhLl9fZGF0YV9fO1xuICAgIGlmICghTWFwIHx8IChwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkpIHtcbiAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIHRoaXMuc2l6ZSA9ICsrZGF0YS5zaXplO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgfVxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja1NldDtcbiIsInZhciBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKSxcbiAgICBzdGFja0NsZWFyID0gcmVxdWlyZSgnLi9fc3RhY2tDbGVhcicpLFxuICAgIHN0YWNrRGVsZXRlID0gcmVxdWlyZSgnLi9fc3RhY2tEZWxldGUnKSxcbiAgICBzdGFja0dldCA9IHJlcXVpcmUoJy4vX3N0YWNrR2V0JyksXG4gICAgc3RhY2tIYXMgPSByZXF1aXJlKCcuL19zdGFja0hhcycpLFxuICAgIHN0YWNrU2V0ID0gcmVxdWlyZSgnLi9fc3RhY2tTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RhY2sgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU3RhY2soZW50cmllcykge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlKGVudHJpZXMpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG5TdGFjay5wcm90b3R5cGUuY2xlYXIgPSBzdGFja0NsZWFyO1xuU3RhY2sucHJvdG90eXBlWydkZWxldGUnXSA9IHN0YWNrRGVsZXRlO1xuU3RhY2sucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0O1xuU3RhY2sucHJvdG90eXBlLmhhcyA9IHN0YWNrSGFzO1xuU3RhY2sucHJvdG90eXBlLnNldCA9IHN0YWNrU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YWNrO1xuIiwidmFyIGJhc2VBc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25WYWx1ZScpLFxuICAgIGVxID0gcmVxdWlyZSgnLi9lcScpO1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYXNzaWduVmFsdWVgIGV4Y2VwdCB0aGF0IGl0IGRvZXNuJ3QgYXNzaWduXG4gKiBgdW5kZWZpbmVkYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgaWYgKCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmICFlcShvYmplY3Rba2V5XSwgdmFsdWUpKSB8fFxuICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc2lnbk1lcmdlVmFsdWU7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSBiYXNlIGZ1bmN0aW9uIGZvciBtZXRob2RzIGxpa2UgYF8uZm9ySW5gIGFuZCBgXy5mb3JPd25gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VGb3IoZnJvbVJpZ2h0KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzRnVuYykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChvYmplY3QpLFxuICAgICAgICBwcm9wcyA9IGtleXNGdW5jKG9iamVjdCksXG4gICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgdmFyIGtleSA9IHByb3BzW2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdO1xuICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVCYXNlRm9yO1xuIiwidmFyIGNyZWF0ZUJhc2VGb3IgPSByZXF1aXJlKCcuL19jcmVhdGVCYXNlRm9yJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGJhc2VGb3JPd25gIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYG9iamVjdGBcbiAqIHByb3BlcnRpZXMgcmV0dXJuZWQgYnkgYGtleXNGdW5jYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LlxuICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG52YXIgYmFzZUZvciA9IGNyZWF0ZUJhc2VGb3IoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRm9yO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgIGFsbG9jVW5zYWZlID0gQnVmZmVyID8gQnVmZmVyLmFsbG9jVW5zYWZlIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiAgYGJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgVGhlIGJ1ZmZlciB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBjbG9uZUJ1ZmZlcihidWZmZXIsIGlzRGVlcCkge1xuICBpZiAoaXNEZWVwKSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5zbGljZSgpO1xuICB9XG4gIHZhciBsZW5ndGggPSBidWZmZXIubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gYWxsb2NVbnNhZmUgPyBhbGxvY1Vuc2FmZShsZW5ndGgpIDogbmV3IGJ1ZmZlci5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gIGJ1ZmZlci5jb3B5KHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVCdWZmZXI7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgVWludDhBcnJheSA9IHJvb3QuVWludDhBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBVaW50OEFycmF5O1xuIiwidmFyIFVpbnQ4QXJyYXkgPSByZXF1aXJlKCcuL19VaW50OEFycmF5Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBhcnJheUJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5QnVmZmVyIFRoZSBhcnJheSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBhcnJheSBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBhcnJheUJ1ZmZlci5jb25zdHJ1Y3RvcihhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgbmV3IFVpbnQ4QXJyYXkocmVzdWx0KS5zZXQobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZUFycmF5QnVmZmVyO1xuIiwidmFyIGNsb25lQXJyYXlCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUFycmF5QnVmZmVyJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGB0eXBlZEFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHR5cGVkQXJyYXkgVGhlIHR5cGVkIGFycmF5IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCB0eXBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2xvbmVUeXBlZEFycmF5KHR5cGVkQXJyYXksIGlzRGVlcCkge1xuICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcih0eXBlZEFycmF5LmJ1ZmZlcikgOiB0eXBlZEFycmF5LmJ1ZmZlcjtcbiAgcmV0dXJuIG5ldyB0eXBlZEFycmF5LmNvbnN0cnVjdG9yKGJ1ZmZlciwgdHlwZWRBcnJheS5ieXRlT2Zmc2V0LCB0eXBlZEFycmF5Lmxlbmd0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVUeXBlZEFycmF5O1xuIiwiLyoqXG4gKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiBgc291cmNlYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG5cbiAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbaW5kZXhdID0gc291cmNlW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weUFycmF5O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNyZWF0ZWAgd2l0aG91dCBzdXBwb3J0IGZvciBhc3NpZ25pbmdcbiAqIHByb3BlcnRpZXMgdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvdG8gVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICovXG52YXIgYmFzZUNyZWF0ZSA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gb2JqZWN0KCkge31cbiAgcmV0dXJuIGZ1bmN0aW9uKHByb3RvKSB7XG4gICAgaWYgKCFpc09iamVjdChwcm90bykpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgaWYgKG9iamVjdENyZWF0ZSkge1xuICAgICAgcmV0dXJuIG9iamVjdENyZWF0ZShwcm90byk7XG4gICAgfVxuICAgIG9iamVjdC5wcm90b3R5cGUgPSBwcm90bztcbiAgICB2YXIgcmVzdWx0ID0gbmV3IG9iamVjdDtcbiAgICBvYmplY3QucHJvdG90eXBlID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VDcmVhdGU7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvdmVyQXJnO1xuIiwidmFyIG92ZXJBcmcgPSByZXF1aXJlKCcuL19vdmVyQXJnJyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIGdldFByb3RvdHlwZSA9IG92ZXJBcmcoT2JqZWN0LmdldFByb3RvdHlwZU9mLCBPYmplY3QpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFByb3RvdHlwZTtcbiIsInZhciBiYXNlQ3JlYXRlID0gcmVxdWlyZSgnLi9fYmFzZUNyZWF0ZScpLFxuICAgIGdldFByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2dldFByb3RvdHlwZScpLFxuICAgIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVPYmplY3Qob2JqZWN0KSB7XG4gIHJldHVybiAodHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmICFpc1Byb3RvdHlwZShvYmplY3QpKVxuICAgID8gYmFzZUNyZWF0ZShnZXRQcm90b3R5cGUob2JqZWN0KSlcbiAgICA6IHt9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRDbG9uZU9iamVjdDtcbiIsInZhciBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNBcnJheUxpa2VgIGV4Y2VwdCB0aGF0IGl0IGFsc28gY2hlY2tzIGlmIGB2YWx1ZWBcbiAqIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheS1saWtlIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0FycmF5TGlrZSh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheUxpa2VPYmplY3Q7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBnZXRQcm90b3R5cGUgPSByZXF1aXJlKCcuL19nZXRQcm90b3R5cGUnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBpbmZlciB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IuICovXG52YXIgb2JqZWN0Q3RvclN0cmluZyA9IGZ1bmNUb1N0cmluZy5jYWxsKE9iamVjdCk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIHRoYXQgaXMsIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZVxuICogYE9iamVjdGAgY29uc3RydWN0b3Igb3Igb25lIHdpdGggYSBgW1tQcm90b3R5cGVdXWAgb2YgYG51bGxgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC44LjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqIH1cbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QobmV3IEZvbyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoeyAneCc6IDAsICd5JzogMCB9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpIHx8IGJhc2VHZXRUYWcodmFsdWUpICE9IG9iamVjdFRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGUodmFsdWUpO1xuICBpZiAocHJvdG8gPT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgQ3RvciA9IGhhc093blByb3BlcnR5LmNhbGwocHJvdG8sICdjb25zdHJ1Y3RvcicpICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuICByZXR1cm4gdHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yIGluc3RhbmNlb2YgQ3RvciAmJlxuICAgIGZ1bmNUb1N0cmluZy5jYWxsKEN0b3IpID09IG9iamVjdEN0b3JTdHJpbmc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNQbGFpbk9iamVjdDtcbiIsIi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAsIHVubGVzcyBga2V5YCBpcyBcIl9fcHJvdG9fX1wiLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gc2FmZUdldChvYmplY3QsIGtleSkge1xuICByZXR1cm4ga2V5ID09ICdfX3Byb3RvX18nXG4gICAgPyB1bmRlZmluZWRcbiAgICA6IG9iamVjdFtrZXldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNhZmVHZXQ7XG4iLCJ2YXIgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBrZXlzSW4gPSByZXF1aXJlKCcuL2tleXNJbicpO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBwbGFpbiBvYmplY3QgZmxhdHRlbmluZyBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmdcbiAqIGtleWVkIHByb3BlcnRpZXMgb2YgYHZhbHVlYCB0byBvd24gcHJvcGVydGllcyBvZiB0aGUgcGxhaW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29udmVydGVkIHBsYWluIG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgbmV3IEZvbyk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAqXG4gKiBfLmFzc2lnbih7ICdhJzogMSB9LCBfLnRvUGxhaW5PYmplY3QobmV3IEZvbykpO1xuICogLy8gPT4geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH1cbiAqL1xuZnVuY3Rpb24gdG9QbGFpbk9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gY29weU9iamVjdCh2YWx1ZSwga2V5c0luKHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9QbGFpbk9iamVjdDtcbiIsInZhciBhc3NpZ25NZXJnZVZhbHVlID0gcmVxdWlyZSgnLi9fYXNzaWduTWVyZ2VWYWx1ZScpLFxuICAgIGNsb25lQnVmZmVyID0gcmVxdWlyZSgnLi9fY2xvbmVCdWZmZXInKSxcbiAgICBjbG9uZVR5cGVkQXJyYXkgPSByZXF1aXJlKCcuL19jbG9uZVR5cGVkQXJyYXknKSxcbiAgICBjb3B5QXJyYXkgPSByZXF1aXJlKCcuL19jb3B5QXJyYXknKSxcbiAgICBpbml0Q2xvbmVPYmplY3QgPSByZXF1aXJlKCcuL19pbml0Q2xvbmVPYmplY3QnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNBcnJheUxpa2VPYmplY3QgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlT2JqZWN0JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGlzUGxhaW5PYmplY3QgPSByZXF1aXJlKCcuL2lzUGxhaW5PYmplY3QnKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzVHlwZWRBcnJheScpLFxuICAgIHNhZmVHZXQgPSByZXF1aXJlKCcuL19zYWZlR2V0JyksXG4gICAgdG9QbGFpbk9iamVjdCA9IHJlcXVpcmUoJy4vdG9QbGFpbk9iamVjdCcpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZU1lcmdlYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gKiBkZWVwIG1lcmdlcyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICogcmVmZXJlbmNlcyB0byBiZSBtZXJnZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIG1lcmdlLlxuICogQHBhcmFtIHtudW1iZXJ9IHNyY0luZGV4IFRoZSBpbmRleCBvZiBgc291cmNlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IG1lcmdlRnVuYyBUaGUgZnVuY3Rpb24gdG8gbWVyZ2UgdmFsdWVzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAqICBjb3VudGVycGFydHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIG1lcmdlRnVuYywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgdmFyIG9ialZhbHVlID0gc2FmZUdldChvYmplY3QsIGtleSksXG4gICAgICBzcmNWYWx1ZSA9IHNhZmVHZXQoc291cmNlLCBrZXkpLFxuICAgICAgc3RhY2tlZCA9IHN0YWNrLmdldChzcmNWYWx1ZSk7XG5cbiAgaWYgKHN0YWNrZWQpIHtcbiAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBzdGFja2VkKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgID8gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIChrZXkgKyAnJyksIG9iamVjdCwgc291cmNlLCBzdGFjaylcbiAgICA6IHVuZGVmaW5lZDtcblxuICB2YXIgaXNDb21tb24gPSBuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkO1xuXG4gIGlmIChpc0NvbW1vbikge1xuICAgIHZhciBpc0FyciA9IGlzQXJyYXkoc3JjVmFsdWUpLFxuICAgICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgaXNCdWZmZXIoc3JjVmFsdWUpLFxuICAgICAgICBpc1R5cGVkID0gIWlzQXJyICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHNyY1ZhbHVlKTtcblxuICAgIG5ld1ZhbHVlID0gc3JjVmFsdWU7XG4gICAgaWYgKGlzQXJyIHx8IGlzQnVmZiB8fCBpc1R5cGVkKSB7XG4gICAgICBpZiAoaXNBcnJheShvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KG9ialZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IGNvcHlBcnJheShvYmpWYWx1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc0J1ZmYpIHtcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgbmV3VmFsdWUgPSBjbG9uZUJ1ZmZlcihzcmNWYWx1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc1R5cGVkKSB7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIG5ld1ZhbHVlID0gY2xvbmVUeXBlZEFycmF5KHNyY1ZhbHVlLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBuZXdWYWx1ZSA9IFtdO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHNyY1ZhbHVlKSB8fCBpc0FyZ3VtZW50cyhzcmNWYWx1ZSkpIHtcbiAgICAgIG5ld1ZhbHVlID0gb2JqVmFsdWU7XG4gICAgICBpZiAoaXNBcmd1bWVudHMob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gdG9QbGFpbk9iamVjdChvYmpWYWx1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICghaXNPYmplY3Qob2JqVmFsdWUpIHx8IChzcmNJbmRleCAmJiBpc0Z1bmN0aW9uKG9ialZhbHVlKSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBpbml0Q2xvbmVPYmplY3Qoc3JjVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmIChpc0NvbW1vbikge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IG1lcmdlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIHN0YWNrLnNldChzcmNWYWx1ZSwgbmV3VmFsdWUpO1xuICAgIG1lcmdlRnVuYyhuZXdWYWx1ZSwgc3JjVmFsdWUsIHNyY0luZGV4LCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgc3RhY2tbJ2RlbGV0ZSddKHNyY1ZhbHVlKTtcbiAgfVxuICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1lcmdlRGVlcDtcbiIsInZhciBTdGFjayA9IHJlcXVpcmUoJy4vX1N0YWNrJyksXG4gICAgYXNzaWduTWVyZ2VWYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnbk1lcmdlVmFsdWUnKSxcbiAgICBiYXNlRm9yID0gcmVxdWlyZSgnLi9fYmFzZUZvcicpLFxuICAgIGJhc2VNZXJnZURlZXAgPSByZXF1aXJlKCcuL19iYXNlTWVyZ2VEZWVwJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAga2V5c0luID0gcmVxdWlyZSgnLi9rZXlzSW4nKSxcbiAgICBzYWZlR2V0ID0gcmVxdWlyZSgnLi9fc2FmZUdldCcpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1lcmdlYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge251bWJlcn0gc3JjSW5kZXggVGhlIGluZGV4IG9mIGBzb3VyY2VgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgbWVyZ2VkIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkXG4gKiAgY291bnRlcnBhcnRzLlxuICovXG5mdW5jdGlvbiBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyLCBzdGFjaykge1xuICBpZiAob2JqZWN0ID09PSBzb3VyY2UpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYmFzZUZvcihzb3VyY2UsIGZ1bmN0aW9uKHNyY1ZhbHVlLCBrZXkpIHtcbiAgICBpZiAoaXNPYmplY3Qoc3JjVmFsdWUpKSB7XG4gICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgYmFzZU1lcmdlRGVlcChvYmplY3QsIHNvdXJjZSwga2V5LCBzcmNJbmRleCwgYmFzZU1lcmdlLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgICA/IGN1c3RvbWl6ZXIoc2FmZUdldChvYmplY3QsIGtleSksIHNyY1ZhbHVlLCAoa2V5ICsgJycpLCBvYmplY3QsIHNvdXJjZSwgc3RhY2spXG4gICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuZXdWYWx1ZSA9IHNyY1ZhbHVlO1xuICAgICAgfVxuICAgICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH1cbiAgfSwga2V5c0luKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlTWVyZ2U7XG4iLCJ2YXIgYmFzZU1lcmdlID0gcmVxdWlyZSgnLi9fYmFzZU1lcmdlJyksXG4gICAgY3JlYXRlQXNzaWduZXIgPSByZXF1aXJlKCcuL19jcmVhdGVBc3NpZ25lcicpO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYXNzaWduYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBtZXJnZXMgb3duIGFuZFxuICogaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdHMgaW50byB0aGVcbiAqIGRlc3RpbmF0aW9uIG9iamVjdC4gU291cmNlIHByb3BlcnRpZXMgdGhhdCByZXNvbHZlIHRvIGB1bmRlZmluZWRgIGFyZVxuICogc2tpcHBlZCBpZiBhIGRlc3RpbmF0aW9uIHZhbHVlIGV4aXN0cy4gQXJyYXkgYW5kIHBsYWluIG9iamVjdCBwcm9wZXJ0aWVzXG4gKiBhcmUgbWVyZ2VkIHJlY3Vyc2l2ZWx5LiBPdGhlciBvYmplY3RzIGFuZCB2YWx1ZSB0eXBlcyBhcmUgb3ZlcnJpZGRlbiBieVxuICogYXNzaWdubWVudC4gU291cmNlIG9iamVjdHMgYXJlIGFwcGxpZWQgZnJvbSBsZWZ0IHRvIHJpZ2h0LiBTdWJzZXF1ZW50XG4gKiBzb3VyY2VzIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyBzb3VyY2VzLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC41LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHtcbiAqICAgJ2EnOiBbeyAnYic6IDIgfSwgeyAnZCc6IDQgfV1cbiAqIH07XG4gKlxuICogdmFyIG90aGVyID0ge1xuICogICAnYSc6IFt7ICdjJzogMyB9LCB7ICdlJzogNSB9XVxuICogfTtcbiAqXG4gKiBfLm1lcmdlKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4geyAnYSc6IFt7ICdiJzogMiwgJ2MnOiAzIH0sIHsgJ2QnOiA0LCAnZSc6IDUgfV0gfVxuICovXG52YXIgbWVyZ2UgPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgpIHtcbiAgYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBtZXJnZTtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZvckVhY2hgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheUVhY2goYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpID09PSBmYWxzZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUVhY2g7XG4iLCJ2YXIgb3ZlckFyZyA9IHJlcXVpcmUoJy4vX292ZXJBcmcnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUtleXMgPSBvdmVyQXJnKE9iamVjdC5rZXlzLCBPYmplY3QpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUtleXM7XG4iLCJ2YXIgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpLFxuICAgIG5hdGl2ZUtleXMgPSByZXF1aXJlKCcuL19uYXRpdmVLZXlzJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlS2V5cztcbiIsInZhciBhcnJheUxpa2VLZXlzID0gcmVxdWlyZSgnLi9fYXJyYXlMaWtlS2V5cycpLFxuICAgIGJhc2VLZXlzID0gcmVxdWlyZSgnLi9fYmFzZUtleXMnKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy5rZXlzKCdoaScpO1xuICogLy8gPT4gWycwJywgJzEnXVxuICovXG5mdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5cztcbiIsInZhciBiYXNlRm9yID0gcmVxdWlyZSgnLi9fYmFzZUZvcicpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JPd25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlRm9yT3duKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yKG9iamVjdCwgaXRlcmF0ZWUsIGtleXMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGb3JPd247XG4iLCJ2YXIgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBiYXNlRWFjaGAgb3IgYGJhc2VFYWNoUmlnaHRgIGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGEgY29sbGVjdGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUVhY2goZWFjaEZ1bmMsIGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9XG4gICAgaWYgKCFpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKTtcbiAgICB9XG4gICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxuICAgICAgICBpbmRleCA9IGZyb21SaWdodCA/IGxlbmd0aCA6IC0xLFxuICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChjb2xsZWN0aW9uKTtcblxuICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVbaW5kZXhdLCBpbmRleCwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQmFzZUVhY2g7XG4iLCJ2YXIgYmFzZUZvck93biA9IHJlcXVpcmUoJy4vX2Jhc2VGb3JPd24nKSxcbiAgICBjcmVhdGVCYXNlRWFjaCA9IHJlcXVpcmUoJy4vX2NyZWF0ZUJhc2VFYWNoJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yRWFjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gKi9cbnZhciBiYXNlRWFjaCA9IGNyZWF0ZUJhc2VFYWNoKGJhc2VGb3JPd24pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VFYWNoO1xuIiwidmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpO1xuXG4vKipcbiAqIENhc3RzIGB2YWx1ZWAgdG8gYGlkZW50aXR5YCBpZiBpdCdzIG5vdCBhIGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGNhc3QgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNhc3RGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicgPyB2YWx1ZSA6IGlkZW50aXR5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhc3RGdW5jdGlvbjtcbiIsInZhciBhcnJheUVhY2ggPSByZXF1aXJlKCcuL19hcnJheUVhY2gnKSxcbiAgICBiYXNlRWFjaCA9IHJlcXVpcmUoJy4vX2Jhc2VFYWNoJyksXG4gICAgY2FzdEZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fY2FzdEZ1bmN0aW9uJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xuXG4vKipcbiAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggZWxlbWVudC5cbiAqIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gKlxuICogKipOb3RlOioqIEFzIHdpdGggb3RoZXIgXCJDb2xsZWN0aW9uc1wiIG1ldGhvZHMsIG9iamVjdHMgd2l0aCBhIFwibGVuZ3RoXCJcbiAqIHByb3BlcnR5IGFyZSBpdGVyYXRlZCBsaWtlIGFycmF5cy4gVG8gYXZvaWQgdGhpcyBiZWhhdmlvciB1c2UgYF8uZm9ySW5gXG4gKiBvciBgXy5mb3JPd25gIGZvciBvYmplY3QgaXRlcmF0aW9uLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBhbGlhcyBlYWNoXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAqIEBzZWUgXy5mb3JFYWNoUmlnaHRcbiAqIEBleGFtcGxlXG4gKlxuICogXy5mb3JFYWNoKFsxLCAyXSwgZnVuY3Rpb24odmFsdWUpIHtcbiAqICAgY29uc29sZS5sb2codmFsdWUpO1xuICogfSk7XG4gKiAvLyA9PiBMb2dzIGAxYCB0aGVuIGAyYC5cbiAqXG4gKiBfLmZvckVhY2goeyAnYSc6IDEsICdiJzogMiB9LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gKiB9KTtcbiAqIC8vID0+IExvZ3MgJ2EnIHRoZW4gJ2InIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpLlxuICovXG5mdW5jdGlvbiBmb3JFYWNoKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RWFjaCA6IGJhc2VFYWNoO1xuICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBjYXN0RnVuY3Rpb24oaXRlcmF0ZWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmb3JFYWNoO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZvckVhY2gnKTtcbiIsImltcG9ydCB7IGVhY2ggfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgc2l6ZSB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBtZXJnZSB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBleHRlbmQgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgaXNBcnJheSB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBpc09iamVjdCB9IGZyb20gJ2xvZGFzaCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKFZ1ZSwgb3B0aW9ucykge1xuXG4gICAgVnVlLnByb3RvdHlwZS5tZXJnZUNsYXNzZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgY2xhc3NlcyA9IHt9O1xuXG4gICAgICAgIGVhY2goW10uc2xpY2UuY2FsbChhcmd1bWVudHMpLCBhcmcgPT4ge1xuICAgICAgICAgICAgaWYoaXNPYmplY3QoYXJnKSkge1xuICAgICAgICAgICAgICAgIGV4dGVuZChjbGFzc2VzLCBhcmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZihpc0FycmF5KGFyZykpIHtcbiAgICAgICAgICAgICAgICBtZXJnZShjbGFzc2VzLCBhcmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZihhcmcpIHtcbiAgICAgICAgICAgICAgICBjbGFzc2VzW2FyZ10gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gY2xhc3NlcztcbiAgICB9O1xuXG59XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5yZWR1Y2VgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luaXRBY2N1bV0gU3BlY2lmeSB1c2luZyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgIGFzXG4gKiAgdGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGFycmF5UmVkdWNlKGFycmF5LCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIGlmIChpbml0QWNjdW0gJiYgbGVuZ3RoKSB7XG4gICAgYWNjdW11bGF0b3IgPSBhcnJheVsrK2luZGV4XTtcbiAgfVxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFjY3VtdWxhdG9yID0gaXRlcmF0ZWUoYWNjdW11bGF0b3IsIGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gYWNjdW11bGF0b3I7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlSZWR1Y2U7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5T2ZgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eU9mKG9iamVjdCkge1xuICByZXR1cm4gZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVByb3BlcnR5T2Y7XG4iLCJ2YXIgYmFzZVByb3BlcnR5T2YgPSByZXF1aXJlKCcuL19iYXNlUHJvcGVydHlPZicpO1xuXG4vKiogVXNlZCB0byBtYXAgTGF0aW4gVW5pY29kZSBsZXR0ZXJzIHRvIGJhc2ljIExhdGluIGxldHRlcnMuICovXG52YXIgZGVidXJyZWRMZXR0ZXJzID0ge1xuICAvLyBMYXRpbi0xIFN1cHBsZW1lbnQgYmxvY2suXG4gICdcXHhjMCc6ICdBJywgICdcXHhjMSc6ICdBJywgJ1xceGMyJzogJ0EnLCAnXFx4YzMnOiAnQScsICdcXHhjNCc6ICdBJywgJ1xceGM1JzogJ0EnLFxuICAnXFx4ZTAnOiAnYScsICAnXFx4ZTEnOiAnYScsICdcXHhlMic6ICdhJywgJ1xceGUzJzogJ2EnLCAnXFx4ZTQnOiAnYScsICdcXHhlNSc6ICdhJyxcbiAgJ1xceGM3JzogJ0MnLCAgJ1xceGU3JzogJ2MnLFxuICAnXFx4ZDAnOiAnRCcsICAnXFx4ZjAnOiAnZCcsXG4gICdcXHhjOCc6ICdFJywgICdcXHhjOSc6ICdFJywgJ1xceGNhJzogJ0UnLCAnXFx4Y2InOiAnRScsXG4gICdcXHhlOCc6ICdlJywgICdcXHhlOSc6ICdlJywgJ1xceGVhJzogJ2UnLCAnXFx4ZWInOiAnZScsXG4gICdcXHhjYyc6ICdJJywgICdcXHhjZCc6ICdJJywgJ1xceGNlJzogJ0knLCAnXFx4Y2YnOiAnSScsXG4gICdcXHhlYyc6ICdpJywgICdcXHhlZCc6ICdpJywgJ1xceGVlJzogJ2knLCAnXFx4ZWYnOiAnaScsXG4gICdcXHhkMSc6ICdOJywgICdcXHhmMSc6ICduJyxcbiAgJ1xceGQyJzogJ08nLCAgJ1xceGQzJzogJ08nLCAnXFx4ZDQnOiAnTycsICdcXHhkNSc6ICdPJywgJ1xceGQ2JzogJ08nLCAnXFx4ZDgnOiAnTycsXG4gICdcXHhmMic6ICdvJywgICdcXHhmMyc6ICdvJywgJ1xceGY0JzogJ28nLCAnXFx4ZjUnOiAnbycsICdcXHhmNic6ICdvJywgJ1xceGY4JzogJ28nLFxuICAnXFx4ZDknOiAnVScsICAnXFx4ZGEnOiAnVScsICdcXHhkYic6ICdVJywgJ1xceGRjJzogJ1UnLFxuICAnXFx4ZjknOiAndScsICAnXFx4ZmEnOiAndScsICdcXHhmYic6ICd1JywgJ1xceGZjJzogJ3UnLFxuICAnXFx4ZGQnOiAnWScsICAnXFx4ZmQnOiAneScsICdcXHhmZic6ICd5JyxcbiAgJ1xceGM2JzogJ0FlJywgJ1xceGU2JzogJ2FlJyxcbiAgJ1xceGRlJzogJ1RoJywgJ1xceGZlJzogJ3RoJyxcbiAgJ1xceGRmJzogJ3NzJyxcbiAgLy8gTGF0aW4gRXh0ZW5kZWQtQSBibG9jay5cbiAgJ1xcdTAxMDAnOiAnQScsICAnXFx1MDEwMic6ICdBJywgJ1xcdTAxMDQnOiAnQScsXG4gICdcXHUwMTAxJzogJ2EnLCAgJ1xcdTAxMDMnOiAnYScsICdcXHUwMTA1JzogJ2EnLFxuICAnXFx1MDEwNic6ICdDJywgICdcXHUwMTA4JzogJ0MnLCAnXFx1MDEwYSc6ICdDJywgJ1xcdTAxMGMnOiAnQycsXG4gICdcXHUwMTA3JzogJ2MnLCAgJ1xcdTAxMDknOiAnYycsICdcXHUwMTBiJzogJ2MnLCAnXFx1MDEwZCc6ICdjJyxcbiAgJ1xcdTAxMGUnOiAnRCcsICAnXFx1MDExMCc6ICdEJywgJ1xcdTAxMGYnOiAnZCcsICdcXHUwMTExJzogJ2QnLFxuICAnXFx1MDExMic6ICdFJywgICdcXHUwMTE0JzogJ0UnLCAnXFx1MDExNic6ICdFJywgJ1xcdTAxMTgnOiAnRScsICdcXHUwMTFhJzogJ0UnLFxuICAnXFx1MDExMyc6ICdlJywgICdcXHUwMTE1JzogJ2UnLCAnXFx1MDExNyc6ICdlJywgJ1xcdTAxMTknOiAnZScsICdcXHUwMTFiJzogJ2UnLFxuICAnXFx1MDExYyc6ICdHJywgICdcXHUwMTFlJzogJ0cnLCAnXFx1MDEyMCc6ICdHJywgJ1xcdTAxMjInOiAnRycsXG4gICdcXHUwMTFkJzogJ2cnLCAgJ1xcdTAxMWYnOiAnZycsICdcXHUwMTIxJzogJ2cnLCAnXFx1MDEyMyc6ICdnJyxcbiAgJ1xcdTAxMjQnOiAnSCcsICAnXFx1MDEyNic6ICdIJywgJ1xcdTAxMjUnOiAnaCcsICdcXHUwMTI3JzogJ2gnLFxuICAnXFx1MDEyOCc6ICdJJywgICdcXHUwMTJhJzogJ0knLCAnXFx1MDEyYyc6ICdJJywgJ1xcdTAxMmUnOiAnSScsICdcXHUwMTMwJzogJ0knLFxuICAnXFx1MDEyOSc6ICdpJywgICdcXHUwMTJiJzogJ2knLCAnXFx1MDEyZCc6ICdpJywgJ1xcdTAxMmYnOiAnaScsICdcXHUwMTMxJzogJ2knLFxuICAnXFx1MDEzNCc6ICdKJywgICdcXHUwMTM1JzogJ2onLFxuICAnXFx1MDEzNic6ICdLJywgICdcXHUwMTM3JzogJ2snLCAnXFx1MDEzOCc6ICdrJyxcbiAgJ1xcdTAxMzknOiAnTCcsICAnXFx1MDEzYic6ICdMJywgJ1xcdTAxM2QnOiAnTCcsICdcXHUwMTNmJzogJ0wnLCAnXFx1MDE0MSc6ICdMJyxcbiAgJ1xcdTAxM2EnOiAnbCcsICAnXFx1MDEzYyc6ICdsJywgJ1xcdTAxM2UnOiAnbCcsICdcXHUwMTQwJzogJ2wnLCAnXFx1MDE0Mic6ICdsJyxcbiAgJ1xcdTAxNDMnOiAnTicsICAnXFx1MDE0NSc6ICdOJywgJ1xcdTAxNDcnOiAnTicsICdcXHUwMTRhJzogJ04nLFxuICAnXFx1MDE0NCc6ICduJywgICdcXHUwMTQ2JzogJ24nLCAnXFx1MDE0OCc6ICduJywgJ1xcdTAxNGInOiAnbicsXG4gICdcXHUwMTRjJzogJ08nLCAgJ1xcdTAxNGUnOiAnTycsICdcXHUwMTUwJzogJ08nLFxuICAnXFx1MDE0ZCc6ICdvJywgICdcXHUwMTRmJzogJ28nLCAnXFx1MDE1MSc6ICdvJyxcbiAgJ1xcdTAxNTQnOiAnUicsICAnXFx1MDE1Nic6ICdSJywgJ1xcdTAxNTgnOiAnUicsXG4gICdcXHUwMTU1JzogJ3InLCAgJ1xcdTAxNTcnOiAncicsICdcXHUwMTU5JzogJ3InLFxuICAnXFx1MDE1YSc6ICdTJywgICdcXHUwMTVjJzogJ1MnLCAnXFx1MDE1ZSc6ICdTJywgJ1xcdTAxNjAnOiAnUycsXG4gICdcXHUwMTViJzogJ3MnLCAgJ1xcdTAxNWQnOiAncycsICdcXHUwMTVmJzogJ3MnLCAnXFx1MDE2MSc6ICdzJyxcbiAgJ1xcdTAxNjInOiAnVCcsICAnXFx1MDE2NCc6ICdUJywgJ1xcdTAxNjYnOiAnVCcsXG4gICdcXHUwMTYzJzogJ3QnLCAgJ1xcdTAxNjUnOiAndCcsICdcXHUwMTY3JzogJ3QnLFxuICAnXFx1MDE2OCc6ICdVJywgICdcXHUwMTZhJzogJ1UnLCAnXFx1MDE2Yyc6ICdVJywgJ1xcdTAxNmUnOiAnVScsICdcXHUwMTcwJzogJ1UnLCAnXFx1MDE3Mic6ICdVJyxcbiAgJ1xcdTAxNjknOiAndScsICAnXFx1MDE2Yic6ICd1JywgJ1xcdTAxNmQnOiAndScsICdcXHUwMTZmJzogJ3UnLCAnXFx1MDE3MSc6ICd1JywgJ1xcdTAxNzMnOiAndScsXG4gICdcXHUwMTc0JzogJ1cnLCAgJ1xcdTAxNzUnOiAndycsXG4gICdcXHUwMTc2JzogJ1knLCAgJ1xcdTAxNzcnOiAneScsICdcXHUwMTc4JzogJ1knLFxuICAnXFx1MDE3OSc6ICdaJywgICdcXHUwMTdiJzogJ1onLCAnXFx1MDE3ZCc6ICdaJyxcbiAgJ1xcdTAxN2EnOiAneicsICAnXFx1MDE3Yyc6ICd6JywgJ1xcdTAxN2UnOiAneicsXG4gICdcXHUwMTMyJzogJ0lKJywgJ1xcdTAxMzMnOiAnaWonLFxuICAnXFx1MDE1Mic6ICdPZScsICdcXHUwMTUzJzogJ29lJyxcbiAgJ1xcdTAxNDknOiBcIiduXCIsICdcXHUwMTdmJzogJ3MnXG59O1xuXG4vKipcbiAqIFVzZWQgYnkgYF8uZGVidXJyYCB0byBjb252ZXJ0IExhdGluLTEgU3VwcGxlbWVudCBhbmQgTGF0aW4gRXh0ZW5kZWQtQVxuICogbGV0dGVycyB0byBiYXNpYyBMYXRpbiBsZXR0ZXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gbGV0dGVyIFRoZSBtYXRjaGVkIGxldHRlciB0byBkZWJ1cnIuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBkZWJ1cnJlZCBsZXR0ZXIuXG4gKi9cbnZhciBkZWJ1cnJMZXR0ZXIgPSBiYXNlUHJvcGVydHlPZihkZWJ1cnJlZExldHRlcnMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlYnVyckxldHRlcjtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlNYXA7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTeW1ib2w7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgYXJyYXlNYXAgPSByZXF1aXJlKCcuL19hcnJheU1hcCcpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFRvU3RyaW5nID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by50b1N0cmluZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1N0cmluZ2Agd2hpY2ggZG9lc24ndCBjb252ZXJ0IG51bGxpc2hcbiAqIHZhbHVlcyB0byBlbXB0eSBzdHJpbmdzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBiYXNlVG9TdHJpbmcodmFsdWUpIHtcbiAgLy8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAvLyBSZWN1cnNpdmVseSBjb252ZXJ0IHZhbHVlcyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIHJldHVybiBhcnJheU1hcCh2YWx1ZSwgYmFzZVRvU3RyaW5nKSArICcnO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3ltYm9sVG9TdHJpbmcgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVG9TdHJpbmc7XG4iLCJ2YXIgYmFzZVRvU3RyaW5nID0gcmVxdWlyZSgnLi9fYmFzZVRvU3RyaW5nJyk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAqIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b1N0cmluZyhudWxsKTtcbiAqIC8vID0+ICcnXG4gKlxuICogXy50b1N0cmluZygtMCk7XG4gKiAvLyA9PiAnLTAnXG4gKlxuICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICogLy8gPT4gJzEsMiwzJ1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1N0cmluZztcbiIsInZhciBkZWJ1cnJMZXR0ZXIgPSByZXF1aXJlKCcuL19kZWJ1cnJMZXR0ZXInKSxcbiAgICB0b1N0cmluZyA9IHJlcXVpcmUoJy4vdG9TdHJpbmcnKTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggTGF0aW4gVW5pY29kZSBsZXR0ZXJzIChleGNsdWRpbmcgbWF0aGVtYXRpY2FsIG9wZXJhdG9ycykuICovXG52YXIgcmVMYXRpbiA9IC9bXFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxceGZmXFx1MDEwMC1cXHUwMTdmXS9nO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2hhcmFjdGVyIGNsYXNzZXMuICovXG52YXIgcnNDb21ib01hcmtzUmFuZ2UgPSAnXFxcXHUwMzAwLVxcXFx1MDM2ZicsXG4gICAgcmVDb21ib0hhbGZNYXJrc1JhbmdlID0gJ1xcXFx1ZmUyMC1cXFxcdWZlMmYnLFxuICAgIHJzQ29tYm9TeW1ib2xzUmFuZ2UgPSAnXFxcXHUyMGQwLVxcXFx1MjBmZicsXG4gICAgcnNDb21ib1JhbmdlID0gcnNDb21ib01hcmtzUmFuZ2UgKyByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgKyByc0NvbWJvU3ltYm9sc1JhbmdlO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2FwdHVyZSBncm91cHMuICovXG52YXIgcnNDb21ibyA9ICdbJyArIHJzQ29tYm9SYW5nZSArICddJztcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3NdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrcykgYW5kXG4gKiBbY29tYmluaW5nIGRpYWNyaXRpY2FsIG1hcmtzIGZvciBzeW1ib2xzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3NfZm9yX1N5bWJvbHMpLlxuICovXG52YXIgcmVDb21ib01hcmsgPSBSZWdFeHAocnNDb21ibywgJ2cnKTtcblxuLyoqXG4gKiBEZWJ1cnJzIGBzdHJpbmdgIGJ5IGNvbnZlcnRpbmdcbiAqIFtMYXRpbi0xIFN1cHBsZW1lbnRdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xhdGluLTFfU3VwcGxlbWVudF8oVW5pY29kZV9ibG9jaykjQ2hhcmFjdGVyX3RhYmxlKVxuICogYW5kIFtMYXRpbiBFeHRlbmRlZC1BXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MYXRpbl9FeHRlbmRlZC1BKVxuICogbGV0dGVycyB0byBiYXNpYyBMYXRpbiBsZXR0ZXJzIGFuZCByZW1vdmluZ1xuICogW2NvbWJpbmluZyBkaWFjcml0aWNhbCBtYXJrc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBkZWJ1cnIuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBkZWJ1cnJlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZGVidXJyKCdkw6lqw6AgdnUnKTtcbiAqIC8vID0+ICdkZWphIHZ1J1xuICovXG5mdW5jdGlvbiBkZWJ1cnIoc3RyaW5nKSB7XG4gIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gIHJldHVybiBzdHJpbmcgJiYgc3RyaW5nLnJlcGxhY2UocmVMYXRpbiwgZGVidXJyTGV0dGVyKS5yZXBsYWNlKHJlQ29tYm9NYXJrLCAnJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGVidXJyO1xuIiwiLyoqIFVzZWQgdG8gbWF0Y2ggd29yZHMgY29tcG9zZWQgb2YgYWxwaGFudW1lcmljIGNoYXJhY3RlcnMuICovXG52YXIgcmVBc2NpaVdvcmQgPSAvW15cXHgwMC1cXHgyZlxceDNhLVxceDQwXFx4NWItXFx4NjBcXHg3Yi1cXHg3Zl0rL2c7XG5cbi8qKlxuICogU3BsaXRzIGFuIEFTQ0lJIGBzdHJpbmdgIGludG8gYW4gYXJyYXkgb2YgaXRzIHdvcmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB3b3JkcyBvZiBgc3RyaW5nYC5cbiAqL1xuZnVuY3Rpb24gYXNjaWlXb3JkcyhzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5tYXRjaChyZUFzY2lpV29yZCkgfHwgW107XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNjaWlXb3JkcztcbiIsIi8qKiBVc2VkIHRvIGRldGVjdCBzdHJpbmdzIHRoYXQgbmVlZCBhIG1vcmUgcm9idXN0IHJlZ2V4cCB0byBtYXRjaCB3b3Jkcy4gKi9cbnZhciByZUhhc1VuaWNvZGVXb3JkID0gL1thLXpdW0EtWl18W0EtWl17Mix9W2Etel18WzAtOV1bYS16QS1aXXxbYS16QS1aXVswLTldfFteYS16QS1aMC05IF0vO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgc3RyaW5nYCBjb250YWlucyBhIHdvcmQgY29tcG9zZWQgb2YgVW5pY29kZSBzeW1ib2xzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhIHdvcmQgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzVW5pY29kZVdvcmQoc3RyaW5nKSB7XG4gIHJldHVybiByZUhhc1VuaWNvZGVXb3JkLnRlc3Qoc3RyaW5nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNVbmljb2RlV29yZDtcbiIsIi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjaGFyYWN0ZXIgY2xhc3Nlcy4gKi9cbnZhciByc0FzdHJhbFJhbmdlID0gJ1xcXFx1ZDgwMC1cXFxcdWRmZmYnLFxuICAgIHJzQ29tYm9NYXJrc1JhbmdlID0gJ1xcXFx1MDMwMC1cXFxcdTAzNmYnLFxuICAgIHJlQ29tYm9IYWxmTWFya3NSYW5nZSA9ICdcXFxcdWZlMjAtXFxcXHVmZTJmJyxcbiAgICByc0NvbWJvU3ltYm9sc1JhbmdlID0gJ1xcXFx1MjBkMC1cXFxcdTIwZmYnLFxuICAgIHJzQ29tYm9SYW5nZSA9IHJzQ29tYm9NYXJrc1JhbmdlICsgcmVDb21ib0hhbGZNYXJrc1JhbmdlICsgcnNDb21ib1N5bWJvbHNSYW5nZSxcbiAgICByc0RpbmdiYXRSYW5nZSA9ICdcXFxcdTI3MDAtXFxcXHUyN2JmJyxcbiAgICByc0xvd2VyUmFuZ2UgPSAnYS16XFxcXHhkZi1cXFxceGY2XFxcXHhmOC1cXFxceGZmJyxcbiAgICByc01hdGhPcFJhbmdlID0gJ1xcXFx4YWNcXFxceGIxXFxcXHhkN1xcXFx4ZjcnLFxuICAgIHJzTm9uQ2hhclJhbmdlID0gJ1xcXFx4MDAtXFxcXHgyZlxcXFx4M2EtXFxcXHg0MFxcXFx4NWItXFxcXHg2MFxcXFx4N2ItXFxcXHhiZicsXG4gICAgcnNQdW5jdHVhdGlvblJhbmdlID0gJ1xcXFx1MjAwMC1cXFxcdTIwNmYnLFxuICAgIHJzU3BhY2VSYW5nZSA9ICcgXFxcXHRcXFxceDBiXFxcXGZcXFxceGEwXFxcXHVmZWZmXFxcXG5cXFxcclxcXFx1MjAyOFxcXFx1MjAyOVxcXFx1MTY4MFxcXFx1MTgwZVxcXFx1MjAwMFxcXFx1MjAwMVxcXFx1MjAwMlxcXFx1MjAwM1xcXFx1MjAwNFxcXFx1MjAwNVxcXFx1MjAwNlxcXFx1MjAwN1xcXFx1MjAwOFxcXFx1MjAwOVxcXFx1MjAwYVxcXFx1MjAyZlxcXFx1MjA1ZlxcXFx1MzAwMCcsXG4gICAgcnNVcHBlclJhbmdlID0gJ0EtWlxcXFx4YzAtXFxcXHhkNlxcXFx4ZDgtXFxcXHhkZScsXG4gICAgcnNWYXJSYW5nZSA9ICdcXFxcdWZlMGVcXFxcdWZlMGYnLFxuICAgIHJzQnJlYWtSYW5nZSA9IHJzTWF0aE9wUmFuZ2UgKyByc05vbkNoYXJSYW5nZSArIHJzUHVuY3R1YXRpb25SYW5nZSArIHJzU3BhY2VSYW5nZTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNhcHR1cmUgZ3JvdXBzLiAqL1xudmFyIHJzQXBvcyA9IFwiWydcXHUyMDE5XVwiLFxuICAgIHJzQnJlYWsgPSAnWycgKyByc0JyZWFrUmFuZ2UgKyAnXScsXG4gICAgcnNDb21ibyA9ICdbJyArIHJzQ29tYm9SYW5nZSArICddJyxcbiAgICByc0RpZ2l0cyA9ICdcXFxcZCsnLFxuICAgIHJzRGluZ2JhdCA9ICdbJyArIHJzRGluZ2JhdFJhbmdlICsgJ10nLFxuICAgIHJzTG93ZXIgPSAnWycgKyByc0xvd2VyUmFuZ2UgKyAnXScsXG4gICAgcnNNaXNjID0gJ1teJyArIHJzQXN0cmFsUmFuZ2UgKyByc0JyZWFrUmFuZ2UgKyByc0RpZ2l0cyArIHJzRGluZ2JhdFJhbmdlICsgcnNMb3dlclJhbmdlICsgcnNVcHBlclJhbmdlICsgJ10nLFxuICAgIHJzRml0eiA9ICdcXFxcdWQ4M2NbXFxcXHVkZmZiLVxcXFx1ZGZmZl0nLFxuICAgIHJzTW9kaWZpZXIgPSAnKD86JyArIHJzQ29tYm8gKyAnfCcgKyByc0ZpdHogKyAnKScsXG4gICAgcnNOb25Bc3RyYWwgPSAnW14nICsgcnNBc3RyYWxSYW5nZSArICddJyxcbiAgICByc1JlZ2lvbmFsID0gJyg/OlxcXFx1ZDgzY1tcXFxcdWRkZTYtXFxcXHVkZGZmXSl7Mn0nLFxuICAgIHJzU3VyclBhaXIgPSAnW1xcXFx1ZDgwMC1cXFxcdWRiZmZdW1xcXFx1ZGMwMC1cXFxcdWRmZmZdJyxcbiAgICByc1VwcGVyID0gJ1snICsgcnNVcHBlclJhbmdlICsgJ10nLFxuICAgIHJzWldKID0gJ1xcXFx1MjAwZCc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSByZWdleGVzLiAqL1xudmFyIHJzTWlzY0xvd2VyID0gJyg/OicgKyByc0xvd2VyICsgJ3wnICsgcnNNaXNjICsgJyknLFxuICAgIHJzTWlzY1VwcGVyID0gJyg/OicgKyByc1VwcGVyICsgJ3wnICsgcnNNaXNjICsgJyknLFxuICAgIHJzT3B0Q29udHJMb3dlciA9ICcoPzonICsgcnNBcG9zICsgJyg/OmR8bGx8bXxyZXxzfHR8dmUpKT8nLFxuICAgIHJzT3B0Q29udHJVcHBlciA9ICcoPzonICsgcnNBcG9zICsgJyg/OkR8TEx8TXxSRXxTfFR8VkUpKT8nLFxuICAgIHJlT3B0TW9kID0gcnNNb2RpZmllciArICc/JyxcbiAgICByc09wdFZhciA9ICdbJyArIHJzVmFyUmFuZ2UgKyAnXT8nLFxuICAgIHJzT3B0Sm9pbiA9ICcoPzonICsgcnNaV0ogKyAnKD86JyArIFtyc05vbkFzdHJhbCwgcnNSZWdpb25hbCwgcnNTdXJyUGFpcl0uam9pbignfCcpICsgJyknICsgcnNPcHRWYXIgKyByZU9wdE1vZCArICcpKicsXG4gICAgcnNPcmRMb3dlciA9ICdcXFxcZCooPzoxc3R8Mm5kfDNyZHwoPyFbMTIzXSlcXFxcZHRoKSg/PVxcXFxifFtBLVpfXSknLFxuICAgIHJzT3JkVXBwZXIgPSAnXFxcXGQqKD86MVNUfDJORHwzUkR8KD8hWzEyM10pXFxcXGRUSCkoPz1cXFxcYnxbYS16X10pJyxcbiAgICByc1NlcSA9IHJzT3B0VmFyICsgcmVPcHRNb2QgKyByc09wdEpvaW4sXG4gICAgcnNFbW9qaSA9ICcoPzonICsgW3JzRGluZ2JhdCwgcnNSZWdpb25hbCwgcnNTdXJyUGFpcl0uam9pbignfCcpICsgJyknICsgcnNTZXE7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGNvbXBsZXggb3IgY29tcG91bmQgd29yZHMuICovXG52YXIgcmVVbmljb2RlV29yZCA9IFJlZ0V4cChbXG4gIHJzVXBwZXIgKyAnPycgKyByc0xvd2VyICsgJysnICsgcnNPcHRDb250ckxvd2VyICsgJyg/PScgKyBbcnNCcmVhaywgcnNVcHBlciwgJyQnXS5qb2luKCd8JykgKyAnKScsXG4gIHJzTWlzY1VwcGVyICsgJysnICsgcnNPcHRDb250clVwcGVyICsgJyg/PScgKyBbcnNCcmVhaywgcnNVcHBlciArIHJzTWlzY0xvd2VyLCAnJCddLmpvaW4oJ3wnKSArICcpJyxcbiAgcnNVcHBlciArICc/JyArIHJzTWlzY0xvd2VyICsgJysnICsgcnNPcHRDb250ckxvd2VyLFxuICByc1VwcGVyICsgJysnICsgcnNPcHRDb250clVwcGVyLFxuICByc09yZFVwcGVyLFxuICByc09yZExvd2VyLFxuICByc0RpZ2l0cyxcbiAgcnNFbW9qaVxuXS5qb2luKCd8JyksICdnJyk7XG5cbi8qKlxuICogU3BsaXRzIGEgVW5pY29kZSBgc3RyaW5nYCBpbnRvIGFuIGFycmF5IG9mIGl0cyB3b3Jkcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgd29yZHMgb2YgYHN0cmluZ2AuXG4gKi9cbmZ1bmN0aW9uIHVuaWNvZGVXb3JkcyhzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5tYXRjaChyZVVuaWNvZGVXb3JkKSB8fCBbXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB1bmljb2RlV29yZHM7XG4iLCJ2YXIgYXNjaWlXb3JkcyA9IHJlcXVpcmUoJy4vX2FzY2lpV29yZHMnKSxcbiAgICBoYXNVbmljb2RlV29yZCA9IHJlcXVpcmUoJy4vX2hhc1VuaWNvZGVXb3JkJyksXG4gICAgdG9TdHJpbmcgPSByZXF1aXJlKCcuL3RvU3RyaW5nJyksXG4gICAgdW5pY29kZVdvcmRzID0gcmVxdWlyZSgnLi9fdW5pY29kZVdvcmRzJyk7XG5cbi8qKlxuICogU3BsaXRzIGBzdHJpbmdgIGludG8gYW4gYXJyYXkgb2YgaXRzIHdvcmRzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge1JlZ0V4cHxzdHJpbmd9IFtwYXR0ZXJuXSBUaGUgcGF0dGVybiB0byBtYXRjaCB3b3Jkcy5cbiAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdvcmRzIG9mIGBzdHJpbmdgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLndvcmRzKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycpO1xuICogLy8gPT4gWydmcmVkJywgJ2Jhcm5leScsICdwZWJibGVzJ11cbiAqXG4gKiBfLndvcmRzKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycsIC9bXiwgXSsvZyk7XG4gKiAvLyA9PiBbJ2ZyZWQnLCAnYmFybmV5JywgJyYnLCAncGViYmxlcyddXG4gKi9cbmZ1bmN0aW9uIHdvcmRzKHN0cmluZywgcGF0dGVybiwgZ3VhcmQpIHtcbiAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgcGF0dGVybiA9IGd1YXJkID8gdW5kZWZpbmVkIDogcGF0dGVybjtcblxuICBpZiAocGF0dGVybiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGhhc1VuaWNvZGVXb3JkKHN0cmluZykgPyB1bmljb2RlV29yZHMoc3RyaW5nKSA6IGFzY2lpV29yZHMoc3RyaW5nKTtcbiAgfVxuICByZXR1cm4gc3RyaW5nLm1hdGNoKHBhdHRlcm4pIHx8IFtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdvcmRzO1xuIiwidmFyIGFycmF5UmVkdWNlID0gcmVxdWlyZSgnLi9fYXJyYXlSZWR1Y2UnKSxcbiAgICBkZWJ1cnIgPSByZXF1aXJlKCcuL2RlYnVycicpLFxuICAgIHdvcmRzID0gcmVxdWlyZSgnLi93b3JkcycpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2FwdHVyZSBncm91cHMuICovXG52YXIgcnNBcG9zID0gXCJbJ1xcdTIwMTldXCI7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGFwb3N0cm9waGVzLiAqL1xudmFyIHJlQXBvcyA9IFJlZ0V4cChyc0Fwb3MsICdnJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uY2FtZWxDYXNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGNvbWJpbmUgZWFjaCB3b3JkLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29tcG91bmRlciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ29tcG91bmRlcihjYWxsYmFjaykge1xuICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgcmV0dXJuIGFycmF5UmVkdWNlKHdvcmRzKGRlYnVycihzdHJpbmcpLnJlcGxhY2UocmVBcG9zLCAnJykpLCBjYWxsYmFjaywgJycpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUNvbXBvdW5kZXI7XG4iLCJ2YXIgY3JlYXRlQ29tcG91bmRlciA9IHJlcXVpcmUoJy4vX2NyZWF0ZUNvbXBvdW5kZXInKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgc3RyaW5nYCB0b1xuICogW2tlYmFiIGNhc2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xldHRlcl9jYXNlI1NwZWNpYWxfY2FzZV9zdHlsZXMpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBrZWJhYiBjYXNlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8ua2ViYWJDYXNlKCdGb28gQmFyJyk7XG4gKiAvLyA9PiAnZm9vLWJhcidcbiAqXG4gKiBfLmtlYmFiQ2FzZSgnZm9vQmFyJyk7XG4gKiAvLyA9PiAnZm9vLWJhcidcbiAqXG4gKiBfLmtlYmFiQ2FzZSgnX19GT09fQkFSX18nKTtcbiAqIC8vID0+ICdmb28tYmFyJ1xuICovXG52YXIga2ViYWJDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyAnLScgOiAnJykgKyB3b3JkLnRvTG93ZXJDYXNlKCk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBrZWJhYkNhc2U7XG4iLCI8dGVtcGxhdGU+XG4gICAgPGRpdiBjbGFzcz1cImFjdGl2aXR5LWluZGljYXRvclwiIDpjbGFzcz1cImNsYXNzZXNcIj5cbiAgICAgICAgPGRpdiB2LWZvcj1cImkgaW4gbm9kZXNcIj48L2Rpdj5cbiAgICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBwcm9wczoge1xuICAgICAgICBub2Rlczoge1xuICAgICAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICAgICAgZGVmYXVsdDogM1xuICAgICAgICB9LFxuICAgICAgICBzaXplOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAnJ1xuICAgICAgICB9LFxuICAgICAgICBwcmVmaXg6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdhY3Rpdml0eS1pbmRpY2F0b3ItJ1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIGNsYXNzZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY29uc3QgY2xhc3NlcyA9IHt9O1xuXG4gICAgICAgICAgICBjbGFzc2VzW3RoaXMuJG9wdGlvbnMubmFtZV0gPSAhIXRoaXMuJG9wdGlvbnMubmFtZTtcbiAgICAgICAgICAgIGNsYXNzZXNbdGhpcy5wcmVmaXggKyB0aGlzLnNpemUucmVwbGFjZSh0aGlzLnByZWZpeCwgJycpXSA9ICEhdGhpcy5zaXplO1xuXG4gICAgICAgICAgICByZXR1cm4gY2xhc3NlcztcbiAgICAgICAgfVxuICAgIH1cblxufVxuPC9zY3JpcHQ+XG4iLCI8c2NyaXB0PlxuaW1wb3J0IEJhc2VUeXBlIGZyb20gJy4vQmFzZVR5cGUnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAnYWN0aXZpdHktaW5kaWNhdG9yLWRvdHMnLFxuXG4gICAgZXh0ZW5kczogQmFzZVR5cGVcbn1cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cInNjc3NcIj5cbkBpbXBvcnQgJy4vbm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC9zY3NzL2Jvb3RzdHJhcC5zY3NzJztcblxuJGFjdGl2aXR5LWluZGljYXRvci1kb3Qtc2l6ZTogLjZyZW07XG5cbi5hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyB7XG5cbiAgICAmID4gZGl2IHtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogMTAwJTtcbiAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkZ3JheS05MDA7XG4gICAgICAgIHdpZHRoOiAkYWN0aXZpdHktaW5kaWNhdG9yLWRvdC1zaXplO1xuICAgICAgICBoZWlnaHQ6ICRhY3Rpdml0eS1pbmRpY2F0b3ItZG90LXNpemU7XG4gICAgICAgIGFuaW1hdGlvbjogYWN0aXZpdHktaW5kaWNhdG9yLWRvdHMgMS40cyBpbmZpbml0ZSBlYXNlLWluLW91dCBib3RoO1xuICAgIH1cblxuICAgICYgPiBkaXY6bm90KDpsYXN0LWNoaWxkKSB7XG4gICAgICAgIG1hcmdpbi1yaWdodDogJGFjdGl2aXR5LWluZGljYXRvci1kb3Qtc2l6ZSAqIC4zMztcbiAgICB9XG5cbiAgICAmLmFjdGl2aXR5LWluZGljYXRvci14cyA+IGRpdiB7XG4gICAgICAgIHdpZHRoOiAkYWN0aXZpdHktaW5kaWNhdG9yLWRvdC1zaXplICogLjU7XG4gICAgICAgIGhlaWdodDogJGFjdGl2aXR5LWluZGljYXRvci1kb3Qtc2l6ZSAqIC41O1xuICAgIH1cblxuICAgICYuYWN0aXZpdHktaW5kaWNhdG9yLXNtID4gZGl2IHtcbiAgICAgICAgd2lkdGg6ICRhY3Rpdml0eS1pbmRpY2F0b3ItZG90LXNpemUgKiAuNzU7XG4gICAgICAgIGhlaWdodDogJGFjdGl2aXR5LWluZGljYXRvci1kb3Qtc2l6ZSAqIC43NTtcbiAgICB9XG5cbiAgICAmLmFjdGl2aXR5LWluZGljYXRvci1tZCA+IGRpdiB7XG4gICAgICAgIHdpZHRoOiAkYWN0aXZpdHktaW5kaWNhdG9yLWRvdC1zaXplICogMTtcbiAgICAgICAgaGVpZ2h0OiAkYWN0aXZpdHktaW5kaWNhdG9yLWRvdC1zaXplICogMTtcbiAgICB9XG5cbiAgICAmLmFjdGl2aXR5LWluZGljYXRvci1sZyA+IGRpdiB7XG4gICAgICAgIHdpZHRoOiAkYWN0aXZpdHktaW5kaWNhdG9yLWRvdC1zaXplICogMS41O1xuICAgICAgICBoZWlnaHQ6ICRhY3Rpdml0eS1pbmRpY2F0b3ItZG90LXNpemUgKiAxLjU7XG4gICAgfVxuXG4gICAgJi5hY3Rpdml0eS1pbmRpY2F0b3IteGwgPiBkaXYge1xuICAgICAgICB3aWR0aDogJGFjdGl2aXR5LWluZGljYXRvci1kb3Qtc2l6ZSAqIDI7XG4gICAgICAgIGhlaWdodDogJGFjdGl2aXR5LWluZGljYXRvci1kb3Qtc2l6ZSAqIDI7XG4gICAgfVxuXG4gICAgQGZvciAkaSBmcm9tIDAgdGhyb3VnaCAxMiB7XG4gICAgICAgICYgPiBkaXY6bnRoLWNoaWxkKCN7JGkgKyAxfSkge1xuICAgICAgICAgICAgYW5pbWF0aW9uLWRlbGF5OiAkaSAqIC4xNnM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBAa2V5ZnJhbWVzIGFjdGl2aXR5LWluZGljYXRvci1kb3RzIHtcbiAgICAgICAgMCUsIDgwJSwgMTAwJSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDApO1xuICAgICAgICB9IDQwJSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDEuMCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi5idG4tYWN0aXZpdHktaW5kaWNhdG9yLWRvdHMge1xuICAgICY6bm90KC5idG4td2FybmluZykgLmFjdGl2aXR5LWluZGljYXRvci1kb3RzID4gZGl2IHtcbiAgICAgICAgYmFja2dyb3VuZDogd2hpdGU7XG4gICAgfVxufVxuXG48L3N0eWxlPlxuIiwiPHNjcmlwdD5cbmltcG9ydCBCYXNlVHlwZSBmcm9tICcuL0Jhc2VUeXBlJztcbmltcG9ydCB7IGV4dGVuZCB9IGZyb20gJ2xvZGFzaCc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdhY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lcicsXG5cbiAgICBleHRlbmRzOiBCYXNlVHlwZSxcblxuICAgIHByb3BzOiBleHRlbmQoe30sIEJhc2VUeXBlLnByb3BzLCB7XG4gICAgICAgIG5vZGVzOiB7XG4gICAgICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgICAgICBkZWZhdWx0OiAxMlxuICAgICAgICB9XG4gICAgfSlcbn1cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cInNjc3NcIj5cbkBpbXBvcnQgJy4vbm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC9zY3NzL2Jvb3RzdHJhcC5zY3NzJztcblxuJGFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyLXNpemU6ICRmb250LXNpemUtYmFzZSAqIDIuMjU7XG4kYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXItd2lkdGg6IDEwJTtcbiRhY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lci1oZWlnaHQ6IDMwJTtcbiRhY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lci1kZWxheTogMXM7XG5cbkBtaXhpbiBzcGlubmVyLXJvdGF0ZS1zZWxlY3RvcnMoJHN0YXJ0OjEsICRlbmQ6MTYsICRkZWxheToxLjJzKSB7XG4gICAgQGZvciAkaSBmcm9tICRzdGFydCB0aHJvdWdoICRlbmQge1xuICAgICAgICAmID4gZGl2OmZpcnN0LWNoaWxkOm50aC1sYXN0LWNoaWxkKCN7JGl9KSxcbiAgICAgICAgJiA+IGRpdjpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCgjeyRpfSkgfiBkaXYge1xuICAgICAgICAgICAgQGluY2x1ZGUgc3Bpbm5lci1yb3RhdGUtdHJhbnNmb3JtKCRpLCAkZGVsYXkpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5AbWl4aW4gc3Bpbm5lci1yb3RhdGUtdHJhbnNmb3JtKCR0b3RhbCwgJGRlbGF5OjEuMnMpIHtcbiAgICBAZm9yICRpIGZyb20gMSB0aHJvdWdoICR0b3RhbCB7XG4gICAgICAgICY6bnRoLWNoaWxkKCN7JGl9KSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgjezM2MCAvICR0b3RhbCAqICRpfWRlZyk7XG5cbiAgICAgICAgICAgICY6YmVmb3JlIHtcbiAgICAgICAgICAgICAgICBhbmltYXRpb24tZGVsYXk6IC0jeyRkZWxheSAtICgkZGVsYXkgLyAkdG90YWwgKiAoJGkgLSAxKSl9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG4uYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIge1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICB3aWR0aDogJGFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyLXNpemU7XG4gICAgaGVpZ2h0OiAkYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXItc2l6ZTtcblxuICAgICYgPiBkaXYgIHtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICBsZWZ0OiAwO1xuICAgICAgICB0b3A6IDA7XG5cbiAgICAgICAgJjpiZWZvcmUge1xuICAgICAgICAgICAgY29udGVudDogJyc7XG4gICAgICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgICAgIG1hcmdpbjogMCBhdXRvO1xuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogJGdyYXktOTAwO1xuICAgICAgICAgICAgd2lkdGg6ICRhY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lci13aWR0aDtcbiAgICAgICAgICAgIGhlaWdodDogJGFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyLWhlaWdodDtcbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDVweDtcbiAgICAgICAgICAgIGFuaW1hdGlvbjogYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIgJGFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyLWRlbGF5IGluZmluaXRlIGVhc2UtaW4tb3V0IGJvdGg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAmLmFjdGl2aXR5LWluZGljYXRvci14cyB7XG4gICAgICAgIHdpZHRoOiAkYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXItc2l6ZSAqIC41O1xuICAgICAgICBoZWlnaHQ6ICRhY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lci1zaXplICogLjU7XG4gICAgfVxuICAgICYuYWN0aXZpdHktaW5kaWNhdG9yLXNtIHtcbiAgICAgICAgd2lkdGg6ICRhY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lci1zaXplICogLjc1O1xuICAgICAgICBoZWlnaHQ6ICRhY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lci1zaXplICogLjc1O1xuICAgIH1cbiAgICAmLmFjdGl2aXR5LWluZGljYXRvci1tZCB7XG4gICAgICAgIHdpZHRoOiAkYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXItc2l6ZSAqIDE7XG4gICAgICAgIGhlaWdodDogJGFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyLXNpemUgKiAxO1xuICAgIH1cbiAgICAmLmFjdGl2aXR5LWluZGljYXRvci1sZyB7XG4gICAgICAgIHdpZHRoOiAkYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXItc2l6ZSAqIDEuNTtcbiAgICAgICAgaGVpZ2h0OiAkYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXItc2l6ZSAqIDEuNTtcbiAgICB9XG4gICAgJi5hY3Rpdml0eS1pbmRpY2F0b3IteGwge1xuICAgICAgICB3aWR0aDogJGFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyLXNpemUgKiAyO1xuICAgICAgICBoZWlnaHQ6ICRhY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lci1zaXplICogMjtcbiAgICB9XG5cbiAgICBAaW5jbHVkZSBzcGlubmVyLXJvdGF0ZS1zZWxlY3RvcnMoMSwgMTIsICRhY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lci1kZWxheSk7XG5cbiAgICBAa2V5ZnJhbWVzIGFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyIHtcbiAgICAgICAgMCUsIDM5JSwgMTAwJSB7IG9wYWNpdHk6IDA7IH1cbiAgICAgICAgNDAlIHsgb3BhY2l0eTogMTsgfVxuICAgIH1cbn1cblxuLmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lciB7XG4gICAgJjpub3QoLmJ0bi13YXJuaW5nKSAuYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIgPiBkaXY6YmVmb3JlIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XG4gICAgfVxufVxuXG48L3N0eWxlPlxuIiwiPHRlbXBsYXRlPlxuICAgIDxkaXYgdi1pZj1cImNlbnRlclwiIGNsYXNzPVwiY2VudGVyLXdyYXBwZXJcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImNlbnRlci1jb250ZW50XCI+XG4gICAgICAgICAgICA8Y29tcG9uZW50IDppcz1cImNvbXBvbmVudFwiIDpzaXplPVwic2l6ZVwiIDpwcmVmaXg9XCJwcmVmaXhcIj48L2NvbXBvbmVudD5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICAgPGNvbXBvbmVudCB2LWVsc2UgOmlzPVwiY29tcG9uZW50XCIgOnNpemU9XCJzaXplXCIgIDpwcmVmaXg9XCJwcmVmaXhcIj48L2NvbXBvbmVudD5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgeyBleHRlbmQgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsga2ViYWJDYXNlIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBCYXNlVHlwZSBmcm9tICcuL1R5cGVzL0Jhc2VUeXBlJztcbmltcG9ydCBBY3Rpdml0eUluZGljYXRvckRvdHMgZnJvbSAnLi9UeXBlcy9Eb3RzJztcbmltcG9ydCBBY3Rpdml0eUluZGljYXRvclNwaW5uZXIgZnJvbSAnLi9UeXBlcy9TcGlubmVyJztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ2FjdGl2aXR5LWluZGljYXRvcicsXG5cbiAgICBleHRlbmRzOiBCYXNlVHlwZSxcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgY2VudGVyOiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgICAgfSxcblxuICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAnZG90cydcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgICAgQWN0aXZpdHlJbmRpY2F0b3JEb3RzLFxuICAgICAgICBBY3Rpdml0eUluZGljYXRvclNwaW5uZXJcbiAgICB9LFxuXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgY29tcG9uZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBrZWJhYkNhc2UodGhpcy5wcmVmaXggKyB0aGlzLnR5cGUucmVwbGFjZSh0aGlzLnByZWZpeCwgJycpKTtcbiAgICAgICAgfVxuICAgIH1cblxufVxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwic2Nzc1wiPlxuQGltcG9ydCAnLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwL3Njc3MvYm9vdHN0cmFwLnNjc3MnO1xuXG4vLyBBY3Rpdml0eUluZGljYXRvcnMgTWl4aW5zXG5cbkBtaXhpbiBzcGlubmVyLWNvbG9yKCRjb2xvcikge1xuXG59XG5cbkBrZXlmcmFtZXMgYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIge1xuICAgIDAlLCAzOSUsIDEwMCUgeyBvcGFjaXR5OiAwOyB9XG4gICAgNDAlIHsgb3BhY2l0eTogMTsgfVxufVxuXG4vLyBDb250ZW50IFBvc2l0aW9uaW5nIEhlbHBlcnNcbi5jZW50ZXItd3JhcHBlciB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHRvcDogMDtcbiAgICBsZWZ0OiAwO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogMTAwJTtcbn1cbi5jZW50ZXItY29udGVudCB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHRvcDogNTAlO1xuICAgIGxlZnQ6IDUwJTtcbiAgICBtYXJnaW4tcmlnaHQ6IC01MCU7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwgLTUwJSlcbn1cblxuPC9zdHlsZT5cbiIsImltcG9ydCB7IGVhY2ggfSBmcm9tICdsb2Rhc2gnO1xuXG5jb25zdCBWdWVJbnN0YWxsZXIgPSB7XG4gICAgdXNlLFxuICAgIHBsdWdpbixcbiAgICBwbHVnaW5zLFxuICAgIGNvbXBvbmVudCxcbiAgICBjb21wb25lbnRzLFxuICAgIGRpcmVjdGl2ZSxcbiAgICBkaXJlY3RpdmVzLFxuICAgICRwbHVnaW5zOiB7fSxcbiAgICAkZGlyZWN0aXZlczoge30sXG4gICAgJGNvbXBvbmVudHM6IHt9LFxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZShwbHVnaW4pIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LlZ1ZSkge1xuICAgICAgICB3aW5kb3cuVnVlLnVzZShwbHVnaW4pO1xuICAgIH1cblxuICAgIHJldHVybiBwbHVnaW47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwbHVnaW4oVnVlLCBuYW1lLCBkZWYpIHtcbiAgICBpZighVnVlSW5zdGFsbGVyLiRwbHVnaW5zW25hbWVdKSB7XG4gICAgICAgIFZ1ZS51c2UoVnVlSW5zdGFsbGVyLiRwbHVnaW5zW25hbWVdID0gZGVmKTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwbHVnaW5zKFZ1ZSwgcGx1Z2lucykge1xuICAgIGVhY2gocGx1Z2lucywgKGRlZiwgbmFtZSkgPT4ge1xuICAgICAgICBwbHVnaW4oVnVlLCBuYW1lLCBkZWYpO1xuICAgIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcG9uZW50KFZ1ZSwgbmFtZSwgZGVmKSB7XG4gICAgaWYoIVZ1ZUluc3RhbGxlci4kY29tcG9uZW50c1tuYW1lXSkge1xuICAgICAgICBWdWUuY29tcG9uZW50KG5hbWUsIFZ1ZUluc3RhbGxlci4kY29tcG9uZW50c1tuYW1lXSA9IGRlZik7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcG9uZW50cyhWdWUsIGNvbXBvbmVudHMpIHtcbiAgICBlYWNoKGNvbXBvbmVudHMsIChkZWYsIG5hbWUpID0+IHtcbiAgICAgICAgY29tcG9uZW50KFZ1ZSwgbmFtZSwgZGVmKTtcbiAgICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpcmVjdGl2ZShWdWUsIG5hbWUsIGRlZikge1xuICAgIGlmKCFWdWVJbnN0YWxsZXIuJGRpcmVjdGl2ZXNbbmFtZV0pIHtcbiAgICAgICAgVnVlLmRpcmVjdGl2ZShuYW1lLCBWdWVJbnN0YWxsZXIuJGRpcmVjdGl2ZXNbbmFtZV0gPSBkZWYpO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpcmVjdGl2ZXMoVnVlLCBkaXJlY3RpdmVzKSB7XG4gICAgZWFjaChkaXJlY3RpdmVzLCAoZGVmLCBuYW1lKSA9PiB7XG4gICAgICAgIGRpcmVjdGl2ZShWdWUsIG5hbWUsIGRlZik7XG4gICAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IFZ1ZUluc3RhbGxlcjtcbiIsImltcG9ydCBBY3Rpdml0eUluZGljYXRvciBmcm9tICcuL0FjdGl2aXR5SW5kaWNhdG9yJztcbmltcG9ydCBWdWVJbnN0YWxsZXIgZnJvbSAnQC9IZWxwZXJzL1Z1ZUluc3RhbGxlci9WdWVJbnN0YWxsZXInO1xuXG5jb25zdCBwbHVnaW4gPSBWdWVJbnN0YWxsZXIudXNlKHtcblxuICAgIGluc3RhbGwoVnVlLCBvcHRpb25zKSB7XG4gICAgICAgIFZ1ZUluc3RhbGxlci5jb21wb25lbnRzKHtcbiAgICAgICAgICAgIEFjdGl2aXR5SW5kaWNhdG9yXG4gICAgICAgIH0pO1xuICAgIH1cblxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IEFjdGl2aXR5SW5kaWNhdG9yO1xuIiwiPHRlbXBsYXRlPlxuICAgIDxidXR0b24gOnR5cGU9XCJ0eXBlXCIgY2xhc3M9XCJidG5cIiA6Y2xhc3M9XCJjbGFzc2VzXCIgQGNsaWNrPVwib25DbGlja1wiPlxuICAgICAgICA8c2xvdD57e2xhYmVsfX08L3Nsb3Q+XG4gICAgICAgIDxhY3Rpdml0eS1pbmRpY2F0b3IgOnR5cGU9XCJpbmRpY2F0b3JcIiAvPlxuICAgIDwvYnV0dG9uPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCB7IGV4dGVuZCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgQWN0aXZpdHlJbmRpY2F0b3IgZnJvbSAnLi4vQWN0aXZpdHlJbmRpY2F0b3InO1xuXG5jb25zdCBjb252ZXJ0QW5pbWF0aW9uRGVsYXlUb0ludCA9IGZ1bmN0aW9uKGRlbGF5KSB7XG4gICAgY29uc3QgbnVtID0gcGFyc2VGbG9hdChkZWxheSwgMTApO1xuICAgIGNvbnN0IG1hdGNoZXMgPSBkZWxheS5tYXRjaCgvbT9zLyk7XG4gICAgY29uc3QgdW5pdCA9IG1hdGNoZXMgPyBtYXRjaGVzWzBdIDogZmFsc2U7XG5cbiAgICBsZXQgbWlsbGlzZWNvbmRzO1xuXG4gICAgc3dpdGNoICh1bml0KSB7XG4gICAgICAgIGNhc2UgXCJzXCI6IC8vIHNlY29uZHNcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IG51bSAqIDEwMDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm1zXCI6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBtaWxsaXNlY29uZHMgPSBudW07XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gbWlsbGlzZWNvbmRzIHx8IDA7XG59O1xuXG5jb25zdCBhbmltYXRlZCA9IGZ1bmN0aW9uKGVsLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGRlZmF1bHRWaWV3ID0gKGVsLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQpLmRlZmF1bHRWaWV3O1xuXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNhbGxiYWNrLmFwcGx5KCk7XG4gICAgfSwgY29udmVydEFuaW1hdGlvbkRlbGF5VG9JbnQoZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbCkuYW5pbWF0aW9uRHVyYXRpb24pKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdhY3Rpdml0eS1idXR0b24nLFxuXG4gICAgY29tcG9uZW50czoge1xuICAgICAgICBBY3Rpdml0eUluZGljYXRvclxuICAgIH0sXG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG91bGQgc2hvdyB0aGUgYWN0aXZpdHkgaW5kaWNhdG9yIGluc2lkZSB0aGUgYnV0dG9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgQm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgYWN0aXZpdHk6IHtcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG91bGQgc2hvdyB0aGUgYnV0dG9uIGFzIGRpc2FibGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgQm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgZGlzYWJsZWQ6IHtcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwbGF5IHRoZSBidXR0b24gYXMgYmxvY2sgd2lkdGguXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBCb29sZWFuXG4gICAgICAgICAqL1xuICAgICAgICBibG9jazoge1xuICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzaXplIG9mIHRoZSBidXR0b24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHNpemU6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdtZCdcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGJvb3RzdHJhcCB2YXJpYW50IG9mIHRoZSBidXR0b24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHZhcmlhbnQ6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdwcmltYXJ5J1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYHR5cGVgIGF0dHJpYnV0ZSBmb3IgdGhlIGJ1dHRvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJ2J1dHRvbidcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHR5cGUgb2YgYWN0aXZpdHkgaW5kaWNhdG9yIGluc2lkZSB0aGUgYnV0dG9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBpbmRpY2F0b3I6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdzcGlubmVyJ1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgb3JpZW50YXRpb24gb2YgdGhlIGFjdGl2aXR5IGJ1dHRvbiBpbnNpZGUgdGhlIGJ1dHRvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgb3JpZW50YXRpb246IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdyaWdodCdcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGJ1dHRvbiBsYWJlbC4gSWYgbm90IHBhc3NlZCBhcyBhIHByb3BlcnR5LCBsYWJlbCBtdXN0IGJlIHBhc3NlZFxuICAgICAgICAgKiBpbnNpZGUgdGhlIGVsZW1lbnQncyBodG1sLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBsYWJlbDoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWV0aG9kczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNhYmxlIHRoZSBidXR0b24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAgICAgKi9cbiAgICAgICAgZGlzYWJsZSgpIHtcbiAgICAgICAgICAgIHRoaXMuJGVsLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5hYmxlIHRoZSBidXR0b24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAgICAgKi9cbiAgICAgICAgZW5hYmxlKCkge1xuICAgICAgICAgICAgdGhpcy4kZWwuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvdyB0aGUgYWN0aXZpdHkgaW5kaWNhdG9yIGluc2lkZSB0aGUgYnV0dG9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgICAgICovXG4gICAgICAgIHNob3dBY3Rpdml0eSgpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzYWJsZSgpO1xuXG4gICAgICAgICAgICBhbmltYXRlZCh0aGlzLiRlbCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuJGVsLmNsYXNzTGlzdC5hZGQoJ2J0bi1hY3Rpdml0eScpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2FjdGl2aXR5OnNob3cnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIaWRlIHRoZSBhY3Rpdml0eSBpbmRpY2F0b3IgaW5zaWRlIHRoZSBidXR0b24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAgICAgKi9cbiAgICAgICAgaGlkZUFjdGl2aXR5KCkge1xuICAgICAgICAgICAgdGhpcy4kZWwuY2xhc3NMaXN0LmFkZCgnYnRuLWhpZGUtYWN0aXZpdHknKTtcblxuICAgICAgICAgICAgYW5pbWF0ZWQodGhpcy4kZWwsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmVuYWJsZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGVsLmNsYXNzTGlzdC5yZW1vdmUoJ2J0bi1hY3Rpdml0eScsICdidG4taGlkZS1hY3Rpdml0eScpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2FjdGl2aXR5OmhpZGUnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNhYmxlIHRoZSBidXR0b24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAgICAgKi9cbiAgICAgICAgb25DbGljayhldmVudCkge1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgnY2xpY2snLCBldmVudCwgdGhpcyk7XG4gICAgICAgIH0sXG4gICAgfSxcblxuICAgIGNvbXB1dGVkOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIG9iamVjdCBvZiBjbGFzc2VzIHRvIGFwcGVuZCB0byB0aGUgYnV0dG9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzZXMoKSB7XG4gICAgICAgICAgICBjb25zdCBjbGFzc2VzID0ge1xuICAgICAgICAgICAgICAgICdidG4tYmxvY2snOiB0aGlzLmJsb2NrLFxuICAgICAgICAgICAgICAgICdidG4tYWN0aXZpdHknOiB0aGlzLmFjdGl2aXR5XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBjbGFzc2VzWydidG4tJyArIHRoaXMuc2l6ZS5yZXBsYWNlKCdidG4tJywgJycpXSA9ICEhdGhpcy5zaXplO1xuICAgICAgICAgICAgY2xhc3Nlc1snYnRuLScgKyB0aGlzLnZhcmlhbnQucmVwbGFjZSgnYnRuLScsICcnKV0gPSAhIXRoaXMudmFyaWFudDtcbiAgICAgICAgICAgIGNsYXNzZXNbJ2J0bi1hY3Rpdml0eS0nICsgdGhpcy5vcmllbnRhdGlvbi5yZXBsYWNlKCdidG4tYWN0aXZpdHktJywgJycpXSA9ICEhdGhpcy5vcmllbnRhdGlvbjtcbiAgICAgICAgICAgIGNsYXNzZXNbJ2J0bi1hY3Rpdml0eS1pbmRpY2F0b3ItJyArIHRoaXMuaW5kaWNhdG9yLnJlcGxhY2UoJ2J0bi1hY3Rpdml0eS1pbmRpY2F0b3ItJywgJycpXSA9ICEhdGhpcy5pbmRpY2F0b3I7XG5cbiAgICAgICAgICAgIHJldHVybiBjbGFzc2VzO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHdhdGNoOiB7XG5cbiAgICAgICAgYWN0aXZpdHkodmFsdWUpIHtcbiAgICAgICAgICAgIGlmKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaG93QWN0aXZpdHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaGlkZUFjdGl2aXR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH1cblxufVxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwic2Nzc1wiPlxuQGltcG9ydCAnLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwL3Njc3MvYm9vdHN0cmFwLnNjc3MnO1xuXG4vLyBBY3Rpdml0eSBJbmRpY2F0b3IgdmFyaWFibGVzXG4kYWN0aXZpdHktaW5kaWNhdG9yLWFuaW1hdGVkLWRlbGF5LWluOiAzMzNtcztcbiRhY3Rpdml0eS1pbmRpY2F0b3ItYW5pbWF0ZWQtZGVsYXktb3V0OiAzMzNtcztcblxuJGFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyLXNpemU6ICRmb250LXNpemUtYmFzZSAqIDIuMjU7XG4kYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXItd2lkdGg6IDEwJTtcbiRhY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lci1oZWlnaHQ6IDMwJTtcbiRhY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lci1kZWxheTogMXM7XG5cbkBrZXlmcmFtZXMgYnRuLWFjdGl2aXR5LWluIHtcbiAgICAwJSwgMTAwJSB7XG4gICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMSk7XG4gICAgfSAzMCUge1xuICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKC45OCk7XG4gICAgfVxufVxuXG5Aa2V5ZnJhbWVzIGJ0bi1hY3Rpdml0eS1vdXQge1xuICAgIDAlLCAxMDAlIHtcbiAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgxKTtcbiAgICB9IDcwJSB7XG4gICAgICAgIHRyYW5zZm9ybTogc2NhbGUoLjk4KTtcbiAgICB9XG59XG5cbi8vIEFjdGl2aXR5IEluZGljYXRvciBCdXR0b25cbi5idG4tYWN0aXZpdHktdG9wLFxuLmJ0bi1hY3Rpdml0eS1ib3R0b20sXG4uYnRuLWFjdGl2aXR5LWxlZnQsXG4uYnRuLWFjdGl2aXR5LXJpZ2h0IHtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgdHJhbnNpdGlvbjogcGFkZGluZyAoJGFjdGl2aXR5LWluZGljYXRvci1hbmltYXRlZC1kZWxheS1pbiAvIDIpIGVhc2UtaW47XG5cbiAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICBvcGFjaXR5OiAwO1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcbiAgICAgICAgdHJhbnNpdGlvbjogb3BhY2l0eSAkYWN0aXZpdHktaW5kaWNhdG9yLWFuaW1hdGVkLWRlbGF5LW91dCBlYXNlLWluO1xuICAgIH1cbn1cblxuLmJ0bi1hY3Rpdml0eS10b3AgLmFjdGl2aXR5LWluZGljYXRvcixcbi5idG4tYWN0aXZpdHktYm90dG9tIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgIGxlZnQ6IDUwJTtcbiAgICBtYXJnaW4tcmlnaHQ6IC01MCU7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MCUpO1xufVxuLmJ0bi1hY3Rpdml0eS1sZWZ0IC5hY3Rpdml0eS1pbmRpY2F0b3IsXG4uYnRuLWFjdGl2aXR5LXJpZ2h0IC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgIHRvcDogNTAlO1xuICAgIG1hcmdpbi1ib3R0b206IC01MCU7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC01MCUpO1xufVxuXG4uYnRuLWFjdGl2aXR5Om5vdCguYnRuLWxpbmspIHtcbiAgICBhbmltYXRpb246IGJ0bi1hY3Rpdml0eS1pbiAkYWN0aXZpdHktaW5kaWNhdG9yLWFuaW1hdGVkLWRlbGF5LWluO1xufVxuLmJ0bi1oaWRlLWFjdGl2aXR5Om5vdCguYnRuLWxpbmspIHtcbiAgICBhbmltYXRpb246IGJ0bi1hY3Rpdml0eS1vdXQgJGFjdGl2aXR5LWluZGljYXRvci1hbmltYXRlZC1kZWxheS1vdXQ7XG59XG5cbi5idG4tYWN0aXZpdHkge1xuXG4gICAgJi5idG4taGlkZS1hY3Rpdml0eSAuYWN0aXZpdHktaW5kaWNhdG9yIHtcbiAgICAgICAgb3BhY2l0eTogMDtcbiAgICB9XG5cbiAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICBvcGFjaXR5OiAxO1xuICAgICAgICB2aXNpYmlsaXR5OiB2aXNpYmxlO1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgfVxuXG4gICAgJi5idG4tb3V0bGluZS1wcmltYXJ5LmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lciAuYWN0aXZpdHktaW5kaWNhdG9yID4gZGl2OmJlZm9yZSB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICRwcmltYXJ5O1xuICAgIH1cbiAgICAmLmJ0bi1vdXRsaW5lLXNlY29uZGFyeS5idG4tYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIgLmFjdGl2aXR5LWluZGljYXRvciA+IGRpdjpiZWZvcmUge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkc3VjY2VzcztcbiAgICB9XG4gICAgJi5idG4tb3V0bGluZS1kYW5nZXIuYnRuLWFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyIC5hY3Rpdml0eS1pbmRpY2F0b3IgPiBkaXY6YmVmb3JlIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogJGRhbmdlcjtcbiAgICB9XG4gICAgJi5idG4tb3V0bGluZS1zdWNjZXNzLmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lciAuYWN0aXZpdHktaW5kaWNhdG9yID4gZGl2OmJlZm9yZSB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICRzdWNjZXNzO1xuICAgIH1cbiAgICAmLmJ0bi1vdXRsaW5lLXdhcm5pbmcuYnRuLWFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyIC5hY3Rpdml0eS1pbmRpY2F0b3IgPiBkaXY6YmVmb3JlIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogJHdhcm5pbmc7XG4gICAgfVxuICAgICYuYnRuLW91dGxpbmUtaW5mby5idG4tYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIgLmFjdGl2aXR5LWluZGljYXRvciA+IGRpdjpiZWZvcmUge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkaW5mbztcbiAgICB9XG4gICAgJi5idG4tb3V0bGluZS1saW5rLmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lciAuYWN0aXZpdHktaW5kaWNhdG9yID4gZGl2OmJlZm9yZSB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICRsaW5rLWNvbG9yO1xuICAgIH1cblxuICAgICYuYnRuLXhzIHtcbiAgICAgICAgJi5idG4tYWN0aXZpdHktdG9wLmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyB7XG4gICAgICAgICAgICBwYWRkaW5nLXRvcDogJGZvbnQtc2l6ZS1iYXNlICogMS4yNTtcblxuICAgICAgICAgICAgJiAuYWN0aXZpdHktaW5kaWNhdG9yIHtcbiAgICAgICAgICAgICAgICB0b3A6ICRmb250LXNpemUtYmFzZSAqIC41O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJi5idG4tYWN0aXZpdHktYm90dG9tLmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyB7XG4gICAgICAgICAgICBwYWRkaW5nLWJvdHRvbTogJGZvbnQtc2l6ZS1iYXNlICogMS4yNTtcblxuICAgICAgICAgICAgJiAuYWN0aXZpdHktaW5kaWNhdG9yIHtcbiAgICAgICAgICAgICAgICBib3R0b206ICRmb250LXNpemUtYmFzZSAqIC41O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJi5idG4tYWN0aXZpdHktbGVmdC5idG4tYWN0aXZpdHktaW5kaWNhdG9yLWRvdHMge1xuICAgICAgICAgICAgcGFkZGluZy1sZWZ0OiAkZm9udC1zaXplLWJhc2UgKiAyLjMzO1xuXG4gICAgICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICAgICAgICAgIGxlZnQ6ICRmb250LXNpemUtYmFzZSAqIC41O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJi5idG4tYWN0aXZpdHktcmlnaHQuYnRuLWFjdGl2aXR5LWluZGljYXRvci1kb3RzIHtcbiAgICAgICAgICAgIHBhZGRpbmctcmlnaHQ6ICRmb250LXNpemUtYmFzZSAqIDIuMzM7XG5cbiAgICAgICAgICAgICYgLmFjdGl2aXR5LWluZGljYXRvciB7XG4gICAgICAgICAgICAgICAgcmlnaHQ6ICRmb250LXNpemUtYmFzZSAqIC41O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJi5idG4tYWN0aXZpdHktaW5kaWNhdG9yLWRvdHMgLmFjdGl2aXR5LWluZGljYXRvciA+IGRpdixcbiAgICAgICAgJiAuYWN0aXZpdHktaW5kaWNhdG9yLWRvdHMgPiBkaXYge1xuICAgICAgICAgICAgd2lkdGg6ICRmb250LXNpemUtYmFzZSAvIDM7XG4gICAgICAgICAgICBoZWlnaHQ6ICRmb250LXNpemUtYmFzZSAvIDM7XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS10b3AuYnRuLWFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyIHtcbiAgICAgICAgICAgIHBhZGRpbmctdG9wOiAkZm9udC1zaXplLWJhc2UgKiAxLjY2O1xuXG4gICAgICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICAgICAgICAgIHRvcDogJGZvbnQtc2l6ZS1iYXNlICogLjI1O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJi5idG4tYWN0aXZpdHktYm90dG9tLmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lciB7XG4gICAgICAgICAgICBwYWRkaW5nLWJvdHRvbTogJGZvbnQtc2l6ZS1iYXNlICogMS42NjtcblxuICAgICAgICAgICAgJiAuYWN0aXZpdHktaW5kaWNhdG9yIHtcbiAgICAgICAgICAgICAgICBib3R0b206ICRmb250LXNpemUtYmFzZSAqIC4yNTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICYuYnRuLWFjdGl2aXR5LWxlZnQuYnRuLWFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyIHtcbiAgICAgICAgICAgIHBhZGRpbmctbGVmdDogJGZvbnQtc2l6ZS1iYXNlICogMS42NjtcblxuICAgICAgICAgICAgJiAuYWN0aXZpdHktaW5kaWNhdG9yIHtcbiAgICAgICAgICAgICAgICBsZWZ0OiAkZm9udC1zaXplLWJhc2UgKiAuMjU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1yaWdodC5idG4tYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIge1xuICAgICAgICAgICAgcGFkZGluZy1yaWdodDogJGZvbnQtc2l6ZS1iYXNlICogMS42NjtcblxuICAgICAgICAgICAgJiAuYWN0aXZpdHktaW5kaWNhdG9yIHtcbiAgICAgICAgICAgICAgICByaWdodDogJGZvbnQtc2l6ZS1iYXNlICogLjI1O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJi5idG4tYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIgLmFjdGl2aXR5LWluZGljYXRvcixcbiAgICAgICAgJiAuYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIge1xuICAgICAgICAgICAgd2lkdGg6ICRmb250LXNpemUtYmFzZSAqIDE7XG4gICAgICAgICAgICBoZWlnaHQ6ICRmb250LXNpemUtYmFzZSAqIDE7XG5cbiAgICAgICAgICAgICYgPiBkaXY6YmVmb3JlIHtcbiAgICAgICAgICAgICAgICAvL3dpZHRoOiAkYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXItd2lkdGggKiAuNjM7XG4gICAgICAgICAgICAgICAgLy9oZWlnaHQ6ICRhY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lci1oZWlnaHQgKiAuNjY7XG4gICAgICAgICAgICAgICAgd2lkdGg6ICRhY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lci13aWR0aCAqIC44NDtcbiAgICAgICAgICAgICAgICBoZWlnaHQ6ICRhY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lci1oZWlnaHQgKiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgJi5idG4tc20ge1xuICAgICAgICAmLmJ0bi1hY3Rpdml0eS10b3AuYnRuLWFjdGl2aXR5LWluZGljYXRvci1kb3RzIHtcbiAgICAgICAgICAgIHBhZGRpbmctdG9wOiAkZm9udC1zaXplLWJhc2UgKiAxLjc1O1xuXG4gICAgICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICAgICAgICAgIHRvcDogJGZvbnQtc2l6ZS1iYXNlICogLjU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1ib3R0b20uYnRuLWFjdGl2aXR5LWluZGljYXRvci1kb3RzIHtcbiAgICAgICAgICAgIHBhZGRpbmctYm90dG9tOiAkZm9udC1zaXplLWJhc2UgKiAxLjc1O1xuXG4gICAgICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICAgICAgICAgIGJvdHRvbTogJGZvbnQtc2l6ZS1iYXNlICogLjU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1sZWZ0LmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyB7XG4gICAgICAgICAgICBwYWRkaW5nLWxlZnQ6ICRmb250LXNpemUtYmFzZSAqIDM7XG5cbiAgICAgICAgICAgICYgLmFjdGl2aXR5LWluZGljYXRvciB7XG4gICAgICAgICAgICAgICAgbGVmdDogJGZvbnQtc2l6ZS1iYXNlICogLjU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1yaWdodC5idG4tYWN0aXZpdHktaW5kaWNhdG9yLWRvdHMge1xuICAgICAgICAgICAgcGFkZGluZy1yaWdodDogJGZvbnQtc2l6ZS1iYXNlICogMztcblxuICAgICAgICAgICAgJiAuYWN0aXZpdHktaW5kaWNhdG9yIHtcbiAgICAgICAgICAgICAgICByaWdodDogJGZvbnQtc2l6ZS1iYXNlICogLjU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyAuYWN0aXZpdHktaW5kaWNhdG9yID4gZGl2LFxuICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyA+IGRpdiB7XG4gICAgICAgICAgICB3aWR0aDogJGZvbnQtc2l6ZS1iYXNlIC8gMjtcbiAgICAgICAgICAgIGhlaWdodDogJGZvbnQtc2l6ZS1iYXNlIC8gMjtcbiAgICAgICAgfVxuXG4gICAgICAgICYuYnRuLWFjdGl2aXR5LXRvcC5idG4tYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIge1xuICAgICAgICAgICAgcGFkZGluZy10b3A6ICRmb250LXNpemUtYmFzZSAqIDI7XG5cbiAgICAgICAgICAgICYgLmFjdGl2aXR5LWluZGljYXRvciB7XG4gICAgICAgICAgICAgICAgdG9wOiAkZm9udC1zaXplLWJhc2UgKiAuMzM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1ib3R0b20uYnRuLWFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyIHtcbiAgICAgICAgICAgIHBhZGRpbmctYm90dG9tOiAkZm9udC1zaXplLWJhc2UgKiAyO1xuXG4gICAgICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICAgICAgICAgIGJvdHRvbTogJGZvbnQtc2l6ZS1iYXNlICogLjMzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJi5idG4tYWN0aXZpdHktbGVmdC5idG4tYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIge1xuICAgICAgICAgICAgcGFkZGluZy1sZWZ0OiAkZm9udC1zaXplLWJhc2UgKiAyLjU7XG5cbiAgICAgICAgICAgICYgLmFjdGl2aXR5LWluZGljYXRvciB7XG4gICAgICAgICAgICAgICAgbGVmdDogJGZvbnQtc2l6ZS1iYXNlICogLjU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1yaWdodC5idG4tYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIge1xuICAgICAgICAgICAgcGFkZGluZy1yaWdodDogJGZvbnQtc2l6ZS1iYXNlICogMi41O1xuXG4gICAgICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICAgICAgICAgIHJpZ2h0OiAkZm9udC1zaXplLWJhc2UgKiAuNTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICYuYnRuLWFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyIC5hY3Rpdml0eS1pbmRpY2F0b3IsXG4gICAgICAgICYgLmFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyIHtcbiAgICAgICAgICAgIHdpZHRoOiAkZm9udC1zaXplLWJhc2UgKiAxLjU7XG4gICAgICAgICAgICBoZWlnaHQ6ICRmb250LXNpemUtYmFzZSAqIDEuNTtcblxuICAgICAgICAgICAgJiA+IGRpdjpiZWZvcmUge1xuICAgICAgICAgICAgICAgIHdpZHRoOiAkYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXItd2lkdGggKiAuNTY7XG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAkYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXItaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgJjpub3QoLmJ0bi14cyk6bm90KC5idG4tc20pOm5vdCguYnRuLW1kKTpub3QoLmJ0bi1sZyk6bm90KC5idG4teGwpLFxuICAgICYuYnRuLW1kIHtcbiAgICAgICAgJi5idG4tYWN0aXZpdHktdG9wLmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyB7XG4gICAgICAgICAgICBwYWRkaW5nLXRvcDogJGZvbnQtc2l6ZS1iYXNlICogMjtcblxuICAgICAgICAgICAgJiAuYWN0aXZpdHktaW5kaWNhdG9yIHtcbiAgICAgICAgICAgICAgICB0b3A6ICRmb250LXNpemUtYmFzZSAqIC42NjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICYuYnRuLWFjdGl2aXR5LWJvdHRvbS5idG4tYWN0aXZpdHktaW5kaWNhdG9yLWRvdHMge1xuICAgICAgICAgICAgcGFkZGluZy1ib3R0b206ICRmb250LXNpemUtYmFzZSAqIDI7XG5cbiAgICAgICAgICAgICYgLmFjdGl2aXR5LWluZGljYXRvciB7XG4gICAgICAgICAgICAgICAgYm90dG9tOiAkZm9udC1zaXplLWJhc2UgKiAuNjY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1sZWZ0LmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyB7XG4gICAgICAgICAgICBwYWRkaW5nLWxlZnQ6ICRmb250LXNpemUtYmFzZSAqIDQ7XG5cbiAgICAgICAgICAgICYgLmFjdGl2aXR5LWluZGljYXRvciB7XG4gICAgICAgICAgICAgICAgbGVmdDogJGZvbnQtc2l6ZS1iYXNlICogLjU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1yaWdodC5idG4tYWN0aXZpdHktaW5kaWNhdG9yLWRvdHMge1xuICAgICAgICAgICAgcGFkZGluZy1yaWdodDogJGZvbnQtc2l6ZS1iYXNlICogNDtcblxuICAgICAgICAgICAgJiAuYWN0aXZpdHktaW5kaWNhdG9yIHtcbiAgICAgICAgICAgICAgICByaWdodDogJGZvbnQtc2l6ZS1iYXNlICogLjU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyAuYWN0aXZpdHktaW5kaWNhdG9yID4gZGl2LFxuICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyA+IGRpdiB7XG4gICAgICAgICAgICB3aWR0aDogJGZvbnQtc2l6ZS1iYXNlIC8gMS4yNTtcbiAgICAgICAgICAgIGhlaWdodDogJGZvbnQtc2l6ZS1iYXNlIC8gMS4yNTtcbiAgICAgICAgfVxuXG4gICAgICAgICYuYnRuLWFjdGl2aXR5LXRvcC5idG4tYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIge1xuICAgICAgICAgICAgcGFkZGluZy10b3A6ICRmb250LXNpemUtYmFzZSAqIDIuNzU7XG5cbiAgICAgICAgICAgICYgLmFjdGl2aXR5LWluZGljYXRvciB7XG4gICAgICAgICAgICAgICAgdG9wOiAkZm9udC1zaXplLWJhc2UgKiAuMzM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1ib3R0b20uYnRuLWFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyIHtcbiAgICAgICAgICAgIHBhZGRpbmctYm90dG9tOiAkZm9udC1zaXplLWJhc2UgKiAyLjc1O1xuXG4gICAgICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICAgICAgICAgIGJvdHRvbTogJGZvbnQtc2l6ZS1iYXNlICogLjMzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJi5idG4tYWN0aXZpdHktbGVmdC5idG4tYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIge1xuICAgICAgICAgICAgcGFkZGluZy1sZWZ0OiAkZm9udC1zaXplLWJhc2UgKiAyLjc1O1xuXG4gICAgICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICAgICAgICAgIGxlZnQ6ICRmb250LXNpemUtYmFzZSAqIC41O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJi5idG4tYWN0aXZpdHktcmlnaHQuYnRuLWFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyIHtcbiAgICAgICAgICAgIHBhZGRpbmctcmlnaHQ6ICRmb250LXNpemUtYmFzZSAqIDIuNzU7XG5cbiAgICAgICAgICAgICYgLmFjdGl2aXR5LWluZGljYXRvciB7XG4gICAgICAgICAgICAgICAgcmlnaHQ6ICRmb250LXNpemUtYmFzZSAqIC41O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJi5idG4tYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIgLmFjdGl2aXR5LWluZGljYXRvcixcbiAgICAgICAgJiAuYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIge1xuICAgICAgICAgICAgd2lkdGg6ICRmb250LXNpemUtYmFzZSAqIDEuNzU7XG4gICAgICAgICAgICBoZWlnaHQ6ICRmb250LXNpemUtYmFzZSAqIDEuNzU7XG5cbiAgICAgICAgICAgICYgPiBkaXY6YmVmb3JlIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogJGFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyLXdpZHRoICogLjY2O1xuICAgICAgICAgICAgICAgIGhlaWdodDogJGFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyLWhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgICYuYnRuLWxnIHtcbiAgICAgICAgJi5idG4tYWN0aXZpdHktdG9wLmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyB7XG4gICAgICAgICAgICBwYWRkaW5nLXRvcDogJGZvbnQtc2l6ZS1iYXNlICogMi43NTtcblxuICAgICAgICAgICAgJiAuYWN0aXZpdHktaW5kaWNhdG9yIHtcbiAgICAgICAgICAgICAgICB0b3A6ICRmb250LXNpemUtYmFzZSAqIC42NjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICYuYnRuLWFjdGl2aXR5LWJvdHRvbS5idG4tYWN0aXZpdHktaW5kaWNhdG9yLWRvdHMge1xuICAgICAgICAgICAgcGFkZGluZy1ib3R0b206ICRmb250LXNpemUtYmFzZSAqIDIuNzU7XG5cbiAgICAgICAgICAgICYgLmFjdGl2aXR5LWluZGljYXRvciB7XG4gICAgICAgICAgICAgICAgYm90dG9tOiAkZm9udC1zaXplLWJhc2UgKiAuNjY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1sZWZ0LmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyB7XG4gICAgICAgICAgICBwYWRkaW5nLWxlZnQ6ICRmb250LXNpemUtYmFzZSAqIDU7XG5cbiAgICAgICAgICAgICYgLmFjdGl2aXR5LWluZGljYXRvciB7XG4gICAgICAgICAgICAgICAgbGVmdDogJGZvbnQtc2l6ZS1iYXNlICogLjU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1yaWdodC5idG4tYWN0aXZpdHktaW5kaWNhdG9yLWRvdHMge1xuICAgICAgICAgICAgcGFkZGluZy1yaWdodDogJGZvbnQtc2l6ZS1iYXNlICogNTtcblxuICAgICAgICAgICAgJiAuYWN0aXZpdHktaW5kaWNhdG9yIHtcbiAgICAgICAgICAgICAgICByaWdodDogJGZvbnQtc2l6ZS1iYXNlICogLjU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyAuYWN0aXZpdHktaW5kaWNhdG9yID4gZGl2LFxuICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyA+IGRpdiB7XG4gICAgICAgICAgICB3aWR0aDogJGZvbnQtc2l6ZS1iYXNlICogMS4xO1xuICAgICAgICAgICAgaGVpZ2h0OiAkZm9udC1zaXplLWJhc2UgKiAxLjE7XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS10b3AuYnRuLWFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyIHtcbiAgICAgICAgICAgIHBhZGRpbmctdG9wOiAkZm9udC1zaXplLWJhc2UgKiAzLjU7XG5cbiAgICAgICAgICAgICYgLmFjdGl2aXR5LWluZGljYXRvciB7XG4gICAgICAgICAgICAgICAgdG9wOiAkZm9udC1zaXplLWJhc2UgKiAuNTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICYuYnRuLWFjdGl2aXR5LWJvdHRvbS5idG4tYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIge1xuICAgICAgICAgICAgcGFkZGluZy1ib3R0b206ICRmb250LXNpemUtYmFzZSAqIDMuNTtcblxuICAgICAgICAgICAgJiAuYWN0aXZpdHktaW5kaWNhdG9yIHtcbiAgICAgICAgICAgICAgICBib3R0b206ICRmb250LXNpemUtYmFzZSAqIC41O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJi5idG4tYWN0aXZpdHktbGVmdC5idG4tYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIge1xuICAgICAgICAgICAgcGFkZGluZy1sZWZ0OiAkZm9udC1zaXplLWJhc2UgKiAzLjI1O1xuXG4gICAgICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICAgICAgICAgIGxlZnQ6ICRmb250LXNpemUtYmFzZSAqIC41O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJi5idG4tYWN0aXZpdHktcmlnaHQuYnRuLWFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyIHtcbiAgICAgICAgICAgIHBhZGRpbmctcmlnaHQ6ICRmb250LXNpemUtYmFzZSAqIDMuMjU7XG5cbiAgICAgICAgICAgICYgLmFjdGl2aXR5LWluZGljYXRvciB7XG4gICAgICAgICAgICAgICAgcmlnaHQ6ICRmb250LXNpemUtYmFzZSAqIC41O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJi5idG4tYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIgLmFjdGl2aXR5LWluZGljYXRvcixcbiAgICAgICAgJiAuYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIge1xuICAgICAgICAgICAgd2lkdGg6ICRmb250LXNpemUtYmFzZSAqIDIuMTU7XG4gICAgICAgICAgICBoZWlnaHQ6ICRmb250LXNpemUtYmFzZSAqIDIuMTU7XG5cbiAgICAgICAgICAgICYgPiBkaXY6YmVmb3JlIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogJGFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyLXdpZHRoICogLjc1O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgJi5idG4teGwge1xuICAgICAgICAmLmJ0bi1hY3Rpdml0eS10b3AuYnRuLWFjdGl2aXR5LWluZGljYXRvci1kb3RzIHtcbiAgICAgICAgICAgIHBhZGRpbmctdG9wOiAkZm9udC1zaXplLWJhc2UgKiAzLjc1O1xuXG4gICAgICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICAgICAgICAgIHRvcDogJGZvbnQtc2l6ZS1iYXNlICogMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICYuYnRuLWFjdGl2aXR5LWJvdHRvbS5idG4tYWN0aXZpdHktaW5kaWNhdG9yLWRvdHMge1xuICAgICAgICAgICAgcGFkZGluZy1ib3R0b206ICRmb250LXNpemUtYmFzZSAqIDMuNzU7XG5cbiAgICAgICAgICAgICYgLmFjdGl2aXR5LWluZGljYXRvciB7XG4gICAgICAgICAgICAgICAgYm90dG9tOiAkZm9udC1zaXplLWJhc2UgKiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJi5idG4tYWN0aXZpdHktbGVmdC5idG4tYWN0aXZpdHktaW5kaWNhdG9yLWRvdHMge1xuICAgICAgICAgICAgcGFkZGluZy1sZWZ0OiAkZm9udC1zaXplLWJhc2UgKiA2O1xuXG4gICAgICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICAgICAgICAgIGxlZnQ6ICRmb250LXNpemUtYmFzZSAqIC43NTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICYuYnRuLWFjdGl2aXR5LXJpZ2h0LmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyB7XG4gICAgICAgICAgICBwYWRkaW5nLXJpZ2h0OiAkZm9udC1zaXplLWJhc2UgKiA2O1xuXG4gICAgICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICAgICAgICAgIHJpZ2h0OiAkZm9udC1zaXplLWJhc2UgKiAuNzU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyAuYWN0aXZpdHktaW5kaWNhdG9yID4gZGl2LFxuICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyA+IGRpdiB7XG4gICAgICAgICAgICB3aWR0aDogJGZvbnQtc2l6ZS1iYXNlICogMS4yNTtcbiAgICAgICAgICAgIGhlaWdodDogJGZvbnQtc2l6ZS1iYXNlICogMS4yNTtcbiAgICAgICAgfVxuXG4gICAgICAgICYuYnRuLWFjdGl2aXR5LXRvcC5idG4tYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIge1xuICAgICAgICAgICAgcGFkZGluZy10b3A6ICRmb250LXNpemUtYmFzZSAqIDQuMjU7XG5cbiAgICAgICAgICAgICYgLmFjdGl2aXR5LWluZGljYXRvciB7XG4gICAgICAgICAgICAgICAgdG9wOiAkZm9udC1zaXplLWJhc2UgKiAuNjY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1ib3R0b20uYnRuLWFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyIHtcbiAgICAgICAgICAgIHBhZGRpbmctYm90dG9tOiAkZm9udC1zaXplLWJhc2UgKiA0LjI1O1xuXG4gICAgICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICAgICAgICAgIGJvdHRvbTogJGZvbnQtc2l6ZS1iYXNlICogLjY2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJi5idG4tYWN0aXZpdHktbGVmdC5idG4tYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIge1xuICAgICAgICAgICAgcGFkZGluZy1sZWZ0OiAkZm9udC1zaXplLWJhc2UgKiA0O1xuXG4gICAgICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICAgICAgICAgIGxlZnQ6ICRmb250LXNpemUtYmFzZSAqIC43NTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICYuYnRuLWFjdGl2aXR5LXJpZ2h0LmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lciB7XG4gICAgICAgICAgICBwYWRkaW5nLXJpZ2h0OiAkZm9udC1zaXplLWJhc2UgKiA0O1xuXG4gICAgICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICAgICAgICAgIHJpZ2h0OiAkZm9udC1zaXplLWJhc2UgKiAuNzU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lciAuYWN0aXZpdHktaW5kaWNhdG9yLFxuICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lciB7XG4gICAgICAgICAgICB3aWR0aDogJGZvbnQtc2l6ZS1iYXNlICogMi41O1xuICAgICAgICAgICAgaGVpZ2h0OiAkZm9udC1zaXplLWJhc2UgKiAyLjU7XG5cbiAgICAgICAgICAgICYgPiBkaXY6YmVmb3JlIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogJGFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyLXdpZHRoICogLjc1O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG59XG48L3N0eWxlPlxuIiwiaW1wb3J0IEFjdGl2aXR5QnV0dG9uIGZyb20gJy4vQWN0aXZpdHlCdXR0b24nO1xuaW1wb3J0IFZ1ZUluc3RhbGxlciBmcm9tICdAL0hlbHBlcnMvVnVlSW5zdGFsbGVyL1Z1ZUluc3RhbGxlcic7XG5cbmNvbnN0IHBsdWdpbiA9IFZ1ZUluc3RhbGxlci51c2Uoe1xuXG4gICAgaW5zdGFsbChWdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgVnVlSW5zdGFsbGVyLmNvbXBvbmVudHMoe1xuICAgICAgICAgICAgQWN0aXZpdHlCdXR0b25cbiAgICAgICAgfSlcbiAgICB9XG5cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBBY3Rpdml0eUJ1dHRvbjtcbiIsIi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqXG4gKiBBZGRzIGB2YWx1ZWAgdG8gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBhZGRcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQGFsaWFzIHB1c2hcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNhY2hlLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlQWRkKHZhbHVlKSB7XG4gIHRoaXMuX19kYXRhX18uc2V0KHZhbHVlLCBIQVNIX1VOREVGSU5FRCk7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldENhY2hlQWRkO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBpbiB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUhhcyh2YWx1ZSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXModmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldENhY2hlSGFzO1xuIiwidmFyIE1hcENhY2hlID0gcmVxdWlyZSgnLi9fTWFwQ2FjaGUnKSxcbiAgICBzZXRDYWNoZUFkZCA9IHJlcXVpcmUoJy4vX3NldENhY2hlQWRkJyksXG4gICAgc2V0Q2FjaGVIYXMgPSByZXF1aXJlKCcuL19zZXRDYWNoZUhhcycpO1xuXG4vKipcbiAqXG4gKiBDcmVhdGVzIGFuIGFycmF5IGNhY2hlIG9iamVjdCB0byBzdG9yZSB1bmlxdWUgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFNldENhY2hlKHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcyA9PSBudWxsID8gMCA6IHZhbHVlcy5sZW5ndGg7XG5cbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB0aGlzLmFkZCh2YWx1ZXNbaW5kZXhdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU2V0Q2FjaGVgLlxuU2V0Q2FjaGUucHJvdG90eXBlLmFkZCA9IFNldENhY2hlLnByb3RvdHlwZS5wdXNoID0gc2V0Q2FjaGVBZGQ7XG5TZXRDYWNoZS5wcm90b3R5cGUuaGFzID0gc2V0Q2FjaGVIYXM7XG5cbm1vZHVsZS5leHBvcnRzID0gU2V0Q2FjaGU7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zb21lYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlTb21lKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5U29tZTtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGEgYGNhY2hlYCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gY2FjaGUgVGhlIGNhY2hlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGNhY2hlSGFzKGNhY2hlLCBrZXkpIHtcbiAgcmV0dXJuIGNhY2hlLmhhcyhrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhY2hlSGFzO1xuIiwidmFyIFNldENhY2hlID0gcmVxdWlyZSgnLi9fU2V0Q2FjaGUnKSxcbiAgICBhcnJheVNvbWUgPSByZXF1aXJlKCcuL19hcnJheVNvbWUnKSxcbiAgICBjYWNoZUhhcyA9IHJlcXVpcmUoJy4vX2NhY2hlSGFzJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGFycmF5cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtBcnJheX0gb3RoZXIgVGhlIG90aGVyIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBhcnJheWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJyYXlzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQXJyYXlzKGFycmF5LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuXG4gIGlmIChhcnJMZW5ndGggIT0gb3RoTGVuZ3RoICYmICEoaXNQYXJ0aWFsICYmIG90aExlbmd0aCA+IGFyckxlbmd0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChhcnJheSk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IHRydWUsXG4gICAgICBzZWVuID0gKGJpdG1hc2sgJiBDT01QQVJFX1VOT1JERVJFRF9GTEFHKSA/IG5ldyBTZXRDYWNoZSA6IHVuZGVmaW5lZDtcblxuICBzdGFjay5zZXQoYXJyYXksIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBhcnJheSk7XG5cbiAgLy8gSWdub3JlIG5vbi1pbmRleCBwcm9wZXJ0aWVzLlxuICB3aGlsZSAoKytpbmRleCA8IGFyckxlbmd0aCkge1xuICAgIHZhciBhcnJWYWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltpbmRleF07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgYXJyVmFsdWUsIGluZGV4LCBvdGhlciwgYXJyYXksIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIoYXJyVmFsdWUsIG90aFZhbHVlLCBpbmRleCwgYXJyYXksIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIGlmIChjb21wYXJlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoY29tcGFyZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmIChzZWVuKSB7XG4gICAgICBpZiAoIWFycmF5U29tZShvdGhlciwgZnVuY3Rpb24ob3RoVmFsdWUsIG90aEluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIWNhY2hlSGFzKHNlZW4sIG90aEluZGV4KSAmJlxuICAgICAgICAgICAgICAgIChhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKSkge1xuICAgICAgICAgICAgICByZXR1cm4gc2Vlbi5wdXNoKG90aEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSkge1xuICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghKFxuICAgICAgICAgIGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fFxuICAgICAgICAgICAgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHN0YWNrWydkZWxldGUnXShhcnJheSk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXF1YWxBcnJheXM7XG4iLCIvKipcbiAqIENvbnZlcnRzIGBtYXBgIHRvIGl0cyBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gKi9cbmZ1bmN0aW9uIG1hcFRvQXJyYXkobWFwKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobWFwLnNpemUpO1xuXG4gIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSBba2V5LCB2YWx1ZV07XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcFRvQXJyYXk7XG4iLCIvKipcbiAqIENvbnZlcnRzIGBzZXRgIHRvIGFuIGFycmF5IG9mIGl0cyB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIHNldFRvQXJyYXkoc2V0KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkoc2V0LnNpemUpO1xuXG4gIHNldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldFRvQXJyYXk7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgVWludDhBcnJheSA9IHJlcXVpcmUoJy4vX1VpbnQ4QXJyYXknKSxcbiAgICBlcSA9IHJlcXVpcmUoJy4vZXEnKSxcbiAgICBlcXVhbEFycmF5cyA9IHJlcXVpcmUoJy4vX2VxdWFsQXJyYXlzJyksXG4gICAgbWFwVG9BcnJheSA9IHJlcXVpcmUoJy4vX21hcFRvQXJyYXknKSxcbiAgICBzZXRUb0FycmF5ID0gcmVxdWlyZSgnLi9fc2V0VG9BcnJheScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJztcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBjb21wYXJpbmcgb2JqZWN0cyBvZlxuICogdGhlIHNhbWUgYHRvU3RyaW5nVGFnYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNvbXBhcmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBvciBgU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0cyB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgdGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAob2JqZWN0LmJ5dGVPZmZzZXQgIT0gb3RoZXIuYnl0ZU9mZnNldCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgb2JqZWN0ID0gb2JqZWN0LmJ1ZmZlcjtcbiAgICAgIG90aGVyID0gb3RoZXIuYnVmZmVyO1xuXG4gICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAhZXF1YWxGdW5jKG5ldyBVaW50OEFycmF5KG9iamVjdCksIG5ldyBVaW50OEFycmF5KG90aGVyKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICBjYXNlIGJvb2xUYWc6XG4gICAgY2FzZSBkYXRlVGFnOlxuICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgLy8gQ29lcmNlIGJvb2xlYW5zIHRvIGAxYCBvciBgMGAgYW5kIGRhdGVzIHRvIG1pbGxpc2Vjb25kcy5cbiAgICAgIC8vIEludmFsaWQgZGF0ZXMgYXJlIGNvZXJjZWQgdG8gYE5hTmAuXG4gICAgICByZXR1cm4gZXEoK29iamVjdCwgK290aGVyKTtcblxuICAgIGNhc2UgZXJyb3JUYWc6XG4gICAgICByZXR1cm4gb2JqZWN0Lm5hbWUgPT0gb3RoZXIubmFtZSAmJiBvYmplY3QubWVzc2FnZSA9PSBvdGhlci5tZXNzYWdlO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAvLyBDb2VyY2UgcmVnZXhlcyB0byBzdHJpbmdzIGFuZCB0cmVhdCBzdHJpbmdzLCBwcmltaXRpdmVzIGFuZCBvYmplY3RzLFxuICAgICAgLy8gYXMgZXF1YWwuIFNlZSBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcmVnZXhwLnByb3RvdHlwZS50b3N0cmluZ1xuICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIHJldHVybiBvYmplY3QgPT0gKG90aGVyICsgJycpO1xuXG4gICAgY2FzZSBtYXBUYWc6XG4gICAgICB2YXIgY29udmVydCA9IG1hcFRvQXJyYXk7XG5cbiAgICBjYXNlIHNldFRhZzpcbiAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUc7XG4gICAgICBjb252ZXJ0IHx8IChjb252ZXJ0ID0gc2V0VG9BcnJheSk7XG5cbiAgICAgIGlmIChvYmplY3Quc2l6ZSAhPSBvdGhlci5zaXplICYmICFpc1BhcnRpYWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgICAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICAgICAgfVxuICAgICAgYml0bWFzayB8PSBDT01QQVJFX1VOT1JERVJFRF9GTEFHO1xuXG4gICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgICAgIHZhciByZXN1bHQgPSBlcXVhbEFycmF5cyhjb252ZXJ0KG9iamVjdCksIGNvbnZlcnQob3RoZXIpLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICAgIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgaWYgKHN5bWJvbFZhbHVlT2YpIHtcbiAgICAgICAgcmV0dXJuIHN5bWJvbFZhbHVlT2YuY2FsbChvYmplY3QpID09IHN5bWJvbFZhbHVlT2YuY2FsbChvdGhlcik7XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxdWFsQnlUYWc7XG4iLCIvKipcbiAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlQdXNoO1xuIiwidmFyIGFycmF5UHVzaCA9IHJlcXVpcmUoJy4vX2FycmF5UHVzaCcpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0QWxsS2V5c2AgYW5kIGBnZXRBbGxLZXlzSW5gIHdoaWNoIHVzZXNcbiAqIGBrZXlzRnVuY2AgYW5kIGBzeW1ib2xzRnVuY2AgdG8gZ2V0IHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN5bWJvbHNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNGdW5jLCBzeW1ib2xzRnVuYykge1xuICB2YXIgcmVzdWx0ID0ga2V5c0Z1bmMob2JqZWN0KTtcbiAgcmV0dXJuIGlzQXJyYXkob2JqZWN0KSA/IHJlc3VsdCA6IGFycmF5UHVzaChyZXN1bHQsIHN5bWJvbHNGdW5jKG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXRBbGxLZXlzO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZmlsdGVyYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RmlsdGVyKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5RmlsdGVyO1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGVtcHR5IGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZW1wdHkgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBhcnJheXMgPSBfLnRpbWVzKDIsIF8uc3R1YkFycmF5KTtcbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXMpO1xuICogLy8gPT4gW1tdLCBbXV1cbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXNbMF0gPT09IGFycmF5c1sxXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBzdHViQXJyYXkoKSB7XG4gIHJldHVybiBbXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHViQXJyYXk7XG4iLCJ2YXIgYXJyYXlGaWx0ZXIgPSByZXF1aXJlKCcuL19hcnJheUZpbHRlcicpLFxuICAgIHN0dWJBcnJheSA9IHJlcXVpcmUoJy4vc3R1YkFycmF5Jyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICByZXR1cm4gYXJyYXlGaWx0ZXIobmF0aXZlR2V0U3ltYm9scyhvYmplY3QpLCBmdW5jdGlvbihzeW1ib2wpIHtcbiAgICByZXR1cm4gcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsIHN5bWJvbCk7XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRTeW1ib2xzO1xuIiwidmFyIGJhc2VHZXRBbGxLZXlzID0gcmVxdWlyZSgnLi9fYmFzZUdldEFsbEtleXMnKSxcbiAgICBnZXRTeW1ib2xzID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9scycpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRBbGxLZXlzKG9iamVjdCkge1xuICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzLCBnZXRTeW1ib2xzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRBbGxLZXlzO1xuIiwidmFyIGdldEFsbEtleXMgPSByZXF1aXJlKCcuL19nZXRBbGxLZXlzJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIG9iamVjdHMgd2l0aCBzdXBwb3J0IGZvclxuICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcbiAgICAgIG9ialByb3BzID0gZ2V0QWxsS2V5cyhvYmplY3QpLFxuICAgICAgb2JqTGVuZ3RoID0gb2JqUHJvcHMubGVuZ3RoLFxuICAgICAgb3RoUHJvcHMgPSBnZXRBbGxLZXlzKG90aGVyKSxcbiAgICAgIG90aExlbmd0aCA9IG90aFByb3BzLmxlbmd0aDtcblxuICBpZiAob2JqTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBpbmRleCA9IG9iakxlbmd0aDtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIGlmICghKGlzUGFydGlhbCA/IGtleSBpbiBvdGhlciA6IGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsIGtleSkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICB9XG4gIHZhciByZXN1bHQgPSB0cnVlO1xuICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gIHN0YWNrLnNldChvdGhlciwgb2JqZWN0KTtcblxuICB2YXIgc2tpcEN0b3IgPSBpc1BhcnRpYWw7XG4gIHdoaWxlICgrK2luZGV4IDwgb2JqTGVuZ3RoKSB7XG4gICAga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2tleV07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgb2JqVmFsdWUsIGtleSwgb3RoZXIsIG9iamVjdCwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihvYmpWYWx1ZSwgb3RoVmFsdWUsIGtleSwgb2JqZWN0LCBvdGhlciwgc3RhY2spO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBpZiAoIShjb21wYXJlZCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyAob2JqVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhvYmpWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSlcbiAgICAgICAgICA6IGNvbXBhcmVkXG4gICAgICAgICkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHNraXBDdG9yIHx8IChza2lwQ3RvciA9IGtleSA9PSAnY29uc3RydWN0b3InKTtcbiAgfVxuICBpZiAocmVzdWx0ICYmICFza2lwQ3Rvcikge1xuICAgIHZhciBvYmpDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICBvdGhDdG9yID0gb3RoZXIuY29uc3RydWN0b3I7XG5cbiAgICAvLyBOb24gYE9iamVjdGAgb2JqZWN0IGluc3RhbmNlcyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVhbC5cbiAgICBpZiAob2JqQ3RvciAhPSBvdGhDdG9yICYmXG4gICAgICAgICgnY29uc3RydWN0b3InIGluIG9iamVjdCAmJiAnY29uc3RydWN0b3InIGluIG90aGVyKSAmJlxuICAgICAgICAhKHR5cGVvZiBvYmpDdG9yID09ICdmdW5jdGlvbicgJiYgb2JqQ3RvciBpbnN0YW5jZW9mIG9iakN0b3IgJiZcbiAgICAgICAgICB0eXBlb2Ygb3RoQ3RvciA9PSAnZnVuY3Rpb24nICYmIG90aEN0b3IgaW5zdGFuY2VvZiBvdGhDdG9yKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxdWFsT2JqZWN0cztcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgRGF0YVZpZXcgPSBnZXROYXRpdmUocm9vdCwgJ0RhdGFWaWV3Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YVZpZXc7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFByb21pc2UgPSBnZXROYXRpdmUocm9vdCwgJ1Byb21pc2UnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9taXNlO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBTZXQgPSBnZXROYXRpdmUocm9vdCwgJ1NldCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNldDtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgV2Vha01hcCA9IGdldE5hdGl2ZShyb290LCAnV2Vha01hcCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYWtNYXA7XG4iLCJ2YXIgRGF0YVZpZXcgPSByZXF1aXJlKCcuL19EYXRhVmlldycpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpLFxuICAgIFByb21pc2UgPSByZXF1aXJlKCcuL19Qcm9taXNlJyksXG4gICAgU2V0ID0gcmVxdWlyZSgnLi9fU2V0JyksXG4gICAgV2Vha01hcCA9IHJlcXVpcmUoJy4vX1dlYWtNYXAnKSxcbiAgICBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIHRvU291cmNlID0gcmVxdWlyZSgnLi9fdG9Tb3VyY2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHByb21pc2VUYWcgPSAnW29iamVjdCBQcm9taXNlXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1hcHMsIHNldHMsIGFuZCB3ZWFrbWFwcy4gKi9cbnZhciBkYXRhVmlld0N0b3JTdHJpbmcgPSB0b1NvdXJjZShEYXRhVmlldyksXG4gICAgbWFwQ3RvclN0cmluZyA9IHRvU291cmNlKE1hcCksXG4gICAgcHJvbWlzZUN0b3JTdHJpbmcgPSB0b1NvdXJjZShQcm9taXNlKSxcbiAgICBzZXRDdG9yU3RyaW5nID0gdG9Tb3VyY2UoU2V0KSxcbiAgICB3ZWFrTWFwQ3RvclN0cmluZyA9IHRvU291cmNlKFdlYWtNYXApO1xuXG4vKipcbiAqIEdldHMgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG52YXIgZ2V0VGFnID0gYmFzZUdldFRhZztcblxuLy8gRmFsbGJhY2sgZm9yIGRhdGEgdmlld3MsIG1hcHMsIHNldHMsIGFuZCB3ZWFrIG1hcHMgaW4gSUUgMTEgYW5kIHByb21pc2VzIGluIE5vZGUuanMgPCA2LlxuaWYgKChEYXRhVmlldyAmJiBnZXRUYWcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSkpICE9IGRhdGFWaWV3VGFnKSB8fFxuICAgIChNYXAgJiYgZ2V0VGFnKG5ldyBNYXApICE9IG1hcFRhZykgfHxcbiAgICAoUHJvbWlzZSAmJiBnZXRUYWcoUHJvbWlzZS5yZXNvbHZlKCkpICE9IHByb21pc2VUYWcpIHx8XG4gICAgKFNldCAmJiBnZXRUYWcobmV3IFNldCkgIT0gc2V0VGFnKSB8fFxuICAgIChXZWFrTWFwICYmIGdldFRhZyhuZXcgV2Vha01hcCkgIT0gd2Vha01hcFRhZykpIHtcbiAgZ2V0VGFnID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gYmFzZUdldFRhZyh2YWx1ZSksXG4gICAgICAgIEN0b3IgPSByZXN1bHQgPT0gb2JqZWN0VGFnID8gdmFsdWUuY29uc3RydWN0b3IgOiB1bmRlZmluZWQsXG4gICAgICAgIGN0b3JTdHJpbmcgPSBDdG9yID8gdG9Tb3VyY2UoQ3RvcikgOiAnJztcblxuICAgIGlmIChjdG9yU3RyaW5nKSB7XG4gICAgICBzd2l0Y2ggKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgY2FzZSBkYXRhVmlld0N0b3JTdHJpbmc6IHJldHVybiBkYXRhVmlld1RhZztcbiAgICAgICAgY2FzZSBtYXBDdG9yU3RyaW5nOiByZXR1cm4gbWFwVGFnO1xuICAgICAgICBjYXNlIHByb21pc2VDdG9yU3RyaW5nOiByZXR1cm4gcHJvbWlzZVRhZztcbiAgICAgICAgY2FzZSBzZXRDdG9yU3RyaW5nOiByZXR1cm4gc2V0VGFnO1xuICAgICAgICBjYXNlIHdlYWtNYXBDdG9yU3RyaW5nOiByZXR1cm4gd2Vha01hcFRhZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRUYWc7XG4iLCJ2YXIgU3RhY2sgPSByZXF1aXJlKCcuL19TdGFjaycpLFxuICAgIGVxdWFsQXJyYXlzID0gcmVxdWlyZSgnLi9fZXF1YWxBcnJheXMnKSxcbiAgICBlcXVhbEJ5VGFnID0gcmVxdWlyZSgnLi9fZXF1YWxCeVRhZycpLFxuICAgIGVxdWFsT2JqZWN0cyA9IHJlcXVpcmUoJy4vX2VxdWFsT2JqZWN0cycpLFxuICAgIGdldFRhZyA9IHJlcXVpcmUoJy4vX2dldFRhZycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJy4vaXNCdWZmZXInKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzVHlwZWRBcnJheScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDE7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAqIGRlZXAgY29tcGFyaXNvbnMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAqIHJlZmVyZW5jZXMgdG8gYmUgY29tcGFyZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsRGVlcChvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBvYmpJc0FyciA9IGlzQXJyYXkob2JqZWN0KSxcbiAgICAgIG90aElzQXJyID0gaXNBcnJheShvdGhlciksXG4gICAgICBvYmpUYWcgPSBvYmpJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG9iamVjdCksXG4gICAgICBvdGhUYWcgPSBvdGhJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG90aGVyKTtcblxuICBvYmpUYWcgPSBvYmpUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG9ialRhZztcbiAgb3RoVGFnID0gb3RoVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvdGhUYWc7XG5cbiAgdmFyIG9iaklzT2JqID0gb2JqVGFnID09IG9iamVjdFRhZyxcbiAgICAgIG90aElzT2JqID0gb3RoVGFnID09IG9iamVjdFRhZyxcbiAgICAgIGlzU2FtZVRhZyA9IG9ialRhZyA9PSBvdGhUYWc7XG5cbiAgaWYgKGlzU2FtZVRhZyAmJiBpc0J1ZmZlcihvYmplY3QpKSB7XG4gICAgaWYgKCFpc0J1ZmZlcihvdGhlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgb2JqSXNBcnIgPSB0cnVlO1xuICAgIG9iaklzT2JqID0gZmFsc2U7XG4gIH1cbiAgaWYgKGlzU2FtZVRhZyAmJiAhb2JqSXNPYmopIHtcbiAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgIHJldHVybiAob2JqSXNBcnIgfHwgaXNUeXBlZEFycmF5KG9iamVjdCkpXG4gICAgICA/IGVxdWFsQXJyYXlzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spXG4gICAgICA6IGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgb2JqVGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgfVxuICBpZiAoIShiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcpKSB7XG4gICAgdmFyIG9iaklzV3JhcHBlZCA9IG9iaklzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCAnX193cmFwcGVkX18nKSxcbiAgICAgICAgb3RoSXNXcmFwcGVkID0gb3RoSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwgJ19fd3JhcHBlZF9fJyk7XG5cbiAgICBpZiAob2JqSXNXcmFwcGVkIHx8IG90aElzV3JhcHBlZCkge1xuICAgICAgdmFyIG9ialVud3JhcHBlZCA9IG9iaklzV3JhcHBlZCA/IG9iamVjdC52YWx1ZSgpIDogb2JqZWN0LFxuICAgICAgICAgIG90aFVud3JhcHBlZCA9IG90aElzV3JhcHBlZCA/IG90aGVyLnZhbHVlKCkgOiBvdGhlcjtcblxuICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgIHJldHVybiBlcXVhbEZ1bmMob2JqVW53cmFwcGVkLCBvdGhVbndyYXBwZWQsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFpc1NhbWVUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgcmV0dXJuIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNFcXVhbERlZXA7XG4iLCJ2YXIgYmFzZUlzRXF1YWxEZWVwID0gcmVxdWlyZSgnLi9fYmFzZUlzRXF1YWxEZWVwJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0VxdWFsYCB3aGljaCBzdXBwb3J0cyBwYXJ0aWFsIGNvbXBhcmlzb25zXG4gKiBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAqICAxIC0gVW5vcmRlcmVkIGNvbXBhcmlzb25cbiAqICAyIC0gUGFydGlhbCBjb21wYXJpc29uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykge1xuICBpZiAodmFsdWUgPT09IG90aGVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgfHwgb3RoZXIgPT0gbnVsbCB8fCAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgIWlzT2JqZWN0TGlrZShvdGhlcikpKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG4gIH1cbiAgcmV0dXJuIGJhc2VJc0VxdWFsRGVlcCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGJhc2VJc0VxdWFsLCBzdGFjayk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzRXF1YWw7XG4iLCJ2YXIgU3RhY2sgPSByZXF1aXJlKCcuL19TdGFjaycpLFxuICAgIGJhc2VJc0VxdWFsID0gcmVxdWlyZSgnLi9fYmFzZUlzRXF1YWwnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWF0Y2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtBcnJheX0gbWF0Y2hEYXRhIFRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSwgY3VzdG9taXplcikge1xuICB2YXIgaW5kZXggPSBtYXRjaERhdGEubGVuZ3RoLFxuICAgICAgbGVuZ3RoID0gaW5kZXgsXG4gICAgICBub0N1c3RvbWl6ZXIgPSAhY3VzdG9taXplcjtcblxuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gIWxlbmd0aDtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgaWYgKChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSlcbiAgICAgICAgICA/IGRhdGFbMV0gIT09IG9iamVjdFtkYXRhWzBdXVxuICAgICAgICAgIDogIShkYXRhWzBdIGluIG9iamVjdClcbiAgICAgICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgdmFyIGtleSA9IGRhdGFbMF0sXG4gICAgICAgIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIHNyY1ZhbHVlID0gZGF0YVsxXTtcblxuICAgIGlmIChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSkge1xuICAgICAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzdGFjayA9IG5ldyBTdGFjaztcbiAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spO1xuICAgICAgfVxuICAgICAgaWYgKCEocmVzdWx0ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcsIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICAgICAgOiByZXN1bHRcbiAgICAgICAgICApKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzTWF0Y2g7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpZiBzdWl0YWJsZSBmb3Igc3RyaWN0XG4gKiAgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgJiYgIWlzT2JqZWN0KHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1N0cmljdENvbXBhcmFibGU7XG4iLCJ2YXIgaXNTdHJpY3RDb21wYXJhYmxlID0gcmVxdWlyZSgnLi9faXNTdHJpY3RDb21wYXJhYmxlJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIEdldHMgdGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG1hdGNoIGRhdGEgb2YgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGdldE1hdGNoRGF0YShvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXMob2JqZWN0KSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgdmFyIGtleSA9IHJlc3VsdFtsZW5ndGhdLFxuICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgcmVzdWx0W2xlbmd0aF0gPSBba2V5LCB2YWx1ZSwgaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKV07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRNYXRjaERhdGE7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgbWF0Y2hlc1Byb3BlcnR5YCBmb3Igc291cmNlIHZhbHVlcyBzdWl0YWJsZVxuICogZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKGtleSwgc3JjVmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0W2tleV0gPT09IHNyY1ZhbHVlICYmXG4gICAgICAoc3JjVmFsdWUgIT09IHVuZGVmaW5lZCB8fCAoa2V5IGluIE9iamVjdChvYmplY3QpKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWF0Y2hlc1N0cmljdENvbXBhcmFibGU7XG4iLCJ2YXIgYmFzZUlzTWF0Y2ggPSByZXF1aXJlKCcuL19iYXNlSXNNYXRjaCcpLFxuICAgIGdldE1hdGNoRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hdGNoRGF0YScpLFxuICAgIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlID0gcmVxdWlyZSgnLi9fbWF0Y2hlc1N0cmljdENvbXBhcmFibGUnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzYCB3aGljaCBkb2Vzbid0IGNsb25lIGBzb3VyY2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hdGNoZXMoc291cmNlKSB7XG4gIHZhciBtYXRjaERhdGEgPSBnZXRNYXRjaERhdGEoc291cmNlKTtcbiAgaWYgKG1hdGNoRGF0YS5sZW5ndGggPT0gMSAmJiBtYXRjaERhdGFbMF1bMl0pIHtcbiAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUobWF0Y2hEYXRhWzBdWzBdLCBtYXRjaERhdGFbMF1bMV0pO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09PSBzb3VyY2UgfHwgYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1hdGNoZXM7XG4iLCJ2YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVJc0RlZXBQcm9wID0gL1xcLnxcXFsoPzpbXltcXF1dKnwoW1wiJ10pKD86KD8hXFwxKVteXFxcXF18XFxcXC4pKj9cXDEpXFxdLyxcbiAgICByZUlzUGxhaW5Qcm9wID0gL15cXHcqJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lIGFuZCBub3QgYSBwcm9wZXJ0eSBwYXRoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXkodmFsdWUsIG9iamVjdCkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGlmICh0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicgfHxcbiAgICAgIHZhbHVlID09IG51bGwgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIHJlSXNQbGFpblByb3AudGVzdCh2YWx1ZSkgfHwgIXJlSXNEZWVwUHJvcC50ZXN0KHZhbHVlKSB8fFxuICAgIChvYmplY3QgIT0gbnVsbCAmJiB2YWx1ZSBpbiBPYmplY3Qob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNLZXk7XG4iLCJ2YXIgTWFwQ2FjaGUgPSByZXF1aXJlKCcuL19NYXBDYWNoZScpO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gKiBwcm92aWRlZCwgaXQgZGV0ZXJtaW5lcyB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHQgYmFzZWQgb24gdGhlXG4gKiBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgYXJndW1lbnRcbiAqIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBtYXAgY2FjaGUga2V5LiBUaGUgYGZ1bmNgXG4gKiBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXG4gKiBmdW5jdGlvbi4gSXRzIGNyZWF0aW9uIG1heSBiZSBjdXN0b21pemVkIGJ5IHJlcGxhY2luZyB0aGUgYF8ubWVtb2l6ZS5DYWNoZWBcbiAqIGNvbnN0cnVjdG9yIHdpdGggb25lIHdob3NlIGluc3RhbmNlcyBpbXBsZW1lbnQgdGhlXG4gKiBbYE1hcGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLW1hcC1wcm90b3R5cGUtb2JqZWN0KVxuICogbWV0aG9kIGludGVyZmFjZSBvZiBgY2xlYXJgLCBgZGVsZXRlYCwgYGdldGAsIGBoYXNgLCBhbmQgYHNldGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2MnOiAzLCAnZCc6IDQgfTtcbiAqXG4gKiB2YXIgdmFsdWVzID0gXy5tZW1vaXplKF8udmFsdWVzKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogdmFsdWVzKG90aGVyKTtcbiAqIC8vID0+IFszLCA0XVxuICpcbiAqIG9iamVjdC5hID0gMjtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogLy8gTW9kaWZ5IHRoZSByZXN1bHQgY2FjaGUuXG4gKiB2YWx1ZXMuY2FjaGUuc2V0KG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsnYScsICdiJ11cbiAqXG4gKiAvLyBSZXBsYWNlIGBfLm1lbW9pemUuQ2FjaGVgLlxuICogXy5tZW1vaXplLkNhY2hlID0gV2Vha01hcDtcbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJyB8fCAocmVzb2x2ZXIgIT0gbnVsbCAmJiB0eXBlb2YgcmVzb2x2ZXIgIT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuICAgICAgICBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuXG4gICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KSB8fCBjYWNoZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBtZW1vaXplZC5jYWNoZSA9IG5ldyAobWVtb2l6ZS5DYWNoZSB8fCBNYXBDYWNoZSk7XG4gIHJldHVybiBtZW1vaXplZDtcbn1cblxuLy8gRXhwb3NlIGBNYXBDYWNoZWAuXG5tZW1vaXplLkNhY2hlID0gTWFwQ2FjaGU7XG5cbm1vZHVsZS5leHBvcnRzID0gbWVtb2l6ZTtcbiIsInZhciBtZW1vaXplID0gcmVxdWlyZSgnLi9tZW1vaXplJyk7XG5cbi8qKiBVc2VkIGFzIHRoZSBtYXhpbXVtIG1lbW9pemUgY2FjaGUgc2l6ZS4gKi9cbnZhciBNQVhfTUVNT0laRV9TSVpFID0gNTAwO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tZW1vaXplYCB3aGljaCBjbGVhcnMgdGhlIG1lbW9pemVkIGZ1bmN0aW9uJ3NcbiAqIGNhY2hlIHdoZW4gaXQgZXhjZWVkcyBgTUFYX01FTU9JWkVfU0laRWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtZW1vaXplQ2FwcGVkKGZ1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IG1lbW9pemUoZnVuYywgZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKGNhY2hlLnNpemUgPT09IE1BWF9NRU1PSVpFX1NJWkUpIHtcbiAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgfVxuICAgIHJldHVybiBrZXk7XG4gIH0pO1xuXG4gIHZhciBjYWNoZSA9IHJlc3VsdC5jYWNoZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplQ2FwcGVkO1xuIiwidmFyIG1lbW9pemVDYXBwZWQgPSByZXF1aXJlKCcuL19tZW1vaXplQ2FwcGVkJyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZVByb3BOYW1lID0gL1teLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCQpKS9nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG52YXIgc3RyaW5nVG9QYXRoID0gbWVtb2l6ZUNhcHBlZChmdW5jdGlvbihzdHJpbmcpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAoc3RyaW5nLmNoYXJDb2RlQXQoMCkgPT09IDQ2IC8qIC4gKi8pIHtcbiAgICByZXN1bHQucHVzaCgnJyk7XG4gIH1cbiAgc3RyaW5nLnJlcGxhY2UocmVQcm9wTmFtZSwgZnVuY3Rpb24obWF0Y2gsIG51bWJlciwgcXVvdGUsIHN1YlN0cmluZykge1xuICAgIHJlc3VsdC5wdXNoKHF1b3RlID8gc3ViU3RyaW5nLnJlcGxhY2UocmVFc2NhcGVDaGFyLCAnJDEnKSA6IChudW1iZXIgfHwgbWF0Y2gpKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpbmdUb1BhdGg7XG4iLCJ2YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzS2V5ID0gcmVxdWlyZSgnLi9faXNLZXknKSxcbiAgICBzdHJpbmdUb1BhdGggPSByZXF1aXJlKCcuL19zdHJpbmdUb1BhdGgnKSxcbiAgICB0b1N0cmluZyA9IHJlcXVpcmUoJy4vdG9TdHJpbmcnKTtcblxuLyoqXG4gKiBDYXN0cyBgdmFsdWVgIHRvIGEgcGF0aCBhcnJheSBpZiBpdCdzIG5vdCBvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNhc3RQYXRoKHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiBpc0tleSh2YWx1ZSwgb2JqZWN0KSA/IFt2YWx1ZV0gOiBzdHJpbmdUb1BhdGgodG9TdHJpbmcodmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYXN0UGF0aDtcbiIsInZhciBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIGtleSBpZiBpdCdzIG5vdCBhIHN0cmluZyBvciBzeW1ib2wuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7c3RyaW5nfHN5bWJvbH0gUmV0dXJucyB0aGUga2V5LlxuICovXG5mdW5jdGlvbiB0b0tleSh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9LZXk7XG4iLCJ2YXIgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5nZXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVmYXVsdCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXQob2JqZWN0LCBwYXRoKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IDAsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICB3aGlsZSAob2JqZWN0ICE9IG51bGwgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICBvYmplY3QgPSBvYmplY3RbdG9LZXkocGF0aFtpbmRleCsrXSldO1xuICB9XG4gIHJldHVybiAoaW5kZXggJiYgaW5kZXggPT0gbGVuZ3RoKSA/IG9iamVjdCA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0O1xuIiwidmFyIGJhc2VHZXQgPSByZXF1aXJlKCcuL19iYXNlR2V0Jyk7XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXNcbiAqIGB1bmRlZmluZWRgLCB0aGUgYGRlZmF1bHRWYWx1ZWAgaXMgcmV0dXJuZWQgaW4gaXRzIHBsYWNlLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy43LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSByZXR1cm5lZCBmb3IgYHVuZGVmaW5lZGAgcmVzb2x2ZWQgdmFsdWVzLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2FbMF0uYi5jJyk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCBbJ2EnLCAnMCcsICdiJywgJ2MnXSk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCAnYS5iLmMnLCAnZGVmYXVsdCcpO1xuICogLy8gPT4gJ2RlZmF1bHQnXG4gKi9cbmZ1bmN0aW9uIGdldChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXQ7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc0luYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IGtleSBUaGUga2V5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSGFzSW4ob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGtleSBpbiBPYmplY3Qob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSGFzSW47XG4iLCJ2YXIgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGV4aXN0cyBvbiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYXNGdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjayBwcm9wZXJ0aWVzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzUGF0aChvYmplY3QsIHBhdGgsIGhhc0Z1bmMpIHtcbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKTtcbiAgICBpZiAoIShyZXN1bHQgPSBvYmplY3QgIT0gbnVsbCAmJiBoYXNGdW5jKG9iamVjdCwga2V5KSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBvYmplY3QgPSBvYmplY3Rba2V5XTtcbiAgfVxuICBpZiAocmVzdWx0IHx8ICsraW5kZXggIT0gbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBsZW5ndGggPSBvYmplY3QgPT0gbnVsbCA/IDAgOiBvYmplY3QubGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJiBpc0luZGV4KGtleSwgbGVuZ3RoKSAmJlxuICAgIChpc0FycmF5KG9iamVjdCkgfHwgaXNBcmd1bWVudHMob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzUGF0aDtcbiIsInZhciBiYXNlSGFzSW4gPSByZXF1aXJlKCcuL19iYXNlSGFzSW4nKSxcbiAgICBoYXNQYXRoID0gcmVxdWlyZSgnLi9faGFzUGF0aCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgaXMgYSBkaXJlY3Qgb3IgaW5oZXJpdGVkIHByb3BlcnR5IG9mIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IF8uY3JlYXRlKHsgJ2EnOiBfLmNyZWF0ZSh7ICdiJzogMiB9KSB9KTtcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EuYicpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2InKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGhhc0luKG9iamVjdCwgcGF0aCkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzUGF0aChvYmplY3QsIHBhdGgsIGJhc2VIYXNJbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzSW47XG4iLCJ2YXIgYmFzZUlzRXF1YWwgPSByZXF1aXJlKCcuL19iYXNlSXNFcXVhbCcpLFxuICAgIGdldCA9IHJlcXVpcmUoJy4vZ2V0JyksXG4gICAgaGFzSW4gPSByZXF1aXJlKCcuL2hhc0luJyksXG4gICAgaXNLZXkgPSByZXF1aXJlKCcuL19pc0tleScpLFxuICAgIGlzU3RyaWN0Q29tcGFyYWJsZSA9IHJlcXVpcmUoJy4vX2lzU3RyaWN0Q29tcGFyYWJsZScpLFxuICAgIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlID0gcmVxdWlyZSgnLi9fbWF0Y2hlc1N0cmljdENvbXBhcmFibGUnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzUHJvcGVydHlgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNyY1ZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuICBpZiAoaXNLZXkocGF0aCkgJiYgaXNTdHJpY3RDb21wYXJhYmxlKHNyY1ZhbHVlKSkge1xuICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSh0b0tleShwYXRoKSwgc3JjVmFsdWUpO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIgb2JqVmFsdWUgPSBnZXQob2JqZWN0LCBwYXRoKTtcbiAgICByZXR1cm4gKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgb2JqVmFsdWUgPT09IHNyY1ZhbHVlKVxuICAgICAgPyBoYXNJbihvYmplY3QsIHBhdGgpXG4gICAgICA6IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlTWF0Y2hlc1Byb3BlcnR5O1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eWAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHkoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUHJvcGVydHk7XG4iLCJ2YXIgYmFzZUdldCA9IHJlcXVpcmUoJy4vX2Jhc2VHZXQnKTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VQcm9wZXJ0eWAgd2hpY2ggc3VwcG9ydHMgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVByb3BlcnR5RGVlcDtcbiIsInZhciBiYXNlUHJvcGVydHkgPSByZXF1aXJlKCcuL19iYXNlUHJvcGVydHknKSxcbiAgICBiYXNlUHJvcGVydHlEZWVwID0gcmVxdWlyZSgnLi9fYmFzZVByb3BlcnR5RGVlcCcpLFxuICAgIGlzS2V5ID0gcmVxdWlyZSgnLi9faXNLZXknKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGEgZ2l2ZW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gW1xuICogICB7ICdhJzogeyAnYic6IDIgfSB9LFxuICogICB7ICdhJzogeyAnYic6IDEgfSB9XG4gKiBdO1xuICpcbiAqIF8ubWFwKG9iamVjdHMsIF8ucHJvcGVydHkoJ2EuYicpKTtcbiAqIC8vID0+IFsyLCAxXVxuICpcbiAqIF8ubWFwKF8uc29ydEJ5KG9iamVjdHMsIF8ucHJvcGVydHkoWydhJywgJ2InXSkpLCAnYS5iJyk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqL1xuZnVuY3Rpb24gcHJvcGVydHkocGF0aCkge1xuICByZXR1cm4gaXNLZXkocGF0aCkgPyBiYXNlUHJvcGVydHkodG9LZXkocGF0aCkpIDogYmFzZVByb3BlcnR5RGVlcChwYXRoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwcm9wZXJ0eTtcbiIsInZhciBiYXNlTWF0Y2hlcyA9IHJlcXVpcmUoJy4vX2Jhc2VNYXRjaGVzJyksXG4gICAgYmFzZU1hdGNoZXNQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2Jhc2VNYXRjaGVzUHJvcGVydHknKSxcbiAgICBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgcHJvcGVydHkgPSByZXF1aXJlKCcuL3Byb3BlcnR5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXRlcmF0ZWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IFt2YWx1ZT1fLmlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhbiBpdGVyYXRlZS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgaXRlcmF0ZWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJdGVyYXRlZSh2YWx1ZSkge1xuICAvLyBEb24ndCBzdG9yZSB0aGUgYHR5cGVvZmAgcmVzdWx0IGluIGEgdmFyaWFibGUgdG8gYXZvaWQgYSBKSVQgYnVnIGluIFNhZmFyaSA5LlxuICAvLyBTZWUgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE1NjAzNCBmb3IgbW9yZSBkZXRhaWxzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gaWRlbnRpdHk7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBpc0FycmF5KHZhbHVlKVxuICAgICAgPyBiYXNlTWF0Y2hlc1Byb3BlcnR5KHZhbHVlWzBdLCB2YWx1ZVsxXSlcbiAgICAgIDogYmFzZU1hdGNoZXModmFsdWUpO1xuICB9XG4gIHJldHVybiBwcm9wZXJ0eSh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUl0ZXJhdGVlO1xuIiwidmFyIGJhc2VBc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25WYWx1ZScpLFxuICAgIGJhc2VGb3JPd24gPSByZXF1aXJlKCcuL19iYXNlRm9yT3duJyksXG4gICAgYmFzZUl0ZXJhdGVlID0gcmVxdWlyZSgnLi9fYmFzZUl0ZXJhdGVlJyk7XG5cbi8qKlxuICogVGhlIG9wcG9zaXRlIG9mIGBfLm1hcFZhbHVlc2A7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYW4gb2JqZWN0IHdpdGggdGhlXG4gKiBzYW1lIHZhbHVlcyBhcyBgb2JqZWN0YCBhbmQga2V5cyBnZW5lcmF0ZWQgYnkgcnVubmluZyBlYWNoIG93biBlbnVtZXJhYmxlXG4gKiBzdHJpbmcga2V5ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAgdGhydSBgaXRlcmF0ZWVgLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZFxuICogd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwga2V5LCBvYmplY3QpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy44LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgb2JqZWN0LlxuICogQHNlZSBfLm1hcFZhbHVlc1xuICogQGV4YW1wbGVcbiAqXG4gKiBfLm1hcEtleXMoeyAnYSc6IDEsICdiJzogMiB9LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gKiAgIHJldHVybiBrZXkgKyB2YWx1ZTtcbiAqIH0pO1xuICogLy8gPT4geyAnYTEnOiAxLCAnYjInOiAyIH1cbiAqL1xuZnVuY3Rpb24gbWFwS2V5cyhvYmplY3QsIGl0ZXJhdGVlKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgaXRlcmF0ZWUgPSBiYXNlSXRlcmF0ZWUoaXRlcmF0ZWUsIDMpO1xuXG4gIGJhc2VGb3JPd24ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICBiYXNlQXNzaWduVmFsdWUocmVzdWx0LCBpdGVyYXRlZSh2YWx1ZSwga2V5LCBvYmplY3QpLCB2YWx1ZSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcEtleXM7XG4iLCJpbXBvcnQgeyBtYXBLZXlzIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IGlzT2JqZWN0IH0gZnJvbSAnbG9kYXNoJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcHJlZml4KHN1YmplY3QsIHByZWZpeCwgZGVsaW1ldGVyID0gJy0nKSB7XG4gICAgY29uc3QgcHJlZml4ZXIgPSAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICBjb25zdCBzdHJpbmcgPSBrZXkgfHwgdmFsdWU7XG5cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHByZWZpeCxcbiAgICAgICAgICAgIHN0cmluZy5yZXBsYWNlKG5ldyBSZWdFeHAoYF4ke3ByZWZpeH0ke2RlbGltZXRlcn0/YCksICcnKVxuICAgICAgICBdLmpvaW4oZGVsaW1ldGVyKTtcbiAgICB9XG5cbiAgICBpZihpc09iamVjdChzdWJqZWN0KSkge1xuICAgICAgICByZXR1cm4gbWFwS2V5cyhzdWJqZWN0LCBwcmVmaXhlcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByZWZpeGVyKHN1YmplY3QpO1xufVxuIiwiaW1wb3J0IHByZWZpeCBmcm9tICdAL0hlbHBlcnMvUHJlZml4L1ByZWZpeCc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB2YXJpYW50IGF0dHJpYnV0ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICB2YXJpYW50OiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAncHJpbWFyeSdcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBjb21wdXRlZDoge1xuXG4gICAgICAgIHZhcmlhbnRDbGFzcygpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmVmaXgodGhpcy52YXJpYW50LCB0aGlzLiRvcHRpb25zLm5hbWUpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbn1cbiIsIjx0ZW1wbGF0ZT5cbiAgICA8YSB2LWlmPVwiaHJlZlwiIDpocmVmPVwiaHJlZlwiIGNsYXNzPVwiYmFkZ2VcIiA6Y2xhc3M9XCJtZXJnZUNsYXNzZXMoY2xhc3NlcywgdmFyaWFudENsYXNzKVwiPlxuICAgICAgICA8c2xvdD57e2xhYmVsfX08L3Nsb3Q+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwic3Itb25seVwiIHYtaHRtbD1cImFjY2Vzc2liaWxpdHlcIi8+XG4gICAgPC9hPlxuICAgIDxzcGFuIHYtZWxzZSBjbGFzcz1cImJhZGdlXCIgOmNsYXNzPVwibWVyZ2VDbGFzc2VzKGNsYXNzZXMsIHZhcmlhbnRDbGFzcylcIj5cbiAgICAgICAgPHNsb3Q+e3tsYWJlbH19PC9zbG90PlxuICAgICAgICA8c3BhbiBjbGFzcz1cInNyLW9ubHlcIiB2LWh0bWw9XCJhY2Nlc3NpYmlsaXR5XCIvPlxuICAgIDwvc3Bhbj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5cbmltcG9ydCBwcmVmaXggZnJvbSAnQC9IZWxwZXJzL1ByZWZpeC9QcmVmaXgnO1xuaW1wb3J0IFZhcmlhbnQgZnJvbSAnQC9NaXhpbnMvVmFyaWFudC9WYXJpYW50JztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ2JhZGdlJyxcblxuICAgIG1peGluczogW1xuICAgICAgICBWYXJpYW50XG4gICAgXSxcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzY3JlZW4gcmVhZGVyIGFjY2Vzc2liaWxpdHkgbGFiZWwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGFjY2Vzc2liaWxpdHk6IFN0cmluZyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgYW4gaHJlZiBhdHRyaWJ1dGUgaXMgcGFzc2VkLCB0aGUgYmFkZ2UgYmVjb21lcyBhbiBhbmNob3IuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGhyZWY6IFN0cmluZyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGJhZGdlIGFwcGVhciBhcyBwaWxsIHNoYXBlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgcGlsbDogQm9vbGVhbixcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGJhZGdlIGxhYmVsLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBsYWJlbDogW051bWJlciwgU3RyaW5nXSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGJhZGdlIGFwcGVhciBhcyBzZWNvbmRhcnkgaW4gc2l6ZSB0byB0aGUgcGFyZW50IGVsZW1lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHNlY29uZGFyeTogQm9vbGVhblxuXG4gICAgfSxcblxuICAgIGNvbXB1dGVkOiB7XG5cbiAgICAgICAgY2xhc3NlcygpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmVmaXgoe1xuICAgICAgICAgICAgICAgICdwaWxsJzogdGhpcy5waWxsLFxuICAgICAgICAgICAgICAgICdzZWNvbmRhcnknOiB0aGlzLnNlY29uZGFyeVxuICAgICAgICAgICAgfSwgdGhpcy4kb3B0aW9ucy5uYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgQmFkZ2UgZnJvbSAnLi9CYWRnZSc7XG5pbXBvcnQgVnVlSW5zdGFsbGVyIGZyb20gJ0AvSGVscGVycy9WdWVJbnN0YWxsZXIvVnVlSW5zdGFsbGVyJztcblxuY29uc3QgcGx1Z2luID0gVnVlSW5zdGFsbGVyLnVzZSh7XG5cbiAgICBpbnN0YWxsKFZ1ZSwgb3B0aW9ucykge1xuICAgICAgICBWdWVJbnN0YWxsZXIuY29tcG9uZW50cyh7XG4gICAgICAgICAgICBCYWRnZVxuICAgICAgICB9KTtcbiAgICB9XG5cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBCYWRnZTtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYHVuZGVmaW5lZGAuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYHVuZGVmaW5lZGAsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1VuZGVmaW5lZCh2b2lkIDApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNVbmRlZmluZWQobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1VuZGVmaW5lZDtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVkdWNlYCBhbmQgYF8ucmVkdWNlUmlnaHRgLCB3aXRob3V0IHN1cHBvcnRcbiAqIGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLCB3aGljaCBpdGVyYXRlcyBvdmVyIGBjb2xsZWN0aW9uYCB1c2luZyBgZWFjaEZ1bmNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHsqfSBhY2N1bXVsYXRvciBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5pdEFjY3VtIFNwZWNpZnkgdXNpbmcgdGhlIGZpcnN0IG9yIGxhc3QgZWxlbWVudCBvZlxuICogIGBjb2xsZWN0aW9uYCBhcyB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYGNvbGxlY3Rpb25gLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiYXNlUmVkdWNlKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtLCBlYWNoRnVuYykge1xuICBlYWNoRnVuYyhjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICBhY2N1bXVsYXRvciA9IGluaXRBY2N1bVxuICAgICAgPyAoaW5pdEFjY3VtID0gZmFsc2UsIHZhbHVlKVxuICAgICAgOiBpdGVyYXRlZShhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgfSk7XG4gIHJldHVybiBhY2N1bXVsYXRvcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUmVkdWNlO1xuIiwidmFyIGFycmF5UmVkdWNlID0gcmVxdWlyZSgnLi9fYXJyYXlSZWR1Y2UnKSxcbiAgICBiYXNlRWFjaCA9IHJlcXVpcmUoJy4vX2Jhc2VFYWNoJyksXG4gICAgYmFzZUl0ZXJhdGVlID0gcmVxdWlyZSgnLi9fYmFzZUl0ZXJhdGVlJyksXG4gICAgYmFzZVJlZHVjZSA9IHJlcXVpcmUoJy4vX2Jhc2VSZWR1Y2UnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5Jyk7XG5cbi8qKlxuICogUmVkdWNlcyBgY29sbGVjdGlvbmAgdG8gYSB2YWx1ZSB3aGljaCBpcyB0aGUgYWNjdW11bGF0ZWQgcmVzdWx0IG9mIHJ1bm5pbmdcbiAqIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAgdGhydSBgaXRlcmF0ZWVgLCB3aGVyZSBlYWNoIHN1Y2Nlc3NpdmVcbiAqIGludm9jYXRpb24gaXMgc3VwcGxpZWQgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgcHJldmlvdXMuIElmIGBhY2N1bXVsYXRvcmBcbiAqIGlzIG5vdCBnaXZlbiwgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gIGlzIHVzZWQgYXMgdGhlIGluaXRpYWxcbiAqIHZhbHVlLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIGZvdXIgYXJndW1lbnRzOlxuICogKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAqXG4gKiBNYW55IGxvZGFzaCBtZXRob2RzIGFyZSBndWFyZGVkIHRvIHdvcmsgYXMgaXRlcmF0ZWVzIGZvciBtZXRob2RzIGxpa2VcbiAqIGBfLnJlZHVjZWAsIGBfLnJlZHVjZVJpZ2h0YCwgYW5kIGBfLnRyYW5zZm9ybWAuXG4gKlxuICogVGhlIGd1YXJkZWQgbWV0aG9kcyBhcmU6XG4gKiBgYXNzaWduYCwgYGRlZmF1bHRzYCwgYGRlZmF1bHRzRGVlcGAsIGBpbmNsdWRlc2AsIGBtZXJnZWAsIGBvcmRlckJ5YCxcbiAqIGFuZCBgc29ydEJ5YFxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAqIEBzZWUgXy5yZWR1Y2VSaWdodFxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnJlZHVjZShbMSwgMl0sIGZ1bmN0aW9uKHN1bSwgbikge1xuICogICByZXR1cm4gc3VtICsgbjtcbiAqIH0sIDApO1xuICogLy8gPT4gM1xuICpcbiAqIF8ucmVkdWNlKHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMSB9LCBmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAqICAgKHJlc3VsdFt2YWx1ZV0gfHwgKHJlc3VsdFt2YWx1ZV0gPSBbXSkpLnB1c2goa2V5KTtcbiAqICAgcmV0dXJuIHJlc3VsdDtcbiAqIH0sIHt9KTtcbiAqIC8vID0+IHsgJzEnOiBbJ2EnLCAnYyddLCAnMic6IFsnYiddIH0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqL1xuZnVuY3Rpb24gcmVkdWNlKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVJlZHVjZSA6IGJhc2VSZWR1Y2UsXG4gICAgICBpbml0QWNjdW0gPSBhcmd1bWVudHMubGVuZ3RoIDwgMztcblxuICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBiYXNlSXRlcmF0ZWUoaXRlcmF0ZWUsIDQpLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtLCBiYXNlRWFjaCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVkdWNlO1xuIiwidmFyIGFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYXNzaWduVmFsdWUnKSxcbiAgICBjYXN0UGF0aCA9IHJlcXVpcmUoJy4vX2Nhc3RQYXRoJyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2V0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBwYXRoIGNyZWF0aW9uLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZVNldChvYmplY3QsIHBhdGgsIHZhbHVlLCBjdXN0b21pemVyKSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBvYmplY3Q7XG4gIH1cbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgIGxhc3RJbmRleCA9IGxlbmd0aCAtIDEsXG4gICAgICBuZXN0ZWQgPSBvYmplY3Q7XG5cbiAgd2hpbGUgKG5lc3RlZCAhPSBudWxsICYmICsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gdG9LZXkocGF0aFtpbmRleF0pLFxuICAgICAgICBuZXdWYWx1ZSA9IHZhbHVlO1xuXG4gICAgaWYgKGluZGV4ICE9IGxhc3RJbmRleCkge1xuICAgICAgdmFyIG9ialZhbHVlID0gbmVzdGVkW2tleV07XG4gICAgICBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXIgPyBjdXN0b21pemVyKG9ialZhbHVlLCBrZXksIG5lc3RlZCkgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuZXdWYWx1ZSA9IGlzT2JqZWN0KG9ialZhbHVlKVxuICAgICAgICAgID8gb2JqVmFsdWVcbiAgICAgICAgICA6IChpc0luZGV4KHBhdGhbaW5kZXggKyAxXSkgPyBbXSA6IHt9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgYXNzaWduVmFsdWUobmVzdGVkLCBrZXksIG5ld1ZhbHVlKTtcbiAgICBuZXN0ZWQgPSBuZXN0ZWRba2V5XTtcbiAgfVxuICByZXR1cm4gb2JqZWN0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VTZXQ7XG4iLCJ2YXIgYmFzZUdldCA9IHJlcXVpcmUoJy4vX2Jhc2VHZXQnKSxcbiAgICBiYXNlU2V0ID0gcmVxdWlyZSgnLi9fYmFzZVNldCcpLFxuICAgIGNhc3RQYXRoID0gcmVxdWlyZSgnLi9fY2FzdFBhdGgnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiAgYF8ucGlja0J5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRocyBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgcHJvcGVydHkuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBiYXNlUGlja0J5KG9iamVjdCwgcGF0aHMsIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHBhdGhzLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IHt9O1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHBhdGggPSBwYXRoc1tpbmRleF0sXG4gICAgICAgIHZhbHVlID0gYmFzZUdldChvYmplY3QsIHBhdGgpO1xuXG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgcGF0aCkpIHtcbiAgICAgIGJhc2VTZXQocmVzdWx0LCBjYXN0UGF0aChwYXRoLCBvYmplY3QpLCB2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVBpY2tCeTtcbiIsInZhciBhcnJheVB1c2ggPSByZXF1aXJlKCcuL19hcnJheVB1c2gnKSxcbiAgICBnZXRQcm90b3R5cGUgPSByZXF1aXJlKCcuL19nZXRQcm90b3R5cGUnKSxcbiAgICBnZXRTeW1ib2xzID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9scycpLFxuICAgIHN0dWJBcnJheSA9IHJlcXVpcmUoJy4vc3R1YkFycmF5Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAqL1xudmFyIGdldFN5bWJvbHNJbiA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgd2hpbGUgKG9iamVjdCkge1xuICAgIGFycmF5UHVzaChyZXN1bHQsIGdldFN5bWJvbHMob2JqZWN0KSk7XG4gICAgb2JqZWN0ID0gZ2V0UHJvdG90eXBlKG9iamVjdCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0U3ltYm9sc0luO1xuIiwidmFyIGJhc2VHZXRBbGxLZXlzID0gcmVxdWlyZSgnLi9fYmFzZUdldEFsbEtleXMnKSxcbiAgICBnZXRTeW1ib2xzSW4gPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzSW4nKSxcbiAgICBrZXlzSW4gPSByZXF1aXJlKCcuL2tleXNJbicpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGdldEFsbEtleXNJbihvYmplY3QpIHtcbiAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0luLCBnZXRTeW1ib2xzSW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEFsbEtleXNJbjtcbiIsInZhciBhcnJheU1hcCA9IHJlcXVpcmUoJy4vX2FycmF5TWFwJyksXG4gICAgYmFzZUl0ZXJhdGVlID0gcmVxdWlyZSgnLi9fYmFzZUl0ZXJhdGVlJyksXG4gICAgYmFzZVBpY2tCeSA9IHJlcXVpcmUoJy4vX2Jhc2VQaWNrQnknKSxcbiAgICBnZXRBbGxLZXlzSW4gPSByZXF1aXJlKCcuL19nZXRBbGxLZXlzSW4nKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgYG9iamVjdGAgcHJvcGVydGllcyBgcHJlZGljYXRlYCByZXR1cm5zXG4gKiB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0d28gYXJndW1lbnRzOiAodmFsdWUsIGtleSkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIHByb3BlcnR5LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gKlxuICogXy5waWNrQnkob2JqZWN0LCBfLmlzTnVtYmVyKTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYyc6IDMgfVxuICovXG5mdW5jdGlvbiBwaWNrQnkob2JqZWN0LCBwcmVkaWNhdGUpIHtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIHZhciBwcm9wcyA9IGFycmF5TWFwKGdldEFsbEtleXNJbihvYmplY3QpLCBmdW5jdGlvbihwcm9wKSB7XG4gICAgcmV0dXJuIFtwcm9wXTtcbiAgfSk7XG4gIHByZWRpY2F0ZSA9IGJhc2VJdGVyYXRlZShwcmVkaWNhdGUpO1xuICByZXR1cm4gYmFzZVBpY2tCeShvYmplY3QsIHByb3BzLCBmdW5jdGlvbih2YWx1ZSwgcGF0aCkge1xuICAgIHJldHVybiBwcmVkaWNhdGUodmFsdWUsIHBhdGhbMF0pO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwaWNrQnk7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGBudWxsYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgbnVsbGAsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc051bGwobnVsbCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc051bGwodm9pZCAwKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTnVsbCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNOdWxsO1xuIiwidmFyIGJhc2VFYWNoID0gcmVxdWlyZSgnLi9fYmFzZUVhY2gnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maWx0ZXJgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZUZpbHRlcihjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGaWx0ZXI7XG4iLCJ2YXIgYXJyYXlGaWx0ZXIgPSByZXF1aXJlKCcuL19hcnJheUZpbHRlcicpLFxuICAgIGJhc2VGaWx0ZXIgPSByZXF1aXJlKCcuL19iYXNlRmlsdGVyJyksXG4gICAgYmFzZUl0ZXJhdGVlID0gcmVxdWlyZSgnLi9fYmFzZUl0ZXJhdGVlJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xuXG4vKipcbiAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gLCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgYWxsIGVsZW1lbnRzXG4gKiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHRocmVlXG4gKiBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAqXG4gKiAqKk5vdGU6KiogVW5saWtlIGBfLnJlbW92ZWAsIHRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICogQHNlZSBfLnJlamVjdFxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgdXNlcnMgPSBbXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAqIF07XG4gKlxuICogXy5maWx0ZXIodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XG4gKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnXVxuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbHRlcih1c2VycywgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0pO1xuICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmlsdGVyKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnXVxuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maWx0ZXIodXNlcnMsICdhY3RpdmUnKTtcbiAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAqL1xuZnVuY3Rpb24gZmlsdGVyKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUZpbHRlciA6IGJhc2VGaWx0ZXI7XG4gIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGJhc2VJdGVyYXRlZShwcmVkaWNhdGUsIDMpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmaWx0ZXI7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3RyaW5nYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3RyaW5nLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTdHJpbmcoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTdHJpbmcoMSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8XG4gICAgKCFpc0FycmF5KHZhbHVlKSAmJiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN0cmluZ1RhZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTdHJpbmc7XG4iLCJ2YXIgYmFzZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fYmFzZVByb3BlcnR5Jyk7XG5cbi8qKlxuICogR2V0cyB0aGUgc2l6ZSBvZiBhbiBBU0NJSSBgc3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdHJpbmcgc2l6ZS5cbiAqL1xudmFyIGFzY2lpU2l6ZSA9IGJhc2VQcm9wZXJ0eSgnbGVuZ3RoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gYXNjaWlTaXplO1xuIiwiLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNoYXJhY3RlciBjbGFzc2VzLiAqL1xudmFyIHJzQXN0cmFsUmFuZ2UgPSAnXFxcXHVkODAwLVxcXFx1ZGZmZicsXG4gICAgcnNDb21ib01hcmtzUmFuZ2UgPSAnXFxcXHUwMzAwLVxcXFx1MDM2ZicsXG4gICAgcmVDb21ib0hhbGZNYXJrc1JhbmdlID0gJ1xcXFx1ZmUyMC1cXFxcdWZlMmYnLFxuICAgIHJzQ29tYm9TeW1ib2xzUmFuZ2UgPSAnXFxcXHUyMGQwLVxcXFx1MjBmZicsXG4gICAgcnNDb21ib1JhbmdlID0gcnNDb21ib01hcmtzUmFuZ2UgKyByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgKyByc0NvbWJvU3ltYm9sc1JhbmdlLFxuICAgIHJzVmFyUmFuZ2UgPSAnXFxcXHVmZTBlXFxcXHVmZTBmJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNhcHR1cmUgZ3JvdXBzLiAqL1xudmFyIHJzWldKID0gJ1xcXFx1MjAwZCc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBzdHJpbmdzIHdpdGggW3plcm8td2lkdGggam9pbmVycyBvciBjb2RlIHBvaW50cyBmcm9tIHRoZSBhc3RyYWwgcGxhbmVzXShodHRwOi8vZWV2LmVlL2Jsb2cvMjAxNS8wOS8xMi9kYXJrLWNvcm5lcnMtb2YtdW5pY29kZS8pLiAqL1xudmFyIHJlSGFzVW5pY29kZSA9IFJlZ0V4cCgnWycgKyByc1pXSiArIHJzQXN0cmFsUmFuZ2UgICsgcnNDb21ib1JhbmdlICsgcnNWYXJSYW5nZSArICddJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBzdHJpbmdgIGNvbnRhaW5zIFVuaWNvZGUgc3ltYm9scy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYSBzeW1ib2wgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzVW5pY29kZShzdHJpbmcpIHtcbiAgcmV0dXJuIHJlSGFzVW5pY29kZS50ZXN0KHN0cmluZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzVW5pY29kZTtcbiIsIi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjaGFyYWN0ZXIgY2xhc3Nlcy4gKi9cbnZhciByc0FzdHJhbFJhbmdlID0gJ1xcXFx1ZDgwMC1cXFxcdWRmZmYnLFxuICAgIHJzQ29tYm9NYXJrc1JhbmdlID0gJ1xcXFx1MDMwMC1cXFxcdTAzNmYnLFxuICAgIHJlQ29tYm9IYWxmTWFya3NSYW5nZSA9ICdcXFxcdWZlMjAtXFxcXHVmZTJmJyxcbiAgICByc0NvbWJvU3ltYm9sc1JhbmdlID0gJ1xcXFx1MjBkMC1cXFxcdTIwZmYnLFxuICAgIHJzQ29tYm9SYW5nZSA9IHJzQ29tYm9NYXJrc1JhbmdlICsgcmVDb21ib0hhbGZNYXJrc1JhbmdlICsgcnNDb21ib1N5bWJvbHNSYW5nZSxcbiAgICByc1ZhclJhbmdlID0gJ1xcXFx1ZmUwZVxcXFx1ZmUwZic7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjYXB0dXJlIGdyb3Vwcy4gKi9cbnZhciByc0FzdHJhbCA9ICdbJyArIHJzQXN0cmFsUmFuZ2UgKyAnXScsXG4gICAgcnNDb21ibyA9ICdbJyArIHJzQ29tYm9SYW5nZSArICddJyxcbiAgICByc0ZpdHogPSAnXFxcXHVkODNjW1xcXFx1ZGZmYi1cXFxcdWRmZmZdJyxcbiAgICByc01vZGlmaWVyID0gJyg/OicgKyByc0NvbWJvICsgJ3wnICsgcnNGaXR6ICsgJyknLFxuICAgIHJzTm9uQXN0cmFsID0gJ1teJyArIHJzQXN0cmFsUmFuZ2UgKyAnXScsXG4gICAgcnNSZWdpb25hbCA9ICcoPzpcXFxcdWQ4M2NbXFxcXHVkZGU2LVxcXFx1ZGRmZl0pezJ9JyxcbiAgICByc1N1cnJQYWlyID0gJ1tcXFxcdWQ4MDAtXFxcXHVkYmZmXVtcXFxcdWRjMDAtXFxcXHVkZmZmXScsXG4gICAgcnNaV0ogPSAnXFxcXHUyMDBkJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIHJlZ2V4ZXMuICovXG52YXIgcmVPcHRNb2QgPSByc01vZGlmaWVyICsgJz8nLFxuICAgIHJzT3B0VmFyID0gJ1snICsgcnNWYXJSYW5nZSArICddPycsXG4gICAgcnNPcHRKb2luID0gJyg/OicgKyByc1pXSiArICcoPzonICsgW3JzTm9uQXN0cmFsLCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyXS5qb2luKCd8JykgKyAnKScgKyByc09wdFZhciArIHJlT3B0TW9kICsgJykqJyxcbiAgICByc1NlcSA9IHJzT3B0VmFyICsgcmVPcHRNb2QgKyByc09wdEpvaW4sXG4gICAgcnNTeW1ib2wgPSAnKD86JyArIFtyc05vbkFzdHJhbCArIHJzQ29tYm8gKyAnPycsIHJzQ29tYm8sIHJzUmVnaW9uYWwsIHJzU3VyclBhaXIsIHJzQXN0cmFsXS5qb2luKCd8JykgKyAnKSc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIFtzdHJpbmcgc3ltYm9sc10oaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtdW5pY29kZSkuICovXG52YXIgcmVVbmljb2RlID0gUmVnRXhwKHJzRml0eiArICcoPz0nICsgcnNGaXR6ICsgJyl8JyArIHJzU3ltYm9sICsgcnNTZXEsICdnJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgc2l6ZSBvZiBhIFVuaWNvZGUgYHN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyBpbnNwZWN0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3RyaW5nIHNpemUuXG4gKi9cbmZ1bmN0aW9uIHVuaWNvZGVTaXplKHN0cmluZykge1xuICB2YXIgcmVzdWx0ID0gcmVVbmljb2RlLmxhc3RJbmRleCA9IDA7XG4gIHdoaWxlIChyZVVuaWNvZGUudGVzdChzdHJpbmcpKSB7XG4gICAgKytyZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB1bmljb2RlU2l6ZTtcbiIsInZhciBhc2NpaVNpemUgPSByZXF1aXJlKCcuL19hc2NpaVNpemUnKSxcbiAgICBoYXNVbmljb2RlID0gcmVxdWlyZSgnLi9faGFzVW5pY29kZScpLFxuICAgIHVuaWNvZGVTaXplID0gcmVxdWlyZSgnLi9fdW5pY29kZVNpemUnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBudW1iZXIgb2Ygc3ltYm9scyBpbiBgc3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdHJpbmcgc2l6ZS5cbiAqL1xuZnVuY3Rpb24gc3RyaW5nU2l6ZShzdHJpbmcpIHtcbiAgcmV0dXJuIGhhc1VuaWNvZGUoc3RyaW5nKVxuICAgID8gdW5pY29kZVNpemUoc3RyaW5nKVxuICAgIDogYXNjaWlTaXplKHN0cmluZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RyaW5nU2l6ZTtcbiIsInZhciBiYXNlS2V5cyA9IHJlcXVpcmUoJy4vX2Jhc2VLZXlzJyksXG4gICAgZ2V0VGFnID0gcmVxdWlyZSgnLi9fZ2V0VGFnJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyksXG4gICAgaXNTdHJpbmcgPSByZXF1aXJlKCcuL2lzU3RyaW5nJyksXG4gICAgc3RyaW5nU2l6ZSA9IHJlcXVpcmUoJy4vX3N0cmluZ1NpemUnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nO1xuXG4vKipcbiAqIEdldHMgdGhlIHNpemUgb2YgYGNvbGxlY3Rpb25gIGJ5IHJldHVybmluZyBpdHMgbGVuZ3RoIGZvciBhcnJheS1saWtlXG4gKiB2YWx1ZXMgb3IgdGhlIG51bWJlciBvZiBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBmb3Igb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb2xsZWN0aW9uIHNpemUuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uc2l6ZShbMSwgMiwgM10pO1xuICogLy8gPT4gM1xuICpcbiAqIF8uc2l6ZSh7ICdhJzogMSwgJ2InOiAyIH0pO1xuICogLy8gPT4gMlxuICpcbiAqIF8uc2l6ZSgncGViYmxlcycpO1xuICogLy8gPT4gN1xuICovXG5mdW5jdGlvbiBzaXplKGNvbGxlY3Rpb24pIHtcbiAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGlmIChpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgIHJldHVybiBpc1N0cmluZyhjb2xsZWN0aW9uKSA/IHN0cmluZ1NpemUoY29sbGVjdGlvbikgOiBjb2xsZWN0aW9uLmxlbmd0aDtcbiAgfVxuICB2YXIgdGFnID0gZ2V0VGFnKGNvbGxlY3Rpb24pO1xuICBpZiAodGFnID09IG1hcFRhZyB8fCB0YWcgPT0gc2V0VGFnKSB7XG4gICAgcmV0dXJuIGNvbGxlY3Rpb24uc2l6ZTtcbiAgfVxuICByZXR1cm4gYmFzZUtleXMoY29sbGVjdGlvbikubGVuZ3RoO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNpemU7XG4iLCJ2YXIgYmFzZUVhY2ggPSByZXF1aXJlKCcuL19iYXNlRWFjaCcpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hcGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlTWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gaXNBcnJheUxpa2UoY29sbGVjdGlvbikgPyBBcnJheShjb2xsZWN0aW9uLmxlbmd0aCkgOiBbXTtcblxuICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gaXRlcmF0ZWUodmFsdWUsIGtleSwgY29sbGVjdGlvbik7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNYXA7XG4iLCJ2YXIgYXJyYXlNYXAgPSByZXF1aXJlKCcuL19hcnJheU1hcCcpLFxuICAgIGJhc2VJdGVyYXRlZSA9IHJlcXVpcmUoJy4vX2Jhc2VJdGVyYXRlZScpLFxuICAgIGJhc2VNYXAgPSByZXF1aXJlKCcuL19iYXNlTWFwJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdmFsdWVzIGJ5IHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCB0aHJ1XG4gKiBgaXRlcmF0ZWVgLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAqICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAqXG4gKiBNYW55IGxvZGFzaCBtZXRob2RzIGFyZSBndWFyZGVkIHRvIHdvcmsgYXMgaXRlcmF0ZWVzIGZvciBtZXRob2RzIGxpa2VcbiAqIGBfLmV2ZXJ5YCwgYF8uZmlsdGVyYCwgYF8ubWFwYCwgYF8ubWFwVmFsdWVzYCwgYF8ucmVqZWN0YCwgYW5kIGBfLnNvbWVgLlxuICpcbiAqIFRoZSBndWFyZGVkIG1ldGhvZHMgYXJlOlxuICogYGFyeWAsIGBjaHVua2AsIGBjdXJyeWAsIGBjdXJyeVJpZ2h0YCwgYGRyb3BgLCBgZHJvcFJpZ2h0YCwgYGV2ZXJ5YCxcbiAqIGBmaWxsYCwgYGludmVydGAsIGBwYXJzZUludGAsIGByYW5kb21gLCBgcmFuZ2VgLCBgcmFuZ2VSaWdodGAsIGByZXBlYXRgLFxuICogYHNhbXBsZVNpemVgLCBgc2xpY2VgLCBgc29tZWAsIGBzb3J0QnlgLCBgc3BsaXRgLCBgdGFrZWAsIGB0YWtlUmlnaHRgLFxuICogYHRlbXBsYXRlYCwgYHRyaW1gLCBgdHJpbUVuZGAsIGB0cmltU3RhcnRgLCBhbmQgYHdvcmRzYFxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAqICAgcmV0dXJuIG4gKiBuO1xuICogfVxuICpcbiAqIF8ubWFwKFs0LCA4XSwgc3F1YXJlKTtcbiAqIC8vID0+IFsxNiwgNjRdXG4gKlxuICogXy5tYXAoeyAnYSc6IDQsICdiJzogOCB9LCBzcXVhcmUpO1xuICogLy8gPT4gWzE2LCA2NF0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiB2YXIgdXNlcnMgPSBbXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JyB9LFxuICogICB7ICd1c2VyJzogJ2ZyZWQnIH1cbiAqIF07XG4gKlxuICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLm1hcCh1c2VycywgJ3VzZXInKTtcbiAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICovXG5mdW5jdGlvbiBtYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlNYXAgOiBiYXNlTWFwO1xuICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBiYXNlSXRlcmF0ZWUoaXRlcmF0ZWUsIDMpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXA7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNsaWNlYCB3aXRob3V0IGFuIGl0ZXJhdGVlIGNhbGwgZ3VhcmQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzbGljZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBiYXNlU2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gLXN0YXJ0ID4gbGVuZ3RoID8gMCA6IChsZW5ndGggKyBzdGFydCk7XG4gIH1cbiAgZW5kID0gZW5kID4gbGVuZ3RoID8gbGVuZ3RoIDogZW5kO1xuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5ndGg7XG4gIH1cbiAgbGVuZ3RoID0gc3RhcnQgPiBlbmQgPyAwIDogKChlbmQgLSBzdGFydCkgPj4+IDApO1xuICBzdGFydCA+Pj49IDA7XG5cbiAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGFycmF5W2luZGV4ICsgc3RhcnRdO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVNsaWNlO1xuIiwidmFyIGJhc2VTbGljZSA9IHJlcXVpcmUoJy4vX2Jhc2VTbGljZScpO1xuXG4vKipcbiAqIENhc3RzIGBhcnJheWAgdG8gYSBzbGljZSBpZiBpdCdzIG5lZWRlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IHNsaWNlLlxuICovXG5mdW5jdGlvbiBjYXN0U2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiBlbmQ7XG4gIHJldHVybiAoIXN0YXJ0ICYmIGVuZCA+PSBsZW5ndGgpID8gYXJyYXkgOiBiYXNlU2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhc3RTbGljZTtcbiIsIi8qKlxuICogQ29udmVydHMgYW4gQVNDSUkgYHN0cmluZ2AgdG8gYW4gYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFzY2lpVG9BcnJheShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5zcGxpdCgnJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNjaWlUb0FycmF5O1xuIiwiLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNoYXJhY3RlciBjbGFzc2VzLiAqL1xudmFyIHJzQXN0cmFsUmFuZ2UgPSAnXFxcXHVkODAwLVxcXFx1ZGZmZicsXG4gICAgcnNDb21ib01hcmtzUmFuZ2UgPSAnXFxcXHUwMzAwLVxcXFx1MDM2ZicsXG4gICAgcmVDb21ib0hhbGZNYXJrc1JhbmdlID0gJ1xcXFx1ZmUyMC1cXFxcdWZlMmYnLFxuICAgIHJzQ29tYm9TeW1ib2xzUmFuZ2UgPSAnXFxcXHUyMGQwLVxcXFx1MjBmZicsXG4gICAgcnNDb21ib1JhbmdlID0gcnNDb21ib01hcmtzUmFuZ2UgKyByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgKyByc0NvbWJvU3ltYm9sc1JhbmdlLFxuICAgIHJzVmFyUmFuZ2UgPSAnXFxcXHVmZTBlXFxcXHVmZTBmJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNhcHR1cmUgZ3JvdXBzLiAqL1xudmFyIHJzQXN0cmFsID0gJ1snICsgcnNBc3RyYWxSYW5nZSArICddJyxcbiAgICByc0NvbWJvID0gJ1snICsgcnNDb21ib1JhbmdlICsgJ10nLFxuICAgIHJzRml0eiA9ICdcXFxcdWQ4M2NbXFxcXHVkZmZiLVxcXFx1ZGZmZl0nLFxuICAgIHJzTW9kaWZpZXIgPSAnKD86JyArIHJzQ29tYm8gKyAnfCcgKyByc0ZpdHogKyAnKScsXG4gICAgcnNOb25Bc3RyYWwgPSAnW14nICsgcnNBc3RyYWxSYW5nZSArICddJyxcbiAgICByc1JlZ2lvbmFsID0gJyg/OlxcXFx1ZDgzY1tcXFxcdWRkZTYtXFxcXHVkZGZmXSl7Mn0nLFxuICAgIHJzU3VyclBhaXIgPSAnW1xcXFx1ZDgwMC1cXFxcdWRiZmZdW1xcXFx1ZGMwMC1cXFxcdWRmZmZdJyxcbiAgICByc1pXSiA9ICdcXFxcdTIwMGQnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgcmVnZXhlcy4gKi9cbnZhciByZU9wdE1vZCA9IHJzTW9kaWZpZXIgKyAnPycsXG4gICAgcnNPcHRWYXIgPSAnWycgKyByc1ZhclJhbmdlICsgJ10/JyxcbiAgICByc09wdEpvaW4gPSAnKD86JyArIHJzWldKICsgJyg/OicgKyBbcnNOb25Bc3RyYWwsIHJzUmVnaW9uYWwsIHJzU3VyclBhaXJdLmpvaW4oJ3wnKSArICcpJyArIHJzT3B0VmFyICsgcmVPcHRNb2QgKyAnKSonLFxuICAgIHJzU2VxID0gcnNPcHRWYXIgKyByZU9wdE1vZCArIHJzT3B0Sm9pbixcbiAgICByc1N5bWJvbCA9ICcoPzonICsgW3JzTm9uQXN0cmFsICsgcnNDb21ibyArICc/JywgcnNDb21ibywgcnNSZWdpb25hbCwgcnNTdXJyUGFpciwgcnNBc3RyYWxdLmpvaW4oJ3wnKSArICcpJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggW3N0cmluZyBzeW1ib2xzXShodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC11bmljb2RlKS4gKi9cbnZhciByZVVuaWNvZGUgPSBSZWdFeHAocnNGaXR6ICsgJyg/PScgKyByc0ZpdHogKyAnKXwnICsgcnNTeW1ib2wgKyByc1NlcSwgJ2cnKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFVuaWNvZGUgYHN0cmluZ2AgdG8gYW4gYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHVuaWNvZGVUb0FycmF5KHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlVW5pY29kZSkgfHwgW107XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdW5pY29kZVRvQXJyYXk7XG4iLCJ2YXIgYXNjaWlUb0FycmF5ID0gcmVxdWlyZSgnLi9fYXNjaWlUb0FycmF5JyksXG4gICAgaGFzVW5pY29kZSA9IHJlcXVpcmUoJy4vX2hhc1VuaWNvZGUnKSxcbiAgICB1bmljb2RlVG9BcnJheSA9IHJlcXVpcmUoJy4vX3VuaWNvZGVUb0FycmF5Jyk7XG5cbi8qKlxuICogQ29udmVydHMgYHN0cmluZ2AgdG8gYW4gYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1RvQXJyYXkoc3RyaW5nKSB7XG4gIHJldHVybiBoYXNVbmljb2RlKHN0cmluZylcbiAgICA/IHVuaWNvZGVUb0FycmF5KHN0cmluZylcbiAgICA6IGFzY2lpVG9BcnJheShzdHJpbmcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0cmluZ1RvQXJyYXk7XG4iLCJ2YXIgY2FzdFNsaWNlID0gcmVxdWlyZSgnLi9fY2FzdFNsaWNlJyksXG4gICAgaGFzVW5pY29kZSA9IHJlcXVpcmUoJy4vX2hhc1VuaWNvZGUnKSxcbiAgICBzdHJpbmdUb0FycmF5ID0gcmVxdWlyZSgnLi9fc3RyaW5nVG9BcnJheScpLFxuICAgIHRvU3RyaW5nID0gcmVxdWlyZSgnLi90b1N0cmluZycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmxvd2VyRmlyc3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZSBUaGUgbmFtZSBvZiB0aGUgYFN0cmluZ2AgY2FzZSBtZXRob2QgdG8gdXNlLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2FzZUZpcnN0KG1ldGhvZE5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG5cbiAgICB2YXIgc3RyU3ltYm9scyA9IGhhc1VuaWNvZGUoc3RyaW5nKVxuICAgICAgPyBzdHJpbmdUb0FycmF5KHN0cmluZylcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgdmFyIGNociA9IHN0clN5bWJvbHNcbiAgICAgID8gc3RyU3ltYm9sc1swXVxuICAgICAgOiBzdHJpbmcuY2hhckF0KDApO1xuXG4gICAgdmFyIHRyYWlsaW5nID0gc3RyU3ltYm9sc1xuICAgICAgPyBjYXN0U2xpY2Uoc3RyU3ltYm9scywgMSkuam9pbignJylcbiAgICAgIDogc3RyaW5nLnNsaWNlKDEpO1xuXG4gICAgcmV0dXJuIGNoclttZXRob2ROYW1lXSgpICsgdHJhaWxpbmc7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQ2FzZUZpcnN0O1xuIiwidmFyIGNyZWF0ZUNhc2VGaXJzdCA9IHJlcXVpcmUoJy4vX2NyZWF0ZUNhc2VGaXJzdCcpO1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYHN0cmluZ2AgdG8gdXBwZXIgY2FzZS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy51cHBlckZpcnN0KCdmcmVkJyk7XG4gKiAvLyA9PiAnRnJlZCdcbiAqXG4gKiBfLnVwcGVyRmlyc3QoJ0ZSRUQnKTtcbiAqIC8vID0+ICdGUkVEJ1xuICovXG52YXIgdXBwZXJGaXJzdCA9IGNyZWF0ZUNhc2VGaXJzdCgndG9VcHBlckNhc2UnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB1cHBlckZpcnN0O1xuIiwidmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi90b1N0cmluZycpLFxuICAgIHVwcGVyRmlyc3QgPSByZXF1aXJlKCcuL3VwcGVyRmlyc3QnKTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGBzdHJpbmdgIHRvIHVwcGVyIGNhc2UgYW5kIHRoZSByZW1haW5pbmdcbiAqIHRvIGxvd2VyIGNhc2UuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY2FwaXRhbGl6ZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNhcGl0YWxpemVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5jYXBpdGFsaXplKCdGUkVEJyk7XG4gKiAvLyA9PiAnRnJlZCdcbiAqL1xuZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHJpbmcpIHtcbiAgcmV0dXJuIHVwcGVyRmlyc3QodG9TdHJpbmcoc3RyaW5nKS50b0xvd2VyQ2FzZSgpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYXBpdGFsaXplO1xuIiwidmFyIGNhcGl0YWxpemUgPSByZXF1aXJlKCcuL2NhcGl0YWxpemUnKSxcbiAgICBjcmVhdGVDb21wb3VuZGVyID0gcmVxdWlyZSgnLi9fY3JlYXRlQ29tcG91bmRlcicpO1xuXG4vKipcbiAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIFtjYW1lbCBjYXNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DYW1lbENhc2UpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjYW1lbCBjYXNlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uY2FtZWxDYXNlKCdGb28gQmFyJyk7XG4gKiAvLyA9PiAnZm9vQmFyJ1xuICpcbiAqIF8uY2FtZWxDYXNlKCctLWZvby1iYXItLScpO1xuICogLy8gPT4gJ2Zvb0JhcidcbiAqXG4gKiBfLmNhbWVsQ2FzZSgnX19GT09fQkFSX18nKTtcbiAqIC8vID0+ICdmb29CYXInXG4gKi9cbnZhciBjYW1lbENhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgd29yZCA9IHdvcmQudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/IGNhcGl0YWxpemUod29yZCkgOiB3b3JkKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNhbWVsQ2FzZTtcbiIsInZhciBXZWFrTWFwID0gcmVxdWlyZSgnLi9fV2Vha01hcCcpO1xuXG4vKiogVXNlZCB0byBzdG9yZSBmdW5jdGlvbiBtZXRhZGF0YS4gKi9cbnZhciBtZXRhTWFwID0gV2Vha01hcCAmJiBuZXcgV2Vha01hcDtcblxubW9kdWxlLmV4cG9ydHMgPSBtZXRhTWFwO1xuIiwidmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpLFxuICAgIG1ldGFNYXAgPSByZXF1aXJlKCcuL19tZXRhTWFwJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldERhdGFgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaG90IGxvb3Agc2hvcnRpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFzc29jaWF0ZSBtZXRhZGF0YSB3aXRoLlxuICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXRhZGF0YS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gKi9cbnZhciBiYXNlU2V0RGF0YSA9ICFtZXRhTWFwID8gaWRlbnRpdHkgOiBmdW5jdGlvbihmdW5jLCBkYXRhKSB7XG4gIG1ldGFNYXAuc2V0KGZ1bmMsIGRhdGEpO1xuICByZXR1cm4gZnVuYztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVNldERhdGE7XG4iLCJ2YXIgYmFzZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX2Jhc2VDcmVhdGUnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwcm9kdWNlcyBhbiBpbnN0YW5jZSBvZiBgQ3RvcmAgcmVnYXJkbGVzcyBvZlxuICogd2hldGhlciBpdCB3YXMgaW52b2tlZCBhcyBwYXJ0IG9mIGEgYG5ld2AgZXhwcmVzc2lvbiBvciBieSBgY2FsbGAgb3IgYGFwcGx5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gQ3RvciBUaGUgY29uc3RydWN0b3IgdG8gd3JhcC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUN0b3IoQ3Rvcikge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgLy8gVXNlIGEgYHN3aXRjaGAgc3RhdGVtZW50IHRvIHdvcmsgd2l0aCBjbGFzcyBjb25zdHJ1Y3RvcnMuIFNlZVxuICAgIC8vIGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtZnVuY3Rpb24tb2JqZWN0cy1jYWxsLXRoaXNhcmd1bWVudC1hcmd1bWVudHNsaXN0XG4gICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6IHJldHVybiBuZXcgQ3RvcjtcbiAgICAgIGNhc2UgMTogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0pO1xuICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICBjYXNlIDM6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgIGNhc2UgNDogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICAgICAgY2FzZSA1OiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSwgYXJnc1s0XSk7XG4gICAgICBjYXNlIDY6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdLCBhcmdzWzVdKTtcbiAgICAgIGNhc2UgNzogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10sIGFyZ3NbNF0sIGFyZ3NbNV0sIGFyZ3NbNl0pO1xuICAgIH1cbiAgICB2YXIgdGhpc0JpbmRpbmcgPSBiYXNlQ3JlYXRlKEN0b3IucHJvdG90eXBlKSxcbiAgICAgICAgcmVzdWx0ID0gQ3Rvci5hcHBseSh0aGlzQmluZGluZywgYXJncyk7XG5cbiAgICAvLyBNaW1pYyB0aGUgY29uc3RydWN0b3IncyBgcmV0dXJuYCBiZWhhdmlvci5cbiAgICAvLyBTZWUgaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4MTMuMi4yIGZvciBtb3JlIGRldGFpbHMuXG4gICAgcmV0dXJuIGlzT2JqZWN0KHJlc3VsdCkgPyByZXN1bHQgOiB0aGlzQmluZGluZztcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVDdG9yO1xuIiwidmFyIGNyZWF0ZUN0b3IgPSByZXF1aXJlKCcuL19jcmVhdGVDdG9yJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgZnVuY3Rpb24gbWV0YWRhdGEuICovXG52YXIgV1JBUF9CSU5EX0ZMQUcgPSAxO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCB0byBpbnZva2UgaXQgd2l0aCB0aGUgb3B0aW9uYWwgYHRoaXNgXG4gKiBiaW5kaW5nIG9mIGB0aGlzQXJnYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmluZChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnKSB7XG4gIHZhciBpc0JpbmQgPSBiaXRtYXNrICYgV1JBUF9CSU5EX0ZMQUcsXG4gICAgICBDdG9yID0gY3JlYXRlQ3RvcihmdW5jKTtcblxuICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgIHZhciBmbiA9ICh0aGlzICYmIHRoaXMgIT09IHJvb3QgJiYgdGhpcyBpbnN0YW5jZW9mIHdyYXBwZXIpID8gQ3RvciA6IGZ1bmM7XG4gICAgcmV0dXJuIGZuLmFwcGx5KGlzQmluZCA/IHRoaXNBcmcgOiB0aGlzLCBhcmd1bWVudHMpO1xuICB9XG4gIHJldHVybiB3cmFwcGVyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUJpbmQ7XG4iLCIvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXg7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSB0aGF0IGlzIHRoZSBjb21wb3NpdGlvbiBvZiBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMsXG4gKiBwbGFjZWhvbGRlcnMsIGFuZCBwcm92aWRlZCBhcmd1bWVudHMgaW50byBhIHNpbmdsZSBhcnJheSBvZiBhcmd1bWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIHByb3ZpZGVkIGFyZ3VtZW50cy5cbiAqIEBwYXJhbSB7QXJyYXl9IHBhcnRpYWxzIFRoZSBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aG9zZSBwcm92aWRlZC5cbiAqIEBwYXJhbSB7QXJyYXl9IGhvbGRlcnMgVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAqIEBwYXJhbXMge2Jvb2xlYW59IFtpc0N1cnJpZWRdIFNwZWNpZnkgY29tcG9zaW5nIGZvciBhIGN1cnJpZWQgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21wb3NlZCBhcmd1bWVudHMuXG4gKi9cbmZ1bmN0aW9uIGNvbXBvc2VBcmdzKGFyZ3MsIHBhcnRpYWxzLCBob2xkZXJzLCBpc0N1cnJpZWQpIHtcbiAgdmFyIGFyZ3NJbmRleCA9IC0xLFxuICAgICAgYXJnc0xlbmd0aCA9IGFyZ3MubGVuZ3RoLFxuICAgICAgaG9sZGVyc0xlbmd0aCA9IGhvbGRlcnMubGVuZ3RoLFxuICAgICAgbGVmdEluZGV4ID0gLTEsXG4gICAgICBsZWZ0TGVuZ3RoID0gcGFydGlhbHMubGVuZ3RoLFxuICAgICAgcmFuZ2VMZW5ndGggPSBuYXRpdmVNYXgoYXJnc0xlbmd0aCAtIGhvbGRlcnNMZW5ndGgsIDApLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobGVmdExlbmd0aCArIHJhbmdlTGVuZ3RoKSxcbiAgICAgIGlzVW5jdXJyaWVkID0gIWlzQ3VycmllZDtcblxuICB3aGlsZSAoKytsZWZ0SW5kZXggPCBsZWZ0TGVuZ3RoKSB7XG4gICAgcmVzdWx0W2xlZnRJbmRleF0gPSBwYXJ0aWFsc1tsZWZ0SW5kZXhdO1xuICB9XG4gIHdoaWxlICgrK2FyZ3NJbmRleCA8IGhvbGRlcnNMZW5ndGgpIHtcbiAgICBpZiAoaXNVbmN1cnJpZWQgfHwgYXJnc0luZGV4IDwgYXJnc0xlbmd0aCkge1xuICAgICAgcmVzdWx0W2hvbGRlcnNbYXJnc0luZGV4XV0gPSBhcmdzW2FyZ3NJbmRleF07XG4gICAgfVxuICB9XG4gIHdoaWxlIChyYW5nZUxlbmd0aC0tKSB7XG4gICAgcmVzdWx0W2xlZnRJbmRleCsrXSA9IGFyZ3NbYXJnc0luZGV4KytdO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29tcG9zZUFyZ3M7XG4iLCIvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXg7XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBjb21wb3NlQXJnc2AgZXhjZXB0IHRoYXQgdGhlIGFyZ3VtZW50cyBjb21wb3NpdGlvblxuICogaXMgdGFpbG9yZWQgZm9yIGBfLnBhcnRpYWxSaWdodGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIHByb3ZpZGVkIGFyZ3VtZW50cy5cbiAqIEBwYXJhbSB7QXJyYXl9IHBhcnRpYWxzIFRoZSBhcmd1bWVudHMgdG8gYXBwZW5kIHRvIHRob3NlIHByb3ZpZGVkLlxuICogQHBhcmFtIHtBcnJheX0gaG9sZGVycyBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICogQHBhcmFtcyB7Ym9vbGVhbn0gW2lzQ3VycmllZF0gU3BlY2lmeSBjb21wb3NpbmcgZm9yIGEgY3VycmllZCBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNvbXBvc2VkIGFyZ3VtZW50cy5cbiAqL1xuZnVuY3Rpb24gY29tcG9zZUFyZ3NSaWdodChhcmdzLCBwYXJ0aWFscywgaG9sZGVycywgaXNDdXJyaWVkKSB7XG4gIHZhciBhcmdzSW5kZXggPSAtMSxcbiAgICAgIGFyZ3NMZW5ndGggPSBhcmdzLmxlbmd0aCxcbiAgICAgIGhvbGRlcnNJbmRleCA9IC0xLFxuICAgICAgaG9sZGVyc0xlbmd0aCA9IGhvbGRlcnMubGVuZ3RoLFxuICAgICAgcmlnaHRJbmRleCA9IC0xLFxuICAgICAgcmlnaHRMZW5ndGggPSBwYXJ0aWFscy5sZW5ndGgsXG4gICAgICByYW5nZUxlbmd0aCA9IG5hdGl2ZU1heChhcmdzTGVuZ3RoIC0gaG9sZGVyc0xlbmd0aCwgMCksXG4gICAgICByZXN1bHQgPSBBcnJheShyYW5nZUxlbmd0aCArIHJpZ2h0TGVuZ3RoKSxcbiAgICAgIGlzVW5jdXJyaWVkID0gIWlzQ3VycmllZDtcblxuICB3aGlsZSAoKythcmdzSW5kZXggPCByYW5nZUxlbmd0aCkge1xuICAgIHJlc3VsdFthcmdzSW5kZXhdID0gYXJnc1thcmdzSW5kZXhdO1xuICB9XG4gIHZhciBvZmZzZXQgPSBhcmdzSW5kZXg7XG4gIHdoaWxlICgrK3JpZ2h0SW5kZXggPCByaWdodExlbmd0aCkge1xuICAgIHJlc3VsdFtvZmZzZXQgKyByaWdodEluZGV4XSA9IHBhcnRpYWxzW3JpZ2h0SW5kZXhdO1xuICB9XG4gIHdoaWxlICgrK2hvbGRlcnNJbmRleCA8IGhvbGRlcnNMZW5ndGgpIHtcbiAgICBpZiAoaXNVbmN1cnJpZWQgfHwgYXJnc0luZGV4IDwgYXJnc0xlbmd0aCkge1xuICAgICAgcmVzdWx0W29mZnNldCArIGhvbGRlcnNbaG9sZGVyc0luZGV4XV0gPSBhcmdzW2FyZ3NJbmRleCsrXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb21wb3NlQXJnc1JpZ2h0O1xuIiwiLyoqXG4gKiBHZXRzIHRoZSBudW1iZXIgb2YgYHBsYWNlaG9sZGVyYCBvY2N1cnJlbmNlcyBpbiBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0gcGxhY2Vob2xkZXIgVGhlIHBsYWNlaG9sZGVyIHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBwbGFjZWhvbGRlciBjb3VudC5cbiAqL1xuZnVuY3Rpb24gY291bnRIb2xkZXJzKGFycmF5LCBwbGFjZWhvbGRlcikge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gMDtcblxuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoYXJyYXlbbGVuZ3RoXSA9PT0gcGxhY2Vob2xkZXIpIHtcbiAgICAgICsrcmVzdWx0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvdW50SG9sZGVycztcbiIsIi8qKlxuICogVGhlIGZ1bmN0aW9uIHdob3NlIHByb3RvdHlwZSBjaGFpbiBzZXF1ZW5jZSB3cmFwcGVycyBpbmhlcml0IGZyb20uXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYmFzZUxvZGFzaCgpIHtcbiAgLy8gTm8gb3BlcmF0aW9uIHBlcmZvcm1lZC5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlTG9kYXNoO1xuIiwidmFyIGJhc2VDcmVhdGUgPSByZXF1aXJlKCcuL19iYXNlQ3JlYXRlJyksXG4gICAgYmFzZUxvZGFzaCA9IHJlcXVpcmUoJy4vX2Jhc2VMb2Rhc2gnKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdGhlIG1heGltdW0gbGVuZ3RoIGFuZCBpbmRleCBvZiBhbiBhcnJheS4gKi9cbnZhciBNQVhfQVJSQVlfTEVOR1RIID0gNDI5NDk2NzI5NTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbGF6eSB3cmFwcGVyIG9iamVjdCB3aGljaCB3cmFwcyBgdmFsdWVgIHRvIGVuYWJsZSBsYXp5IGV2YWx1YXRpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAqL1xuZnVuY3Rpb24gTGF6eVdyYXBwZXIodmFsdWUpIHtcbiAgdGhpcy5fX3dyYXBwZWRfXyA9IHZhbHVlO1xuICB0aGlzLl9fYWN0aW9uc19fID0gW107XG4gIHRoaXMuX19kaXJfXyA9IDE7XG4gIHRoaXMuX19maWx0ZXJlZF9fID0gZmFsc2U7XG4gIHRoaXMuX19pdGVyYXRlZXNfXyA9IFtdO1xuICB0aGlzLl9fdGFrZUNvdW50X18gPSBNQVhfQVJSQVlfTEVOR1RIO1xuICB0aGlzLl9fdmlld3NfXyA9IFtdO1xufVxuXG4vLyBFbnN1cmUgYExhenlXcmFwcGVyYCBpcyBhbiBpbnN0YW5jZSBvZiBgYmFzZUxvZGFzaGAuXG5MYXp5V3JhcHBlci5wcm90b3R5cGUgPSBiYXNlQ3JlYXRlKGJhc2VMb2Rhc2gucHJvdG90eXBlKTtcbkxhenlXcmFwcGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExhenlXcmFwcGVyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExhenlXcmFwcGVyO1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGB1bmRlZmluZWRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi4zLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5ub29wKTtcbiAqIC8vID0+IFt1bmRlZmluZWQsIHVuZGVmaW5lZF1cbiAqL1xuZnVuY3Rpb24gbm9vcCgpIHtcbiAgLy8gTm8gb3BlcmF0aW9uIHBlcmZvcm1lZC5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBub29wO1xuIiwidmFyIG1ldGFNYXAgPSByZXF1aXJlKCcuL19tZXRhTWFwJyksXG4gICAgbm9vcCA9IHJlcXVpcmUoJy4vbm9vcCcpO1xuXG4vKipcbiAqIEdldHMgbWV0YWRhdGEgZm9yIGBmdW5jYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWV0YWRhdGEgZm9yIGBmdW5jYC5cbiAqL1xudmFyIGdldERhdGEgPSAhbWV0YU1hcCA/IG5vb3AgOiBmdW5jdGlvbihmdW5jKSB7XG4gIHJldHVybiBtZXRhTWFwLmdldChmdW5jKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0RGF0YTtcbiIsIi8qKiBVc2VkIHRvIGxvb2t1cCB1bm1pbmlmaWVkIGZ1bmN0aW9uIG5hbWVzLiAqL1xudmFyIHJlYWxOYW1lcyA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlYWxOYW1lcztcbiIsInZhciByZWFsTmFtZXMgPSByZXF1aXJlKCcuL19yZWFsTmFtZXMnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBHZXRzIHRoZSBuYW1lIG9mIGBmdW5jYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBuYW1lLlxuICovXG5mdW5jdGlvbiBnZXRGdW5jTmFtZShmdW5jKSB7XG4gIHZhciByZXN1bHQgPSAoZnVuYy5uYW1lICsgJycpLFxuICAgICAgYXJyYXkgPSByZWFsTmFtZXNbcmVzdWx0XSxcbiAgICAgIGxlbmd0aCA9IGhhc093blByb3BlcnR5LmNhbGwocmVhbE5hbWVzLCByZXN1bHQpID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICB2YXIgZGF0YSA9IGFycmF5W2xlbmd0aF0sXG4gICAgICAgIG90aGVyRnVuYyA9IGRhdGEuZnVuYztcbiAgICBpZiAob3RoZXJGdW5jID09IG51bGwgfHwgb3RoZXJGdW5jID09IGZ1bmMpIHtcbiAgICAgIHJldHVybiBkYXRhLm5hbWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0RnVuY05hbWU7XG4iLCJ2YXIgYmFzZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX2Jhc2VDcmVhdGUnKSxcbiAgICBiYXNlTG9kYXNoID0gcmVxdWlyZSgnLi9fYmFzZUxvZGFzaCcpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGNvbnN0cnVjdG9yIGZvciBjcmVhdGluZyBgbG9kYXNoYCB3cmFwcGVyIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtjaGFpbkFsbF0gRW5hYmxlIGV4cGxpY2l0IG1ldGhvZCBjaGFpbiBzZXF1ZW5jZXMuXG4gKi9cbmZ1bmN0aW9uIExvZGFzaFdyYXBwZXIodmFsdWUsIGNoYWluQWxsKSB7XG4gIHRoaXMuX193cmFwcGVkX18gPSB2YWx1ZTtcbiAgdGhpcy5fX2FjdGlvbnNfXyA9IFtdO1xuICB0aGlzLl9fY2hhaW5fXyA9ICEhY2hhaW5BbGw7XG4gIHRoaXMuX19pbmRleF9fID0gMDtcbiAgdGhpcy5fX3ZhbHVlc19fID0gdW5kZWZpbmVkO1xufVxuXG5Mb2Rhc2hXcmFwcGVyLnByb3RvdHlwZSA9IGJhc2VDcmVhdGUoYmFzZUxvZGFzaC5wcm90b3R5cGUpO1xuTG9kYXNoV3JhcHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMb2Rhc2hXcmFwcGVyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExvZGFzaFdyYXBwZXI7XG4iLCJ2YXIgTGF6eVdyYXBwZXIgPSByZXF1aXJlKCcuL19MYXp5V3JhcHBlcicpLFxuICAgIExvZGFzaFdyYXBwZXIgPSByZXF1aXJlKCcuL19Mb2Rhc2hXcmFwcGVyJyksXG4gICAgY29weUFycmF5ID0gcmVxdWlyZSgnLi9fY29weUFycmF5Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGB3cmFwcGVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHdyYXBwZXIgVGhlIHdyYXBwZXIgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgd3JhcHBlci5cbiAqL1xuZnVuY3Rpb24gd3JhcHBlckNsb25lKHdyYXBwZXIpIHtcbiAgaWYgKHdyYXBwZXIgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcikge1xuICAgIHJldHVybiB3cmFwcGVyLmNsb25lKCk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IG5ldyBMb2Rhc2hXcmFwcGVyKHdyYXBwZXIuX193cmFwcGVkX18sIHdyYXBwZXIuX19jaGFpbl9fKTtcbiAgcmVzdWx0Ll9fYWN0aW9uc19fID0gY29weUFycmF5KHdyYXBwZXIuX19hY3Rpb25zX18pO1xuICByZXN1bHQuX19pbmRleF9fICA9IHdyYXBwZXIuX19pbmRleF9fO1xuICByZXN1bHQuX192YWx1ZXNfXyA9IHdyYXBwZXIuX192YWx1ZXNfXztcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3cmFwcGVyQ2xvbmU7XG4iLCJ2YXIgTGF6eVdyYXBwZXIgPSByZXF1aXJlKCcuL19MYXp5V3JhcHBlcicpLFxuICAgIExvZGFzaFdyYXBwZXIgPSByZXF1aXJlKCcuL19Mb2Rhc2hXcmFwcGVyJyksXG4gICAgYmFzZUxvZGFzaCA9IHJlcXVpcmUoJy4vX2Jhc2VMb2Rhc2gnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKSxcbiAgICB3cmFwcGVyQ2xvbmUgPSByZXF1aXJlKCcuL193cmFwcGVyQ2xvbmUnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgYGxvZGFzaGAgb2JqZWN0IHdoaWNoIHdyYXBzIGB2YWx1ZWAgdG8gZW5hYmxlIGltcGxpY2l0IG1ldGhvZFxuICogY2hhaW4gc2VxdWVuY2VzLiBNZXRob2RzIHRoYXQgb3BlcmF0ZSBvbiBhbmQgcmV0dXJuIGFycmF5cywgY29sbGVjdGlvbnMsXG4gKiBhbmQgZnVuY3Rpb25zIGNhbiBiZSBjaGFpbmVkIHRvZ2V0aGVyLiBNZXRob2RzIHRoYXQgcmV0cmlldmUgYSBzaW5nbGUgdmFsdWVcbiAqIG9yIG1heSByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUgd2lsbCBhdXRvbWF0aWNhbGx5IGVuZCB0aGUgY2hhaW4gc2VxdWVuY2VcbiAqIGFuZCByZXR1cm4gdGhlIHVud3JhcHBlZCB2YWx1ZS4gT3RoZXJ3aXNlLCB0aGUgdmFsdWUgbXVzdCBiZSB1bndyYXBwZWRcbiAqIHdpdGggYF8jdmFsdWVgLlxuICpcbiAqIEV4cGxpY2l0IGNoYWluIHNlcXVlbmNlcywgd2hpY2ggbXVzdCBiZSB1bndyYXBwZWQgd2l0aCBgXyN2YWx1ZWAsIG1heSBiZVxuICogZW5hYmxlZCB1c2luZyBgXy5jaGFpbmAuXG4gKlxuICogVGhlIGV4ZWN1dGlvbiBvZiBjaGFpbmVkIG1ldGhvZHMgaXMgbGF6eSwgdGhhdCBpcywgaXQncyBkZWZlcnJlZCB1bnRpbFxuICogYF8jdmFsdWVgIGlzIGltcGxpY2l0bHkgb3IgZXhwbGljaXRseSBjYWxsZWQuXG4gKlxuICogTGF6eSBldmFsdWF0aW9uIGFsbG93cyBzZXZlcmFsIG1ldGhvZHMgdG8gc3VwcG9ydCBzaG9ydGN1dCBmdXNpb24uXG4gKiBTaG9ydGN1dCBmdXNpb24gaXMgYW4gb3B0aW1pemF0aW9uIHRvIG1lcmdlIGl0ZXJhdGVlIGNhbGxzOyB0aGlzIGF2b2lkc1xuICogdGhlIGNyZWF0aW9uIG9mIGludGVybWVkaWF0ZSBhcnJheXMgYW5kIGNhbiBncmVhdGx5IHJlZHVjZSB0aGUgbnVtYmVyIG9mXG4gKiBpdGVyYXRlZSBleGVjdXRpb25zLiBTZWN0aW9ucyBvZiBhIGNoYWluIHNlcXVlbmNlIHF1YWxpZnkgZm9yIHNob3J0Y3V0XG4gKiBmdXNpb24gaWYgdGhlIHNlY3Rpb24gaXMgYXBwbGllZCB0byBhbiBhcnJheSBhbmQgaXRlcmF0ZWVzIGFjY2VwdCBvbmx5XG4gKiBvbmUgYXJndW1lbnQuIFRoZSBoZXVyaXN0aWMgZm9yIHdoZXRoZXIgYSBzZWN0aW9uIHF1YWxpZmllcyBmb3Igc2hvcnRjdXRcbiAqIGZ1c2lvbiBpcyBzdWJqZWN0IHRvIGNoYW5nZS5cbiAqXG4gKiBDaGFpbmluZyBpcyBzdXBwb3J0ZWQgaW4gY3VzdG9tIGJ1aWxkcyBhcyBsb25nIGFzIHRoZSBgXyN2YWx1ZWAgbWV0aG9kIGlzXG4gKiBkaXJlY3RseSBvciBpbmRpcmVjdGx5IGluY2x1ZGVkIGluIHRoZSBidWlsZC5cbiAqXG4gKiBJbiBhZGRpdGlvbiB0byBsb2Rhc2ggbWV0aG9kcywgd3JhcHBlcnMgaGF2ZSBgQXJyYXlgIGFuZCBgU3RyaW5nYCBtZXRob2RzLlxuICpcbiAqIFRoZSB3cmFwcGVyIGBBcnJheWAgbWV0aG9kcyBhcmU6XG4gKiBgY29uY2F0YCwgYGpvaW5gLCBgcG9wYCwgYHB1c2hgLCBgc2hpZnRgLCBgc29ydGAsIGBzcGxpY2VgLCBhbmQgYHVuc2hpZnRgXG4gKlxuICogVGhlIHdyYXBwZXIgYFN0cmluZ2AgbWV0aG9kcyBhcmU6XG4gKiBgcmVwbGFjZWAgYW5kIGBzcGxpdGBcbiAqXG4gKiBUaGUgd3JhcHBlciBtZXRob2RzIHRoYXQgc3VwcG9ydCBzaG9ydGN1dCBmdXNpb24gYXJlOlxuICogYGF0YCwgYGNvbXBhY3RgLCBgZHJvcGAsIGBkcm9wUmlnaHRgLCBgZHJvcFdoaWxlYCwgYGZpbHRlcmAsIGBmaW5kYCxcbiAqIGBmaW5kTGFzdGAsIGBoZWFkYCwgYGluaXRpYWxgLCBgbGFzdGAsIGBtYXBgLCBgcmVqZWN0YCwgYHJldmVyc2VgLCBgc2xpY2VgLFxuICogYHRhaWxgLCBgdGFrZWAsIGB0YWtlUmlnaHRgLCBgdGFrZVJpZ2h0V2hpbGVgLCBgdGFrZVdoaWxlYCwgYW5kIGB0b0FycmF5YFxuICpcbiAqIFRoZSBjaGFpbmFibGUgd3JhcHBlciBtZXRob2RzIGFyZTpcbiAqIGBhZnRlcmAsIGBhcnlgLCBgYXNzaWduYCwgYGFzc2lnbkluYCwgYGFzc2lnbkluV2l0aGAsIGBhc3NpZ25XaXRoYCwgYGF0YCxcbiAqIGBiZWZvcmVgLCBgYmluZGAsIGBiaW5kQWxsYCwgYGJpbmRLZXlgLCBgY2FzdEFycmF5YCwgYGNoYWluYCwgYGNodW5rYCxcbiAqIGBjb21taXRgLCBgY29tcGFjdGAsIGBjb25jYXRgLCBgY29uZm9ybXNgLCBgY29uc3RhbnRgLCBgY291bnRCeWAsIGBjcmVhdGVgLFxuICogYGN1cnJ5YCwgYGRlYm91bmNlYCwgYGRlZmF1bHRzYCwgYGRlZmF1bHRzRGVlcGAsIGBkZWZlcmAsIGBkZWxheWAsXG4gKiBgZGlmZmVyZW5jZWAsIGBkaWZmZXJlbmNlQnlgLCBgZGlmZmVyZW5jZVdpdGhgLCBgZHJvcGAsIGBkcm9wUmlnaHRgLFxuICogYGRyb3BSaWdodFdoaWxlYCwgYGRyb3BXaGlsZWAsIGBleHRlbmRgLCBgZXh0ZW5kV2l0aGAsIGBmaWxsYCwgYGZpbHRlcmAsXG4gKiBgZmxhdE1hcGAsIGBmbGF0TWFwRGVlcGAsIGBmbGF0TWFwRGVwdGhgLCBgZmxhdHRlbmAsIGBmbGF0dGVuRGVlcGAsXG4gKiBgZmxhdHRlbkRlcHRoYCwgYGZsaXBgLCBgZmxvd2AsIGBmbG93UmlnaHRgLCBgZnJvbVBhaXJzYCwgYGZ1bmN0aW9uc2AsXG4gKiBgZnVuY3Rpb25zSW5gLCBgZ3JvdXBCeWAsIGBpbml0aWFsYCwgYGludGVyc2VjdGlvbmAsIGBpbnRlcnNlY3Rpb25CeWAsXG4gKiBgaW50ZXJzZWN0aW9uV2l0aGAsIGBpbnZlcnRgLCBgaW52ZXJ0QnlgLCBgaW52b2tlTWFwYCwgYGl0ZXJhdGVlYCwgYGtleUJ5YCxcbiAqIGBrZXlzYCwgYGtleXNJbmAsIGBtYXBgLCBgbWFwS2V5c2AsIGBtYXBWYWx1ZXNgLCBgbWF0Y2hlc2AsIGBtYXRjaGVzUHJvcGVydHlgLFxuICogYG1lbW9pemVgLCBgbWVyZ2VgLCBgbWVyZ2VXaXRoYCwgYG1ldGhvZGAsIGBtZXRob2RPZmAsIGBtaXhpbmAsIGBuZWdhdGVgLFxuICogYG50aEFyZ2AsIGBvbWl0YCwgYG9taXRCeWAsIGBvbmNlYCwgYG9yZGVyQnlgLCBgb3ZlcmAsIGBvdmVyQXJnc2AsXG4gKiBgb3ZlckV2ZXJ5YCwgYG92ZXJTb21lYCwgYHBhcnRpYWxgLCBgcGFydGlhbFJpZ2h0YCwgYHBhcnRpdGlvbmAsIGBwaWNrYCxcbiAqIGBwaWNrQnlgLCBgcGxhbnRgLCBgcHJvcGVydHlgLCBgcHJvcGVydHlPZmAsIGBwdWxsYCwgYHB1bGxBbGxgLCBgcHVsbEFsbEJ5YCxcbiAqIGBwdWxsQWxsV2l0aGAsIGBwdWxsQXRgLCBgcHVzaGAsIGByYW5nZWAsIGByYW5nZVJpZ2h0YCwgYHJlYXJnYCwgYHJlamVjdGAsXG4gKiBgcmVtb3ZlYCwgYHJlc3RgLCBgcmV2ZXJzZWAsIGBzYW1wbGVTaXplYCwgYHNldGAsIGBzZXRXaXRoYCwgYHNodWZmbGVgLFxuICogYHNsaWNlYCwgYHNvcnRgLCBgc29ydEJ5YCwgYHNwbGljZWAsIGBzcHJlYWRgLCBgdGFpbGAsIGB0YWtlYCwgYHRha2VSaWdodGAsXG4gKiBgdGFrZVJpZ2h0V2hpbGVgLCBgdGFrZVdoaWxlYCwgYHRhcGAsIGB0aHJvdHRsZWAsIGB0aHJ1YCwgYHRvQXJyYXlgLFxuICogYHRvUGFpcnNgLCBgdG9QYWlyc0luYCwgYHRvUGF0aGAsIGB0b1BsYWluT2JqZWN0YCwgYHRyYW5zZm9ybWAsIGB1bmFyeWAsXG4gKiBgdW5pb25gLCBgdW5pb25CeWAsIGB1bmlvbldpdGhgLCBgdW5pcWAsIGB1bmlxQnlgLCBgdW5pcVdpdGhgLCBgdW5zZXRgLFxuICogYHVuc2hpZnRgLCBgdW56aXBgLCBgdW56aXBXaXRoYCwgYHVwZGF0ZWAsIGB1cGRhdGVXaXRoYCwgYHZhbHVlc2AsXG4gKiBgdmFsdWVzSW5gLCBgd2l0aG91dGAsIGB3cmFwYCwgYHhvcmAsIGB4b3JCeWAsIGB4b3JXaXRoYCwgYHppcGAsXG4gKiBgemlwT2JqZWN0YCwgYHppcE9iamVjdERlZXBgLCBhbmQgYHppcFdpdGhgXG4gKlxuICogVGhlIHdyYXBwZXIgbWV0aG9kcyB0aGF0IGFyZSAqKm5vdCoqIGNoYWluYWJsZSBieSBkZWZhdWx0IGFyZTpcbiAqIGBhZGRgLCBgYXR0ZW1wdGAsIGBjYW1lbENhc2VgLCBgY2FwaXRhbGl6ZWAsIGBjZWlsYCwgYGNsYW1wYCwgYGNsb25lYCxcbiAqIGBjbG9uZURlZXBgLCBgY2xvbmVEZWVwV2l0aGAsIGBjbG9uZVdpdGhgLCBgY29uZm9ybXNUb2AsIGBkZWJ1cnJgLFxuICogYGRlZmF1bHRUb2AsIGBkaXZpZGVgLCBgZWFjaGAsIGBlYWNoUmlnaHRgLCBgZW5kc1dpdGhgLCBgZXFgLCBgZXNjYXBlYCxcbiAqIGBlc2NhcGVSZWdFeHBgLCBgZXZlcnlgLCBgZmluZGAsIGBmaW5kSW5kZXhgLCBgZmluZEtleWAsIGBmaW5kTGFzdGAsXG4gKiBgZmluZExhc3RJbmRleGAsIGBmaW5kTGFzdEtleWAsIGBmaXJzdGAsIGBmbG9vcmAsIGBmb3JFYWNoYCwgYGZvckVhY2hSaWdodGAsXG4gKiBgZm9ySW5gLCBgZm9ySW5SaWdodGAsIGBmb3JPd25gLCBgZm9yT3duUmlnaHRgLCBgZ2V0YCwgYGd0YCwgYGd0ZWAsIGBoYXNgLFxuICogYGhhc0luYCwgYGhlYWRgLCBgaWRlbnRpdHlgLCBgaW5jbHVkZXNgLCBgaW5kZXhPZmAsIGBpblJhbmdlYCwgYGludm9rZWAsXG4gKiBgaXNBcmd1bWVudHNgLCBgaXNBcnJheWAsIGBpc0FycmF5QnVmZmVyYCwgYGlzQXJyYXlMaWtlYCwgYGlzQXJyYXlMaWtlT2JqZWN0YCxcbiAqIGBpc0Jvb2xlYW5gLCBgaXNCdWZmZXJgLCBgaXNEYXRlYCwgYGlzRWxlbWVudGAsIGBpc0VtcHR5YCwgYGlzRXF1YWxgLFxuICogYGlzRXF1YWxXaXRoYCwgYGlzRXJyb3JgLCBgaXNGaW5pdGVgLCBgaXNGdW5jdGlvbmAsIGBpc0ludGVnZXJgLCBgaXNMZW5ndGhgLFxuICogYGlzTWFwYCwgYGlzTWF0Y2hgLCBgaXNNYXRjaFdpdGhgLCBgaXNOYU5gLCBgaXNOYXRpdmVgLCBgaXNOaWxgLCBgaXNOdWxsYCxcbiAqIGBpc051bWJlcmAsIGBpc09iamVjdGAsIGBpc09iamVjdExpa2VgLCBgaXNQbGFpbk9iamVjdGAsIGBpc1JlZ0V4cGAsXG4gKiBgaXNTYWZlSW50ZWdlcmAsIGBpc1NldGAsIGBpc1N0cmluZ2AsIGBpc1VuZGVmaW5lZGAsIGBpc1R5cGVkQXJyYXlgLFxuICogYGlzV2Vha01hcGAsIGBpc1dlYWtTZXRgLCBgam9pbmAsIGBrZWJhYkNhc2VgLCBgbGFzdGAsIGBsYXN0SW5kZXhPZmAsXG4gKiBgbG93ZXJDYXNlYCwgYGxvd2VyRmlyc3RgLCBgbHRgLCBgbHRlYCwgYG1heGAsIGBtYXhCeWAsIGBtZWFuYCwgYG1lYW5CeWAsXG4gKiBgbWluYCwgYG1pbkJ5YCwgYG11bHRpcGx5YCwgYG5vQ29uZmxpY3RgLCBgbm9vcGAsIGBub3dgLCBgbnRoYCwgYHBhZGAsXG4gKiBgcGFkRW5kYCwgYHBhZFN0YXJ0YCwgYHBhcnNlSW50YCwgYHBvcGAsIGByYW5kb21gLCBgcmVkdWNlYCwgYHJlZHVjZVJpZ2h0YCxcbiAqIGByZXBlYXRgLCBgcmVzdWx0YCwgYHJvdW5kYCwgYHJ1bkluQ29udGV4dGAsIGBzYW1wbGVgLCBgc2hpZnRgLCBgc2l6ZWAsXG4gKiBgc25ha2VDYXNlYCwgYHNvbWVgLCBgc29ydGVkSW5kZXhgLCBgc29ydGVkSW5kZXhCeWAsIGBzb3J0ZWRMYXN0SW5kZXhgLFxuICogYHNvcnRlZExhc3RJbmRleEJ5YCwgYHN0YXJ0Q2FzZWAsIGBzdGFydHNXaXRoYCwgYHN0dWJBcnJheWAsIGBzdHViRmFsc2VgLFxuICogYHN0dWJPYmplY3RgLCBgc3R1YlN0cmluZ2AsIGBzdHViVHJ1ZWAsIGBzdWJ0cmFjdGAsIGBzdW1gLCBgc3VtQnlgLFxuICogYHRlbXBsYXRlYCwgYHRpbWVzYCwgYHRvRmluaXRlYCwgYHRvSW50ZWdlcmAsIGB0b0pTT05gLCBgdG9MZW5ndGhgLFxuICogYHRvTG93ZXJgLCBgdG9OdW1iZXJgLCBgdG9TYWZlSW50ZWdlcmAsIGB0b1N0cmluZ2AsIGB0b1VwcGVyYCwgYHRyaW1gLFxuICogYHRyaW1FbmRgLCBgdHJpbVN0YXJ0YCwgYHRydW5jYXRlYCwgYHVuZXNjYXBlYCwgYHVuaXF1ZUlkYCwgYHVwcGVyQ2FzZWAsXG4gKiBgdXBwZXJGaXJzdGAsIGB2YWx1ZWAsIGFuZCBgd29yZHNgXG4gKlxuICogQG5hbWUgX1xuICogQGNvbnN0cnVjdG9yXG4gKiBAY2F0ZWdvcnkgU2VxXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwIGluIGEgYGxvZGFzaGAgaW5zdGFuY2UuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAqICAgcmV0dXJuIG4gKiBuO1xuICogfVxuICpcbiAqIHZhciB3cmFwcGVkID0gXyhbMSwgMiwgM10pO1xuICpcbiAqIC8vIFJldHVybnMgYW4gdW53cmFwcGVkIHZhbHVlLlxuICogd3JhcHBlZC5yZWR1Y2UoXy5hZGQpO1xuICogLy8gPT4gNlxuICpcbiAqIC8vIFJldHVybnMgYSB3cmFwcGVkIHZhbHVlLlxuICogdmFyIHNxdWFyZXMgPSB3cmFwcGVkLm1hcChzcXVhcmUpO1xuICpcbiAqIF8uaXNBcnJheShzcXVhcmVzKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KHNxdWFyZXMudmFsdWUoKSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGxvZGFzaCh2YWx1ZSkge1xuICBpZiAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiAhaXNBcnJheSh2YWx1ZSkgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExvZGFzaFdyYXBwZXIpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdfX3dyYXBwZWRfXycpKSB7XG4gICAgICByZXR1cm4gd3JhcHBlckNsb25lKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHZhbHVlKTtcbn1cblxuLy8gRW5zdXJlIHdyYXBwZXJzIGFyZSBpbnN0YW5jZXMgb2YgYGJhc2VMb2Rhc2hgLlxubG9kYXNoLnByb3RvdHlwZSA9IGJhc2VMb2Rhc2gucHJvdG90eXBlO1xubG9kYXNoLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGxvZGFzaDtcblxubW9kdWxlLmV4cG9ydHMgPSBsb2Rhc2g7XG4iLCJ2YXIgTGF6eVdyYXBwZXIgPSByZXF1aXJlKCcuL19MYXp5V3JhcHBlcicpLFxuICAgIGdldERhdGEgPSByZXF1aXJlKCcuL19nZXREYXRhJyksXG4gICAgZ2V0RnVuY05hbWUgPSByZXF1aXJlKCcuL19nZXRGdW5jTmFtZScpLFxuICAgIGxvZGFzaCA9IHJlcXVpcmUoJy4vd3JhcHBlckxvZGFzaCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGEgbGF6eSBjb3VudGVycGFydC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGhhcyBhIGxhenkgY291bnRlcnBhcnQsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0xhemlhYmxlKGZ1bmMpIHtcbiAgdmFyIGZ1bmNOYW1lID0gZ2V0RnVuY05hbWUoZnVuYyksXG4gICAgICBvdGhlciA9IGxvZGFzaFtmdW5jTmFtZV07XG5cbiAgaWYgKHR5cGVvZiBvdGhlciAhPSAnZnVuY3Rpb24nIHx8ICEoZnVuY05hbWUgaW4gTGF6eVdyYXBwZXIucHJvdG90eXBlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZnVuYyA9PT0gb3RoZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgZGF0YSA9IGdldERhdGEob3RoZXIpO1xuICByZXR1cm4gISFkYXRhICYmIGZ1bmMgPT09IGRhdGFbMF07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNMYXppYWJsZTtcbiIsInZhciBiYXNlU2V0RGF0YSA9IHJlcXVpcmUoJy4vX2Jhc2VTZXREYXRhJyksXG4gICAgc2hvcnRPdXQgPSByZXF1aXJlKCcuL19zaG9ydE91dCcpO1xuXG4vKipcbiAqIFNldHMgbWV0YWRhdGEgZm9yIGBmdW5jYC5cbiAqXG4gKiAqKk5vdGU6KiogSWYgdGhpcyBmdW5jdGlvbiBiZWNvbWVzIGhvdCwgaS5lLiBpcyBpbnZva2VkIGEgbG90IGluIGEgc2hvcnRcbiAqIHBlcmlvZCBvZiB0aW1lLCBpdCB3aWxsIHRyaXAgaXRzIGJyZWFrZXIgYW5kIHRyYW5zaXRpb24gdG8gYW4gaWRlbnRpdHlcbiAqIGZ1bmN0aW9uIHRvIGF2b2lkIGdhcmJhZ2UgY29sbGVjdGlvbiBwYXVzZXMgaW4gVjguIFNlZVxuICogW1Y4IGlzc3VlIDIwNzBdKGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIwNzApXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhc3NvY2lhdGUgbWV0YWRhdGEgd2l0aC5cbiAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWV0YWRhdGEuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovXG52YXIgc2V0RGF0YSA9IHNob3J0T3V0KGJhc2VTZXREYXRhKTtcblxubW9kdWxlLmV4cG9ydHMgPSBzZXREYXRhO1xuIiwiLyoqIFVzZWQgdG8gbWF0Y2ggd3JhcCBkZXRhaWwgY29tbWVudHMuICovXG52YXIgcmVXcmFwRGV0YWlscyA9IC9cXHtcXG5cXC9cXCogXFxbd3JhcHBlZCB3aXRoICguKylcXF0gXFwqLyxcbiAgICByZVNwbGl0RGV0YWlscyA9IC8sPyAmIC87XG5cbi8qKlxuICogRXh0cmFjdHMgd3JhcHBlciBkZXRhaWxzIGZyb20gdGhlIGBzb3VyY2VgIGJvZHkgY29tbWVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSBUaGUgc291cmNlIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdyYXBwZXIgZGV0YWlscy5cbiAqL1xuZnVuY3Rpb24gZ2V0V3JhcERldGFpbHMoc291cmNlKSB7XG4gIHZhciBtYXRjaCA9IHNvdXJjZS5tYXRjaChyZVdyYXBEZXRhaWxzKTtcbiAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0uc3BsaXQocmVTcGxpdERldGFpbHMpIDogW107XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0V3JhcERldGFpbHM7XG4iLCIvKiogVXNlZCB0byBtYXRjaCB3cmFwIGRldGFpbCBjb21tZW50cy4gKi9cbnZhciByZVdyYXBDb21tZW50ID0gL1xceyg/OlxcblxcL1xcKiBcXFt3cmFwcGVkIHdpdGggLitcXF0gXFwqXFwvKT9cXG4/LztcblxuLyoqXG4gKiBJbnNlcnRzIHdyYXBwZXIgYGRldGFpbHNgIGluIGEgY29tbWVudCBhdCB0aGUgdG9wIG9mIHRoZSBgc291cmNlYCBib2R5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc291cmNlIFRoZSBzb3VyY2UgdG8gbW9kaWZ5LlxuICogQHJldHVybnMge0FycmF5fSBkZXRhaWxzIFRoZSBkZXRhaWxzIHRvIGluc2VydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIG1vZGlmaWVkIHNvdXJjZS5cbiAqL1xuZnVuY3Rpb24gaW5zZXJ0V3JhcERldGFpbHMoc291cmNlLCBkZXRhaWxzKSB7XG4gIHZhciBsZW5ndGggPSBkZXRhaWxzLmxlbmd0aDtcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICByZXR1cm4gc291cmNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBsZW5ndGggLSAxO1xuICBkZXRhaWxzW2xhc3RJbmRleF0gPSAobGVuZ3RoID4gMSA/ICcmICcgOiAnJykgKyBkZXRhaWxzW2xhc3RJbmRleF07XG4gIGRldGFpbHMgPSBkZXRhaWxzLmpvaW4obGVuZ3RoID4gMiA/ICcsICcgOiAnICcpO1xuICByZXR1cm4gc291cmNlLnJlcGxhY2UocmVXcmFwQ29tbWVudCwgJ3tcXG4vKiBbd3JhcHBlZCB3aXRoICcgKyBkZXRhaWxzICsgJ10gKi9cXG4nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbnNlcnRXcmFwRGV0YWlscztcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmluZEluZGV4YCBhbmQgYF8uZmluZExhc3RJbmRleGAgd2l0aG91dFxuICogc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBiYXNlRmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCwgZnJvbVJpZ2h0KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBpbmRleCA9IGZyb21JbmRleCArIChmcm9tUmlnaHQgPyAxIDogLTEpO1xuXG4gIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGaW5kSW5kZXg7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmFOYCB3aXRob3V0IHN1cHBvcnQgZm9yIG51bWJlciBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGBOYU5gLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hTih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc05hTjtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmluZGV4T2ZgIHdoaWNoIHBlcmZvcm1zIHN0cmljdCBlcXVhbGl0eVxuICogY29tcGFyaXNvbnMgb2YgdmFsdWVzLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIHN0cmljdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgdmFyIGluZGV4ID0gZnJvbUluZGV4IC0gMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpY3RJbmRleE9mO1xuIiwidmFyIGJhc2VGaW5kSW5kZXggPSByZXF1aXJlKCcuL19iYXNlRmluZEluZGV4JyksXG4gICAgYmFzZUlzTmFOID0gcmVxdWlyZSgnLi9fYmFzZUlzTmFOJyksXG4gICAgc3RyaWN0SW5kZXhPZiA9IHJlcXVpcmUoJy4vX3N0cmljdEluZGV4T2YnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pbmRleE9mYCB3aXRob3V0IGBmcm9tSW5kZXhgIGJvdW5kcyBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZVxuICAgID8gc3RyaWN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleClcbiAgICA6IGJhc2VGaW5kSW5kZXgoYXJyYXksIGJhc2VJc05hTiwgZnJvbUluZGV4KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSW5kZXhPZjtcbiIsInZhciBiYXNlSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Jhc2VJbmRleE9mJyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmluY2x1ZGVzYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIHNwZWNpZnlpbmcgYW4gaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHRhcmdldCBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdGFyZ2V0YCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheUluY2x1ZGVzKGFycmF5LCB2YWx1ZSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gIHJldHVybiAhIWxlbmd0aCAmJiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIDApID4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlJbmNsdWRlcztcbiIsInZhciBhcnJheUVhY2ggPSByZXF1aXJlKCcuL19hcnJheUVhY2gnKSxcbiAgICBhcnJheUluY2x1ZGVzID0gcmVxdWlyZSgnLi9fYXJyYXlJbmNsdWRlcycpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBmdW5jdGlvbiBtZXRhZGF0YS4gKi9cbnZhciBXUkFQX0JJTkRfRkxBRyA9IDEsXG4gICAgV1JBUF9CSU5EX0tFWV9GTEFHID0gMixcbiAgICBXUkFQX0NVUlJZX0ZMQUcgPSA4LFxuICAgIFdSQVBfQ1VSUllfUklHSFRfRkxBRyA9IDE2LFxuICAgIFdSQVBfUEFSVElBTF9GTEFHID0gMzIsXG4gICAgV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcgPSA2NCxcbiAgICBXUkFQX0FSWV9GTEFHID0gMTI4LFxuICAgIFdSQVBfUkVBUkdfRkxBRyA9IDI1NixcbiAgICBXUkFQX0ZMSVBfRkxBRyA9IDUxMjtcblxuLyoqIFVzZWQgdG8gYXNzb2NpYXRlIHdyYXAgbWV0aG9kcyB3aXRoIHRoZWlyIGJpdCBmbGFncy4gKi9cbnZhciB3cmFwRmxhZ3MgPSBbXG4gIFsnYXJ5JywgV1JBUF9BUllfRkxBR10sXG4gIFsnYmluZCcsIFdSQVBfQklORF9GTEFHXSxcbiAgWydiaW5kS2V5JywgV1JBUF9CSU5EX0tFWV9GTEFHXSxcbiAgWydjdXJyeScsIFdSQVBfQ1VSUllfRkxBR10sXG4gIFsnY3VycnlSaWdodCcsIFdSQVBfQ1VSUllfUklHSFRfRkxBR10sXG4gIFsnZmxpcCcsIFdSQVBfRkxJUF9GTEFHXSxcbiAgWydwYXJ0aWFsJywgV1JBUF9QQVJUSUFMX0ZMQUddLFxuICBbJ3BhcnRpYWxSaWdodCcsIFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHXSxcbiAgWydyZWFyZycsIFdSQVBfUkVBUkdfRkxBR11cbl07XG5cbi8qKlxuICogVXBkYXRlcyB3cmFwcGVyIGBkZXRhaWxzYCBiYXNlZCBvbiBgYml0bWFza2AgZmxhZ3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEByZXR1cm5zIHtBcnJheX0gZGV0YWlscyBUaGUgZGV0YWlscyB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBkZXRhaWxzYC5cbiAqL1xuZnVuY3Rpb24gdXBkYXRlV3JhcERldGFpbHMoZGV0YWlscywgYml0bWFzaykge1xuICBhcnJheUVhY2god3JhcEZsYWdzLCBmdW5jdGlvbihwYWlyKSB7XG4gICAgdmFyIHZhbHVlID0gJ18uJyArIHBhaXJbMF07XG4gICAgaWYgKChiaXRtYXNrICYgcGFpclsxXSkgJiYgIWFycmF5SW5jbHVkZXMoZGV0YWlscywgdmFsdWUpKSB7XG4gICAgICBkZXRhaWxzLnB1c2godmFsdWUpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBkZXRhaWxzLnNvcnQoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB1cGRhdGVXcmFwRGV0YWlscztcbiIsInZhciBnZXRXcmFwRGV0YWlscyA9IHJlcXVpcmUoJy4vX2dldFdyYXBEZXRhaWxzJyksXG4gICAgaW5zZXJ0V3JhcERldGFpbHMgPSByZXF1aXJlKCcuL19pbnNlcnRXcmFwRGV0YWlscycpLFxuICAgIHNldFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fc2V0VG9TdHJpbmcnKSxcbiAgICB1cGRhdGVXcmFwRGV0YWlscyA9IHJlcXVpcmUoJy4vX3VwZGF0ZVdyYXBEZXRhaWxzJyk7XG5cbi8qKlxuICogU2V0cyB0aGUgYHRvU3RyaW5nYCBtZXRob2Qgb2YgYHdyYXBwZXJgIHRvIG1pbWljIHRoZSBzb3VyY2Ugb2YgYHJlZmVyZW5jZWBcbiAqIHdpdGggd3JhcHBlciBkZXRhaWxzIGluIGEgY29tbWVudCBhdCB0aGUgdG9wIG9mIHRoZSBzb3VyY2UgYm9keS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gd3JhcHBlciBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVmZXJlbmNlIFRoZSByZWZlcmVuY2UgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGB3cmFwcGVyYC5cbiAqL1xuZnVuY3Rpb24gc2V0V3JhcFRvU3RyaW5nKHdyYXBwZXIsIHJlZmVyZW5jZSwgYml0bWFzaykge1xuICB2YXIgc291cmNlID0gKHJlZmVyZW5jZSArICcnKTtcbiAgcmV0dXJuIHNldFRvU3RyaW5nKHdyYXBwZXIsIGluc2VydFdyYXBEZXRhaWxzKHNvdXJjZSwgdXBkYXRlV3JhcERldGFpbHMoZ2V0V3JhcERldGFpbHMoc291cmNlKSwgYml0bWFzaykpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRXcmFwVG9TdHJpbmc7XG4iLCJ2YXIgaXNMYXppYWJsZSA9IHJlcXVpcmUoJy4vX2lzTGF6aWFibGUnKSxcbiAgICBzZXREYXRhID0gcmVxdWlyZSgnLi9fc2V0RGF0YScpLFxuICAgIHNldFdyYXBUb1N0cmluZyA9IHJlcXVpcmUoJy4vX3NldFdyYXBUb1N0cmluZycpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBmdW5jdGlvbiBtZXRhZGF0YS4gKi9cbnZhciBXUkFQX0JJTkRfRkxBRyA9IDEsXG4gICAgV1JBUF9CSU5EX0tFWV9GTEFHID0gMixcbiAgICBXUkFQX0NVUlJZX0JPVU5EX0ZMQUcgPSA0LFxuICAgIFdSQVBfQ1VSUllfRkxBRyA9IDgsXG4gICAgV1JBUF9QQVJUSUFMX0ZMQUcgPSAzMixcbiAgICBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRyA9IDY0O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCB0byBjb250aW51ZSBjdXJyeWluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB3cmFwRnVuYyBUaGUgZnVuY3Rpb24gdG8gY3JlYXRlIHRoZSBgZnVuY2Agd3JhcHBlci5cbiAqIEBwYXJhbSB7Kn0gcGxhY2Vob2xkZXIgVGhlIHBsYWNlaG9sZGVyIHZhbHVlLlxuICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBwcmVwZW5kIHRvIHRob3NlIHByb3ZpZGVkIHRvXG4gKiAgdGhlIG5ldyBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7QXJyYXl9IFtob2xkZXJzXSBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICogQHBhcmFtIHtBcnJheX0gW2FyZ1Bvc10gVGhlIGFyZ3VtZW50IHBvc2l0aW9ucyBvZiB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFthcnldIFRoZSBhcml0eSBjYXAgb2YgYGZ1bmNgLlxuICogQHBhcmFtIHtudW1iZXJ9IFthcml0eV0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJlY3VycnkoZnVuYywgYml0bWFzaywgd3JhcEZ1bmMsIHBsYWNlaG9sZGVyLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycywgYXJnUG9zLCBhcnksIGFyaXR5KSB7XG4gIHZhciBpc0N1cnJ5ID0gYml0bWFzayAmIFdSQVBfQ1VSUllfRkxBRyxcbiAgICAgIG5ld0hvbGRlcnMgPSBpc0N1cnJ5ID8gaG9sZGVycyA6IHVuZGVmaW5lZCxcbiAgICAgIG5ld0hvbGRlcnNSaWdodCA9IGlzQ3VycnkgPyB1bmRlZmluZWQgOiBob2xkZXJzLFxuICAgICAgbmV3UGFydGlhbHMgPSBpc0N1cnJ5ID8gcGFydGlhbHMgOiB1bmRlZmluZWQsXG4gICAgICBuZXdQYXJ0aWFsc1JpZ2h0ID0gaXNDdXJyeSA/IHVuZGVmaW5lZCA6IHBhcnRpYWxzO1xuXG4gIGJpdG1hc2sgfD0gKGlzQ3VycnkgPyBXUkFQX1BBUlRJQUxfRkxBRyA6IFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHKTtcbiAgYml0bWFzayAmPSB+KGlzQ3VycnkgPyBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRyA6IFdSQVBfUEFSVElBTF9GTEFHKTtcblxuICBpZiAoIShiaXRtYXNrICYgV1JBUF9DVVJSWV9CT1VORF9GTEFHKSkge1xuICAgIGJpdG1hc2sgJj0gfihXUkFQX0JJTkRfRkxBRyB8IFdSQVBfQklORF9LRVlfRkxBRyk7XG4gIH1cbiAgdmFyIG5ld0RhdGEgPSBbXG4gICAgZnVuYywgYml0bWFzaywgdGhpc0FyZywgbmV3UGFydGlhbHMsIG5ld0hvbGRlcnMsIG5ld1BhcnRpYWxzUmlnaHQsXG4gICAgbmV3SG9sZGVyc1JpZ2h0LCBhcmdQb3MsIGFyeSwgYXJpdHlcbiAgXTtcblxuICB2YXIgcmVzdWx0ID0gd3JhcEZ1bmMuYXBwbHkodW5kZWZpbmVkLCBuZXdEYXRhKTtcbiAgaWYgKGlzTGF6aWFibGUoZnVuYykpIHtcbiAgICBzZXREYXRhKHJlc3VsdCwgbmV3RGF0YSk7XG4gIH1cbiAgcmVzdWx0LnBsYWNlaG9sZGVyID0gcGxhY2Vob2xkZXI7XG4gIHJldHVybiBzZXRXcmFwVG9TdHJpbmcocmVzdWx0LCBmdW5jLCBiaXRtYXNrKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVSZWN1cnJ5O1xuIiwiLyoqXG4gKiBHZXRzIHRoZSBhcmd1bWVudCBwbGFjZWhvbGRlciB2YWx1ZSBmb3IgYGZ1bmNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnNwZWN0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHBsYWNlaG9sZGVyIHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRIb2xkZXIoZnVuYykge1xuICB2YXIgb2JqZWN0ID0gZnVuYztcbiAgcmV0dXJuIG9iamVjdC5wbGFjZWhvbGRlcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRIb2xkZXI7XG4iLCJ2YXIgY29weUFycmF5ID0gcmVxdWlyZSgnLi9fY29weUFycmF5JyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1pbiA9IE1hdGgubWluO1xuXG4vKipcbiAqIFJlb3JkZXIgYGFycmF5YCBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZCBpbmRleGVzIHdoZXJlIHRoZSBlbGVtZW50IGF0XG4gKiB0aGUgZmlyc3QgaW5kZXggaXMgYXNzaWduZWQgYXMgdGhlIGZpcnN0IGVsZW1lbnQsIHRoZSBlbGVtZW50IGF0XG4gKiB0aGUgc2Vjb25kIGluZGV4IGlzIGFzc2lnbmVkIGFzIHRoZSBzZWNvbmQgZWxlbWVudCwgYW5kIHNvIG9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcmVvcmRlci5cbiAqIEBwYXJhbSB7QXJyYXl9IGluZGV4ZXMgVGhlIGFycmFuZ2VkIGFycmF5IGluZGV4ZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gcmVvcmRlcihhcnJheSwgaW5kZXhlcykge1xuICB2YXIgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgbGVuZ3RoID0gbmF0aXZlTWluKGluZGV4ZXMubGVuZ3RoLCBhcnJMZW5ndGgpLFxuICAgICAgb2xkQXJyYXkgPSBjb3B5QXJyYXkoYXJyYXkpO1xuXG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIHZhciBpbmRleCA9IGluZGV4ZXNbbGVuZ3RoXTtcbiAgICBhcnJheVtsZW5ndGhdID0gaXNJbmRleChpbmRleCwgYXJyTGVuZ3RoKSA/IG9sZEFycmF5W2luZGV4XSA6IHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVvcmRlcjtcbiIsIi8qKiBVc2VkIGFzIHRoZSBpbnRlcm5hbCBhcmd1bWVudCBwbGFjZWhvbGRlci4gKi9cbnZhciBQTEFDRUhPTERFUiA9ICdfX2xvZGFzaF9wbGFjZWhvbGRlcl9fJztcblxuLyoqXG4gKiBSZXBsYWNlcyBhbGwgYHBsYWNlaG9sZGVyYCBlbGVtZW50cyBpbiBgYXJyYXlgIHdpdGggYW4gaW50ZXJuYWwgcGxhY2Vob2xkZXJcbiAqIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIHRoZWlyIGluZGV4ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0geyp9IHBsYWNlaG9sZGVyIFRoZSBwbGFjZWhvbGRlciB0byByZXBsYWNlLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAqL1xuZnVuY3Rpb24gcmVwbGFjZUhvbGRlcnMoYXJyYXksIHBsYWNlaG9sZGVyKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgaWYgKHZhbHVlID09PSBwbGFjZWhvbGRlciB8fCB2YWx1ZSA9PT0gUExBQ0VIT0xERVIpIHtcbiAgICAgIGFycmF5W2luZGV4XSA9IFBMQUNFSE9MREVSO1xuICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gaW5kZXg7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVwbGFjZUhvbGRlcnM7XG4iLCJ2YXIgY29tcG9zZUFyZ3MgPSByZXF1aXJlKCcuL19jb21wb3NlQXJncycpLFxuICAgIGNvbXBvc2VBcmdzUmlnaHQgPSByZXF1aXJlKCcuL19jb21wb3NlQXJnc1JpZ2h0JyksXG4gICAgY291bnRIb2xkZXJzID0gcmVxdWlyZSgnLi9fY291bnRIb2xkZXJzJyksXG4gICAgY3JlYXRlQ3RvciA9IHJlcXVpcmUoJy4vX2NyZWF0ZUN0b3InKSxcbiAgICBjcmVhdGVSZWN1cnJ5ID0gcmVxdWlyZSgnLi9fY3JlYXRlUmVjdXJyeScpLFxuICAgIGdldEhvbGRlciA9IHJlcXVpcmUoJy4vX2dldEhvbGRlcicpLFxuICAgIHJlb3JkZXIgPSByZXF1aXJlKCcuL19yZW9yZGVyJyksXG4gICAgcmVwbGFjZUhvbGRlcnMgPSByZXF1aXJlKCcuL19yZXBsYWNlSG9sZGVycycpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGZ1bmN0aW9uIG1ldGFkYXRhLiAqL1xudmFyIFdSQVBfQklORF9GTEFHID0gMSxcbiAgICBXUkFQX0JJTkRfS0VZX0ZMQUcgPSAyLFxuICAgIFdSQVBfQ1VSUllfRkxBRyA9IDgsXG4gICAgV1JBUF9DVVJSWV9SSUdIVF9GTEFHID0gMTYsXG4gICAgV1JBUF9BUllfRkxBRyA9IDEyOCxcbiAgICBXUkFQX0ZMSVBfRkxBRyA9IDUxMjtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgdG8gaW52b2tlIGl0IHdpdGggb3B0aW9uYWwgYHRoaXNgXG4gKiBiaW5kaW5nIG9mIGB0aGlzQXJnYCwgcGFydGlhbCBhcHBsaWNhdGlvbiwgYW5kIGN1cnJ5aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufHN0cmluZ30gZnVuYyBUaGUgZnVuY3Rpb24gb3IgbWV0aG9kIG5hbWUgdG8gd3JhcC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIHByZXBlbmQgdG8gdGhvc2UgcHJvdmlkZWQgdG9cbiAqICB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQHBhcmFtIHtBcnJheX0gW2hvbGRlcnNdIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbHNSaWdodF0gVGhlIGFyZ3VtZW50cyB0byBhcHBlbmQgdG8gdGhvc2UgcHJvdmlkZWRcbiAqICB0byB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQHBhcmFtIHtBcnJheX0gW2hvbGRlcnNSaWdodF0gVGhlIGBwYXJ0aWFsc1JpZ2h0YCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICogQHBhcmFtIHtBcnJheX0gW2FyZ1Bvc10gVGhlIGFyZ3VtZW50IHBvc2l0aW9ucyBvZiB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFthcnldIFRoZSBhcml0eSBjYXAgb2YgYGZ1bmNgLlxuICogQHBhcmFtIHtudW1iZXJ9IFthcml0eV0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUh5YnJpZChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycywgcGFydGlhbHNSaWdodCwgaG9sZGVyc1JpZ2h0LCBhcmdQb3MsIGFyeSwgYXJpdHkpIHtcbiAgdmFyIGlzQXJ5ID0gYml0bWFzayAmIFdSQVBfQVJZX0ZMQUcsXG4gICAgICBpc0JpbmQgPSBiaXRtYXNrICYgV1JBUF9CSU5EX0ZMQUcsXG4gICAgICBpc0JpbmRLZXkgPSBiaXRtYXNrICYgV1JBUF9CSU5EX0tFWV9GTEFHLFxuICAgICAgaXNDdXJyaWVkID0gYml0bWFzayAmIChXUkFQX0NVUlJZX0ZMQUcgfCBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcpLFxuICAgICAgaXNGbGlwID0gYml0bWFzayAmIFdSQVBfRkxJUF9GTEFHLFxuICAgICAgQ3RvciA9IGlzQmluZEtleSA/IHVuZGVmaW5lZCA6IGNyZWF0ZUN0b3IoZnVuYyk7XG5cbiAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgYXJncyA9IEFycmF5KGxlbmd0aCksXG4gICAgICAgIGluZGV4ID0gbGVuZ3RoO1xuXG4gICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgIGFyZ3NbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICB9XG4gICAgaWYgKGlzQ3VycmllZCkge1xuICAgICAgdmFyIHBsYWNlaG9sZGVyID0gZ2V0SG9sZGVyKHdyYXBwZXIpLFxuICAgICAgICAgIGhvbGRlcnNDb3VudCA9IGNvdW50SG9sZGVycyhhcmdzLCBwbGFjZWhvbGRlcik7XG4gICAgfVxuICAgIGlmIChwYXJ0aWFscykge1xuICAgICAgYXJncyA9IGNvbXBvc2VBcmdzKGFyZ3MsIHBhcnRpYWxzLCBob2xkZXJzLCBpc0N1cnJpZWQpO1xuICAgIH1cbiAgICBpZiAocGFydGlhbHNSaWdodCkge1xuICAgICAgYXJncyA9IGNvbXBvc2VBcmdzUmlnaHQoYXJncywgcGFydGlhbHNSaWdodCwgaG9sZGVyc1JpZ2h0LCBpc0N1cnJpZWQpO1xuICAgIH1cbiAgICBsZW5ndGggLT0gaG9sZGVyc0NvdW50O1xuICAgIGlmIChpc0N1cnJpZWQgJiYgbGVuZ3RoIDwgYXJpdHkpIHtcbiAgICAgIHZhciBuZXdIb2xkZXJzID0gcmVwbGFjZUhvbGRlcnMoYXJncywgcGxhY2Vob2xkZXIpO1xuICAgICAgcmV0dXJuIGNyZWF0ZVJlY3VycnkoXG4gICAgICAgIGZ1bmMsIGJpdG1hc2ssIGNyZWF0ZUh5YnJpZCwgd3JhcHBlci5wbGFjZWhvbGRlciwgdGhpc0FyZyxcbiAgICAgICAgYXJncywgbmV3SG9sZGVycywgYXJnUG9zLCBhcnksIGFyaXR5IC0gbGVuZ3RoXG4gICAgICApO1xuICAgIH1cbiAgICB2YXIgdGhpc0JpbmRpbmcgPSBpc0JpbmQgPyB0aGlzQXJnIDogdGhpcyxcbiAgICAgICAgZm4gPSBpc0JpbmRLZXkgPyB0aGlzQmluZGluZ1tmdW5jXSA6IGZ1bmM7XG5cbiAgICBsZW5ndGggPSBhcmdzLmxlbmd0aDtcbiAgICBpZiAoYXJnUG9zKSB7XG4gICAgICBhcmdzID0gcmVvcmRlcihhcmdzLCBhcmdQb3MpO1xuICAgIH0gZWxzZSBpZiAoaXNGbGlwICYmIGxlbmd0aCA+IDEpIHtcbiAgICAgIGFyZ3MucmV2ZXJzZSgpO1xuICAgIH1cbiAgICBpZiAoaXNBcnkgJiYgYXJ5IDwgbGVuZ3RoKSB7XG4gICAgICBhcmdzLmxlbmd0aCA9IGFyeTtcbiAgICB9XG4gICAgaWYgKHRoaXMgJiYgdGhpcyAhPT0gcm9vdCAmJiB0aGlzIGluc3RhbmNlb2Ygd3JhcHBlcikge1xuICAgICAgZm4gPSBDdG9yIHx8IGNyZWF0ZUN0b3IoZm4pO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpc0JpbmRpbmcsIGFyZ3MpO1xuICB9XG4gIHJldHVybiB3cmFwcGVyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUh5YnJpZDtcbiIsInZhciBhcHBseSA9IHJlcXVpcmUoJy4vX2FwcGx5JyksXG4gICAgY3JlYXRlQ3RvciA9IHJlcXVpcmUoJy4vX2NyZWF0ZUN0b3InKSxcbiAgICBjcmVhdGVIeWJyaWQgPSByZXF1aXJlKCcuL19jcmVhdGVIeWJyaWQnKSxcbiAgICBjcmVhdGVSZWN1cnJ5ID0gcmVxdWlyZSgnLi9fY3JlYXRlUmVjdXJyeScpLFxuICAgIGdldEhvbGRlciA9IHJlcXVpcmUoJy4vX2dldEhvbGRlcicpLFxuICAgIHJlcGxhY2VIb2xkZXJzID0gcmVxdWlyZSgnLi9fcmVwbGFjZUhvbGRlcnMnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCB0byBlbmFibGUgY3VycnlpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtudW1iZXJ9IGFyaXR5IFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVDdXJyeShmdW5jLCBiaXRtYXNrLCBhcml0eSkge1xuICB2YXIgQ3RvciA9IGNyZWF0ZUN0b3IoZnVuYyk7XG5cbiAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgYXJncyA9IEFycmF5KGxlbmd0aCksXG4gICAgICAgIGluZGV4ID0gbGVuZ3RoLFxuICAgICAgICBwbGFjZWhvbGRlciA9IGdldEhvbGRlcih3cmFwcGVyKTtcblxuICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICBhcmdzW2luZGV4XSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgfVxuICAgIHZhciBob2xkZXJzID0gKGxlbmd0aCA8IDMgJiYgYXJnc1swXSAhPT0gcGxhY2Vob2xkZXIgJiYgYXJnc1tsZW5ndGggLSAxXSAhPT0gcGxhY2Vob2xkZXIpXG4gICAgICA/IFtdXG4gICAgICA6IHJlcGxhY2VIb2xkZXJzKGFyZ3MsIHBsYWNlaG9sZGVyKTtcblxuICAgIGxlbmd0aCAtPSBob2xkZXJzLmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoIDwgYXJpdHkpIHtcbiAgICAgIHJldHVybiBjcmVhdGVSZWN1cnJ5KFxuICAgICAgICBmdW5jLCBiaXRtYXNrLCBjcmVhdGVIeWJyaWQsIHdyYXBwZXIucGxhY2Vob2xkZXIsIHVuZGVmaW5lZCxcbiAgICAgICAgYXJncywgaG9sZGVycywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGFyaXR5IC0gbGVuZ3RoKTtcbiAgICB9XG4gICAgdmFyIGZuID0gKHRoaXMgJiYgdGhpcyAhPT0gcm9vdCAmJiB0aGlzIGluc3RhbmNlb2Ygd3JhcHBlcikgPyBDdG9yIDogZnVuYztcbiAgICByZXR1cm4gYXBwbHkoZm4sIHRoaXMsIGFyZ3MpO1xuICB9XG4gIHJldHVybiB3cmFwcGVyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUN1cnJ5O1xuIiwidmFyIGFwcGx5ID0gcmVxdWlyZSgnLi9fYXBwbHknKSxcbiAgICBjcmVhdGVDdG9yID0gcmVxdWlyZSgnLi9fY3JlYXRlQ3RvcicpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGZ1bmN0aW9uIG1ldGFkYXRhLiAqL1xudmFyIFdSQVBfQklORF9GTEFHID0gMTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgdG8gaW52b2tlIGl0IHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nXG4gKiBvZiBgdGhpc0FyZ2AgYW5kIGBwYXJ0aWFsc2AgcHJlcGVuZGVkIHRvIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge0FycmF5fSBwYXJ0aWFscyBUaGUgYXJndW1lbnRzIHRvIHByZXBlbmQgdG8gdGhvc2UgcHJvdmlkZWQgdG9cbiAqICB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUGFydGlhbChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscykge1xuICB2YXIgaXNCaW5kID0gYml0bWFzayAmIFdSQVBfQklORF9GTEFHLFxuICAgICAgQ3RvciA9IGNyZWF0ZUN0b3IoZnVuYyk7XG5cbiAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICB2YXIgYXJnc0luZGV4ID0gLTEsXG4gICAgICAgIGFyZ3NMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICBsZWZ0SW5kZXggPSAtMSxcbiAgICAgICAgbGVmdExlbmd0aCA9IHBhcnRpYWxzLmxlbmd0aCxcbiAgICAgICAgYXJncyA9IEFycmF5KGxlZnRMZW5ndGggKyBhcmdzTGVuZ3RoKSxcbiAgICAgICAgZm4gPSAodGhpcyAmJiB0aGlzICE9PSByb290ICYmIHRoaXMgaW5zdGFuY2VvZiB3cmFwcGVyKSA/IEN0b3IgOiBmdW5jO1xuXG4gICAgd2hpbGUgKCsrbGVmdEluZGV4IDwgbGVmdExlbmd0aCkge1xuICAgICAgYXJnc1tsZWZ0SW5kZXhdID0gcGFydGlhbHNbbGVmdEluZGV4XTtcbiAgICB9XG4gICAgd2hpbGUgKGFyZ3NMZW5ndGgtLSkge1xuICAgICAgYXJnc1tsZWZ0SW5kZXgrK10gPSBhcmd1bWVudHNbKythcmdzSW5kZXhdO1xuICAgIH1cbiAgICByZXR1cm4gYXBwbHkoZm4sIGlzQmluZCA/IHRoaXNBcmcgOiB0aGlzLCBhcmdzKTtcbiAgfVxuICByZXR1cm4gd3JhcHBlcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVQYXJ0aWFsO1xuIiwidmFyIGNvbXBvc2VBcmdzID0gcmVxdWlyZSgnLi9fY29tcG9zZUFyZ3MnKSxcbiAgICBjb21wb3NlQXJnc1JpZ2h0ID0gcmVxdWlyZSgnLi9fY29tcG9zZUFyZ3NSaWdodCcpLFxuICAgIHJlcGxhY2VIb2xkZXJzID0gcmVxdWlyZSgnLi9fcmVwbGFjZUhvbGRlcnMnKTtcblxuLyoqIFVzZWQgYXMgdGhlIGludGVybmFsIGFyZ3VtZW50IHBsYWNlaG9sZGVyLiAqL1xudmFyIFBMQUNFSE9MREVSID0gJ19fbG9kYXNoX3BsYWNlaG9sZGVyX18nO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBmdW5jdGlvbiBtZXRhZGF0YS4gKi9cbnZhciBXUkFQX0JJTkRfRkxBRyA9IDEsXG4gICAgV1JBUF9CSU5EX0tFWV9GTEFHID0gMixcbiAgICBXUkFQX0NVUlJZX0JPVU5EX0ZMQUcgPSA0LFxuICAgIFdSQVBfQ1VSUllfRkxBRyA9IDgsXG4gICAgV1JBUF9BUllfRkxBRyA9IDEyOCxcbiAgICBXUkFQX1JFQVJHX0ZMQUcgPSAyNTY7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNaW4gPSBNYXRoLm1pbjtcblxuLyoqXG4gKiBNZXJnZXMgdGhlIGZ1bmN0aW9uIG1ldGFkYXRhIG9mIGBzb3VyY2VgIGludG8gYGRhdGFgLlxuICpcbiAqIE1lcmdpbmcgbWV0YWRhdGEgcmVkdWNlcyB0aGUgbnVtYmVyIG9mIHdyYXBwZXJzIHVzZWQgdG8gaW52b2tlIGEgZnVuY3Rpb24uXG4gKiBUaGlzIGlzIHBvc3NpYmxlIGJlY2F1c2UgbWV0aG9kcyBsaWtlIGBfLmJpbmRgLCBgXy5jdXJyeWAsIGFuZCBgXy5wYXJ0aWFsYFxuICogbWF5IGJlIGFwcGxpZWQgcmVnYXJkbGVzcyBvZiBleGVjdXRpb24gb3JkZXIuIE1ldGhvZHMgbGlrZSBgXy5hcnlgIGFuZFxuICogYF8ucmVhcmdgIG1vZGlmeSBmdW5jdGlvbiBhcmd1bWVudHMsIG1ha2luZyB0aGUgb3JkZXIgaW4gd2hpY2ggdGhleSBhcmVcbiAqIGV4ZWN1dGVkIGltcG9ydGFudCwgcHJldmVudGluZyB0aGUgbWVyZ2luZyBvZiBtZXRhZGF0YS4gSG93ZXZlciwgd2UgbWFrZVxuICogYW4gZXhjZXB0aW9uIGZvciBhIHNhZmUgY29tYmluZWQgY2FzZSB3aGVyZSBjdXJyaWVkIGZ1bmN0aW9ucyBoYXZlIGBfLmFyeWBcbiAqIGFuZCBvciBgXy5yZWFyZ2AgYXBwbGllZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gZGF0YSBUaGUgZGVzdGluYXRpb24gbWV0YWRhdGEuXG4gKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIHNvdXJjZSBtZXRhZGF0YS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgZGF0YWAuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGF0YShkYXRhLCBzb3VyY2UpIHtcbiAgdmFyIGJpdG1hc2sgPSBkYXRhWzFdLFxuICAgICAgc3JjQml0bWFzayA9IHNvdXJjZVsxXSxcbiAgICAgIG5ld0JpdG1hc2sgPSBiaXRtYXNrIHwgc3JjQml0bWFzayxcbiAgICAgIGlzQ29tbW9uID0gbmV3Qml0bWFzayA8IChXUkFQX0JJTkRfRkxBRyB8IFdSQVBfQklORF9LRVlfRkxBRyB8IFdSQVBfQVJZX0ZMQUcpO1xuXG4gIHZhciBpc0NvbWJvID1cbiAgICAoKHNyY0JpdG1hc2sgPT0gV1JBUF9BUllfRkxBRykgJiYgKGJpdG1hc2sgPT0gV1JBUF9DVVJSWV9GTEFHKSkgfHxcbiAgICAoKHNyY0JpdG1hc2sgPT0gV1JBUF9BUllfRkxBRykgJiYgKGJpdG1hc2sgPT0gV1JBUF9SRUFSR19GTEFHKSAmJiAoZGF0YVs3XS5sZW5ndGggPD0gc291cmNlWzhdKSkgfHxcbiAgICAoKHNyY0JpdG1hc2sgPT0gKFdSQVBfQVJZX0ZMQUcgfCBXUkFQX1JFQVJHX0ZMQUcpKSAmJiAoc291cmNlWzddLmxlbmd0aCA8PSBzb3VyY2VbOF0pICYmIChiaXRtYXNrID09IFdSQVBfQ1VSUllfRkxBRykpO1xuXG4gIC8vIEV4aXQgZWFybHkgaWYgbWV0YWRhdGEgY2FuJ3QgYmUgbWVyZ2VkLlxuICBpZiAoIShpc0NvbW1vbiB8fCBpc0NvbWJvKSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIC8vIFVzZSBzb3VyY2UgYHRoaXNBcmdgIGlmIGF2YWlsYWJsZS5cbiAgaWYgKHNyY0JpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRykge1xuICAgIGRhdGFbMl0gPSBzb3VyY2VbMl07XG4gICAgLy8gU2V0IHdoZW4gY3VycnlpbmcgYSBib3VuZCBmdW5jdGlvbi5cbiAgICBuZXdCaXRtYXNrIHw9IGJpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRyA/IDAgOiBXUkFQX0NVUlJZX0JPVU5EX0ZMQUc7XG4gIH1cbiAgLy8gQ29tcG9zZSBwYXJ0aWFsIGFyZ3VtZW50cy5cbiAgdmFyIHZhbHVlID0gc291cmNlWzNdO1xuICBpZiAodmFsdWUpIHtcbiAgICB2YXIgcGFydGlhbHMgPSBkYXRhWzNdO1xuICAgIGRhdGFbM10gPSBwYXJ0aWFscyA/IGNvbXBvc2VBcmdzKHBhcnRpYWxzLCB2YWx1ZSwgc291cmNlWzRdKSA6IHZhbHVlO1xuICAgIGRhdGFbNF0gPSBwYXJ0aWFscyA/IHJlcGxhY2VIb2xkZXJzKGRhdGFbM10sIFBMQUNFSE9MREVSKSA6IHNvdXJjZVs0XTtcbiAgfVxuICAvLyBDb21wb3NlIHBhcnRpYWwgcmlnaHQgYXJndW1lbnRzLlxuICB2YWx1ZSA9IHNvdXJjZVs1XTtcbiAgaWYgKHZhbHVlKSB7XG4gICAgcGFydGlhbHMgPSBkYXRhWzVdO1xuICAgIGRhdGFbNV0gPSBwYXJ0aWFscyA/IGNvbXBvc2VBcmdzUmlnaHQocGFydGlhbHMsIHZhbHVlLCBzb3VyY2VbNl0pIDogdmFsdWU7XG4gICAgZGF0YVs2XSA9IHBhcnRpYWxzID8gcmVwbGFjZUhvbGRlcnMoZGF0YVs1XSwgUExBQ0VIT0xERVIpIDogc291cmNlWzZdO1xuICB9XG4gIC8vIFVzZSBzb3VyY2UgYGFyZ1Bvc2AgaWYgYXZhaWxhYmxlLlxuICB2YWx1ZSA9IHNvdXJjZVs3XTtcbiAgaWYgKHZhbHVlKSB7XG4gICAgZGF0YVs3XSA9IHZhbHVlO1xuICB9XG4gIC8vIFVzZSBzb3VyY2UgYGFyeWAgaWYgaXQncyBzbWFsbGVyLlxuICBpZiAoc3JjQml0bWFzayAmIFdSQVBfQVJZX0ZMQUcpIHtcbiAgICBkYXRhWzhdID0gZGF0YVs4XSA9PSBudWxsID8gc291cmNlWzhdIDogbmF0aXZlTWluKGRhdGFbOF0sIHNvdXJjZVs4XSk7XG4gIH1cbiAgLy8gVXNlIHNvdXJjZSBgYXJpdHlgIGlmIG9uZSBpcyBub3QgcHJvdmlkZWQuXG4gIGlmIChkYXRhWzldID09IG51bGwpIHtcbiAgICBkYXRhWzldID0gc291cmNlWzldO1xuICB9XG4gIC8vIFVzZSBzb3VyY2UgYGZ1bmNgIGFuZCBtZXJnZSBiaXRtYXNrcy5cbiAgZGF0YVswXSA9IHNvdXJjZVswXTtcbiAgZGF0YVsxXSA9IG5ld0JpdG1hc2s7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWVyZ2VEYXRhO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBOQU4gPSAwIC8gMDtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZS4gKi9cbnZhciByZVRyaW0gPSAvXlxccyt8XFxzKyQvZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJhZCBzaWduZWQgaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmFkSGV4ID0gL15bLStdMHhbMC05YS1mXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiaW5hcnkgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmluYXJ5ID0gL14wYlswMV0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb2N0YWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzT2N0YWwgPSAvXjBvWzAtN10rJC9pO1xuXG4vKiogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgd2l0aG91dCBhIGRlcGVuZGVuY3kgb24gYHJvb3RgLiAqL1xudmFyIGZyZWVQYXJzZUludCA9IHBhcnNlSW50O1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9OdW1iZXIoMy4yKTtcbiAqIC8vID0+IDMuMlxuICpcbiAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiA1ZS0zMjRcbiAqXG4gKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcbiAqIC8vID0+IEluZmluaXR5XG4gKlxuICogXy50b051bWJlcignMy4yJyk7XG4gKiAvLyA9PiAzLjJcbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIE5BTjtcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuICAgIHZhbHVlID0gaXNPYmplY3Qob3RoZXIpID8gKG90aGVyICsgJycpIDogb3RoZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICB9XG4gIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZVRyaW0sICcnKTtcbiAgdmFyIGlzQmluYXJ5ID0gcmVJc0JpbmFyeS50ZXN0KHZhbHVlKTtcbiAgcmV0dXJuIChpc0JpbmFyeSB8fCByZUlzT2N0YWwudGVzdCh2YWx1ZSkpXG4gICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXG4gICAgOiAocmVJc0JhZEhleC50ZXN0KHZhbHVlKSA/IE5BTiA6ICt2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9OdW1iZXI7XG4iLCJ2YXIgdG9OdW1iZXIgPSByZXF1aXJlKCcuL3RvTnVtYmVyJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDAsXG4gICAgTUFYX0lOVEVHRVIgPSAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwODtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgZmluaXRlIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTIuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgbnVtYmVyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvRmluaXRlKDMuMik7XG4gKiAvLyA9PiAzLjJcbiAqXG4gKiBfLnRvRmluaXRlKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gNWUtMzI0XG4gKlxuICogXy50b0Zpbml0ZShJbmZpbml0eSk7XG4gKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICpcbiAqIF8udG9GaW5pdGUoJzMuMicpO1xuICogLy8gPT4gMy4yXG4gKi9cbmZ1bmN0aW9uIHRvRmluaXRlKHZhbHVlKSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6IDA7XG4gIH1cbiAgdmFsdWUgPSB0b051bWJlcih2YWx1ZSk7XG4gIGlmICh2YWx1ZSA9PT0gSU5GSU5JVFkgfHwgdmFsdWUgPT09IC1JTkZJTklUWSkge1xuICAgIHZhciBzaWduID0gKHZhbHVlIDwgMCA/IC0xIDogMSk7XG4gICAgcmV0dXJuIHNpZ24gKiBNQVhfSU5URUdFUjtcbiAgfVxuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlID8gdmFsdWUgOiAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvRmluaXRlO1xuIiwidmFyIHRvRmluaXRlID0gcmVxdWlyZSgnLi90b0Zpbml0ZScpO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gaW50ZWdlci5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0ludGVnZXJgXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9pbnRlZ2VyKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBpbnRlZ2VyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvSW50ZWdlcigzLjIpO1xuICogLy8gPT4gM1xuICpcbiAqIF8udG9JbnRlZ2VyKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gMFxuICpcbiAqIF8udG9JbnRlZ2VyKEluZmluaXR5KTtcbiAqIC8vID0+IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4XG4gKlxuICogXy50b0ludGVnZXIoJzMuMicpO1xuICogLy8gPT4gM1xuICovXG5mdW5jdGlvbiB0b0ludGVnZXIodmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IHRvRmluaXRlKHZhbHVlKSxcbiAgICAgIHJlbWFpbmRlciA9IHJlc3VsdCAlIDE7XG5cbiAgcmV0dXJuIHJlc3VsdCA9PT0gcmVzdWx0ID8gKHJlbWFpbmRlciA/IHJlc3VsdCAtIHJlbWFpbmRlciA6IHJlc3VsdCkgOiAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvSW50ZWdlcjtcbiIsInZhciBiYXNlU2V0RGF0YSA9IHJlcXVpcmUoJy4vX2Jhc2VTZXREYXRhJyksXG4gICAgY3JlYXRlQmluZCA9IHJlcXVpcmUoJy4vX2NyZWF0ZUJpbmQnKSxcbiAgICBjcmVhdGVDdXJyeSA9IHJlcXVpcmUoJy4vX2NyZWF0ZUN1cnJ5JyksXG4gICAgY3JlYXRlSHlicmlkID0gcmVxdWlyZSgnLi9fY3JlYXRlSHlicmlkJyksXG4gICAgY3JlYXRlUGFydGlhbCA9IHJlcXVpcmUoJy4vX2NyZWF0ZVBhcnRpYWwnKSxcbiAgICBnZXREYXRhID0gcmVxdWlyZSgnLi9fZ2V0RGF0YScpLFxuICAgIG1lcmdlRGF0YSA9IHJlcXVpcmUoJy4vX21lcmdlRGF0YScpLFxuICAgIHNldERhdGEgPSByZXF1aXJlKCcuL19zZXREYXRhJyksXG4gICAgc2V0V3JhcFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fc2V0V3JhcFRvU3RyaW5nJyksXG4gICAgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi90b0ludGVnZXInKTtcblxuLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgZnVuY3Rpb24gbWV0YWRhdGEuICovXG52YXIgV1JBUF9CSU5EX0ZMQUcgPSAxLFxuICAgIFdSQVBfQklORF9LRVlfRkxBRyA9IDIsXG4gICAgV1JBUF9DVVJSWV9GTEFHID0gOCxcbiAgICBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcgPSAxNixcbiAgICBXUkFQX1BBUlRJQUxfRkxBRyA9IDMyLFxuICAgIFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHID0gNjQ7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBlaXRoZXIgY3VycmllcyBvciBpbnZva2VzIGBmdW5jYCB3aXRoIG9wdGlvbmFsXG4gKiBgdGhpc2AgYmluZGluZyBhbmQgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufHN0cmluZ30gZnVuYyBUaGUgZnVuY3Rpb24gb3IgbWV0aG9kIG5hbWUgdG8gd3JhcC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICogICAgMSAtIGBfLmJpbmRgXG4gKiAgICAyIC0gYF8uYmluZEtleWBcbiAqICAgIDQgLSBgXy5jdXJyeWAgb3IgYF8uY3VycnlSaWdodGAgb2YgYSBib3VuZCBmdW5jdGlvblxuICogICAgOCAtIGBfLmN1cnJ5YFxuICogICAxNiAtIGBfLmN1cnJ5UmlnaHRgXG4gKiAgIDMyIC0gYF8ucGFydGlhbGBcbiAqICAgNjQgLSBgXy5wYXJ0aWFsUmlnaHRgXG4gKiAgMTI4IC0gYF8ucmVhcmdgXG4gKiAgMjU2IC0gYF8uYXJ5YFxuICogIDUxMiAtIGBfLmZsaXBgXG4gKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICogQHBhcmFtIHtBcnJheX0gW2hvbGRlcnNdIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJnUG9zXSBUaGUgYXJndW1lbnQgcG9zaXRpb25zIG9mIHRoZSBuZXcgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2FyeV0gVGhlIGFyaXR5IGNhcCBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5XSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlV3JhcChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycywgYXJnUG9zLCBhcnksIGFyaXR5KSB7XG4gIHZhciBpc0JpbmRLZXkgPSBiaXRtYXNrICYgV1JBUF9CSU5EX0tFWV9GTEFHO1xuICBpZiAoIWlzQmluZEtleSAmJiB0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHZhciBsZW5ndGggPSBwYXJ0aWFscyA/IHBhcnRpYWxzLmxlbmd0aCA6IDA7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgYml0bWFzayAmPSB+KFdSQVBfUEFSVElBTF9GTEFHIHwgV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcpO1xuICAgIHBhcnRpYWxzID0gaG9sZGVycyA9IHVuZGVmaW5lZDtcbiAgfVxuICBhcnkgPSBhcnkgPT09IHVuZGVmaW5lZCA/IGFyeSA6IG5hdGl2ZU1heCh0b0ludGVnZXIoYXJ5KSwgMCk7XG4gIGFyaXR5ID0gYXJpdHkgPT09IHVuZGVmaW5lZCA/IGFyaXR5IDogdG9JbnRlZ2VyKGFyaXR5KTtcbiAgbGVuZ3RoIC09IGhvbGRlcnMgPyBob2xkZXJzLmxlbmd0aCA6IDA7XG5cbiAgaWYgKGJpdG1hc2sgJiBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRykge1xuICAgIHZhciBwYXJ0aWFsc1JpZ2h0ID0gcGFydGlhbHMsXG4gICAgICAgIGhvbGRlcnNSaWdodCA9IGhvbGRlcnM7XG5cbiAgICBwYXJ0aWFscyA9IGhvbGRlcnMgPSB1bmRlZmluZWQ7XG4gIH1cbiAgdmFyIGRhdGEgPSBpc0JpbmRLZXkgPyB1bmRlZmluZWQgOiBnZXREYXRhKGZ1bmMpO1xuXG4gIHZhciBuZXdEYXRhID0gW1xuICAgIGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzLCBwYXJ0aWFsc1JpZ2h0LCBob2xkZXJzUmlnaHQsXG4gICAgYXJnUG9zLCBhcnksIGFyaXR5XG4gIF07XG5cbiAgaWYgKGRhdGEpIHtcbiAgICBtZXJnZURhdGEobmV3RGF0YSwgZGF0YSk7XG4gIH1cbiAgZnVuYyA9IG5ld0RhdGFbMF07XG4gIGJpdG1hc2sgPSBuZXdEYXRhWzFdO1xuICB0aGlzQXJnID0gbmV3RGF0YVsyXTtcbiAgcGFydGlhbHMgPSBuZXdEYXRhWzNdO1xuICBob2xkZXJzID0gbmV3RGF0YVs0XTtcbiAgYXJpdHkgPSBuZXdEYXRhWzldID0gbmV3RGF0YVs5XSA9PT0gdW5kZWZpbmVkXG4gICAgPyAoaXNCaW5kS2V5ID8gMCA6IGZ1bmMubGVuZ3RoKVxuICAgIDogbmF0aXZlTWF4KG5ld0RhdGFbOV0gLSBsZW5ndGgsIDApO1xuXG4gIGlmICghYXJpdHkgJiYgYml0bWFzayAmIChXUkFQX0NVUlJZX0ZMQUcgfCBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcpKSB7XG4gICAgYml0bWFzayAmPSB+KFdSQVBfQ1VSUllfRkxBRyB8IFdSQVBfQ1VSUllfUklHSFRfRkxBRyk7XG4gIH1cbiAgaWYgKCFiaXRtYXNrIHx8IGJpdG1hc2sgPT0gV1JBUF9CSU5EX0ZMQUcpIHtcbiAgICB2YXIgcmVzdWx0ID0gY3JlYXRlQmluZChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnKTtcbiAgfSBlbHNlIGlmIChiaXRtYXNrID09IFdSQVBfQ1VSUllfRkxBRyB8fCBiaXRtYXNrID09IFdSQVBfQ1VSUllfUklHSFRfRkxBRykge1xuICAgIHJlc3VsdCA9IGNyZWF0ZUN1cnJ5KGZ1bmMsIGJpdG1hc2ssIGFyaXR5KTtcbiAgfSBlbHNlIGlmICgoYml0bWFzayA9PSBXUkFQX1BBUlRJQUxfRkxBRyB8fCBiaXRtYXNrID09IChXUkFQX0JJTkRfRkxBRyB8IFdSQVBfUEFSVElBTF9GTEFHKSkgJiYgIWhvbGRlcnMubGVuZ3RoKSB7XG4gICAgcmVzdWx0ID0gY3JlYXRlUGFydGlhbChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscyk7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0gY3JlYXRlSHlicmlkLmFwcGx5KHVuZGVmaW5lZCwgbmV3RGF0YSk7XG4gIH1cbiAgdmFyIHNldHRlciA9IGRhdGEgPyBiYXNlU2V0RGF0YSA6IHNldERhdGE7XG4gIHJldHVybiBzZXRXcmFwVG9TdHJpbmcoc2V0dGVyKHJlc3VsdCwgbmV3RGF0YSksIGZ1bmMsIGJpdG1hc2spO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVdyYXA7XG4iLCJ2YXIgYmFzZVJlc3QgPSByZXF1aXJlKCcuL19iYXNlUmVzdCcpLFxuICAgIGNyZWF0ZVdyYXAgPSByZXF1aXJlKCcuL19jcmVhdGVXcmFwJyksXG4gICAgZ2V0SG9sZGVyID0gcmVxdWlyZSgnLi9fZ2V0SG9sZGVyJyksXG4gICAgcmVwbGFjZUhvbGRlcnMgPSByZXF1aXJlKCcuL19yZXBsYWNlSG9sZGVycycpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBmdW5jdGlvbiBtZXRhZGF0YS4gKi9cbnZhciBXUkFQX0JJTkRfRkxBRyA9IDEsXG4gICAgV1JBUF9QQVJUSUFMX0ZMQUcgPSAzMjtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2BcbiAqIGFuZCBgcGFydGlhbHNgIHByZXBlbmRlZCB0byB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxuICpcbiAqIFRoZSBgXy5iaW5kLnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWMgYnVpbGRzLFxuICogbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICpcbiAqICoqTm90ZToqKiBVbmxpa2UgbmF0aXZlIGBGdW5jdGlvbiNiaW5kYCwgdGhpcyBtZXRob2QgZG9lc24ndCBzZXQgdGhlIFwibGVuZ3RoXCJcbiAqIHByb3BlcnR5IG9mIGJvdW5kIGZ1bmN0aW9ucy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGJpbmQuXG4gKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAqIEBwYXJhbSB7Li4uKn0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYm91bmQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIGdyZWV0KGdyZWV0aW5nLCBwdW5jdHVhdGlvbikge1xuICogICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyB0aGlzLnVzZXIgKyBwdW5jdHVhdGlvbjtcbiAqIH1cbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAndXNlcic6ICdmcmVkJyB9O1xuICpcbiAqIHZhciBib3VuZCA9IF8uYmluZChncmVldCwgb2JqZWN0LCAnaGknKTtcbiAqIGJvdW5kKCchJyk7XG4gKiAvLyA9PiAnaGkgZnJlZCEnXG4gKlxuICogLy8gQm91bmQgd2l0aCBwbGFjZWhvbGRlcnMuXG4gKiB2YXIgYm91bmQgPSBfLmJpbmQoZ3JlZXQsIG9iamVjdCwgXywgJyEnKTtcbiAqIGJvdW5kKCdoaScpO1xuICogLy8gPT4gJ2hpIGZyZWQhJ1xuICovXG52YXIgYmluZCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIHRoaXNBcmcsIHBhcnRpYWxzKSB7XG4gIHZhciBiaXRtYXNrID0gV1JBUF9CSU5EX0ZMQUc7XG4gIGlmIChwYXJ0aWFscy5sZW5ndGgpIHtcbiAgICB2YXIgaG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKHBhcnRpYWxzLCBnZXRIb2xkZXIoYmluZCkpO1xuICAgIGJpdG1hc2sgfD0gV1JBUF9QQVJUSUFMX0ZMQUc7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMpO1xufSk7XG5cbi8vIEFzc2lnbiBkZWZhdWx0IHBsYWNlaG9sZGVycy5cbmJpbmQucGxhY2Vob2xkZXIgPSB7fTtcblxubW9kdWxlLmV4cG9ydHMgPSBiaW5kO1xuIiwiLyogYXhpb3MgdjAuMTguMCB8IChjKSAyMDE4IGJ5IE1hdHQgWmFicmlza2llICovXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJheGlvc1wiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJheGlvc1wiXSA9IGZhY3RvcnkoKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9LFxuLyoqKioqKi8gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bG9hZGVkOiBmYWxzZVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuLyoqKi8gfSksXG4vKiAxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0dmFyIHV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblx0dmFyIGJpbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXHR2YXIgQXhpb3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXHR2YXIgZGVmYXVsdHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXHRcblx0LyoqXG5cdCAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBBeGlvc1xuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGVmYXVsdENvbmZpZyBUaGUgZGVmYXVsdCBjb25maWcgZm9yIHRoZSBpbnN0YW5jZVxuXHQgKiBAcmV0dXJuIHtBeGlvc30gQSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3Ncblx0ICovXG5cdGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlKGRlZmF1bHRDb25maWcpIHtcblx0ICB2YXIgY29udGV4dCA9IG5ldyBBeGlvcyhkZWZhdWx0Q29uZmlnKTtcblx0ICB2YXIgaW5zdGFuY2UgPSBiaW5kKEF4aW9zLnByb3RvdHlwZS5yZXF1ZXN0LCBjb250ZXh0KTtcblx0XG5cdCAgLy8gQ29weSBheGlvcy5wcm90b3R5cGUgdG8gaW5zdGFuY2Vcblx0ICB1dGlscy5leHRlbmQoaW5zdGFuY2UsIEF4aW9zLnByb3RvdHlwZSwgY29udGV4dCk7XG5cdFxuXHQgIC8vIENvcHkgY29udGV4dCB0byBpbnN0YW5jZVxuXHQgIHV0aWxzLmV4dGVuZChpbnN0YW5jZSwgY29udGV4dCk7XG5cdFxuXHQgIHJldHVybiBpbnN0YW5jZTtcblx0fVxuXHRcblx0Ly8gQ3JlYXRlIHRoZSBkZWZhdWx0IGluc3RhbmNlIHRvIGJlIGV4cG9ydGVkXG5cdHZhciBheGlvcyA9IGNyZWF0ZUluc3RhbmNlKGRlZmF1bHRzKTtcblx0XG5cdC8vIEV4cG9zZSBBeGlvcyBjbGFzcyB0byBhbGxvdyBjbGFzcyBpbmhlcml0YW5jZVxuXHRheGlvcy5BeGlvcyA9IEF4aW9zO1xuXHRcblx0Ly8gRmFjdG9yeSBmb3IgY3JlYXRpbmcgbmV3IGluc3RhbmNlc1xuXHRheGlvcy5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoaW5zdGFuY2VDb25maWcpIHtcblx0ICByZXR1cm4gY3JlYXRlSW5zdGFuY2UodXRpbHMubWVyZ2UoZGVmYXVsdHMsIGluc3RhbmNlQ29uZmlnKSk7XG5cdH07XG5cdFxuXHQvLyBFeHBvc2UgQ2FuY2VsICYgQ2FuY2VsVG9rZW5cblx0YXhpb3MuQ2FuY2VsID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XG5cdGF4aW9zLkNhbmNlbFRva2VuID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNCk7XG5cdGF4aW9zLmlzQ2FuY2VsID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG5cdFxuXHQvLyBFeHBvc2UgYWxsL3NwcmVhZFxuXHRheGlvcy5hbGwgPSBmdW5jdGlvbiBhbGwocHJvbWlzZXMpIHtcblx0ICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuXHR9O1xuXHRheGlvcy5zcHJlYWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KTtcblx0XG5cdG1vZHVsZS5leHBvcnRzID0gYXhpb3M7XG5cdFxuXHQvLyBBbGxvdyB1c2Ugb2YgZGVmYXVsdCBpbXBvcnQgc3ludGF4IGluIFR5cGVTY3JpcHRcblx0bW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGF4aW9zO1xuXG5cbi8qKiovIH0pLFxuLyogMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdHZhciBiaW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblx0dmFyIGlzQnVmZmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblx0XG5cdC8qZ2xvYmFsIHRvU3RyaW5nOnRydWUqL1xuXHRcblx0Ly8gdXRpbHMgaXMgYSBsaWJyYXJ5IG9mIGdlbmVyaWMgaGVscGVyIGZ1bmN0aW9ucyBub24tc3BlY2lmaWMgdG8gYXhpb3Ncblx0XG5cdHZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cdFxuXHQvKipcblx0ICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gQXJyYXlcblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBBcnJheSwgb3RoZXJ3aXNlIGZhbHNlXG5cdCAqL1xuXHRmdW5jdGlvbiBpc0FycmF5KHZhbCkge1xuXHQgIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlclxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2Vcblx0ICovXG5cdGZ1bmN0aW9uIGlzQXJyYXlCdWZmZXIodmFsKSB7XG5cdCAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJztcblx0fVxuXHRcblx0LyoqXG5cdCAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRm9ybURhdGFcblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBGb3JtRGF0YSwgb3RoZXJ3aXNlIGZhbHNlXG5cdCAqL1xuXHRmdW5jdGlvbiBpc0Zvcm1EYXRhKHZhbCkge1xuXHQgIHJldHVybiAodHlwZW9mIEZvcm1EYXRhICE9PSAndW5kZWZpbmVkJykgJiYgKHZhbCBpbnN0YW5jZW9mIEZvcm1EYXRhKTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgdmlldyBvbiBhbiBBcnJheUJ1ZmZlclxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgdmlldyBvbiBhbiBBcnJheUJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG5cdCAqL1xuXHRmdW5jdGlvbiBpc0FycmF5QnVmZmVyVmlldyh2YWwpIHtcblx0ICB2YXIgcmVzdWx0O1xuXHQgIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJykgJiYgKEFycmF5QnVmZmVyLmlzVmlldykpIHtcblx0ICAgIHJlc3VsdCA9IEFycmF5QnVmZmVyLmlzVmlldyh2YWwpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICByZXN1bHQgPSAodmFsKSAmJiAodmFsLmJ1ZmZlcikgJiYgKHZhbC5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcik7XG5cdCAgfVxuXHQgIHJldHVybiByZXN1bHQ7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFN0cmluZ1xuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyaW5nLCBvdGhlcndpc2UgZmFsc2Vcblx0ICovXG5cdGZ1bmN0aW9uIGlzU3RyaW5nKHZhbCkge1xuXHQgIHJldHVybiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJztcblx0fVxuXHRcblx0LyoqXG5cdCAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgTnVtYmVyXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3Rcblx0ICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBOdW1iZXIsIG90aGVyd2lzZSBmYWxzZVxuXHQgKi9cblx0ZnVuY3Rpb24gaXNOdW1iZXIodmFsKSB7XG5cdCAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInO1xuXHR9XG5cdFxuXHQvKipcblx0ICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgdW5kZWZpbmVkXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3Rcblx0ICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHZhbHVlIGlzIHVuZGVmaW5lZCwgb3RoZXJ3aXNlIGZhbHNlXG5cdCAqL1xuXHRmdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWwpIHtcblx0ICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCc7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBPYmplY3Rcblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBPYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuXHQgKi9cblx0ZnVuY3Rpb24gaXNPYmplY3QodmFsKSB7XG5cdCAgcmV0dXJuIHZhbCAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0Jztcblx0fVxuXHRcblx0LyoqXG5cdCAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRGF0ZVxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRGF0ZSwgb3RoZXJ3aXNlIGZhbHNlXG5cdCAqL1xuXHRmdW5jdGlvbiBpc0RhdGUodmFsKSB7XG5cdCAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xuXHR9XG5cdFxuXHQvKipcblx0ICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGaWxlXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3Rcblx0ICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGaWxlLCBvdGhlcndpc2UgZmFsc2Vcblx0ICovXG5cdGZ1bmN0aW9uIGlzRmlsZSh2YWwpIHtcblx0ICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBGaWxlXSc7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEJsb2Jcblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJsb2IsIG90aGVyd2lzZSBmYWxzZVxuXHQgKi9cblx0ZnVuY3Rpb24gaXNCbG9iKHZhbCkge1xuXHQgIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEJsb2JdJztcblx0fVxuXHRcblx0LyoqXG5cdCAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRnVuY3Rpb25cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEZ1bmN0aW9uLCBvdGhlcndpc2UgZmFsc2Vcblx0ICovXG5cdGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsKSB7XG5cdCAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcblx0fVxuXHRcblx0LyoqXG5cdCAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgU3RyZWFtXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3Rcblx0ICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBTdHJlYW0sIG90aGVyd2lzZSBmYWxzZVxuXHQgKi9cblx0ZnVuY3Rpb24gaXNTdHJlYW0odmFsKSB7XG5cdCAgcmV0dXJuIGlzT2JqZWN0KHZhbCkgJiYgaXNGdW5jdGlvbih2YWwucGlwZSk7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3Rcblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuXHQgKi9cblx0ZnVuY3Rpb24gaXNVUkxTZWFyY2hQYXJhbXModmFsKSB7XG5cdCAgcmV0dXJuIHR5cGVvZiBVUkxTZWFyY2hQYXJhbXMgIT09ICd1bmRlZmluZWQnICYmIHZhbCBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcztcblx0fVxuXHRcblx0LyoqXG5cdCAqIFRyaW0gZXhjZXNzIHdoaXRlc3BhY2Ugb2ZmIHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiBhIHN0cmluZ1xuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBTdHJpbmcgdG8gdHJpbVxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgU3RyaW5nIGZyZWVkIG9mIGV4Y2VzcyB3aGl0ZXNwYWNlXG5cdCAqL1xuXHRmdW5jdGlvbiB0cmltKHN0cikge1xuXHQgIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyovLCAnJykucmVwbGFjZSgvXFxzKiQvLCAnJyk7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBEZXRlcm1pbmUgaWYgd2UncmUgcnVubmluZyBpbiBhIHN0YW5kYXJkIGJyb3dzZXIgZW52aXJvbm1lbnRcblx0ICpcblx0ICogVGhpcyBhbGxvd3MgYXhpb3MgdG8gcnVuIGluIGEgd2ViIHdvcmtlciwgYW5kIHJlYWN0LW5hdGl2ZS5cblx0ICogQm90aCBlbnZpcm9ubWVudHMgc3VwcG9ydCBYTUxIdHRwUmVxdWVzdCwgYnV0IG5vdCBmdWxseSBzdGFuZGFyZCBnbG9iYWxzLlxuXHQgKlxuXHQgKiB3ZWIgd29ya2Vyczpcblx0ICogIHR5cGVvZiB3aW5kb3cgLT4gdW5kZWZpbmVkXG5cdCAqICB0eXBlb2YgZG9jdW1lbnQgLT4gdW5kZWZpbmVkXG5cdCAqXG5cdCAqIHJlYWN0LW5hdGl2ZTpcblx0ICogIG5hdmlnYXRvci5wcm9kdWN0IC0+ICdSZWFjdE5hdGl2ZSdcblx0ICovXG5cdGZ1bmN0aW9uIGlzU3RhbmRhcmRCcm93c2VyRW52KCkge1xuXHQgIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ1JlYWN0TmF0aXZlJykge1xuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH1cblx0ICByZXR1cm4gKFxuXHQgICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcblx0ICAgIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCdcblx0ICApO1xuXHR9XG5cdFxuXHQvKipcblx0ICogSXRlcmF0ZSBvdmVyIGFuIEFycmF5IG9yIGFuIE9iamVjdCBpbnZva2luZyBhIGZ1bmN0aW9uIGZvciBlYWNoIGl0ZW0uXG5cdCAqXG5cdCAqIElmIGBvYmpgIGlzIGFuIEFycmF5IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHBhc3Npbmdcblx0ICogdGhlIHZhbHVlLCBpbmRleCwgYW5kIGNvbXBsZXRlIGFycmF5IGZvciBlYWNoIGl0ZW0uXG5cdCAqXG5cdCAqIElmICdvYmonIGlzIGFuIE9iamVjdCBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBwYXNzaW5nXG5cdCAqIHRoZSB2YWx1ZSwga2V5LCBhbmQgY29tcGxldGUgb2JqZWN0IGZvciBlYWNoIHByb3BlcnR5LlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdHxBcnJheX0gb2JqIFRoZSBvYmplY3QgdG8gaXRlcmF0ZVxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIGZvciBlYWNoIGl0ZW1cblx0ICovXG5cdGZ1bmN0aW9uIGZvckVhY2gob2JqLCBmbikge1xuXHQgIC8vIERvbid0IGJvdGhlciBpZiBubyB2YWx1ZSBwcm92aWRlZFxuXHQgIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0ICAgIHJldHVybjtcblx0ICB9XG5cdFxuXHQgIC8vIEZvcmNlIGFuIGFycmF5IGlmIG5vdCBhbHJlYWR5IHNvbWV0aGluZyBpdGVyYWJsZVxuXHQgIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuXHQgICAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG5cdCAgICBvYmogPSBbb2JqXTtcblx0ICB9XG5cdFxuXHQgIGlmIChpc0FycmF5KG9iaikpIHtcblx0ICAgIC8vIEl0ZXJhdGUgb3ZlciBhcnJheSB2YWx1ZXNcblx0ICAgIGZvciAodmFyIGkgPSAwLCBsID0gb2JqLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHQgICAgICBmbi5jYWxsKG51bGwsIG9ialtpXSwgaSwgb2JqKTtcblx0ICAgIH1cblx0ICB9IGVsc2Uge1xuXHQgICAgLy8gSXRlcmF0ZSBvdmVyIG9iamVjdCBrZXlzXG5cdCAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG5cdCAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG5cdCAgICAgICAgZm4uY2FsbChudWxsLCBvYmpba2V5XSwga2V5LCBvYmopO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cdFxuXHQvKipcblx0ICogQWNjZXB0cyB2YXJhcmdzIGV4cGVjdGluZyBlYWNoIGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCwgdGhlblxuXHQgKiBpbW11dGFibHkgbWVyZ2VzIHRoZSBwcm9wZXJ0aWVzIG9mIGVhY2ggb2JqZWN0IGFuZCByZXR1cm5zIHJlc3VsdC5cblx0ICpcblx0ICogV2hlbiBtdWx0aXBsZSBvYmplY3RzIGNvbnRhaW4gdGhlIHNhbWUga2V5IHRoZSBsYXRlciBvYmplY3QgaW5cblx0ICogdGhlIGFyZ3VtZW50cyBsaXN0IHdpbGwgdGFrZSBwcmVjZWRlbmNlLlxuXHQgKlxuXHQgKiBFeGFtcGxlOlxuXHQgKlxuXHQgKiBgYGBqc1xuXHQgKiB2YXIgcmVzdWx0ID0gbWVyZ2Uoe2ZvbzogMTIzfSwge2ZvbzogNDU2fSk7XG5cdCAqIGNvbnNvbGUubG9nKHJlc3VsdC5mb28pOyAvLyBvdXRwdXRzIDQ1NlxuXHQgKiBgYGBcblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IG9iajEgT2JqZWN0IHRvIG1lcmdlXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IFJlc3VsdCBvZiBhbGwgbWVyZ2UgcHJvcGVydGllc1xuXHQgKi9cblx0ZnVuY3Rpb24gbWVyZ2UoLyogb2JqMSwgb2JqMiwgb2JqMywgLi4uICovKSB7XG5cdCAgdmFyIHJlc3VsdCA9IHt9O1xuXHQgIGZ1bmN0aW9uIGFzc2lnblZhbHVlKHZhbCwga2V5KSB7XG5cdCAgICBpZiAodHlwZW9mIHJlc3VsdFtrZXldID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0Jykge1xuXHQgICAgICByZXN1bHRba2V5XSA9IG1lcmdlKHJlc3VsdFtrZXldLCB2YWwpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmVzdWx0W2tleV0gPSB2YWw7XG5cdCAgICB9XG5cdCAgfVxuXHRcblx0ICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0ICAgIGZvckVhY2goYXJndW1lbnRzW2ldLCBhc3NpZ25WYWx1ZSk7XG5cdCAgfVxuXHQgIHJldHVybiByZXN1bHQ7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBFeHRlbmRzIG9iamVjdCBhIGJ5IG11dGFibHkgYWRkaW5nIHRvIGl0IHRoZSBwcm9wZXJ0aWVzIG9mIG9iamVjdCBiLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gYSBUaGUgb2JqZWN0IHRvIGJlIGV4dGVuZGVkXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBiIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb21cblx0ICogQHBhcmFtIHtPYmplY3R9IHRoaXNBcmcgVGhlIG9iamVjdCB0byBiaW5kIGZ1bmN0aW9uIHRvXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIHJlc3VsdGluZyB2YWx1ZSBvZiBvYmplY3QgYVxuXHQgKi9cblx0ZnVuY3Rpb24gZXh0ZW5kKGEsIGIsIHRoaXNBcmcpIHtcblx0ICBmb3JFYWNoKGIsIGZ1bmN0aW9uIGFzc2lnblZhbHVlKHZhbCwga2V5KSB7XG5cdCAgICBpZiAodGhpc0FyZyAmJiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgIGFba2V5XSA9IGJpbmQodmFsLCB0aGlzQXJnKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGFba2V5XSA9IHZhbDtcblx0ICAgIH1cblx0ICB9KTtcblx0ICByZXR1cm4gYTtcblx0fVxuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSB7XG5cdCAgaXNBcnJheTogaXNBcnJheSxcblx0ICBpc0FycmF5QnVmZmVyOiBpc0FycmF5QnVmZmVyLFxuXHQgIGlzQnVmZmVyOiBpc0J1ZmZlcixcblx0ICBpc0Zvcm1EYXRhOiBpc0Zvcm1EYXRhLFxuXHQgIGlzQXJyYXlCdWZmZXJWaWV3OiBpc0FycmF5QnVmZmVyVmlldyxcblx0ICBpc1N0cmluZzogaXNTdHJpbmcsXG5cdCAgaXNOdW1iZXI6IGlzTnVtYmVyLFxuXHQgIGlzT2JqZWN0OiBpc09iamVjdCxcblx0ICBpc1VuZGVmaW5lZDogaXNVbmRlZmluZWQsXG5cdCAgaXNEYXRlOiBpc0RhdGUsXG5cdCAgaXNGaWxlOiBpc0ZpbGUsXG5cdCAgaXNCbG9iOiBpc0Jsb2IsXG5cdCAgaXNGdW5jdGlvbjogaXNGdW5jdGlvbixcblx0ICBpc1N0cmVhbTogaXNTdHJlYW0sXG5cdCAgaXNVUkxTZWFyY2hQYXJhbXM6IGlzVVJMU2VhcmNoUGFyYW1zLFxuXHQgIGlzU3RhbmRhcmRCcm93c2VyRW52OiBpc1N0YW5kYXJkQnJvd3NlckVudixcblx0ICBmb3JFYWNoOiBmb3JFYWNoLFxuXHQgIG1lcmdlOiBtZXJnZSxcblx0ICBleHRlbmQ6IGV4dGVuZCxcblx0ICB0cmltOiB0cmltXG5cdH07XG5cblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBiaW5kKGZuLCB0aGlzQXJnKSB7XG5cdCAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoKSB7XG5cdCAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuXHQgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuXHQgIH07XG5cdH07XG5cblxuLyoqKi8gfSksXG4vKiA0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0LyohXG5cdCAqIERldGVybWluZSBpZiBhbiBvYmplY3QgaXMgYSBCdWZmZXJcblx0ICpcblx0ICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cblx0ICogQGxpY2Vuc2UgIE1JVFxuXHQgKi9cblx0XG5cdC8vIFRoZSBfaXNCdWZmZXIgY2hlY2sgaXMgZm9yIFNhZmFyaSA1LTcgc3VwcG9ydCwgYmVjYXVzZSBpdCdzIG1pc3Npbmdcblx0Ly8gT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvci4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseVxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHtcblx0ICByZXR1cm4gb2JqICE9IG51bGwgJiYgKGlzQnVmZmVyKG9iaikgfHwgaXNTbG93QnVmZmVyKG9iaikgfHwgISFvYmouX2lzQnVmZmVyKVxuXHR9XG5cdFxuXHRmdW5jdGlvbiBpc0J1ZmZlciAob2JqKSB7XG5cdCAgcmV0dXJuICEhb2JqLmNvbnN0cnVjdG9yICYmIHR5cGVvZiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iailcblx0fVxuXHRcblx0Ly8gRm9yIE5vZGUgdjAuMTAgc3VwcG9ydC4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseS5cblx0ZnVuY3Rpb24gaXNTbG93QnVmZmVyIChvYmopIHtcblx0ICByZXR1cm4gdHlwZW9mIG9iai5yZWFkRmxvYXRMRSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLnNsaWNlID09PSAnZnVuY3Rpb24nICYmIGlzQnVmZmVyKG9iai5zbGljZSgwLCAwKSlcblx0fVxuXG5cbi8qKiovIH0pLFxuLyogNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdHZhciBkZWZhdWx0cyA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cdHZhciB1dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cdHZhciBJbnRlcmNlcHRvck1hbmFnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KTtcblx0dmFyIGRpc3BhdGNoUmVxdWVzdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xuXHRcblx0LyoqXG5cdCAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gaW5zdGFuY2VDb25maWcgVGhlIGRlZmF1bHQgY29uZmlnIGZvciB0aGUgaW5zdGFuY2Vcblx0ICovXG5cdGZ1bmN0aW9uIEF4aW9zKGluc3RhbmNlQ29uZmlnKSB7XG5cdCAgdGhpcy5kZWZhdWx0cyA9IGluc3RhbmNlQ29uZmlnO1xuXHQgIHRoaXMuaW50ZXJjZXB0b3JzID0ge1xuXHQgICAgcmVxdWVzdDogbmV3IEludGVyY2VwdG9yTWFuYWdlcigpLFxuXHQgICAgcmVzcG9uc2U6IG5ldyBJbnRlcmNlcHRvck1hbmFnZXIoKVxuXHQgIH07XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBEaXNwYXRjaCBhIHJlcXVlc3Rcblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHNwZWNpZmljIGZvciB0aGlzIHJlcXVlc3QgKG1lcmdlZCB3aXRoIHRoaXMuZGVmYXVsdHMpXG5cdCAqL1xuXHRBeGlvcy5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uIHJlcXVlc3QoY29uZmlnKSB7XG5cdCAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG5cdCAgLy8gQWxsb3cgZm9yIGF4aW9zKCdleGFtcGxlL3VybCdbLCBjb25maWddKSBhIGxhIGZldGNoIEFQSVxuXHQgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuXHQgICAgY29uZmlnID0gdXRpbHMubWVyZ2Uoe1xuXHQgICAgICB1cmw6IGFyZ3VtZW50c1swXVxuXHQgICAgfSwgYXJndW1lbnRzWzFdKTtcblx0ICB9XG5cdFxuXHQgIGNvbmZpZyA9IHV0aWxzLm1lcmdlKGRlZmF1bHRzLCB7bWV0aG9kOiAnZ2V0J30sIHRoaXMuZGVmYXVsdHMsIGNvbmZpZyk7XG5cdCAgY29uZmlnLm1ldGhvZCA9IGNvbmZpZy5tZXRob2QudG9Mb3dlckNhc2UoKTtcblx0XG5cdCAgLy8gSG9vayB1cCBpbnRlcmNlcHRvcnMgbWlkZGxld2FyZVxuXHQgIHZhciBjaGFpbiA9IFtkaXNwYXRjaFJlcXVlc3QsIHVuZGVmaW5lZF07XG5cdCAgdmFyIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoY29uZmlnKTtcblx0XG5cdCAgdGhpcy5pbnRlcmNlcHRvcnMucmVxdWVzdC5mb3JFYWNoKGZ1bmN0aW9uIHVuc2hpZnRSZXF1ZXN0SW50ZXJjZXB0b3JzKGludGVyY2VwdG9yKSB7XG5cdCAgICBjaGFpbi51bnNoaWZ0KGludGVyY2VwdG9yLmZ1bGZpbGxlZCwgaW50ZXJjZXB0b3IucmVqZWN0ZWQpO1xuXHQgIH0pO1xuXHRcblx0ICB0aGlzLmludGVyY2VwdG9ycy5yZXNwb25zZS5mb3JFYWNoKGZ1bmN0aW9uIHB1c2hSZXNwb25zZUludGVyY2VwdG9ycyhpbnRlcmNlcHRvcikge1xuXHQgICAgY2hhaW4ucHVzaChpbnRlcmNlcHRvci5mdWxmaWxsZWQsIGludGVyY2VwdG9yLnJlamVjdGVkKTtcblx0ICB9KTtcblx0XG5cdCAgd2hpbGUgKGNoYWluLmxlbmd0aCkge1xuXHQgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihjaGFpbi5zaGlmdCgpLCBjaGFpbi5zaGlmdCgpKTtcblx0ICB9XG5cdFxuXHQgIHJldHVybiBwcm9taXNlO1xuXHR9O1xuXHRcblx0Ly8gUHJvdmlkZSBhbGlhc2VzIGZvciBzdXBwb3J0ZWQgcmVxdWVzdCBtZXRob2RzXG5cdHV0aWxzLmZvckVhY2goWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAnb3B0aW9ucyddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kTm9EYXRhKG1ldGhvZCkge1xuXHQgIC8qZXNsaW50IGZ1bmMtbmFtZXM6MCovXG5cdCAgQXhpb3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbih1cmwsIGNvbmZpZykge1xuXHQgICAgcmV0dXJuIHRoaXMucmVxdWVzdCh1dGlscy5tZXJnZShjb25maWcgfHwge30sIHtcblx0ICAgICAgbWV0aG9kOiBtZXRob2QsXG5cdCAgICAgIHVybDogdXJsXG5cdCAgICB9KSk7XG5cdCAgfTtcblx0fSk7XG5cdFxuXHR1dGlscy5mb3JFYWNoKFsncG9zdCcsICdwdXQnLCAncGF0Y2gnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZFdpdGhEYXRhKG1ldGhvZCkge1xuXHQgIC8qZXNsaW50IGZ1bmMtbmFtZXM6MCovXG5cdCAgQXhpb3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbih1cmwsIGRhdGEsIGNvbmZpZykge1xuXHQgICAgcmV0dXJuIHRoaXMucmVxdWVzdCh1dGlscy5tZXJnZShjb25maWcgfHwge30sIHtcblx0ICAgICAgbWV0aG9kOiBtZXRob2QsXG5cdCAgICAgIHVybDogdXJsLFxuXHQgICAgICBkYXRhOiBkYXRhXG5cdCAgICB9KSk7XG5cdCAgfTtcblx0fSk7XG5cdFxuXHRtb2R1bGUuZXhwb3J0cyA9IEF4aW9zO1xuXG5cbi8qKiovIH0pLFxuLyogNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdHZhciB1dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cdHZhciBub3JtYWxpemVIZWFkZXJOYW1lID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblx0XG5cdHZhciBERUZBVUxUX0NPTlRFTlRfVFlQRSA9IHtcblx0ICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCdcblx0fTtcblx0XG5cdGZ1bmN0aW9uIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCB2YWx1ZSkge1xuXHQgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoaGVhZGVycykgJiYgdXRpbHMuaXNVbmRlZmluZWQoaGVhZGVyc1snQ29udGVudC1UeXBlJ10pKSB7XG5cdCAgICBoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9IHZhbHVlO1xuXHQgIH1cblx0fVxuXHRcblx0ZnVuY3Rpb24gZ2V0RGVmYXVsdEFkYXB0ZXIoKSB7XG5cdCAgdmFyIGFkYXB0ZXI7XG5cdCAgaWYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0ICAgIC8vIEZvciBicm93c2VycyB1c2UgWEhSIGFkYXB0ZXJcblx0ICAgIGFkYXB0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXHQgIH0gZWxzZSBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnKSB7XG5cdCAgICAvLyBGb3Igbm9kZSB1c2UgSFRUUCBhZGFwdGVyXG5cdCAgICBhZGFwdGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblx0ICB9XG5cdCAgcmV0dXJuIGFkYXB0ZXI7XG5cdH1cblx0XG5cdHZhciBkZWZhdWx0cyA9IHtcblx0ICBhZGFwdGVyOiBnZXREZWZhdWx0QWRhcHRlcigpLFxuXHRcblx0ICB0cmFuc2Zvcm1SZXF1ZXN0OiBbZnVuY3Rpb24gdHJhbnNmb3JtUmVxdWVzdChkYXRhLCBoZWFkZXJzKSB7XG5cdCAgICBub3JtYWxpemVIZWFkZXJOYW1lKGhlYWRlcnMsICdDb250ZW50LVR5cGUnKTtcblx0ICAgIGlmICh1dGlscy5pc0Zvcm1EYXRhKGRhdGEpIHx8XG5cdCAgICAgIHV0aWxzLmlzQXJyYXlCdWZmZXIoZGF0YSkgfHxcblx0ICAgICAgdXRpbHMuaXNCdWZmZXIoZGF0YSkgfHxcblx0ICAgICAgdXRpbHMuaXNTdHJlYW0oZGF0YSkgfHxcblx0ICAgICAgdXRpbHMuaXNGaWxlKGRhdGEpIHx8XG5cdCAgICAgIHV0aWxzLmlzQmxvYihkYXRhKVxuXHQgICAgKSB7XG5cdCAgICAgIHJldHVybiBkYXRhO1xuXHQgICAgfVxuXHQgICAgaWYgKHV0aWxzLmlzQXJyYXlCdWZmZXJWaWV3KGRhdGEpKSB7XG5cdCAgICAgIHJldHVybiBkYXRhLmJ1ZmZlcjtcblx0ICAgIH1cblx0ICAgIGlmICh1dGlscy5pc1VSTFNlYXJjaFBhcmFtcyhkYXRhKSkge1xuXHQgICAgICBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PXV0Zi04Jyk7XG5cdCAgICAgIHJldHVybiBkYXRhLnRvU3RyaW5nKCk7XG5cdCAgICB9XG5cdCAgICBpZiAodXRpbHMuaXNPYmplY3QoZGF0YSkpIHtcblx0ICAgICAgc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsICdhcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTgnKTtcblx0ICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGRhdGE7XG5cdCAgfV0sXG5cdFxuXHQgIHRyYW5zZm9ybVJlc3BvbnNlOiBbZnVuY3Rpb24gdHJhbnNmb3JtUmVzcG9uc2UoZGF0YSkge1xuXHQgICAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG5cdCAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG5cdCAgICAgIHRyeSB7XG5cdCAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XG5cdCAgICAgIH0gY2F0Y2ggKGUpIHsgLyogSWdub3JlICovIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiBkYXRhO1xuXHQgIH1dLFxuXHRcblx0ICAvKipcblx0ICAgKiBBIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIHRvIGFib3J0IGEgcmVxdWVzdC4gSWYgc2V0IHRvIDAgKGRlZmF1bHQpIGFcblx0ICAgKiB0aW1lb3V0IGlzIG5vdCBjcmVhdGVkLlxuXHQgICAqL1xuXHQgIHRpbWVvdXQ6IDAsXG5cdFxuXHQgIHhzcmZDb29raWVOYW1lOiAnWFNSRi1UT0tFTicsXG5cdCAgeHNyZkhlYWRlck5hbWU6ICdYLVhTUkYtVE9LRU4nLFxuXHRcblx0ICBtYXhDb250ZW50TGVuZ3RoOiAtMSxcblx0XG5cdCAgdmFsaWRhdGVTdGF0dXM6IGZ1bmN0aW9uIHZhbGlkYXRlU3RhdHVzKHN0YXR1cykge1xuXHQgICAgcmV0dXJuIHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwO1xuXHQgIH1cblx0fTtcblx0XG5cdGRlZmF1bHRzLmhlYWRlcnMgPSB7XG5cdCAgY29tbW9uOiB7XG5cdCAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24sIHRleHQvcGxhaW4sICovKidcblx0ICB9XG5cdH07XG5cdFxuXHR1dGlscy5mb3JFYWNoKFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2ROb0RhdGEobWV0aG9kKSB7XG5cdCAgZGVmYXVsdHMuaGVhZGVyc1ttZXRob2RdID0ge307XG5cdH0pO1xuXHRcblx0dXRpbHMuZm9yRWFjaChbJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2RXaXRoRGF0YShtZXRob2QpIHtcblx0ICBkZWZhdWx0cy5oZWFkZXJzW21ldGhvZF0gPSB1dGlscy5tZXJnZShERUZBVUxUX0NPTlRFTlRfVFlQRSk7XG5cdH0pO1xuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSBkZWZhdWx0cztcblxuXG4vKioqLyB9KSxcbi8qIDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHR2YXIgdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBub3JtYWxpemVIZWFkZXJOYW1lKGhlYWRlcnMsIG5vcm1hbGl6ZWROYW1lKSB7XG5cdCAgdXRpbHMuZm9yRWFjaChoZWFkZXJzLCBmdW5jdGlvbiBwcm9jZXNzSGVhZGVyKHZhbHVlLCBuYW1lKSB7XG5cdCAgICBpZiAobmFtZSAhPT0gbm9ybWFsaXplZE5hbWUgJiYgbmFtZS50b1VwcGVyQ2FzZSgpID09PSBub3JtYWxpemVkTmFtZS50b1VwcGVyQ2FzZSgpKSB7XG5cdCAgICAgIGhlYWRlcnNbbm9ybWFsaXplZE5hbWVdID0gdmFsdWU7XG5cdCAgICAgIGRlbGV0ZSBoZWFkZXJzW25hbWVdO1xuXHQgICAgfVxuXHQgIH0pO1xuXHR9O1xuXG5cbi8qKiovIH0pLFxuLyogOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdHZhciB1dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cdHZhciBzZXR0bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXHR2YXIgYnVpbGRVUkwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcblx0dmFyIHBhcnNlSGVhZGVycyA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuXHR2YXIgaXNVUkxTYW1lT3JpZ2luID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG5cdHZhciBjcmVhdGVFcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xuXHR2YXIgYnRvYSA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuYnRvYSAmJiB3aW5kb3cuYnRvYS5iaW5kKHdpbmRvdykpIHx8IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB4aHJBZGFwdGVyKGNvbmZpZykge1xuXHQgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiBkaXNwYXRjaFhoclJlcXVlc3QocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdCAgICB2YXIgcmVxdWVzdERhdGEgPSBjb25maWcuZGF0YTtcblx0ICAgIHZhciByZXF1ZXN0SGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzO1xuXHRcblx0ICAgIGlmICh1dGlscy5pc0Zvcm1EYXRhKHJlcXVlc3REYXRhKSkge1xuXHQgICAgICBkZWxldGUgcmVxdWVzdEhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddOyAvLyBMZXQgdGhlIGJyb3dzZXIgc2V0IGl0XG5cdCAgICB9XG5cdFxuXHQgICAgdmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblx0ICAgIHZhciBsb2FkRXZlbnQgPSAnb25yZWFkeXN0YXRlY2hhbmdlJztcblx0ICAgIHZhciB4RG9tYWluID0gZmFsc2U7XG5cdFxuXHQgICAgLy8gRm9yIElFIDgvOSBDT1JTIHN1cHBvcnRcblx0ICAgIC8vIE9ubHkgc3VwcG9ydHMgUE9TVCBhbmQgR0VUIGNhbGxzIGFuZCBkb2Vzbid0IHJldHVybnMgdGhlIHJlc3BvbnNlIGhlYWRlcnMuXG5cdCAgICAvLyBET04nVCBkbyB0aGlzIGZvciB0ZXN0aW5nIGIvYyBYTUxIdHRwUmVxdWVzdCBpcyBtb2NrZWQsIG5vdCBYRG9tYWluUmVxdWVzdC5cblx0ICAgIGlmICgoXCJwcm9kdWN0aW9uXCIpICE9PSAndGVzdCcgJiZcblx0ICAgICAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuXHQgICAgICAgIHdpbmRvdy5YRG9tYWluUmVxdWVzdCAmJiAhKCd3aXRoQ3JlZGVudGlhbHMnIGluIHJlcXVlc3QpICYmXG5cdCAgICAgICAgIWlzVVJMU2FtZU9yaWdpbihjb25maWcudXJsKSkge1xuXHQgICAgICByZXF1ZXN0ID0gbmV3IHdpbmRvdy5YRG9tYWluUmVxdWVzdCgpO1xuXHQgICAgICBsb2FkRXZlbnQgPSAnb25sb2FkJztcblx0ICAgICAgeERvbWFpbiA9IHRydWU7XG5cdCAgICAgIHJlcXVlc3Qub25wcm9ncmVzcyA9IGZ1bmN0aW9uIGhhbmRsZVByb2dyZXNzKCkge307XG5cdCAgICAgIHJlcXVlc3Qub250aW1lb3V0ID0gZnVuY3Rpb24gaGFuZGxlVGltZW91dCgpIHt9O1xuXHQgICAgfVxuXHRcblx0ICAgIC8vIEhUVFAgYmFzaWMgYXV0aGVudGljYXRpb25cblx0ICAgIGlmIChjb25maWcuYXV0aCkge1xuXHQgICAgICB2YXIgdXNlcm5hbWUgPSBjb25maWcuYXV0aC51c2VybmFtZSB8fCAnJztcblx0ICAgICAgdmFyIHBhc3N3b3JkID0gY29uZmlnLmF1dGgucGFzc3dvcmQgfHwgJyc7XG5cdCAgICAgIHJlcXVlc3RIZWFkZXJzLkF1dGhvcml6YXRpb24gPSAnQmFzaWMgJyArIGJ0b2EodXNlcm5hbWUgKyAnOicgKyBwYXNzd29yZCk7XG5cdCAgICB9XG5cdFxuXHQgICAgcmVxdWVzdC5vcGVuKGNvbmZpZy5tZXRob2QudG9VcHBlckNhc2UoKSwgYnVpbGRVUkwoY29uZmlnLnVybCwgY29uZmlnLnBhcmFtcywgY29uZmlnLnBhcmFtc1NlcmlhbGl6ZXIpLCB0cnVlKTtcblx0XG5cdCAgICAvLyBTZXQgdGhlIHJlcXVlc3QgdGltZW91dCBpbiBNU1xuXHQgICAgcmVxdWVzdC50aW1lb3V0ID0gY29uZmlnLnRpbWVvdXQ7XG5cdFxuXHQgICAgLy8gTGlzdGVuIGZvciByZWFkeSBzdGF0ZVxuXHQgICAgcmVxdWVzdFtsb2FkRXZlbnRdID0gZnVuY3Rpb24gaGFuZGxlTG9hZCgpIHtcblx0ICAgICAgaWYgKCFyZXF1ZXN0IHx8IChyZXF1ZXN0LnJlYWR5U3RhdGUgIT09IDQgJiYgIXhEb21haW4pKSB7XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgICB9XG5cdFxuXHQgICAgICAvLyBUaGUgcmVxdWVzdCBlcnJvcmVkIG91dCBhbmQgd2UgZGlkbid0IGdldCBhIHJlc3BvbnNlLCB0aGlzIHdpbGwgYmVcblx0ICAgICAgLy8gaGFuZGxlZCBieSBvbmVycm9yIGluc3RlYWRcblx0ICAgICAgLy8gV2l0aCBvbmUgZXhjZXB0aW9uOiByZXF1ZXN0IHRoYXQgdXNpbmcgZmlsZTogcHJvdG9jb2wsIG1vc3QgYnJvd3NlcnNcblx0ICAgICAgLy8gd2lsbCByZXR1cm4gc3RhdHVzIGFzIDAgZXZlbiB0aG91Z2ggaXQncyBhIHN1Y2Nlc3NmdWwgcmVxdWVzdFxuXHQgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDAgJiYgIShyZXF1ZXN0LnJlc3BvbnNlVVJMICYmIHJlcXVlc3QucmVzcG9uc2VVUkwuaW5kZXhPZignZmlsZTonKSA9PT0gMCkpIHtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblx0XG5cdCAgICAgIC8vIFByZXBhcmUgdGhlIHJlc3BvbnNlXG5cdCAgICAgIHZhciByZXNwb25zZUhlYWRlcnMgPSAnZ2V0QWxsUmVzcG9uc2VIZWFkZXJzJyBpbiByZXF1ZXN0ID8gcGFyc2VIZWFkZXJzKHJlcXVlc3QuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpIDogbnVsbDtcblx0ICAgICAgdmFyIHJlc3BvbnNlRGF0YSA9ICFjb25maWcucmVzcG9uc2VUeXBlIHx8IGNvbmZpZy5yZXNwb25zZVR5cGUgPT09ICd0ZXh0JyA/IHJlcXVlc3QucmVzcG9uc2VUZXh0IDogcmVxdWVzdC5yZXNwb25zZTtcblx0ICAgICAgdmFyIHJlc3BvbnNlID0ge1xuXHQgICAgICAgIGRhdGE6IHJlc3BvbnNlRGF0YSxcblx0ICAgICAgICAvLyBJRSBzZW5kcyAxMjIzIGluc3RlYWQgb2YgMjA0IChodHRwczovL2dpdGh1Yi5jb20vYXhpb3MvYXhpb3MvaXNzdWVzLzIwMSlcblx0ICAgICAgICBzdGF0dXM6IHJlcXVlc3Quc3RhdHVzID09PSAxMjIzID8gMjA0IDogcmVxdWVzdC5zdGF0dXMsXG5cdCAgICAgICAgc3RhdHVzVGV4dDogcmVxdWVzdC5zdGF0dXMgPT09IDEyMjMgPyAnTm8gQ29udGVudCcgOiByZXF1ZXN0LnN0YXR1c1RleHQsXG5cdCAgICAgICAgaGVhZGVyczogcmVzcG9uc2VIZWFkZXJzLFxuXHQgICAgICAgIGNvbmZpZzogY29uZmlnLFxuXHQgICAgICAgIHJlcXVlc3Q6IHJlcXVlc3Rcblx0ICAgICAgfTtcblx0XG5cdCAgICAgIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHJlc3BvbnNlKTtcblx0XG5cdCAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3Rcblx0ICAgICAgcmVxdWVzdCA9IG51bGw7XG5cdCAgICB9O1xuXHRcblx0ICAgIC8vIEhhbmRsZSBsb3cgbGV2ZWwgbmV0d29yayBlcnJvcnNcblx0ICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uIGhhbmRsZUVycm9yKCkge1xuXHQgICAgICAvLyBSZWFsIGVycm9ycyBhcmUgaGlkZGVuIGZyb20gdXMgYnkgdGhlIGJyb3dzZXJcblx0ICAgICAgLy8gb25lcnJvciBzaG91bGQgb25seSBmaXJlIGlmIGl0J3MgYSBuZXR3b3JrIGVycm9yXG5cdCAgICAgIHJlamVjdChjcmVhdGVFcnJvcignTmV0d29yayBFcnJvcicsIGNvbmZpZywgbnVsbCwgcmVxdWVzdCkpO1xuXHRcblx0ICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuXHQgICAgICByZXF1ZXN0ID0gbnVsbDtcblx0ICAgIH07XG5cdFxuXHQgICAgLy8gSGFuZGxlIHRpbWVvdXRcblx0ICAgIHJlcXVlc3Qub250aW1lb3V0ID0gZnVuY3Rpb24gaGFuZGxlVGltZW91dCgpIHtcblx0ICAgICAgcmVqZWN0KGNyZWF0ZUVycm9yKCd0aW1lb3V0IG9mICcgKyBjb25maWcudGltZW91dCArICdtcyBleGNlZWRlZCcsIGNvbmZpZywgJ0VDT05OQUJPUlRFRCcsXG5cdCAgICAgICAgcmVxdWVzdCkpO1xuXHRcblx0ICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuXHQgICAgICByZXF1ZXN0ID0gbnVsbDtcblx0ICAgIH07XG5cdFxuXHQgICAgLy8gQWRkIHhzcmYgaGVhZGVyXG5cdCAgICAvLyBUaGlzIGlzIG9ubHkgZG9uZSBpZiBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciBlbnZpcm9ubWVudC5cblx0ICAgIC8vIFNwZWNpZmljYWxseSBub3QgaWYgd2UncmUgaW4gYSB3ZWIgd29ya2VyLCBvciByZWFjdC1uYXRpdmUuXG5cdCAgICBpZiAodXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSkge1xuXHQgICAgICB2YXIgY29va2llcyA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xuXHRcblx0ICAgICAgLy8gQWRkIHhzcmYgaGVhZGVyXG5cdCAgICAgIHZhciB4c3JmVmFsdWUgPSAoY29uZmlnLndpdGhDcmVkZW50aWFscyB8fCBpc1VSTFNhbWVPcmlnaW4oY29uZmlnLnVybCkpICYmIGNvbmZpZy54c3JmQ29va2llTmFtZSA/XG5cdCAgICAgICAgICBjb29raWVzLnJlYWQoY29uZmlnLnhzcmZDb29raWVOYW1lKSA6XG5cdCAgICAgICAgICB1bmRlZmluZWQ7XG5cdFxuXHQgICAgICBpZiAoeHNyZlZhbHVlKSB7XG5cdCAgICAgICAgcmVxdWVzdEhlYWRlcnNbY29uZmlnLnhzcmZIZWFkZXJOYW1lXSA9IHhzcmZWYWx1ZTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHRcblx0ICAgIC8vIEFkZCBoZWFkZXJzIHRvIHRoZSByZXF1ZXN0XG5cdCAgICBpZiAoJ3NldFJlcXVlc3RIZWFkZXInIGluIHJlcXVlc3QpIHtcblx0ICAgICAgdXRpbHMuZm9yRWFjaChyZXF1ZXN0SGVhZGVycywgZnVuY3Rpb24gc2V0UmVxdWVzdEhlYWRlcih2YWwsIGtleSkge1xuXHQgICAgICAgIGlmICh0eXBlb2YgcmVxdWVzdERhdGEgPT09ICd1bmRlZmluZWQnICYmIGtleS50b0xvd2VyQ2FzZSgpID09PSAnY29udGVudC10eXBlJykge1xuXHQgICAgICAgICAgLy8gUmVtb3ZlIENvbnRlbnQtVHlwZSBpZiBkYXRhIGlzIHVuZGVmaW5lZFxuXHQgICAgICAgICAgZGVsZXRlIHJlcXVlc3RIZWFkZXJzW2tleV07XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIC8vIE90aGVyd2lzZSBhZGQgaGVhZGVyIHRvIHRoZSByZXF1ZXN0XG5cdCAgICAgICAgICByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWwpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSk7XG5cdCAgICB9XG5cdFxuXHQgICAgLy8gQWRkIHdpdGhDcmVkZW50aWFscyB0byByZXF1ZXN0IGlmIG5lZWRlZFxuXHQgICAgaWYgKGNvbmZpZy53aXRoQ3JlZGVudGlhbHMpIHtcblx0ICAgICAgcmVxdWVzdC53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuXHQgICAgfVxuXHRcblx0ICAgIC8vIEFkZCByZXNwb25zZVR5cGUgdG8gcmVxdWVzdCBpZiBuZWVkZWRcblx0ICAgIGlmIChjb25maWcucmVzcG9uc2VUeXBlKSB7XG5cdCAgICAgIHRyeSB7XG5cdCAgICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSBjb25maWcucmVzcG9uc2VUeXBlO1xuXHQgICAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgICAgLy8gRXhwZWN0ZWQgRE9NRXhjZXB0aW9uIHRocm93biBieSBicm93c2VycyBub3QgY29tcGF0aWJsZSBYTUxIdHRwUmVxdWVzdCBMZXZlbCAyLlxuXHQgICAgICAgIC8vIEJ1dCwgdGhpcyBjYW4gYmUgc3VwcHJlc3NlZCBmb3IgJ2pzb24nIHR5cGUgYXMgaXQgY2FuIGJlIHBhcnNlZCBieSBkZWZhdWx0ICd0cmFuc2Zvcm1SZXNwb25zZScgZnVuY3Rpb24uXG5cdCAgICAgICAgaWYgKGNvbmZpZy5yZXNwb25zZVR5cGUgIT09ICdqc29uJykge1xuXHQgICAgICAgICAgdGhyb3cgZTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblx0XG5cdCAgICAvLyBIYW5kbGUgcHJvZ3Jlc3MgaWYgbmVlZGVkXG5cdCAgICBpZiAodHlwZW9mIGNvbmZpZy5vbkRvd25sb2FkUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGNvbmZpZy5vbkRvd25sb2FkUHJvZ3Jlc3MpO1xuXHQgICAgfVxuXHRcblx0ICAgIC8vIE5vdCBhbGwgYnJvd3NlcnMgc3VwcG9ydCB1cGxvYWQgZXZlbnRzXG5cdCAgICBpZiAodHlwZW9mIGNvbmZpZy5vblVwbG9hZFByb2dyZXNzID09PSAnZnVuY3Rpb24nICYmIHJlcXVlc3QudXBsb2FkKSB7XG5cdCAgICAgIHJlcXVlc3QudXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgY29uZmlnLm9uVXBsb2FkUHJvZ3Jlc3MpO1xuXHQgICAgfVxuXHRcblx0ICAgIGlmIChjb25maWcuY2FuY2VsVG9rZW4pIHtcblx0ICAgICAgLy8gSGFuZGxlIGNhbmNlbGxhdGlvblxuXHQgICAgICBjb25maWcuY2FuY2VsVG9rZW4ucHJvbWlzZS50aGVuKGZ1bmN0aW9uIG9uQ2FuY2VsZWQoY2FuY2VsKSB7XG5cdCAgICAgICAgaWYgKCFyZXF1ZXN0KSB7XG5cdCAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICByZXF1ZXN0LmFib3J0KCk7XG5cdCAgICAgICAgcmVqZWN0KGNhbmNlbCk7XG5cdCAgICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuXHQgICAgICAgIHJlcXVlc3QgPSBudWxsO1xuXHQgICAgICB9KTtcblx0ICAgIH1cblx0XG5cdCAgICBpZiAocmVxdWVzdERhdGEgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICByZXF1ZXN0RGF0YSA9IG51bGw7XG5cdCAgICB9XG5cdFxuXHQgICAgLy8gU2VuZCB0aGUgcmVxdWVzdFxuXHQgICAgcmVxdWVzdC5zZW5kKHJlcXVlc3REYXRhKTtcblx0ICB9KTtcblx0fTtcblxuXG4vKioqLyB9KSxcbi8qIDkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHR2YXIgY3JlYXRlRXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcblx0XG5cdC8qKlxuXHQgKiBSZXNvbHZlIG9yIHJlamVjdCBhIFByb21pc2UgYmFzZWQgb24gcmVzcG9uc2Ugc3RhdHVzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXNvbHZlIEEgZnVuY3Rpb24gdGhhdCByZXNvbHZlcyB0aGUgcHJvbWlzZS5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0IEEgZnVuY3Rpb24gdGhhdCByZWplY3RzIHRoZSBwcm9taXNlLlxuXHQgKiBAcGFyYW0ge29iamVjdH0gcmVzcG9uc2UgVGhlIHJlc3BvbnNlLlxuXHQgKi9cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCByZXNwb25zZSkge1xuXHQgIHZhciB2YWxpZGF0ZVN0YXR1cyA9IHJlc3BvbnNlLmNvbmZpZy52YWxpZGF0ZVN0YXR1cztcblx0ICAvLyBOb3RlOiBzdGF0dXMgaXMgbm90IGV4cG9zZWQgYnkgWERvbWFpblJlcXVlc3Rcblx0ICBpZiAoIXJlc3BvbnNlLnN0YXR1cyB8fCAhdmFsaWRhdGVTdGF0dXMgfHwgdmFsaWRhdGVTdGF0dXMocmVzcG9uc2Uuc3RhdHVzKSkge1xuXHQgICAgcmVzb2x2ZShyZXNwb25zZSk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHJlamVjdChjcmVhdGVFcnJvcihcblx0ICAgICAgJ1JlcXVlc3QgZmFpbGVkIHdpdGggc3RhdHVzIGNvZGUgJyArIHJlc3BvbnNlLnN0YXR1cyxcblx0ICAgICAgcmVzcG9uc2UuY29uZmlnLFxuXHQgICAgICBudWxsLFxuXHQgICAgICByZXNwb25zZS5yZXF1ZXN0LFxuXHQgICAgICByZXNwb25zZVxuXHQgICAgKSk7XG5cdCAgfVxuXHR9O1xuXG5cbi8qKiovIH0pLFxuLyogMTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHR2YXIgZW5oYW5jZUVycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cdFxuXHQvKipcblx0ICogQ3JlYXRlIGFuIEVycm9yIHdpdGggdGhlIHNwZWNpZmllZCBtZXNzYWdlLCBjb25maWcsIGVycm9yIGNvZGUsIHJlcXVlc3QgYW5kIHJlc3BvbnNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSBUaGUgZXJyb3IgbWVzc2FnZS5cblx0ICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW2NvZGVdIFRoZSBlcnJvciBjb2RlIChmb3IgZXhhbXBsZSwgJ0VDT05OQUJPUlRFRCcpLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW3JlcXVlc3RdIFRoZSByZXF1ZXN0LlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW3Jlc3BvbnNlXSBUaGUgcmVzcG9uc2UuXG5cdCAqIEByZXR1cm5zIHtFcnJvcn0gVGhlIGNyZWF0ZWQgZXJyb3IuXG5cdCAqL1xuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZUVycm9yKG1lc3NhZ2UsIGNvbmZpZywgY29kZSwgcmVxdWVzdCwgcmVzcG9uc2UpIHtcblx0ICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG5cdCAgcmV0dXJuIGVuaGFuY2VFcnJvcihlcnJvciwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSk7XG5cdH07XG5cblxuLyoqKi8gfSksXG4vKiAxMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdC8qKlxuXHQgKiBVcGRhdGUgYW4gRXJyb3Igd2l0aCB0aGUgc3BlY2lmaWVkIGNvbmZpZywgZXJyb3IgY29kZSwgYW5kIHJlc3BvbnNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0Vycm9yfSBlcnJvciBUaGUgZXJyb3IgdG8gdXBkYXRlLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbY29kZV0gVGhlIGVycm9yIGNvZGUgKGZvciBleGFtcGxlLCAnRUNPTk5BQk9SVEVEJykuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbcmVxdWVzdF0gVGhlIHJlcXVlc3QuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbcmVzcG9uc2VdIFRoZSByZXNwb25zZS5cblx0ICogQHJldHVybnMge0Vycm9yfSBUaGUgZXJyb3IuXG5cdCAqL1xuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVuaGFuY2VFcnJvcihlcnJvciwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSkge1xuXHQgIGVycm9yLmNvbmZpZyA9IGNvbmZpZztcblx0ICBpZiAoY29kZSkge1xuXHQgICAgZXJyb3IuY29kZSA9IGNvZGU7XG5cdCAgfVxuXHQgIGVycm9yLnJlcXVlc3QgPSByZXF1ZXN0O1xuXHQgIGVycm9yLnJlc3BvbnNlID0gcmVzcG9uc2U7XG5cdCAgcmV0dXJuIGVycm9yO1xuXHR9O1xuXG5cbi8qKiovIH0pLFxuLyogMTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHR2YXIgdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXHRcblx0ZnVuY3Rpb24gZW5jb2RlKHZhbCkge1xuXHQgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQodmFsKS5cblx0ICAgIHJlcGxhY2UoLyU0MC9naSwgJ0AnKS5cblx0ICAgIHJlcGxhY2UoLyUzQS9naSwgJzonKS5cblx0ICAgIHJlcGxhY2UoLyUyNC9nLCAnJCcpLlxuXHQgICAgcmVwbGFjZSgvJTJDL2dpLCAnLCcpLlxuXHQgICAgcmVwbGFjZSgvJTIwL2csICcrJykuXG5cdCAgICByZXBsYWNlKC8lNUIvZ2ksICdbJykuXG5cdCAgICByZXBsYWNlKC8lNUQvZ2ksICddJyk7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBCdWlsZCBhIFVSTCBieSBhcHBlbmRpbmcgcGFyYW1zIHRvIHRoZSBlbmRcblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgYmFzZSBvZiB0aGUgdXJsIChlLmcuLCBodHRwOi8vd3d3Lmdvb2dsZS5jb20pXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBbcGFyYW1zXSBUaGUgcGFyYW1zIHRvIGJlIGFwcGVuZGVkXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBmb3JtYXR0ZWQgdXJsXG5cdCAqL1xuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJ1aWxkVVJMKHVybCwgcGFyYW1zLCBwYXJhbXNTZXJpYWxpemVyKSB7XG5cdCAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG5cdCAgaWYgKCFwYXJhbXMpIHtcblx0ICAgIHJldHVybiB1cmw7XG5cdCAgfVxuXHRcblx0ICB2YXIgc2VyaWFsaXplZFBhcmFtcztcblx0ICBpZiAocGFyYW1zU2VyaWFsaXplcikge1xuXHQgICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcmFtc1NlcmlhbGl6ZXIocGFyYW1zKTtcblx0ICB9IGVsc2UgaWYgKHV0aWxzLmlzVVJMU2VhcmNoUGFyYW1zKHBhcmFtcykpIHtcblx0ICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJhbXMudG9TdHJpbmcoKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgdmFyIHBhcnRzID0gW107XG5cdFxuXHQgICAgdXRpbHMuZm9yRWFjaChwYXJhbXMsIGZ1bmN0aW9uIHNlcmlhbGl6ZSh2YWwsIGtleSkge1xuXHQgICAgICBpZiAodmFsID09PSBudWxsIHx8IHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnKSB7XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgICB9XG5cdFxuXHQgICAgICBpZiAodXRpbHMuaXNBcnJheSh2YWwpKSB7XG5cdCAgICAgICAga2V5ID0ga2V5ICsgJ1tdJztcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICB2YWwgPSBbdmFsXTtcblx0ICAgICAgfVxuXHRcblx0ICAgICAgdXRpbHMuZm9yRWFjaCh2YWwsIGZ1bmN0aW9uIHBhcnNlVmFsdWUodikge1xuXHQgICAgICAgIGlmICh1dGlscy5pc0RhdGUodikpIHtcblx0ICAgICAgICAgIHYgPSB2LnRvSVNPU3RyaW5nKCk7XG5cdCAgICAgICAgfSBlbHNlIGlmICh1dGlscy5pc09iamVjdCh2KSkge1xuXHQgICAgICAgICAgdiA9IEpTT04uc3RyaW5naWZ5KHYpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBwYXJ0cy5wdXNoKGVuY29kZShrZXkpICsgJz0nICsgZW5jb2RlKHYpKTtcblx0ICAgICAgfSk7XG5cdCAgICB9KTtcblx0XG5cdCAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFydHMuam9pbignJicpO1xuXHQgIH1cblx0XG5cdCAgaWYgKHNlcmlhbGl6ZWRQYXJhbXMpIHtcblx0ICAgIHVybCArPSAodXJsLmluZGV4T2YoJz8nKSA9PT0gLTEgPyAnPycgOiAnJicpICsgc2VyaWFsaXplZFBhcmFtcztcblx0ICB9XG5cdFxuXHQgIHJldHVybiB1cmw7XG5cdH07XG5cblxuLyoqKi8gfSksXG4vKiAxMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdHZhciB1dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cdFxuXHQvLyBIZWFkZXJzIHdob3NlIGR1cGxpY2F0ZXMgYXJlIGlnbm9yZWQgYnkgbm9kZVxuXHQvLyBjLmYuIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvaHR0cC5odG1sI2h0dHBfbWVzc2FnZV9oZWFkZXJzXG5cdHZhciBpZ25vcmVEdXBsaWNhdGVPZiA9IFtcblx0ICAnYWdlJywgJ2F1dGhvcml6YXRpb24nLCAnY29udGVudC1sZW5ndGgnLCAnY29udGVudC10eXBlJywgJ2V0YWcnLFxuXHQgICdleHBpcmVzJywgJ2Zyb20nLCAnaG9zdCcsICdpZi1tb2RpZmllZC1zaW5jZScsICdpZi11bm1vZGlmaWVkLXNpbmNlJyxcblx0ICAnbGFzdC1tb2RpZmllZCcsICdsb2NhdGlvbicsICdtYXgtZm9yd2FyZHMnLCAncHJveHktYXV0aG9yaXphdGlvbicsXG5cdCAgJ3JlZmVyZXInLCAncmV0cnktYWZ0ZXInLCAndXNlci1hZ2VudCdcblx0XTtcblx0XG5cdC8qKlxuXHQgKiBQYXJzZSBoZWFkZXJzIGludG8gYW4gb2JqZWN0XG5cdCAqXG5cdCAqIGBgYFxuXHQgKiBEYXRlOiBXZWQsIDI3IEF1ZyAyMDE0IDA4OjU4OjQ5IEdNVFxuXHQgKiBDb250ZW50LVR5cGU6IGFwcGxpY2F0aW9uL2pzb25cblx0ICogQ29ubmVjdGlvbjoga2VlcC1hbGl2ZVxuXHQgKiBUcmFuc2Zlci1FbmNvZGluZzogY2h1bmtlZFxuXHQgKiBgYGBcblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IGhlYWRlcnMgSGVhZGVycyBuZWVkaW5nIHRvIGJlIHBhcnNlZFxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBIZWFkZXJzIHBhcnNlZCBpbnRvIGFuIG9iamVjdFxuXHQgKi9cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZUhlYWRlcnMoaGVhZGVycykge1xuXHQgIHZhciBwYXJzZWQgPSB7fTtcblx0ICB2YXIga2V5O1xuXHQgIHZhciB2YWw7XG5cdCAgdmFyIGk7XG5cdFxuXHQgIGlmICghaGVhZGVycykgeyByZXR1cm4gcGFyc2VkOyB9XG5cdFxuXHQgIHV0aWxzLmZvckVhY2goaGVhZGVycy5zcGxpdCgnXFxuJyksIGZ1bmN0aW9uIHBhcnNlcihsaW5lKSB7XG5cdCAgICBpID0gbGluZS5pbmRleE9mKCc6Jyk7XG5cdCAgICBrZXkgPSB1dGlscy50cmltKGxpbmUuc3Vic3RyKDAsIGkpKS50b0xvd2VyQ2FzZSgpO1xuXHQgICAgdmFsID0gdXRpbHMudHJpbShsaW5lLnN1YnN0cihpICsgMSkpO1xuXHRcblx0ICAgIGlmIChrZXkpIHtcblx0ICAgICAgaWYgKHBhcnNlZFtrZXldICYmIGlnbm9yZUR1cGxpY2F0ZU9mLmluZGV4T2Yoa2V5KSA+PSAwKSB7XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgICB9XG5cdCAgICAgIGlmIChrZXkgPT09ICdzZXQtY29va2llJykge1xuXHQgICAgICAgIHBhcnNlZFtrZXldID0gKHBhcnNlZFtrZXldID8gcGFyc2VkW2tleV0gOiBbXSkuY29uY2F0KFt2YWxdKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBwYXJzZWRba2V5XSA9IHBhcnNlZFtrZXldID8gcGFyc2VkW2tleV0gKyAnLCAnICsgdmFsIDogdmFsO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSk7XG5cdFxuXHQgIHJldHVybiBwYXJzZWQ7XG5cdH07XG5cblxuLyoqKi8gfSksXG4vKiAxNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdHZhciB1dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cdFxuXHRtb2R1bGUuZXhwb3J0cyA9IChcblx0ICB1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpID9cblx0XG5cdCAgLy8gU3RhbmRhcmQgYnJvd3NlciBlbnZzIGhhdmUgZnVsbCBzdXBwb3J0IG9mIHRoZSBBUElzIG5lZWRlZCB0byB0ZXN0XG5cdCAgLy8gd2hldGhlciB0aGUgcmVxdWVzdCBVUkwgaXMgb2YgdGhlIHNhbWUgb3JpZ2luIGFzIGN1cnJlbnQgbG9jYXRpb24uXG5cdCAgKGZ1bmN0aW9uIHN0YW5kYXJkQnJvd3NlckVudigpIHtcblx0ICAgIHZhciBtc2llID0gLyhtc2llfHRyaWRlbnQpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblx0ICAgIHZhciB1cmxQYXJzaW5nTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcblx0ICAgIHZhciBvcmlnaW5VUkw7XG5cdFxuXHQgICAgLyoqXG5cdCAgICAqIFBhcnNlIGEgVVJMIHRvIGRpc2NvdmVyIGl0J3MgY29tcG9uZW50c1xuXHQgICAgKlxuXHQgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIFRoZSBVUkwgdG8gYmUgcGFyc2VkXG5cdCAgICAqIEByZXR1cm5zIHtPYmplY3R9XG5cdCAgICAqL1xuXHQgICAgZnVuY3Rpb24gcmVzb2x2ZVVSTCh1cmwpIHtcblx0ICAgICAgdmFyIGhyZWYgPSB1cmw7XG5cdFxuXHQgICAgICBpZiAobXNpZSkge1xuXHQgICAgICAgIC8vIElFIG5lZWRzIGF0dHJpYnV0ZSBzZXQgdHdpY2UgdG8gbm9ybWFsaXplIHByb3BlcnRpZXNcblx0ICAgICAgICB1cmxQYXJzaW5nTm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKTtcblx0ICAgICAgICBocmVmID0gdXJsUGFyc2luZ05vZGUuaHJlZjtcblx0ICAgICAgfVxuXHRcblx0ICAgICAgdXJsUGFyc2luZ05vZGUuc2V0QXR0cmlidXRlKCdocmVmJywgaHJlZik7XG5cdFxuXHQgICAgICAvLyB1cmxQYXJzaW5nTm9kZSBwcm92aWRlcyB0aGUgVXJsVXRpbHMgaW50ZXJmYWNlIC0gaHR0cDovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3VybHV0aWxzXG5cdCAgICAgIHJldHVybiB7XG5cdCAgICAgICAgaHJlZjogdXJsUGFyc2luZ05vZGUuaHJlZixcblx0ICAgICAgICBwcm90b2NvbDogdXJsUGFyc2luZ05vZGUucHJvdG9jb2wgPyB1cmxQYXJzaW5nTm9kZS5wcm90b2NvbC5yZXBsYWNlKC86JC8sICcnKSA6ICcnLFxuXHQgICAgICAgIGhvc3Q6IHVybFBhcnNpbmdOb2RlLmhvc3QsXG5cdCAgICAgICAgc2VhcmNoOiB1cmxQYXJzaW5nTm9kZS5zZWFyY2ggPyB1cmxQYXJzaW5nTm9kZS5zZWFyY2gucmVwbGFjZSgvXlxcPy8sICcnKSA6ICcnLFxuXHQgICAgICAgIGhhc2g6IHVybFBhcnNpbmdOb2RlLmhhc2ggPyB1cmxQYXJzaW5nTm9kZS5oYXNoLnJlcGxhY2UoL14jLywgJycpIDogJycsXG5cdCAgICAgICAgaG9zdG5hbWU6IHVybFBhcnNpbmdOb2RlLmhvc3RuYW1lLFxuXHQgICAgICAgIHBvcnQ6IHVybFBhcnNpbmdOb2RlLnBvcnQsXG5cdCAgICAgICAgcGF0aG5hbWU6ICh1cmxQYXJzaW5nTm9kZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJykgP1xuXHQgICAgICAgICAgICAgICAgICB1cmxQYXJzaW5nTm9kZS5wYXRobmFtZSA6XG5cdCAgICAgICAgICAgICAgICAgICcvJyArIHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lXG5cdCAgICAgIH07XG5cdCAgICB9XG5cdFxuXHQgICAgb3JpZ2luVVJMID0gcmVzb2x2ZVVSTCh3aW5kb3cubG9jYXRpb24uaHJlZik7XG5cdFxuXHQgICAgLyoqXG5cdCAgICAqIERldGVybWluZSBpZiBhIFVSTCBzaGFyZXMgdGhlIHNhbWUgb3JpZ2luIGFzIHRoZSBjdXJyZW50IGxvY2F0aW9uXG5cdCAgICAqXG5cdCAgICAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0VVJMIFRoZSBVUkwgdG8gdGVzdFxuXHQgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBVUkwgc2hhcmVzIHRoZSBzYW1lIG9yaWdpbiwgb3RoZXJ3aXNlIGZhbHNlXG5cdCAgICAqL1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIGlzVVJMU2FtZU9yaWdpbihyZXF1ZXN0VVJMKSB7XG5cdCAgICAgIHZhciBwYXJzZWQgPSAodXRpbHMuaXNTdHJpbmcocmVxdWVzdFVSTCkpID8gcmVzb2x2ZVVSTChyZXF1ZXN0VVJMKSA6IHJlcXVlc3RVUkw7XG5cdCAgICAgIHJldHVybiAocGFyc2VkLnByb3RvY29sID09PSBvcmlnaW5VUkwucHJvdG9jb2wgJiZcblx0ICAgICAgICAgICAgcGFyc2VkLmhvc3QgPT09IG9yaWdpblVSTC5ob3N0KTtcblx0ICAgIH07XG5cdCAgfSkoKSA6XG5cdFxuXHQgIC8vIE5vbiBzdGFuZGFyZCBicm93c2VyIGVudnMgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG5cdCAgKGZ1bmN0aW9uIG5vblN0YW5kYXJkQnJvd3NlckVudigpIHtcblx0ICAgIHJldHVybiBmdW5jdGlvbiBpc1VSTFNhbWVPcmlnaW4oKSB7XG5cdCAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfTtcblx0ICB9KSgpXG5cdCk7XG5cblxuLyoqKi8gfSksXG4vKiAxNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdC8vIGJ0b2EgcG9seWZpbGwgZm9yIElFPDEwIGNvdXJ0ZXN5IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXZpZGNoYW1iZXJzL0Jhc2U2NC5qc1xuXHRcblx0dmFyIGNoYXJzID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89Jztcblx0XG5cdGZ1bmN0aW9uIEUoKSB7XG5cdCAgdGhpcy5tZXNzYWdlID0gJ1N0cmluZyBjb250YWlucyBhbiBpbnZhbGlkIGNoYXJhY3Rlcic7XG5cdH1cblx0RS5wcm90b3R5cGUgPSBuZXcgRXJyb3I7XG5cdEUucHJvdG90eXBlLmNvZGUgPSA1O1xuXHRFLnByb3RvdHlwZS5uYW1lID0gJ0ludmFsaWRDaGFyYWN0ZXJFcnJvcic7XG5cdFxuXHRmdW5jdGlvbiBidG9hKGlucHV0KSB7XG5cdCAgdmFyIHN0ciA9IFN0cmluZyhpbnB1dCk7XG5cdCAgdmFyIG91dHB1dCA9ICcnO1xuXHQgIGZvciAoXG5cdCAgICAvLyBpbml0aWFsaXplIHJlc3VsdCBhbmQgY291bnRlclxuXHQgICAgdmFyIGJsb2NrLCBjaGFyQ29kZSwgaWR4ID0gMCwgbWFwID0gY2hhcnM7XG5cdCAgICAvLyBpZiB0aGUgbmV4dCBzdHIgaW5kZXggZG9lcyBub3QgZXhpc3Q6XG5cdCAgICAvLyAgIGNoYW5nZSB0aGUgbWFwcGluZyB0YWJsZSB0byBcIj1cIlxuXHQgICAgLy8gICBjaGVjayBpZiBkIGhhcyBubyBmcmFjdGlvbmFsIGRpZ2l0c1xuXHQgICAgc3RyLmNoYXJBdChpZHggfCAwKSB8fCAobWFwID0gJz0nLCBpZHggJSAxKTtcblx0ICAgIC8vIFwiOCAtIGlkeCAlIDEgKiA4XCIgZ2VuZXJhdGVzIHRoZSBzZXF1ZW5jZSAyLCA0LCA2LCA4XG5cdCAgICBvdXRwdXQgKz0gbWFwLmNoYXJBdCg2MyAmIGJsb2NrID4+IDggLSBpZHggJSAxICogOClcblx0ICApIHtcblx0ICAgIGNoYXJDb2RlID0gc3RyLmNoYXJDb2RlQXQoaWR4ICs9IDMgLyA0KTtcblx0ICAgIGlmIChjaGFyQ29kZSA+IDB4RkYpIHtcblx0ICAgICAgdGhyb3cgbmV3IEUoKTtcblx0ICAgIH1cblx0ICAgIGJsb2NrID0gYmxvY2sgPDwgOCB8IGNoYXJDb2RlO1xuXHQgIH1cblx0ICByZXR1cm4gb3V0cHV0O1xuXHR9XG5cdFxuXHRtb2R1bGUuZXhwb3J0cyA9IGJ0b2E7XG5cblxuLyoqKi8gfSksXG4vKiAxNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdHZhciB1dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cdFxuXHRtb2R1bGUuZXhwb3J0cyA9IChcblx0ICB1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpID9cblx0XG5cdCAgLy8gU3RhbmRhcmQgYnJvd3NlciBlbnZzIHN1cHBvcnQgZG9jdW1lbnQuY29va2llXG5cdCAgKGZ1bmN0aW9uIHN0YW5kYXJkQnJvd3NlckVudigpIHtcblx0ICAgIHJldHVybiB7XG5cdCAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZShuYW1lLCB2YWx1ZSwgZXhwaXJlcywgcGF0aCwgZG9tYWluLCBzZWN1cmUpIHtcblx0ICAgICAgICB2YXIgY29va2llID0gW107XG5cdCAgICAgICAgY29va2llLnB1c2gobmFtZSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpO1xuXHRcblx0ICAgICAgICBpZiAodXRpbHMuaXNOdW1iZXIoZXhwaXJlcykpIHtcblx0ICAgICAgICAgIGNvb2tpZS5wdXNoKCdleHBpcmVzPScgKyBuZXcgRGF0ZShleHBpcmVzKS50b0dNVFN0cmluZygpKTtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIGlmICh1dGlscy5pc1N0cmluZyhwYXRoKSkge1xuXHQgICAgICAgICAgY29va2llLnB1c2goJ3BhdGg9JyArIHBhdGgpO1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgaWYgKHV0aWxzLmlzU3RyaW5nKGRvbWFpbikpIHtcblx0ICAgICAgICAgIGNvb2tpZS5wdXNoKCdkb21haW49JyArIGRvbWFpbik7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICBpZiAoc2VjdXJlID09PSB0cnVlKSB7XG5cdCAgICAgICAgICBjb29raWUucHVzaCgnc2VjdXJlJyk7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICBkb2N1bWVudC5jb29raWUgPSBjb29raWUuam9pbignOyAnKTtcblx0ICAgICAgfSxcblx0XG5cdCAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQobmFtZSkge1xuXHQgICAgICAgIHZhciBtYXRjaCA9IGRvY3VtZW50LmNvb2tpZS5tYXRjaChuZXcgUmVnRXhwKCcoXnw7XFxcXHMqKSgnICsgbmFtZSArICcpPShbXjtdKiknKSk7XG5cdCAgICAgICAgcmV0dXJuIChtYXRjaCA/IGRlY29kZVVSSUNvbXBvbmVudChtYXRjaFszXSkgOiBudWxsKTtcblx0ICAgICAgfSxcblx0XG5cdCAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKG5hbWUpIHtcblx0ICAgICAgICB0aGlzLndyaXRlKG5hbWUsICcnLCBEYXRlLm5vdygpIC0gODY0MDAwMDApO1xuXHQgICAgICB9XG5cdCAgICB9O1xuXHQgIH0pKCkgOlxuXHRcblx0ICAvLyBOb24gc3RhbmRhcmQgYnJvd3NlciBlbnYgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG5cdCAgKGZ1bmN0aW9uIG5vblN0YW5kYXJkQnJvd3NlckVudigpIHtcblx0ICAgIHJldHVybiB7XG5cdCAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZSgpIHt9LFxuXHQgICAgICByZWFkOiBmdW5jdGlvbiByZWFkKCkgeyByZXR1cm4gbnVsbDsgfSxcblx0ICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7fVxuXHQgICAgfTtcblx0ICB9KSgpXG5cdCk7XG5cblxuLyoqKi8gfSksXG4vKiAxNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdHZhciB1dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cdFxuXHRmdW5jdGlvbiBJbnRlcmNlcHRvck1hbmFnZXIoKSB7XG5cdCAgdGhpcy5oYW5kbGVycyA9IFtdO1xuXHR9XG5cdFxuXHQvKipcblx0ICogQWRkIGEgbmV3IGludGVyY2VwdG9yIHRvIHRoZSBzdGFja1xuXHQgKlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdWxmaWxsZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgdGhlbmAgZm9yIGEgYFByb21pc2VgXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdGVkIFRoZSBmdW5jdGlvbiB0byBoYW5kbGUgYHJlamVjdGAgZm9yIGEgYFByb21pc2VgXG5cdCAqXG5cdCAqIEByZXR1cm4ge051bWJlcn0gQW4gSUQgdXNlZCB0byByZW1vdmUgaW50ZXJjZXB0b3IgbGF0ZXJcblx0ICovXG5cdEludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24gdXNlKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpIHtcblx0ICB0aGlzLmhhbmRsZXJzLnB1c2goe1xuXHQgICAgZnVsZmlsbGVkOiBmdWxmaWxsZWQsXG5cdCAgICByZWplY3RlZDogcmVqZWN0ZWRcblx0ICB9KTtcblx0ICByZXR1cm4gdGhpcy5oYW5kbGVycy5sZW5ndGggLSAxO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFJlbW92ZSBhbiBpbnRlcmNlcHRvciBmcm9tIHRoZSBzdGFja1xuXHQgKlxuXHQgKiBAcGFyYW0ge051bWJlcn0gaWQgVGhlIElEIHRoYXQgd2FzIHJldHVybmVkIGJ5IGB1c2VgXG5cdCAqL1xuXHRJbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLmVqZWN0ID0gZnVuY3Rpb24gZWplY3QoaWQpIHtcblx0ICBpZiAodGhpcy5oYW5kbGVyc1tpZF0pIHtcblx0ICAgIHRoaXMuaGFuZGxlcnNbaWRdID0gbnVsbDtcblx0ICB9XG5cdH07XG5cdFxuXHQvKipcblx0ICogSXRlcmF0ZSBvdmVyIGFsbCB0aGUgcmVnaXN0ZXJlZCBpbnRlcmNlcHRvcnNcblx0ICpcblx0ICogVGhpcyBtZXRob2QgaXMgcGFydGljdWxhcmx5IHVzZWZ1bCBmb3Igc2tpcHBpbmcgb3ZlciBhbnlcblx0ICogaW50ZXJjZXB0b3JzIHRoYXQgbWF5IGhhdmUgYmVjb21lIGBudWxsYCBjYWxsaW5nIGBlamVjdGAuXG5cdCAqXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIGludGVyY2VwdG9yXG5cdCAqL1xuXHRJbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoKGZuKSB7XG5cdCAgdXRpbHMuZm9yRWFjaCh0aGlzLmhhbmRsZXJzLCBmdW5jdGlvbiBmb3JFYWNoSGFuZGxlcihoKSB7XG5cdCAgICBpZiAoaCAhPT0gbnVsbCkge1xuXHQgICAgICBmbihoKTtcblx0ICAgIH1cblx0ICB9KTtcblx0fTtcblx0XG5cdG1vZHVsZS5leHBvcnRzID0gSW50ZXJjZXB0b3JNYW5hZ2VyO1xuXG5cbi8qKiovIH0pLFxuLyogMTggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHR2YXIgdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXHR2YXIgdHJhbnNmb3JtRGF0YSA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xuXHR2YXIgaXNDYW5jZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKTtcblx0dmFyIGRlZmF1bHRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblx0dmFyIGlzQWJzb2x1dGVVUkwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKTtcblx0dmFyIGNvbWJpbmVVUkxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMik7XG5cdFxuXHQvKipcblx0ICogVGhyb3dzIGEgYENhbmNlbGAgaWYgY2FuY2VsbGF0aW9uIGhhcyBiZWVuIHJlcXVlc3RlZC5cblx0ICovXG5cdGZ1bmN0aW9uIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKSB7XG5cdCAgaWYgKGNvbmZpZy5jYW5jZWxUb2tlbikge1xuXHQgICAgY29uZmlnLmNhbmNlbFRva2VuLnRocm93SWZSZXF1ZXN0ZWQoKTtcblx0ICB9XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBEaXNwYXRjaCBhIHJlcXVlc3QgdG8gdGhlIHNlcnZlciB1c2luZyB0aGUgY29uZmlndXJlZCBhZGFwdGVyLlxuXHQgKlxuXHQgKiBAcGFyYW0ge29iamVjdH0gY29uZmlnIFRoZSBjb25maWcgdGhhdCBpcyB0byBiZSB1c2VkIGZvciB0aGUgcmVxdWVzdFxuXHQgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIFByb21pc2UgdG8gYmUgZnVsZmlsbGVkXG5cdCAqL1xuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRpc3BhdGNoUmVxdWVzdChjb25maWcpIHtcblx0ICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cdFxuXHQgIC8vIFN1cHBvcnQgYmFzZVVSTCBjb25maWdcblx0ICBpZiAoY29uZmlnLmJhc2VVUkwgJiYgIWlzQWJzb2x1dGVVUkwoY29uZmlnLnVybCkpIHtcblx0ICAgIGNvbmZpZy51cmwgPSBjb21iaW5lVVJMcyhjb25maWcuYmFzZVVSTCwgY29uZmlnLnVybCk7XG5cdCAgfVxuXHRcblx0ICAvLyBFbnN1cmUgaGVhZGVycyBleGlzdFxuXHQgIGNvbmZpZy5oZWFkZXJzID0gY29uZmlnLmhlYWRlcnMgfHwge307XG5cdFxuXHQgIC8vIFRyYW5zZm9ybSByZXF1ZXN0IGRhdGFcblx0ICBjb25maWcuZGF0YSA9IHRyYW5zZm9ybURhdGEoXG5cdCAgICBjb25maWcuZGF0YSxcblx0ICAgIGNvbmZpZy5oZWFkZXJzLFxuXHQgICAgY29uZmlnLnRyYW5zZm9ybVJlcXVlc3Rcblx0ICApO1xuXHRcblx0ICAvLyBGbGF0dGVuIGhlYWRlcnNcblx0ICBjb25maWcuaGVhZGVycyA9IHV0aWxzLm1lcmdlKFxuXHQgICAgY29uZmlnLmhlYWRlcnMuY29tbW9uIHx8IHt9LFxuXHQgICAgY29uZmlnLmhlYWRlcnNbY29uZmlnLm1ldGhvZF0gfHwge30sXG5cdCAgICBjb25maWcuaGVhZGVycyB8fCB7fVxuXHQgICk7XG5cdFxuXHQgIHV0aWxzLmZvckVhY2goXG5cdCAgICBbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdwb3N0JywgJ3B1dCcsICdwYXRjaCcsICdjb21tb24nXSxcblx0ICAgIGZ1bmN0aW9uIGNsZWFuSGVhZGVyQ29uZmlnKG1ldGhvZCkge1xuXHQgICAgICBkZWxldGUgY29uZmlnLmhlYWRlcnNbbWV0aG9kXTtcblx0ICAgIH1cblx0ICApO1xuXHRcblx0ICB2YXIgYWRhcHRlciA9IGNvbmZpZy5hZGFwdGVyIHx8IGRlZmF1bHRzLmFkYXB0ZXI7XG5cdFxuXHQgIHJldHVybiBhZGFwdGVyKGNvbmZpZykudGhlbihmdW5jdGlvbiBvbkFkYXB0ZXJSZXNvbHV0aW9uKHJlc3BvbnNlKSB7XG5cdCAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cdFxuXHQgICAgLy8gVHJhbnNmb3JtIHJlc3BvbnNlIGRhdGFcblx0ICAgIHJlc3BvbnNlLmRhdGEgPSB0cmFuc2Zvcm1EYXRhKFxuXHQgICAgICByZXNwb25zZS5kYXRhLFxuXHQgICAgICByZXNwb25zZS5oZWFkZXJzLFxuXHQgICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2Vcblx0ICAgICk7XG5cdFxuXHQgICAgcmV0dXJuIHJlc3BvbnNlO1xuXHQgIH0sIGZ1bmN0aW9uIG9uQWRhcHRlclJlamVjdGlvbihyZWFzb24pIHtcblx0ICAgIGlmICghaXNDYW5jZWwocmVhc29uKSkge1xuXHQgICAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cdFxuXHQgICAgICAvLyBUcmFuc2Zvcm0gcmVzcG9uc2UgZGF0YVxuXHQgICAgICBpZiAocmVhc29uICYmIHJlYXNvbi5yZXNwb25zZSkge1xuXHQgICAgICAgIHJlYXNvbi5yZXNwb25zZS5kYXRhID0gdHJhbnNmb3JtRGF0YShcblx0ICAgICAgICAgIHJlYXNvbi5yZXNwb25zZS5kYXRhLFxuXHQgICAgICAgICAgcmVhc29uLnJlc3BvbnNlLmhlYWRlcnMsXG5cdCAgICAgICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2Vcblx0ICAgICAgICApO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdFxuXHQgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHJlYXNvbik7XG5cdCAgfSk7XG5cdH07XG5cblxuLyoqKi8gfSksXG4vKiAxOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdHZhciB1dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cdFxuXHQvKipcblx0ICogVHJhbnNmb3JtIHRoZSBkYXRhIGZvciBhIHJlcXVlc3Qgb3IgYSByZXNwb25zZVxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGRhdGEgVGhlIGRhdGEgdG8gYmUgdHJhbnNmb3JtZWRcblx0ICogQHBhcmFtIHtBcnJheX0gaGVhZGVycyBUaGUgaGVhZGVycyBmb3IgdGhlIHJlcXVlc3Qgb3IgcmVzcG9uc2Vcblx0ICogQHBhcmFtIHtBcnJheXxGdW5jdGlvbn0gZm5zIEEgc2luZ2xlIGZ1bmN0aW9uIG9yIEFycmF5IG9mIGZ1bmN0aW9uc1xuXHQgKiBAcmV0dXJucyB7Kn0gVGhlIHJlc3VsdGluZyB0cmFuc2Zvcm1lZCBkYXRhXG5cdCAqL1xuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRyYW5zZm9ybURhdGEoZGF0YSwgaGVhZGVycywgZm5zKSB7XG5cdCAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG5cdCAgdXRpbHMuZm9yRWFjaChmbnMsIGZ1bmN0aW9uIHRyYW5zZm9ybShmbikge1xuXHQgICAgZGF0YSA9IGZuKGRhdGEsIGhlYWRlcnMpO1xuXHQgIH0pO1xuXHRcblx0ICByZXR1cm4gZGF0YTtcblx0fTtcblxuXG4vKioqLyB9KSxcbi8qIDIwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0NhbmNlbCh2YWx1ZSkge1xuXHQgIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5fX0NBTkNFTF9fKTtcblx0fTtcblxuXG4vKioqLyB9KSxcbi8qIDIxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0LyoqXG5cdCAqIERldGVybWluZXMgd2hldGhlciB0aGUgc3BlY2lmaWVkIFVSTCBpcyBhYnNvbHV0ZVxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBVUkwgdG8gdGVzdFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIFVSTCBpcyBhYnNvbHV0ZSwgb3RoZXJ3aXNlIGZhbHNlXG5cdCAqL1xuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQWJzb2x1dGVVUkwodXJsKSB7XG5cdCAgLy8gQSBVUkwgaXMgY29uc2lkZXJlZCBhYnNvbHV0ZSBpZiBpdCBiZWdpbnMgd2l0aCBcIjxzY2hlbWU+Oi8vXCIgb3IgXCIvL1wiIChwcm90b2NvbC1yZWxhdGl2ZSBVUkwpLlxuXHQgIC8vIFJGQyAzOTg2IGRlZmluZXMgc2NoZW1lIG5hbWUgYXMgYSBzZXF1ZW5jZSBvZiBjaGFyYWN0ZXJzIGJlZ2lubmluZyB3aXRoIGEgbGV0dGVyIGFuZCBmb2xsb3dlZFxuXHQgIC8vIGJ5IGFueSBjb21iaW5hdGlvbiBvZiBsZXR0ZXJzLCBkaWdpdHMsIHBsdXMsIHBlcmlvZCwgb3IgaHlwaGVuLlxuXHQgIHJldHVybiAvXihbYS16XVthLXpcXGRcXCtcXC1cXC5dKjopP1xcL1xcLy9pLnRlc3QodXJsKTtcblx0fTtcblxuXG4vKioqLyB9KSxcbi8qIDIyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBuZXcgVVJMIGJ5IGNvbWJpbmluZyB0aGUgc3BlY2lmaWVkIFVSTHNcblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkwgVGhlIGJhc2UgVVJMXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSByZWxhdGl2ZVVSTCBUaGUgcmVsYXRpdmUgVVJMXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjb21iaW5lZCBVUkxcblx0ICovXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY29tYmluZVVSTHMoYmFzZVVSTCwgcmVsYXRpdmVVUkwpIHtcblx0ICByZXR1cm4gcmVsYXRpdmVVUkxcblx0ICAgID8gYmFzZVVSTC5yZXBsYWNlKC9cXC8rJC8sICcnKSArICcvJyArIHJlbGF0aXZlVVJMLnJlcGxhY2UoL15cXC8rLywgJycpXG5cdCAgICA6IGJhc2VVUkw7XG5cdH07XG5cblxuLyoqKi8gfSksXG4vKiAyMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdC8qKlxuXHQgKiBBIGBDYW5jZWxgIGlzIGFuIG9iamVjdCB0aGF0IGlzIHRocm93biB3aGVuIGFuIG9wZXJhdGlvbiBpcyBjYW5jZWxlZC5cblx0ICpcblx0ICogQGNsYXNzXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gbWVzc2FnZSBUaGUgbWVzc2FnZS5cblx0ICovXG5cdGZ1bmN0aW9uIENhbmNlbChtZXNzYWdlKSB7XG5cdCAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcblx0fVxuXHRcblx0Q2FuY2VsLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuXHQgIHJldHVybiAnQ2FuY2VsJyArICh0aGlzLm1lc3NhZ2UgPyAnOiAnICsgdGhpcy5tZXNzYWdlIDogJycpO1xuXHR9O1xuXHRcblx0Q2FuY2VsLnByb3RvdHlwZS5fX0NBTkNFTF9fID0gdHJ1ZTtcblx0XG5cdG1vZHVsZS5leHBvcnRzID0gQ2FuY2VsO1xuXG5cbi8qKiovIH0pLFxuLyogMjQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHR2YXIgQ2FuY2VsID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XG5cdFxuXHQvKipcblx0ICogQSBgQ2FuY2VsVG9rZW5gIGlzIGFuIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlcXVlc3QgY2FuY2VsbGF0aW9uIG9mIGFuIG9wZXJhdGlvbi5cblx0ICpcblx0ICogQGNsYXNzXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGV4ZWN1dG9yIFRoZSBleGVjdXRvciBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIENhbmNlbFRva2VuKGV4ZWN1dG9yKSB7XG5cdCAgaWYgKHR5cGVvZiBleGVjdXRvciAhPT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhlY3V0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uLicpO1xuXHQgIH1cblx0XG5cdCAgdmFyIHJlc29sdmVQcm9taXNlO1xuXHQgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIHByb21pc2VFeGVjdXRvcihyZXNvbHZlKSB7XG5cdCAgICByZXNvbHZlUHJvbWlzZSA9IHJlc29sdmU7XG5cdCAgfSk7XG5cdFxuXHQgIHZhciB0b2tlbiA9IHRoaXM7XG5cdCAgZXhlY3V0b3IoZnVuY3Rpb24gY2FuY2VsKG1lc3NhZ2UpIHtcblx0ICAgIGlmICh0b2tlbi5yZWFzb24pIHtcblx0ICAgICAgLy8gQ2FuY2VsbGF0aW9uIGhhcyBhbHJlYWR5IGJlZW4gcmVxdWVzdGVkXG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0XG5cdCAgICB0b2tlbi5yZWFzb24gPSBuZXcgQ2FuY2VsKG1lc3NhZ2UpO1xuXHQgICAgcmVzb2x2ZVByb21pc2UodG9rZW4ucmVhc29uKTtcblx0ICB9KTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIFRocm93cyBhIGBDYW5jZWxgIGlmIGNhbmNlbGxhdGlvbiBoYXMgYmVlbiByZXF1ZXN0ZWQuXG5cdCAqL1xuXHRDYW5jZWxUb2tlbi5wcm90b3R5cGUudGhyb3dJZlJlcXVlc3RlZCA9IGZ1bmN0aW9uIHRocm93SWZSZXF1ZXN0ZWQoKSB7XG5cdCAgaWYgKHRoaXMucmVhc29uKSB7XG5cdCAgICB0aHJvdyB0aGlzLnJlYXNvbjtcblx0ICB9XG5cdH07XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyBhbiBvYmplY3QgdGhhdCBjb250YWlucyBhIG5ldyBgQ2FuY2VsVG9rZW5gIGFuZCBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLFxuXHQgKiBjYW5jZWxzIHRoZSBgQ2FuY2VsVG9rZW5gLlxuXHQgKi9cblx0Q2FuY2VsVG9rZW4uc291cmNlID0gZnVuY3Rpb24gc291cmNlKCkge1xuXHQgIHZhciBjYW5jZWw7XG5cdCAgdmFyIHRva2VuID0gbmV3IENhbmNlbFRva2VuKGZ1bmN0aW9uIGV4ZWN1dG9yKGMpIHtcblx0ICAgIGNhbmNlbCA9IGM7XG5cdCAgfSk7XG5cdCAgcmV0dXJuIHtcblx0ICAgIHRva2VuOiB0b2tlbixcblx0ICAgIGNhbmNlbDogY2FuY2VsXG5cdCAgfTtcblx0fTtcblx0XG5cdG1vZHVsZS5leHBvcnRzID0gQ2FuY2VsVG9rZW47XG5cblxuLyoqKi8gfSksXG4vKiAyNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdC8qKlxuXHQgKiBTeW50YWN0aWMgc3VnYXIgZm9yIGludm9raW5nIGEgZnVuY3Rpb24gYW5kIGV4cGFuZGluZyBhbiBhcnJheSBmb3IgYXJndW1lbnRzLlxuXHQgKlxuXHQgKiBDb21tb24gdXNlIGNhc2Ugd291bGQgYmUgdG8gdXNlIGBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHlgLlxuXHQgKlxuXHQgKiAgYGBganNcblx0ICogIGZ1bmN0aW9uIGYoeCwgeSwgeikge31cblx0ICogIHZhciBhcmdzID0gWzEsIDIsIDNdO1xuXHQgKiAgZi5hcHBseShudWxsLCBhcmdzKTtcblx0ICogIGBgYFxuXHQgKlxuXHQgKiBXaXRoIGBzcHJlYWRgIHRoaXMgZXhhbXBsZSBjYW4gYmUgcmUtd3JpdHRlbi5cblx0ICpcblx0ICogIGBgYGpzXG5cdCAqICBzcHJlYWQoZnVuY3Rpb24oeCwgeSwgeikge30pKFsxLCAyLCAzXSk7XG5cdCAqICBgYGBcblx0ICpcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcblx0ICogQHJldHVybnMge0Z1bmN0aW9ufVxuXHQgKi9cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzcHJlYWQoY2FsbGJhY2spIHtcblx0ICByZXR1cm4gZnVuY3Rpb24gd3JhcChhcnIpIHtcblx0ICAgIHJldHVybiBjYWxsYmFjay5hcHBseShudWxsLCBhcnIpO1xuXHQgIH07XG5cdH07XG5cblxuLyoqKi8gfSlcbi8qKioqKiovIF0pXG59KTtcbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF4aW9zLm1hcCIsImltcG9ydCBheGlvcyBmcm9tICdheGlvcy9kaXN0L2F4aW9zJztcbmltcG9ydCBtb21lbnQgZnJvbSAnbW9tZW50JztcbmltcG9ydCB7IGJpbmQgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgZWFjaCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBleHRlbmQgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgaXNPYmplY3QgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgY2FtZWxDYXNlIH0gZnJvbSAnbG9kYXNoJztcblxuY29uc3QgUFJPWFlfQ09ORklHX1BST1BFUlRJRVMgPSBbJ2hlYWRlcnMnLCAncGFyYW1zJywgJ2RhdGEnXTtcblxuY29uc3QgUFJPWFlfQ09ORklHX01FVEhPRFMgPSB7XG4gICAgZ2V0KHByb3AsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0W3Byb3BdO1xuICAgICAgICB9O1xuICAgIH0sXG4gICAgc2V0KHByb3AsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgY29udGV4dFtwcm9wXSA9IHZhbHVlO1xuICAgICAgICB9O1xuICAgIH0sXG4gICAgYWRkKHByb3AsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBjb250ZXh0W3Byb3BdW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHJlbW92ZShwcm9wLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiAoa2V5KSA9PiB7XG4gICAgICAgICAgICBkZWxldGUgY29udGV4dFtwcm9wXVtrZXldO1xuICAgICAgICB9O1xuICAgIH0sXG4gICAgbWVyZ2UocHJvcCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gKGtleSwgdmFsdWVzKSA9PiB7XG4gICAgICAgICAgICBleHRlbmQoY29udGV4dFtwcm9wXSwga2V5KTtcbiAgICAgICAgfTtcbiAgICB9XG59O1xuXG5jb25zdCBtZXRob2QgPSBmdW5jdGlvbihhY3Rpb24sIHByb3ApIHtcbiAgICByZXR1cm4gY2FtZWxDYXNlKFthY3Rpb24sIHByb3BdLmpvaW4oJyAnKSk7XG59O1xuXG5jb25zdCBjaGFpbmFibGUgPSBmdW5jdGlvbihwcm9wKSB7XG4gICAgcmV0dXJuIChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgIGlmKGtleSBpbnN0YW5jZW9mIEZvcm1EYXRhKSB7XG4gICAgICAgICAgICB0aGlzW21ldGhvZCgnc2V0JywgcHJvcCldKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihpc09iamVjdChrZXkpKSB7XG4gICAgICAgICAgICB0aGlzW21ldGhvZCgnbWVyZ2UnLCBwcm9wKV0oa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXNbbWV0aG9kKCdhZGQnLCBwcm9wKV0oa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVxdWVzdCB7XG5cbiAgICBjb25zdHJ1Y3Rvcih1cmwsIGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHRoaXMuJGNvbmZpZyA9IGV4dGVuZCh7XG4gICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgICAgICAgcGFyYW1zOiB7fSxcbiAgICAgICAgICAgIGRhdGE6IHt9XG4gICAgICAgIH0sIGNvbmZpZyk7XG5cbiAgICAgICAgZWFjaChQUk9YWV9DT05GSUdfTUVUSE9EUywgKGNhbGxiYWNrLCBrZXkpID0+IHtcbiAgICAgICAgICAgIHRoaXNbbWV0aG9kKGtleSwgJ2NvbmZpZycpXSA9IGJpbmQoY2FsbGJhY2spKCckY29uZmlnJywgdGhpcyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXNbJ2NvbmZpZyddID0gYmluZChjaGFpbmFibGUsIHRoaXMpKCdjb25maWcnKTtcblxuICAgICAgICBlYWNoKFBST1hZX0NPTkZJR19QUk9QRVJUSUVTLCAocHJvcCkgPT4ge1xuICAgICAgICAgICAgZWFjaChQUk9YWV9DT05GSUdfTUVUSE9EUywgKGNhbGxiYWNrLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzW21ldGhvZChrZXksIHByb3ApXSA9IGJpbmQoY2FsbGJhY2spKHByb3AsIHRoaXMuJGNvbmZpZyk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpc1twcm9wXSA9IGJpbmQoY2hhaW5hYmxlLCB0aGlzKShwcm9wKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH1cblxuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLiRlcnJvciA9IG51bGw7XG4gICAgICAgIHRoaXMuJHN0YXR1cyA9IG51bGw7XG4gICAgICAgIHRoaXMuJHN0YXR1c1RleHQgPSBudWxsO1xuICAgICAgICB0aGlzLiRyZXNwb25zZSA9IG51bGw7XG4gICAgICAgIHRoaXMuJHJlcXVlc3RTZW50QXQgPSBudWxsO1xuICAgICAgICB0aGlzLiRyZXNwb25zZVJlY2VpdmVkQXQgPSBudWxsO1xuICAgIH1cblxuICAgIGhhc1NlbnQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuJHJlcXVlc3RTZW50QXQ7XG4gICAgfVxuXG4gICAgaGFzUmVzcG9uc2UoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuJHJlc3BvbnNlUmVjZWl2ZWRBdDtcbiAgICB9XG5cbiAgICBwYXNzZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc1Jlc3BvbnNlKCkgJiYgIXRoaXMuJGVycm9yO1xuICAgIH1cblxuICAgIGZhaWxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzUmVzcG9uc2UoKSAmJiAhIXRoaXMuJGVycm9yO1xuICAgIH1cblxuICAgIGdldFVybCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHVybDtcbiAgICB9XG5cbiAgICBzZXRVcmwodXJsKSB7XG4gICAgICAgIHRoaXMuJHVybCA9IHVybDtcbiAgICB9XG5cbiAgICBnZXQocGFyYW1zID0ge30sIGhlYWRlcnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJhbXMocGFyYW1zKS5oZWFkZXJzKGhlYWRlcnMpLnJlcXVlc3QoJ2dldCcpO1xuICAgIH1cblxuICAgIHBvc3QoZGF0YSA9IHt9LCBoZWFkZXJzID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YShkYXRhKS5oZWFkZXJzKGhlYWRlcnMpLnJlcXVlc3QoJ3Bvc3QnKTtcbiAgICB9XG5cbiAgICBwdXQoZGF0YSA9IHt9LCBoZWFkZXJzID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YShkYXRhKS5oZWFkZXJzKGhlYWRlcnMpLnJlcXVlc3QoJ3B1dCcpO1xuICAgIH1cblxuICAgIGRlbGV0ZShoZWFkZXJzID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVhZGVycyhoZWFkZXJzKS5yZXF1ZXN0KCdkZWxldGUnKTtcbiAgICB9XG5cbiAgICByZXF1ZXN0KG1ldGhvZCkge1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIHRoaXMuJHJlcXVlc3RTZW50QXQgPSBtb21lbnQoKTtcbiAgICAgICAgdGhpcy5hZGRDb25maWcoJ21ldGhvZCcsIG1ldGhvZCk7XG5cbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGF4aW9zLnJlcXVlc3QodGhpcy4kY29uZmlnKS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLiRyZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIHRoaXMuJHJlc3BvbnNlUmVjZWl2ZWRBdCA9IG1vbWVudCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuJHN0YXR1cyA9IHJlc3BvbnNlLnN0YXR1cztcbiAgICAgICAgICAgICAgICB0aGlzLiRzdGF0dXNUZXh0ID0gcmVzcG9uc2Uuc3RhdHVzVGV4dDtcblxuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzcG9uc2UuZGF0YSk7XG4gICAgICAgICAgICB9LCBlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy4kZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICB0aGlzLiRyZXNwb25zZSA9IGVycm9yLnJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIHRoaXMuJHJlc3BvbnNlUmVjZWl2ZWRBdCA9IG1vbWVudCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuJHN0YXR1cyA9IGVycm9yLnJlc3BvbnNlLnN0YXR1cztcbiAgICAgICAgICAgICAgICB0aGlzLiRzdGF0dXNUZXh0ID0gZXJyb3IucmVzcG9uc2Uuc3RhdHVzVGV4dDtcblxuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvci5yZXNwb25zZS5kYXRhLmVycm9ycyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuXG59XG4iLCJpbXBvcnQgeyBtYXAgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgZWFjaCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBrZXlzIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IHNpemUgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgZXh0ZW5kIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IGZpbHRlciB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBpc051bGwgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgcGlja0J5IH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IHJlZHVjZSB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBpc0FycmF5IH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IGlzT2JqZWN0IH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IGlzVW5kZWZpbmVkIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBSZXF1ZXN0IGZyb20gJy4uL1JlcXVlc3QnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNb2RlbCB7XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIHRoZSBtb2RlbCBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGEgb2JqZWN0XG4gICAgICogQHJldHVybiB2b2lkXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZGF0YSA9IHt9LCBwYXJhbXMgPSB7fSkge1xuICAgICAgICB0aGlzLiRjaGFuZ2VkID0ge307XG4gICAgICAgIHRoaXMuJGV4aXN0cyA9IGZhbHNlO1xuICAgICAgICB0aGlzLiRhdHRyaWJ1dGVzID0ge307XG4gICAgICAgIHRoaXMuJGtleSA9IHRoaXMua2V5KCk7XG4gICAgICAgIHRoaXMuJGZpbGVzID0gdGhpcy5maWxlcygpO1xuICAgICAgICB0aGlzLiR0YWJsZSA9IHRoaXMudGFibGUoKTtcbiAgICAgICAgdGhpcy4kcHJvcGVydGllcyA9IHRoaXMucHJvcGVydGllcygpO1xuICAgICAgICB0aGlzLmluaXRpYWxpemUoZGF0YSk7XG5cbiAgICAgICAgZWFjaChwYXJhbXMsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICB0aGlzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYoIXRoaXMuJHRhYmxlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgdGFibGUgbXVzdCBiZSBkZWZpbmVkIGZvciBldmVyeSBtb2RlbC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuJGluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIHRoZSBtb2RlbCB3aXRoIHRoZSBnaXZlbiBkYXRhIHdpdGhvdXQgY29uc2lkZXJpbmcgdGhlIGRhdGFcbiAgICAgKiBhcyBcImNoYW5nZWRcIi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRhIG9iamVjdFxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIGluaXRpYWxpemUoZGF0YSkge1xuICAgICAgICB0aGlzLiRpbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmZpbGwoZGF0YSk7XG4gICAgICAgIHRoaXMuJGluaXRpYWxpemVkID0gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWZpbmUgdGhlIGNvcnJlc3BvbmRpbmcgZGF0YWJhc2UgdGFibGUgKGFrYSBBUEkgZW5kcG9pbnQgc2x1ZykuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHN0cmluZ1xuICAgICAqL1xuICAgIHRhYmxlKCkge1xuICAgICAgICAvL1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlZmluZSBhIHByaW1hcnkga2V5LiBUaGlzIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIHRoZSBtb2RlbCBleGlzdHMgYW5kXG4gICAgICogd2hpY2ggZW5kcG9pbnQgdG8gdXNlLlxuICAgICAqXG4gICAgICogQHJldHVybiBzdHJpbmdcbiAgICAgKi9cbiAgICBrZXkoKSB7XG4gICAgICAgIHJldHVybiAnaWQnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhbiBhcnJheSBvZiBwcm9wZXJ0aWVzIHRoYXQgYXJlIHNlbnQgdG8gdGhlIEFQSS4gSWYgbm8gcHJvcGVydGllc1xuICAgICAqIGFyZSBkZWZpbmVkLCB0aGVuIGFsbCB0aGUgYXR0cmlidXRlcyB3aWxsIGJlIGluY2x1ZGVkIGluIHRoZSByZXF1ZXN0LlxuICAgICAqXG4gICAgICogQHJldHVybiBhcnJheVxuICAgICAqL1xuICAgIHByb3BlcnRpZXMoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGF0dHJpYnV0ZXMgaW4gdGhlIG1vZGVsIHdpdGggdGhlIGRhdGEgZ2l2ZW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGF0YSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICBmaWxsKGRhdGEpIHtcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGVzKGRhdGEpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBvbmUgb3IgbW9yZSBhdHRyaWJ1dGVzIGZyb20gdGhlIG1vZGVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGEgc3RyaW5nfGFycmF5XG4gICAgICogQHJldHVybiBhcnJheXxtaXhlZFxuICAgICAqL1xuICAgIGdldChrZXkpIHtcbiAgICAgICAgaWYoaXNBcnJheShrZXkpIHx8IGlzT2JqZWN0KGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZXMoKS5maWx0ZXIoKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEuaW5kZXhPZih2YWx1ZSkgIT09IC0xO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoa2V5KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFsaWFzIGZvciBzZXRBdHRyaWJ1dGVzKCkgZXhjZXB0IHRoaXMgbWV0aG9kIHJldHVybnMgYHRoaXNgLiBUaGlzIG1ldGhvZFxuICAgICAqIGFsc28gYWNjZXB0cyBhbiBhcnJheSBvZiB2YWx1ZXMgb3Iga2V5L3ZhbHVlIHBhaXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICBzZXQoa2V5LCB2YWx1ZSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZihpc0FycmF5KGtleSkgfHwgaXNPYmplY3Qoa2V5KSkge1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGVzKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgdGhlIGRlZmluZWQgYXR0cmlidXRlcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gYXJyYXlcbiAgICAgKi9cbiAgICBnZXRBdHRyaWJ1dGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kYXR0cmlidXRlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNoYW5nZWQgYXR0cmlidXRlc1xuICAgICAqXG4gICAgICogQHJldHVybiBhcnJheVxuICAgICAqL1xuICAgIGdldENoYW5nZWRBdHRyaWJ1dGVzKCkge1xuICAgICAgICByZXR1cm4ga2V5cyh0aGlzLiRjaGFuZ2VkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNoYW5nZWQgYXR0cmlidXRlc1xuICAgICAqXG4gICAgICogQHJldHVybiBhcnJheVxuICAgICAqL1xuICAgIGdldE9yaWdpbmFsVmFsdWUoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRjaGFuZ2VkW2tleV0gfHwgdGhpcy4kYXR0cmlidXRlc1trZXldO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdW5jaGFuZ2VkIGF0dHJpYnV0ZXNcbiAgICAgKlxuICAgICAqIEByZXR1cm4gYXJyYXlcbiAgICAgKi9cbiAgICBnZXRVbmNoYW5nZWRBdHRyaWJ1dGVzKCkge1xuICAgICAgICByZXR1cm4gZmlsdGVyKGtleXModGhpcy4kYXR0cmlidXRlcyksIGtleSA9PiAhKGtleSBpbiB0aGlzLiRjaGFuZ2VkKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGFuIGF0dHJpYnV0ZSB3aXRoIGEgZ2l2ZW4ga2V5LiBJZiBubyBrZXkgaXMgZGVmaW5lZFxuICAgICAqXG4gICAgICogQHBhcmFtIGtleSBzdHJpbmdcbiAgICAgKiBAcGFyYW0gZGVmYXVsdCB1bmRlZmluZWR8bWl4ZWRcbiAgICAgKiBAcmV0dXJuIGFycmF5XG4gICAgICovXG4gICAgZ2V0QXR0cmlidXRlKGtleSwgdmFsdWUgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGF0dHJpYnV0ZXNba2V5XSB8fCB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgYW4gYXJyYXkgb3Igb2JqZWN0IG9mIGRhdGEgYXMgYXR0cmlidXRlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhdHRyaWJ1dGVzIGFycmF5fG9iamVjdFxuICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAqL1xuICAgIHNldEF0dHJpYnV0ZXMoZGF0YSkge1xuICAgICAgICBpZighaXNBcnJheShkYXRhKSAmJiAhaXNPYmplY3QoZGF0YSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXR0cmlidXRlcyBtdXN0IGJlIHNldCB3aXRoIGFuIGFycmF5IG9yIG9iamVjdC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVhY2goZGF0YSwgKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgYW4gYXR0cmlidXRlIHdpdGggYSBnaXZlbiBrZXkvdmFsdWUgcGFpci4gVGhpcyB3aWxsIHRyYWNrIHRoZSBjaGFuZ2VzXG4gICAgICogaW4gdGhlIG1vZGVsIHdpdGhpbiB0aGUgYHRoaXMuJGNoYW5nZWRgIHByb3BlcnR5LiBJZiB0aGUgcHJpbWFyeSBrZXlcbiAgICAgKiBpcyBzZXQsIGl0IHdpbGwgYWxzbyBjaGFuZ2UgdGhlIGB0aGlzLiRleGlzdHNgIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGtleSBzdHJpbmdcbiAgICAgKiBAcGFyYW0gdmFsdWUgbWl4ZWRcbiAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgKi9cbiAgICBzZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZih0aGlzLmdldEF0dHJpYnV0ZShrZXkpICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVBdHRyaWJ1dGVDaGFuZ2Uoa2V5LCB2YWx1ZSk7XG5cbiAgICAgICAgICAgIGlmKGlzVW5kZWZpbmVkKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLiRhdHRyaWJ1dGVzW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRhdHRyaWJ1dGVzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldmVydCB0aGUgbW9kZWwgdG8gaXRzIG9yaWdpbmFsIHN0YXRlLlxuICAgICAqXG4gICAgICogQHJldHVybiBib29sXG4gICAgICovXG4gICAgcmV2ZXJ0KCkge1xuICAgICAgICBlYWNoKHRoaXMuJGNoYW5nZWQsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICBpZighaXNVbmRlZmluZWQodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kYXR0cmlidXRlc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy4kYXR0cmlidXRlc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLiRjaGFuZ2VkID0ge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpZiB0aGUgbW9kZWwgaGFzIGEgcHJpbWFyeSBrZXkgc2V0LlxuICAgICAqXG4gICAgICogQHJldHVybiBib29sXG4gICAgICovXG4gICAgZXhpc3RzKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLiRleGlzdHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbW9kZWwgYmVlbiBjaGFuZ2VkIG9yIG5vdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gYm9vbFxuICAgICAqL1xuICAgIGhhc0NoYW5nZWQoa2V5KSB7XG4gICAgICAgIHJldHVybiAha2V5ID8gc2l6ZSh0aGlzLiRjaGFuZ2VkKSA+IDAgOiAhaXNVbmRlZmluZWQodGhpcy4kY2hhbmdlZFtrZXldKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEb2VzIHRoZSBtb2RlbCBoYXZlIGFueSBGaWxlIG9iamVjdHMuIElmIHNvLCBuZWVkIHRvIHNlbmQgYXMgbXVsdGlwYXJ0LlxuICAgICAqXG4gICAgICogQHJldHVybiBib29sXG4gICAgICovXG4gICAgaGFzRmlsZXMoKSB7XG4gICAgICAgIGZ1bmN0aW9uIGNvdW50KGZpbGVzLCB0b3RhbCA9IDApIHtcbiAgICAgICAgICAgIHJldHVybiByZWR1Y2UoZmlsZXMsIChjYXJyeSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICBpZihpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FycnkgKyBjb3VudCh2YWx1ZSwgdG90YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmKHZhbHVlIGluc3RhbmNlb2YgRmlsZSB8fCB2YWx1ZSBpbnN0YW5jZW9mIEZpbGVMaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYXJyeSArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2Fycnk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdG90YWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvdW50KHRoaXMudG9KU09OKCkpICE9PSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBzZXR0aW5ncyB0aGUgJGNoYW5nZWQgYXR0cmlidXRlcyB3aGVuIGFuIGF0dHJpYnV0ZSB2YWx1ZSBpcyBzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ga2V5IHN0cmluZ1xuICAgICAqIEBwYXJhbSB2YWx1ZSBtaXhlZFxuICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAqL1xuICAgIGhhbmRsZUF0dHJpYnV0ZUNoYW5nZShrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmKHRoaXMuJGluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICBpZih0aGlzLiRjaGFuZ2VkW2tleV0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuJGNoYW5nZWRba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYoIShrZXkgaW4gdGhpcy4kY2hhbmdlZCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRjaGFuZ2VkW2tleV0gPSB0aGlzLmdldEF0dHJpYnV0ZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5oYW5kbGVQcmltYXJ5S2V5Q2hhbmdlKGtleSwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCBhbiBhcnJheSBvciBvYmplY3Qgb2YgZGF0YSBhcyBhdHRyaWJ1dGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGtleSBzdHJpbmdcbiAgICAgKiBAcGFyYW0gdmFsdWUgbWl4ZWRcbiAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgKi9cbiAgICBoYW5kbGVQcmltYXJ5S2V5Q2hhbmdlKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYodGhpcy4ka2V5ID09PSBrZXkpIHtcbiAgICAgICAgICAgIHRoaXMuJGV4aXN0cyA9ICFpc1VuZGVmaW5lZCh2YWx1ZSkgJiYgIWlzTnVsbCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTYXZlIHRoZSBtb2RlbCB0byB0aGUgZGF0YWJhc2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRhIG9iamVjdFxuICAgICAqIEByZXR1cm4gYm9vbFxuICAgICAqL1xuICAgIHNhdmUoZGF0YSA9IHt9LCBjb25maWcgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5leGlzdHMoKSA/IHRoaXMuY3JlYXRlKGRhdGEsIGNvbmZpZykgOiB0aGlzLnVwZGF0ZShkYXRhLCBjb25maWcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBtb2RlbFxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGEgb2JqZWN0XG4gICAgICogQHJldHVybiBib29sXG4gICAgICovXG4gICAgY3JlYXRlKGRhdGEgPSB7fSwgY29uZmlnID0ge30pIHtcbiAgICAgICAgaWYodGhpcy5leGlzdHMoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKGRhdGEsIGNvbmZpZyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmZpbGwoZGF0YSk7XG5cbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMucmVxdWVzdChgL2FwaS8ke3RoaXMudGFibGUoKX1gLCBleHRlbmQoe1xuICAgICAgICAgICAgZGF0YTogIXRoaXMuaGFzRmlsZXMoKSA/IHRoaXMudG9Kc29uKCkgOiB0aGlzLnRvRm9ybURhdGEoKVxuICAgICAgICB9LCBjb25maWcpKVxuXG4gICAgICAgIHJldHVybiByZXF1ZXN0LnBvc3QoKS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbGwocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgYW4gZXhpc3RpbmcgbW9kZWxcbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRhIG9iamVjdFxuICAgICAqIEByZXR1cm4gYm9vbFxuICAgICAqL1xuICAgIHVwZGF0ZShkYXRhID0ge30sIGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIGlmKCF0aGlzLmV4aXN0cygpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGUoZGF0YSwgY29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdGhpcy5maWxsKGRhdGEpO1xuXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLnJlcXVlc3QoYC9hcGkvJHt0aGlzLnRhYmxlKCl9LyR7dGhpcy5nZXQodGhpcy5rZXkoKSl9YCwgZXh0ZW5kKHtcbiAgICAgICAgICAgIGRhdGE6ICF0aGlzLmhhc0ZpbGVzKCkgPyB0aGlzLnRvSnNvbigpIDogdGhpcy50b0Zvcm1EYXRhKClcbiAgICAgICAgfSwgY29uZmlnKSk7XG5cbiAgICAgICAgcmV0dXJuIHJlcXVlc3RbdGhpcy5oYXNGaWxlcygpID8gJ3Bvc3QnIDogJ3B1dCddKCkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maWxsKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVsZXRlIGFuIGV4aXN0aW5nIG1vZGVsXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGF0YSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIGJvb2xcbiAgICAgKi9cbiAgICBkZWxldGUoZGF0YSA9IHt9LCBjb25maWcgPSB7fSkge1xuICAgICAgICBpZighdGhpcy5leGlzdHMoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgbW9kZWwgbXVzdCBoYXZlIGEgcHJpbWFyeSBrZXkgYmVmb3JlIGl0IGNhbiBiZSBkZWxldGUuJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmZpbGwoZGF0YSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChgL2FwaS8ke3RoaXMudGFibGUoKX0vJHt0aGlzLmdldCh0aGlzLmtleSgpKX1gLCBjb25maWcpLmRlbGV0ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmQgYW4gZXhpc3RpbmcgbW9kZWwgYnkgaWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRhIG9iamVjdFxuICAgICAqIEByZXR1cm4gYm9vbFxuICAgICAqL1xuICAgIHNlYXJjaChwYXJhbXMgPSB7fSwgY29uZmlnID0ge30pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdChgL2FwaS8ke3RoaXMudGFibGUoKX1gLCBleHRlbmQoe1xuICAgICAgICAgICAgICAgIHBhcmFtczogcGFyYW1zXG4gICAgICAgICAgICB9LCBjb25maWcpKS5nZXQoKS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKG1hcChyZXNwb25zZS5kYXRhLCBkYXRhID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyAodGhpcy5jb25zdHJ1Y3RvcikoZGF0YSk7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSwgZXJyb3JzID0+IHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3JzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kIGFuIGV4aXN0aW5nIG1vZGVsIGJ5IGlkXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGF0YSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIGJvb2xcbiAgICAgKi9cbiAgICBmaW5kKGlkLCBjb25maWcgPSB7fSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0KGAvYXBpLyR7dGhpcy50YWJsZSgpfS8ke2lkfWAsIGNvbmZpZykuZ2V0KCkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLmluaXRpYWxpemUocmVzcG9uc2UpKTtcbiAgICAgICAgICAgIH0sIGVycm9ycyA9PiB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9ycyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgcmVxdWVzdCBmcm9tIHRoZSBtb2RlbCBkYXRhXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGF0YSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIGJvb2xcbiAgICAgKi9cbiAgICByZXF1ZXN0KHVybCwgY29uZmlnID0ge30pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXF1ZXN0KHVybCwgY29uZmlnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRoZSBNb2RlbCBpbnN0YW5jZSB0byBhIEZvcm1EYXRhIGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIG9iamVjdFxuICAgICAqL1xuICAgIHRvRm9ybURhdGEoKSB7XG4gICAgICAgIGNvbnN0IGZvcm0gPSBuZXcgRm9ybURhdGEoKTtcblxuICAgICAgICBlYWNoKHRoaXMudG9KU09OKCksICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICBpZihpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGVhY2godmFsdWUsIGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgICAgICBmb3JtLmFwcGVuZChrZXkucmVwbGFjZSgvKC4rKShcXFsuK1xcXT8pJC8sICckMScpKydbXScsIGl0ZW0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9ybS5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBmb3JtO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgdGhlIGluc3RhbmNlIHRvIEpTT04gcGF5bG9hZFxuICAgICAqXG4gICAgICogQHJldHVybiBvYmplY3RcbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiBwaWNrQnkodGhpcy4kYXR0cmlidXRlcywgKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy4kcHJvcGVydGllcy5sZW5ndGggfHwgKFxuICAgICAgICAgICAgICAgIGtleSA9PT0gdGhpcy5rZXkoKSB8fCB0aGlzLiRwcm9wZXJ0aWVzLmluZGV4T2Yoa2V5KSAhPT0gLTFcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFsaWFzIGZvciB0b0pTT05cbiAgICAgKlxuICAgICAqIEByZXR1cm4gb2JqZWN0XG4gICAgICovXG4gICAgdG9Kc29uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0pTT04oKTtcbiAgICB9XG5cbn1cbiIsIjx0ZW1wbGF0ZT5cbiAgICA8Zm9ybSBAc3VibWl0LnByZXZlbnQ9XCJvblN1Ym1pdFwiIDpjbGFzcz1cInsnZm9ybS1pbmxpbmUnOiBpbmxpbmV9XCIgOm5vdmFsaWRhdGU9XCJub3ZhbGlkYXRlXCI+XG4gICAgICAgIDxzbG90Pjwvc2xvdD5cbiAgICA8L2Zvcm0+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuXG5pbXBvcnQgeyBpc0Z1bmN0aW9uIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBNb2RlbCBmcm9tICdAL0h0dHAvTW9kZWwvTW9kZWwnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBvYmplY3Qgb2YgZm9ybSBkYXRhXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBPYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc3BsYXkgdGhlIGZvcm0gZmllbGRzIGlubGluZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgT2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBtb2RlbDoge1xuICAgICAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBNb2RlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzcGxheSB0aGUgZm9ybSBmaWVsZHMgaW5saW5lXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBCb29sZWFuXG4gICAgICAgICAqL1xuICAgICAgICBpbmxpbmU6IHtcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGNhbGxiYWNrIGZ1bmN0aW9uIGZvciB0aGUgYHN1Ym1pdGAgZXZlbnRcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IEJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIG5vdmFsaWRhdGU6IHtcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgICBkZWZhdWx0OiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgVVJJIG9yIFVSTCB1c2VkIHRvIHJlZGlyZWN0IHVzZXIgYWZ0ZXIgZm9ybSBzdWJtaXRzIHN1Y2Nlc3NmdWxseS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IEZ1bmN0aW9ufFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgcmVkaXJlY3Q6IFtTdHJpbmcsIEZ1bmN0aW9uXSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBjYWxsYmFjayBmdW5jdGlvbiBmb3IgdGhlIGBzdWJtaXRgIGV2ZW50XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBGdW5jdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgb25TdWJtaXQ6IHtcbiAgICAgICAgICAgIHR5cGU6IEZ1bmN0aW9uLFxuICAgICAgICAgICAgZGVmYXVsdChldmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ3N1Ym1pdCcsIGV2ZW50KTtcblxuICAgICAgICAgICAgICAgIGlmKHRoaXMubW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2RhdGEnLCB0aGlzLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5zYXZlKHRoaXMuZGF0YSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25VcGxvYWRQcm9ncmVzczogZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ3N1Ym1pdDpwcm9ncmVzcycsIGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSkudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vblN1Ym1pdFN1Y2Nlc3MoZXZlbnQsIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9LCAoZXJyb3JzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uU3VibWl0RmFpbGVkKGV2ZW50LCBlcnJvcnMpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIHRoZSBgc3VibWl0OnN1Y2Nlc3NgIGV2ZW50XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBGdW5jdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgb25TdWJtaXRTdWNjZXNzOiB7XG4gICAgICAgICAgICB0eXBlOiBGdW5jdGlvbixcbiAgICAgICAgICAgIGRlZmF1bHQoZXZlbnQsIGRhdGEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdzdWJtaXQ6c3VjY2VzcycsIGV2ZW50LCBkYXRhKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdzdWJtaXQ6Y29tcGxldGUnLCBldmVudCwgdHJ1ZSwgZGF0YSk7XG5cbiAgICAgICAgICAgICAgICBpZih0aGlzLnJlZGlyZWN0ICYmIGlzRnVuY3Rpb24odGhpcy5yZWRpcmVjdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWRpcmVjdCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZih0aGlzLnJlZGlyZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbiA9IHRoaXMucmVkaXJlY3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGNhbGxiYWNrIGZ1bmN0aW9uIGZvciB0aGUgYHN1Ym1pdDpzdWNjZXNzYCBldmVudFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgRnVuY3Rpb25cbiAgICAgICAgICovXG4gICAgICAgIG9uU3VibWl0RmFpbGVkOiB7XG4gICAgICAgICAgICB0eXBlOiBGdW5jdGlvbixcbiAgICAgICAgICAgIGRlZmF1bHQoZXZlbnQsIGVycm9ycykge1xuICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ3N1Ym1pdDpmYWlsZWQnLCBldmVudCwgZXJyb3JzKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdzdWJtaXQ6Y29tcGxldGUnLCBldmVudCwgZmFsc2UsIGVycm9ycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZXJyb3JzOiB7fVxuICAgICAgICB9XG4gICAgfVxuXG59XG5cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IEJhc2VGb3JtIGZyb20gJy4vQmFzZUZvcm0nO1xuaW1wb3J0IFZ1ZUluc3RhbGxlciBmcm9tICdAL0hlbHBlcnMvVnVlSW5zdGFsbGVyL1Z1ZUluc3RhbGxlcic7XG5cbmNvbnN0IHBsdWdpbiA9IFZ1ZUluc3RhbGxlci51c2Uoe1xuXG4gICAgaW5zdGFsbChWdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgVnVlSW5zdGFsbGVyLmNvbXBvbmVudHMoe1xuICAgICAgICAgICAgQmFzZUZvcm1cbiAgICAgICAgfSk7XG4gICAgfVxuXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgQmFzZUZvcm07XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1dWlkKCkge1xuICAgIHJldHVybiAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIGMgPT4ge1xuICAgICAgICB2YXIgciA9IE1hdGgucmFuZG9tKCkgKiAxNiB8IDAsIHYgPSBjID09ICd4JyA/IHIgOiAociAmIDB4MyB8IDB4OCk7XG4gICAgICAgIHJldHVybiB2LnRvU3RyaW5nKDE2KTtcbiAgICB9KTtcbn1cbiIsImltcG9ydCB7IGlzRnVuY3Rpb24gfSBmcm9tICdsb2Rhc2gnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBtZXRob2RzOiB7XG4gICAgICAgIHByb3h5KGNhbGxiYWNrLCBldmVudCkge1xuICAgICAgICAgICAgaWYoaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykuc3BsaWNlKDEpKTtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG59XG4iLCI8dGVtcGxhdGU+XG4gICAgPGFcbiAgICAgICAgOmhyZWY9XCJocmVmIHx8ICcjJ1wiXG4gICAgICAgIGNsYXNzPVwiZHJvcGRvd24taXRlbVwiXG4gICAgICAgIDpjbGFzcz1cInsnYWN0aXZlJzogYWN0aXZlfVwiXG4gICAgICAgIEBjbGljaz1cInByb3h5KG9uQ2xpY2ssICRldmVudCk7b25DbGlja2VkKCRldmVudCk7XCI+XG4gICAgICAgIDxpIHYtaWY9XCJpY29uXCIgOmNsYXNzPVwiaWNvblwiLz5cbiAgICAgICAgPHNsb3Q+e3tsYWJlbH19PC9zbG90PlxuICAgIDwvYT5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5cbmltcG9ydCBQcm94eSBmcm9tICdAL01peGlucy9Qcm94eS9Qcm94eSc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG1peGluczogW1Byb3h5XSxcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElzIHRoZSBtZW51IGl0ZW0gYWN0aXZlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgT2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBhY3RpdmU6IEJvb2xlYW4sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBgaHJlZmAgYXR0cmlidXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgT2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBocmVmOiBTdHJpbmcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsYWJlbCBvZiB0aGUgZHJvcGRvd24gbWVudSBpdGVtLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgT2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBsYWJlbDogU3RyaW5nLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaWNvbiBvZiB0aGUgZHJvcGRvd24gbWVudSBpdGVtLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgT2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBpY29uOiBTdHJpbmcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIHRoZSBgY2xpY2tgIGV2ZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgT2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBvbkNsaWNrOiBGdW5jdGlvblxuXG4gICAgfSxcblxuICAgIG1ldGhvZHM6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBjYWxsYmFjayBmdW5jdGlvbiBmb3IgdGhlIGBjbGlja2AgZXZlbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBPYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIG9uQ2xpY2tlZChldmVudCkge1xuICAgICAgICAgICAgaWYoIXRoaXMuaHJlZikge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2NsaWNrJywgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG59XG5cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICAgIDxoNSBjbGFzcz1cImRyb3Bkb3duLWhlYWRlclwiPlxuICAgICAgICB7e2hlYWRlcn19XG5cbiAgICAgICAgPHNsb3Q+PC9zbG90PlxuICAgIDwvaDU+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAnZHJvcGRvd24tbWVudS1oZWFkZXInLFxuXG4gICAgcHJvcHM6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHZhbHVlIG9mIHRoZSBoZWFkZXJcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IE9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgaGVhZGVyOiBTdHJpbmdcblxuICAgIH1cblxufVxuXG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgICA8ZGl2IGNsYXNzPVwiZHJvcGRvd24tZGl2aWRlclwiPjwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ2Ryb3Bkb3duLW1lbnUtZGl2aWRlcidcblxufVxuXG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgICA8ZGl2IGNsYXNzPVwiZHJvcGRvd24tbWVudVwiIDpjbGFzcz1cInsnZHJvcGRvd24tbWVudS1yaWdodCc6IGFsaWduID09PSAncmlnaHQnLCAnc2hvdyc6IHNob3d9XCIgOmFyaWEtbGFiZWxsZWRieT1cImlkXCI+XG4gICAgICAgIDxzbG90PlxuICAgICAgICAgICAgPHRlbXBsYXRlIHYtZm9yPVwiaXRlbSBpbiBpdGVtc1wiPlxuICAgICAgICAgICAgICAgIDxjb21wb25lbnQgOmlzPVwicHJlZml4KGl0ZW0udHlwZSB8fCAnaXRlbScsICdkcm9wZG93bi1tZW51JylcIiB2LWJpbmQ9XCJpdGVtXCIgQGNsaWNrPVwib25DbGljaygkZXZlbnQsIGl0ZW0pXCIgLz5cbiAgICAgICAgICAgIDwvdGVtcGxhdGU+XG4gICAgICAgIDwvc2xvdD5cbiAgICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5cbmltcG9ydCB1dWlkIGZyb20gJ0AvSGVscGVycy9VdWlkL1V1aWQnO1xuaW1wb3J0IHByZWZpeCBmcm9tICdAL0hlbHBlcnMvUHJlZml4L1ByZWZpeCc7XG5pbXBvcnQgRHJvcGRvd25NZW51SXRlbSBmcm9tICcuL0Ryb3Bkb3duTWVudUl0ZW0nO1xuaW1wb3J0IERyb3Bkb3duTWVudUhlYWRlciBmcm9tICcuL0Ryb3Bkb3duTWVudUhlYWRlcic7XG5pbXBvcnQgRHJvcGRvd25NZW51RGl2aWRlciBmcm9tICcuL0Ryb3Bkb3duTWVudURpdmlkZXInO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBjb21wb25lbnRzOiB7XG4gICAgICAgIERyb3Bkb3duTWVudUl0ZW0sXG4gICAgICAgIERyb3Bkb3duTWVudUhlYWRlcixcbiAgICAgICAgRHJvcGRvd25NZW51RGl2aWRlclxuICAgIH0sXG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYGlkYCBhdHRyaWJ1dGUgb24gdGhlIHRvZ2dsZSBidXR0b24gYW5kIGFyaWEgbGFiZWwuIElmIG5vIGBpZGAgaXNcbiAgICAgICAgICogZGVmaW5lZCwgdGhlbiBhIFVVSUQgd2lsbCBiZSBnZW5lcmF0ZWQgaW5zdGVhZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IE9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgaWQ6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6IHV1aWRcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzcGxheSB0aGUgZHJvcGRvd24gbWVudSBhbGlnbmVkIGxlZnQgb3IgcmlnaHRcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgYWxpZ246IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdsZWZ0JyxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsnbGVmdCcsICdyaWdodCddLmluZGV4T2YodmFsdWUudG9Mb3dlckNhc2UoKSkgIT09IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGVmYXVsdCB2aXNpYmlsaXR5IG9mIHRoZSBkcm9wZG93biBtZW51LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgT2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBzaG93OiBCb29sZWFuLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBhcnJheSBvZiBkcm9wZG93biBpdGVtcy4gSWYgYW4ga2V5L3ZhbHVlIHBhaXIgaXNuJ3QgZGVmaW5lZCwgdGhlXG4gICAgICAgICAqIGRlZmF1bHQgdmFsdWUgd2lsbCBiZSB1c2VkLiBJZiBubyBpdGVtcyBhcmUgZGVmaW5lZCwgdGhlbiB0aGUgc2xvdFxuICAgICAgICAgKiBuYW1lZCBcIml0ZW1zXCIgY2FuIGJlIHVzZWQgdG8gZGVmaW5lIHRoZSBvcHRpb25zIHdpdGggSFRNTC5cbiAgICAgICAgICpcbiAgICAgICAgICogW3tcbiAgICAgICAgICogICAgICB0eXBlOiAnaXRlbScsIC8vIFN0cmluZyBbaXRlbXxoZWFkZXJ8ZGl2aWRlcl1cbiAgICAgICAgICogICAgICBocmVmOiAnIycsIC8vIFN0cmluZ1xuICAgICAgICAgKiAgICAgIGxhYmVsOiAnU29tZSBsYWJlbCcsIC8vIFN0cmluZ1xuICAgICAgICAgKiAgICAgIG9uQ2xpY2s6IChldmVudCkgPT4ge30gLy8gRnVuY3Rpb25cbiAgICAgICAgICogfV1cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IEFycmF5XG4gICAgICAgICAqL1xuICAgICAgICBpdGVtczogQXJyYXlcblxuICAgIH0sXG5cbiAgICBtZXRob2RzOiB7XG5cbiAgICAgICAgcHJlZml4OiBwcmVmaXgsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIHRoZSBgY2xpY2tgIGV2ZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gT2JqZWN0IGV2ZW50XG4gICAgICAgICAqIEBwYXJhbSBPYmplY3QgaXRlbVxuICAgICAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgICAgICovXG4gICAgICAgIG9uQ2xpY2soZXZlbnQsIGl0ZW0pIHtcbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2l0ZW06Y2xpY2snLCBldmVudCwgaXRlbSk7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCd1cGRhdGU6c2hvdycsIGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG59XG5cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IERyb3Bkb3duTWVudSBmcm9tICcuL0Ryb3Bkb3duTWVudSc7XG5pbXBvcnQgRHJvcGRvd25NZW51RGl2aWRlciBmcm9tICcuL0Ryb3Bkb3duTWVudURpdmlkZXInO1xuaW1wb3J0IERyb3Bkb3duTWVudUhlYWRlciBmcm9tICcuL0Ryb3Bkb3duTWVudUhlYWRlcic7XG5pbXBvcnQgVnVlSW5zdGFsbGVyIGZyb20gJ0AvSGVscGVycy9WdWVJbnN0YWxsZXIvVnVlSW5zdGFsbGVyJztcblxuY29uc3QgcGx1Z2luID0gVnVlSW5zdGFsbGVyLnVzZSh7XG5cbiAgICBpbnN0YWxsKFZ1ZSwgb3B0aW9ucykge1xuICAgICAgICBWdWVJbnN0YWxsZXIuY29tcG9uZW50cyh7XG4gICAgICAgICAgICBEcm9wZG93bk1lbnUsXG4gICAgICAgICAgICBEcm9wZG93bk1lbnVEaXZpZGVyLFxuICAgICAgICAgICAgRHJvcGRvd25NZW51SGVhZGVyXG4gICAgICAgIH0pO1xuICAgIH1cblxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IERyb3Bkb3duTWVudTtcbiIsIjx0ZW1wbGF0ZT5cblxuICAgIDxkaXYgY2xhc3M9XCJidG4tZ3JvdXBcIiA6Y2xhc3M9XCJ7J2Ryb3B1cCc6IGRyb3B1cCwgJ2Ryb3ByaWdodCc6IGRyb3ByaWdodCwgJ2Ryb3BsZWZ0JzogZHJvcGxlZnR9XCI+XG5cbiAgICAgICAgPHNsb3QgbmFtZT1cImJ1dHRvblwiPlxuICAgICAgICAgICAgPHRlbXBsYXRlIHYtaWY9XCJzcGxpdFwiPlxuICAgICAgICAgICAgICAgIDxhIHYtaWY9XCJocmVmXCIgOmhyZWY9XCJocmVmXCIgOmNsYXNzPVwiYWN0aW9uQ2xhc3Nlc1wiIEBjbGljaz1cIm9uQ2xpY2tcIj5cbiAgICAgICAgICAgICAgICAgICAgPHNsb3QgbmFtZT1cImxhYmVsLXdyYXBwZXJcIj48aSB2LWlmPVwiaWNvblwiIDpjbGFzcz1cImljb25cIj48L2k+IDxzbG90IG5hbWU9XCJsYWJlbFwiPnt7bGFiZWx9fTwvc2xvdD48L3Nsb3Q+XG4gICAgICAgICAgICAgICAgPC9hPlxuICAgICAgICAgICAgICAgIDxidXR0b24gdi1lbHNlIDp0eXBlPVwidHlwZVwiIDpjbGFzcz1cImFjdGlvbkNsYXNzZXNcIiBAY2xpY2s9XCJvbkNsaWNrXCI+XG4gICAgICAgICAgICAgICAgICAgIDxzbG90IG5hbWU9XCJsYWJlbC13cmFwcGVyXCI+PGkgdi1pZj1cImljb25cIiA6Y2xhc3M9XCJpY29uXCI+PC9pPiA8c2xvdCBuYW1lPVwibGFiZWxcIj57e2xhYmVsfX08L3Nsb3Q+PC9zbG90PlxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGFyaWEtaGFzcG9wdXA9XCJ0cnVlXCIgOmFyaWEtZXhwYW5kZWQ9XCJpc0Ryb3Bkb3duU2hvd2luZ1wiIDppZD1cImlkXCIgOmNsYXNzPVwidG9nZ2xlQ2xhc3Nlc1wiIEBjbGljay5wcmV2ZW50PVwiIWlzRHJvcGRvd25TaG93aW5nID8gc2hvd0Ryb3Bkb3duKCkgOiBoaWRlRHJvcGRvd24oKVwiIEBibHVyPVwib25CbHVyXCI+PC9idXR0b24+XG4gICAgICAgICAgICA8L3RlbXBsYXRlPlxuICAgICAgICAgICAgPHRlbXBsYXRlIHYtZWxzZT5cbiAgICAgICAgICAgICAgICA8YnV0dG9uIGFyaWEtaGFzcG9wdXA9XCJ0cnVlXCIgOmFyaWEtZXhwYW5kZWQ9XCJpc0Ryb3Bkb3duU2hvd2luZ1wiIDp0eXBlPVwidHlwZVwiIDppZD1cImlkXCIgOmNsYXNzPVwidG9nZ2xlQ2xhc3Nlc1wiIEBjbGljay5wcmV2ZW50PVwiIWlzRHJvcGRvd25TaG93aW5nID8gc2hvd0Ryb3Bkb3duKCkgOiBoaWRlRHJvcGRvd24oKVwiIEBibHVyPVwib25CbHVyXCI+XG4gICAgICAgICAgICAgICAgICAgIDxzbG90IG5hbWU9XCJsYWJlbC13cmFwcGVyXCI+PGkgdi1pZj1cImljb25cIiA6Y2xhc3M9XCJpY29uXCI+PC9pPiA8c2xvdCBuYW1lPVwibGFiZWxcIj57e2xhYmVsfX08L3Nsb3Q+PC9zbG90PlxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgPC90ZW1wbGF0ZT5cbiAgICAgICAgPC9zbG90PlxuXG4gICAgICAgIDxzbG90IG5hbWU9XCJkcm9wZG93bi1tZW51XCI+XG4gICAgICAgICAgICA8ZHJvcGRvd24tbWVudSA6aWQ9XCJpZFwiIDppdGVtcz1cIml0ZW1zXCIgOmFsaWduPVwiYWxpZ25cIiA6c2hvdy5zeW5jPVwiaXNEcm9wZG93blNob3dpbmdcIiBAaXRlbTpjbGljaz1cIm9uSXRlbUNsaWNrXCIgdi10cmFuc2Zvcm0tcG9zaXRpb24+XG4gICAgICAgICAgICAgICAgPHNsb3QvPlxuICAgICAgICAgICAgPC9kcm9wZG93bi1tZW51PlxuICAgICAgICA8L3Nsb3Q+XG4gICAgPC9kaXY+XG5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5cbmltcG9ydCB1dWlkIGZyb20gJ0AvSGVscGVycy9VdWlkL1V1aWQnO1xuaW1wb3J0IHByZWZpeCBmcm9tICdAL0hlbHBlcnMvUHJlZml4L1ByZWZpeCc7XG5pbXBvcnQgRHJvcGRvd25NZW51IGZyb20gJy4uL0Ryb3Bkb3duTWVudSc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdidXR0b24tZHJvcGRvd24nLFxuXG4gICAgY29tcG9uZW50czoge1xuICAgICAgICBEcm9wZG93bk1lbnVcbiAgICB9LFxuXG4gICAgZGlyZWN0aXZlczoge1xuICAgICAgICB0cmFuc2Zvcm1Qb3NpdGlvbjoge1xuICAgICAgICAgICAgdXBkYXRlKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgICAgICAgICAgICAgIGxldCB0b3AgPSBudWxsLCBib3R0b20gPSBudWxsLCBsZWZ0ID0gbnVsbCwgcmlnaHQgPSBudWxsLCB4ID0gMCwgeSA9IDA7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXRFbGVtZW50ID0gZ2V0Q29tcHV0ZWRTdHlsZSh2bm9kZS5jb250ZXh0LiRlbC5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAgICAgICAgICAgICB2bm9kZS5jb250ZXh0LnNwbGl0ID8gJy5idG46bm90KC5kcm9wZG93bi10b2dnbGUpJyA6ICcuYnRuLmRyb3Bkb3duLXRvZ2dsZSdcbiAgICAgICAgICAgICAgICApKTtcblxuICAgICAgICAgICAgICAgIC8vaWYodm5vZGUuY29udGV4dC5zcGxpdCkge1xuICAgICAgICAgICAgICAgICAgICBpZih2bm9kZS5jb250ZXh0LnNwbGl0ICYmIHZub2RlLmNvbnRleHQuYWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IG9mZnNldEVsZW1lbnQud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbnVsbFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy99XG5cbiAgICAgICAgICAgICAgICBlbC5zdHlsZS5sZWZ0ID0gbGVmdCA9PT0gbnVsbCA/ICdhdXRvJyA6IGxlZnQ7XG4gICAgICAgICAgICAgICAgZWwuc3R5bGUucmlnaHQgPSByaWdodCA9PT0gbnVsbCA/ICdhdXRvJyA6IHJpZ2h0O1xuICAgICAgICAgICAgICAgIGVsLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoJHt4fSwgJHt5fSlgO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGFycmF5IG9mIGRyb3Bkb3duIGl0ZW1zLiBJZiBhbiBrZXkvdmFsdWUgcGFpciBpc24ndCBkZWZpbmVkLCB0aGVcbiAgICAgICAgICogZGVmYXVsdCB2YWx1ZSB3aWxsIGJlIHVzZWQuIElmIG5vIGl0ZW1zIGFyZSBkZWZpbmVkLCB0aGVuIHRoZSBzbG90XG4gICAgICAgICAqIG5hbWVkIFwiaXRlbXNcIiBjYW4gYmUgdXNlZCB0byBkZWZpbmUgdGhlIG9wdGlvbnMgd2l0aCBIVE1MLlxuICAgICAgICAgKlxuICAgICAgICAgKiBbe1xuICAgICAgICAgKiAgICAgIHR5cGU6ICdpdGVtJywgLy8gU3RyaW5nIFtpdGVtfGhlYWRlcnxkaXZpZGVyXVxuICAgICAgICAgKiAgICAgIGhyZWY6ICcjJywgLy8gU3RyaW5nXG4gICAgICAgICAqICAgICAgbGFiZWw6ICdTb21lIGxhYmVsJywgLy8gU3RyaW5nXG4gICAgICAgICAqICAgICAgb25DbGljazogKGV2ZW50KSA9PiB7fSAvLyBGdW5jdGlvblxuICAgICAgICAgKiB9XVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgQXJyYXlcbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1zOiBBcnJheSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGBocmVmYCBhdHRyaWJ1dGUgb24gdGhlIGFjdGlvbiBidXR0b24gKGlmIGEgc3BsaXQgYnV0dG9uKS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgaHJlZjogU3RyaW5nLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYnV0dG9uIGljb24gdGhhdCBhcHBlYXJzIGJlZm9yZSB0aGUgbGFiZWwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGljb246IFN0cmluZyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRvZ2dsZSBidXR0b24ncyBsYWJlbC4gSWYgbm90IGRlZmluZWQgYXMgYW4gYXR0cmlidXRlLFxuICAgICAgICAgKiB5b3UgY2FuIG92ZXJyaWRlIHdpdGggdGhlIGNvbXBvbmVudCdzIHNsb3QgKGlubmVyIGh0bWwpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBsYWJlbDogU3RyaW5nLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYGlkYCBhdHRyaWJ1dGUgb24gdGhlIHRvZ2dsZSBidXR0b24gYW5kIGFyaWEgbGFiZWwuIElmIG5vIGBpZGAgaXNcbiAgICAgICAgICogZGVmaW5lZCwgdGhlbiBhIFVVSUQgd2lsbCBiZSBnZW5lcmF0ZWQgaW5zdGVhZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgaWQ6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6IHV1aWRcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGB0eXBlYCBhdHRyaWJ1dGUgb24gdGhlIHRvZ2dsZSBidXR0b25cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJ2J1dHRvbidcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNpemUgY2xhc3Mgb2YgdGhlIHRvZ2dsZSBidXR0b25cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgc2l6ZToge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJ21kJ1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdG9nZ2xlIGJ1dHRvbidzIHZhcmlhbnQgY2xhc3MuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHZhcmlhbnQ6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdwcmltYXJ5J1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwbGF5IHRoZSBkcm9wZG93biBtZW51IGFsaWduZWQgbGVmdCBvciByaWdodFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBhbGlnbjoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJ2xlZnQnLFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZih2YWx1ZS50b0xvd2VyQ2FzZSgpKSAhPT0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc3BsYXkgdGhlIGRyb3Bkb3duIGJ1dHRvbiB3aXRoIGEgc3BsaXQgdG9nZ2xlIGJ1dHRvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IEJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIHNwbGl0OiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzcGxheSBhcyBhIGRyb3B1cCBpbnN0ZWFkIG9mIGEgZHJvcGRvd24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBCb29sZWFuXG4gICAgICAgICAqL1xuICAgICAgICBkcm9wdXA6IHtcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwbGF5IGFzIGEgZHJvcHJpZ2h0IGluc3RlYWQgb2YgYSBkcm9wZG93bi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IEJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIGRyb3ByaWdodDoge1xuICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc3BsYXkgYXMgYSBkcm9wbGVmdCBpbnN0ZWFkIG9mIGEgZHJvcGRvd24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBCb29sZWFuXG4gICAgICAgICAqL1xuICAgICAgICBkcm9wbGVmdDoge1xuICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBtZXRob2RzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3cgdGhlIGRyb3Bkb3duIG1lbnVcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB2b2lkXG4gICAgICAgICAqL1xuICAgICAgICBzaG93RHJvcGRvd24oKSB7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCd0b2dnbGUnLCB0aGlzLmlzRHJvcGRvd25TaG93aW5nID0gdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCdzaG93Jyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhpZGUgdGhlIGRyb3Bkb3duIG1lbnVcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB2b2lkXG4gICAgICAgICAqL1xuICAgICAgICBoaWRlRHJvcGRvd24oKSB7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCd0b2dnbGUnLCB0aGlzLmlzRHJvcGRvd25TaG93aW5nID0gZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgnaGlkZScpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGNhbGxiYWNrIGZ1bmN0aW9uIGZvciB0aGUgYGNsaWNrYCBldmVudCBmb3IgdGhlIGFjdGlvbiBidXR0b25cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB2b2lkXG4gICAgICAgICAqL1xuICAgICAgICBvbkNsaWNrKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmhpZGVEcm9wZG93bigpO1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgnY2xpY2snLCBldmVudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIHRoZSBgYmx1cmAgZXZlbnQgZm9yIHRoZSBhY3Rpb24gYnV0dG9uXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAgICAgKi9cbiAgICAgICAgb25CbHVyKGV2ZW50KSB7XG4gICAgICAgICAgICBpZighdGhpcy4kZWwuY29udGFpbnMoZXZlbnQucmVsYXRlZFRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGVEcm9wZG93bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGNhbGxiYWNrIGZ1bmN0aW9uIGZvciB0aGUgYGl0ZW06Y2xpY2tgIGV2ZW50IGZvciB0aGUgYWN0aW9uIGJ1dHRvblxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgICAgICovXG4gICAgICAgIG9uSXRlbUNsaWNrKGV2ZW50LCBjaGlsZCkge1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgnaXRlbTpjbGljaycsIGV2ZW50LCBjaGlsZCk7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBjb21wdXRlZDoge1xuXG4gICAgICAgIGFjdGlvbkNsYXNzZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICdidG4nLFxuICAgICAgICAgICAgICAgIHByZWZpeCh0aGlzLnNpemUsICdidG4nKSxcbiAgICAgICAgICAgICAgICBwcmVmaXgodGhpcy52YXJpYW50LCAnYnRuJylcbiAgICAgICAgICAgIF0uam9pbignICcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRvZ2dsZUNsYXNzZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICdidG4nLFxuICAgICAgICAgICAgICAgICdkcm9wZG93bi10b2dnbGUnLFxuICAgICAgICAgICAgICAgIHByZWZpeCh0aGlzLnNpemUsICdidG4nKSxcbiAgICAgICAgICAgICAgICBwcmVmaXgodGhpcy52YXJpYW50LCAnYnRuJyksXG4gICAgICAgICAgICAgICAgKHRoaXMuc3BsaXQgPyAnZHJvcGRvd24tdG9nZ2xlLXNwbGl0JyA6ICcnKSxcbiAgICAgICAgICAgIF0uam9pbignICcpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpc0Ryb3Bkb3duU2hvd2luZzogZmFsc2VcbiAgICAgICAgfTtcbiAgICB9XG5cbn1cblxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgQnV0dG9uRHJvcGRvd24gZnJvbSAnLi9CdXR0b25Ecm9wZG93bic7XG5pbXBvcnQgVnVlSW5zdGFsbGVyIGZyb20gJ0AvSGVscGVycy9WdWVJbnN0YWxsZXIvVnVlSW5zdGFsbGVyJztcblxuY29uc3QgcGx1Z2luID0gVnVlSW5zdGFsbGVyLnVzZSh7XG5cbiAgICBpbnN0YWxsKFZ1ZSwgb3B0aW9ucykge1xuICAgICAgICBWdWVJbnN0YWxsZXIuY29tcG9uZW50cyh7XG4gICAgICAgICAgICBCdXR0b25Ecm9wZG93blxuICAgICAgICB9KTtcbiAgICB9XG5cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25Ecm9wZG93bjtcbiIsIi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbmVnYXRlcyB0aGUgcmVzdWx0IG9mIHRoZSBwcmVkaWNhdGUgYGZ1bmNgLiBUaGVcbiAqIGBmdW5jYCBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBhbmQgYXJndW1lbnRzIG9mIHRoZVxuICogY3JlYXRlZCBmdW5jdGlvbi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgcHJlZGljYXRlIHRvIG5lZ2F0ZS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG5lZ2F0ZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIGlzRXZlbihuKSB7XG4gKiAgIHJldHVybiBuICUgMiA9PSAwO1xuICogfVxuICpcbiAqIF8uZmlsdGVyKFsxLCAyLCAzLCA0LCA1LCA2XSwgXy5uZWdhdGUoaXNFdmVuKSk7XG4gKiAvLyA9PiBbMSwgMywgNV1cbiAqL1xuZnVuY3Rpb24gbmVnYXRlKHByZWRpY2F0ZSkge1xuICBpZiAodHlwZW9mIHByZWRpY2F0ZSAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6IHJldHVybiAhcHJlZGljYXRlLmNhbGwodGhpcyk7XG4gICAgICBjYXNlIDE6IHJldHVybiAhcHJlZGljYXRlLmNhbGwodGhpcywgYXJnc1swXSk7XG4gICAgICBjYXNlIDI6IHJldHVybiAhcHJlZGljYXRlLmNhbGwodGhpcywgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICBjYXNlIDM6IHJldHVybiAhcHJlZGljYXRlLmNhbGwodGhpcywgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgfVxuICAgIHJldHVybiAhcHJlZGljYXRlLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5lZ2F0ZTtcbiIsInZhciBiYXNlSXRlcmF0ZWUgPSByZXF1aXJlKCcuL19iYXNlSXRlcmF0ZWUnKSxcbiAgICBuZWdhdGUgPSByZXF1aXJlKCcuL25lZ2F0ZScpLFxuICAgIHBpY2tCeSA9IHJlcXVpcmUoJy4vcGlja0J5Jyk7XG5cbi8qKlxuICogVGhlIG9wcG9zaXRlIG9mIGBfLnBpY2tCeWA7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mXG4gKiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBgb2JqZWN0YCB0aGF0XG4gKiBgcHJlZGljYXRlYCBkb2Vzbid0IHJldHVybiB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0d29cbiAqIGFyZ3VtZW50czogKHZhbHVlLCBrZXkpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBwcm9wZXJ0eS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAnMicsICdjJzogMyB9O1xuICpcbiAqIF8ub21pdEJ5KG9iamVjdCwgXy5pc051bWJlcik7XG4gKiAvLyA9PiB7ICdiJzogJzInIH1cbiAqL1xuZnVuY3Rpb24gb21pdEJ5KG9iamVjdCwgcHJlZGljYXRlKSB7XG4gIHJldHVybiBwaWNrQnkob2JqZWN0LCBuZWdhdGUoYmFzZUl0ZXJhdGVlKHByZWRpY2F0ZSkpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvbWl0Qnk7XG4iLCJpbXBvcnQgeyBtYXAgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgZWFjaCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBmaWx0ZXIgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgaXNOdWxsIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IG9taXRCeSB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBjYW1lbENhc2UgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHByZWZpeCBmcm9tICdAL0hlbHBlcnMvUHJlZml4L1ByZWZpeCc7XG5cbmNvbnN0IENPTE9SUyA9IFtcbiAgICAncHJpbWFyeScsXG4gICAgJ3NlY29uZGFyeScsXG4gICAgJ3N1Y2Nlc3MnLFxuICAgICdkYW5nZXInLFxuICAgICd3YXJuaW5nJyxcbiAgICAnaW5mbycsXG4gICAgJ2xpZ2h0JyxcbiAgICAnZGFyaycsXG4gICAgJ3doaXRlJ1xuXTtcblxuY29uc3QgcHJvcHMgPSB7fTtcblxuZWFjaChbJ3RleHQnLCAnYmcnLCAnYmctZ3JhZGllbnQnXSwgbmFtZXNwYWNlID0+IHtcbiAgICBlYWNoKENPTE9SUywgY29sb3IgPT4ge1xuICAgICAgICBwcm9wc1tjYW1lbENhc2UocHJlZml4KGNvbG9yLCBuYW1lc3BhY2UpKV0gPSBCb29sZWFuO1xuICAgIH0pO1xufSk7XG5cbmZ1bmN0aW9uIGNsYXNzZXMoaW5zdGFuY2UsIG5hbWVzcGFjZSkge1xuICAgIHJldHVybiBmaWx0ZXIobWFwKENPTE9SUywgY29sb3IgPT4ge1xuICAgICAgICByZXR1cm4gaW5zdGFuY2VbY2FtZWxDYXNlKGNvbG9yID0gcHJlZml4KGNvbG9yLCBuYW1lc3BhY2UpKV0gPyBjb2xvciA6IG51bGw7XG4gICAgfSkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBwcm9wczogcHJvcHMsXG5cbiAgICBtZXRob2RzOiB7XG5cbiAgICAgICAgdGV4dENvbG9yKCkge1xuICAgICAgICAgICAgcmV0dXJuIGNsYXNzZXModGhpcywgJ3RleHQnKTtcbiAgICAgICAgfSxcblxuICAgICAgICBiZ0NvbG9yKCkge1xuICAgICAgICAgICAgcmV0dXJuIGNsYXNzZXModGhpcywgJ2JnJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYmdHcmFkaWVudENvbG9yKCkge1xuICAgICAgICAgICAgcmV0dXJuIGNsYXNzZXModGhpcywgJ2JnLWdyYWRpZW50Jyk7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBjb21wdXRlZDoge1xuXG4gICAgICAgIHRleHRDb2xvckNsYXNzZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50ZXh0Q29sb3IoKS5qb2luKCcgJykudHJpbSgpIHx8IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYmdDb2xvckNsYXNzZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iZ0NvbG9yKCkuam9pbignICcpLnRyaW0oKSB8fCBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIGJnR3JhZGllbnRDb2xvckNsYXNzZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iZ0dyYWRpZW50Q29sb3IoKS5qb2luKCcgJykudHJpbSgpIHx8IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29sb3JhYmxlQ2xhc3NlcygpIHtcbiAgICAgICAgICAgIGNvbnN0IGNsYXNzZXMgPSB7fTtcblxuICAgICAgICAgICAgY2xhc3Nlc1t0aGlzLnRleHRDb2xvckNsYXNzZXNdID0gISF0aGlzLnRleHRDb2xvckNsYXNzZXM7XG4gICAgICAgICAgICBjbGFzc2VzW3RoaXMuYmdDb2xvckNsYXNzZXNdID0gISF0aGlzLmJnQ29sb3JDbGFzc2VzO1xuICAgICAgICAgICAgY2xhc3Nlc1t0aGlzLmJnR3JhZGllbnRDb2xvckNsYXNzZXNdID0gISF0aGlzLmJnR3JhZGllbnRDb2xvckNsYXNzZXM7XG5cbiAgICAgICAgICAgIHJldHVybiBvbWl0QnkoY2xhc3NlcywgKGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIWtleSB8fCAhdmFsdWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG59XG4iLCJpbXBvcnQgeyBlYWNoIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IG1lcmdlIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IGV4dGVuZCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBpc0FycmF5IH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IGlzT2JqZWN0IH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IGNhbWVsQ2FzZSB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBpc1VuZGVmaW5lZCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgcHJlZml4IGZyb20gJ0AvSGVscGVycy9QcmVmaXgvUHJlZml4JztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgcHJvcHM6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGZpZWxkIGlkIGF0dHJpYnV0ZSB2YWx1ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgaWQ6IFN0cmluZyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHZhbHVlIG9mIGxhYmVsIGVsZW1lbnQuIElmIG5vIHZhbHVlLCBubyBsYWJlbCB3aWxsIGFwcGVhci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgbGFiZWw6IFN0cmluZyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGZpZWxkIG5hbWUgYXR0cmlidXRlIHZhbHVlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBuYW1lOiBTdHJpbmcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBmaWVsZCBpZCBhdHRyaWJ1dGUgdmFsdWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICBkZWZhdWx0OiBudWxsXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwbGFjZWhvbGRlciBhdHRyaWJ1dGUgdmFsdWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHBsYWNlaG9sZGVyOiBTdHJpbmcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElzIHRoZSBmaWVsZCByZXF1aXJlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgcmVxdWlyZWQ6IEJvb2xlYW4sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSByZWdleCBwYXR0ZXJuIGZvciB2YWxpZGF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBwYXR0ZXJuOiBTdHJpbmcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGlubGluZSBmaWVsZCB2YWxpZGF0aW9uIGVycm9yLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nfEJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIGVycm9yOiBTdHJpbmcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGlubGluZSBmaWVsZCB2YWxpZGF0aW9uIGVycm9ycyBwYXNzZWQgYXMgb2JqZWN0IHdpdGgga2V5L3ZhbHVlXG4gICAgICAgICAqIHBhaXJzLiBJZiBlcnJvcnMgcGFzc2VkIGFzIGFuIG9iamVjdCwgdGhlIGZvcm0gbmFtZSB3aWxsIGJlIHVzZWQgZm9yXG4gICAgICAgICAqIHRoZSBrZXkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBPYmplY3R8Qm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgZXJyb3JzOiBbT2JqZWN0LCBBcnJheV0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNvbWUgZmVlZGJhY2sgdG8gYWRkIHRvIHRoZSBmaWVsZCBvbmNlIHRoZSBmaWVsZCBpcyBzdWNjZXNzZnVsbHlcbiAgICAgICAgICogdmFsaWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGZlZWRiYWNrOiBbU3RyaW5nLCBBcnJheV0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGFycmF5IG9mIGV2ZW50IG5hbWVzIHRoYXQgY29ycmVsYXRlIHdpdGggY2FsbGJhY2sgZnVuY3Rpb25zXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBGdW5jdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgYmluZEV2ZW50czoge1xuICAgICAgICAgICAgdHlwZTogQXJyYXksXG4gICAgICAgICAgICBkZWZhdWx0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbJ2ZvY3VzJywgJ2JsdXInLCAnY2hhbmdlJywgJ2NsaWNrJywgJ2tleXVwJywgJ2tleWRvd24nLCAncHJvZ3Jlc3MnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRlZmF1bHQgY2xhc3MgbmFtZSBhc3NpZ25lZCB0byB0aGUgY29udHJvbCBlbGVtZW50XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGRlZmF1bHRDb250cm9sQ2xhc3M6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdmb3JtLWNvbnRyb2wnXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhpZGUgdGhlIGxhYmVsIGZvciBicm93c2VycywgYnV0IGxlYXZlIGl0IGZvciBzY3JlZW4gcmVhZGVycy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgaGlkZUxhYmVsOiBCb29sZWFuLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRpdGlvbmFsIG1hcmdpbi9wYWRkaW5nIGNsYXNzZXMgZm9yIGZpbmUgY29udHJvbCBvZiBzcGFjaW5nXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHNwYWNpbmc6IFN0cmluZyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNpemUgb2YgdGhlIGZvcm0gY29udHJvbFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBzaXplOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAnbWQnLFxuICAgICAgICAgICAgdmFsaWRhdGU6IHZhbHVlID0+IFsnc20nLCAnbWQnLCAnbGcnXS5pbmRleE9mKHZhbHVlKSAhPT0gLTFcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzcGxheSB0aGUgZm9ybSBmaWVsZCBpbmxpbmVcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgaW5saW5lOiBCb29sZWFuLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGUgZm9ybSBjb250cm9sIGlzIHJlYWRvbmx5LCBkaXNwbGF5IG9ubHkgYXMgdGV4dD9cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgcGxhaW50ZXh0OiBCb29sZWFuLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJcyB0aGUgZm9ybSBjb250cm9sIHJlYWRvbmx5P1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICByZWFkb25seTogQm9vbGVhbixcblxuICAgICAgICAvKipcbiAgICAgICAgICogSXMgdGhlIGZvcm0gY29udHJvbCBkaXNhYmxlZD9cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgZGlzYWJsZWQ6IEJvb2xlYW4sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNvbWUgaW5zdHJ1Y3Rpb25zIHRvIGFwcGVhciB1bmRlciB0aGUgZmllbGQgbGFiZWxcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgaGVscFRleHQ6IFN0cmluZyxcblxuICAgIH0sXG5cbiAgICBkaXJlY3RpdmVzOiB7XG4gICAgICAgIGJpbmRFdmVudHM6IHtcbiAgICAgICAgICAgIGJpbmQoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXZlbnRzID0gYmluZGluZy52YWx1ZSB8fCB2bm9kZS5jb250ZXh0LmJpbmRFdmVudHM7XG5cbiAgICAgICAgICAgICAgICBlYWNoKGV2ZW50cywgbmFtZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdm5vZGUuY29udGV4dC4kZW1pdChuYW1lLCBldmVudCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1ldGhvZHM6IHtcblxuICAgICAgICBnZXRJbnB1dEZpZWxkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3IoJy5mb3JtLWNvbnRyb2wsIGlucHV0LCBzZWxlY3QsIHRleHRhcmVhJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0RmllbGRFcnJvcnMoKSB7XG4gICAgICAgICAgICBsZXQgZXJyb3JzID0gdGhpcy5lcnJvciB8fCB0aGlzLmVycm9ycztcblxuICAgICAgICAgICAgaWYoaXNPYmplY3QodGhpcy5lcnJvcnMpKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzID0gdGhpcy5lcnJvcnNbdGhpcy5uYW1lIHx8IHRoaXMuaWRdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gIWVycm9ycyB8fCBpc0FycmF5KGVycm9ycykgfHwgaXNPYmplY3QoZXJyb3JzKSA/IGVycm9ycyA6IFtlcnJvcnNdO1xuICAgICAgICB9LFxuXG4gICAgICAgIHVwZGF0ZWQodmFsdWUsIGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KGV2ZW50IHx8ICdpbnB1dCcsIHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGNvbXB1dGVkOiB7XG5cbiAgICAgICAgY2FsbGJhY2tzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmluZEV2ZW50cy5tYXAoZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogdGhpc1tjYW1lbENhc2UoWydvbicsIGV2ZW50XS5qb2luKCcgJykpXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLmZpbHRlcihldmVudCA9PiAhaXNVbmRlZmluZWQoZXZlbnQuY2FsbGJhY2spKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpbnZhbGlkRmVlZGJhY2soKSB7XG4gICAgICAgICAgICBpZih0aGlzLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3I7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGVycm9ycyA9IHRoaXMuZ2V0RmllbGRFcnJvcnMoKTtcblxuICAgICAgICAgICAgcmV0dXJuIGlzQXJyYXkoZXJyb3JzKSA/IGVycm9ycy5qb2luKCc8YnI+JykgOiBlcnJvcnM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdmFsaWRGZWVkYmFjaygpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuZmVlZGJhY2spID8gdGhpcy5mZWVkYmFjay5qb2luKCc8YnI+JykgOiB0aGlzLmZlZWRiYWNrO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNvbnRyb2xDbGFzcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlZmF1bHRDb250cm9sQ2xhc3MgKyAodGhpcy5wbGFpbnRleHQgPyAnLXBsYWludGV4dCcgOiAnJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29udHJvbFNpemVDbGFzcygpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmVmaXgodGhpcy5zaXplLCB0aGlzLmNvbnRyb2xDbGFzcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29udHJvbENsYXNzZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHRoaXMuY29udHJvbENsYXNzLFxuICAgICAgICAgICAgICAgIHRoaXMuY29udHJvbFNpemVDbGFzcyxcbiAgICAgICAgICAgICAgICAodGhpcy5zcGFjaW5nIHx8ICcnKSxcbiAgICAgICAgICAgICAgICAodGhpcy5pbnZhbGlkRmVlZGJhY2sgPyAnaXMtaW52YWxpZCcgOiAnJylcbiAgICAgICAgICAgIF0uam9pbignICcpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbn1cbiIsIjx0ZW1wbGF0ZT5cbiAgICA8ZGl2IGNsYXNzPVwiZm9ybS1jaGVja1wiIDpjbGFzcz1cIm1lcmdlQ2xhc3Nlcyh7J2Zvcm0tY2hlY2staW5saW5lJzogaW5saW5lfSwgY29udHJvbFNpemVDbGFzcylcIj5cbiAgICAgICAgPGxhYmVsIDpmb3I9XCJpZFwiIDpjbGFzcz1cIm1lcmdlQ2xhc3NlcygnZm9ybS1jaGVjay1sYWJlbCcsIGNvbG9yYWJsZUNsYXNzZXMpXCI+XG4gICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICB0eXBlPVwicmFkaW9cIlxuICAgICAgICAgICAgICAgIDpuYW1lPVwibmFtZVwiXG4gICAgICAgICAgICAgICAgOmlkPVwiaWRcIlxuICAgICAgICAgICAgICAgIDp2YWx1ZT1cInZhbHVlXCJcbiAgICAgICAgICAgICAgICA6cmVxdWlyZWQ9XCJyZXF1aXJlZFwiXG4gICAgICAgICAgICAgICAgOmRpc2FibGVkPVwiZGlzYWJsZWQgfHwgcmVhZG9ubHlcIlxuICAgICAgICAgICAgICAgIDpyZWFkb25seT1cInJlYWRvbmx5XCJcbiAgICAgICAgICAgICAgICA6cGF0dGVybj1cInBhdHRlcm5cIlxuICAgICAgICAgICAgICAgIDpjaGVja2VkPVwidmFsdWUgPT09IGNoZWNrZWRcIlxuICAgICAgICAgICAgICAgIDpjbGFzcz1cIm1lcmdlQ2xhc3Nlcyhjb250cm9sQ2xhc3MsIChpbnZhbGlkRmVlZGJhY2sgPyAnaXMtaW52YWxpZCc6JycpLCAhKGxhYmVsID8gJ3Bvc2l0aW9uLXN0YXRpYycgOiAnJykpXCJcbiAgICAgICAgICAgICAgICB2LWJpbmQtZXZlbnRzPVwiYmluZEV2ZW50c1wiXG4gICAgICAgICAgICAgICAgdi1vbjpjaGFuZ2U9XCJ1cGRhdGVkKCRldmVudC50YXJnZXQudmFsdWUsICdjaGFuZ2UnKVwiPlxuXG4gICAgICAgICAgICA8c2xvdD57e2xhYmVsfX08L3Nsb3Q+XG5cbiAgICAgICAgICAgIDxzbG90IG5hbWU9XCJmZWVkYmFja1wiPlxuICAgICAgICAgICAgICAgIDxmb3JtLWZlZWRiYWNrIHYtaWY9XCJ2YWxpZEZlZWRiYWNrXCIgdi1odG1sPVwidmFsaWRGZWVkYmFja1wiIHZhbGlkIC8+XG4gICAgICAgICAgICAgICAgPGZvcm0tZmVlZGJhY2sgdi1pZj1cImludmFsaWRGZWVkYmFja1wiIHYtaHRtbD1cImludmFsaWRGZWVkYmFja1wiIGludmFsaWQgLz5cbiAgICAgICAgICAgIDwvc2xvdD5cbiAgICAgICAgPC9sYWJlbD5cblxuICAgICAgICA8c2xvdCBuYW1lPVwiaGVscFwiPlxuICAgICAgICAgICAgPGhlbHAtdGV4dCB2LWlmPVwiaGVscFRleHRcIiB2LWh0bWw9XCJoZWxwVGV4dFwiIC8+XG4gICAgICAgIDwvc2xvdD5cbiAgICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5cbmltcG9ydCBwcmVmaXggZnJvbSAnQC9IZWxwZXJzL1ByZWZpeC9QcmVmaXgnO1xuaW1wb3J0IENvbG9yYWJsZSBmcm9tICdAL01peGlucy9Db2xvcmFibGUvQ29sb3JhYmxlJztcbmltcG9ydCBGb3JtQ29udHJvbCBmcm9tICdAL01peGlucy9Gb3JtQ29udHJvbC9Gb3JtQ29udHJvbCc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdyYWRpby1maWVsZCcsXG5cbiAgICBtaXhpbnM6IFtcbiAgICAgICAgQ29sb3JhYmxlLFxuICAgICAgICBGb3JtQ29udHJvbFxuICAgIF0sXG5cbiAgICBtb2RlbDoge1xuICAgICAgICBwcm9wOiAnY2hlY2tlZCcsXG4gICAgICAgIGV2ZW50OiAnY2hhbmdlJ1xuICAgIH0sXG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgZm9ybS1ncm91cCB0byB0aGUgd3JhcHBpbmcgZWxlbWVudFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBncm91cDoge1xuICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc3BsYXkgdGhlIGZvcm0gZmllbGQgYW5kIGxhYmVsIGlubGluZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgRnVuY3Rpb25cbiAgICAgICAgICovXG4gICAgICAgIGlubGluZToge1xuICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjaGVja2VkIHZhbHVlc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBjaGVja2VkOiBbTnVtYmVyLCBTdHJpbmcsIE9iamVjdF0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjbGFzcyBuYW1lIGFzc2lnbmVkIHRvIHRoZSBjb250cm9sIGVsZW1lbnRcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgZGVmYXVsdENvbnRyb2xDbGFzczoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJ2Zvcm0tY2hlY2staW5wdXQnXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBjb21wdXRlZDoge1xuXG4gICAgICAgIGNvbnRyb2xDbGFzcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlZmF1bHRDb250cm9sQ2xhc3M7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29udHJvbFNpemVDbGFzcygpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmVmaXgodGhpcy5zaXplLCAnZm9ybS1jb250cm9sJyk7XG4gICAgICAgIH1cblxuICAgIH1cblxufVxuXG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgICA8ZGl2IGNsYXNzPVwiZm9ybS1jaGVja1wiIDpjbGFzcz1cIm1lcmdlQ2xhc3Nlcyh7J2Zvcm0tY2hlY2staW5saW5lJzogaW5saW5lfSwgY29udHJvbFNpemVDbGFzcylcIj5cbiAgICAgICAgPGxhYmVsIDpmb3I9XCJpZFwiIDpjbGFzcz1cIm1lcmdlQ2xhc3NlcygnZm9ybS1jaGVjay1sYWJlbCcsIGNvbG9yYWJsZUNsYXNzZXMpXCI+XG4gICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICB0eXBlPVwiY2hlY2tib3hcIlxuICAgICAgICAgICAgICAgIDpuYW1lPVwibmFtZVwiXG4gICAgICAgICAgICAgICAgOmlkPVwiaWRcIlxuICAgICAgICAgICAgICAgIDp2YWx1ZT1cInZhbHVlXCJcbiAgICAgICAgICAgICAgICA6cmVxdWlyZWQ9XCJyZXF1aXJlZFwiXG4gICAgICAgICAgICAgICAgOmRpc2FibGVkPVwiZGlzYWJsZWQgfHwgcmVhZG9ubHlcIlxuICAgICAgICAgICAgICAgIDpyZWFkb25seT1cInJlYWRvbmx5XCJcbiAgICAgICAgICAgICAgICA6cGF0dGVybj1cInBhdHRlcm5cIlxuICAgICAgICAgICAgICAgIDpjaGVja2VkPVwiY2hlY2tlZC5pbmRleE9mKHZhbHVlKSAhPT0gLTFcIlxuICAgICAgICAgICAgICAgIDpjbGFzcz1cIm1lcmdlQ2xhc3Nlcyhjb250cm9sQ2xhc3MsIChpbnZhbGlkRmVlZGJhY2sgPyAnaXMtaW52YWxpZCc6JycpLCAhKGxhYmVsID8gJ3Bvc2l0aW9uLXN0YXRpYycgOiAnJykpXCJcbiAgICAgICAgICAgICAgICB2LWJpbmQtZXZlbnRzPVwiYmluZEV2ZW50c1wiXG4gICAgICAgICAgICAgICAgdi1vbjpjaGFuZ2U9XCJ1cGRhdGVkKCRldmVudC50YXJnZXQudmFsdWUsICdjaGFuZ2UnKVwiPlxuXG4gICAgICAgICAgICA8c2xvdD57e2xhYmVsfX08L3Nsb3Q+XG5cbiAgICAgICAgICAgIDxzbG90IG5hbWU9XCJmZWVkYmFja1wiPlxuICAgICAgICAgICAgICAgIDxmb3JtLWZlZWRiYWNrIHYtaWY9XCJ2YWxpZEZlZWRiYWNrXCIgdi1odG1sPVwidmFsaWRGZWVkYmFja1wiIHZhbGlkIC8+XG4gICAgICAgICAgICAgICAgPGZvcm0tZmVlZGJhY2sgdi1pZj1cImludmFsaWRGZWVkYmFja1wiIHYtaHRtbD1cImludmFsaWRGZWVkYmFja1wiIGludmFsaWQgLz5cbiAgICAgICAgICAgIDwvc2xvdD5cbiAgICAgICAgPC9sYWJlbD5cblxuICAgICAgICA8c2xvdCBuYW1lPVwiaGVscFwiPlxuICAgICAgICAgICAgPGhlbHAtdGV4dCB2LWlmPVwiaGVscFRleHRcIiB2LWh0bWw9XCJoZWxwVGV4dFwiIC8+XG4gICAgICAgIDwvc2xvdD5cbiAgICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5cbmltcG9ydCBSYWRpb0ZpZWxkIGZyb20gJ0AvQ29tcG9uZW50cy9SYWRpb0ZpZWxkL1JhZGlvRmllbGQnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAnY2hlY2tib3gtZmllbGQnLFxuXG4gICAgZXh0ZW5kczogUmFkaW9GaWVsZCxcblxuICAgIHByb3BzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY2hlY2tlZCB2YWx1ZXNcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgY2hlY2tlZDoge1xuICAgICAgICAgICAgdHlwZTogQXJyYXksXG4gICAgICAgICAgICBkZWZhdWx0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtZXRob2RzOiB7XG4gICAgICAgIHVwZGF0ZWQodmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrZWQgPSB0aGlzLmNoZWNrZWQuc2xpY2UoMCk7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuY2hlY2tlZC5pbmRleE9mKHZhbHVlKTtcblxuICAgICAgICAgICAgaWYoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgY2hlY2tlZC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoZWNrZWQuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgY2hlY2tlZCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IENoZWNrYm94RmllbGQgZnJvbSAnLi9DaGVja2JveEZpZWxkJztcbmltcG9ydCBWdWVJbnN0YWxsZXIgZnJvbSAnQC9IZWxwZXJzL1Z1ZUluc3RhbGxlci9WdWVJbnN0YWxsZXInO1xuXG5jb25zdCBwbHVnaW4gPSBWdWVJbnN0YWxsZXIudXNlKHtcblxuICAgIGluc3RhbGwoVnVlLCBvcHRpb25zKSB7XG4gICAgICAgIFZ1ZUluc3RhbGxlci5jb21wb25lbnRzKHtcbiAgICAgICAgICAgIENoZWNrYm94RmllbGRcbiAgICAgICAgfSk7XG4gICAgfVxuXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgQ2hlY2tib3hGaWVsZDtcbiIsIjx0ZW1wbGF0ZT5cblxuICAgIDxkaXYgY2xhc3M9XCJjb250YWluZXJcIj48c2xvdC8+PC9kaXY+XG5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5cblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ2NvbnRhaW5lcidcblxufVxuXG48L3NjcmlwdD5cbiIsImltcG9ydCBDb250YWluZXIgZnJvbSAnLi9Db250YWluZXInO1xuaW1wb3J0IFZ1ZUluc3RhbGxlciBmcm9tICdAL0hlbHBlcnMvVnVlSW5zdGFsbGVyL1Z1ZUluc3RhbGxlcic7XG5cbmNvbnN0IHBsdWdpbiA9IFZ1ZUluc3RhbGxlci51c2Uoe1xuXG4gICAgaW5zdGFsbChWdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgVnVlSW5zdGFsbGVyLmNvbXBvbmVudHMoe1xuICAgICAgICAgICAgQ29udGFpbmVyXG4gICAgICAgIH0pO1xuICAgIH1cblxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IENvbnRhaW5lcjtcbiIsIjx0ZW1wbGF0ZT5cblxuICAgIDxmb3JtLWdyb3VwPlxuXG4gICAgICAgIDxzbG90IG5hbWU9XCJsYWJlbFwiPlxuICAgICAgICAgICAgPGZvcm0tbGFiZWwgdi1pZj1cImxhYmVsXCIgOmZvcj1cImlkXCIgdi1odG1sPVwibGFiZWxcIiAvPlxuICAgICAgICA8L3Nsb3Q+XG5cbiAgICAgICAgPHNsb3QgbmFtZT1cImNvbnRyb2xcIj5cbiAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgIDp0eXBlPVwidHlwZVwiXG4gICAgICAgICAgICAgICAgOmlkPVwiaWRcIlxuICAgICAgICAgICAgICAgIDp2YWx1ZT1cInZhbHVlXCJcbiAgICAgICAgICAgICAgICA6cGxhY2Vob2xkZXI9XCJwbGFjZWhvbGRlclwiXG4gICAgICAgICAgICAgICAgOnJlcXVpcmVkPVwicmVxdWlyZWRcIlxuICAgICAgICAgICAgICAgIDpkaXNhYmxlZD1cImRpc2FibGVkIHx8IHJlYWRvbmx5XCJcbiAgICAgICAgICAgICAgICA6cmVhZG9ubHk9XCJyZWFkb25seVwiXG4gICAgICAgICAgICAgICAgOnBhdHRlcm49XCJwYXR0ZXJuXCJcbiAgICAgICAgICAgICAgICA6Y2xhc3M9XCJtZXJnZUNsYXNzZXMoY29udHJvbENsYXNzZXMsIGNvbG9yYWJsZUNsYXNzZXMpXCJcbiAgICAgICAgICAgICAgICB2LWJpbmQtZXZlbnRzPVwiYmluZEV2ZW50c1wiXG4gICAgICAgICAgICAgICAgdi1vbjppbnB1dD1cInVwZGF0ZWQoJGV2ZW50LnRhcmdldC52YWx1ZSlcIlxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9zbG90PlxuXG4gICAgICAgIDxzbG90IG5hbWU9XCJoZWxwXCI+XG4gICAgICAgICAgICA8aGVscC10ZXh0IHYtaWY9XCJoZWxwVGV4dFwiIHYtaHRtbD1cImhlbHBUZXh0XCIgLz5cbiAgICAgICAgPC9zbG90PlxuXG4gICAgICAgIDxzbG90IG5hbWU9XCJmZWVkYmFja1wiPlxuICAgICAgICAgICAgPGZvcm0tZmVlZGJhY2sgdi1pZj1cInZhbGlkRmVlZGJhY2tcIiB2LWh0bWw9XCJ2YWxpZEZlZWRiYWNrXCIgdmFsaWQgLz5cbiAgICAgICAgICAgIDxmb3JtLWZlZWRiYWNrIHYtaWY9XCJpbnZhbGlkRmVlZGJhY2tcIiB2LWh0bWw9XCJpbnZhbGlkRmVlZGJhY2tcIiBpbnZhbGlkIC8+XG4gICAgICAgIDwvc2xvdD5cblxuICAgIDwvZm9ybS1ncm91cD5cblxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cblxuaW1wb3J0IENvbG9yYWJsZSBmcm9tICdAL01peGlucy9Db2xvcmFibGUvQ29sb3JhYmxlJztcbmltcG9ydCBGb3JtQ29udHJvbCBmcm9tICdAL01peGlucy9Gb3JtQ29udHJvbC9Gb3JtQ29udHJvbCc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdpbnB1dC1maWVsZCcsXG5cbiAgICBtaXhpbnM6IFtcbiAgICAgICAgQ29sb3JhYmxlLFxuICAgICAgICBGb3JtQ29udHJvbFxuICAgIF0sXG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdHlwZSBhdHRyaWJ1dGVcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJ3RleHQnXG4gICAgICAgIH1cblxuICAgIH1cblxufVxuXG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cblxuICAgIDxmb3JtLWdyb3VwPlxuXG4gICAgICAgIDxzbG90IG5hbWU9XCJsYWJlbFwiPlxuICAgICAgICAgICAgPGZvcm0tbGFiZWwgdi1pZj1cImxhYmVsXCIgOmZvcj1cImlkXCIgdi1odG1sPVwibGFiZWxcIj48L2Zvcm0tbGFiZWw+XG4gICAgICAgIDwvc2xvdD5cblxuICAgICAgICA8ZGl2IGNsYXNzPVwiY3VzdG9tLWZpbGVcIj5cblxuICAgICAgICAgICAgPHNsb3QgbmFtZT1cInBsYWNlaG9sZGVyXCI+XG4gICAgICAgICAgICAgICAgPGZvcm0tbGFiZWwgOmNsYXNzPVwibWVyZ2VDbGFzc2VzKGNvbG9yYWJsZUNsYXNzZXMsICdjdXN0b20tZmlsZS1sYWJlbCcpXCIgOmZvcj1cImlkXCIgdi1odG1sPVwicGxhY2Vob2xkZXIgfHwgJ0Nob29zZSBmaWxlJ1wiIC8+XG4gICAgICAgICAgICA8L3Nsb3Q+XG5cbiAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgIHYtYmluZC1ldmVudHNcbiAgICAgICAgICAgICAgICB0eXBlPVwiZmlsZVwiXG4gICAgICAgICAgICAgICAgOmNsYXNzPVwiY29udHJvbENsYXNzZXNcIlxuICAgICAgICAgICAgICAgIDppZD1cImlkXCJcbiAgICAgICAgICAgICAgICA6d2lkdGg9XCJ3aWR0aFwiXG4gICAgICAgICAgICAgICAgOmhlaWdodD1cImhlaWdodFwiXG4gICAgICAgICAgICAgICAgOnJlcXVpcmVkPVwicmVxdWlyZWRcIlxuICAgICAgICAgICAgICAgIDptdWx0aXBsZT1cIm11bHRpcGxlXCJcbiAgICAgICAgICAgICAgICA6cmVhZG9ubHk9XCJyZWFkb25seVwiXG4gICAgICAgICAgICAgICAgdi1vbjpjaGFuZ2U9XCJ1cGRhdGVkKCRldmVudC50YXJnZXQuZmlsZXMpXCI+XG5cbiAgICAgICAgICAgIDxzbG90IG5hbWU9XCJoZWxwXCI+XG4gICAgICAgICAgICAgICAgPGhlbHAtdGV4dCB2LWlmPVwiaGVscFRleHRcIiB2LWh0bWw9XCJoZWxwVGV4dFwiIC8+XG4gICAgICAgICAgICA8L3Nsb3Q+XG5cbiAgICAgICAgICAgIDxzbG90IG5hbWU9XCJmZWVkYmFja1wiPlxuICAgICAgICAgICAgICAgIDxmb3JtLWZlZWRiYWNrIHYtaWY9XCJ2YWxpZEZlZWRiYWNrXCIgdi1odG1sPVwidmFsaWRGZWVkYmFja1wiIHZhbGlkIC8+XG4gICAgICAgICAgICAgICAgPGZvcm0tZmVlZGJhY2sgdi1pZj1cImludmFsaWRGZWVkYmFja1wiIHYtaHRtbD1cImludmFsaWRGZWVkYmFja1wiIGludmFsaWQgLz5cbiAgICAgICAgICAgIDwvc2xvdD5cblxuICAgICAgICA8L2Rpdj5cblxuICAgIDwvZm9ybS1ncm91cD5cblxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cblxuaW1wb3J0IElucHV0RmllbGQgZnJvbSAnQC9Db21wb25lbnRzL0lucHV0RmllbGQvSW5wdXRGaWVsZCc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdmaWxlLWZpZWxkJyxcblxuICAgIGV4dGVuZHM6IElucHV0RmllbGQsXG5cbiAgICBtb2RlbDoge1xuICAgICAgICBldmVudDogJ2NoYW5nZSdcbiAgICB9LFxuXG4gICAgcHJvcHM6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNsYXNzIG5hbWUgYXNzaWduZWQgdG8gdGhlIGNvbnRyb2wgZWxlbWVudFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBkZWZhdWx0Q29udHJvbENsYXNzOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAnY3VzdG9tLWZpbGUtaW5wdXQnXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGFycmF5IG9mIHZhbGlkIGV4dGVuc2lvbnNcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgZXh0ZW5zaW9uczogQXJyYXksXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0eXBlIGF0dHJpYnV0ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBtdWx0aXBsZTogQm9vbGVhbixcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGhlaWdodCBhdHRyaWJ1dGUgZm9yIHRoZSBjb250cm9sIGVsZW1lbnRcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgaGVpZ2h0OiBbTnVtYmVyLCBTdHJpbmddLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgd2lkdGggYXR0cmlidXRlIGZvciB0aGUgY29udHJvbCBlbGVtZW50XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHdpZHRoOiBbTnVtYmVyLCBTdHJpbmddXG5cbiAgICB9XG5cbn1cblxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgRmlsZUZpZWxkIGZyb20gJy4vRmlsZUZpZWxkJztcbmltcG9ydCBWdWVJbnN0YWxsZXIgZnJvbSAnQC9IZWxwZXJzL1Z1ZUluc3RhbGxlci9WdWVJbnN0YWxsZXInO1xuXG5jb25zdCBwbHVnaW4gPSBWdWVJbnN0YWxsZXIudXNlKHtcblxuICAgIGluc3RhbGwoVnVlLCBvcHRpb25zKSB7XG4gICAgICAgIFZ1ZUluc3RhbGxlci5jb21wb25lbnRzKHtcbiAgICAgICAgICAgIEZpbGVGaWVsZFxuICAgICAgICB9KTtcbiAgICB9XG5cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBGaWxlRmllbGQ7XG4iLCJpbXBvcnQgeyBpc0Z1bmN0aW9uIH0gZnJvbSAnbG9kYXNoJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmVhZEZpbGUoZmlsZSwgcHJvZ3Jlc3MpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcjtcbiAgICAgICAgcmVhZGVyLm9ubG9hZCA9IGUgPT4gcmVzb2x2ZShlKTtcbiAgICAgICAgcmVhZGVyLm9uZXJyb3IgPSBlID0+IHJlamVjdChlKTtcbiAgICAgICAgcmVhZGVyLm9uYWJvcnQgPSBlID0+IHJlamVjdChlKTtcbiAgICAgICAgcmVhZGVyLm9ucHJvZ3Jlc3MgPSBlID0+IHByb2dyZXNzKGUsIHJlYWRlcik7XG4gICAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGZpbGUpO1xuICAgIH0pO1xufVxuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgTnVtYmVyYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqICoqTm90ZToqKiBUbyBleGNsdWRlIGBJbmZpbml0eWAsIGAtSW5maW5pdHlgLCBhbmQgYE5hTmAsIHdoaWNoIGFyZVxuICogY2xhc3NpZmllZCBhcyBudW1iZXJzLCB1c2UgdGhlIGBfLmlzRmluaXRlYCBtZXRob2QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBudW1iZXIsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc051bWJlcigzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNOdW1iZXIoSW5maW5pdHkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNOdW1iZXIoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBudW1iZXJUYWcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTnVtYmVyO1xuIiwiPHRlbXBsYXRlPlxuICAgIDxkaXYgY2xhc3M9XCJwcm9ncmVzc1wiIDpzdHlsZT1cInsnaGVpZ2h0JzogZm9ybWF0dGVkSGVpZ2h0fVwiPlxuICAgICAgICA8ZGl2IHJvbGU9XCJwcm9ncmVzc2JhclwiIDpzdHlsZT1cInsnd2lkdGgnOiBwcm9ncmVzcyArICclJ31cIiBjbGFzcz1cInByb2dyZXNzLWJhclwiIDpjbGFzcz1cIm1lcmdlQ2xhc3Nlcyhwcm9ncmVzc0NsYXNzZXMsIGNvbG9yYWJsZUNsYXNzZXMpXCIgOmFyaWEtdmFsdWVub3c9XCJwcm9ncmVzc1wiIGFyaWEtdmFsdWVtaW49XCIwXCIgYXJpYS12YWx1ZW1heD1cIjEwMFwiPlxuICAgICAgICAgICAgPHNwYW4gdi1pZj1cImxhYmVsXCI+e3twcm9ncmVzc319JTwvc3Bhbj5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuXG5pbXBvcnQgeyBpc051bWJlciB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgQ29sb3JhYmxlIGZyb20gJ0AvTWl4aW5zL0NvbG9yYWJsZS9Db2xvcmFibGUnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAncHJvZ3Jlc3MtYmFyJyxcblxuICAgIG1peGluczogW1xuICAgICAgICBDb2xvcmFibGVcbiAgICBdLFxuXG4gICAgcHJvcHM6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHByb2dyZXNzIGJhciBwZXJjZW50YWdlIHZhbHVlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHByb2dyZXNzOiB7XG4gICAgICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBwcm9ncmVzcyBiYXJcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgaGVpZ2h0OiBbTnVtYmVyLCBTdHJpbmddLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG93IHRoZSBwcm9ncmVzcyBiYXIgdmFsdWUgYXMgYSBsYWJlbCBpbnNpZGUgdGhlIGJhclxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBsYWJlbDogQm9vbGVhbixcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvdWxkIHRoZSBwcm9ncmVzcyBiYXIgYXBwZWFyIHdpdGggc3RyaXBlc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBzdHJpcGVkOiBCb29sZWFuLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG91bGQgdGhlIHByb2dyZXNzIGJhciBhcHBlYXIgd2l0aCBhbmltYXRlZCBzdHJpcGVzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGFuaW1hdGVkOiBCb29sZWFuXG5cbiAgICB9LFxuXG4gICAgY29tcHV0ZWQ6IHtcblxuICAgICAgICBmb3JtYXR0ZWRIZWlnaHQoKSB7XG4gICAgICAgICAgICByZXR1cm4gIXRoaXMuaGVpZ2h0ID8gbnVsbCA6IChcbiAgICAgICAgICAgICAgICBpc051bWJlcih0aGlzLmhlaWdodCkgPyB0aGlzLmhlaWdodCArICdweCcgOiB0aGlzLmhlaWdodFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICBwcm9ncmVzc0NsYXNzZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICdwcm9ncmVzcy1iYXItc3RyaXBlZCc6IHRoaXMuc3RyaXBlZCxcbiAgICAgICAgICAgICAgICAncHJvZ3Jlc3MtYmFyLWFuaW1hdGVkJzogdGhpcy5hbmltYXRlZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG59XG5cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuXG4gICAgPGRpdiBjbGFzcz1cImZpbGUtcHJldmlld1wiIDpjbGFzcz1cInsnaXMtaW1hZ2UnOiBpc0ltYWdlfVwiPlxuXG4gICAgICAgIDxhIHYtaWY9XCIhaXNJbWFnZSB8fCBpbWFnZVwiIGhyZWY9XCIjXCIgY2xhc3M9XCJmaWxlLXByZXZpZXctY2xvc2VcIiBAY2xpY2sucHJldmVudD1cIiRlbWl0KCdjbG9zZScsIGZpbGUpXCI+XG4gICAgICAgICAgICA8aSBjbGFzcz1cImZhIGZhLXRpbWVzLWNpcmNsZVwiPjwvaT5cbiAgICAgICAgPC9hPlxuXG4gICAgICAgIDxkaXYgdi1pZj1cImlzSW1hZ2VcIiBjbGFzcz1cImZpbGUtcHJldmlldy1pbWFnZVwiPlxuICAgICAgICAgICAgPGltZyB2LWlmPVwiaW1hZ2VcIiA6c3JjPVwiaW1hZ2VcIiBjbGFzcz1cImZpbGUtcHJldmlldy10aHVtYm5haWxcIj5cbiAgICAgICAgICAgIDxwcm9ncmVzcy1iYXIgdi1lbHNlIHYtcmVhZHk9XCJyZWFkRmlsZVwiIDpwcm9ncmVzcz1cImxvYWRlZFwiIDpoZWlnaHQ9XCIxMFwiIC8+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIDxkaXYgdi1lbHNlIGNsYXNzPVwiZmlsZS1wcmV2aWV3LWljb25cIj5cbiAgICAgICAgICAgIDxpIGNsYXNzPVwiZmEgZmEtZmlsZS1vXCI+PC9pPlxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8ZGl2IGNsYXNzPVwiZmlsZS1wcmV2aWV3LWZpbGVuYW1lXCIgdi1odG1sPVwibmFtZVwiPjwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwiZmlsZS1wcmV2aWV3LWZpbGVzaXplXCI+KHt7c2l6ZX19KTwvZGl2PlxuICAgIDwvZGl2PlxuXG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IG1vbWVudCBmcm9tICdtb21lbnQnO1xuaW1wb3J0IHsgaXNGdW5jdGlvbiB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgcmVhZEZpbGUgZnJvbSAnQC9IZWxwZXJzL1JlYWRGaWxlL1JlYWRGaWxlJztcbmltcG9ydCBQcm9ncmVzc0JhciBmcm9tICdAL0NvbXBvbmVudHMvUHJvZ3Jlc3NCYXIvUHJvZ3Jlc3NCYXInO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAnZmlsZS1wcmV2aWV3JyxcblxuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgICAgUHJvZ3Jlc3NCYXJcbiAgICB9LFxuXG4gICAgZGlyZWN0aXZlczoge1xuICAgICAgICByZWFkeToge1xuICAgICAgICAgICAgaW5zZXJ0ZWQoZWwsIGJpbmRpbmcpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYoaXNGdW5jdGlvbihiaW5kaW5nLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmluZGluZy52YWx1ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgNTApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB1cGxvYWRlZCBGaWxlIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgT2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBmaWxlOiB7XG4gICAgICAgICAgICB0eXBlOiBbT2JqZWN0LCBGaWxlXSxcbiAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGFycmF5IG9mIG1pbWUgdHlwZXMgdGhhdCBzaG91bGQgYmUgdXNlZCB0byBkZXRlcm1pbmUgaWYgdGhlXG4gICAgICAgICAqIGZpbGUgaXMgYW4gaW1hZ2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBBcnJheVxuICAgICAgICAgKi9cbiAgICAgICAgaW1hZ2VNaW1lczoge1xuICAgICAgICAgICAgdHlwZTogQXJyYXksXG4gICAgICAgICAgICBkZWZhdWx0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbJ2ltYWdlL2dpZicsICdpbWFnZS9wbmcnLCAnaW1hZ2UvanBlZycsICdpbWFnZS9ibXAnLCAnaW1hZ2Uvd2VicCddO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgY29tcHV0ZWQ6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBmaWxlIG5hbWVcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgbmFtZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbGUgaW5zdGFuY2VvZiBGaWxlID8gdGhpcy5maWxlLm5hbWUgOiB0aGlzLmZpbGUub3JpZ19maWxlbmFtZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBmaWxlIGV4dGVuc2lvblxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBleHRlbnNpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maWxlIGluc3RhbmNlb2YgRmlsZSA/IHRoaXMuZmlsZS5uYW1lLnNwbGl0KCcuJykucG9wKCkudG9Mb3dlckNhc2UoKSA6IHRoaXMuZmlsZS5leHRlbnNpb247XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgZmlsZSBmb3JtYXR0ZWQgc2l6ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBzaXplKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnl0ZXNUb1NpemUodGhpcy5maWxlIGluc3RhbmNlb2YgRmlsZSA/IHRoaXMuZmlsZS5zaXplIDogdGhpcy5maWxlLmJ5dGVzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBmaWxlIHR5cGVcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgdHlwZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbGUgaW5zdGFuY2VvZiBGaWxlID8gdGhpcy5maWxlLnR5cGUgOiB0aGlzLmZpbGUubWltZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhlIGZpbGUgYW4gaW1hZ2U/XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGlzSW1hZ2UoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbWFnZU1pbWVzLmluZGV4T2YodGhpcy50eXBlKSAhPT0gLTE7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgbGFzdCB0aW1lIHRoZSBmaWxlIHdhcyBtb2RpZmllZCAoYXMgdGltZXN0YW1wKVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBsYXN0TW9kaWZpZWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maWxlIGluc3RhbmNlb2YgRmlsZSA/IHRoaXMuZmlsZS5sYXN0TW9kaWZpZWQgOiBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGxhc3QgdGltZSB0aGUgZmlsZSB3YXMgbW9kaWZpZWQgKGFzIERhdGUpXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGxhc3RNb2RpZmllZERhdGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maWxlIGluc3RhbmNlb2YgRmlsZSA/IHRoaXMuZmlsZS5sYXN0TW9kaWZpZWREYXRlIDogbnVsbDtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgcmVhZEZpbGUoKSB7XG4gICAgICAgICAgICBpZih0aGlzLmZpbGUgaW5zdGFuY2VvZiBGaWxlKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBtb21lbnQoKTtcblxuICAgICAgICAgICAgICAgIHJlYWRGaWxlKHRoaXMuZmlsZSwgZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmKGUubGVuZ3RoQ29tcHV0YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2FkZWQgPSBwYXJzZUludCgoZS5sb2FkZWQgLyBlLnRvdGFsKSAqIDEwMCwgMTApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkudGhlbihlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmltYWdlID0gZS50YXJnZXQucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9LCA2MDAgLSBtb21lbnQoKS5kaWZmKHN0YXJ0KSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICBcdGJ5dGVzVG9TaXplOiBmdW5jdGlvbihieXRlcykge1xuICAgIFx0XHR2YXIgc2l6ZXMgPSBbJ0J5dGVzJywgJ0tCJywgJ01CJywgJ0dCJywgJ1RCJ107XG4gICAgXHRcdGlmIChieXRlcyA9PSAwKSByZXR1cm4gJzAgQnl0ZSc7XG4gICAgXHRcdHZhciBpID0gcGFyc2VJbnQoTWF0aC5mbG9vcihNYXRoLmxvZyhieXRlcykgLyBNYXRoLmxvZygxMDI0KSkpO1xuICAgIFx0XHRyZXR1cm4gTWF0aC5yb3VuZChieXRlcyAvIE1hdGgucG93KDEwMjQsIGkpLCAyKSArICcgJyArIHNpemVzW2ldO1xuICAgIFx0fVxuXG4gICAgfSxcblxuICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsb2FkZWQ6IDAsXG4gICAgICAgICAgICBpbWFnZTogdGhpcy5maWxlLnVybFxuICAgICAgICB9O1xuICAgIH1cblxufVxuXG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJzY3NzXCI+XG5AaW1wb3J0ICcuL25vZGVfbW9kdWxlcy9ib290c3RyYXAvc2Nzcy9ib290c3RyYXAuc2Nzcyc7XG5cbiRmaWxlLXByZXZpZXctY2xvc2Utd2lkdGg6ICRmb250LXNpemUtYmFzZSAqIDI7XG4kZmlsZS1wcmV2aWV3LWNsb3NlLWhlaWdodDogJGZvbnQtc2l6ZS1iYXNlICogMjtcblxuLmZpbGUtcHJldmlldyB7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuXG4gICAgLmZpbGUtcHJldmlldy1jbG9zZSB7XG4gICAgICAgIHRvcDogMDtcbiAgICAgICAgcmlnaHQ6IDA7XG4gICAgICAgIHBhZGRpbmc6IDA7XG4gICAgICAgIHdpZHRoOiAyNHB4O1xuICAgICAgICBoZWlnaHQ6IDI0cHg7XG4gICAgICAgIGJhY2tncm91bmQ6IHdoaXRlO1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDEwMCU7XG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKDMzJSwgLTMzJSk7XG5cbiAgICAgICAgaSB7XG4gICAgICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgICAgICB0b3A6IDA7XG4gICAgICAgICAgICBsZWZ0OiAwO1xuICAgICAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgICAgICBmb250LXNpemU6IDI0cHg7XG4gICAgICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAuZmlsZS1wcmV2aWV3LWljb24ge1xuICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgICAgIGZvbnQtc2l6ZTogNjBweDtcbiAgICAgICAgcGFkZGluZzogMXJlbTtcbiAgICB9XG5cbiAgICAuZmlsZS1wcmV2aWV3LXRodW1ibmFpbCB7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBtYXgtd2lkdGg6IDEwMCU7XG4gICAgfVxuXG4gICAgLmZpbGUtcHJldmlldy1maWxlbmFtZSB7XG4gICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcbiAgICAgICAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XG4gICAgfVxuXG4gICAgLmZpbGUtcHJldmlldy1maWxlbmFtZSxcbiAgICAuZmlsZS1wcmV2aWV3LWZpbGVzaXplIHtcbiAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgIH1cblxufVxuXG48L3N0eWxlPlxuIiwiaW1wb3J0IEZpbGVQcmV2aWV3IGZyb20gJy4vRmlsZVByZXZpZXcnO1xuaW1wb3J0IFZ1ZUluc3RhbGxlciBmcm9tICdAL0hlbHBlcnMvVnVlSW5zdGFsbGVyL1Z1ZUluc3RhbGxlcic7XG5cbmNvbnN0IHBsdWdpbiA9IFZ1ZUluc3RhbGxlci51c2Uoe1xuXG4gICAgaW5zdGFsbChWdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgVnVlSW5zdGFsbGVyLmNvbXBvbmVudHMoe1xuICAgICAgICAgICAgRmlsZVByZXZpZXdcbiAgICAgICAgfSk7XG4gICAgfVxuXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgRmlsZVByZXZpZXc7XG4iLCI8dGVtcGxhdGU+XG5cbiAgICA8ZGl2IDpjbGFzcz1cInsnaW52YWxpZC1mZWVkYmFjayc6IGludmFsaWQsICd2YWxpZC1mZWVkYmFjayc6IHZhbGlkICYmICFpbnZhbGlkfVwiPlxuICAgICAgICA8c2xvdD57e2xhYmVsfX08L3Nsb3Q+XG4gICAgPC9kaXY+XG5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5cbmltcG9ydCBDb2xvcmFibGUgZnJvbSAnQC9NaXhpbnMvQ29sb3JhYmxlL0NvbG9yYWJsZSc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdmb3JtLWZlZWRiYWNrJyxcblxuICAgIG1peGluczogW1xuICAgICAgICBDb2xvcmFibGVcbiAgICBdLFxuXG4gICAgcHJvcHM6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHZhbHVlIG9mIGxhYmVsIGVsZW1lbnQuIElmIG5vIHZhbHVlLCBubyBsYWJlbCB3aWxsIGFwcGVhci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgbGFiZWw6IFN0cmluZyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvdWxkIHRoZSBmZWVkYmFjayBtYXJrZWQgYXMgaW52YWxpZFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBpbnZhbGlkOiBCb29sZWFuLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG91bGQgdGhlIGZlZWRiYWNrIG1hcmtlZCBhcyBpbnZhbGlkXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHZhbGlkOiBCb29sZWFuXG5cbiAgICB9XG5cbn1cblxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgRm9ybUZlZWRiYWNrIGZyb20gJy4vRm9ybUZlZWRiYWNrJztcbmltcG9ydCBWdWVJbnN0YWxsZXIgZnJvbSAnQC9IZWxwZXJzL1Z1ZUluc3RhbGxlci9WdWVJbnN0YWxsZXInO1xuXG5jb25zdCBwbHVnaW4gPSBWdWVJbnN0YWxsZXIudXNlKHtcblxuICAgIGluc3RhbGwoVnVlLCBvcHRpb25zKSB7XG4gICAgICAgIFZ1ZUluc3RhbGxlci5jb21wb25lbnRzKHtcbiAgICAgICAgICAgIEZvcm1GZWVkYmFja1xuICAgICAgICB9KTtcbiAgICB9XG5cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBGb3JtRmVlZGJhY2s7XG4iLCI8dGVtcGxhdGU+XG5cbiAgICA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cFwiPjxzbG90Lz48L2Rpdj5cblxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cblxuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAnZm9ybS1ncm91cCdcbiAgICBcbn1cblxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgRm9ybUdyb3VwIGZyb20gJy4vRm9ybUdyb3VwJztcbmltcG9ydCBWdWVJbnN0YWxsZXIgZnJvbSAnQC9IZWxwZXJzL1Z1ZUluc3RhbGxlci9WdWVJbnN0YWxsZXInO1xuXG5jb25zdCBwbHVnaW4gPSBWdWVJbnN0YWxsZXIudXNlKHtcblxuICAgIGluc3RhbGwoVnVlLCBvcHRpb25zKSB7XG4gICAgICAgIFZ1ZUluc3RhbGxlci5jb21wb25lbnRzKHtcbiAgICAgICAgICAgIEZvcm1Hcm91cFxuICAgICAgICB9KTtcbiAgICB9XG5cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBGb3JtR3JvdXA7XG4iLCJleHBvcnQgZGVmYXVsdCB7XG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG91bGQgc2hvdyBvbmx5IGZvciBzY3JlZW5yZWFkZXJzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBCb29sZWFuXG4gICAgICAgICAqL1xuICAgICAgICBzck9ubHk6IEJvb2xlYW4sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3VsZCBiZSBmb2N1c2FibGUgZm9yIHNjcmVlbnJlYWRlcnNcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IEJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIHNyT25seUZvY3VzYWJsZTogQm9vbGVhblxuXG4gICAgfSxcblxuICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIHNjcmVlbnJlYWRlckNsYXNzZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICdzci1vbmx5JzogdGhpcy5zck9ubHksXG4gICAgICAgICAgICAgICAgJ3NyLW9ubHktZm9jdXNhYmxlJzogdGhpcy5zck9ubHlGb2N1c2FibGUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG59XG4iLCI8dGVtcGxhdGU+XG5cbiAgICA8bGFiZWwgOmNsYXNzPVwiY2xhc3Nlc1wiPjxzbG90Lz48L2xhYmVsPlxuXG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuXG5pbXBvcnQgeyBleHRlbmQgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IENvbG9yYWJsZSBmcm9tICdAL01peGlucy9Db2xvcmFibGUvQ29sb3JhYmxlJztcbmltcG9ydCBTY3JlZW5yZWFkZXJzIGZyb20gJ0AvTWl4aW5zL1NjcmVlbnJlYWRlcnMvU2NyZWVucmVhZGVycyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdmb3JtLWxhYmVsJyxcblxuICAgIG1peGluczogW1xuICAgICAgICBDb2xvcmFibGUsXG4gICAgICAgIFNjcmVlbnJlYWRlcnNcbiAgICBdLFxuXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgY2xhc3NlcygpIHtcbiAgICAgICAgICAgIHJldHVybiBleHRlbmQoe30sIHRoaXMuc2NyZWVucmVhZGVyQ2xhc3NlcywgdGhpcy5jb2xvcmFibGVDbGFzc2VzKTtcbiAgICAgICAgfVxuICAgIH1cblxufVxuXG48L3NjcmlwdD5cbiIsImltcG9ydCBGb3JtTGFiZWwgZnJvbSAnLi9Gb3JtTGFiZWwnO1xuaW1wb3J0IFZ1ZUluc3RhbGxlciBmcm9tICdAL0hlbHBlcnMvVnVlSW5zdGFsbGVyL1Z1ZUluc3RhbGxlcic7XG5cbmNvbnN0IHBsdWdpbiA9IFZ1ZUluc3RhbGxlci51c2Uoe1xuXG4gICAgaW5zdGFsbChWdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgVnVlSW5zdGFsbGVyLmNvbXBvbmVudHMoe1xuICAgICAgICAgICAgRm9ybUxhYmVsXG4gICAgICAgIH0pO1xuICAgIH1cblxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IEZvcm1MYWJlbDtcbiIsIjx0ZW1wbGF0ZT5cblxuICAgIDxzbWFsbCBjbGFzcz1cImZvcm0tdGV4dFwiIDpjbGFzcz1cImNsYXNzZXNcIj48c2xvdCAvPjwvc21hbGw+XG5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5cbmltcG9ydCB7IGV4dGVuZCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgQ29sb3JhYmxlIGZyb20gJ0AvTWl4aW5zL0NvbG9yYWJsZS9Db2xvcmFibGUnO1xuaW1wb3J0IFNjcmVlbnJlYWRlcnMgZnJvbSAnQC9NaXhpbnMvU2NyZWVucmVhZGVycy9TY3JlZW5yZWFkZXJzJztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ2hlbHAtdGV4dCcsXG5cbiAgICBtaXhpbnM6IFtcbiAgICAgICAgQ29sb3JhYmxlLFxuICAgICAgICBTY3JlZW5yZWFkZXJzXG4gICAgXSxcblxuICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIGNsYXNzZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gZXh0ZW5kKHt9LCB0aGlzLnNjcmVlbnJlYWRlckNsYXNzZXMsIHRoaXMuY29sb3JhYmxlQ2xhc3Nlcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgSGVscFRleHQgZnJvbSAnLi9IZWxwVGV4dCc7XG5pbXBvcnQgVnVlSW5zdGFsbGVyIGZyb20gJ0AvSGVscGVycy9WdWVJbnN0YWxsZXIvVnVlSW5zdGFsbGVyJztcblxuY29uc3QgcGx1Z2luID0gVnVlSW5zdGFsbGVyLnVzZSh7XG5cbiAgICBpbnN0YWxsKFZ1ZSwgb3B0aW9ucykge1xuICAgICAgICBWdWVJbnN0YWxsZXIuY29tcG9uZW50cyh7XG4gICAgICAgICAgICBIZWxwVGV4dFxuICAgICAgICB9KTtcbiAgICB9XG5cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBIZWxwVGV4dDtcbiIsImltcG9ydCBJbnB1dEZpZWxkIGZyb20gJy4vSW5wdXRGaWVsZCc7XG5pbXBvcnQgVnVlSW5zdGFsbGVyIGZyb20gJ0AvSGVscGVycy9WdWVJbnN0YWxsZXIvVnVlSW5zdGFsbGVyJztcblxuY29uc3QgcGx1Z2luID0gVnVlSW5zdGFsbGVyLnVzZSh7XG5cbiAgICBpbnN0YWxsKFZ1ZSwgb3B0aW9ucykge1xuICAgICAgICBWdWVJbnN0YWxsZXIuY29tcG9uZW50cyh7XG4gICAgICAgICAgICBJbnB1dEZpZWxkXG4gICAgICAgIH0pO1xuICAgIH1cblxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IElucHV0RmllbGQ7XG4iLCI8dGVtcGxhdGU+XG4gICAgPGZvcm0tZ3JvdXA+XG4gICAgICAgIDxzbG90IG5hbWU9XCJsYWJlbFwiPlxuICAgICAgICAgICAgPGZvcm0tbGFiZWwgdi1pZj1cImxhYmVsXCIgOmZvcj1cImlkXCIgdi1odG1sPVwibGFiZWxcIiAvPlxuICAgICAgICA8L3Nsb3Q+XG5cbiAgICAgICAgPGRpdiA6Y2xhc3M9XCJjb250cm9sQ2xhc3Nlc1wiIHRhYmluZGV4PVwiMFwiIEBjbGljaz1cInRvZ2dsZSgpXCIgQGtleXVwLjMyPVwidG9nZ2xlKClcIiBAa2V5dXAuMzc9XCJ0b2dnbGUob2ZmVmFsdWUpXCIgQGtleXVwLjM5PVwidG9nZ2xlKG9uVmFsdWUpXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwibGlnaHQtc3dpdGNoLWhhbmRsZVwiPjwvZGl2PlxuICAgICAgICBcdDxkaXYgY2xhc3M9XCJsaWdodC1zd2l0Y2gtY29udGFpbmVyXCI+XG4gICAgICAgIFx0XHQ8ZGl2IGNsYXNzPVwibGlnaHQtc3dpdGNoLWxhYmVsIG9uLXZhbHVlXCI+PC9kaXY+XG4gICAgICAgIFx0XHQ8ZGl2IGNsYXNzPVwibGlnaHQtc3dpdGNoLWxhYmVsIG9mZi12YWx1ZVwiPjwvZGl2PlxuICAgICAgICBcdDwvZGl2PlxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiA6bmFtZT1cIm5hbWVcIiA6dmFsdWU9XCJ2YWx1ZVwiIDppZD1cImlkXCIgY2xhc3M9XCJmb3JtLWNvbnRyb2wgZC1ub25lXCI+XG5cbiAgICAgICAgPHNsb3QgbmFtZT1cImZlZWRiYWNrXCI+XG4gICAgICAgICAgICA8Zm9ybS1mZWVkYmFjayB2LWlmPVwidmFsaWRGZWVkYmFja1wiIHYtaHRtbD1cInZhbGlkRmVlZGJhY2tcIiB2YWxpZCAvPlxuICAgICAgICAgICAgPGZvcm0tZmVlZGJhY2sgdi1pZj1cImludmFsaWRGZWVkYmFja1wiIHYtaHRtbD1cImludmFsaWRGZWVkYmFja1wiIGludmFsaWQgLz5cbiAgICAgICAgPC9zbG90PlxuXG4gICAgICAgIDxzbG90IG5hbWU9XCJoZWxwXCI+XG4gICAgICAgICAgICA8aGVscC10ZXh0IHYtaWY9XCJoZWxwVGV4dFwiIHYtaHRtbD1cImhlbHBUZXh0XCIgLz5cbiAgICAgICAgPC9zbG90PlxuICAgIDwvZm9ybS1ncm91cD5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5cbmltcG9ydCB7IGV4dGVuZCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBpc1VuZGVmaW5lZCB9IGZyb20gJ2xvZGFzaCc7XG4vL2ltcG9ydCBCYXNlRmllbGQgZnJvbSAnLi9CYXNlRmllbGQnO1xuaW1wb3J0IEZvcm1Db250cm9sIGZyb20gJ0AvTWl4aW5zL0Zvcm1Db250cm9sL0Zvcm1Db250cm9sJztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ2xpZ2h0LXN3aXRjaC1maWVsZCcsXG5cbiAgICBtaXhpbnM6IFtGb3JtQ29udHJvbF0sXG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY2xhc3MgbmFtZSBhc3NpZ25lZCB0byB0aGUgY29udHJvbCBlbGVtZW50XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGRlZmF1bHRDb250cm9sQ2xhc3M6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdmb3JtLWNvbnRyb2wgbGlnaHQtc3dpdGNoJ1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY2xhc3MgbmFtZSBhc3NpZ25lZCB0byB0aGUgY29udHJvbCBlbGVtZW50XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGFjdGl2ZUNsYXNzOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAnb24nXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjbGFzcyBuYW1lIGFzc2lnbmVkIHRvIHRoZSBjb250cm9sIGVsZW1lbnRcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgb25WYWx1ZToge1xuICAgICAgICAgICAgZGVmYXVsdDogMVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY2xhc3MgbmFtZSBhc3NpZ25lZCB0byB0aGUgY29udHJvbCBlbGVtZW50XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIG9mZlZhbHVlOiB7XG4gICAgICAgICAgICBkZWZhdWx0OiAwXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBjb21wdXRlZDoge1xuXG4gICAgICAgIGlzQWN0aXZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlID09PSB0aGlzLm9uVmFsdWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29udHJvbENsYXNzZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHRoaXMuY29udHJvbENsYXNzLFxuICAgICAgICAgICAgICAgIHRoaXMuY29udHJvbFNpemVDbGFzcyxcbiAgICAgICAgICAgICAgICAodGhpcy5zcGFjaW5nIHx8ICcnKSxcbiAgICAgICAgICAgICAgICAodGhpcy5pbnZhbGlkRmVlZGJhY2sgPyAnaXMtaW52YWxpZCcgOiAnJyksXG4gICAgICAgICAgICAgICAgKHRoaXMuZHJhZ2dpbmcgPyAnaXMtZHJhZ2dpbmcnIDogJycpLFxuICAgICAgICAgICAgICAgICh0aGlzLmlzQWN0aXZlID8gJ2lzLWFjdGl2ZScgOiAnJylcbiAgICAgICAgICAgIF0uam9pbignICcpO1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgbWV0aG9kczoge1xuXG4gICAgICAgIGdldFRyYW5zaXRpb25Jbk1pbGxpc2Vjb25kcygpIHtcbiAgICAgICAgICAgIGNvbnN0IGR1cmF0aW9uID0gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLiRlbC5xdWVyeVNlbGVjdG9yKCcubGlnaHQtc3dpdGNoLWhhbmRsZScpKS50cmFuc2l0aW9uRHVyYXRpb247XG4gICAgICAgICAgICBjb25zdCBudW1lcmljID0gcGFyc2VGbG9hdChkdXJhdGlvbiwgMTApO1xuICAgICAgICAgICAgY29uc3QgdW5pdCA9IGR1cmF0aW9uLm1hdGNoKC9tP3MvKTtcblxuICAgICAgICAgICAgc3dpdGNoICh1bml0WzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudW1lcmljICogMTAwMDtcbiAgICAgICAgICAgICAgICBjYXNlICdtcyc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudW1lcmljO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke3VuaXRbMF19XCIgaXMgbm90IGEgdmFsaWQgdW5pdCBvZiBtZWFzdXJlLiBVbml0IG11c3QgYmUgXCJzXCIgKHNlY29uZHMpIG9yIFwibXNcIiAobWlsbGlzZWNvbmRzKS5gKTtcbiAgICAgICAgfSxcblxuICAgICAgICB0b2dnbGUodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2lucHV0JywgIWlzVW5kZWZpbmVkKHZhbHVlKSA/IHZhbHVlIDogKHRoaXMuaXNBY3RpdmUgPyB0aGlzLm9mZlZhbHVlIDogdGhpcy5vblZhbHVlKSk7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICB3YXRjaDoge1xuICAgICAgICB2YWx1ZSgpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9LCB0aGlzLmdldFRyYW5zaXRpb25Jbk1pbGxpc2Vjb25kcygpKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZHJhZ2dpbmc6IGZhbHNlXG4gICAgICAgIH07XG4gICAgfVxuXG59XG5cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cInNjc3NcIj5cbkBpbXBvcnQgJy4vbm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC9zY3NzL2Jvb3RzdHJhcC5zY3NzJztcblxuJGxpZ2h0LXN3aXRjaC1hbmltYXRpb24tZWFzaW5nOiBlYXNlO1xuJGxpZ2h0LXN3aXRjaC1hbmltYXRpb24tbGVuZ3RoOiAxcyAvIDM7XG4kbGlnaHQtc3dpdGNoLWhhbmRsZS13aWR0aDogJGZvbnQtc2l6ZS1iYXNlICogMjtcbiRsaWdodC1zd2l0Y2gtaGFuZGxlLWhlaWdodDogJGxpZ2h0LXN3aXRjaC1oYW5kbGUtd2lkdGg7XG4kbGlnaHQtc3dpdGNoLXNpemUtd2lkdGg6ICRsaWdodC1zd2l0Y2gtaGFuZGxlLXdpZHRoICogMS41O1xuJGxpZ2h0LXN3aXRjaC1zaXplLWhlaWdodDogJGxpZ2h0LXN3aXRjaC1oYW5kbGUtaGVpZ2h0O1xuJGxpZ2h0LXN3aXRjaC1sYWJlbC13aWR0aDogJGxpZ2h0LXN3aXRjaC1oYW5kbGUtd2lkdGg7XG4kbGlnaHQtc3dpdGNoLWxhYmVsLWhlaWdodDogJGxpZ2h0LXN3aXRjaC1oYW5kbGUtaGVpZ2h0O1xuXG5AbWl4aW4gbGlnaHQtc3dpdGNoLXNpemUoJHNpemUsICRtb2RpZmllcikge1xuICAgICRoYW5kbGUtd2lkdGg6ICRsaWdodC1zd2l0Y2gtaGFuZGxlLXdpZHRoICogJG1vZGlmaWVyO1xuICAgICRoYW5kbGUtaGVpZ2h0OiAkaGFuZGxlLXdpZHRoO1xuICAgICRzaXplLXdpZHRoOiAkaGFuZGxlLXdpZHRoICogMS41O1xuICAgICRzaXplLWhlaWdodDogJGhhbmRsZS1oZWlnaHQ7XG4gICAgJGxhYmVsLXdpZHRoOiAkaGFuZGxlLXdpZHRoO1xuICAgICRsYWJlbC1oZWlnaHQ6ICRoYW5kbGUtaGVpZ2h0O1xuXG4gICAgJi5saWdodC1zd2l0Y2gtI3skc2l6ZX0ge1xuICAgICAgICBwYWRkaW5nOiAwO1xuICAgIFx0d2lkdGg6ICRzaXplLXdpZHRoO1xuICAgIFx0aGVpZ2h0OiAkaGFuZGxlLWhlaWdodDtcbiAgICBcdGJvcmRlci1yYWRpdXM6ICRoYW5kbGUtd2lkdGg7XG5cbiAgICAgICAgLmxpZ2h0LXN3aXRjaC1oYW5kbGUge1xuICAgICAgICAgICAgd2lkdGg6ICRoYW5kbGUtd2lkdGg7XG4gICAgICAgICAgICBoZWlnaHQ6ICRoYW5kbGUtaGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgLmxpZ2h0LXN3aXRjaC1jb250YWluZXIge1xuICAgICAgICAgICAgbGVmdDogLSRoYW5kbGUtd2lkdGggLyAyO1xuICAgICAgICAgICAgd2lkdGg6ICRsYWJlbC13aWR0aCAqIDI7XG4gICAgICAgICAgICBoZWlnaHQ6ICRsYWJlbC1oZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICAmLmlzLWFjdGl2ZSB7XG4gICAgICAgICAgICAubGlnaHQtc3dpdGNoLWhhbmRsZSB7XG4gICAgICAgICAgICAgICAgbGVmdDogJGhhbmRsZS13aWR0aCAvIDI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAubGlnaHQtc3dpdGNoLWxhYmVsIHtcbiAgICAgICAgICAgIHdpZHRoOiAkbGFiZWwtd2lkdGg7XG4gICAgICAgICAgICBoZWlnaHQ6ICRsYWJlbC1oZWlnaHQ7XG5cbiAgICAgICAgICAgICYub24tdmFsdWUge1xuICAgICAgICAgICAgICAgIC8vYm9yZGVyLXJhZGl1czogJGhhbmRsZS13aWR0aCAwIDAgJGhhbmRsZS13aWR0aDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgJi5vZmYtdmFsdWUge1xuICAgICAgICAgICAgICAgIC8vYm9yZGVyLXJhZGl1czogMCAkaGFuZGxlLXdpZHRoICRoYW5kbGUtd2lkdGggMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuLmxpZ2h0LXN3aXRjaCB7XG4gICAgcGFkZGluZzogMDtcblx0cG9zaXRpb246IHJlbGF0aXZlO1xuXHRib3JkZXI6IG5vbmU7XG5cdHdpZHRoOiAkbGlnaHQtc3dpdGNoLXNpemUtd2lkdGg7XG5cdGhlaWdodDogJGxpZ2h0LXN3aXRjaC1oYW5kbGUtaGVpZ2h0O1xuXHRib3JkZXItcmFkaXVzOiAkbGlnaHQtc3dpdGNoLWhhbmRsZS13aWR0aDtcblx0b3ZlcmZsb3c6IGhpZGRlbjtcblx0Y3Vyc29yOiBwb2ludGVyO1xuXHQtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xuXHQtbW96LXVzZXItc2VsZWN0OiBub25lO1xuXHQtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XG5cdG92ZXJmbG93OiBoaWRkZW47XG5cbiAgICBAaW5jbHVkZSBsaWdodC1zd2l0Y2gtc2l6ZSgneHMnLCAuNSk7XG4gICAgQGluY2x1ZGUgbGlnaHQtc3dpdGNoLXNpemUoJ3NtJywgLjc1KTtcbiAgICBAaW5jbHVkZSBsaWdodC1zd2l0Y2gtc2l6ZSgnbWQnLCAxKTtcbiAgICBAaW5jbHVkZSBsaWdodC1zd2l0Y2gtc2l6ZSgnbGcnLCAxLjUpO1xuICAgIEBpbmNsdWRlIGxpZ2h0LXN3aXRjaC1zaXplKCd4bCcsIDIpO1xuXG4gICAgQGluY2x1ZGUgZm9ybS12YWxpZGF0aW9uLXN0YXRlKFwidmFsaWRcIiwgJGZvcm0tZmVlZGJhY2stdmFsaWQtY29sb3IpO1xuICAgIEBpbmNsdWRlIGZvcm0tdmFsaWRhdGlvbi1zdGF0ZShcImludmFsaWRcIiwgJGZvcm0tZmVlZGJhY2staW52YWxpZC1jb2xvcik7XG5cbiAgICAmLmlzLWludmFsaWQge1xuICAgICAgICBib3JkZXI6IDFweCBzb2xpZCAkZm9ybS1mZWVkYmFjay1pbnZhbGlkLWNvbG9yO1xuXG4gICAgICAgICYgLmxpZ2h0LXN3aXRjaC1oYW5kbGUge1xuXG5cbiAgICAgICAgfVxuXG4gICAgICAgICY6bm90KC5pcy1hY3RpdmUpIC5saWdodC1zd2l0Y2gtaGFuZGxlIHtcbiAgICAgICAgICAgIGJhY2tncm91bmQ6ICRmb3JtLWZlZWRiYWNrLWludmFsaWQtY29sb3I7XG4gICAgICAgIH1cblxuICAgICAgICAubGlnaHQtc3dpdGNoLWxhYmVsIHtcbiAgICAgICAgICAgICYub24tdmFsdWUge1xuICAgICAgICAgICAgICAgIGxlZnQ6IC0xcHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAmLm9mZi12YWx1ZSB7XG4gICAgICAgICAgICAgICAgcmlnaHQ6IC0xcHg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAubGlnaHQtc3dpdGNoLWhhbmRsZSB7XG4gICAgICAgIHRvcDogLTFweDtcbiAgICAgICAgbGVmdDogLTFweDtcbiAgICAgICAgei1pbmRleDogMTtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICBib3JkZXItcmFkaXVzOiAxMDAlO1xuICAgICAgICB0cmFuc2l0aW9uOiBsZWZ0ICRsaWdodC1zd2l0Y2gtYW5pbWF0aW9uLWxlbmd0aCAkbGlnaHQtc3dpdGNoLWFuaW1hdGlvbi1lYXNpbmc7XG4gICAgICAgIHdpZHRoOiAkbGlnaHQtc3dpdGNoLWhhbmRsZS13aWR0aDtcbiAgICAgICAgaGVpZ2h0OiAkbGlnaHQtc3dpdGNoLWhhbmRsZS1oZWlnaHQ7XG4gICAgICAgIGJhY2tncm91bmQ6IHdoaXRlO1xuICAgICAgICBiYWNrZ3JvdW5kLWltYWdlOiByYWRpYWwtZ3JhZGllbnQod2hpdGUsIHJnYigyNTAsIDI1MCwgMjUwKSA1MCUsIHdoaXRlIDc1JSk7XG4gICAgICAgIGJveC1zaGFkb3c6IGluc2V0IDAgMCAwIDFweCByZ2JhKDAsIDAsIDAsIDAuMSksIDAgMCAwIDFweCByZ2JhKDAsIDAsIDAsIDAuMSk7XG4gICAgfVxuXG4gICAgLmxpZ2h0LXN3aXRjaC1jb250YWluZXIge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIGxlZnQ6IC0kbGlnaHQtc3dpdGNoLWhhbmRsZS13aWR0aCAvIDI7XG4gICAgICAgIHRvcDogKCRsaWdodC1zd2l0Y2gtaGFuZGxlLWhlaWdodCAtICAkbGlnaHQtc3dpdGNoLWxhYmVsLWhlaWdodCkgLyAyO1xuICAgICAgICB3aWR0aDogJGxpZ2h0LXN3aXRjaC1sYWJlbC13aWR0aCAqIDI7XG4gICAgICAgIGhlaWdodDogJGxpZ2h0LXN3aXRjaC1sYWJlbC1oZWlnaHQ7XG4gICAgICAgIHRyYW5zaXRpb246IGxlZnQgJGxpZ2h0LXN3aXRjaC1hbmltYXRpb24tbGVuZ3RoICRsaWdodC1zd2l0Y2gtYW5pbWF0aW9uLWVhc2luZztcbiAgICB9XG5cbiAgICAmOm5vdCguaXMtYWN0aXZlKSB7XG4gICAgICAgICY6bm90KC5pcy1kcmFnZ2luZykgLm9uLXZhbHVlIHtcbiAgICAgICAgICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgICYuaXMtYWN0aXZlIHtcbiAgICAgICAgJjpub3QoLmlzLWRyYWdnaW5nKSAub2ZmLXZhbHVlIHtcbiAgICAgICAgICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcbiAgICAgICAgfVxuXG4gICAgICAgIC5saWdodC1zd2l0Y2gtaGFuZGxlIHtcbiAgICAgICAgICAgIGxlZnQ6ICRsaWdodC1zd2l0Y2gtaGFuZGxlLXdpZHRoIC8gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIC5saWdodC1zd2l0Y2gtY29udGFpbmVyIHtcbiAgICAgICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAubGlnaHQtc3dpdGNoLWxhYmVsIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB3aWR0aDogJGxpZ2h0LXN3aXRjaC1sYWJlbC13aWR0aDtcbiAgICAgICAgaGVpZ2h0OiAkbGlnaHQtc3dpdGNoLWxhYmVsLWhlaWdodDtcbiAgICAgICAgLy9ib3gtc2hhZG93OiBpbnNldCAwIDAgMCAxcHggcmdiYSgwLCAwLCAwLCAwLjEpO1xuXG4gICAgICAgICYub24tdmFsdWUge1xuICAgICAgICAgICAgbGVmdDogMDtcbiAgICAgICAgICAgIGJhY2tncm91bmQ6ICMwMGIwMDc7XG4gICAgICAgICAgICAvL2JvcmRlci1yYWRpdXM6ICRsaWdodC1zd2l0Y2gtaGFuZGxlLXdpZHRoIDAgMCAkbGlnaHQtc3dpdGNoLWhhbmRsZS13aWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgICYub2ZmLXZhbHVlIHtcbiAgICAgICAgICAgIHJpZ2h0OiAwO1xuICAgICAgICAgICAgYmFja2dyb3VuZDogI2ViZWRlZjtcbiAgICAgICAgICAgIC8vYm9yZGVyLXJhZGl1czogMCAkbGlnaHQtc3dpdGNoLWhhbmRsZS13aWR0aCAkbGlnaHQtc3dpdGNoLWhhbmRsZS13aWR0aCAwO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cblxuPC9zdHlsZT5cbiIsImltcG9ydCBMaWdodFN3aXRjaEZpZWxkIGZyb20gJy4vTGlnaHRTd2l0Y2hGaWVsZCc7XG5pbXBvcnQgVnVlSW5zdGFsbGVyIGZyb20gJ0AvSGVscGVycy9WdWVJbnN0YWxsZXIvVnVlSW5zdGFsbGVyJztcblxuY29uc3QgcGx1Z2luID0gVnVlSW5zdGFsbGVyLnVzZSh7XG5cbiAgICBpbnN0YWxsKFZ1ZSwgb3B0aW9ucykge1xuICAgICAgICBWdWVJbnN0YWxsZXIuY29tcG9uZW50cyh7XG4gICAgICAgICAgICBMaWdodFN3aXRjaEZpZWxkXG4gICAgICAgIH0pO1xuICAgIH1cblxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IExpZ2h0U3dpdGNoRmllbGQ7XG4iLCI8dGVtcGxhdGU+XG4gICAgPGEgdi1pZj1cImhyZWZcIiA6aHJlZj1cImhyZWZcIiBjbGFzcz1cImxpc3QtZ3JvdXAtaXRlbVwiIDpjbGFzcz1cImNsYXNzZXNcIiBAY2xpY2s9XCJvbkNsaWNrXCI+XG4gICAgICAgIDxzbG90Pnt7bGFiZWx9fTwvc2xvdD4gPGJhZGdlIHYtaWY9XCJiYWRnZVwiIHYtYmluZD1cImJhZGdlT3B0aW9uc1wiPjwvYmFkZ2U+XG4gICAgPC9hPlxuICAgIDxhIHYtZWxzZS1pZj1cImFjdGlvblwiIGhyZWY9XCIjXCIgY2xhc3M9XCJsaXN0LWdyb3VwLWl0ZW1cIiA6Y2xhc3M9XCJjbGFzc2VzXCIgQGNsaWNrLnByZXZlbnQ9XCJvbkNsaWNrXCI+XG4gICAgICAgIDxzbG90Pnt7bGFiZWx9fTwvc2xvdD4gPGJhZGdlIHYtaWY9XCJiYWRnZVwiIHYtYmluZD1cImJhZGdlT3B0aW9uc1wiPjwvYmFkZ2U+XG4gICAgPC9hPlxuICAgIDxkaXYgdi1lbHNlIGNsYXNzPVwibGlzdC1ncm91cC1pdGVtXCIgOmNsYXNzPVwiY2xhc3Nlc1wiIEBjbGljaz1cIm9uQ2xpY2tcIj5cbiAgICAgICAgPHNsb3Q+e3tsYWJlbH19PC9zbG90PiA8YmFkZ2Ugdi1pZj1cImJhZGdlXCIgdi1iaW5kPVwiYmFkZ2VPcHRpb25zXCI+PC9iYWRnZT5cbiAgICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5cbmltcG9ydCB7IGlzT2JqZWN0IH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBCYWRnZSBmcm9tICcuLi9CYWRnZSc7XG5pbXBvcnQgcHJlZml4IGZyb20gJ0AvSGVscGVycy9QcmVmaXgvUHJlZml4JztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgY29tcG9uZW50czoge1xuICAgICAgICBCYWRnZVxuICAgIH0sXG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbGlzdCBpdGVtIGxhYmVsLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgT2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBsYWJlbDoge1xuICAgICAgICAgICAgdHlwZTogW051bWJlciwgU3RyaW5nXSxcbiAgICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsaXN0IGdyb3VwIGl0ZW0gYW4gYWN0aW9uLCBvciBjbGlja2FibGUgaXRlbS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IEJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIGFjdGlvbjoge1xuICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsaXN0IGdyb3VwIGl0ZW0gYWN0aXZlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgQm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgYWN0aXZlOiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGxpc3QgZ3JvdXAgaXRlbSBkaXNhYmxlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IEJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIGRpc2FibGVkOiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGxpc3QgZ3JvdXAgaXRlbSB2YXJpYW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICB2YXJpYW50OiBTdHJpbmcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsaXN0IGdyb3VwIGl0ZW0gaHJlZiBhdHRyaWJ1dGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGhyZWY6IFN0cmluZyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGJhZGdlIGxhYmVsIChpZiBudW1iZXIgb3Igc3RyaW5nKSBvciBvYmplY3Qgb2Ygb3B0aW9ucyB0byBwYXNzIHRvXG4gICAgICAgICAqIHRoZSBjb21wb25lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmd8T2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBiYWRnZTogW051bWJlciwgU3RyaW5nLCBPYmplY3RdXG5cbiAgICB9LFxuXG4gICAgY29tcHV0ZWQ6IHtcblxuICAgICAgICBjbGFzc2VzKCkge1xuICAgICAgICAgICAgY29uc3QgY2xhc3NlcyA9IHByZWZpeCh7XG4gICAgICAgICAgICAgICAgJ2FjdGlvbic6IHRoaXMuYWN0aW9uLFxuICAgICAgICAgICAgfSwgJ2xpc3QtZ3JvdXAtaXRlbScpO1xuXG4gICAgICAgICAgICBjbGFzc2VzWydhY3RpdmUnXSA9IHRoaXMuaXNBY3RpdmU7XG4gICAgICAgICAgICBjbGFzc2VzWydkaXNhYmxlZCddID0gdGhpcy5pc0Rpc2FibGVkO1xuXG4gICAgICAgICAgICBpZih0aGlzLnZhcmlhbnQpIHtcbiAgICAgICAgICAgICAgICBjbGFzc2VzW3ByZWZpeCh0aGlzLnZhcmlhbnQsICdsaXN0LWdyb3VwLWl0ZW0nKV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY2xhc3NlcztcbiAgICAgICAgfSxcblxuICAgICAgICBiYWRnZU9wdGlvbnMoKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNPYmplY3QodGhpcy5iYWRnZSkgPyB0aGlzLmJhZGdlIDoge1xuICAgICAgICAgICAgICAgIGxhYmVsOiB0aGlzLmJhZGdlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgbWV0aG9kczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUb2dnbGUgdGhlIGxpc3QgaXRlbSdzIGFjdGl2ZSBjbGFzcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB2b2lkXG4gICAgICAgICAqL1xuICAgICAgICB0b2dnbGUoKSB7XG4gICAgICAgICAgICB0aGlzLmlzQWN0aXZlID0gIXRoaXMuaXNBY3RpdmU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFjdGl2YXRlIHRoZSBsaXN0IGl0ZW0uXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAgICAgKi9cbiAgICAgICAgYWN0aXZhdGUoKSB7XG4gICAgICAgICAgICB0aGlzLmlzQWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVhY3RpdmF0ZSB0aGUgbGlzdCBpdGVtLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgICAgICovXG4gICAgICAgIGRlYWN0aXZhdGUoKSB7XG4gICAgICAgICAgICB0aGlzLmlzQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFjdGl2YXRlIHRoZSBsaXN0IGl0ZW0uXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAgICAgKi9cbiAgICAgICAgZGlzYWJsZSgpIHtcbiAgICAgICAgICAgIHRoaXMuaXNEaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWFjdGl2YXRlIHRoZSBsaXN0IGl0ZW0uXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAgICAgKi9cbiAgICAgICAgZW5hYmxlKCkge1xuICAgICAgICAgICAgdGhpcy5pc0Rpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjYWxsYmFjayBmdW5jdGlvbiBmb3IgdGhlIGBjbGlja2AgZXZlbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAgICAgKi9cbiAgICAgICAgb25DbGljayhldmVudCkge1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgnY2xpY2snLCBldmVudCwgdGhpcyk7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICB3YXRjaDoge1xuXG4gICAgICAgIGlzQWN0aXZlKHZhbHVlLCBwcmV2VmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ3VwZGF0ZTphY3RpdmUnLCB0aGlzLmlzQWN0aXZlKTtcbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ3RvZ2dsZScsIHRoaXMuaXNBY3RpdmUsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy4kZW1pdCh2YWx1ZSA/ICdhY3RpdmF0ZScgOiAnZGVhY3RpdmF0ZScsIHRoaXMpO1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlzQWN0aXZlOiB0aGlzLmFjdGl2ZSxcbiAgICAgICAgICAgIGlzRGlzYWJsZWQ6IHRoaXMuZGlzYWJsZWRcbiAgICAgICAgfTtcbiAgICB9XG5cbn1cblxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gICAgPGRpdiBjbGFzcz1cImxpc3QtZ3JvdXBcIiA6Y2xhc3M9XCJjbGFzc2VzXCI+XG4gICAgICAgIDxzbG90PlxuICAgICAgICAgICAgPGxpc3QtZ3JvdXAtaXRlbSB2LWZvcj1cIihpdGVtLCBrZXkpIGluIGl0ZW1zXCIgOmtleT1cImtleVwiIHYtYmluZD1cIml0ZW1cIi8+XG4gICAgICAgIDwvc2xvdD5cbiAgICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5cbmltcG9ydCB7IGVhY2ggfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IExpc3RHcm91cEl0ZW0gZnJvbSAnLi9MaXN0R3JvdXBJdGVtJztcbmltcG9ydCBwcmVmaXggZnJvbSAnQC9IZWxwZXJzL1ByZWZpeC9QcmVmaXgnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBjb21wb25lbnRzOiB7XG4gICAgICAgIExpc3RHcm91cEl0ZW1cbiAgICB9LFxuXG4gICAgcHJvcHM6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gYXJyYXkgb2YgbGlzdCBpdGVtIG9iamVjdHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFt7bGFiZWw6ICdTb21lIExhYmVsJywgYmFkZ2U6IDF9XVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgT2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBpdGVtczogQXJyYXksXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbiB0aGUgbGlzdCBpdGVtcyBiZSBhY3RpdmF0ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBCb29sZWFuXG4gICAgICAgICAqL1xuICAgICAgICBhY3RpdmF0ZWFibGU6IHtcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbGlzdCBncm91cCBhcHBlYXIgZmx1c2ggKHdpdGhvdXQgc29tZSBib3JkZXJzKS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IEJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIGZsdXNoOiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FuIGFjdGl2YXRlIG11bHRpcGxlIGxpc3QgaXRlbXNcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IEJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIG11bHRpcGxlOiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIGNsYXNzZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJlZml4KHtcbiAgICAgICAgICAgICAgICAnZmx1c2gnOiB0aGlzLmZsdXNoXG4gICAgICAgICAgICB9LCAnbGlzdC1ncm91cCcpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1ldGhvZHM6IHtcblxuICAgICAgICBiaW5kRXZlbnRzVG9DaGlsZHJlbigpIHtcbiAgICAgICAgICAgIGVhY2godGhpcy4kY2hpbGRyZW4sIGNoaWxkID0+IHtcbiAgICAgICAgICAgICAgICBjaGlsZC4kb2ZmKCdjbGljaycsIHRoaXMub25DbGlja0NoaWxkKTtcbiAgICAgICAgICAgICAgICBjaGlsZC4kb24oJ2NsaWNrJywgdGhpcy5vbkNsaWNrQ2hpbGQpO1xuICAgICAgICAgICAgICAgIGNoaWxkLiRvZmYoJ2FjdGl2YXRlJywgdGhpcy5vbkFjdGl2YXRlKTtcbiAgICAgICAgICAgICAgICBjaGlsZC4kb24oJ2FjdGl2YXRlJywgdGhpcy5vbkFjdGl2YXRlKTtcbiAgICAgICAgICAgICAgICBjaGlsZC4kb2ZmKCdkZWFjdGl2YXRlJywgdGhpcy5vbkRlYWN0aXZhdGUpO1xuICAgICAgICAgICAgICAgIGNoaWxkLiRvbignZGVhY3RpdmF0ZScsIHRoaXMub25EZWFjdGl2YXRlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uQ2xpY2tDaGlsZChldmVudCwgY2hpbGQpIHtcbiAgICAgICAgICAgIGlmKHRoaXMuYWN0aXZhdGVhYmxlKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQudG9nZ2xlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2NsaWNrOmNoaWxkJywgZXZlbnQsIGNoaWxkKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbkFjdGl2YXRlKGl0ZW0pIHtcbiAgICAgICAgICAgIGlmKCF0aGlzLm11bHRpcGxlICYmIHRoaXMuYWN0aXZlSXRlbSAhPT0gaXRlbSkge1xuICAgICAgICAgICAgICAgIGlmKHRoaXMuYWN0aXZlSXRlbSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZUl0ZW0uZGVhY3RpdmF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlSXRlbSA9IGl0ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25EZWFjdGl2YXRlKGl0ZW0pIHtcbiAgICAgICAgICAgIGlmKCF0aGlzLm11bHRpcGxlICYmIHRoaXMuYWN0aXZlSXRlbSA9PT0gaXRlbSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlSXRlbSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFjdGl2ZUl0ZW06IG51bGxcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtb3VudGVkKCkge1xuICAgICAgICB0aGlzLmJpbmRFdmVudHNUb0NoaWxkcmVuKCk7XG4gICAgfSxcblxuICAgIHVwZGF0ZWQoKSB7XG4gICAgICAgIHRoaXMuYmluZEV2ZW50c1RvQ2hpbGRyZW4oKTtcbiAgICB9XG5cbn1cblxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgTGlzdEdyb3VwIGZyb20gJy4vTGlzdEdyb3VwJztcbmltcG9ydCBWdWVJbnN0YWxsZXIgZnJvbSAnQC9IZWxwZXJzL1Z1ZUluc3RhbGxlci9WdWVJbnN0YWxsZXInO1xuXG5jb25zdCBwbHVnaW4gPSBWdWVJbnN0YWxsZXIudXNlKHtcblxuICAgIGluc3RhbGwoVnVlLCBvcHRpb25zKSB7XG4gICAgICAgIFZ1ZUluc3RhbGxlci5jb21wb25lbnRzKHtcbiAgICAgICAgICAgIExpc3RHcm91cFxuICAgICAgICB9KTtcbiAgICB9XG5cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBMaXN0R3JvdXA7XG4iLCI8dGVtcGxhdGU+XG4gICAgPGRpdiBjbGFzcz1cIm92ZXJsYXlcIiA6Y2xhc3M9XCJ7J3Nob3cnOiB2aXNpYmxlfVwiIDpzdHlsZT1cIntiYWNrZ3JvdW5kOiBiYWNrZ3JvdW5kfVwiIEBrZXl1cC5lc2M9XCJoaWRlXCI+XG4gICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1saW5rIG92ZXJsYXktY2xvc2VcIiBAY2xpY2s9XCJvbkNsaWNrQ2xvc2VcIj5cbiAgICAgICAgICAgIDxpIGNsYXNzPVwiZmEgZmEtdGltZXMtY2lyY2xlXCI+PC9pPlxuICAgICAgICA8L2J1dHRvbj5cblxuICAgICAgICA8ZGl2IGNsYXNzPVwib3ZlcmxheS1jb250ZW50IGNvbnRhaW5lclwiPlxuICAgICAgICAgICAgPHNsb3QgLz5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAnb3ZlcmxheScsXG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgb3ZlcmxheSBiYWNrZ3JvdW5kIGNvbG9yLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBiYWNrZ3JvdW5kOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAncmdiYSgyNTUsIDI1NSwgMjU1LCAuOTI1KSdcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSXMgdGhlIG92ZXJsYXkgc2hvd2luZy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IEJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIHZpc2libGU6IHtcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgICBkZWZhdWx0OiB0cnVlXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICB3YXRjaDoge1xuICAgICAgICB2aXNpYmxlKHZhbHVlKSB7XG4gICAgICAgICAgICBpZih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtZXRob2RzOiB7XG5cbiAgICAgICAgZm9jdXMoKSB7XG4gICAgICAgICAgICBjb25zdCBlbCA9IHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3IoJy5mb3JtLWNvbnRyb2wsIGlucHV0LCBzZWxlY3QsIHRleHRhcmVhJyk7XG5cbiAgICAgICAgICAgIGlmKGVsKSB7XG4gICAgICAgICAgICAgICAgZWwuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvdyB0aGUgb3ZlcmxheVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgICAgICovXG4gICAgICAgIHNob3coKSB7XG4gICAgICAgICAgICB0aGlzLiRtb3VudChkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpKSk7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCdzaG93Jyk7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCd1cGRhdGU6dmlzaWJsZScsIHRydWUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIaWRlIHRoZSBvdmVybGF5XG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAgICAgKi9cbiAgICAgICAgaGlkZSgpIHtcbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2hpZGUnKTtcbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ3VwZGF0ZTp2aXNpYmxlJywgZmFsc2UpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY2FsbGJhY2sgZm9yIHRoZSBgY2xpY2tgIGV2ZW50IG9uIHRoZSBjbG9zZSBidXR0b24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAgICAgKi9cbiAgICAgICAgb25DbGlja0Nsb3NlKCkge1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgnY2xpY2s6Y2xvc2UnKTtcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgbW91bnRlZCgpIHtcbiAgICAgICAgaWYodGhpcy52aXNpYmxlKSB7XG4gICAgICAgICAgICB0aGlzLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwic2Nzc1wiPlxuQGltcG9ydCAnLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwL3Njc3MvYm9vdHN0cmFwLnNjc3MnO1xuXG4ub3ZlcmxheSB7XG4gICAgcG9zaXRpb246IGZpeGVkO1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgbWluLWhlaWdodDogMDtcbiAgICB0b3A6IDA7XG4gICAgbGVmdDogMDtcbiAgICB6LWluZGV4OiAtMTtcbiAgICBvcGFjaXR5OiAwO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogMTAwJTtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGFsaWduLWNvbnRlbnQ6IGNlbnRlcjtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIHRyYW5zaXRpb246IGFsbCAzMzNtcyBlYXNlLW91dDtcblxuICAgICYuc2hvdyB7XG4gICAgICAgIHotaW5kZXg6IDEwMDAwO1xuICAgICAgICBvcGFjaXR5OiAxMDA7XG4gICAgfVxuXG4gICAgLm92ZXJsYXktaGVhZGVyIHtcbiAgICAgICAgbWFyZ2luLXRvcDogJGZvbnQtc2l6ZS1iYXNlICogMS41O1xuICAgIH1cblxuICAgIC5vdmVybGF5LWNsb3NlIHtcbiAgICAgICAgZm9udC1zaXplOiAkZm9udC1zaXplLWJhc2UgKiAxLjI1O1xuICAgICAgICBjb2xvcjogJGdyYXktNzAwO1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogJGZvbnQtc2l6ZS1iYXNlO1xuICAgICAgICByaWdodDogJGZvbnQtc2l6ZS1iYXNlO1xuICAgICAgICB6LWluZGV4OiAxO1xuICAgIH1cblxuICAgIC5vdmVybGF5LWNvbnRlbnQge1xuICAgICAgICBvdmVyZmxvdy15OiBhdXRvO1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBtYXJnaW46IDAgYXV0bztcbiAgICAgICAgcGFkZGluZy1ib3R0b206ICRmb250LXNpemUtYmFzZSAqIDY7XG5cbiAgICAgICAgLm92ZXJsYXktY29udHJvbHMge1xuICAgICAgICAgICAgZmxvYXQ6IHJpZ2h0O1xuICAgICAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICAgICAgdG9wOiA0cHg7XG4gICAgICAgICAgICBwYWRkaW5nLXJpZ2h0OiAwO1xuICAgICAgICAgICAgcGFkZGluZy1ib3R0b206ICRmb250LXNpemUtYmFzZTtcblxuICAgICAgICAgICAgJi5sZWZ0IHtcbiAgICAgICAgICAgICAgICBsZWZ0OiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJi5yaWdodCB7XG4gICAgICAgICAgICAgICAgcmlnaHQ6IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICYgKyAqIHtcbiAgICAgICAgICAgICAgICBjbGVhcjogYm90aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbjwvc3R5bGU+XG4iLCJpbXBvcnQgT3ZlcmxheSBmcm9tICcuL092ZXJsYXknO1xuaW1wb3J0IFZ1ZUluc3RhbGxlciBmcm9tICdAL0hlbHBlcnMvVnVlSW5zdGFsbGVyL1Z1ZUluc3RhbGxlcic7XG5cbmNvbnN0IHBsdWdpbiA9IFZ1ZUluc3RhbGxlci51c2Uoe1xuXG4gICAgaW5zdGFsbChWdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgVnVlSW5zdGFsbGVyLmNvbXBvbmVudHMoe1xuICAgICAgICAgICAgT3ZlcmxheVxuICAgICAgICB9KTtcbiAgICB9XG5cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBPdmVybGF5O1xuIiwiPHRlbXBsYXRlPlxuICAgIDxuYXYgYXJpYS1sYWJlbD1cIlBhZ2UgbmF2aWdhdGlvbiBleGFtcGxlXCI+XG4gICAgICAgIDx1bCBjbGFzcz1cInBhZ2luYXRpb25cIiA6Y2xhc3M9XCJjbGFzc2VzXCI+XG4gICAgICAgIFx0PGxpIGNsYXNzPVwicGFnZS1pdGVtXCIgOmNsYXNzPVwieydkaXNhYmxlZCc6IGN1cnJlbnRQYWdlID09PSAxfVwiPlxuICAgICAgICBcdFx0PGEgaHJlZj1cIiNcIiBjbGFzcz1cInBhZ2UtbGlua1wiIGFyaWEtbGFiZWw9XCJQcmV2aW91c1wiIEBjbGljay5wcmV2ZW50PVwicHJldigkZXZlbnQpXCI+XG4gICAgICAgIFx0XHRcdDxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPiZsYXF1bzs8L3NwYW4+XG4gICAgICAgIFx0XHQ8L2E+XG4gICAgICAgIFx0PC9saT5cbiAgICAgICAgICAgIDxsaSB2LWZvcj1cIml0ZW0gaW4gcGFnZXNcIiA6ZGF0YS1wYWdlPVwiaXRlbS5wYWdlXCIgY2xhc3M9XCJwYWdlLWl0ZW1cIiA6Y2xhc3M9XCJ7J2FjdGl2ZSc6IGl0ZW0ucGFnZSA9PT0gY3VycmVudFBhZ2UsICdkaXNhYmxlZCc6ICEhaXRlbS5kaXZpZGVyfVwiPlxuICAgICAgICAgICAgICAgIDxzbG90IDppdGVtPVwiaXRlbVwiPlxuICAgICAgICAgICAgICAgICAgICA8YSB2LWlmPVwiaXRlbS5kaXZpZGVyXCIgY2xhc3M9XCJwYWdlLWxpbmtcIj4maGVsbGlwOzwvYT5cbiAgICAgICAgICAgICAgICBcdDxhIHYtZWxzZSBocmVmPVwiI1wiIGNsYXNzPVwicGFnZS1saW5rXCIgOmNsYXNzPVwiaXRlbS5jbGFzc1wiIDpkYXRhLWxhYmVsPVwiaXRlbS5sYWJlbFwiIEBjbGljay5wcmV2ZW50PVwicGFnaW5hdGUoaXRlbS5wYWdlLCAkZXZlbnQpXCI+XG4gICAgICAgICAgICAgICAgXHRcdDxzcGFuIHYtaWY9XCJpdGVtLmxhYmVsXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCIgdi1odG1sPVwiaXRlbS5sYWJlbFwiPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICBcdFx0PHNwYW4gdi1pZj1cIml0ZW0ucGFnZVwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIHYtaHRtbD1cIml0ZW0ucGFnZVwiPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICBcdDwvYT5cbiAgICAgICAgICAgICAgICA8L3Nsb3Q+XG4gICAgICAgICAgICA8L2xpPlxuICAgICAgICBcdDxsaSBjbGFzcz1cInBhZ2UtaXRlbVwiIDpjbGFzcz1cInsnZGlzYWJsZWQnOiBjdXJyZW50UGFnZSA+PSB0b3RhbFBhZ2VzfVwiPlxuICAgICAgICBcdFx0PGEgaHJlZj1cIiNcIiBjbGFzcz1cInBhZ2UtbGlua1wiIGFyaWEtbGFiZWw9XCJOZXh0XCIgQGNsaWNrLnByZXZlbnQ9XCJuZXh0KCRldmVudClcIj5cbiAgICAgICAgXHRcdFx0PHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCI+JnJhcXVvOzwvc3Bhbj5cbiAgICAgICAgXHRcdDwvYT5cbiAgICAgICAgICAgIDwvbGk+XG4gICAgICAgIDwvdWw+XG4gICAgPC9uYXY+XG5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAncGFnaW5hdGlvbicsXG5cbiAgICBwcm9wczoge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGFsaWdubWVudCBvZiB0aGUgcGFnaW5hdGlvbiBjb21wb25lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wIFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgYWxpZ246IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIHZhbGlkYXRlOiB2YWx1ZSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsnc3RhcnQnLCAnZW5kJywgJ2NlbnRlciddLmluZGV4T2YodmFsdWUpICE9PSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHBhZ2Ugb24gd2hpY2ggdGhlIHBhZ2luYXRvciBzaG91bGQgc3RhcnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wIFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgcGFnZToge1xuICAgICAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICAgICAgZGVmYXVsdDogMVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdG90YWwgbnVtYmVyIG9mIHBhZ2VzIGluIHRoZSBwYWdpbmF0b3IuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wIFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgdG90YWxQYWdlczoge1xuICAgICAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICAgICAgZGVmYXVsdDogMVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbnVtYmVyIG9mIHBhZ2VzIHRvIHNob3cgd2hlbiB0aGUgdG90YWwgbnVtYmVyIG9mIHBhZ2VzIGlzXG4gICAgICAgICAqIGdyZWF0ZXIgdGhhbiB0aGUgbnVtYmVyIG9mIHBhZ2VzIHRoYXQgc2hvdWxkIGJlIHNob3duLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcCBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHNob3dQYWdlczoge1xuICAgICAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICAgICAgZGVmYXVsdDogNlxuICAgICAgICB9LFxuXG4gICAgICAgIG9uUGFnaW5hdGU6IEZ1bmN0aW9uXG4gICAgfSxcblxuICAgIG1ldGhvZHM6IHtcblxuICAgICAgICBuZXh0KGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLnBhZ2luYXRlKHRoaXMuY3VycmVudFBhZ2UgPj0gdGhpcy50b3RhbFBhZ2VzID8gdGhpcy5jdXJyZW50UGFnZSA6IHRoaXMuY3VycmVudFBhZ2UgKyAxLCBldmVudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcHJldihldmVudCkge1xuICAgICAgICAgICAgdGhpcy5wYWdpbmF0ZSh0aGlzLmN1cnJlbnRQYWdlIDw9IDEgPyB0aGlzLmN1cnJlbnRQYWdlIDogdGhpcy5jdXJyZW50UGFnZSAtIDEsIGV2ZW50KTtcbiAgICAgICAgfSxcblxuICAgICAgICBwYWdpbmF0ZShwYWdlLCBldmVudCkge1xuICAgICAgICAgICAgaWYoZXZlbnQuY3VycmVudFRhcmdldC5wYXJlbnROb2RlLmNsYXNzTGlzdC5jb250YWlucygnZGlzYWJsZWQnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuXHRcdFx0dGhpcy5zZXRBY3RpdmVQYWdlKHBhZ2UpO1xuXG4gICAgICAgICAgICBpZih0aGlzLm9uUGFnaW5hdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uUGFnaW5hdGUocGFnZSwgZXZlbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLiRlbWl0KCdwYWdpbmF0ZScsIHBhZ2UsIGV2ZW50KTtcbiAgICAgICAgfSxcblxuXHRcdHNldEFjdGl2ZVBhZ2UocGFnZSkge1xuXHRcdFx0aWYodGhpcy5jdXJyZW50UGFnZSAhPT0gcGFnZSkge1xuXHRcdFx0XHR0aGlzLmN1cnJlbnRQYWdlID0gcGFnZTtcblx0XHRcdH1cblx0XHR9LFxuXG4gICAgICAgIGdlbmVyYXRlKCkge1xuICAgICAgICAgICAgY29uc3QgcGFnZXMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHNob3dQYWdlcyA9IHRoaXMuc2hvd1BhZ2VzICUgMiA/IHRoaXMuc2hvd1BhZ2VzICsgMTogdGhpcy5zaG93UGFnZXM7XG5cbiAgICAgICAgICAgIGxldCBzdGFydFBhZ2UgPSAodGhpcy5jdXJyZW50UGFnZSA+PSBzaG93UGFnZXMpID8gdGhpcy5jdXJyZW50UGFnZSAtIChzaG93UGFnZXMgLyAyKSA6IDE7XG4gICAgICAgICAgICBjb25zdCBzdGFydE9mZnNldCA9IHNob3dQYWdlcyArIHN0YXJ0UGFnZTtcbiAgICAgICAgICAgIGNvbnN0IGVuZFBhZ2UgPSAodGhpcy50b3RhbFBhZ2VzIDwgc3RhcnRPZmZzZXQpID8gdGhpcy50b3RhbFBhZ2VzIDogc3RhcnRPZmZzZXQ7XG4gICAgICAgICAgICBjb25zdCBkaWZmID0gc3RhcnRQYWdlIC0gZW5kUGFnZSArIHNob3dQYWdlcztcblxuICAgICAgICAgICAgc3RhcnRQYWdlIC09IChzdGFydFBhZ2UgLSBkaWZmID4gMCkgPyBkaWZmIDogMDtcblxuICAgICAgICAgICAgaWYgKHN0YXJ0UGFnZSA+IDEpIHtcbiAgICAgICAgICAgICAgICBwYWdlcy5wdXNoKHtwYWdlOiAxfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKHN0YXJ0UGFnZSA+IDIpIHtcbiAgICAgICAgICAgICAgICBwYWdlcy5wdXNoKHtkaXZpZGVyOiB0cnVlfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvcihsZXQgaSA9IHN0YXJ0UGFnZTsgaSA8IGVuZFBhZ2U7IGkrKykge1xuICAgICAgICAgICAgICAgIHBhZ2VzLnB1c2goe3BhZ2U6IGl9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGVuZFBhZ2UgPD0gdGhpcy50b3RhbFBhZ2VzKSB7XG4gICAgICAgICAgICAgICAgaWYodGhpcy50b3RhbFBhZ2VzIC0gMSA+IGVuZFBhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFnZXMucHVzaCh7ZGl2aWRlcjogdHJ1ZX0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHBhZ2VzLnB1c2goe3BhZ2U6IHRoaXMudG90YWxQYWdlc30pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcGFnZXM7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBjb21wdXRlZDoge1xuXG4gICAgICAgIHBhZ2VzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGUoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjbGFzc2VzKCkge1xuICAgICAgICAgICAgY29uc3QgY2xhc3NlcyA9IHt9O1xuXG4gICAgICAgICAgICBjbGFzc2VzWydqdXN0aWZ5LWNvbnRlbnQtJyArIHRoaXMuYWxpZ25dID0gdHJ1ZTtcblxuICAgICAgICAgICAgcmV0dXJuIGNsYXNzZXM7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBkYXRhKCkge1xuICAgICAgICByZXR1cm4gIHtcbiAgICAgICAgICAgIGN1cnJlbnRQYWdlOiB0aGlzLnBhZ2VcbiAgICAgICAgfTtcbiAgICB9XG5cbn07XG48L3NjcmlwdD5cbiIsImltcG9ydCBQYWdpbmF0aW9uIGZyb20gJy4vUGFnaW5hdGlvbic7XG5pbXBvcnQgVnVlSW5zdGFsbGVyIGZyb20gJ0AvSGVscGVycy9WdWVJbnN0YWxsZXIvVnVlSW5zdGFsbGVyJztcblxuY29uc3QgcGx1Z2luID0gVnVlSW5zdGFsbGVyLnVzZSh7XG5cbiAgICBpbnN0YWxsKFZ1ZSwgb3B0aW9ucykge1xuICAgICAgICBWdWVJbnN0YWxsZXIuY29tcG9uZW50cyh7XG4gICAgICAgICAgICBQYWdpbmF0aW9uXG4gICAgICAgIH0pO1xuICAgIH1cblxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IFBhZ2luYXRpb247XG4iLCJpbXBvcnQgUHJvZ3Jlc3NCYXIgZnJvbSAnLi9Qcm9ncmVzc0Jhcic7XG5pbXBvcnQgVnVlSW5zdGFsbGVyIGZyb20gJ0AvSGVscGVycy9WdWVJbnN0YWxsZXIvVnVlSW5zdGFsbGVyJztcblxuY29uc3QgcGx1Z2luID0gVnVlSW5zdGFsbGVyLnVzZSh7XG5cbiAgICBpbnN0YWxsKFZ1ZSwgb3B0aW9ucykge1xuICAgICAgICBWdWVJbnN0YWxsZXIuY29tcG9uZW50cyh7XG4gICAgICAgICAgICBQcm9ncmVzc0JhclxuICAgICAgICB9KTtcbiAgICB9XG5cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBQcm9ncmVzc0JhcjtcbiIsImltcG9ydCBSYWRpb0ZpZWxkIGZyb20gJy4vUmFkaW9GaWVsZCc7XG5pbXBvcnQgVnVlSW5zdGFsbGVyIGZyb20gJ0AvSGVscGVycy9WdWVJbnN0YWxsZXIvVnVlSW5zdGFsbGVyJztcblxuY29uc3QgcGx1Z2luID0gVnVlSW5zdGFsbGVyLnVzZSh7XG5cbiAgICBpbnN0YWxsKFZ1ZSwgb3B0aW9ucykge1xuICAgICAgICBWdWVJbnN0YWxsZXIuY29tcG9uZW50cyh7XG4gICAgICAgICAgICBSYWRpb0ZpZWxkXG4gICAgICAgIH0pO1xuICAgIH1cblxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IFJhZGlvRmllbGQ7XG4iLCI8dGVtcGxhdGU+XG5cbiAgICA8Zm9ybS1ncm91cD5cblxuICAgICAgICA8c2xvdCBuYW1lPVwibGFiZWxcIj5cbiAgICAgICAgICAgIDxmb3JtLWxhYmVsIHYtaWY9XCJsYWJlbFwiIDpmb3I9XCJpZFwiIHYtaHRtbD1cImxhYmVsXCIgLz5cbiAgICAgICAgPC9zbG90PlxuXG4gICAgICAgIDxzbG90IG5hbWU9XCJjb250cm9sXCI+XG4gICAgICAgICAgICA8c2VsZWN0XG4gICAgICAgICAgICAgICAgOmlkPVwiaWRcIlxuICAgICAgICAgICAgICAgIDp2YWx1ZT1cInZhbHVlXCJcbiAgICAgICAgICAgICAgICA6cmVxdWlyZWQ9XCJyZXF1aXJlZFwiXG4gICAgICAgICAgICAgICAgOmRpc2FibGVkPVwiZGlzYWJsZWQgfHwgcmVhZG9ubHlcIlxuICAgICAgICAgICAgICAgIDpyZWFkb25seT1cInJlYWRvbmx5XCJcbiAgICAgICAgICAgICAgICA6cGF0dGVybj1cInBhdHRlcm5cIlxuICAgICAgICAgICAgICAgIDpjbGFzcz1cIm1lcmdlQ2xhc3Nlcyhjb250cm9sQ2xhc3NlcywgY29sb3JhYmxlQ2xhc3NlcylcIlxuICAgICAgICAgICAgICAgIHYtb246aW5wdXQ9XCJ1cGRhdGVkKCRldmVudC50YXJnZXQudmFsdWUpXCI+XG4gICAgICAgICAgICAgICAgPHNsb3QgLz5cbiAgICAgICAgICAgIDwvc2VsZWN0PlxuICAgICAgICA8L3Nsb3Q+XG5cbiAgICAgICAgPHNsb3QgbmFtZT1cImhlbHBcIj5cbiAgICAgICAgICAgIDxoZWxwLXRleHQgdi1pZj1cImhlbHBUZXh0XCIgdi1odG1sPVwiaGVscFRleHRcIiAvPlxuICAgICAgICA8L3Nsb3Q+XG5cbiAgICAgICAgPHNsb3QgbmFtZT1cImZlZWRiYWNrXCI+XG4gICAgICAgICAgICA8Zm9ybS1mZWVkYmFjayB2LWlmPVwidmFsaWRGZWVkYmFja1wiIHYtaHRtbD1cInZhbGlkRmVlZGJhY2tcIiB2YWxpZCAvPlxuICAgICAgICAgICAgPGZvcm0tZmVlZGJhY2sgdi1pZj1cImludmFsaWRGZWVkYmFja1wiIHYtaHRtbD1cImludmFsaWRGZWVkYmFja1wiIGludmFsaWQgLz5cbiAgICAgICAgPC9zbG90PlxuXG4gICAgPC9mb3JtLWdyb3VwPlxuXG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuXG4vL2ltcG9ydCBCYXNlRmllbGQgZnJvbSAnLi9CYXNlRmllbGQnO1xuaW1wb3J0IENvbG9yYWJsZSBmcm9tICdAL01peGlucy9Db2xvcmFibGUvQ29sb3JhYmxlJztcbmltcG9ydCBGb3JtQ29udHJvbCBmcm9tICdAL01peGlucy9Gb3JtQ29udHJvbC9Gb3JtQ29udHJvbCc7XG5cbmNvbnN0IENVU1RPTV9TRUxFQ1RfUFJFRklYID0gJ2N1c3RvbS1zZWxlY3QtJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAnc2VsZWN0LWZpZWxkJyxcblxuICAgIGV4dGVuZHM6IEZvcm1Db250cm9sLFxuXG4gICAgbWl4aW5zOiBbXG4gICAgICAgIEZvcm1Db250cm9sLFxuICAgICAgICBDb2xvcmFibGVcbiAgICBdLFxuXG4gICAgcHJvcHM6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkIGBjdXN0b20tc2VsZWN0YCB0byB0aGUgZm9ybSBjb250cm9sIGlmIHRydWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGN1c3RvbToge1xuICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBjb21wdXRlZDoge1xuXG4gICAgICAgIGNvbnRyb2xDbGFzcygpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRyb2xDbGFzcyA9IHRoaXMuY3VzdG9tID8gJ2N1c3RvbS1zZWxlY3QnIDogdGhpcy5kZWZhdWx0Q29udHJvbENsYXNzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGxhaW50ZXh0ID8gYCR7Y29udHJvbENsYXNzfS1wbGFpbnRleHRgIDogY29udHJvbENsYXNzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGN1c3RvbVNlbGVjdENsYXNzZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIENVU1RPTV9TRUxFQ1RfUFJFRklYLnJlcGxhY2UoL1xcLSQvLCAnJykgKyAodGhpcy5wbGFpbnRleHQgPyAnLXBsYWludGV4dCcgOiAnJyksXG4gICAgICAgICAgICAgICAgdGhpcy5jdXN0b21TZWxlY3RTaXplQ2xhc3MsXG4gICAgICAgICAgICAgICAgKHRoaXMuc3BhY2luZyB8fCAnJylcbiAgICAgICAgICAgIF0uam9pbignICcpO1xuICAgICAgICB9XG4gICAgfVxuXG59XG48L3NjcmlwdD5cbiIsImltcG9ydCBTZWxlY3RGaWVsZCBmcm9tICcuL1NlbGVjdEZpZWxkJztcbmltcG9ydCBWdWVJbnN0YWxsZXIgZnJvbSAnQC9IZWxwZXJzL1Z1ZUluc3RhbGxlci9WdWVJbnN0YWxsZXInO1xuXG5jb25zdCBwbHVnaW4gPSBWdWVJbnN0YWxsZXIudXNlKHtcblxuICAgIGluc3RhbGwoVnVlLCBvcHRpb25zKSB7XG4gICAgICAgIFZ1ZUluc3RhbGxlci5jb21wb25lbnRzKHtcbiAgICAgICAgICAgIFNlbGVjdEZpZWxkXG4gICAgICAgIH0pO1xuICAgIH1cblxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IFNlbGVjdEZpZWxkO1xuIiwiaW1wb3J0IHsgZWFjaCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBpc0FycmF5IH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IGlzT2JqZWN0IH0gZnJvbSAnbG9kYXNoJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVHJhbnNmb3JtZXIge1xuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0aGUgdHJhbnNmb3JtZXIgaW5zdGFuY2UgdXNpbmcgYW4gSFRUUCByZXNwb25zZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGF0YSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihyZXNwb25zZSkge1xuICAgICAgICBpZighaXNPYmplY3QodGhpcy4kb3JpZ2luYWxSZXNwb25zZSA9IHJlc3BvbnNlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgdHJhbnNmb3JtZXIgbXVzdCBiZSBpbnN0YW50aWF0ZWQgd2l0aCBhIHJlc3BvbnNlIG9iamVjdC4nKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYoIWlzQXJyYXkodGhpcy4kcmVxdWlyZWQgPSB0aGlzLnJlcXVpcmVkKCkpIHx8ICF0aGlzLiRyZXF1aXJlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQSB0cmFuc2Zvcm1lciBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIHJlcXVpcmVkIHByb3BlcnR5LicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy4kdHJhbnNmb3JtZWRSZXNwb25zZSA9IHRoaXMudHJhbnNmb3JtKHJlc3BvbnNlKTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZSgpO1xuICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIG1ldGhvZCB0byBvdmVycmlkZSB0byBwZXJmb3JtIGxvZ2ljIHRvIGZpbmlzaGVkIGluaXRpYWxpemluZy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAqL1xuICAgIGluaXRpYWxpemUoKSB7XG4gICAgICAgIC8vXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVmaW5lIGFuIGFycmF5IG9mIHJlcXVpcmVkIHByb3BlcnRpZSB3aXRoIGF0IGxlYXN0IG9uZSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAqL1xuICAgIHJlcXVpcmVkKCkge1xuICAgICAgICAvL1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyYW5mb3JtIHRoZSByZXNwb25zZSBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgKi9cbiAgICB0cmFuc2Zvcm0ocmVzcG9uc2UpIHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdHJhbmZvcm1lZCByZXNwb25zZVxuICAgICAqXG4gICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAqL1xuICAgIHJlc3BvbnNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kdHJhbnNmb3JtZWRSZXNwb25zZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZSB0aGUgdHJhbmZvcm1lZCByZXNwb25zZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAqL1xuICAgIHZhbGlkYXRlKCkge1xuICAgICAgICBpZighaXNPYmplY3QodGhpcy4kdHJhbnNmb3JtZWRSZXNwb25zZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHRyYW5zZm9ybWVkIHJlc3BvbnNlIG11c3QgYmUgYW4gb2JqZWN0LicpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWFjaCh0aGlzLiRyZXF1aXJlZCwga2V5ID0+IHtcbiAgICAgICAgICAgIGlmKCEoa2V5IGluIHRoaXMuJHRyYW5zZm9ybWVkUmVzcG9uc2UpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7a2V5fVwiIGlzIGEgcmVxdWlyZWQgcHJvcGVydHkgYW5kIGRvZXMgbm90IGV4aXN0IGluIHRoZSB0cmFuZm9ybWVkIHJlc3BvbnNlLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbn1cbiIsImltcG9ydCB7IGVhY2ggfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgaXNBcnJheSB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBpc09iamVjdCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgVHJhbnNmb3JtZXIgZnJvbSAnLi4vVHJhbnNmb3JtZXInO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUYWJsZVZpZXdUcmFuc2Zvcm1lciBleHRlbmRzIFRyYW5zZm9ybWVyIHtcblxuICAgIHJlcXVpcmVkKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgLy8gVGhlIGVuZCBvZiB0aGUgY291bnQgb2YgdGhlIHBhZ2luYXRlZCBsaXN0LlxuICAgICAgICAgICAgJ3RvJyxcblxuICAgICAgICAgICAgLy8gVGhlIHN0YXJ0IG9mIHRoZSBjb3VudCBvZiB0aGUgcGFnaW5hdGVkIGxpc3QuXG4gICAgICAgICAgICAnZnJvbScsXG5cbiAgICAgICAgICAgIC8vIFRoZSB0b3RhbCBudW1iZXIgb2YgaXRlbXMgKG5vdCBqdXN0IGluY2x1ZGVkIGluIHRoZSBwYWdpbmF0aW9uKVxuICAgICAgICAgICAgJ3RvdGFsJyxcblxuICAgICAgICAgICAgLy8gVGhlIG51bWJlciBvZiBpdGVtcyBwZXIgcGFnZVxuICAgICAgICAgICAgJ3Blcl9wYWdlJyxcblxuICAgICAgICAgICAgLy8gVGhlIGxhc3QgcGFnZSBudW1iZXIgKG9yIHRvdGFsIHBhZ2VzKVxuICAgICAgICAgICAgJ2xhc3RfcGFnZScsXG5cbiAgICAgICAgICAgIC8vIFRoZSBjdXJyZW50IHBhZ2UgbnVtYmVyXG4gICAgICAgICAgICAnY3VycmVudF9wYWdlJyxcblxuICAgICAgICAgICAgLy8gVGhlIGFjdHVhbCByZXNwb25zZSBkYXRhIHRvIGFwcGVhciBpbiB0aGUgdGFibGVcbiAgICAgICAgICAgICdkYXRhJ1xuICAgICAgICBdO1xuICAgIH1cblxuICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiR0cmFuc2Zvcm1lZFJlc3BvbnNlLmRhdGE7XG4gICAgfVxuXG4gICAgaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgaWYoIWlzQXJyYXkodGhpcy5kYXRhKCkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBkYXRhIHByb3BlcnR5IG11c3QgYmUgYW4gYXJyYXkuJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbn1cbiIsIjx0ZW1wbGF0ZT5cblxuICAgIDxkaXYgY2xhc3M9XCJ0YWJsZS12aWV3XCI+XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cImQtZmxleCBqdXN0aWZ5LWNvbnRlbnQtYmV0d2VlbiBhbGlnbi1pdGVtcy1jZW50ZXJcIj5cbiAgICAgICAgICAgIDxzbG90IG5hbWU9XCJoZWFkZXJcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidGFibGUtdmlldy1oZWFkZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgPHNsb3QgbmFtZT1cImhlYWRpbmdcIj48aDMgdi1pZj1cImhlYWRpbmdcIiB2LWh0bWw9XCJoZWFkaW5nXCI+PC9oMz48L3Nsb3Q+XG4gICAgICAgICAgICAgICAgICAgIDxzbG90IG5hbWU9XCJkZXNjcmlwdGlvblwiPjxwIHYtaWY9XCJkZXNjcmlwdGlvblwiIHYtaHRtbD1cImRlc2NyaXB0aW9uXCI+PC9wPjwvc2xvdD5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvc2xvdD5cblxuICAgICAgICAgICAgPHNsb3QgbmFtZT1cImJ1dHRvbnNcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IHYtaWY9XCJidXR0b25zLmxlbmd0aFwiIGNsYXNzPVwiYnV0dG9ucy13cmFwcGVyIG15LTNcIj5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4+XG4gICAgICAgICAgICAgICAgXHRcdDxhIHYtZm9yPVwiKGJ1dHRvbiwga2V5KSBpbiBidXR0b25zXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6aHJlZj1cImJ1dHRvbi5ocmVmIHx8ICcjJ1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOmNsYXNzPVwiYnV0dG9uLmNsYXNzTmFtZSB8fCAnYnRuIGJ0bi1wcmltYXJ5J1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQGNsaWNrPVwicHJveHkoYnV0dG9uLm9uQ2xpY2ssICRldmVudClcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aSB2LWlmPVwiYnV0dG9uLmljb25cIiA6Y2xhc3M9XCJidXR0b24uaWNvblwiPjwvaT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiB2LWh0bWw9XCJidXR0b24ubGFiZWxcIj48L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2E+XG4gICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvc2xvdD5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPHRhYmxlIGNsYXNzPVwidGFibGVcIiA6Y2xhc3M9XCJ7J3RhYmxlLWhvdmVyJzogIWxvYWRpbmd9XCI+XG5cbiAgICAgICAgICAgIDxzbG90IG5hbWU9XCJ0aGVhZFwiPlxuICAgICAgICAgICAgXHQ8dGhlYWQ+XG4gICAgICAgICAgICBcdFx0PHRyPlxuICAgICAgICAgICAgXHRcdFx0PHRoIHNjb3BlPVwiY29sXCIgOndpZHRoPVwiY29sdW1uLndpZHRoXCIgdi1mb3I9XCJjb2x1bW4gaW4gdGFibGVDb2x1bW5zXCI+XG4gICAgICAgICAgICBcdFx0XHQgICAgPGRpdiB2LWlmPVwiY29sdW1uLmlkXCI+XG4gICAgICAgICAgICBcdFx0XHRcdFx0PGEgaHJlZj1cIiNcIiBjbGFzcz1cInNvcnRcIiA6ZGF0YS1pZD1cImNvbHVtbi5pZFwiIEBjbGljay5wcmV2ZW50PVwib3JkZXJCeShjb2x1bW4uaWQpXCIgdi1odG1sPVwiY29sdW1uLm5hbWUgfHwgY29sdW1uLmlkXCI+PC9hPlxuICAgICAgICAgICAgXHRcdFx0XHRcdDxpIHYtaWY9XCJyZXF1ZXN0LnBhcmFtcy5vcmRlciA9PT0gY29sdW1uLmlkICYmIHJlcXVlc3QucGFyYW1zLnNvcnQgPT09ICdhc2MnXCIgY2xhc3M9XCJzb3J0LWljb24gZmEgZmEtc29ydC1hc2NcIj48L2k+XG4gICAgICAgICAgICBcdFx0XHRcdFx0PGkgdi1pZj1cInJlcXVlc3QucGFyYW1zLm9yZGVyID09PSBjb2x1bW4uaWQgJiYgcmVxdWVzdC5wYXJhbXMuc29ydCA9PT0gJ2Rlc2MnXCIgY2xhc3M9XCJzb3J0LWljb24gZmEgZmEtc29ydC1kZXNjXCI+PC9pPlxuICAgICAgICAgICAgXHRcdFx0XHQ8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IHYtZWxzZSB2LWh0bWw9XCJjb2x1bW4ubmFtZVwiPjwvZGl2PlxuICAgICAgICAgICAgXHRcdFx0PC90aD5cbiAgICAgICAgICAgIFx0XHQ8L3RyPlxuICAgICAgICAgICAgXHQ8L3RoZWFkPlxuICAgICAgICAgICAgPC9zbG90PlxuXG4gICAgICAgICAgICA8c2xvdCBuYW1lPVwidGJvZHlcIj5cbiAgICAgICAgICAgICAgICA8dGJvZHk+XG4gICAgICAgICAgICAgICAgICAgIDx0ciB2LWlmPVwibG9hZGluZ1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHRkIDpjb2xzcGFuPVwidGFibGVDb2x1bW5zLmxlbmd0aFwiIGNsYXNzPVwicG9zaXRpb24tcmVsYXRpdmVcIiA6c3R5bGU9XCJ7J2hlaWdodCc6IGhlaWdodChtaW5IZWlnaHQpfVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhY3Rpdml0eS1pbmRpY2F0b3IgOmNlbnRlcj1cInRydWVcIj48L2FjdGl2aXR5LWluZGljYXRvcj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICAgICAgICAgIDwvdHI+XG5cbiAgICAgICAgICAgICAgICAgICAgPHNsb3Qgdi1lbHNlIDpkYXRhPVwiZGF0YVwiIDpjb2x1bW5zPVwidGFibGVDb2x1bW5zXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dHIgdi1mb3I9XCIocm93LCBpKSBpbiBkYXRhXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIHYtZm9yPVwiY29sdW1uIGluIHRhYmxlQ29sdW1uc1wiIHYtaHRtbD1cInJvd1tjb2x1bW4uaWRdIHx8IHJvd1tjb2x1bW4ubmFtZV1cIj48L3RkPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cbiAgICAgICAgICAgICAgICAgICAgPC9zbG90PlxuICAgICAgICAgICAgICAgIDwvdGJvZHk+XG4gICAgICAgICAgICA8L3Nsb3Q+XG5cbiAgICAgICAgICAgIDxzbG90IG5hbWU9XCJ0Zm9vdFwiPlxuICAgICAgICAgICAgXHQ8dGZvb3Q+XG4gICAgICAgICAgICBcdFx0PHRkIDpjb2xzcGFuPVwidGFibGVDb2x1bW5zLmxlbmd0aFwiIGNsYXNzPVwidGFibGUtdmlldy1mb290ZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzbG90IG5hbWU9XCJwYWdpbmF0aW9uXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHBhZ2luYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdi1pZj1cInBhZ2luYXRlICYmIHJlc3BvbnNlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ249XCJjZW50ZXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6cGFnZT1cInJlc3BvbnNlLmN1cnJlbnRfcGFnZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDp0b3RhbC1wYWdlcz1cInJlc3BvbnNlLmxhc3RfcGFnZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDpvbi1wYWdpbmF0ZT1cIm9uUGFnaW5hdGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L3Nsb3Q+XG4gICAgICAgICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICBcdDwvdGZvb3Q+XG4gICAgICAgICAgICA8L3Nsb3Q+XG5cbiAgICAgICAgPC90YWJsZT5cblxuICAgIDwvZGl2PlxuXG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IHsga2V5cyB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBlYWNoIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IGV4dGVuZCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBpc09iamVjdCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgUGFnaW5hdGlvbiBmcm9tICcuLi9QYWdpbmF0aW9uJztcbmltcG9ydCBBY3Rpdml0eUluZGljYXRvciBmcm9tICcuLi9BY3Rpdml0eUluZGljYXRvcic7XG5pbXBvcnQgUHJveHkgZnJvbSAnQC9NaXhpbnMvUHJveHkvUHJveHknO1xuaW1wb3J0IFJlcXVlc3QgZnJvbSAnQC9IdHRwL1JlcXVlc3QvUmVxdWVzdCc7XG5pbXBvcnQgVGFibGVWaWV3VHJhbnNmb3JtZXIgZnJvbSAnQC9IdHRwL1RhYmxlVmlld1RyYW5zZm9ybWVyL1RhYmxlVmlld1RyYW5zZm9ybWVyJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIG5hbWU6ICd0YWJsZS12aWV3JyxcblxuICAgIG1peGluczogW1Byb3h5XSxcblxuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgICAgUGFnaW5hdGlvbixcbiAgICAgICAgQWN0aXZpdHlJbmRpY2F0b3JcbiAgICB9LFxuXG4gICAgcHJvcHM6IHtcbiAgICAgICAgLy8gKHN0cmluZykgQSByZWxhdGl2ZSBvciBhYnNvbHV0ZSBlbmRwb2ludCBVUkwgdXNlZCB0byBmZXRjaCBkYXRhXG4gICAgICAgIHVybDoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICAvLyAoaW50ZWdlcikgVGhlIHN0YXJ0aW5nIHBhZ2Ugb2YgdGhlIHRhYmxlXG4gICAgICAgIHBhZ2U6IHtcbiAgICAgICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgICAgIGRlZmF1bHQ6IDFcbiAgICAgICAgfSxcblxuICAgICAgICAvLyAoaW50ZWdlcikgVGhlIHRvdGFsIG51bWJlciBvZiByZXN1bHRzIHBlciBwYWdlXG4gICAgICAgIGxpbWl0OiB7XG4gICAgICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgICAgICBkZWZhdWx0OiAyMFxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIChzdHJpbmcpIFRoZSBjb2x1bW4gdXNlZCB0byBvcmRlciB0aGUgZGF0YVxuICAgICAgICBvcmRlcjogU3RyaW5nLFxuXG4gICAgICAgIC8vIChzdHJpbmcpIFRoZSBzb3J0IGRpcmVjdGlvbiAoYXNjfGRlc2MpXG4gICAgICAgIHNvcnQ6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIHZhbGlkYXRlOiAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWydhc2MnLCAnZGVzYyddLmluZGV4T2YodmFsdWUpICE9PSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyAoaW50ZWdlcikgVGhlIG1pbmltdW0gaGVpZ2h0IG9mIHRoZSByb3cgd2hlbiBsb2FkaW5nIGRhdGFcbiAgICAgICAgbWluSGVpZ2h0OiB7XG4gICAgICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgICAgICBkZWZhdWx0OiA0MDBcbiAgICAgICAgfSxcblxuICAgICAgICAvLyAoYXJyYXkpIEFuIGFycmF5IG9mIGJ1dHRvbiBvYmplY3RzXG4gICAgICAgIC8vIFt7aHJlZjogJ3Rlc3QtMTIzJywgbGFiZWw6ICdUZXN0IDEyMyd9XVxuICAgICAgICBidXR0b25zOiB7XG4gICAgICAgICAgICB0eXBlOiBBcnJheSxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICgpID0+IHsgcmV0dXJuIFtdOyB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gKGFycmF5KSBBbiBhcnJheSBvZiB0YWJsZSBjb2x1bW5cbiAgICAgICAgLy8gW3tpZDogJ2RhdGFiYXNlX2lkJywgbmFtZTogJ0RhdGFiYXNlIGlkJywgd2lkdGg6ICcyMCUnfV1cbiAgICAgICAgY29sdW1uczoge1xuICAgICAgICAgICAgdHlwZTogQXJyYXksXG4gICAgICAgICAgICBkZWZhdWx0OiAoKSA9PiB7IHJldHVybiBbXTsgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIChzdHJpbmcpIFRoZSB0YWJsZSBoZWFkaW5nXG4gICAgICAgIGhlYWRpbmc6IFN0cmluZyxcblxuICAgICAgICAvLyAoc3RyaW5nKSBUaGUgdGFibGUgZGVzY3JpcHRpb25cbiAgICAgICAgZGVzY3JpcHRpb246IFN0cmluZyxcblxuICAgICAgICAvLyAoYm9vbCkgU2hvdWxkIHNob3cgdGhlIHBhZ2luYXRpb24gZm9yIHRoaXMgdGFibGVcbiAgICAgICAgcGFnaW5hdGU6IHtcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgICBkZWZhdWx0OiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gKG9iamVjdCkgVGhlIEhUVFAgcmVzcG9uc2UgdHJhbnNmb3JtZXIgaW5zdGFuY2VcbiAgICAgICAgdHJhbnNmb3JtZXI6IHtcbiAgICAgICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgICAgIHZhbGlkYXRlOiAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBUYWJsZVZpZXdUcmFuc2Zvcm1lcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBjb21wdXRlZDoge1xuICAgICAgICB0YWJsZUNvbHVtbnMoKSB7XG4gICAgICAgICAgICBsZXQgY29sdW1ucyA9IHRoaXMuY29sdW1ucztcblxuICAgICAgICAgICAgaWYoIWNvbHVtbnMgfHwgIWNvbHVtbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29sdW1ucyA9IGtleXModGhpcy5kYXRhWzBdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNvbHVtbnMubWFwKGNvbHVtbiA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzT2JqZWN0KGNvbHVtbikgPyBjb2x1bW4gOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGNvbHVtblxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtZXRob2RzOiB7XG5cbiAgICAgICAgb3JkZXJCeShvcmRlcikge1xuICAgICAgICAgICAgY29uc3QgZGVmYXVsdFNvcnQgPSAnZGVzYyc7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50U29ydCA9IHRoaXMuZ2V0UmVxdWVzdFBhcmFtKCdzb3J0Jyk7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50T3JkZXIgPSB0aGlzLmdldFJlcXVlc3RQYXJhbSgnb3JkZXInKTtcblxuICAgICAgICAgICAgdGhpcy5hZGRSZXF1ZXN0UGFyYW0oJ29yZGVyJywgb3JkZXIpO1xuICAgICAgICAgICAgdGhpcy5hZGRSZXF1ZXN0UGFyYW0oJ3NvcnQnLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRPcmRlciAhPT0gb3JkZXIgfHwgIWN1cnJlbnRTb3J0ID8gZGVmYXVsdFNvcnQgOiAoXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTb3J0ID09PSBkZWZhdWx0U29ydCA/ICdhc2MnIDogbnVsbFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHRoaXMuZmV0Y2goKTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRSZXF1ZXN0SGVhZGVyKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QuaGVhZGVyc1trZXldIHx8IHZhbHVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkUmVxdWVzdEhlYWRlcihrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICBpZighdGhpcy5yZXF1ZXN0LmhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3QuaGVhZGVycyA9IHt9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnJlcXVlc3QuaGVhZGVyc1trZXldID0gdmFsdWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0UmVxdWVzdFBhcmFtKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QucGFyYW1zW2tleV0gfHwgdmFsdWVcbiAgICAgICAgfSxcblxuICAgICAgICBhZGRSZXF1ZXN0UGFyYW0oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYoIXRoaXMucmVxdWVzdC5wYXJhbXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3QucGFyYW1zID0ge307XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucmVxdWVzdC5wYXJhbXNba2V5XSA9IHZhbHVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZldGNoKCkge1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KHRoaXMudXJsLCB0aGlzLnJlcXVlc3QpO1xuXG4gICAgICAgICAgICB0aGlzLmxvYWRpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVxdWVzdC5nZXQoKS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1lciA9IHRoaXMudHJhbnNmb3JtZXIgfHwgbmV3IFRhYmxlVmlld1RyYW5zZm9ybWVyKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3BvbnNlID0gdHJhbnNmb3JtZXIucmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEgPSB0cmFuc2Zvcm1lci5kYXRhKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9LCBlcnJvcnMgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGVpZ2h0KG1pbikge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudHMgPSBbXG4gICAgICAgICAgICAgICAgLy8gdGhpcy4kZWwucXVlcnlTZWxlY3RvcigndGhlYWQnKSxcbiAgICAgICAgICAgICAgICB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yKCd0Ym9keScpXG4gICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICBsZXQgaGVpZ2h0ID0gMDtcblxuICAgICAgICAgICAgZWFjaChlbGVtZW50cywgZWwgPT4ge1xuICAgICAgICAgICAgICAgIGhlaWdodCArPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KG1pbiwgaGVpZ2h0KSArICdweCc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25QYWdpbmF0ZShwYWdlLCBldmVudCkge1xuICAgICAgICAgICAgaWYoIXRoaXMucmVxdWVzdC5wYXJhbXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3QucGFyYW1zID0ge307XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucmVxdWVzdC5wYXJhbXMucGFnZSA9IHBhZ2U7XG4gICAgICAgICAgICB0aGlzLmZldGNoKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC8vIChhcnJheSkgVGhlIGRhdGFzZXQgZm9yIHRoZSB0YWJsZVxuICAgICAgICAgICAgZGF0YTogdGhpcy4kYXR0cnMuZGF0YSB8fCBbXSxcblxuICAgICAgICAgICAgLy8gKGJvb2wpIElzIHRoZSB0YWJsZSBjdXJyZW50bHkgbG9hZGluZyBkYXRhXG4gICAgICAgICAgICBsb2FkaW5nOiBmYWxzZSxcblxuICAgICAgICAgICAgLy8gKG51bGx8b2JqZWN0KSBUaGUgcmVzcG9uc2Ugb2JqZWN0XG4gICAgICAgICAgICByZXNwb25zZTogbnVsbCxcblxuICAgICAgICAgICAgLy8gKG9iamVjdCkgVGhlIEhUVFAgcmVxdWVzdCBvYmplY3RcbiAgICAgICAgICAgIHJlcXVlc3Q6IGV4dGVuZCh7XG4gICAgICAgICAgICAgICAgaGVhZGVyczoge30sXG4gICAgICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgICAgIHBhZ2U6IHRoaXMucGFnZSxcbiAgICAgICAgICAgICAgICAgICAgbGltaXQ6IHRoaXMubGltaXQsXG4gICAgICAgICAgICAgICAgICAgIG9yZGVyOiB0aGlzLm9yZGVyLFxuICAgICAgICAgICAgICAgICAgICBzb3J0OiB0aGlzLnNvcnRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzLiRhdHRycy5yZXF1ZXN0KVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBtb3VudGVkKCkge1xuICAgICAgICB0aGlzLmZldGNoKCk7XG4gICAgfSxcblxuICAgIC8qXG4gICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIGV4dGVuZCh7XG4gICAgICAgICAgICBidXR0b25zOiBbXSxcblxuICAgICAgICAgICAgY29sdW1uczogW10sXG5cbiAgICAgICAgICAgIGhlYWRlcjogZmFsc2UsXG5cbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBmYWxzZSxcblxuICAgICAgICAgICAgLy8gKGJvb2wpIFNob3VsZCBzaG93IHRoZSBwYWdpbmF0aW9uIGZvciB0aGlzIHRhYmxlXG4gICAgICAgICAgICBwYWdpbmF0ZTogdHJ1ZSxcblxuICAgICAgICAgICAgLy8gKGJvb2wpIElzIHRoZSB0YWJsZSBjdXJyZW50bHkgbG9hZGluZyBkYXRhXG4gICAgICAgICAgICBsb2FkaW5nOiBmYWxzZSxcblxuICAgICAgICAgICAgLy8gKG9iamVjdCkgQW4gb2JqZWN0IHdpdGgga2V5L3ZhbHVlIHBhaXJzIGZvciBjb21wb25lbnRzIHVzZWQgaW4gdGhlIHRlbXBsYXRlXG4gICAgICAgICAgICBjb21wb25lbnRzOiB7XG4gICAgICAgICAgICAgICAgLy8gKHN0cmluZykgVGhlIG5hbWUgb2YgdGhlIGNvbXBvbmVudCB1c2VkIGZvciB0aGUgdGFibGUgaGVhZGVyXG4gICAgICAgICAgICAgICAgaGVhZGVyOiAndGFibGUtdmlldy1oZWFkZXInLFxuXG4gICAgICAgICAgICAgICAgLy8gKHN0cmluZykgVGhlIG5hbWUgb2YgdGhlIGNvbXBvbmVudCB1c2VkIGZvciB0aGUgdGFibGUgcm93XG4gICAgICAgICAgICAgICAgcm93OiAndGFibGUtdmlldy1yb3cnLFxuXG4gICAgICAgICAgICAgICAgLy8gKHN0cmluZykgVGhlIG5hbWUgb2YgdGhlIGNvbXBvbmVudCB1c2VkIGZvciB0aGUgdGFibGUgcm93XG4gICAgICAgICAgICAgICAgZm9vdGVyOiAndGFibGUtdmlldy1mb290ZXInXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyAoaW50KSBUaGUgc3RhcnRpbmcgcGFnZVxuICAgICAgICAgICAgLy8gcGFnZTogMSxcblxuICAgICAgICAgICAgLy8gKHN0cmluZykgVGhlIG9yZGVyIG9mIHRoZSBkYXRlIGJlaW5nIHJldHVybmVkXG4gICAgICAgICAgICAvLyBvcmRlcjogbnVsbCxcblxuICAgICAgICAgICAgLy8gKHN0cmluZykgRWl0aGVyIGFzYyBvciBkZXNjIHNvcnRpbmcgb3JkZXJcbiAgICAgICAgICAgIC8vIHNvcnQ6IG51bGwsXG5cbiAgICAgICAgICAgIC8vIChpbnQpIFRoZSBudW1iZXJzIG9mIHJvd3MgcGVyIHBhZ2VcbiAgICAgICAgICAgIC8vIGxpbWl0OiAyMCxcblxuICAgICAgICAgICAgLy8gKGJvb2wpIEZldGNoIHRoZSBkYXRhIHdoZW4gdGFibGUgaXMgc2hvd25cbiAgICAgICAgICAgIC8vIGZldGNoT25SZW5kZXI6IHRydWUsXG5cbiAgICAgICAgICAgIC8vIChhcnJheSkgQW4gYXJyYXkgb2YgaGVhZGVycyBhcHBlbmRlZCB0byB0aGUgcmVxdWVzdFxuICAgICAgICAgICAgLy8gcmVxdWVzdEhlYWRlcnM6IFtdLFxuXG4gICAgICAgICAgICAvLyAoYXJyYXkpIFRoZSBkZWZhdWx0IG9wdGlvbnMgdXNlZCB0byBnZW5lcmF0ZSB0aGUgcXVlcnkgc3RyaW5nXG4gICAgICAgICAgICAvLyBkZWZhdWx0UmVxdWVzdERhdGFPcHRpb25zOiBbXG4gICAgICAgICAgICAvLyAgICAncGFnZScsXG4gICAgICAgICAgICAvLyAgICAnbGltaXQnLFxuICAgICAgICAgICAgLy8gICAgJ29yZGVyJyxcbiAgICAgICAgICAgIC8vICAgICdzb3J0J1xuICAgICAgICAgICAgLy8gXSxcblxuICAgICAgICAgICAgLy8gKG9iamVjdCkgQW4gb3B0aW9uIHRvIHBhc3MgYW4gb2JqZWN0IHdpdGggcmVxdWVzdCBkYXRhXG4gICAgICAgICAgICAvLyByZXF1ZXN0RGF0YToge30sXG5cbiAgICAgICAgICAgIC8vIChhcnJheSkgQWRkaXRpb25hbCBvcHRpb25zIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIHF1ZXJ5IHN0cmluZ1xuICAgICAgICAgICAgLy8gcmVxdWVzdERhdGFPcHRpb25zOiBbXSxcblxuICAgICAgICAgICAgLy8gKG9iamVjdCkgVGhlIGJvZHkgdmlldyBvcHRpb25zIG9iamVjdFxuICAgICAgICAgICAgLy8gYm9keVZpZXdPcHRpb25zOiBmYWxzZSxcblxuICAgICAgICAgICAgLy8gKG9iamVjdCkgVGhlIHBhZ2luYXRpb24gdmlldyBjbGFzc1xuICAgICAgICAgICAgLy8gZm9vdGVyVmlldzogJ3BhZ2luYXRpb24nLFxuXG4gICAgICAgICAgICAvLyAob2JqZWN0KSBUaGUgcGFnaW5hdGlvbiB2aWV3IG9wdGlvbnMgb2JqZWN0XG4gICAgICAgICAgICAvLyBmb290ZXJWaWV3T3B0aW9uczogZmFsc2UsXG5cbiAgICAgICAgICAgIC8vIChzdHJpbmcpIFRoZSB0YWJsZSBmb290ZXIgY2xhc3MgbmFtZVxuICAgICAgICAgICAgLy8gZm9vdGVyQ2xhc3NOYW1lOiAndGFibGUtaGVhZGVyJyxcblxuICAgICAgICAgICAgLy8gKHN0cmluZykgVGhlIHRhYmxlIGhlYWRlclxuICAgICAgICAgICAgLy8gaGVhZGVyOiBmYWxzZSxcblxuICAgICAgICAgICAgLy8gKHN0cmluZykgVGhlIHRhYmxlIGhlYWRlciB0YWcgbmFtZVxuICAgICAgICAgICAgLy8gaGVhZGVyVGFnTmFtZTogJ2gzJyxcblxuICAgICAgICAgICAgLy8gKHN0cmluZykgVGhlIHRhYmxlIGhlYWRlciBjbGFzcyBuYW1lXG4gICAgICAgICAgICAvLyBoZWFkZXJDbGFzc05hbWU6ICd0YWJsZS1oZWFkZXInLFxuXG4gICAgICAgICAgICAvLyAob2JqZWN0KSBUaGUgaGVhZGVyIHZpZXcgY2xhc3NcbiAgICAgICAgICAgIC8vIGhlYWRlclZpZXc6IGZhbHNlLFxuXG4gICAgICAgICAgICAvLyAob2JqZWN0KSBUaGUgaGVhZGVyIHZpZXcgb3B0aW9ucyBvYmplY3RcbiAgICAgICAgICAgIC8vIGhlYWRlclZpZXdPcHRpb25zOiBmYWxzZSxcblxuICAgICAgICAgICAgLy8gKHN0cmluZykgVGhlIHRhYmxlIGRlc2NyaXB0aW9uXG4gICAgICAgICAgICAvLyBkZXNjcmlwdGlvbjogZmFsc2UsXG5cbiAgICAgICAgICAgIC8vIChzdHJpbmcpIFRoZSB0YWJsZSBkZXNjcmlwdGlvbiB0YWdcbiAgICAgICAgICAgIC8vIGRlc2NyaXB0aW9uVGFnOiAncCcsXG5cbiAgICAgICAgICAgIC8vIChzdHJpbmcpIFRoZSB0YWJsZSBkZXNjcmlwdGlvbiB0YWdcbiAgICAgICAgICAgIC8vIGRlc2NyaXB0aW9uQ2xhc3NOYW1lOiAnZGVzY3JpcHRpb24gcm93IGNvbC1zbS02JyxcblxuICAgICAgICAgICAgLy8gKHN0cmluZykgVGhlIHRhYmxlIGNsYXNzIG5hbWVcbiAgICAgICAgICAgIC8vIHRhYmxlQ2xhc3NOYW1lOiAndGFibGUnLFxuXG4gICAgICAgICAgICAvLyAoc3RyaW5nKSBUaGUgbG9hZGluZyBjbGFzcyBuYW1lXG4gICAgICAgICAgICAvLyBsb2FkaW5nQ2xhc3NOYW1lOiAnbG9hZGluZycsXG5cbiAgICAgICAgICAgIC8vIChzdHJpbmcpIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSBpbiB0aGUgbW9kZWwgc3RvcmluZyB0aGUgY29sdW1uc1xuICAgICAgICAgICAgLy8gY2hpbGRWaWV3Q29sdW1uc1Byb3BlcnR5OiAnY29sdW1ucycsXG5cbiAgICAgICAgICAgIC8vIChvYmplY3QpIFRoZSBhY3Rpdml0eSBpbmRpY2F0b3Igb3B0aW9uc1xuICAgICAgICAgICAgLy8gaW5kaWNhdG9yT3B0aW9uczoge1xuICAgICAgICAgICAgLy8gICAgIGluZGljYXRvcjogJ3NtYWxsJ1xuICAgICAgICAgICAgLy8gfSxcblxuICAgICAgICAgICAgLy8gKHN0cmluZykgVGhlIG1lc3NhZ2UgdG8gZGlzcGxheSBpZiB0aGVyZSBhcmUgbm8gdGFibGUgcm93c1xuICAgICAgICAgICAgLy8gZW1wdHlNZXNzYWdlOiAnTm8gcm93cyBmb3VuZCcsXG5cbiAgICAgICAgICAgIC8vIChzdHJpbmcpIFRoZSBuYW1lIG9mIHRoZSBjbGFzcyBhcHBlbmRlZCB0byB0aGUgYnV0dG9uc1xuICAgICAgICAgICAgLy8gYnV0dG9uQ2xhc3NOYW1lOiAnYnRuIGJ0bi1kZWZhdWx0JyxcbiAgICAgICAgfSwgdGhpcy4kYXR0cnMpO1xuICAgIH0sXG4gICAgKi9cblxuICAgIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuJG9mZigpO1xuICAgIH1cbn1cblxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgVGFibGVWaWV3IGZyb20gJy4vVGFibGVWaWV3JztcbmltcG9ydCBWdWVJbnN0YWxsZXIgZnJvbSAnQC9IZWxwZXJzL1Z1ZUluc3RhbGxlci9WdWVJbnN0YWxsZXInO1xuXG5jb25zdCBwbHVnaW4gPSBWdWVJbnN0YWxsZXIudXNlKHtcblxuICAgIGluc3RhbGwoVnVlLCBvcHRpb25zKSB7XG4gICAgICAgIFZ1ZUluc3RhbGxlci5jb21wb25lbnRzKHtcbiAgICAgICAgICAgIFRhYmxlVmlld1xuICAgICAgICB9KTtcbiAgICB9XG5cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBUYWJsZVZpZXc7XG4iLCI8dGVtcGxhdGU+XG4gICAgPGZvcm0tZ3JvdXA+XG5cbiAgICAgICAgPHNsb3QgbmFtZT1cImxhYmVsXCI+XG4gICAgICAgICAgICA8Zm9ybS1sYWJlbCB2LWlmPVwibGFiZWxcIiA6Zm9yPVwiaWRcIiB2LWh0bWw9XCJsYWJlbFwiIC8+XG4gICAgICAgIDwvc2xvdD5cblxuICAgICAgICA8c2xvdCBuYW1lPVwiY29udHJvbFwiPlxuICAgICAgICAgICAgPHRleHRhcmVhXG4gICAgICAgICAgICAgICAgOmlkPVwiaWRcIlxuICAgICAgICAgICAgICAgIDp2YWx1ZT1cInZhbHVlXCJcbiAgICAgICAgICAgICAgICA6cGxhY2Vob2xkZXI9XCJwbGFjZWhvbGRlclwiXG4gICAgICAgICAgICAgICAgOnJlcXVpcmVkPVwicmVxdWlyZWRcIlxuICAgICAgICAgICAgICAgIDpkaXNhYmxlZD1cImRpc2FibGVkIHx8IHJlYWRvbmx5XCJcbiAgICAgICAgICAgICAgICA6cmVhZG9ubHk9XCJyZWFkb25seVwiXG4gICAgICAgICAgICAgICAgOnBhdHRlcm49XCJwYXR0ZXJuXCJcbiAgICAgICAgICAgICAgICA6Y2xhc3M9XCJtZXJnZUNsYXNzZXMoY29udHJvbENsYXNzZXMsIGNvbG9yYWJsZUNsYXNzZXMpXCJcbiAgICAgICAgICAgICAgICB2LWJpbmQtZXZlbnRzPVwiYmluZEV2ZW50c1wiXG4gICAgICAgICAgICAgICAgdi1vbjppbnB1dD1cInVwZGF0ZWQoJGV2ZW50LnRhcmdldC52YWx1ZSlcIj5cbiAgICAgICAgICAgIDwvdGV4dGFyZWE+XG4gICAgICAgIDwvc2xvdD5cblxuICAgICAgICA8c2xvdCBuYW1lPVwiaGVscFwiPlxuICAgICAgICAgICAgPGhlbHAtdGV4dCB2LWlmPVwiaGVscFRleHRcIiB2LWh0bWw9XCJoZWxwVGV4dFwiIC8+XG4gICAgICAgIDwvc2xvdD5cblxuICAgICAgICA8c2xvdCBuYW1lPVwiZmVlZGJhY2tcIj5cbiAgICAgICAgICAgIDxmb3JtLWZlZWRiYWNrIHYtaWY9XCJ2YWxpZEZlZWRiYWNrXCIgdi1odG1sPVwidmFsaWRGZWVkYmFja1wiIHZhbGlkIC8+XG4gICAgICAgICAgICA8Zm9ybS1mZWVkYmFjayB2LWlmPVwiaW52YWxpZEZlZWRiYWNrXCIgdi1odG1sPVwiaW52YWxpZEZlZWRiYWNrXCIgaW52YWxpZCAvPlxuICAgICAgICA8L3Nsb3Q+XG5cbiAgICA8L2Zvcm0tZ3JvdXA+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuXG5pbXBvcnQgQ29sb3JhYmxlIGZyb20gJ0AvTWl4aW5zL0NvbG9yYWJsZS9Db2xvcmFibGUnO1xuaW1wb3J0IEZvcm1Db250cm9sIGZyb20gJ0AvTWl4aW5zL0Zvcm1Db250cm9sL0Zvcm1Db250cm9sJztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ3RleHRhcmVhLWZpZWxkJyxcblxuICAgIG1peGluczogW1xuICAgICAgICBDb2xvcmFibGUsXG4gICAgICAgIEZvcm1Db250cm9sXG4gICAgXSxcblxuICAgIHByb3BzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdHlwZSBhdHRyaWJ1dGVcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJ3RleHQnXG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgVGV4dGFyZWFGaWVsZCBmcm9tICcuL1RleHRhcmVhRmllbGQnO1xuaW1wb3J0IFZ1ZUluc3RhbGxlciBmcm9tICdAL0hlbHBlcnMvVnVlSW5zdGFsbGVyL1Z1ZUluc3RhbGxlcic7XG5cbmNvbnN0IHBsdWdpbiA9IFZ1ZUluc3RhbGxlci51c2Uoe1xuXG4gICAgaW5zdGFsbChWdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgVnVlSW5zdGFsbGVyLmNvbXBvbmVudHMoe1xuICAgICAgICAgICAgVGV4dGFyZWFGaWVsZFxuICAgICAgICB9KTtcbiAgICB9XG5cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBUZXh0YXJlYUZpZWxkO1xuIiwidmFyIGJhc2VGaW5kSW5kZXggPSByZXF1aXJlKCcuL19iYXNlRmluZEluZGV4JyksXG4gICAgYmFzZUl0ZXJhdGVlID0gcmVxdWlyZSgnLi9fYmFzZUl0ZXJhdGVlJyksXG4gICAgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi90b0ludGVnZXInKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0XG4gKiBlbGVtZW50IGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciBpbnN0ZWFkIG9mIHRoZSBlbGVtZW50IGl0c2VsZi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDEuMS4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZvdW5kIGVsZW1lbnQsIGVsc2UgYC0xYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIHVzZXJzID0gW1xuICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogZmFsc2UgfSxcbiAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiB0cnVlIH1cbiAqIF07XG4gKlxuICogXy5maW5kSW5kZXgodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8udXNlciA9PSAnYmFybmV5JzsgfSk7XG4gKiAvLyA9PiAwXG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmluZEluZGV4KHVzZXJzLCB7ICd1c2VyJzogJ2ZyZWQnLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gKiAvLyA9PiAxXG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kSW5kZXgodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAqIC8vID0+IDBcbiAqXG4gKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmluZEluZGV4KHVzZXJzLCAnYWN0aXZlJyk7XG4gKiAvLyA9PiAyXG4gKi9cbmZ1bmN0aW9uIGZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICBpZiAoIWxlbmd0aCkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICB2YXIgaW5kZXggPSBmcm9tSW5kZXggPT0gbnVsbCA/IDAgOiB0b0ludGVnZXIoZnJvbUluZGV4KTtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIGluZGV4ID0gbmF0aXZlTWF4KGxlbmd0aCArIGluZGV4LCAwKTtcbiAgfVxuICByZXR1cm4gYmFzZUZpbmRJbmRleChhcnJheSwgYmFzZUl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIGluZGV4KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmaW5kSW5kZXg7XG4iLCIvKipcbiAqIEdldHMgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmxhc3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IDNcbiAqL1xuZnVuY3Rpb24gbGFzdChhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gIHJldHVybiBsZW5ndGggPyBhcnJheVtsZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsYXN0O1xuIiwidmFyIGJhc2VHZXQgPSByZXF1aXJlKCcuL19iYXNlR2V0JyksXG4gICAgYmFzZVNsaWNlID0gcmVxdWlyZSgnLi9fYmFzZVNsaWNlJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgcGFyZW50IHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheX0gcGF0aCBUaGUgcGF0aCB0byBnZXQgdGhlIHBhcmVudCB2YWx1ZSBvZi5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwYXJlbnQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHBhcmVudChvYmplY3QsIHBhdGgpIHtcbiAgcmV0dXJuIHBhdGgubGVuZ3RoIDwgMiA/IG9iamVjdCA6IGJhc2VHZXQob2JqZWN0LCBiYXNlU2xpY2UocGF0aCwgMCwgLTEpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwYXJlbnQ7XG4iLCJ2YXIgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpLFxuICAgIGxhc3QgPSByZXF1aXJlKCcuL2xhc3QnKSxcbiAgICBwYXJlbnQgPSByZXF1aXJlKCcuL19wYXJlbnQnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5zZXRgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHByb3BlcnR5IHBhdGggdG8gdW5zZXQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHByb3BlcnR5IGlzIGRlbGV0ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuc2V0KG9iamVjdCwgcGF0aCkge1xuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcbiAgb2JqZWN0ID0gcGFyZW50KG9iamVjdCwgcGF0aCk7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCB8fCBkZWxldGUgb2JqZWN0W3RvS2V5KGxhc3QocGF0aCkpXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVW5zZXQ7XG4iLCJ2YXIgYmFzZVVuc2V0ID0gcmVxdWlyZSgnLi9fYmFzZVVuc2V0JyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnB1bGxBdGAgd2l0aG91dCBzdXBwb3J0IGZvciBpbmRpdmlkdWFsXG4gKiBpbmRleGVzIG9yIGNhcHR1cmluZyB0aGUgcmVtb3ZlZCBlbGVtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7bnVtYmVyW119IGluZGV4ZXMgVGhlIGluZGV4ZXMgb2YgZWxlbWVudHMgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VQdWxsQXQoYXJyYXksIGluZGV4ZXMpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID8gaW5kZXhlcy5sZW5ndGggOiAwLFxuICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTtcblxuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICB2YXIgaW5kZXggPSBpbmRleGVzW2xlbmd0aF07XG4gICAgaWYgKGxlbmd0aCA9PSBsYXN0SW5kZXggfHwgaW5kZXggIT09IHByZXZpb3VzKSB7XG4gICAgICB2YXIgcHJldmlvdXMgPSBpbmRleDtcbiAgICAgIGlmIChpc0luZGV4KGluZGV4KSkge1xuICAgICAgICBzcGxpY2UuY2FsbChhcnJheSwgaW5kZXgsIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmFzZVVuc2V0KGFycmF5LCBpbmRleCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUHVsbEF0O1xuIiwidmFyIGJhc2VJdGVyYXRlZSA9IHJlcXVpcmUoJy4vX2Jhc2VJdGVyYXRlZScpLFxuICAgIGJhc2VQdWxsQXQgPSByZXF1aXJlKCcuL19iYXNlUHVsbEF0Jyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwgZWxlbWVudHMgZnJvbSBgYXJyYXlgIHRoYXQgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yXG4gKiBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiB0aGUgcmVtb3ZlZCBlbGVtZW50cy4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkXG4gKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICpcbiAqICoqTm90ZToqKiBVbmxpa2UgYF8uZmlsdGVyYCwgdGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLiBVc2UgYF8ucHVsbGBcbiAqIHRvIHB1bGwgZWxlbWVudHMgZnJvbSBhbiBhcnJheSBieSB2YWx1ZS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuMC4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiByZW1vdmVkIGVsZW1lbnRzLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgYXJyYXkgPSBbMSwgMiwgMywgNF07XG4gKiB2YXIgZXZlbnMgPSBfLnJlbW92ZShhcnJheSwgZnVuY3Rpb24obikge1xuICogICByZXR1cm4gbiAlIDIgPT0gMDtcbiAqIH0pO1xuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAqIC8vID0+IFsxLCAzXVxuICpcbiAqIGNvbnNvbGUubG9nKGV2ZW5zKTtcbiAqIC8vID0+IFsyLCA0XVxuICovXG5mdW5jdGlvbiByZW1vdmUoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgaW5kZXhlcyA9IFtdLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIHByZWRpY2F0ZSA9IGJhc2VJdGVyYXRlZShwcmVkaWNhdGUsIDMpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICBpbmRleGVzLnB1c2goaW5kZXgpO1xuICAgIH1cbiAgfVxuICBiYXNlUHVsbEF0KGFycmF5LCBpbmRleGVzKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZW1vdmU7XG4iLCI8dGVtcGxhdGU+XG5cbiAgICA8Zm9ybS1ncm91cCBjbGFzcz1cInVwbG9hZC1maWVsZFwiIDpjbGFzcz1cInsnZW5hYmxlLWRyb3B6b25lJzogZHJvcHpvbmV9XCIgQGRyYWdlbnRlci5wcmV2ZW50PVwib25EcmFnRW50ZXJcIiBAZHJhZ292ZXIucHJldmVudD1cIm9uRHJhZ092ZXJcIiBAZHJhZ2xlYXZlLnByZXZlbnQ9XCJvbkRyYWdMZWF2ZVwiPlxuXG4gICAgICAgIDxmaWxlLWZpZWxkXG4gICAgICAgICAgICB2LWlmPVwibXVsdGlwbGUgJiYgKCFtYXhVcGxvYWRzIHx8IG1heFVwbG9hZHMgPiBkYXRhLmxlbmd0aCkgfHwgIW11bHRpcGxlICYmICFkYXRhXCJcbiAgICAgICAgICAgIDpuYW1lPVwibmFtZVwiXG4gICAgICAgICAgICA6bGFiZWw9XCJsYWJlbFwiXG4gICAgICAgICAgICA6cGxhY2Vob2xkZXI9XCJwbGFjZWhvbGRlclwiXG4gICAgICAgICAgICA6aGVscC10ZXh0PVwiaGVscFRleHRcIlxuICAgICAgICAgICAgOm11bHRpcGxlPVwibXVsdGlwbGVcIlxuICAgICAgICAgICAgOndpZHRoPVwid2lkdGhcIlxuICAgICAgICAgICAgOmhlaWdodD1cImhlaWdodFwiXG4gICAgICAgICAgICA6ZXJyb3JzPVwiZXJyb3JzXCJcbiAgICAgICAgICAgIEBjaGFuZ2U9XCJtdWx0aXBsZSA/IGFkZEZpbGVzKCRldmVudC50YXJnZXQuZmlsZXMpIDogYWRkRmlsZSgkZXZlbnQudGFyZ2V0LmZpbGVzWzBdKVwiXG4gICAgICAgIC8+XG5cbiAgICAgICAgPGRpdiB2LWlmPVwibXVsdGlwbGVcIiBjbGFzcz1cInVwbG9hZC1maWVsZC1wcmV2aWV3IG10LTRcIj5cbiAgICAgICAgICAgIDxmaWxlLXByZXZpZXcgdi1mb3I9XCIoZmlsZSwga2V5KSBpbiBkYXRhXCIgOmtleT1cIltmaWxlLm5hbWUsIGZpbGUubGFzdE1vZGlmaWVkLCBmaWxlLnNpemVdLmpvaW4oJycpXCIgOmZpbGU9XCJmaWxlXCIgQGNsb3NlPVwicmVtb3ZlRmlsZShmaWxlKVwiICAvPlxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8ZGl2IHYtZWxzZS1pZj1cIiFtdWx0aXBsZSAmJiBkYXRhXCIgY2xhc3M9XCJ1cGxvYWQtZmllbGQtcHJldmlldyBtdC00XCI+XG4gICAgICAgICAgICA8ZmlsZS1wcmV2aWV3IDpmaWxlPVwiZGF0YVwiIEBjbG9zZT1cInJlbW92ZUZpbGUoZGF0YSlcIiAgLz5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPGRpdiB2LWlmPVwic2hvd0Ryb3BFbGVtZW50XCIgY2xhc3M9XCJ1cGxvYWQtZmllbGQtZHJvcHpvbmVcIiA6c3R5bGU9XCJ7J21pbi1oZWlnaHQnOiBkcm9wem9uZU1pbkhlaWdodH1cIiBAZHJvcC5wcmV2ZW50PVwib25Ecm9wXCI+XG4gICAgICAgICAgICA8aSBjbGFzcz1cImZhIGZhLWNsb3VkLXVwbG9hZFwiPjwvaT5cbiAgICAgICAgICAgIDxkaXY+RHJhZyBhbmQgZHJvcCBmaWxlcyB0byB1cGxvYWQ8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG5cbiAgICA8L2Zvcm0tZ3JvdXA+XG5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgeyBlYWNoIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IG1lcmdlIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IHJlbW92ZSB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBleHRlbmQgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgZmluZEluZGV4IH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IGlzVW5kZWZpbmVkIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBGb3JtQ29udHJvbCBmcm9tICdAL01peGlucy9Gb3JtQ29udHJvbC9Gb3JtQ29udHJvbCc7XG5pbXBvcnQgRmlsZUZpZWxkIGZyb20gJ0AvQ29tcG9uZW50cy9GaWxlRmllbGQvRmlsZUZpZWxkJztcbmltcG9ydCBGaWxlUHJldmlldyBmcm9tICdAL0NvbXBvbmVudHMvRmlsZVByZXZpZXcvRmlsZVByZXZpZXcnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAndXBsb2FkLWZpZWxkJyxcblxuICAgIG1peGluczogW0Zvcm1Db250cm9sXSxcblxuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgICAgRmlsZUZpZWxkLFxuICAgICAgICBGaWxlUHJldmlld1xuICAgIH0sXG5cbiAgICBtb2RlbDoge1xuICAgICAgICBwcm9wOiAnZGF0YScsXG4gICAgICAgIGV2ZW50OiAnY2hhbmdlJ1xuICAgIH0sXG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJcyB0aGUgdXNlciBkcmFnZ2luZyBhIGZpbGUgb3ZlciB0aGUgZHJvcHpvbmVcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ2dpbmc6IHtcbiAgICAgICAgICAgIHR5cGU6IFtTdHJpbmcsIEJvb2xlYW5dLFxuICAgICAgICAgICAgZGVmYXVsdCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgZmlsZXMgdGhhdCBhIHVzZXIgY2FuIHVwbG9hZFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBtYXhVcGxvYWRzOiBOdW1iZXIsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBoZWlnaHQgYXR0cmlidXRlIGZvciB0aGUgY29udHJvbCBlbGVtZW50XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGhlaWdodDogW051bWJlciwgU3RyaW5nXSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHdpZHRoIGF0dHJpYnV0ZSBmb3IgdGhlIGNvbnRyb2wgZWxlbWVudFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICB3aWR0aDogW051bWJlciwgU3RyaW5nXSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FuIHVzZXIgZHJhZy9kcm9wIGZpbGVzIGludG8gYnJvd3NlciB0byB1cGxvYWQgdGhlbS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgZHJvcHpvbmU6IHtcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgICBkZWZhdWx0OiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbiB1c2VyIGRyYWcvZHJvcCBmaWxlcyBpbnRvIGJyb3dzZXIgdG8gdXBsb2FkIHRoZW0uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGRyb3B6b25lTWluSGVpZ2h0OiBbTnVtYmVyLCBTdHJpbmddLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYW4gdXNlciB1cGxvYWQgbXVsdGlwbGUgZmlsZXNcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGlwbGU6IHtcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGF0YSBhdHRyaWJ1dGVcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IEZpbGV8RmlsZUxpc3R8QXJyYXlcbiAgICAgICAgICovXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIHR5cGU6IFtPYmplY3QsIEZpbGUsIEZpbGVMaXN0LCBBcnJheV0sXG4gICAgICAgICAgICBkZWZhdWx0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhdGhpcy5tdWx0aXBsZSA/IG51bGwgOiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIG1ldGhvZHM6IHtcblxuICAgICAgICByZW1vdmVGaWxlKGRhdGEpIHtcbiAgICAgICAgICAgIGlmKHRoaXMubXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWxlcyA9IHRoaXMuZGF0YS5zbGljZSgwKTtcblxuICAgICAgICAgICAgICAgIHJlbW92ZShmaWxlcywge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBkYXRhLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHNpemU6IGRhdGEuc2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgbGFzdE1vZGlmaWVkOiBkYXRhLmxhc3RNb2RpZmllZFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgZmlsZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkRmlsZShmaWxlLCBzdWJqZWN0KSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6IGZpbGUubmFtZSxcbiAgICAgICAgICAgICAgICBsYXN0TW9kaWZpZWQ6IGZpbGUubGFzdE1vZGlmaWVkLFxuICAgICAgICAgICAgICAgIGxhc3RNb2RpZmllZERhdGU6IGZpbGUubGFzdE1vZGlmaWVkRGF0ZSxcbiAgICAgICAgICAgICAgICBzaXplOiBmaWxlLnNpemUsXG4gICAgICAgICAgICAgICAgdHlwZTogZmlsZS50eXBlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKHRoaXMubXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWxlcyA9IHN1YmplY3QgfHwgdGhpcy5kYXRhLnNsaWNlKDApO1xuXG4gICAgICAgICAgICAgICAgaWYoIXRoaXMubWF4VXBsb2FkcyB8fCB0aGlzLm1heFVwbG9hZHMgPiBmaWxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYoZmluZEluZGV4KGZpbGVzLCBkYXRhKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVzLnB1c2goZmlsZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnLCBmaWxlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgZmlsZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBhZGRGaWxlcyhmaWxlcykge1xuICAgICAgICAgICAgY29uc3Qgc3ViamVjdCA9IHRoaXMuZGF0YS5zbGljZSgwKTtcblxuICAgICAgICAgICAgZWFjaChmaWxlcywgZmlsZSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRGaWxlKGZpbGUsIHN1YmplY3QpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGV2ZW50LnRhcmdldC52YWx1ZSA9IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBgZHJhZ292ZXJgIGV2ZW50IGNhbGxiYWNrLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBvbkRyYWdPdmVyKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmlzRHJhZ2dpbmdJbnNpZGUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgndXBkYXRlOmRyYWdnaW5nJywgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCdkcmFnOm92ZXInLCBldmVudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBgZHJhZ292ZXJgIGV2ZW50IGNhbGxiYWNrLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBvbkRyYWdFbnRlcihldmVudCkge1xuICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nSW5zaWRlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ3VwZGF0ZTpkcmFnZ2luZycsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgnZHJhZzplbnRlcicsIGV2ZW50KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGBkcmFnbGVhdmVgIGV2ZW50IGNhbGxiYWNrLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBvbkRyYWdMZWF2ZShldmVudCkge1xuICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nSW5zaWRlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCd1cGRhdGU6ZHJhZ2dpbmcnLCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCdkcmFnOmxlYXZlJywgZXZlbnQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYGRyb3BgIGV2ZW50IGNhbGxiYWNrLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBvbkRyb3AoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZ0luc2lkZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5hZGRGaWxlcyhldmVudC5kYXRhVHJhbnNmZXIuZmlsZXMpO1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgndXBkYXRlOmRyYWdnaW5nJywgZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgnZHJvcCcsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBjb21wdXRlZDoge1xuICAgICAgICBzaG93RHJvcEVsZW1lbnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gIWlzVW5kZWZpbmVkKHRoaXMuZHJhZ2dpbmcpID8gdGhpcy5kcmFnZ2luZyA6IHRoaXMuaXNEcmFnZ2luZ0luc2lkZVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpc0RyYWdnaW5nSW5zaWRlOiBmYWxzZVxuICAgICAgICB9O1xuICAgIH1cblxufVxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwic2Nzc1wiPlxuQGltcG9ydCAnLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwL3Njc3MvYm9vdHN0cmFwLnNjc3MnO1xuXG4udXBsb2FkLWZpZWxkIHtcblxuICAgICYuZW5hYmxlLWRyb3B6b25lIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIH1cblxuICAgICY6bm90KC5lbmFibGUtZHJvcHpvbmUpIC51cGxvYWQtZmllbGQtZHJvcHpvbmUge1xuICAgICAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgfVxuXG4gICAgLnVwbG9hZC1maWVsZC1kcm9wem9uZSB7XG4gICAgICAgIGNvbG9yOiAkaW5mbztcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgdG9wOiAwO1xuICAgICAgICBsZWZ0OiAwO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICB6LWluZGV4OiAxMDA7XG4gICAgICAgIGJhY2tncm91bmQ6IGxpZ2h0ZW4oJGluZm8sIDQ1JSk7XG4gICAgICAgIGJvcmRlcjogMnB4IGRhc2hlZCBsaWdodGVuKCRpbmZvLCAyNSUpO1xuICAgICAgICB0ZXh0LXNoYWRvdzogMCAxcHggMCB3aGl0ZTtcblxuICAgICAgICAmID4gaSB7XG4gICAgICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMzJweDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC51cGxvYWQtZmllbGQtcHJldmlldyB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGZsZXgtd3JhcDogd3JhcDtcbiAgICB9XG5cbiAgICAudXBsb2FkLWZpZWxkLXByZXZpZXcgLmZpbGUtcHJldmlldzpub3QoLmlzLWltYWdlKSB7XG4gICAgICAgIHdpZHRoOiAxNTBweDtcbiAgICB9XG5cbiAgICAudXBsb2FkLWZpZWxkLXByZXZpZXcgLmZpbGUtcHJldmlldy5pcy1pbWFnZSB7XG4gICAgICAgIHdpZHRoOiAyMi43NSU7XG4gICAgICAgIG1hcmdpbi1yaWdodDogMyU7XG5cbiAgICAgICAgJjpudGgtY2hpbGQoNG4pIHtcbiAgICAgICAgICAgIG1hcmdpbi1yaWdodDogMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC51cGxvYWQtZmllbGQtcHJldmlldyAuZmlsZS1wcmV2aWV3IHtcbiAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgIH1cblxuICAgIC51cGxvYWQtZmllbGQtcHJldmlldyAuZmlsZS1wcmV2aWV3LW5hbWUtbGFiZWwge1xuICAgICAgICBtYXgtd2lkdGg6IDIwMHB4O1xuICAgIH1cbn1cbjwvc3R5bGU+XG4iLCJpbXBvcnQgVXBsb2FkRmllbGQgZnJvbSAnLi9VcGxvYWRGaWVsZCc7XG5pbXBvcnQgVnVlSW5zdGFsbGVyIGZyb20gJ0AvSGVscGVycy9WdWVJbnN0YWxsZXIvVnVlSW5zdGFsbGVyJztcblxuY29uc3QgcGx1Z2luID0gVnVlSW5zdGFsbGVyLnVzZSh7XG5cbiAgICBpbnN0YWxsKFZ1ZSwgb3B0aW9ucykge1xuICAgICAgICBWdWVJbnN0YWxsZXIuY29tcG9uZW50cyh7XG4gICAgICAgICAgICBVcGxvYWRGaWVsZFxuICAgICAgICB9KTtcbiAgICB9XG5cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBVcGxvYWRGaWVsZDtcbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlc3BvbnNlVHJhbnNmb3JtZXIge1xuXG4gICAgY29uc3RydWN0b3IocmVzcG9uc2UpIHtcbiAgICAgICAgdGhpcy4kcmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICB9XG5cbn1cbiIsImltcG9ydCBwcmVmaXggZnJvbSAnQC9IZWxwZXJzL1ByZWZpeC9QcmVmaXgnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc2l6ZSBvZiB0aGUgZm9ybSBjb250cm9sXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHNpemU6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdtZCcsXG4gICAgICAgICAgICB2YWxpZGF0ZTogdmFsdWUgPT4gWydzbScsICdtZCcsICdsZyddLmluZGV4T2YodmFsdWUpICE9PSAtMVxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgc2l6ZWFibGVDbGFzcygpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmVmaXgodGhpcy5zaXplLCB0aGlzLiRvcHRpb25zLm5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuXG59XG4iLCJpbXBvcnQgeyBpc0Z1bmN0aW9uIH0gZnJvbSAnbG9kYXNoJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYmxvYih1cmwsIHByb2dyZXNzKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIHVybCwgdHJ1ZSk7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYmxvYic7XG5cbiAgICAgICAgaWYoaXNGdW5jdGlvbihwcm9ncmVzcykpIHtcbiAgICAgICAgICAgIHhoci5vbnByb2dyZXNzID0gZSA9PiBwcm9ncmVzcyhlLCB4aHIpO1xuICAgICAgICB9XG5cbiAgICAgICAgeGhyLm9uZXJyb3IgPSBlID0+IHJlamVjdChlKTtcbiAgICAgICAgeGhyLm9uYWJvcnQgPSBlID0+IHJlamVjdChlKTtcbiAgICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLnJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB4aHIuc2VuZCgpO1xuICAgIH0pO1xufVxuIiwiaW1wb3J0IHsgZWFjaCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgKiBhcyBwbHVnaW5zIGZyb20gJy4vUGx1Z2lucyc7XG5pbXBvcnQgKiBhcyBjb21wb25lbnRzIGZyb20gJy4vQ29tcG9uZW50cyc7XG4vL2ltcG9ydCAqIGFzIGRpcmVjdGl2ZXMgZnJvbSAnLi9EaXJlY3RpdmVzJztcbmltcG9ydCBWdWVJbnN0YWxsZXIgZnJvbSAnLi9IZWxwZXJzL1Z1ZUluc3RhbGxlcic7XG5cbmV4cG9ydCAqIGZyb20gJy4vSHR0cCc7XG5leHBvcnQgKiBmcm9tICcuL01peGlucyc7XG5leHBvcnQgKiBmcm9tICcuL1BsdWdpbnMnO1xuZXhwb3J0ICogZnJvbSAnLi9Db21wb25lbnRzJztcbi8vZXhwb3J0ICogZnJvbSAnLi9EaXJlY3RpdmVzJztcbmV4cG9ydCAqIGZyb20gJy4vSGVscGVycyc7XG5cbmV4cG9ydCBkZWZhdWx0IFZ1ZUluc3RhbGxlci51c2Uoe1xuXG4gICAgaW5zdGFsbChWdWUpIHtcbiAgICAgICAgVnVlSW5zdGFsbGVyLnBsdWdpbnMoVnVlLCBwbHVnaW5zKTtcbiAgICAgICAgVnVlSW5zdGFsbGVyLmNvbXBvbmVudHMoVnVlLCBjb21wb25lbnRzKTtcbiAgICAgICAgLy9WdWVJbnN0YWxsZXIuZGlyZWN0aXZlcyhWdWUsIGRpcmVjdGl2ZXMpO1xuICAgIH1cblxufSk7XG4iXSwibmFtZXMiOlsiZ2xvYmFsIiwiZnJlZUdsb2JhbCIsIlN5bWJvbCIsInJvb3QiLCJvYmplY3RQcm90byIsIm5hdGl2ZU9iamVjdFRvU3RyaW5nIiwic3ltVG9TdHJpbmdUYWciLCJnZXRSYXdUYWciLCJvYmplY3RUb1N0cmluZyIsImlzT2JqZWN0IiwiYmFzZUdldFRhZyIsImNvcmVKc0RhdGEiLCJmdW5jUHJvdG8iLCJmdW5jVG9TdHJpbmciLCJoYXNPd25Qcm9wZXJ0eSIsImlzTWFza2VkIiwiaXNGdW5jdGlvbiIsInRvU291cmNlIiwiZ2V0VmFsdWUiLCJiYXNlSXNOYXRpdmUiLCJnZXROYXRpdmUiLCJkZWZpbmVQcm9wZXJ0eSIsImVxIiwiYmFzZUFzc2lnblZhbHVlIiwiYXNzaWduVmFsdWUiLCJhcHBseSIsImlkZW50aXR5IiwiY29uc3RhbnQiLCJzaG9ydE91dCIsImJhc2VTZXRUb1N0cmluZyIsInNldFRvU3RyaW5nIiwib3ZlclJlc3QiLCJpc0xlbmd0aCIsIk1BWF9TQUZFX0lOVEVHRVIiLCJpc0FycmF5TGlrZSIsImlzSW5kZXgiLCJiYXNlUmVzdCIsImlzSXRlcmF0ZWVDYWxsIiwiaXNPYmplY3RMaWtlIiwiYmFzZUlzQXJndW1lbnRzIiwic3R1YkZhbHNlIiwiYXJnc1RhZyIsImZ1bmNUYWciLCJub2RlVXRpbCIsImJhc2VVbmFyeSIsImJhc2VJc1R5cGVkQXJyYXkiLCJpc0FycmF5IiwiaXNBcmd1bWVudHMiLCJpc0J1ZmZlciIsImlzVHlwZWRBcnJheSIsImJhc2VUaW1lcyIsIm5hdGl2ZUtleXNJbiIsImlzUHJvdG90eXBlIiwiYXJyYXlMaWtlS2V5cyIsImJhc2VLZXlzSW4iLCJjcmVhdGVBc3NpZ25lciIsImNvcHlPYmplY3QiLCJrZXlzSW4iLCJyZXF1aXJlJCQwIiwiYXNzb2NJbmRleE9mIiwibGlzdENhY2hlQ2xlYXIiLCJsaXN0Q2FjaGVEZWxldGUiLCJsaXN0Q2FjaGVHZXQiLCJsaXN0Q2FjaGVIYXMiLCJsaXN0Q2FjaGVTZXQiLCJMaXN0Q2FjaGUiLCJNYXAiLCJuYXRpdmVDcmVhdGUiLCJIQVNIX1VOREVGSU5FRCIsImhhc2hDbGVhciIsImhhc2hEZWxldGUiLCJoYXNoR2V0IiwiaGFzaEhhcyIsImhhc2hTZXQiLCJIYXNoIiwiaXNLZXlhYmxlIiwiZ2V0TWFwRGF0YSIsIm1hcENhY2hlQ2xlYXIiLCJtYXBDYWNoZURlbGV0ZSIsIm1hcENhY2hlR2V0IiwibWFwQ2FjaGVIYXMiLCJtYXBDYWNoZVNldCIsIk1hcENhY2hlIiwic3RhY2tDbGVhciIsInN0YWNrRGVsZXRlIiwic3RhY2tHZXQiLCJzdGFja0hhcyIsInN0YWNrU2V0IiwiY3JlYXRlQmFzZUZvciIsIlVpbnQ4QXJyYXkiLCJjbG9uZUFycmF5QnVmZmVyIiwib3ZlckFyZyIsImJhc2VDcmVhdGUiLCJnZXRQcm90b3R5cGUiLCJvYmplY3RUYWciLCJzYWZlR2V0IiwiYXNzaWduTWVyZ2VWYWx1ZSIsImlzQXJyYXlMaWtlT2JqZWN0IiwiY29weUFycmF5IiwiY2xvbmVCdWZmZXIiLCJjbG9uZVR5cGVkQXJyYXkiLCJpc1BsYWluT2JqZWN0IiwidG9QbGFpbk9iamVjdCIsImluaXRDbG9uZU9iamVjdCIsImJhc2VGb3IiLCJTdGFjayIsImJhc2VNZXJnZURlZXAiLCJiYXNlTWVyZ2UiLCJuYXRpdmVLZXlzIiwiYmFzZUtleXMiLCJrZXlzIiwiY3JlYXRlQmFzZUVhY2giLCJiYXNlRm9yT3duIiwiYXJyYXlFYWNoIiwiYmFzZUVhY2giLCJjYXN0RnVuY3Rpb24iLCJWdWUiLCJvcHRpb25zIiwicHJvdG90eXBlIiwibWVyZ2VDbGFzc2VzIiwiY2xhc3NlcyIsInNsaWNlIiwiY2FsbCIsImFyZ3VtZW50cyIsIl9pc09iamVjdCIsImFyZyIsIl9pc0FycmF5IiwiYmFzZVByb3BlcnR5T2YiLCJhcnJheU1hcCIsImlzU3ltYm9sIiwiYmFzZVRvU3RyaW5nIiwidG9TdHJpbmciLCJkZWJ1cnJMZXR0ZXIiLCJyc0NvbWJvTWFya3NSYW5nZSIsInJlQ29tYm9IYWxmTWFya3NSYW5nZSIsInJzQ29tYm9TeW1ib2xzUmFuZ2UiLCJyc0NvbWJvUmFuZ2UiLCJyc0NvbWJvIiwiaGFzVW5pY29kZVdvcmQiLCJ1bmljb2RlV29yZHMiLCJhc2NpaVdvcmRzIiwicnNBcG9zIiwiYXJyYXlSZWR1Y2UiLCJ3b3JkcyIsImRlYnVyciIsImNyZWF0ZUNvbXBvdW5kZXIiLCJyZW5kZXIiLCJwcm9wcyIsIm5vZGVzIiwidHlwZSIsIk51bWJlciIsImRlZmF1bHQiLCJzaXplIiwiU3RyaW5nIiwicHJlZml4IiwiY29tcHV0ZWQiLCIkb3B0aW9ucyIsIm5hbWUiLCJyZXBsYWNlIiwiZXh0ZW5kcyIsIkJhc2VUeXBlIiwiX2V4dGVuZCIsImNlbnRlciIsIkJvb2xlYW4iLCJjb21wb25lbnRzIiwiQWN0aXZpdHlJbmRpY2F0b3JEb3RzIiwiQWN0aXZpdHlJbmRpY2F0b3JTcGlubmVyIiwiY29tcG9uZW50IiwiX2tlYmFiQ2FzZSIsIlZ1ZUluc3RhbGxlciIsInVzZSIsInBsdWdpbiIsInBsdWdpbnMiLCJkaXJlY3RpdmUiLCJkaXJlY3RpdmVzIiwiJHBsdWdpbnMiLCIkZGlyZWN0aXZlcyIsIiRjb21wb25lbnRzIiwid2luZG93IiwiZGVmIiwiaW5zdGFsbCIsIkFjdGl2aXR5SW5kaWNhdG9yIiwiY29udmVydEFuaW1hdGlvbkRlbGF5VG9JbnQiLCJkZWxheSIsIm51bSIsInBhcnNlRmxvYXQiLCJtYXRjaGVzIiwibWF0Y2giLCJ1bml0IiwibWlsbGlzZWNvbmRzIiwiYW5pbWF0ZWQiLCJlbCIsImNhbGxiYWNrIiwiZGVmYXVsdFZpZXciLCJvd25lckRvY3VtZW50IiwiZG9jdW1lbnQiLCJzZXRUaW1lb3V0IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImFuaW1hdGlvbkR1cmF0aW9uIiwiYWN0aXZpdHkiLCJkaXNhYmxlZCIsImJsb2NrIiwidmFyaWFudCIsImluZGljYXRvciIsIm9yaWVudGF0aW9uIiwibGFiZWwiLCJtZXRob2RzIiwiZGlzYWJsZSIsIiRlbCIsImVuYWJsZSIsInNob3dBY3Rpdml0eSIsImNsYXNzTGlzdCIsImFkZCIsIiRlbWl0IiwiaGlkZUFjdGl2aXR5IiwicmVtb3ZlIiwib25DbGljayIsImV2ZW50Iiwid2F0Y2giLCJ2YWx1ZSIsIkFjdGl2aXR5QnV0dG9uIiwic2V0Q2FjaGVBZGQiLCJzZXRDYWNoZUhhcyIsIlNldENhY2hlIiwiYXJyYXlTb21lIiwiY2FjaGVIYXMiLCJDT01QQVJFX1BBUlRJQUxfRkxBRyIsIkNPTVBBUkVfVU5PUkRFUkVEX0ZMQUciLCJib29sVGFnIiwiZGF0ZVRhZyIsImVycm9yVGFnIiwibWFwVGFnIiwibnVtYmVyVGFnIiwicmVnZXhwVGFnIiwic2V0VGFnIiwic3RyaW5nVGFnIiwic3ltYm9sVGFnIiwiYXJyYXlCdWZmZXJUYWciLCJkYXRhVmlld1RhZyIsInN5bWJvbFByb3RvIiwibWFwVG9BcnJheSIsInNldFRvQXJyYXkiLCJlcXVhbEFycmF5cyIsImFycmF5UHVzaCIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwic3R1YkFycmF5IiwiYXJyYXlGaWx0ZXIiLCJiYXNlR2V0QWxsS2V5cyIsImdldFN5bWJvbHMiLCJnZXRBbGxLZXlzIiwiUHJvbWlzZSIsIndlYWtNYXBUYWciLCJEYXRhVmlldyIsIlNldCIsIldlYWtNYXAiLCJhcnJheVRhZyIsImdldFRhZyIsImVxdWFsQnlUYWciLCJlcXVhbE9iamVjdHMiLCJiYXNlSXNFcXVhbERlZXAiLCJiYXNlSXNFcXVhbCIsImlzU3RyaWN0Q29tcGFyYWJsZSIsImdldE1hdGNoRGF0YSIsIm1hdGNoZXNTdHJpY3RDb21wYXJhYmxlIiwiYmFzZUlzTWF0Y2giLCJtZW1vaXplIiwibWVtb2l6ZUNhcHBlZCIsImlzS2V5Iiwic3RyaW5nVG9QYXRoIiwiSU5GSU5JVFkiLCJjYXN0UGF0aCIsInRvS2V5IiwiYmFzZUdldCIsImhhc1BhdGgiLCJiYXNlSGFzSW4iLCJnZXQiLCJoYXNJbiIsImJhc2VQcm9wZXJ0eSIsImJhc2VQcm9wZXJ0eURlZXAiLCJiYXNlTWF0Y2hlc1Byb3BlcnR5IiwiYmFzZU1hdGNoZXMiLCJwcm9wZXJ0eSIsImJhc2VJdGVyYXRlZSIsInN1YmplY3QiLCJkZWxpbWV0ZXIiLCJwcmVmaXhlciIsImtleSIsInN0cmluZyIsIlJlZ0V4cCIsImpvaW4iLCJfbWFwS2V5cyIsInZhcmlhbnRDbGFzcyIsIm1peGlucyIsIlZhcmlhbnQiLCJhY2Nlc3NpYmlsaXR5IiwiaHJlZiIsInBpbGwiLCJzZWNvbmRhcnkiLCJCYWRnZSIsImJhc2VSZWR1Y2UiLCJiYXNlU2V0IiwibmF0aXZlR2V0U3ltYm9scyIsImdldFN5bWJvbHNJbiIsImdldEFsbEtleXNJbiIsImJhc2VQaWNrQnkiLCJiYXNlRmlsdGVyIiwicnNBc3RyYWxSYW5nZSIsInJzVmFyUmFuZ2UiLCJyc1pXSiIsInJzRml0eiIsInJzTW9kaWZpZXIiLCJyc05vbkFzdHJhbCIsInJzUmVnaW9uYWwiLCJyc1N1cnJQYWlyIiwicmVPcHRNb2QiLCJyc09wdFZhciIsInJzT3B0Sm9pbiIsInJzU2VxIiwiaGFzVW5pY29kZSIsInVuaWNvZGVTaXplIiwiYXNjaWlTaXplIiwiaXNTdHJpbmciLCJzdHJpbmdTaXplIiwiYmFzZU1hcCIsImJhc2VTbGljZSIsInJzQXN0cmFsIiwicnNTeW1ib2wiLCJyZVVuaWNvZGUiLCJ1bmljb2RlVG9BcnJheSIsImFzY2lpVG9BcnJheSIsInN0cmluZ1RvQXJyYXkiLCJjYXN0U2xpY2UiLCJjcmVhdGVDYXNlRmlyc3QiLCJ1cHBlckZpcnN0IiwiY2FwaXRhbGl6ZSIsIm1ldGFNYXAiLCJjcmVhdGVDdG9yIiwibmF0aXZlTWF4IiwiYmFzZUxvZGFzaCIsIm5vb3AiLCJyZWFsTmFtZXMiLCJMYXp5V3JhcHBlciIsIkxvZGFzaFdyYXBwZXIiLCJ3cmFwcGVyQ2xvbmUiLCJnZXRGdW5jTmFtZSIsImxvZGFzaCIsImdldERhdGEiLCJiYXNlU2V0RGF0YSIsInN0cmljdEluZGV4T2YiLCJiYXNlRmluZEluZGV4IiwiYmFzZUlzTmFOIiwiYmFzZUluZGV4T2YiLCJXUkFQX0JJTkRfRkxBRyIsImFycmF5SW5jbHVkZXMiLCJpbnNlcnRXcmFwRGV0YWlscyIsInVwZGF0ZVdyYXBEZXRhaWxzIiwiZ2V0V3JhcERldGFpbHMiLCJXUkFQX0JJTkRfS0VZX0ZMQUciLCJXUkFQX0NVUlJZX0ZMQUciLCJXUkFQX1BBUlRJQUxfRkxBRyIsIldSQVBfUEFSVElBTF9SSUdIVF9GTEFHIiwiaXNMYXppYWJsZSIsInNldERhdGEiLCJzZXRXcmFwVG9TdHJpbmciLCJXUkFQX0NVUlJZX1JJR0hUX0ZMQUciLCJXUkFQX0FSWV9GTEFHIiwiV1JBUF9GTElQX0ZMQUciLCJnZXRIb2xkZXIiLCJjb3VudEhvbGRlcnMiLCJjb21wb3NlQXJncyIsImNvbXBvc2VBcmdzUmlnaHQiLCJyZXBsYWNlSG9sZGVycyIsImNyZWF0ZVJlY3VycnkiLCJyZW9yZGVyIiwiY3JlYXRlSHlicmlkIiwiUExBQ0VIT0xERVIiLCJXUkFQX0NVUlJZX0JPVU5EX0ZMQUciLCJXUkFQX1JFQVJHX0ZMQUciLCJuYXRpdmVNaW4iLCJ0b051bWJlciIsInRvRmluaXRlIiwiRlVOQ19FUlJPUl9URVhUIiwidG9JbnRlZ2VyIiwibWVyZ2VEYXRhIiwiY3JlYXRlQmluZCIsImNyZWF0ZUN1cnJ5IiwiY3JlYXRlUGFydGlhbCIsImNyZWF0ZVdyYXAiLCJ0aGlzIiwiUFJPWFlfQ09ORklHX1BST1BFUlRJRVMiLCJQUk9YWV9DT05GSUdfTUVUSE9EUyIsInByb3AiLCJjb250ZXh0Iiwic2V0IiwibWVyZ2UiLCJ2YWx1ZXMiLCJtZXRob2QiLCJhY3Rpb24iLCJfY2FtZWxDYXNlIiwiY2hhaW5hYmxlIiwiRm9ybURhdGEiLCJSZXF1ZXN0IiwidXJsIiwiY29uZmlnIiwiJGNvbmZpZyIsImhlYWRlcnMiLCJwYXJhbXMiLCJkYXRhIiwiX2JpbmQiLCJyZXNldCIsIiRlcnJvciIsIiRzdGF0dXMiLCIkc3RhdHVzVGV4dCIsIiRyZXNwb25zZSIsIiRyZXF1ZXN0U2VudEF0IiwiJHJlc3BvbnNlUmVjZWl2ZWRBdCIsImhhc1Jlc3BvbnNlIiwiJHVybCIsInJlcXVlc3QiLCJtb21lbnQiLCJhZGRDb25maWciLCJwcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImF4aW9zIiwidGhlbiIsInJlc3BvbnNlIiwic3RhdHVzIiwic3RhdHVzVGV4dCIsImVycm9yIiwiZXJyb3JzIiwiTW9kZWwiLCIkY2hhbmdlZCIsIiRleGlzdHMiLCIkYXR0cmlidXRlcyIsIiRrZXkiLCIkZmlsZXMiLCJmaWxlcyIsIiR0YWJsZSIsInRhYmxlIiwiJHByb3BlcnRpZXMiLCJwcm9wZXJ0aWVzIiwiaW5pdGlhbGl6ZSIsIkVycm9yIiwiJGluaXRpYWxpemVkIiwiZmlsbCIsInNldEF0dHJpYnV0ZXMiLCJnZXRBdHRyaWJ1dGVzIiwiZmlsdGVyIiwiaW5kZXhPZiIsImdldEF0dHJpYnV0ZSIsInVuZGVmaW5lZCIsInNldEF0dHJpYnV0ZSIsIl9rZXlzIiwiX2ZpbHRlciIsImhhbmRsZUF0dHJpYnV0ZUNoYW5nZSIsIl9pc1VuZGVmaW5lZCIsIl9zaXplIiwiY291bnQiLCJ0b3RhbCIsIl9yZWR1Y2UiLCJjYXJyeSIsIkZpbGUiLCJGaWxlTGlzdCIsInRvSlNPTiIsImhhbmRsZVByaW1hcnlLZXlDaGFuZ2UiLCJfaXNOdWxsIiwiZXhpc3RzIiwiY3JlYXRlIiwidXBkYXRlIiwiaGFzRmlsZXMiLCJ0b0pzb24iLCJ0b0Zvcm1EYXRhIiwicG9zdCIsImRlbGV0ZSIsIl9tYXAiLCJjb25zdHJ1Y3RvciIsImlkIiwiZm9ybSIsImFwcGVuZCIsIml0ZW0iLCJfcGlja0J5IiwibGVuZ3RoIiwiT2JqZWN0IiwibW9kZWwiLCJ2YWxpZGF0ZSIsImlubGluZSIsIm5vdmFsaWRhdGUiLCJyZWRpcmVjdCIsIkZ1bmN0aW9uIiwib25TdWJtaXQiLCJjb25zb2xlIiwibG9nIiwic2F2ZSIsIm9uVXBsb2FkUHJvZ3Jlc3MiLCJvblN1Ym1pdFN1Y2Nlc3MiLCJvblN1Ym1pdEZhaWxlZCIsIl9pc0Z1bmN0aW9uIiwibG9jYXRpb24iLCJCYXNlRm9ybSIsInV1aWQiLCJyIiwiTWF0aCIsInJhbmRvbSIsInYiLCJjIiwicHJveHkiLCJzcGxpY2UiLCJwcmV2ZW50RGVmYXVsdCIsIlByb3h5IiwiYWN0aXZlIiwiaWNvbiIsIm9uQ2xpY2tlZCIsImhlYWRlciIsIkRyb3Bkb3duTWVudUl0ZW0iLCJEcm9wZG93bk1lbnVIZWFkZXIiLCJEcm9wZG93bk1lbnVEaXZpZGVyIiwiYWxpZ24iLCJ0b0xvd2VyQ2FzZSIsInNob3ciLCJpdGVtcyIsIkFycmF5IiwiRHJvcGRvd25NZW51IiwidHJhbnNmb3JtUG9zaXRpb24iLCJiaW5kaW5nIiwidm5vZGUiLCJsZWZ0IiwicmlnaHQiLCJ4IiwieSIsIm9mZnNldEVsZW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwic3BsaXQiLCJ3aWR0aCIsInN0eWxlIiwidHJhbnNmb3JtIiwiZHJvcHVwIiwiZHJvcHJpZ2h0IiwiZHJvcGxlZnQiLCJzaG93RHJvcGRvd24iLCJpc0Ryb3Bkb3duU2hvd2luZyIsImhpZGVEcm9wZG93biIsIm9uQmx1ciIsImNvbnRhaW5zIiwicmVsYXRlZFRhcmdldCIsIm9uSXRlbUNsaWNrIiwiY2hpbGQiLCJhY3Rpb25DbGFzc2VzIiwidG9nZ2xlQ2xhc3NlcyIsIkJ1dHRvbkRyb3Bkb3duIiwicGlja0J5IiwibmVnYXRlIiwiQ09MT1JTIiwiX2VhY2giLCJjb2xvciIsIm5hbWVzcGFjZSIsImluc3RhbmNlIiwidGV4dENvbG9yIiwiYmdDb2xvciIsImJnR3JhZGllbnRDb2xvciIsInRleHRDb2xvckNsYXNzZXMiLCJ0cmltIiwiYmdDb2xvckNsYXNzZXMiLCJiZ0dyYWRpZW50Q29sb3JDbGFzc2VzIiwiY29sb3JhYmxlQ2xhc3NlcyIsIl9vbWl0QnkiLCJwbGFjZWhvbGRlciIsInJlcXVpcmVkIiwicGF0dGVybiIsImZlZWRiYWNrIiwiYmluZEV2ZW50cyIsImRlZmF1bHRDb250cm9sQ2xhc3MiLCJoaWRlTGFiZWwiLCJzcGFjaW5nIiwicGxhaW50ZXh0IiwicmVhZG9ubHkiLCJoZWxwVGV4dCIsImJpbmQiLCJldmVudHMiLCJhZGRFdmVudExpc3RlbmVyIiwiZ2V0SW5wdXRGaWVsZCIsImdldEZpZWxkRXJyb3JzIiwidXBkYXRlZCIsImNhbGxiYWNrcyIsIm1hcCIsImludmFsaWRGZWVkYmFjayIsInZhbGlkRmVlZGJhY2siLCJjb250cm9sQ2xhc3MiLCJjb250cm9sU2l6ZUNsYXNzIiwiY29udHJvbENsYXNzZXMiLCJDb2xvcmFibGUiLCJGb3JtQ29udHJvbCIsImdyb3VwIiwiY2hlY2tlZCIsIlJhZGlvRmllbGQiLCJpbmRleCIsInB1c2giLCJDaGVja2JveEZpZWxkIiwiQ29udGFpbmVyIiwiSW5wdXRGaWVsZCIsImV4dGVuc2lvbnMiLCJtdWx0aXBsZSIsImhlaWdodCIsIkZpbGVGaWVsZCIsInJlYWRGaWxlIiwiZmlsZSIsInByb2dyZXNzIiwicmVhZGVyIiwiRmlsZVJlYWRlciIsIm9ubG9hZCIsImUiLCJvbmVycm9yIiwib25hYm9ydCIsIm9ucHJvZ3Jlc3MiLCJyZWFkQXNEYXRhVVJMIiwic3RyaXBlZCIsImZvcm1hdHRlZEhlaWdodCIsIl9pc051bWJlciIsInByb2dyZXNzQ2xhc3NlcyIsIlByb2dyZXNzQmFyIiwicmVhZHkiLCJpbnNlcnRlZCIsImltYWdlTWltZXMiLCJvcmlnX2ZpbGVuYW1lIiwiZXh0ZW5zaW9uIiwicG9wIiwiYnl0ZXNUb1NpemUiLCJieXRlcyIsIm1pbWUiLCJpc0ltYWdlIiwibGFzdE1vZGlmaWVkIiwibGFzdE1vZGlmaWVkRGF0ZSIsInN0YXJ0IiwibGVuZ3RoQ29tcHV0YWJsZSIsImxvYWRlZCIsInBhcnNlSW50IiwiaW1hZ2UiLCJ0YXJnZXQiLCJyZXN1bHQiLCJkaWZmIiwic2l6ZXMiLCJpIiwiZmxvb3IiLCJyb3VuZCIsInBvdyIsIkZpbGVQcmV2aWV3IiwiaW52YWxpZCIsInZhbGlkIiwiRm9ybUZlZWRiYWNrIiwiRm9ybUdyb3VwIiwic3JPbmx5Iiwic3JPbmx5Rm9jdXNhYmxlIiwic2NyZWVucmVhZGVyQ2xhc3NlcyIsIlNjcmVlbnJlYWRlcnMiLCJGb3JtTGFiZWwiLCJIZWxwVGV4dCIsImFjdGl2ZUNsYXNzIiwib25WYWx1ZSIsIm9mZlZhbHVlIiwiaXNBY3RpdmUiLCJkcmFnZ2luZyIsImdldFRyYW5zaXRpb25Jbk1pbGxpc2Vjb25kcyIsImR1cmF0aW9uIiwidHJhbnNpdGlvbkR1cmF0aW9uIiwibnVtZXJpYyIsInRvZ2dsZSIsIkxpZ2h0U3dpdGNoRmllbGQiLCJiYWRnZSIsImlzRGlzYWJsZWQiLCJiYWRnZU9wdGlvbnMiLCJhY3RpdmF0ZSIsImRlYWN0aXZhdGUiLCJwcmV2VmFsdWUiLCJMaXN0R3JvdXBJdGVtIiwiYWN0aXZhdGVhYmxlIiwiZmx1c2giLCJiaW5kRXZlbnRzVG9DaGlsZHJlbiIsIiRjaGlsZHJlbiIsIiRvZmYiLCJvbkNsaWNrQ2hpbGQiLCIkb24iLCJvbkFjdGl2YXRlIiwib25EZWFjdGl2YXRlIiwiYWN0aXZlSXRlbSIsIm1vdW50ZWQiLCJMaXN0R3JvdXAiLCJiYWNrZ3JvdW5kIiwidmlzaWJsZSIsImZvY3VzIiwiJG1vdW50IiwiYm9keSIsImFwcGVuZENoaWxkIiwiY3JlYXRlRWxlbWVudCIsImhpZGUiLCJvbkNsaWNrQ2xvc2UiLCJPdmVybGF5IiwicGFnZSIsInRvdGFsUGFnZXMiLCJzaG93UGFnZXMiLCJvblBhZ2luYXRlIiwibmV4dCIsInBhZ2luYXRlIiwiY3VycmVudFBhZ2UiLCJwcmV2IiwiY3VycmVudFRhcmdldCIsInBhcmVudE5vZGUiLCJzZXRBY3RpdmVQYWdlIiwiZ2VuZXJhdGUiLCJwYWdlcyIsInN0YXJ0UGFnZSIsInN0YXJ0T2Zmc2V0IiwiZW5kUGFnZSIsImRpdmlkZXIiLCJQYWdpbmF0aW9uIiwiQ1VTVE9NX1NFTEVDVF9QUkVGSVgiLCJjdXN0b20iLCJjdXN0b21TZWxlY3RDbGFzc2VzIiwiY3VzdG9tU2VsZWN0U2l6ZUNsYXNzIiwiU2VsZWN0RmllbGQiLCJUcmFuc2Zvcm1lciIsIiRvcmlnaW5hbFJlc3BvbnNlIiwiJHJlcXVpcmVkIiwiJHRyYW5zZm9ybWVkUmVzcG9uc2UiLCJUYWJsZVZpZXdUcmFuc2Zvcm1lciIsImxpbWl0Iiwib3JkZXIiLCJzb3J0IiwibWluSGVpZ2h0IiwiYnV0dG9ucyIsImNvbHVtbnMiLCJoZWFkaW5nIiwiZGVzY3JpcHRpb24iLCJ0cmFuc2Zvcm1lciIsInRhYmxlQ29sdW1ucyIsImNvbHVtbiIsIm9yZGVyQnkiLCJkZWZhdWx0U29ydCIsImN1cnJlbnRTb3J0IiwiZ2V0UmVxdWVzdFBhcmFtIiwiY3VycmVudE9yZGVyIiwiYWRkUmVxdWVzdFBhcmFtIiwiZmV0Y2giLCJnZXRSZXF1ZXN0SGVhZGVyIiwiYWRkUmVxdWVzdEhlYWRlciIsImxvYWRpbmciLCJtaW4iLCJlbGVtZW50cyIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsIm1heCIsIiRhdHRycyIsImJlZm9yZURlc3Ryb3kiLCJUYWJsZVZpZXciLCJUZXh0YXJlYUZpZWxkIiwicGFyZW50IiwibGFzdCIsImFycmF5UHJvdG8iLCJiYXNlVW5zZXQiLCJiYXNlUHVsbEF0IiwibWF4VXBsb2FkcyIsImRyb3B6b25lIiwiZHJvcHpvbmVNaW5IZWlnaHQiLCJyZW1vdmVGaWxlIiwiYWRkRmlsZSIsIl9maW5kSW5kZXgiLCJhZGRGaWxlcyIsIm9uRHJhZ092ZXIiLCJpc0RyYWdnaW5nSW5zaWRlIiwib25EcmFnRW50ZXIiLCJvbkRyYWdMZWF2ZSIsIm9uRHJvcCIsImRhdGFUcmFuc2ZlciIsInNob3dEcm9wRWxlbWVudCIsIlVwbG9hZEZpZWxkIiwiUmVzcG9uc2VUcmFuc2Zvcm1lciIsInNpemVhYmxlQ2xhc3MiLCJibG9iIiwieGhyIiwiWE1MSHR0cFJlcXVlc3QiLCJvcGVuIiwicmVzcG9uc2VUeXBlIiwic2VuZCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7RUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQXlCQSxTQUFTLFFBQVEsQ0FBQyxLQUFLLEVBQUU7SUFDdkIsSUFBSSxJQUFJLEdBQUcsT0FBTyxLQUFLLENBQUM7SUFDeEIsT0FBTyxLQUFLLElBQUksSUFBSSxLQUFLLElBQUksSUFBSSxRQUFRLElBQUksSUFBSSxJQUFJLFVBQVUsQ0FBQyxDQUFDO0dBQ2xFOztFQUVELGNBQWMsR0FBRyxRQUFRLENBQUM7O0VDOUIxQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUF1QkEsSUFBSSxPQUFP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QWUsR0FBRzs7SUFFcEIsTUFBTSxFQUFFLEdBQUcsR0FBRyxNQUFNLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxHQUFHO0lBQzdFLE1BQU0sRUFBRSxHQUFHLEdBQUcsTUFBTSxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsR0FBRztJQUM3RSxNQUFNLEVBQUUsR0FBRyxHQUFHLE1BQU0sRUFBRSxHQUFHO0lBQ3pCLE1BQU0sRUFBRSxHQUFHLEdBQUcsTUFBTSxFQUFFLEdBQUc7SUFDekIsTUFBTSxFQUFFLEdBQUcsR0FBRyxNQUFNLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLEdBQUc7SUFDbkQsTUFBTSxFQUFFLEdBQUcsR0FBRyxNQUFNLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLEdBQUc7SUFDbkQsTUFBTSxFQUFFLEdBQUcsR0FBRyxNQUFNLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLEdBQUc7SUFDbkQsTUFBTSxFQUFFLEdBQUcsR0FBRyxNQUFNLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLEdBQUc7SUFDbkQsTUFBTSxFQUFFLEdBQUcsR0FBRyxNQUFNLEVBQUUsR0FBRztJQUN6QixNQUFNLEVBQUUsR0FBRyxHQUFHLE1BQU0sRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLEdBQUc7SUFDN0UsTUFBTSxFQUFFLEdBQUcsR0FBRyxNQUFNLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxHQUFHO0lBQzdFLE1BQU0sRUFBRSxHQUFHLEdBQUcsTUFBTSxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxHQUFHO0lBQ25ELE1BQU0sRUFBRSxHQUFHLEdBQUcsTUFBTSxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxHQUFHO0lBQ25ELE1BQU0sRUFBRSxHQUFHLEdBQUcsTUFBTSxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsR0FBRztJQUN0QyxNQUFNLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxJQUFJO0lBQzFCLE1BQU0sRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLElBQUk7SUFDMUIsTUFBTSxFQUFFLElBQUk7O0lBRVosUUFBUSxFQUFFLEdBQUcsR0FBRyxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHO0lBQzVDLFFBQVEsRUFBRSxHQUFHLEdBQUcsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRztJQUM1QyxRQUFRLEVBQUUsR0FBRyxHQUFHLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRztJQUMzRCxRQUFRLEVBQUUsR0FBRyxHQUFHLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRztJQUMzRCxRQUFRLEVBQUUsR0FBRyxHQUFHLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRztJQUMzRCxRQUFRLEVBQUUsR0FBRyxHQUFHLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHO0lBQzFFLFFBQVEsRUFBRSxHQUFHLEdBQUcsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUc7SUFDMUUsUUFBUSxFQUFFLEdBQUcsR0FBRyxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUc7SUFDM0QsUUFBUSxFQUFFLEdBQUcsR0FBRyxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUc7SUFDM0QsUUFBUSxFQUFFLEdBQUcsR0FBRyxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUc7SUFDM0QsUUFBUSxFQUFFLEdBQUcsR0FBRyxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRztJQUMxRSxRQUFRLEVBQUUsR0FBRyxHQUFHLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHO0lBQzFFLFFBQVEsRUFBRSxHQUFHLEdBQUcsUUFBUSxFQUFFLEdBQUc7SUFDN0IsUUFBUSxFQUFFLEdBQUcsR0FBRyxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHO0lBQzVDLFFBQVEsRUFBRSxHQUFHLEdBQUcsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUc7SUFDMUUsUUFBUSxFQUFFLEdBQUcsR0FBRyxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRztJQUMxRSxRQUFRLEVBQUUsR0FBRyxHQUFHLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRztJQUMzRCxRQUFRLEVBQUUsR0FBRyxHQUFHLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRztJQUMzRCxRQUFRLEVBQUUsR0FBRyxHQUFHLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUc7SUFDNUMsUUFBUSxFQUFFLEdBQUcsR0FBRyxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHO0lBQzVDLFFBQVEsRUFBRSxHQUFHLEdBQUcsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRztJQUM1QyxRQUFRLEVBQUUsR0FBRyxHQUFHLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUc7SUFDNUMsUUFBUSxFQUFFLEdBQUcsR0FBRyxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUc7SUFDM0QsUUFBUSxFQUFFLEdBQUcsR0FBRyxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUc7SUFDM0QsUUFBUSxFQUFFLEdBQUcsR0FBRyxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHO0lBQzVDLFFBQVEsRUFBRSxHQUFHLEdBQUcsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRztJQUM1QyxRQUFRLEVBQUUsR0FBRyxHQUFHLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUc7SUFDekYsUUFBUSxFQUFFLEdBQUcsR0FBRyxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHO0lBQ3pGLFFBQVEsRUFBRSxHQUFHLEdBQUcsUUFBUSxFQUFFLEdBQUc7SUFDN0IsUUFBUSxFQUFFLEdBQUcsR0FBRyxRQUFRLEVBQUUsR0FBRyxFQUFF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
