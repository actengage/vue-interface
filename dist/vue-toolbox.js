(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('moment')) :
    typeof define === 'function' && define.amd ? define(['exports', 'moment'], factory) :
    (factory((global.VueToolbox = {}),global.moment));
}(this, (function (exports,moment) { 'use strict';

    moment = moment && moment.hasOwnProperty('default') ? moment['default'] : moment;

    function DateFilter (value, format) {
      if (value) {
        return moment(String(value)).format(format);
      }

      return '';
    }

    function MomentFilter (value, format) {
      if (value) {
        return moment(String(value)).format(format);
      }

      return '';
    }

    function index (Vue, options) {
      Vue.filter('date', DateFilter);
      Vue.filter('moment', MomentFilter);
    }



    var filters = /*#__PURE__*/Object.freeze({
        DateFilter: index,
        MomentFilter: index
    });

    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == 'object' || type == 'function');
    }

    var isObject_1 = isObject;

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
    var isArray = Array.isArray;

    var isArray_1 = isArray;

    var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function createCommonjsModule(fn, module) {
    	return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    /** Detect free variable `global` from Node.js. */
    var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

    var _freeGlobal = freeGlobal;

    /** Detect free variable `self`. */
    var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

    /** Used as a reference to the global object. */
    var root = _freeGlobal || freeSelf || Function('return this')();

    var _root = root;

    /** Built-in value references. */
    var Symbol$1 = _root.Symbol;

    var _Symbol = Symbol$1;

    /** Used for built-in method references. */
    var objectProto = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString = objectProto.toString;

    /** Built-in value references. */
    var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

    /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag),
          tag = value[symToStringTag];

      try {
        value[symToStringTag] = undefined;
        var unmasked = true;
      } catch (e) {}

      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }

    var _getRawTag = getRawTag;

    /** Used for built-in method references. */
    var objectProto$1 = Object.prototype;

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString$1 = objectProto$1.toString;

    /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */
    function objectToString(value) {
      return nativeObjectToString$1.call(value);
    }

    var _objectToString = objectToString;

    /** `Object#toString` result references. */
    var nullTag = '[object Null]',
        undefinedTag = '[object Undefined]';

    /** Built-in value references. */
    var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;

    /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    function baseGetTag(value) {
      if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
      }
      return (symToStringTag$1 && symToStringTag$1 in Object(value))
        ? _getRawTag(value)
        : _objectToString(value);
    }

    var _baseGetTag = baseGetTag;

    /** `Object#toString` result references. */
    var asyncTag = '[object AsyncFunction]',
        funcTag = '[object Function]',
        genTag = '[object GeneratorFunction]',
        proxyTag = '[object Proxy]';

    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      if (!isObject_1(value)) {
        return false;
      }
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 9 which returns 'object' for typed arrays and other constructors.
      var tag = _baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }

    var isFunction_1 = isFunction;

    /** Used to detect overreaching core-js shims. */
    var coreJsData = _root['__core-js_shared__'];

    var _coreJsData = coreJsData;

    /** Used to detect methods masquerading as native. */
    var maskSrcKey = (function() {
      var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || '');
      return uid ? ('Symbol(src)_1.' + uid) : '';
    }());

    /**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */
    function isMasked(func) {
      return !!maskSrcKey && (maskSrcKey in func);
    }

    var _isMasked = isMasked;

    /** Used for built-in method references. */
    var funcProto = Function.prototype;

    /** Used to resolve the decompiled source of functions. */
    var funcToString = funcProto.toString;

    /**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to convert.
     * @returns {string} Returns the source code.
     */
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {}
        try {
          return (func + '');
        } catch (e) {}
      }
      return '';
    }

    var _toSource = toSource;

    /**
     * Used to match `RegExp`
     * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
     */
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

    /** Used to detect host constructors (Safari). */
    var reIsHostCtor = /^\[object .+?Constructor\]$/;

    /** Used for built-in method references. */
    var funcProto$1 = Function.prototype,
        objectProto$2 = Object.prototype;

    /** Used to resolve the decompiled source of functions. */
    var funcToString$1 = funcProto$1.toString;

    /** Used to check objects for own properties. */
    var hasOwnProperty$1 = objectProto$2.hasOwnProperty;

    /** Used to detect if a method is native. */
    var reIsNative = RegExp('^' +
      funcToString$1.call(hasOwnProperty$1).replace(reRegExpChar, '\\$&')
      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
    );

    /**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */
    function baseIsNative(value) {
      if (!isObject_1(value) || _isMasked(value)) {
        return false;
      }
      var pattern = isFunction_1(value) ? reIsNative : reIsHostCtor;
      return pattern.test(_toSource(value));
    }

    var _baseIsNative = baseIsNative;

    /**
     * Gets the value at `key` of `object`.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */
    function getValue(object, key) {
      return object == null ? undefined : object[key];
    }

    var _getValue = getValue;

    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */
    function getNative(object, key) {
      var value = _getValue(object, key);
      return _baseIsNative(value) ? value : undefined;
    }

    var _getNative = getNative;

    var defineProperty = (function() {
      try {
        var func = _getNative(Object, 'defineProperty');
        func({}, '', {});
        return func;
      } catch (e) {}
    }());

    var _defineProperty = defineProperty;

    /**
     * The base implementation of `assignValue` and `assignMergeValue` without
     * value checks.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function baseAssignValue(object, key, value) {
      if (key == '__proto__' && _defineProperty) {
        _defineProperty(object, key, {
          'configurable': true,
          'enumerable': true,
          'value': value,
          'writable': true
        });
      } else {
        object[key] = value;
      }
    }

    var _baseAssignValue = baseAssignValue;

    /**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */
    function eq(value, other) {
      return value === other || (value !== value && other !== other);
    }

    var eq_1 = eq;

    /** Used for built-in method references. */
    var objectProto$3 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$2 = objectProto$3.hasOwnProperty;

    /**
     * Assigns `value` to `key` of `object` if the existing value is not equivalent
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty$2.call(object, key) && eq_1(objValue, value)) ||
          (value === undefined && !(key in object))) {
        _baseAssignValue(object, key, value);
      }
    }

    var _assignValue = assignValue;

    /**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property identifiers to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Function} [customizer] The function to customize copied values.
     * @returns {Object} Returns `object`.
     */
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});

      var index = -1,
          length = props.length;

      while (++index < length) {
        var key = props[index];

        var newValue = customizer
          ? customizer(object[key], source[key], key, object, source)
          : undefined;

        if (newValue === undefined) {
          newValue = source[key];
        }
        if (isNew) {
          _baseAssignValue(object, key, newValue);
        } else {
          _assignValue(object, key, newValue);
        }
      }
      return object;
    }

    var _copyObject = copyObject;

    /**
     * This method returns the first argument it receives.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'a': 1 };
     *
     * console.log(_.identity(object) === object);
     * // => true
     */
    function identity(value) {
      return value;
    }

    var identity_1 = identity;

    /**
     * A faster alternative to `Function#apply`, this function invokes `func`
     * with the `this` binding of `thisArg` and the arguments of `args`.
     *
     * @private
     * @param {Function} func The function to invoke.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} args The arguments to invoke `func` with.
     * @returns {*} Returns the result of `func`.
     */
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0: return func.call(thisArg);
        case 1: return func.call(thisArg, args[0]);
        case 2: return func.call(thisArg, args[0], args[1]);
        case 3: return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }

    var _apply = apply;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeMax = Math.max;

    /**
     * A specialized version of `baseRest` which transforms the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @param {Function} transform The rest array transform.
     * @returns {Function} Returns the new function.
     */
    function overRest(func, start, transform) {
      start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
      return function() {
        var args = arguments,
            index = -1,
            length = nativeMax(args.length - start, 0),
            array = Array(length);

        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return _apply(func, this, otherArgs);
      };
    }

    var _overRest = overRest;

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new constant function.
     * @example
     *
     * var objects = _.times(2, _.constant({ 'a': 1 }));
     *
     * console.log(objects);
     * // => [{ 'a': 1 }, { 'a': 1 }]
     *
     * console.log(objects[0] === objects[1]);
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    var constant_1 = constant;

    /**
     * The base implementation of `setToString` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
    var baseSetToString = !_defineProperty ? identity_1 : function(func, string) {
      return _defineProperty(func, 'toString', {
        'configurable': true,
        'enumerable': false,
        'value': constant_1(string),
        'writable': true
      });
    };

    var _baseSetToString = baseSetToString;

    /** Used to detect hot functions by number of calls within a span of milliseconds. */
    var HOT_COUNT = 800,
        HOT_SPAN = 16;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeNow = Date.now;

    /**
     * Creates a function that'll short out and invoke `identity` instead
     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
     * milliseconds.
     *
     * @private
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new shortable function.
     */
    function shortOut(func) {
      var count = 0,
          lastCalled = 0;

      return function() {
        var stamp = nativeNow(),
            remaining = HOT_SPAN - (stamp - lastCalled);

        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(undefined, arguments);
      };
    }

    var _shortOut = shortOut;

    /**
     * Sets the `toString` method of `func` to return `string`.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
    var setToString = _shortOut(_baseSetToString);

    var _setToString = setToString;

    /**
     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     */
    function baseRest(func, start) {
      return _setToString(_overRest(func, start, identity_1), func + '');
    }

    var _baseRest = baseRest;

    /** Used as references for various `Number` constants. */
    var MAX_SAFE_INTEGER = 9007199254740991;

    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */
    function isLength(value) {
      return typeof value == 'number' &&
        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }

    var isLength_1 = isLength;

    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */
    function isArrayLike(value) {
      return value != null && isLength_1(value.length) && !isFunction_1(value);
    }

    var isArrayLike_1 = isArrayLike;

    /** Used as references for various `Number` constants. */
    var MAX_SAFE_INTEGER$1 = 9007199254740991;

    /** Used to detect unsigned integer values. */
    var reIsUint = /^(?:0|[1-9]\d*)$/;

    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER$1 : length;

      return !!length &&
        (type == 'number' ||
          (type != 'symbol' && reIsUint.test(value))) &&
            (value > -1 && value % 1 == 0 && value < length);
    }

    var _isIndex = isIndex;

    /**
     * Checks if the given arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
     *  else `false`.
     */
    function isIterateeCall(value, index, object) {
      if (!isObject_1(object)) {
        return false;
      }
      var type = typeof index;
      if (type == 'number'
            ? (isArrayLike_1(object) && _isIndex(index, object.length))
            : (type == 'string' && index in object)
          ) {
        return eq_1(object[index], value);
      }
      return false;
    }

    var _isIterateeCall = isIterateeCall;

    /**
     * Creates a function like `_.assign`.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */
    function createAssigner(assigner) {
      return _baseRest(function(object, sources) {
        var index = -1,
            length = sources.length,
            customizer = length > 1 ? sources[length - 1] : undefined,
            guard = length > 2 ? sources[2] : undefined;

        customizer = (assigner.length > 3 && typeof customizer == 'function')
          ? (length--, customizer)
          : undefined;

        if (guard && _isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? undefined : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }

    var _createAssigner = createAssigner;

    /**
     * The base implementation of `_.times` without support for iteratee shorthands
     * or max array length checks.
     *
     * @private
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     */
    function baseTimes(n, iteratee) {
      var index = -1,
          result = Array(n);

      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }

    var _baseTimes = baseTimes;

    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return value != null && typeof value == 'object';
    }

    var isObjectLike_1 = isObjectLike;

    /** `Object#toString` result references. */
    var argsTag = '[object Arguments]';

    /**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */
    function baseIsArguments(value) {
      return isObjectLike_1(value) && _baseGetTag(value) == argsTag;
    }

    var _baseIsArguments = baseIsArguments;

    /** Used for built-in method references. */
    var objectProto$4 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$3 = objectProto$4.hasOwnProperty;

    /** Built-in value references. */
    var propertyIsEnumerable = objectProto$4.propertyIsEnumerable;

    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    var isArguments = _baseIsArguments(function() { return arguments; }()) ? _baseIsArguments : function(value) {
      return isObjectLike_1(value) && hasOwnProperty$3.call(value, 'callee') &&
        !propertyIsEnumerable.call(value, 'callee');
    };

    var isArguments_1 = isArguments;

    /**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */
    function stubFalse() {
      return false;
    }

    var stubFalse_1 = stubFalse;

    var isBuffer_1 = createCommonjsModule(function (module, exports) {
    /** Detect free variable `exports`. */
    var freeExports = 'object' == 'object' && exports && !exports.nodeType && exports;

    /** Detect free variable `module`. */
    var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

    /** Detect the popular CommonJS extension `module.exports`. */
    var moduleExports = freeModule && freeModule.exports === freeExports;

    /** Built-in value references. */
    var Buffer = moduleExports ? _root.Buffer : undefined;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */
    var isBuffer = nativeIsBuffer || stubFalse_1;

    module.exports = isBuffer;
    });

    /** `Object#toString` result references. */
    var argsTag$1 = '[object Arguments]',
        arrayTag = '[object Array]',
        boolTag = '[object Boolean]',
        dateTag = '[object Date]',
        errorTag = '[object Error]',
        funcTag$1 = '[object Function]',
        mapTag = '[object Map]',
        numberTag = '[object Number]',
        objectTag = '[object Object]',
        regexpTag = '[object RegExp]',
        setTag = '[object Set]',
        stringTag = '[object String]',
        weakMapTag = '[object WeakMap]';

    var arrayBufferTag = '[object ArrayBuffer]',
        dataViewTag = '[object DataView]',
        float32Tag = '[object Float32Array]',
        float64Tag = '[object Float64Array]',
        int8Tag = '[object Int8Array]',
        int16Tag = '[object Int16Array]',
        int32Tag = '[object Int32Array]',
        uint8Tag = '[object Uint8Array]',
        uint8ClampedTag = '[object Uint8ClampedArray]',
        uint16Tag = '[object Uint16Array]',
        uint32Tag = '[object Uint32Array]';

    /** Used to identify `toStringTag` values of typed arrays. */
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
    typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
    typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
    typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
    typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag$1] = typedArrayTags[arrayTag] =
    typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
    typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
    typedArrayTags[errorTag] = typedArrayTags[funcTag$1] =
    typedArrayTags[mapTag] = typedArrayTags[numberTag] =
    typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
    typedArrayTags[setTag] = typedArrayTags[stringTag] =
    typedArrayTags[weakMapTag] = false;

    /**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */
    function baseIsTypedArray(value) {
      return isObjectLike_1(value) &&
        isLength_1(value.length) && !!typedArrayTags[_baseGetTag(value)];
    }

    var _baseIsTypedArray = baseIsTypedArray;

    /**
     * The base implementation of `_.unary` without support for storing metadata.
     *
     * @private
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     */
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }

    var _baseUnary = baseUnary;

    var _nodeUtil = createCommonjsModule(function (module, exports) {
    /** Detect free variable `exports`. */
    var freeExports = 'object' == 'object' && exports && !exports.nodeType && exports;

    /** Detect free variable `module`. */
    var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

    /** Detect the popular CommonJS extension `module.exports`. */
    var moduleExports = freeModule && freeModule.exports === freeExports;

    /** Detect free variable `process` from Node.js. */
    var freeProcess = moduleExports && _freeGlobal.process;

    /** Used to access faster Node.js helpers. */
    var nodeUtil = (function() {
      try {
        return freeProcess && freeProcess.binding && freeProcess.binding('util');
      } catch (e) {}
    }());

    module.exports = nodeUtil;
    });

    /* Node.js helper references. */
    var nodeIsTypedArray = _nodeUtil && _nodeUtil.isTypedArray;

    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    var isTypedArray = nodeIsTypedArray ? _baseUnary(nodeIsTypedArray) : _baseIsTypedArray;

    var isTypedArray_1 = isTypedArray;

    /** Used for built-in method references. */
    var objectProto$5 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$4 = objectProto$5.hasOwnProperty;

    /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray_1(value),
          isArg = !isArr && isArguments_1(value),
          isBuff = !isArr && !isArg && isBuffer_1(value),
          isType = !isArr && !isArg && !isBuff && isTypedArray_1(value),
          skipIndexes = isArr || isArg || isBuff || isType,
          result = skipIndexes ? _baseTimes(value.length, String) : [],
          length = result.length;

      for (var key in value) {
        if ((inherited || hasOwnProperty$4.call(value, key)) &&
            !(skipIndexes && (
               // Safari 9 has enumerable `arguments.length` in strict mode.
               key == 'length' ||
               // Node.js 0.10 has enumerable non-index properties on buffers.
               (isBuff && (key == 'offset' || key == 'parent')) ||
               // PhantomJS 2 has enumerable non-index properties on typed arrays.
               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
               // Skip index properties.
               _isIndex(key, length)
            ))) {
          result.push(key);
        }
      }
      return result;
    }

    var _arrayLikeKeys = arrayLikeKeys;

    /** Used for built-in method references. */
    var objectProto$6 = Object.prototype;

    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */
    function isPrototype(value) {
      var Ctor = value && value.constructor,
          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$6;

      return value === proto;
    }

    var _isPrototype = isPrototype;

    /**
     * This function is like
     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * except that it includes inherited enumerable properties.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }

    var _nativeKeysIn = nativeKeysIn;

    /** Used for built-in method references. */
    var objectProto$7 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$5 = objectProto$7.hasOwnProperty;

    /**
     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeysIn(object) {
      if (!isObject_1(object)) {
        return _nativeKeysIn(object);
      }
      var isProto = _isPrototype(object),
          result = [];

      for (var key in object) {
        if (!(key == 'constructor' && (isProto || !hasOwnProperty$5.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }

    var _baseKeysIn = baseKeysIn;

    /**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */
    function keysIn(object) {
      return isArrayLike_1(object) ? _arrayLikeKeys(object, true) : _baseKeysIn(object);
    }

    var keysIn_1 = keysIn;

    /**
     * This method is like `_.assign` except that it iterates over own and
     * inherited source properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assign
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
     */
    var assignIn = _createAssigner(function(object, source) {
      _copyObject(source, keysIn_1(source), object);
    });

    var assignIn_1 = assignIn;

    var extend = assignIn_1;

    /**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }

    var _listCacheClear = listCacheClear;

    /**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq_1(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }

    var _assocIndexOf = assocIndexOf;

    /** Used for built-in method references. */
    var arrayProto = Array.prototype;

    /** Built-in value references. */
    var splice = arrayProto.splice;

    /**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function listCacheDelete(key) {
      var data = this.__data__,
          index = _assocIndexOf(data, key);

      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }

    var _listCacheDelete = listCacheDelete;

    /**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function listCacheGet(key) {
      var data = this.__data__,
          index = _assocIndexOf(data, key);

      return index < 0 ? undefined : data[index][1];
    }

    var _listCacheGet = listCacheGet;

    /**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function listCacheHas(key) {
      return _assocIndexOf(this.__data__, key) > -1;
    }

    var _listCacheHas = listCacheHas;

    /**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */
    function listCacheSet(key, value) {
      var data = this.__data__,
          index = _assocIndexOf(data, key);

      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }

    var _listCacheSet = listCacheSet;

    /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function ListCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    // Add methods to `ListCache`.
    ListCache.prototype.clear = _listCacheClear;
    ListCache.prototype['delete'] = _listCacheDelete;
    ListCache.prototype.get = _listCacheGet;
    ListCache.prototype.has = _listCacheHas;
    ListCache.prototype.set = _listCacheSet;

    var _ListCache = ListCache;

    /**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */
    function stackClear() {
      this.__data__ = new _ListCache;
      this.size = 0;
    }

    var _stackClear = stackClear;

    /**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function stackDelete(key) {
      var data = this.__data__,
          result = data['delete'](key);

      this.size = data.size;
      return result;
    }

    var _stackDelete = stackDelete;

    /**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function stackGet(key) {
      return this.__data__.get(key);
    }

    var _stackGet = stackGet;

    /**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function stackHas(key) {
      return this.__data__.has(key);
    }

    var _stackHas = stackHas;

    /* Built-in method references that are verified to be native. */
    var Map$1 = _getNative(_root, 'Map');

    var _Map = Map$1;

    /* Built-in method references that are verified to be native. */
    var nativeCreate = _getNative(Object, 'create');

    var _nativeCreate = nativeCreate;

    /**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */
    function hashClear() {
      this.__data__ = _nativeCreate ? _nativeCreate(null) : {};
      this.size = 0;
    }

    var _hashClear = hashClear;

    /**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }

    var _hashDelete = hashDelete;

    /** Used to stand-in for `undefined` hash values. */
    var HASH_UNDEFINED = '__lodash_hash_undefined__';

    /** Used for built-in method references. */
    var objectProto$8 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$6 = objectProto$8.hasOwnProperty;

    /**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function hashGet(key) {
      var data = this.__data__;
      if (_nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
      }
      return hasOwnProperty$6.call(data, key) ? data[key] : undefined;
    }

    var _hashGet = hashGet;

    /** Used for built-in method references. */
    var objectProto$9 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$7 = objectProto$9.hasOwnProperty;

    /**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function hashHas(key) {
      var data = this.__data__;
      return _nativeCreate ? (data[key] !== undefined) : hasOwnProperty$7.call(data, key);
    }

    var _hashHas = hashHas;

    /** Used to stand-in for `undefined` hash values. */
    var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

    /**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = (_nativeCreate && value === undefined) ? HASH_UNDEFINED$1 : value;
      return this;
    }

    var _hashSet = hashSet;

    /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Hash(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    // Add methods to `Hash`.
    Hash.prototype.clear = _hashClear;
    Hash.prototype['delete'] = _hashDelete;
    Hash.prototype.get = _hashGet;
    Hash.prototype.has = _hashHas;
    Hash.prototype.set = _hashSet;

    var _Hash = Hash;

    /**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        'hash': new _Hash,
        'map': new (_Map || _ListCache),
        'string': new _Hash
      };
    }

    var _mapCacheClear = mapCacheClear;

    /**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */
    function isKeyable(value) {
      var type = typeof value;
      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
        ? (value !== '__proto__')
        : (value === null);
    }

    var _isKeyable = isKeyable;

    /**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */
    function getMapData(map, key) {
      var data = map.__data__;
      return _isKeyable(key)
        ? data[typeof key == 'string' ? 'string' : 'hash']
        : data.map;
    }

    var _getMapData = getMapData;

    /**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function mapCacheDelete(key) {
      var result = _getMapData(this, key)['delete'](key);
      this.size -= result ? 1 : 0;
      return result;
    }

    var _mapCacheDelete = mapCacheDelete;

    /**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function mapCacheGet(key) {
      return _getMapData(this, key).get(key);
    }

    var _mapCacheGet = mapCacheGet;

    /**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapCacheHas(key) {
      return _getMapData(this, key).has(key);
    }

    var _mapCacheHas = mapCacheHas;

    /**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */
    function mapCacheSet(key, value) {
      var data = _getMapData(this, key),
          size = data.size;

      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }

    var _mapCacheSet = mapCacheSet;

    /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function MapCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    // Add methods to `MapCache`.
    MapCache.prototype.clear = _mapCacheClear;
    MapCache.prototype['delete'] = _mapCacheDelete;
    MapCache.prototype.get = _mapCacheGet;
    MapCache.prototype.has = _mapCacheHas;
    MapCache.prototype.set = _mapCacheSet;

    var _MapCache = MapCache;

    /** Used as the size to enable large array optimizations. */
    var LARGE_ARRAY_SIZE = 200;

    /**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof _ListCache) {
        var pairs = data.__data__;
        if (!_Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new _MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }

    var _stackSet = stackSet;

    /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Stack(entries) {
      var data = this.__data__ = new _ListCache(entries);
      this.size = data.size;
    }

    // Add methods to `Stack`.
    Stack.prototype.clear = _stackClear;
    Stack.prototype['delete'] = _stackDelete;
    Stack.prototype.get = _stackGet;
    Stack.prototype.has = _stackHas;
    Stack.prototype.set = _stackSet;

    var _Stack = Stack;

    /**
     * This function is like `assignValue` except that it doesn't assign
     * `undefined` values.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignMergeValue(object, key, value) {
      if ((value !== undefined && !eq_1(object[key], value)) ||
          (value === undefined && !(key in object))) {
        _baseAssignValue(object, key, value);
      }
    }

    var _assignMergeValue = assignMergeValue;

    /**
     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1,
            iterable = Object(object),
            props = keysFunc(object),
            length = props.length;

        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }

    var _createBaseFor = createBaseFor;

    /**
     * The base implementation of `baseForOwn` which iterates over `object`
     * properties returned by `keysFunc` and invokes `iteratee` for each property.
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseFor = _createBaseFor();

    var _baseFor = baseFor;

    var _cloneBuffer = createCommonjsModule(function (module, exports) {
    /** Detect free variable `exports`. */
    var freeExports = 'object' == 'object' && exports && !exports.nodeType && exports;

    /** Detect free variable `module`. */
    var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

    /** Detect the popular CommonJS extension `module.exports`. */
    var moduleExports = freeModule && freeModule.exports === freeExports;

    /** Built-in value references. */
    var Buffer = moduleExports ? _root.Buffer : undefined,
        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

    /**
     * Creates a clone of  `buffer`.
     *
     * @private
     * @param {Buffer} buffer The buffer to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Buffer} Returns the cloned buffer.
     */
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length,
          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

      buffer.copy(result);
      return result;
    }

    module.exports = cloneBuffer;
    });

    /** Built-in value references. */
    var Uint8Array = _root.Uint8Array;

    var _Uint8Array = Uint8Array;

    /**
     * Creates a clone of `arrayBuffer`.
     *
     * @private
     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new _Uint8Array(result).set(new _Uint8Array(arrayBuffer));
      return result;
    }

    var _cloneArrayBuffer = cloneArrayBuffer;

    /**
     * Creates a clone of `typedArray`.
     *
     * @private
     * @param {Object} typedArray The typed array to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned typed array.
     */
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? _cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }

    var _cloneTypedArray = cloneTypedArray;

    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function copyArray(source, array) {
      var index = -1,
          length = source.length;

      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }

    var _copyArray = copyArray;

    /** Built-in value references. */
    var objectCreate = Object.create;

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} proto The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    var baseCreate = (function() {
      function object() {}
      return function(proto) {
        if (!isObject_1(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object;
        object.prototype = undefined;
        return result;
      };
    }());

    var _baseCreate = baseCreate;

    /**
     * Creates a unary function that invokes `func` with its argument transformed.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {Function} transform The argument transform.
     * @returns {Function} Returns the new function.
     */
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }

    var _overArg = overArg;

    /** Built-in value references. */
    var getPrototype = _overArg(Object.getPrototypeOf, Object);

    var _getPrototype = getPrototype;

    /**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneObject(object) {
      return (typeof object.constructor == 'function' && !_isPrototype(object))
        ? _baseCreate(_getPrototype(object))
        : {};
    }

    var _initCloneObject = initCloneObject;

    /**
     * This method is like `_.isArrayLike` except that it also checks if `value`
     * is an object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array-like object,
     *  else `false`.
     * @example
     *
     * _.isArrayLikeObject([1, 2, 3]);
     * // => true
     *
     * _.isArrayLikeObject(document.body.children);
     * // => true
     *
     * _.isArrayLikeObject('abc');
     * // => false
     *
     * _.isArrayLikeObject(_.noop);
     * // => false
     */
    function isArrayLikeObject(value) {
      return isObjectLike_1(value) && isArrayLike_1(value);
    }

    var isArrayLikeObject_1 = isArrayLikeObject;

    /** `Object#toString` result references. */
    var objectTag$1 = '[object Object]';

    /** Used for built-in method references. */
    var funcProto$2 = Function.prototype,
        objectProto$10 = Object.prototype;

    /** Used to resolve the decompiled source of functions. */
    var funcToString$2 = funcProto$2.toString;

    /** Used to check objects for own properties. */
    var hasOwnProperty$8 = objectProto$10.hasOwnProperty;

    /** Used to infer the `Object` constructor. */
    var objectCtorString = funcToString$2.call(Object);

    /**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * @static
     * @memberOf _
     * @since 0.8.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */
    function isPlainObject(value) {
      if (!isObjectLike_1(value) || _baseGetTag(value) != objectTag$1) {
        return false;
      }
      var proto = _getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty$8.call(proto, 'constructor') && proto.constructor;
      return typeof Ctor == 'function' && Ctor instanceof Ctor &&
        funcToString$2.call(Ctor) == objectCtorString;
    }

    var isPlainObject_1 = isPlainObject;

    /**
     * Gets the value at `key`, unless `key` is "__proto__".
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */
    function safeGet(object, key) {
      return key == '__proto__'
        ? undefined
        : object[key];
    }

    var _safeGet = safeGet;

    /**
     * Converts `value` to a plain object flattening inherited enumerable string
     * keyed properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */
    function toPlainObject(value) {
      return _copyObject(value, keysIn_1(value));
    }

    var toPlainObject_1 = toPlainObject;

    /**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = _safeGet(object, key),
          srcValue = _safeGet(source, key),
          stacked = stack.get(srcValue);

      if (stacked) {
        _assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer
        ? customizer(objValue, srcValue, (key + ''), object, source, stack)
        : undefined;

      var isCommon = newValue === undefined;

      if (isCommon) {
        var isArr = isArray_1(srcValue),
            isBuff = !isArr && isBuffer_1(srcValue),
            isTyped = !isArr && !isBuff && isTypedArray_1(srcValue);

        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray_1(objValue)) {
            newValue = objValue;
          }
          else if (isArrayLikeObject_1(objValue)) {
            newValue = _copyArray(objValue);
          }
          else if (isBuff) {
            isCommon = false;
            newValue = _cloneBuffer(srcValue, true);
          }
          else if (isTyped) {
            isCommon = false;
            newValue = _cloneTypedArray(srcValue, true);
          }
          else {
            newValue = [];
          }
        }
        else if (isPlainObject_1(srcValue) || isArguments_1(srcValue)) {
          newValue = objValue;
          if (isArguments_1(objValue)) {
            newValue = toPlainObject_1(objValue);
          }
          else if (!isObject_1(objValue) || (srcIndex && isFunction_1(objValue))) {
            newValue = _initCloneObject(srcValue);
          }
        }
        else {
          isCommon = false;
        }
      }
      if (isCommon) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack['delete'](srcValue);
      }
      _assignMergeValue(object, key, newValue);
    }

    var _baseMergeDeep = baseMergeDeep;

    /**
     * The base implementation of `_.merge` without support for multiple sources.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      _baseFor(source, function(srcValue, key) {
        if (isObject_1(srcValue)) {
          stack || (stack = new _Stack);
          _baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        }
        else {
          var newValue = customizer
            ? customizer(_safeGet(object, key), srcValue, (key + ''), object, source, stack)
            : undefined;

          if (newValue === undefined) {
            newValue = srcValue;
          }
          _assignMergeValue(object, key, newValue);
        }
      }, keysIn_1);
    }

    var _baseMerge = baseMerge;

    /**
     * This method is like `_.assign` except that it recursively merges own and
     * inherited enumerable string keyed properties of source objects into the
     * destination object. Source properties that resolve to `undefined` are
     * skipped if a destination value exists. Array and plain object properties
     * are merged recursively. Other objects and value types are overridden by
     * assignment. Source objects are applied from left to right. Subsequent
     * sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {
     *   'a': [{ 'b': 2 }, { 'd': 4 }]
     * };
     *
     * var other = {
     *   'a': [{ 'c': 3 }, { 'e': 5 }]
     * };
     *
     * _.merge(object, other);
     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
     */
    var merge = _createAssigner(function(object, source, srcIndex) {
      _baseMerge(object, source, srcIndex);
    });

    var merge_1 = merge;

    /**
     * A specialized version of `_.forEach` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns `array`.
     */
    function arrayEach(array, iteratee) {
      var index = -1,
          length = array == null ? 0 : array.length;

      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }

    var _arrayEach = arrayEach;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeKeys = _overArg(Object.keys, Object);

    var _nativeKeys = nativeKeys;

    /** Used for built-in method references. */
    var objectProto$11 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$9 = objectProto$11.hasOwnProperty;

    /**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeys(object) {
      if (!_isPrototype(object)) {
        return _nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty$9.call(object, key) && key != 'constructor') {
          result.push(key);
        }
      }
      return result;
    }

    var _baseKeys = baseKeys;

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    function keys(object) {
      return isArrayLike_1(object) ? _arrayLikeKeys(object) : _baseKeys(object);
    }

    var keys_1 = keys;

    /**
     * The base implementation of `_.forOwn` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwn(object, iteratee) {
      return object && _baseFor(object, iteratee, keys_1);
    }

    var _baseForOwn = baseForOwn;

    /**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike_1(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length,
            index = fromRight ? length : -1,
            iterable = Object(collection);

        while ((fromRight ? index-- : ++index < length)) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }

    var _createBaseEach = createBaseEach;

    /**
     * The base implementation of `_.forEach` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
    var baseEach = _createBaseEach(_baseForOwn);

    var _baseEach = baseEach;

    /**
     * Casts `value` to `identity` if it's not a function.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Function} Returns cast function.
     */
    function castFunction(value) {
      return typeof value == 'function' ? value : identity_1;
    }

    var _castFunction = castFunction;

    /**
     * Iterates over elements of `collection` and invokes `iteratee` for each element.
     * The iteratee is invoked with three arguments: (value, index|key, collection).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a "length"
     * property are iterated like arrays. To avoid this behavior use `_.forIn`
     * or `_.forOwn` for object iteration.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias each
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEachRight
     * @example
     *
     * _.forEach([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `1` then `2`.
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */
    function forEach(collection, iteratee) {
      var func = isArray_1(collection) ? _arrayEach : _baseEach;
      return func(collection, _castFunction(iteratee));
    }

    var forEach_1 = forEach;

    var each = forEach_1;

    function MergeClasses (Vue, options) {
      Vue.prototype.$mergeClasses = function () {
        var classes = {};

        each([].slice.call(arguments), function (arg) {
          if (isObject_1(arg)) {
            extend(classes, arg);
          } else if (isArray_1(arg)) {
            merge_1(classes, arg);
          } else if (arg) {
            classes[arg] = true;
          }
        });

        return classes;
      };
    }

    var Overlay = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "overlay",
          class: {
            'show': _vm.isVisible
          },
          style: {
            background: _vm.background
          },
          on: {
            "keyup": function keyup($event) {
              if (!('button' in $event) && _vm._k($event.keyCode, "esc", 27, $event.key, "Escape")) {
                return null;
              }

              return _vm.hide($event);
            }
          }
        }, [_vm.closeButton ? _c('button', {
          staticClass: "btn btn-link overlay-close",
          attrs: {
            "type": "button"
          },
          on: {
            "click": _vm.onClickClose
          }
        }, [_c('i', {
          staticClass: "fa fa-times-circle"
        })]) : _vm._e(), _vm._v(" "), _c('div', {
          staticClass: "overlay-content container",
          class: {
            'fixed': _vm.fixedContent
          },
          style: {
            minHeight: _vm.minHeight
          }
        }, [_vm._t("default")], 2)]);
      },
      staticRenderFns: [],
      name: 'overlay',
      props: {
        /**
         * The overlay background color.
         *
         * @property String
         */
        background: {
          type: String,
          default: 'rgba(255, 255, 255, .925)'
        },

        /**
         * Is the overlay showing.
         *
         * @property Boolean
         */
        visible: Boolean,

        /**
         * Is the overlay content fixed position
         *
         * @property Boolean
         */
        fixedContent: Boolean,

        /**
         * Is the overlay content fixed position
         *
         * @property Boolean
         */
        closeButton: {
          type: Boolean,
          default: true
        },

        /**
         * Is the overlay content minimum height.
         *
         * @property Boolean
         */
        minHeight: [String, Number]
      },
      watch: {
        visible: function visible(value) {
          (this.isVisible = value) && this.focus();
        }
      },
      methods: {
        focus: function focus() {
          var el = this.$el.querySelector('.form-control, input, select, textarea');

          if (el) {
            el.focus();
          }
        },

        /**
         * Show the overlay
         *
         * @return void
         */
        show: function show(contents, options) {
          this.$mount(document.body.appendChild(document.createElement('div')));

          if (contents.$mount) {
            contents.$parent = this;
            contents.$mount(this.$el.querySelector('.overlay-content').appendChild(document.createElement('div')));
          }

          this.focus();
          this.$emit('show');
          this.$emit('update:visible', this.isVisible = true);
        },

        /**
         * Hide the overlay
         *
         * @return void
         */
        hide: function hide() {
          this.$emit('hide');
          this.$emit('update:visible', this.isVisible = false);
        },

        /**
         * The callback for the `click` event on the close button.
         *
         * @return void
         */
        onClickClose: function onClickClose() {
          this.$emit('click:close');
          this.hide();
        }
      },
      mounted: function mounted() {
        this.visible && this.focus();
      },
      data: function data() {
        return {
          isVisible: this.visible
        };
      }
    };

    function overlay (Vue, options) {
      Vue.prototype.$overlay = function (ContentComponent, options, overlayOptions, OverlayComponent) {
        var _this = this;

        var component = function component(vue, options) {
          if (!(vue instanceof Vue) && isObject_1(vue)) {
            vue = Vue.extend(vue);
            vue.options.route = _this.$route;
            vue.options.router = _this.$router;
          }

          return isFunction_1(vue) ? new vue(options) : vue;
        };

        var overlay = component(OverlayComponent || Overlay, overlayOptions);
        overlay.$content = component(ContentComponent, options);
        overlay.show(overlay.$content);
        return overlay;
      };
    }



    var plugins = /*#__PURE__*/Object.freeze({
        mergeClasses: MergeClasses,
        overlay: overlay
    });

    /**
     * A specialized version of `_.reduce` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {boolean} [initAccum] Specify using the first element of `array` as
     *  the initial value.
     * @returns {*} Returns the accumulated value.
     */
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1,
          length = array == null ? 0 : array.length;

      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }

    var _arrayReduce = arrayReduce;

    /**
     * The base implementation of `_.propertyOf` without support for deep paths.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new accessor function.
     */
    function basePropertyOf(object) {
      return function(key) {
        return object == null ? undefined : object[key];
      };
    }

    var _basePropertyOf = basePropertyOf;

    /** Used to map Latin Unicode letters to basic Latin letters. */
    var deburredLetters = {
      // Latin-1 Supplement block.
      '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
      '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
      '\xc7': 'C',  '\xe7': 'c',
      '\xd0': 'D',  '\xf0': 'd',
      '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
      '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
      '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
      '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
      '\xd1': 'N',  '\xf1': 'n',
      '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
      '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
      '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
      '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
      '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
      '\xc6': 'Ae', '\xe6': 'ae',
      '\xde': 'Th', '\xfe': 'th',
      '\xdf': 'ss',
      // Latin Extended-A block.
      '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
      '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
      '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
      '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
      '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
      '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
      '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
      '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
      '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
      '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
      '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
      '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
      '\u0134': 'J',  '\u0135': 'j',
      '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
      '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
      '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
      '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
      '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
      '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
      '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
      '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
      '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
      '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
      '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
      '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
      '\u0163': 't',  '\u0165': 't', '\u0167': 't',
      '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
      '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
      '\u0174': 'W',  '\u0175': 'w',
      '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
      '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
      '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
      '\u0132': 'IJ', '\u0133': 'ij',
      '\u0152': 'Oe', '\u0153': 'oe',
      '\u0149': "'n", '\u017f': 's'
    };

    /**
     * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
     * letters to basic Latin letters.
     *
     * @private
     * @param {string} letter The matched letter to deburr.
     * @returns {string} Returns the deburred letter.
     */
    var deburrLetter = _basePropertyOf(deburredLetters);

    var _deburrLetter = deburrLetter;

    /**
     * A specialized version of `_.map` for arrays without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function arrayMap(array, iteratee) {
      var index = -1,
          length = array == null ? 0 : array.length,
          result = Array(length);

      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }

    var _arrayMap = arrayMap;

    /** `Object#toString` result references. */
    var symbolTag = '[object Symbol]';

    /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */
    function isSymbol(value) {
      return typeof value == 'symbol' ||
        (isObjectLike_1(value) && _baseGetTag(value) == symbolTag);
    }

    var isSymbol_1 = isSymbol;

    /** Used as references for various `Number` constants. */
    var INFINITY = 1 / 0;

    /** Used to convert symbols to primitives and strings. */
    var symbolProto = _Symbol ? _Symbol.prototype : undefined,
        symbolToString = symbolProto ? symbolProto.toString : undefined;

    /**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */
    function baseToString(value) {
      // Exit early for strings to avoid a performance hit in some environments.
      if (typeof value == 'string') {
        return value;
      }
      if (isArray_1(value)) {
        // Recursively convert values (susceptible to call stack limits).
        return _arrayMap(value, baseToString) + '';
      }
      if (isSymbol_1(value)) {
        return symbolToString ? symbolToString.call(value) : '';
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }

    var _baseToString = baseToString;

    /**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */
    function toString(value) {
      return value == null ? '' : _baseToString(value);
    }

    var toString_1 = toString;

    /** Used to match Latin Unicode letters (excluding mathematical operators). */
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

    /** Used to compose unicode character classes. */
    var rsComboMarksRange = '\\u0300-\\u036f',
        reComboHalfMarksRange = '\\ufe20-\\ufe2f',
        rsComboSymbolsRange = '\\u20d0-\\u20ff',
        rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;

    /** Used to compose unicode capture groups. */
    var rsCombo = '[' + rsComboRange + ']';

    /**
     * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
     * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
     */
    var reComboMark = RegExp(rsCombo, 'g');

    /**
     * Deburrs `string` by converting
     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
     * letters to basic Latin letters and removing
     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('déjà vu');
     * // => 'deja vu'
     */
    function deburr(string) {
      string = toString_1(string);
      return string && string.replace(reLatin, _deburrLetter).replace(reComboMark, '');
    }

    var deburr_1 = deburr;

    /** Used to match words composed of alphanumeric characters. */
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

    /**
     * Splits an ASCII `string` into an array of its words.
     *
     * @private
     * @param {string} The string to inspect.
     * @returns {Array} Returns the words of `string`.
     */
    function asciiWords(string) {
      return string.match(reAsciiWord) || [];
    }

    var _asciiWords = asciiWords;

    /** Used to detect strings that need a more robust regexp to match words. */
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

    /**
     * Checks if `string` contains a word composed of Unicode symbols.
     *
     * @private
     * @param {string} string The string to inspect.
     * @returns {boolean} Returns `true` if a word is found, else `false`.
     */
    function hasUnicodeWord(string) {
      return reHasUnicodeWord.test(string);
    }

    var _hasUnicodeWord = hasUnicodeWord;

    /** Used to compose unicode character classes. */
    var rsAstralRange = '\\ud800-\\udfff',
        rsComboMarksRange$1 = '\\u0300-\\u036f',
        reComboHalfMarksRange$1 = '\\ufe20-\\ufe2f',
        rsComboSymbolsRange$1 = '\\u20d0-\\u20ff',
        rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1,
        rsDingbatRange = '\\u2700-\\u27bf',
        rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
        rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
        rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
        rsPunctuationRange = '\\u2000-\\u206f',
        rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
        rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
        rsVarRange = '\\ufe0e\\ufe0f',
        rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

    /** Used to compose unicode capture groups. */
    var rsApos = "['\u2019]",
        rsBreak = '[' + rsBreakRange + ']',
        rsCombo$1 = '[' + rsComboRange$1 + ']',
        rsDigits = '\\d+',
        rsDingbat = '[' + rsDingbatRange + ']',
        rsLower = '[' + rsLowerRange + ']',
        rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
        rsFitz = '\\ud83c[\\udffb-\\udfff]',
        rsModifier = '(?:' + rsCombo$1 + '|' + rsFitz + ')',
        rsNonAstral = '[^' + rsAstralRange + ']',
        rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
        rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
        rsUpper = '[' + rsUpperRange + ']',
        rsZWJ = '\\u200d';

    /** Used to compose unicode regexes. */
    var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
        rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
        rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
        rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
        reOptMod = rsModifier + '?',
        rsOptVar = '[' + rsVarRange + ']?',
        rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
        rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
        rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
        rsSeq = rsOptVar + reOptMod + rsOptJoin,
        rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq;

    /** Used to match complex or compound words. */
    var reUnicodeWord = RegExp([
      rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
      rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
      rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
      rsUpper + '+' + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join('|'), 'g');

    /**
     * Splits a Unicode `string` into an array of its words.
     *
     * @private
     * @param {string} The string to inspect.
     * @returns {Array} Returns the words of `string`.
     */
    function unicodeWords(string) {
      return string.match(reUnicodeWord) || [];
    }

    var _unicodeWords = unicodeWords;

    /**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */
    function words(string, pattern, guard) {
      string = toString_1(string);
      pattern = guard ? undefined : pattern;

      if (pattern === undefined) {
        return _hasUnicodeWord(string) ? _unicodeWords(string) : _asciiWords(string);
      }
      return string.match(pattern) || [];
    }

    var words_1 = words;

    /** Used to compose unicode capture groups. */
    var rsApos$1 = "['\u2019]";

    /** Used to match apostrophes. */
    var reApos = RegExp(rsApos$1, 'g');

    /**
     * Creates a function like `_.camelCase`.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */
    function createCompounder(callback) {
      return function(string) {
        return _arrayReduce(words_1(deburr_1(string).replace(reApos, '')), callback, '');
      };
    }

    var _createCompounder = createCompounder;

    /**
     * Converts `string` to
     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__FOO_BAR__');
     * // => 'foo-bar'
     */
    var kebabCase = _createCompounder(function(result, word, index) {
      return result + (index ? '-' : '') + word.toLowerCase();
    });

    var kebabCase_1 = kebabCase;

    var BaseType = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "activity-indicator",
          class: _vm.classes
        }, _vm._l(_vm.nodes, function (i) {
          return _c('div');
        }));
      },
      staticRenderFns: [],
      props: {
        nodes: {
          type: Number,
          default: 3
        },
        size: {
          type: String,
          default: ''
        },
        prefix: {
          type: String,
          default: 'activity-indicator-'
        }
      },
      computed: {
        classes: function classes() {
          var classes = {};
          classes[this.$options.name] = !!this.$options.name;
          classes[this.prefix + this.size.replace(this.prefix, '')] = !!this.size;
          return classes;
        }
      }
    };

    var ActivityIndicatorDots = {
      name: 'activity-indicator-dots',
      extends: BaseType
    };

    var ActivityIndicatorSpinner = {
      name: 'activity-indicator-spinner',
      extends: BaseType,
      props: extend({}, BaseType.props, {
        nodes: {
          type: Number,
          default: 12
        }
      })
    };

    var ActivityIndicator = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _vm.center ? _c('div', {
          staticClass: "center-wrapper"
        }, [_c('div', {
          staticClass: "center-content"
        }, [_c(_vm.component, {
          tag: "component",
          attrs: {
            "size": _vm.size,
            "prefix": _vm.prefix
          }
        })], 1)]) : _c(_vm.component, {
          tag: "component",
          attrs: {
            "size": _vm.size,
            "prefix": _vm.prefix
          }
        });
      },
      staticRenderFns: [],
      name: 'activity-indicator',
      extends: BaseType,
      props: {
        center: {
          type: Boolean,
          default: false
        },
        type: {
          type: String,
          default: 'dots'
        }
      },
      components: {
        ActivityIndicatorDots: ActivityIndicatorDots,
        ActivityIndicatorSpinner: ActivityIndicatorSpinner
      },
      computed: {
        component: function component() {
          return kebabCase_1(this.prefix + this.type.replace(this.prefix, ''));
        }
      }
    };

    var loaded = {};

    function element(url) {
      var script = document.createElement('script');
      script.setAttribute('src', url);
      script.setAttribute('type', 'text/javascript');
      script.setAttribute('charset', 'utf-8');
      return script;
    }

    function append(script) {
      if (document.querySelector('head')) {
        document.querySelector('head').appendChild(script);
      } else {
        document.querySelector('body').appendChild(script);
      }

      return script;
    }

    function script(url) {
      return new Promise(function (resolve, reject) {
        try {
          if (!loaded[url]) {
            append(element(url)).addEventListener('load', function (e) {
              resolve(loaded[url] = e);
            });
          } else {
            resolve(loaded[url]);
          }
        } catch (e) {
          reject(e);
        }
      });
    }

    var VueInstaller = {
      use: use,
      script: script,
      plugin: plugin,
      plugins: plugins$1,
      filter: filter,
      filters: filters$1,
      component: component,
      components: components,
      directive: directive,
      directives: directives,
      $plugins: {},
      $filters: {},
      $directives: {},
      $components: {}
    };
    function use(plugin) {
      if (typeof window !== 'undefined' && window.Vue) {
        window.Vue.use(plugin);
      }

      return plugin;
    }
    function plugin(Vue, name, def) {
      if (!VueInstaller.$plugins[name]) {
        Vue.use(VueInstaller.$plugins[name] = def);
      }
    }
    function plugins$1(Vue, plugins) {
      each(plugins, function (def, name) {
        plugin(Vue, name, def);
      });
    }
    function filter(Vue, name, def) {
      if (!VueInstaller.$filters[name]) {
        Vue.use(VueInstaller.$filters[name] = def);
      }
    }
    function filters$1(Vue, filters) {
      each(filters, function (def, name) {
        filter(Vue, name, def);
      });
    }
    function component(Vue, name, def) {
      if (!VueInstaller.$components[name]) {
        Vue.component(name, VueInstaller.$components[name] = def);
      }
    }
    function components(Vue, components) {
      each(components, function (def, name) {
        component(Vue, name, def);
      });
    }
    function directive(Vue, name, def) {
      if (!VueInstaller.$directives[name]) {
        Vue.directive(name, VueInstaller.$directives[name] = def);
      }
    }
    function directives(Vue, directives) {
      each(directives, function (def, name) {
        directive(Vue, name, def);
      });
    }

    var plugin$1 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          ActivityIndicator: ActivityIndicator
        });
      }
    });

    var convertAnimationDelayToInt = function convertAnimationDelayToInt(delay) {
      var num = parseFloat(delay, 10);
      var matches = delay.match(/m?s/);
      var unit = matches ? matches[0] : false;
      var milliseconds;

      switch (unit) {
        case "s":
          // seconds
          milliseconds = num * 1000;
          break;

        case "ms":
        default:
          milliseconds = num;
          break;
      }

      return milliseconds || 0;
    };

    var animated = function animated(el, callback) {
      var defaultView = (el.ownerDocument || document).defaultView;
      setTimeout(function () {
        callback.apply();
      }, convertAnimationDelayToInt(defaultView.getComputedStyle(el).animationDuration));
    };

    var ActivityButton = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('button', {
          staticClass: "btn",
          class: _vm.classes,
          attrs: {
            "type": _vm.type
          },
          on: {
            "click": _vm.onClick
          }
        }, [_vm._t("default", [_vm.icon ? _c('i', {
          class: _vm.icon
        }) : _vm._e(), _vm._v(" " + _vm._s(_vm.label))]), _vm._v(" "), _c('activity-indicator', {
          attrs: {
            "type": _vm.indicator
          }
        })], 2);
      },
      staticRenderFns: [],
      name: 'activity-button',
      components: {
        ActivityIndicator: ActivityIndicator
      },
      props: {
        /**
         * Should show the activity indicator inside the button.
         *
         * @property Boolean
         */
        activity: Boolean,

        /**
         * Should show the button as disabled.
         *
         * @property Boolean
         */
        disabled: Boolean,

        /**
         * Display the button as block width.
         *
         * @property Boolean
         */
        block: Boolean,

        /**
         * The button label. If not passed as a property, label must be passed
         * inside the element's html.
         *
         * @property String
         */
        label: String,

        /**
         * The button icon
         *
         * @property String
         */
        icon: String,

        /**
         * The size of the button.
         *
         * @property String
         */
        size: {
          type: String,
          default: 'md'
        },

        /**
         * The bootstrap variant of the button.
         *
         * @property String
         */
        variant: {
          type: String,
          default: 'primary'
        },

        /**
         * The `type` attribute for the button.
         *
         * @property String
         */
        type: {
          type: String,
          default: 'button'
        },

        /**
         * The type of activity indicator inside the button.
         *
         * @property String
         */
        indicator: {
          type: String,
          default: 'spinner'
        },

        /**
         * The orientation of the activity button inside the button.
         *
         * @property String
         */
        orientation: {
          type: String,
          default: 'right'
        }
      },
      methods: {
        /**
         * Disable the button.
         *
         * @return void
         */
        disable: function disable() {
          this.$el.disabled = true;
        },

        /**
         * Enable the button.
         *
         * @return void
         */
        enable: function enable() {
          this.$el.disabled = false;
        },

        /**
         * Show the activity indicator inside the button.
         *
         * @return void
         */
        showActivity: function showActivity() {
          var _this = this;

          this.disable();
          animated(this.$el, function () {
            _this.$el.classList.add('btn-activity');

            _this.$emit('activity:show');
          });
        },

        /**
         * Hide the activity indicator inside the button.
         *
         * @return void
         */
        hideActivity: function hideActivity() {
          var _this2 = this;

          this.$el.classList.add('btn-hide-activity');
          animated(this.$el, function () {
            _this2.enable();

            _this2.$el.classList.remove('btn-activity', 'btn-hide-activity');

            _this2.$emit('activity:hide');
          });
        },

        /**
         * Disable the button.
         *
         * @return void
         */
        onClick: function onClick(event) {
          this.$emit('click', event, this);
        }
      },
      computed: {
        /**
         * An object of classes to append to the button.
         *
         * @return void
         */
        classes: function classes() {
          var classes = {
            'btn-block': this.block,
            'btn-activity': this.activity
          };
          classes['btn-' + this.size.replace('btn-', '')] = !!this.size;
          classes['btn-' + this.variant.replace('btn-', '')] = !!this.variant;
          classes['btn-activity-' + this.orientation.replace('btn-activity-', '')] = !!this.orientation;
          classes['btn-activity-indicator-' + this.indicator.replace('btn-activity-indicator-', '')] = !!this.indicator;
          return classes;
        }
      },
      watch: {
        activity: function activity(value) {
          if (value) {
            this.showActivity();
          } else {
            this.hideActivity();
          }
        }
      }
    };

    var plugin$2 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          ActivityButton: ActivityButton
        });
      }
    });

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */
    function isUndefined(value) {
      return value === undefined;
    }

    var isUndefined_1 = isUndefined;

    /** Used to stand-in for `undefined` hash values. */
    var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

    /**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED$2);
      return this;
    }

    var _setCacheAdd = setCacheAdd;

    /**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */
    function setCacheHas(value) {
      return this.__data__.has(value);
    }

    var _setCacheHas = setCacheHas;

    /**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */
    function SetCache(values) {
      var index = -1,
          length = values == null ? 0 : values.length;

      this.__data__ = new _MapCache;
      while (++index < length) {
        this.add(values[index]);
      }
    }

    // Add methods to `SetCache`.
    SetCache.prototype.add = SetCache.prototype.push = _setCacheAdd;
    SetCache.prototype.has = _setCacheHas;

    var _SetCache = SetCache;

    /**
     * A specialized version of `_.some` for arrays without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function arraySome(array, predicate) {
      var index = -1,
          length = array == null ? 0 : array.length;

      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }

    var _arraySome = arraySome;

    /**
     * Checks if a `cache` value for `key` exists.
     *
     * @private
     * @param {Object} cache The cache to query.
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function cacheHas(cache, key) {
      return cache.has(key);
    }

    var _cacheHas = cacheHas;

    /** Used to compose bitmasks for value comparisons. */
    var COMPARE_PARTIAL_FLAG = 1,
        COMPARE_UNORDERED_FLAG = 2;

    /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
          arrLength = array.length,
          othLength = other.length;

      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(array);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var index = -1,
          result = true,
          seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new _SetCache : undefined;

      stack.set(array, other);
      stack.set(other, array);

      // Ignore non-index properties.
      while (++index < arrLength) {
        var arrValue = array[index],
            othValue = other[index];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, arrValue, index, other, array, stack)
            : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== undefined) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        // Recursively compare arrays (susceptible to call stack limits).
        if (seen) {
          if (!_arraySome(other, function(othValue, othIndex) {
                if (!_cacheHas(seen, othIndex) &&
                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
            result = false;
            break;
          }
        } else if (!(
              arrValue === othValue ||
                equalFunc(arrValue, othValue, bitmask, customizer, stack)
            )) {
          result = false;
          break;
        }
      }
      stack['delete'](array);
      stack['delete'](other);
      return result;
    }

    var _equalArrays = equalArrays;

    /**
     * Converts `map` to its key-value pairs.
     *
     * @private
     * @param {Object} map The map to convert.
     * @returns {Array} Returns the key-value pairs.
     */
    function mapToArray(map) {
      var index = -1,
          result = Array(map.size);

      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }

    var _mapToArray = mapToArray;

    /**
     * Converts `set` to an array of its values.
     *
     * @private
     * @param {Object} set The set to convert.
     * @returns {Array} Returns the values.
     */
    function setToArray(set) {
      var index = -1,
          result = Array(set.size);

      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }

    var _setToArray = setToArray;

    /** Used to compose bitmasks for value comparisons. */
    var COMPARE_PARTIAL_FLAG$1 = 1,
        COMPARE_UNORDERED_FLAG$1 = 2;

    /** `Object#toString` result references. */
    var boolTag$1 = '[object Boolean]',
        dateTag$1 = '[object Date]',
        errorTag$1 = '[object Error]',
        mapTag$1 = '[object Map]',
        numberTag$1 = '[object Number]',
        regexpTag$1 = '[object RegExp]',
        setTag$1 = '[object Set]',
        stringTag$1 = '[object String]',
        symbolTag$1 = '[object Symbol]';

    var arrayBufferTag$1 = '[object ArrayBuffer]',
        dataViewTag$1 = '[object DataView]';

    /** Used to convert symbols to primitives and strings. */
    var symbolProto$1 = _Symbol ? _Symbol.prototype : undefined,
        symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : undefined;

    /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag$1:
          if ((object.byteLength != other.byteLength) ||
              (object.byteOffset != other.byteOffset)) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;

        case arrayBufferTag$1:
          if ((object.byteLength != other.byteLength) ||
              !equalFunc(new _Uint8Array(object), new _Uint8Array(other))) {
            return false;
          }
          return true;

        case boolTag$1:
        case dateTag$1:
        case numberTag$1:
          // Coerce booleans to `1` or `0` and dates to milliseconds.
          // Invalid dates are coerced to `NaN`.
          return eq_1(+object, +other);

        case errorTag$1:
          return object.name == other.name && object.message == other.message;

        case regexpTag$1:
        case stringTag$1:
          // Coerce regexes to strings and treat strings, primitives and objects,
          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
          // for more details.
          return object == (other + '');

        case mapTag$1:
          var convert = _mapToArray;

        case setTag$1:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1;
          convert || (convert = _setToArray);

          if (object.size != other.size && !isPartial) {
            return false;
          }
          // Assume cyclic values are equal.
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG$1;

          // Recursively compare objects (susceptible to call stack limits).
          stack.set(object, other);
          var result = _equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack['delete'](object);
          return result;

        case symbolTag$1:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }

    var _equalByTag = equalByTag;

    /**
     * Appends the elements of `values` to `array`.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to append.
     * @returns {Array} Returns `array`.
     */
    function arrayPush(array, values) {
      var index = -1,
          length = values.length,
          offset = array.length;

      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }

    var _arrayPush = arrayPush;

    /**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray_1(object) ? result : _arrayPush(result, symbolsFunc(object));
    }

    var _baseGetAllKeys = baseGetAllKeys;

    /**
     * A specialized version of `_.filter` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function arrayFilter(array, predicate) {
      var index = -1,
          length = array == null ? 0 : array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }

    var _arrayFilter = arrayFilter;

    /**
     * This method returns a new empty array.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Array} Returns the new empty array.
     * @example
     *
     * var arrays = _.times(2, _.stubArray);
     *
     * console.log(arrays);
     * // => [[], []]
     *
     * console.log(arrays[0] === arrays[1]);
     * // => false
     */
    function stubArray() {
      return [];
    }

    var stubArray_1 = stubArray;

    /** Used for built-in method references. */
    var objectProto$12 = Object.prototype;

    /** Built-in value references. */
    var propertyIsEnumerable$1 = objectProto$12.propertyIsEnumerable;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeGetSymbols = Object.getOwnPropertySymbols;

    /**
     * Creates an array of the own enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbols = !nativeGetSymbols ? stubArray_1 : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return _arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable$1.call(object, symbol);
      });
    };

    var _getSymbols = getSymbols;

    /**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeys(object) {
      return _baseGetAllKeys(object, keys_1, _getSymbols);
    }

    var _getAllKeys = getAllKeys;

    /** Used to compose bitmasks for value comparisons. */
    var COMPARE_PARTIAL_FLAG$2 = 1;

    /** Used for built-in method references. */
    var objectProto$13 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$10 = objectProto$13.hasOwnProperty;

    /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2,
          objProps = _getAllKeys(object),
          objLength = objProps.length,
          othProps = _getAllKeys(other),
          othLength = othProps.length;

      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty$10.call(other, key))) {
          return false;
        }
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);

      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key],
            othValue = other[key];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, objValue, key, other, object, stack)
            : customizer(objValue, othValue, key, object, other, stack);
        }
        // Recursively compare objects (susceptible to call stack limits).
        if (!(compared === undefined
              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
              : compared
            )) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == 'constructor');
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor,
            othCtor = other.constructor;

        // Non `Object` object instances with different constructors are not equal.
        if (objCtor != othCtor &&
            ('constructor' in object && 'constructor' in other) &&
            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack['delete'](object);
      stack['delete'](other);
      return result;
    }

    var _equalObjects = equalObjects;

    /* Built-in method references that are verified to be native. */
    var DataView = _getNative(_root, 'DataView');

    var _DataView = DataView;

    /* Built-in method references that are verified to be native. */
    var Promise$1 = _getNative(_root, 'Promise');

    var _Promise = Promise$1;

    /* Built-in method references that are verified to be native. */
    var Set = _getNative(_root, 'Set');

    var _Set = Set;

    /* Built-in method references that are verified to be native. */
    var WeakMap = _getNative(_root, 'WeakMap');

    var _WeakMap = WeakMap;

    /** `Object#toString` result references. */
    var mapTag$2 = '[object Map]',
        objectTag$2 = '[object Object]',
        promiseTag = '[object Promise]',
        setTag$2 = '[object Set]',
        weakMapTag$1 = '[object WeakMap]';

    var dataViewTag$2 = '[object DataView]';

    /** Used to detect maps, sets, and weakmaps. */
    var dataViewCtorString = _toSource(_DataView),
        mapCtorString = _toSource(_Map),
        promiseCtorString = _toSource(_Promise),
        setCtorString = _toSource(_Set),
        weakMapCtorString = _toSource(_WeakMap);

    /**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    var getTag = _baseGetTag;

    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
    if ((_DataView && getTag(new _DataView(new ArrayBuffer(1))) != dataViewTag$2) ||
        (_Map && getTag(new _Map) != mapTag$2) ||
        (_Promise && getTag(_Promise.resolve()) != promiseTag) ||
        (_Set && getTag(new _Set) != setTag$2) ||
        (_WeakMap && getTag(new _WeakMap) != weakMapTag$1)) {
      getTag = function(value) {
        var result = _baseGetTag(value),
            Ctor = result == objectTag$2 ? value.constructor : undefined,
            ctorString = Ctor ? _toSource(Ctor) : '';

        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString: return dataViewTag$2;
            case mapCtorString: return mapTag$2;
            case promiseCtorString: return promiseTag;
            case setCtorString: return setTag$2;
            case weakMapCtorString: return weakMapTag$1;
          }
        }
        return result;
      };
    }

    var _getTag = getTag;

    /** Used to compose bitmasks for value comparisons. */
    var COMPARE_PARTIAL_FLAG$3 = 1;

    /** `Object#toString` result references. */
    var argsTag$2 = '[object Arguments]',
        arrayTag$1 = '[object Array]',
        objectTag$3 = '[object Object]';

    /** Used for built-in method references. */
    var objectProto$14 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$11 = objectProto$14.hasOwnProperty;

    /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray_1(object),
          othIsArr = isArray_1(other),
          objTag = objIsArr ? arrayTag$1 : _getTag(object),
          othTag = othIsArr ? arrayTag$1 : _getTag(other);

      objTag = objTag == argsTag$2 ? objectTag$3 : objTag;
      othTag = othTag == argsTag$2 ? objectTag$3 : othTag;

      var objIsObj = objTag == objectTag$3,
          othIsObj = othTag == objectTag$3,
          isSameTag = objTag == othTag;

      if (isSameTag && isBuffer_1(object)) {
        if (!isBuffer_1(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new _Stack);
        return (objIsArr || isTypedArray_1(object))
          ? _equalArrays(object, other, bitmask, customizer, equalFunc, stack)
          : _equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG$3)) {
        var objIsWrapped = objIsObj && hasOwnProperty$11.call(object, '__wrapped__'),
            othIsWrapped = othIsObj && hasOwnProperty$11.call(other, '__wrapped__');

        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object,
              othUnwrapped = othIsWrapped ? other.value() : other;

          stack || (stack = new _Stack);
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new _Stack);
      return _equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }

    var _baseIsEqualDeep = baseIsEqualDeep;

    /**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Unordered comparison
     *  2 - Partial comparison
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || (!isObjectLike_1(value) && !isObjectLike_1(other))) {
        return value !== value && other !== other;
      }
      return _baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }

    var _baseIsEqual = baseIsEqual;

    /** Used to compose bitmasks for value comparisons. */
    var COMPARE_PARTIAL_FLAG$4 = 1,
        COMPARE_UNORDERED_FLAG$2 = 2;

    /**
     * The base implementation of `_.isMatch` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Array} matchData The property names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length,
          length = index,
          noCustomizer = !customizer;

      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if ((noCustomizer && data[2])
              ? data[1] !== object[data[0]]
              : !(data[0] in object)
            ) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0],
            objValue = object[key],
            srcValue = data[1];

        if (noCustomizer && data[2]) {
          if (objValue === undefined && !(key in object)) {
            return false;
          }
        } else {
          var stack = new _Stack;
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === undefined
                ? _baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$4 | COMPARE_UNORDERED_FLAG$2, customizer, stack)
                : result
              )) {
            return false;
          }
        }
      }
      return true;
    }

    var _baseIsMatch = baseIsMatch;

    /**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */
    function isStrictComparable(value) {
      return value === value && !isObject_1(value);
    }

    var _isStrictComparable = isStrictComparable;

    /**
     * Gets the property names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */
    function getMatchData(object) {
      var result = keys_1(object),
          length = result.length;

      while (length--) {
        var key = result[length],
            value = object[key];

        result[length] = [key, value, _isStrictComparable(value)];
      }
      return result;
    }

    var _getMatchData = getMatchData;

    /**
     * A specialized version of `matchesProperty` for source values suitable
     * for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue &&
          (srcValue !== undefined || (key in Object(object)));
      };
    }

    var _matchesStrictComparable = matchesStrictComparable;

    /**
     * The base implementation of `_.matches` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatches(source) {
      var matchData = _getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return _matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || _baseIsMatch(object, source, matchData);
      };
    }

    var _baseMatches = baseMatches;

    /** Used to match property names within property paths. */
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
        reIsPlainProp = /^\w*$/;

    /**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */
    function isKey(value, object) {
      if (isArray_1(value)) {
        return false;
      }
      var type = typeof value;
      if (type == 'number' || type == 'symbol' || type == 'boolean' ||
          value == null || isSymbol_1(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
        (object != null && value in Object(object));
    }

    var _isKey = isKey;

    /** Error message constants. */
    var FUNC_ERROR_TEXT = 'Expected a function';

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided, it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the
     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoized function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // Modify the result cache.
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // Replace `_.memoize.Cache`.
     * _.memoize.Cache = WeakMap;
     */
    function memoize(func, resolver) {
      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments,
            key = resolver ? resolver.apply(this, args) : args[0],
            cache = memoized.cache;

        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize.Cache || _MapCache);
      return memoized;
    }

    // Expose `MapCache`.
    memoize.Cache = _MapCache;

    var memoize_1 = memoize;

    /** Used as the maximum memoize cache size. */
    var MAX_MEMOIZE_SIZE = 500;

    /**
     * A specialized version of `_.memoize` which clears the memoized function's
     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
     *
     * @private
     * @param {Function} func The function to have its output memoized.
     * @returns {Function} Returns the new memoized function.
     */
    function memoizeCapped(func) {
      var result = memoize_1(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });

      var cache = result.cache;
      return result;
    }

    var _memoizeCapped = memoizeCapped;

    /** Used to match property names within property paths. */
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

    /** Used to match backslashes in property paths. */
    var reEscapeChar = /\\(\\)?/g;

    /**
     * Converts `string` to a property path array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the property path array.
     */
    var stringToPath = _memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46 /* . */) {
        result.push('');
      }
      string.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
      });
      return result;
    });

    var _stringToPath = stringToPath;

    /**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {Object} [object] The object to query keys on.
     * @returns {Array} Returns the cast property path array.
     */
    function castPath(value, object) {
      if (isArray_1(value)) {
        return value;
      }
      return _isKey(value, object) ? [value] : _stringToPath(toString_1(value));
    }

    var _castPath = castPath;

    /** Used as references for various `Number` constants. */
    var INFINITY$1 = 1 / 0;

    /**
     * Converts `value` to a string key if it's not a string or symbol.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {string|symbol} Returns the key.
     */
    function toKey(value) {
      if (typeof value == 'string' || isSymbol_1(value)) {
        return value;
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY$1) ? '-0' : result;
    }

    var _toKey = toKey;

    /**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */
    function baseGet(object, path) {
      path = _castPath(path, object);

      var index = 0,
          length = path.length;

      while (object != null && index < length) {
        object = object[_toKey(path[index++])];
      }
      return (index && index == length) ? object : undefined;
    }

    var _baseGet = baseGet;

    /**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined`, the `defaultValue` is returned in its place.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */
    function get(object, path, defaultValue) {
      var result = object == null ? undefined : _baseGet(object, path);
      return result === undefined ? defaultValue : result;
    }

    var get_1 = get;

    /**
     * The base implementation of `_.hasIn` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }

    var _baseHasIn = baseHasIn;

    /**
     * Checks if `path` exists on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @param {Function} hasFunc The function to check properties.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     */
    function hasPath(object, path, hasFunc) {
      path = _castPath(path, object);

      var index = -1,
          length = path.length,
          result = false;

      while (++index < length) {
        var key = _toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result || ++index != length) {
        return result;
      }
      length = object == null ? 0 : object.length;
      return !!length && isLength_1(length) && _isIndex(key, length) &&
        (isArray_1(object) || isArguments_1(object));
    }

    var _hasPath = hasPath;

    /**
     * Checks if `path` is a direct or inherited property of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.hasIn(object, 'a');
     * // => true
     *
     * _.hasIn(object, 'a.b');
     * // => true
     *
     * _.hasIn(object, ['a', 'b']);
     * // => true
     *
     * _.hasIn(object, 'b');
     * // => false
     */
    function hasIn(object, path) {
      return object != null && _hasPath(object, path, _baseHasIn);
    }

    var hasIn_1 = hasIn;

    /** Used to compose bitmasks for value comparisons. */
    var COMPARE_PARTIAL_FLAG$5 = 1,
        COMPARE_UNORDERED_FLAG$3 = 2;

    /**
     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatchesProperty(path, srcValue) {
      if (_isKey(path) && _isStrictComparable(srcValue)) {
        return _matchesStrictComparable(_toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get_1(object, path);
        return (objValue === undefined && objValue === srcValue)
          ? hasIn_1(object, path)
          : _baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$5 | COMPARE_UNORDERED_FLAG$3);
      };
    }

    var _baseMatchesProperty = baseMatchesProperty;

    /**
     * The base implementation of `_.property` without support for deep paths.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @returns {Function} Returns the new accessor function.
     */
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined : object[key];
      };
    }

    var _baseProperty = baseProperty;

    /**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     */
    function basePropertyDeep(path) {
      return function(object) {
        return _baseGet(object, path);
      };
    }

    var _basePropertyDeep = basePropertyDeep;

    /**
     * Creates a function that returns the value at `path` of a given object.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': 2 } },
     *   { 'a': { 'b': 1 } }
     * ];
     *
     * _.map(objects, _.property('a.b'));
     * // => [2, 1]
     *
     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
     * // => [1, 2]
     */
    function property(path) {
      return _isKey(path) ? _baseProperty(_toKey(path)) : _basePropertyDeep(path);
    }

    var property_1 = property;

    /**
     * The base implementation of `_.iteratee`.
     *
     * @private
     * @param {*} [value=_.identity] The value to convert to an iteratee.
     * @returns {Function} Returns the iteratee.
     */
    function baseIteratee(value) {
      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
      if (typeof value == 'function') {
        return value;
      }
      if (value == null) {
        return identity_1;
      }
      if (typeof value == 'object') {
        return isArray_1(value)
          ? _baseMatchesProperty(value[0], value[1])
          : _baseMatches(value);
      }
      return property_1(value);
    }

    var _baseIteratee = baseIteratee;

    /**
     * The opposite of `_.mapValues`; this method creates an object with the
     * same values as `object` and keys generated by running each own enumerable
     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
     * with three arguments: (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapValues
     * @example
     *
     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
     *   return key + value;
     * });
     * // => { 'a1': 1, 'b2': 2 }
     */
    function mapKeys(object, iteratee) {
      var result = {};
      iteratee = _baseIteratee(iteratee, 3);

      _baseForOwn(object, function(value, key, object) {
        _baseAssignValue(result, iteratee(value, key, object), value);
      });
      return result;
    }

    var mapKeys_1 = mapKeys;

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    var isNull_1 = isNull;

    function prefix(subject, prefix) {
      var delimeter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '-';

      var prefixer = function prefixer(value, key) {
        var string = key || value;
        return [prefix, string.replace(new RegExp("^".concat(prefix).concat(delimeter, "?")), '')].join(delimeter);
      };

      if (isNull_1(subject) || isUndefined_1(subject)) {
        return subject;
      }

      if (isObject_1(subject)) {
        return mapKeys_1(subject, prefixer);
      }

      return prefixer(subject);
    }

    var Variant = {
      props: {
        /**
         * The variant attribute
         *
         * @property String
         */
        variant: {
          type: String,
          default: 'primary'
        }
      },
      computed: {
        variantClassPrefix: function variantClassPrefix() {
          return this.$options.name;
        },
        variantClass: function variantClass() {
          return prefix(this.variant, this.variantClassPrefix);
        }
      }
    };

    function duration(el) {
      var duration = getComputedStyle(el).transitionDuration;
      var numeric = parseFloat(duration, 10) || 0;
      var unit = duration.match(/m?s/);

      switch (unit[0]) {
        case 's':
          return numeric * 1000;

        case 'ms':
          return numeric;
      }
    }

    function transition(el) {
      return new Promise(function (resolve, reject) {
        try {
          var delay = duration(el);
          setTimeout(function () {
            return resolve(delay);
          }, delay);
        } catch (e) {
          reject(e);
        }
      });
    }

    var Alert = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "alert",
          class: _vm.$mergeClasses(_vm.variantClass, {
            show: _vm.isVisible,
            fade: _vm.fade
          }),
          attrs: {
            "role": "alert"
          }
        }, [_vm._t("default"), _vm._v(" "), _vm.dismissible ? _c('alert-close', {
          on: {
            "click": function click($event) {
              _vm.dismiss();
            }
          }
        }) : _vm._e(), _vm._v(" "), typeof _vm.show === 'number' ? _c('progress-bar', {
          staticClass: "my-3",
          attrs: {
            "variant": _vm.variant,
            "height": 5,
            "value": _vm.dismissCount,
            "max": _vm.show
          }
        }) : _vm._e()], 2);
      },
      staticRenderFns: [],
      name: 'alert',
      mixins: [Variant],
      props: {
        /**
         * Is the alert dismissible
         *
         * @property Boolean
         */
        dismissible: Boolean,

        /**
         * Should the alert fade when hidden
         *
         * @property Boolean
         */
        fade: {
          type: Boolean,
          default: true
        },

        /**
         * Should the alert be visible by default. If passed a number, alert
         * will be shown for the number of seconds that are passed.
         *
         * @property Boolean
         */
        show: {
          type: [Number, Boolean],
          default: true
        }
      },
      methods: {
        dismiss: function dismiss() {
          var _this = this;

          transition(this.$el).then(function (delay) {
            _this.$emit('dismissed');
          });
          this.$emit('update:visible', this.isVisible = false);
        }
      },
      mounted: function mounted() {
        var _this2 = this;

        if (typeof this.show === 'number') {
          var el = this.$el.querySelector('.progress-bar');
          this.$emit('dismiss-countdown', this.dismissCount = this.show);
          var interval = setInterval(function () {
            _this2.$emit('dismiss-countdown', _this2.dismissCount -= 1);

            if (!_this2.dismissCount) {
              clearInterval(interval);
              transition(el).then(function (delay) {
                return _this2.dismiss();
              });
            }
          }, 1000);
        }
      },
      data: function data() {
        return {
          dismissCount: this.show,
          isVisible: this.show
        };
      }
    };

    var AlertLink = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('a', {
          staticClass: "alert-link"
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'alert-link'
    };

    var AlertClose = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('button', {
          staticClass: "close",
          attrs: {
            "type": "button",
            "data-dismiss": "alert",
            "aria-label": "Close"
          },
          on: {
            "click": _vm.onClick
          }
        }, [_c('span', {
          attrs: {
            "aria-hidden": "true"
          }
        }, [_vm._v("×")])]);
      },
      staticRenderFns: [],
      name: 'alert-close',
      methods: {
        onClick: function onClick(event) {
          this.$emit('click', event);
        }
      }
    };

    var AlertHeading = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('h4', {
          staticClass: "alert-heading"
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'alert-heading'
    };

    var plugin$3 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          Alert: Alert,
          AlertLink: AlertLink,
          AlertClose: AlertClose,
          AlertHeading: AlertHeading
        });
      }
    });

    var Badge = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _vm.href ? _c('a', {
          staticClass: "badge",
          class: _vm.$mergeClasses(_vm.classes, _vm.variantClass),
          attrs: {
            "href": _vm.href
          }
        }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))]), _vm._v(" "), _c('span', {
          staticClass: "sr-only",
          domProps: {
            "innerHTML": _vm._s(_vm.accessibility)
          }
        })], 2) : _c('span', {
          staticClass: "badge",
          class: _vm.$mergeClasses(_vm.classes, _vm.variantClass)
        }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))]), _vm._v(" "), _c('span', {
          staticClass: "sr-only",
          domProps: {
            "innerHTML": _vm._s(_vm.accessibility)
          }
        })], 2);
      },
      staticRenderFns: [],
      name: 'badge',
      mixins: [Variant],
      props: {
        /**
         * The screen reader accessibility label.
         *
         * @property String
         */
        accessibility: String,

        /**
         * If an href attribute is passed, the badge becomes an anchor.
         *
         * @property String
         */
        href: String,

        /**
         * The badge appear as pill shaped.
         *
         * @property String
         */
        pill: Boolean,

        /**
         * The badge label.
         *
         * @property String
         */
        label: [Number, String],

        /**
         * The badge appear as secondary in size to the parent element.
         *
         * @property String
         */
        secondary: Boolean
      },
      computed: {
        classes: function classes() {
          return prefix({
            'pill': this.pill,
            'secondary': this.secondary
          }, this.$options.name);
        }
      }
    };

    var plugin$4 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          Badge: Badge
        });
      }
    });

    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      return Constructor;
    }

    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }

      return _assertThisInitialized(self);
    }

    /**
     * The base implementation of `_.reduce` and `_.reduceRight`, without support
     * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} accumulator The initial value.
     * @param {boolean} initAccum Specify using the first or last element of
     *  `collection` as the initial value.
     * @param {Function} eachFunc The function to iterate over `collection`.
     * @returns {*} Returns the accumulated value.
     */
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function(value, index, collection) {
        accumulator = initAccum
          ? (initAccum = false, value)
          : iteratee(accumulator, value, index, collection);
      });
      return accumulator;
    }

    var _baseReduce = baseReduce;

    /**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` thru `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not given, the first element of `collection` is used as the initial
     * value. The iteratee is invoked with four arguments:
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
     * and `sortBy`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduceRight
     * @example
     *
     * _.reduce([1, 2], function(sum, n) {
     *   return sum + n;
     * }, 0);
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     *   return result;
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
     */
    function reduce(collection, iteratee, accumulator) {
      var func = isArray_1(collection) ? _arrayReduce : _baseReduce,
          initAccum = arguments.length < 3;

      return func(collection, _baseIteratee(iteratee, 4), accumulator, initAccum, _baseEach);
    }

    var reduce_1 = reduce;

    /**
     * The base implementation of `_.set`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */
    function baseSet(object, path, value, customizer) {
      if (!isObject_1(object)) {
        return object;
      }
      path = _castPath(path, object);

      var index = -1,
          length = path.length,
          lastIndex = length - 1,
          nested = object;

      while (nested != null && ++index < length) {
        var key = _toKey(path[index]),
            newValue = value;

        if (index != lastIndex) {
          var objValue = nested[key];
          newValue = customizer ? customizer(objValue, key, nested) : undefined;
          if (newValue === undefined) {
            newValue = isObject_1(objValue)
              ? objValue
              : (_isIndex(path[index + 1]) ? [] : {});
          }
        }
        _assignValue(nested, key, newValue);
        nested = nested[key];
      }
      return object;
    }

    var _baseSet = baseSet;

    /**
     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @param {Function} predicate The function invoked per property.
     * @returns {Object} Returns the new object.
     */
    function basePickBy(object, paths, predicate) {
      var index = -1,
          length = paths.length,
          result = {};

      while (++index < length) {
        var path = paths[index],
            value = _baseGet(object, path);

        if (predicate(value, path)) {
          _baseSet(result, _castPath(path, object), value);
        }
      }
      return result;
    }

    var _basePickBy = basePickBy;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeGetSymbols$1 = Object.getOwnPropertySymbols;

    /**
     * Creates an array of the own and inherited enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbolsIn = !nativeGetSymbols$1 ? stubArray_1 : function(object) {
      var result = [];
      while (object) {
        _arrayPush(result, _getSymbols(object));
        object = _getPrototype(object);
      }
      return result;
    };

    var _getSymbolsIn = getSymbolsIn;

    /**
     * Creates an array of own and inherited enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeysIn(object) {
      return _baseGetAllKeys(object, keysIn_1, _getSymbolsIn);
    }

    var _getAllKeysIn = getAllKeysIn;

    /**
     * Creates an object composed of the `object` properties `predicate` returns
     * truthy for. The predicate is invoked with two arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pickBy(object, _.isNumber);
     * // => { 'a': 1, 'c': 3 }
     */
    function pickBy(object, predicate) {
      if (object == null) {
        return {};
      }
      var props = _arrayMap(_getAllKeysIn(object), function(prop) {
        return [prop];
      });
      predicate = _baseIteratee(predicate);
      return _basePickBy(object, props, function(value, path) {
        return predicate(value, path[0]);
      });
    }

    var pickBy_1 = pickBy;

    /**
     * The base implementation of `_.filter` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function baseFilter(collection, predicate) {
      var result = [];
      _baseEach(collection, function(value, index, collection) {
        if (predicate(value, index, collection)) {
          result.push(value);
        }
      });
      return result;
    }

    var _baseFilter = baseFilter;

    /**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * **Note:** Unlike `_.remove`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.reject
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, { 'age': 36, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.filter(users, 'active');
     * // => objects for ['barney']
     */
    function filter$1(collection, predicate) {
      var func = isArray_1(collection) ? _arrayFilter : _baseFilter;
      return func(collection, _baseIteratee(predicate, 3));
    }

    var filter_1 = filter$1;

    /** `Object#toString` result references. */
    var stringTag$2 = '[object String]';

    /**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */
    function isString(value) {
      return typeof value == 'string' ||
        (!isArray_1(value) && isObjectLike_1(value) && _baseGetTag(value) == stringTag$2);
    }

    var isString_1 = isString;

    /**
     * Gets the size of an ASCII `string`.
     *
     * @private
     * @param {string} string The string inspect.
     * @returns {number} Returns the string size.
     */
    var asciiSize = _baseProperty('length');

    var _asciiSize = asciiSize;

    /** Used to compose unicode character classes. */
    var rsAstralRange$1 = '\\ud800-\\udfff',
        rsComboMarksRange$2 = '\\u0300-\\u036f',
        reComboHalfMarksRange$2 = '\\ufe20-\\ufe2f',
        rsComboSymbolsRange$2 = '\\u20d0-\\u20ff',
        rsComboRange$2 = rsComboMarksRange$2 + reComboHalfMarksRange$2 + rsComboSymbolsRange$2,
        rsVarRange$1 = '\\ufe0e\\ufe0f';

    /** Used to compose unicode capture groups. */
    var rsZWJ$1 = '\\u200d';

    /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
    var reHasUnicode = RegExp('[' + rsZWJ$1 + rsAstralRange$1  + rsComboRange$2 + rsVarRange$1 + ']');

    /**
     * Checks if `string` contains Unicode symbols.
     *
     * @private
     * @param {string} string The string to inspect.
     * @returns {boolean} Returns `true` if a symbol is found, else `false`.
     */
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }

    var _hasUnicode = hasUnicode;

    /** Used to compose unicode character classes. */
    var rsAstralRange$2 = '\\ud800-\\udfff',
        rsComboMarksRange$3 = '\\u0300-\\u036f',
        reComboHalfMarksRange$3 = '\\ufe20-\\ufe2f',
        rsComboSymbolsRange$3 = '\\u20d0-\\u20ff',
        rsComboRange$3 = rsComboMarksRange$3 + reComboHalfMarksRange$3 + rsComboSymbolsRange$3,
        rsVarRange$2 = '\\ufe0e\\ufe0f';

    /** Used to compose unicode capture groups. */
    var rsAstral = '[' + rsAstralRange$2 + ']',
        rsCombo$2 = '[' + rsComboRange$3 + ']',
        rsFitz$1 = '\\ud83c[\\udffb-\\udfff]',
        rsModifier$1 = '(?:' + rsCombo$2 + '|' + rsFitz$1 + ')',
        rsNonAstral$1 = '[^' + rsAstralRange$2 + ']',
        rsRegional$1 = '(?:\\ud83c[\\udde6-\\uddff]){2}',
        rsSurrPair$1 = '[\\ud800-\\udbff][\\udc00-\\udfff]',
        rsZWJ$2 = '\\u200d';

    /** Used to compose unicode regexes. */
    var reOptMod$1 = rsModifier$1 + '?',
        rsOptVar$1 = '[' + rsVarRange$2 + ']?',
        rsOptJoin$1 = '(?:' + rsZWJ$2 + '(?:' + [rsNonAstral$1, rsRegional$1, rsSurrPair$1].join('|') + ')' + rsOptVar$1 + reOptMod$1 + ')*',
        rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1,
        rsSymbol = '(?:' + [rsNonAstral$1 + rsCombo$2 + '?', rsCombo$2, rsRegional$1, rsSurrPair$1, rsAstral].join('|') + ')';

    /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
    var reUnicode = RegExp(rsFitz$1 + '(?=' + rsFitz$1 + ')|' + rsSymbol + rsSeq$1, 'g');

    /**
     * Gets the size of a Unicode `string`.
     *
     * @private
     * @param {string} string The string inspect.
     * @returns {number} Returns the string size.
     */
    function unicodeSize(string) {
      var result = reUnicode.lastIndex = 0;
      while (reUnicode.test(string)) {
        ++result;
      }
      return result;
    }

    var _unicodeSize = unicodeSize;

    /**
     * Gets the number of symbols in `string`.
     *
     * @private
     * @param {string} string The string to inspect.
     * @returns {number} Returns the string size.
     */
    function stringSize(string) {
      return _hasUnicode(string)
        ? _unicodeSize(string)
        : _asciiSize(string);
    }

    var _stringSize = stringSize;

    /** `Object#toString` result references. */
    var mapTag$3 = '[object Map]',
        setTag$3 = '[object Set]';

    /**
     * Gets the size of `collection` by returning its length for array-like
     * values or the number of own enumerable string keyed properties for objects.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns the collection size.
     * @example
     *
     * _.size([1, 2, 3]);
     * // => 3
     *
     * _.size({ 'a': 1, 'b': 2 });
     * // => 2
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      if (collection == null) {
        return 0;
      }
      if (isArrayLike_1(collection)) {
        return isString_1(collection) ? _stringSize(collection) : collection.length;
      }
      var tag = _getTag(collection);
      if (tag == mapTag$3 || tag == setTag$3) {
        return collection.size;
      }
      return _baseKeys(collection).length;
    }

    var size_1 = size;

    /**
     * The base implementation of `_.map` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function baseMap(collection, iteratee) {
      var index = -1,
          result = isArrayLike_1(collection) ? Array(collection.length) : [];

      _baseEach(collection, function(value, key, collection) {
        result[++index] = iteratee(value, key, collection);
      });
      return result;
    }

    var _baseMap = baseMap;

    /**
     * Creates an array of values by running each element in `collection` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * _.map([4, 8], square);
     * // => [16, 64]
     *
     * _.map({ 'a': 4, 'b': 8 }, square);
     * // => [16, 64] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */
    function map(collection, iteratee) {
      var func = isArray_1(collection) ? _arrayMap : _baseMap;
      return func(collection, _baseIteratee(iteratee, 3));
    }

    var map_1 = map;

    /**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseSlice(array, start, end) {
      var index = -1,
          length = array.length;

      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : ((end - start) >>> 0);
      start >>>= 0;

      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }

    var _baseSlice = baseSlice;

    /**
     * Casts `array` to a slice if it's needed.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {number} start The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the cast slice.
     */
    function castSlice(array, start, end) {
      var length = array.length;
      end = end === undefined ? length : end;
      return (!start && end >= length) ? array : _baseSlice(array, start, end);
    }

    var _castSlice = castSlice;

    /**
     * Converts an ASCII `string` to an array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the converted array.
     */
    function asciiToArray(string) {
      return string.split('');
    }

    var _asciiToArray = asciiToArray;

    /** Used to compose unicode character classes. */
    var rsAstralRange$3 = '\\ud800-\\udfff',
        rsComboMarksRange$4 = '\\u0300-\\u036f',
        reComboHalfMarksRange$4 = '\\ufe20-\\ufe2f',
        rsComboSymbolsRange$4 = '\\u20d0-\\u20ff',
        rsComboRange$4 = rsComboMarksRange$4 + reComboHalfMarksRange$4 + rsComboSymbolsRange$4,
        rsVarRange$3 = '\\ufe0e\\ufe0f';

    /** Used to compose unicode capture groups. */
    var rsAstral$1 = '[' + rsAstralRange$3 + ']',
        rsCombo$3 = '[' + rsComboRange$4 + ']',
        rsFitz$2 = '\\ud83c[\\udffb-\\udfff]',
        rsModifier$2 = '(?:' + rsCombo$3 + '|' + rsFitz$2 + ')',
        rsNonAstral$2 = '[^' + rsAstralRange$3 + ']',
        rsRegional$2 = '(?:\\ud83c[\\udde6-\\uddff]){2}',
        rsSurrPair$2 = '[\\ud800-\\udbff][\\udc00-\\udfff]',
        rsZWJ$3 = '\\u200d';

    /** Used to compose unicode regexes. */
    var reOptMod$2 = rsModifier$2 + '?',
        rsOptVar$2 = '[' + rsVarRange$3 + ']?',
        rsOptJoin$2 = '(?:' + rsZWJ$3 + '(?:' + [rsNonAstral$2, rsRegional$2, rsSurrPair$2].join('|') + ')' + rsOptVar$2 + reOptMod$2 + ')*',
        rsSeq$2 = rsOptVar$2 + reOptMod$2 + rsOptJoin$2,
        rsSymbol$1 = '(?:' + [rsNonAstral$2 + rsCombo$3 + '?', rsCombo$3, rsRegional$2, rsSurrPair$2, rsAstral$1].join('|') + ')';

    /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
    var reUnicode$1 = RegExp(rsFitz$2 + '(?=' + rsFitz$2 + ')|' + rsSymbol$1 + rsSeq$2, 'g');

    /**
     * Converts a Unicode `string` to an array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the converted array.
     */
    function unicodeToArray(string) {
      return string.match(reUnicode$1) || [];
    }

    var _unicodeToArray = unicodeToArray;

    /**
     * Converts `string` to an array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the converted array.
     */
    function stringToArray(string) {
      return _hasUnicode(string)
        ? _unicodeToArray(string)
        : _asciiToArray(string);
    }

    var _stringToArray = stringToArray;

    /**
     * Creates a function like `_.lowerFirst`.
     *
     * @private
     * @param {string} methodName The name of the `String` case method to use.
     * @returns {Function} Returns the new case function.
     */
    function createCaseFirst(methodName) {
      return function(string) {
        string = toString_1(string);

        var strSymbols = _hasUnicode(string)
          ? _stringToArray(string)
          : undefined;

        var chr = strSymbols
          ? strSymbols[0]
          : string.charAt(0);

        var trailing = strSymbols
          ? _castSlice(strSymbols, 1).join('')
          : string.slice(1);

        return chr[methodName]() + trailing;
      };
    }

    var _createCaseFirst = createCaseFirst;

    /**
     * Converts the first character of `string` to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.upperFirst('fred');
     * // => 'Fred'
     *
     * _.upperFirst('FRED');
     * // => 'FRED'
     */
    var upperFirst = _createCaseFirst('toUpperCase');

    var upperFirst_1 = upperFirst;

    /**
     * Converts the first character of `string` to upper case and the remaining
     * to lower case.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('FRED');
     * // => 'Fred'
     */
    function capitalize(string) {
      return upperFirst_1(toString_1(string).toLowerCase());
    }

    var capitalize_1 = capitalize;

    /**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar--');
     * // => 'fooBar'
     *
     * _.camelCase('__FOO_BAR__');
     * // => 'fooBar'
     */
    var camelCase = _createCompounder(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? capitalize_1(word) : word);
    });

    var camelCase_1 = camelCase;

    /** Used to store function metadata. */
    var metaMap = _WeakMap && new _WeakMap;

    var _metaMap = metaMap;

    /**
     * The base implementation of `setData` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var baseSetData = !_metaMap ? identity_1 : function(func, data) {
      _metaMap.set(func, data);
      return func;
    };

    var _baseSetData = baseSetData;

    /**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCtor(Ctor) {
      return function() {
        // Use a `switch` statement to work with class constructors. See
        // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
        // for more details.
        var args = arguments;
        switch (args.length) {
          case 0: return new Ctor;
          case 1: return new Ctor(args[0]);
          case 2: return new Ctor(args[0], args[1]);
          case 3: return new Ctor(args[0], args[1], args[2]);
          case 4: return new Ctor(args[0], args[1], args[2], args[3]);
          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
        }
        var thisBinding = _baseCreate(Ctor.prototype),
            result = Ctor.apply(thisBinding, args);

        // Mimic the constructor's `return` behavior.
        // See https://es5.github.io/#x13.2.2 for more details.
        return isObject_1(result) ? result : thisBinding;
      };
    }

    var _createCtor = createCtor;

    /** Used to compose bitmasks for function metadata. */
    var WRAP_BIND_FLAG = 1;

    /**
     * Creates a function that wraps `func` to invoke it with the optional `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createBind(func, bitmask, thisArg) {
      var isBind = bitmask & WRAP_BIND_FLAG,
          Ctor = _createCtor(func);

      function wrapper() {
        var fn = (this && this !== _root && this instanceof wrapper) ? Ctor : func;
        return fn.apply(isBind ? thisArg : this, arguments);
      }
      return wrapper;
    }

    var _createBind = createBind;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeMax$1 = Math.max;

    /**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgs(args, partials, holders, isCurried) {
      var argsIndex = -1,
          argsLength = args.length,
          holdersLength = holders.length,
          leftIndex = -1,
          leftLength = partials.length,
          rangeLength = nativeMax$1(argsLength - holdersLength, 0),
          result = Array(leftLength + rangeLength),
          isUncurried = !isCurried;

      while (++leftIndex < leftLength) {
        result[leftIndex] = partials[leftIndex];
      }
      while (++argsIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[holders[argsIndex]] = args[argsIndex];
        }
      }
      while (rangeLength--) {
        result[leftIndex++] = args[argsIndex++];
      }
      return result;
    }

    var _composeArgs = composeArgs;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeMax$2 = Math.max;

    /**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgsRight(args, partials, holders, isCurried) {
      var argsIndex = -1,
          argsLength = args.length,
          holdersIndex = -1,
          holdersLength = holders.length,
          rightIndex = -1,
          rightLength = partials.length,
          rangeLength = nativeMax$2(argsLength - holdersLength, 0),
          result = Array(rangeLength + rightLength),
          isUncurried = !isCurried;

      while (++argsIndex < rangeLength) {
        result[argsIndex] = args[argsIndex];
      }
      var offset = argsIndex;
      while (++rightIndex < rightLength) {
        result[offset + rightIndex] = partials[rightIndex];
      }
      while (++holdersIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[offset + holders[holdersIndex]] = args[argsIndex++];
        }
      }
      return result;
    }

    var _composeArgsRight = composeArgsRight;

    /**
     * Gets the number of `placeholder` occurrences in `array`.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} placeholder The placeholder to search for.
     * @returns {number} Returns the placeholder count.
     */
    function countHolders(array, placeholder) {
      var length = array.length,
          result = 0;

      while (length--) {
        if (array[length] === placeholder) {
          ++result;
        }
      }
      return result;
    }

    var _countHolders = countHolders;

    /**
     * The function whose prototype chain sequence wrappers inherit from.
     *
     * @private
     */
    function baseLodash() {
      // No operation performed.
    }

    var _baseLodash = baseLodash;

    /** Used as references for the maximum length and index of an array. */
    var MAX_ARRAY_LENGTH = 4294967295;

    /**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @constructor
     * @param {*} value The value to wrap.
     */
    function LazyWrapper(value) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__dir__ = 1;
      this.__filtered__ = false;
      this.__iteratees__ = [];
      this.__takeCount__ = MAX_ARRAY_LENGTH;
      this.__views__ = [];
    }

    // Ensure `LazyWrapper` is an instance of `baseLodash`.
    LazyWrapper.prototype = _baseCreate(_baseLodash.prototype);
    LazyWrapper.prototype.constructor = LazyWrapper;

    var _LazyWrapper = LazyWrapper;

    /**
     * This method returns `undefined`.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Util
     * @example
     *
     * _.times(2, _.noop);
     * // => [undefined, undefined]
     */
    function noop() {
      // No operation performed.
    }

    var noop_1 = noop;

    /**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */
    var getData = !_metaMap ? noop_1 : function(func) {
      return _metaMap.get(func);
    };

    var _getData = getData;

    /** Used to lookup unminified function names. */
    var realNames = {};

    var _realNames = realNames;

    /** Used for built-in method references. */
    var objectProto$15 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$12 = objectProto$15.hasOwnProperty;

    /**
     * Gets the name of `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {string} Returns the function name.
     */
    function getFuncName(func) {
      var result = (func.name + ''),
          array = _realNames[result],
          length = hasOwnProperty$12.call(_realNames, result) ? array.length : 0;

      while (length--) {
        var data = array[length],
            otherFunc = data.func;
        if (otherFunc == null || otherFunc == func) {
          return data.name;
        }
      }
      return result;
    }

    var _getFuncName = getFuncName;

    /**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable explicit method chain sequences.
     */
    function LodashWrapper(value, chainAll) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__chain__ = !!chainAll;
      this.__index__ = 0;
      this.__values__ = undefined;
    }

    LodashWrapper.prototype = _baseCreate(_baseLodash.prototype);
    LodashWrapper.prototype.constructor = LodashWrapper;

    var _LodashWrapper = LodashWrapper;

    /**
     * Creates a clone of `wrapper`.
     *
     * @private
     * @param {Object} wrapper The wrapper to clone.
     * @returns {Object} Returns the cloned wrapper.
     */
    function wrapperClone(wrapper) {
      if (wrapper instanceof _LazyWrapper) {
        return wrapper.clone();
      }
      var result = new _LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
      result.__actions__ = _copyArray(wrapper.__actions__);
      result.__index__  = wrapper.__index__;
      result.__values__ = wrapper.__values__;
      return result;
    }

    var _wrapperClone = wrapperClone;

    /** Used for built-in method references. */
    var objectProto$16 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$13 = objectProto$16.hasOwnProperty;

    /**
     * Creates a `lodash` object which wraps `value` to enable implicit method
     * chain sequences. Methods that operate on and return arrays, collections,
     * and functions can be chained together. Methods that retrieve a single value
     * or may return a primitive value will automatically end the chain sequence
     * and return the unwrapped value. Otherwise, the value must be unwrapped
     * with `_#value`.
     *
     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
     * enabled using `_.chain`.
     *
     * The execution of chained methods is lazy, that is, it's deferred until
     * `_#value` is implicitly or explicitly called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion.
     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
     * the creation of intermediate arrays and can greatly reduce the number of
     * iteratee executions. Sections of a chain sequence qualify for shortcut
     * fusion if the section is applied to an array and iteratees accept only
     * one argument. The heuristic for whether a section qualifies for shortcut
     * fusion is subject to change.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers have `Array` and `String` methods.
     *
     * The wrapper `Array` methods are:
     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
     *
     * The wrapper `String` methods are:
     * `replace` and `split`
     *
     * The wrapper methods that support shortcut fusion are:
     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
     * `zipObject`, `zipObjectDeep`, and `zipWith`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
     * `upperFirst`, `value`, and `words`
     *
     * @name _
     * @constructor
     * @category Seq
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // Returns an unwrapped value.
     * wrapped.reduce(_.add);
     * // => 6
     *
     * // Returns a wrapped value.
     * var squares = wrapped.map(square);
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      if (isObjectLike_1(value) && !isArray_1(value) && !(value instanceof _LazyWrapper)) {
        if (value instanceof _LodashWrapper) {
          return value;
        }
        if (hasOwnProperty$13.call(value, '__wrapped__')) {
          return _wrapperClone(value);
        }
      }
      return new _LodashWrapper(value);
    }

    // Ensure wrappers are instances of `baseLodash`.
    lodash.prototype = _baseLodash.prototype;
    lodash.prototype.constructor = lodash;

    var wrapperLodash = lodash;

    /**
     * Checks if `func` has a lazy counterpart.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
     *  else `false`.
     */
    function isLaziable(func) {
      var funcName = _getFuncName(func),
          other = wrapperLodash[funcName];

      if (typeof other != 'function' || !(funcName in _LazyWrapper.prototype)) {
        return false;
      }
      if (func === other) {
        return true;
      }
      var data = _getData(other);
      return !!data && func === data[0];
    }

    var _isLaziable = isLaziable;

    /**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity
     * function to avoid garbage collection pauses in V8. See
     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var setData = _shortOut(_baseSetData);

    var _setData = setData;

    /** Used to match wrap detail comments. */
    var reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
        reSplitDetails = /,? & /;

    /**
     * Extracts wrapper details from the `source` body comment.
     *
     * @private
     * @param {string} source The source to inspect.
     * @returns {Array} Returns the wrapper details.
     */
    function getWrapDetails(source) {
      var match = source.match(reWrapDetails);
      return match ? match[1].split(reSplitDetails) : [];
    }

    var _getWrapDetails = getWrapDetails;

    /** Used to match wrap detail comments. */
    var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/;

    /**
     * Inserts wrapper `details` in a comment at the top of the `source` body.
     *
     * @private
     * @param {string} source The source to modify.
     * @returns {Array} details The details to insert.
     * @returns {string} Returns the modified source.
     */
    function insertWrapDetails(source, details) {
      var length = details.length;
      if (!length) {
        return source;
      }
      var lastIndex = length - 1;
      details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
      details = details.join(length > 2 ? ', ' : ' ');
      return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
    }

    var _insertWrapDetails = insertWrapDetails;

    /**
     * The base implementation of `_.findIndex` and `_.findLastIndex` without
     * support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} predicate The function invoked per iteration.
     * @param {number} fromIndex The index to search from.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length,
          index = fromIndex + (fromRight ? 1 : -1);

      while ((fromRight ? index-- : ++index < length)) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }

    var _baseFindIndex = baseFindIndex;

    /**
     * The base implementation of `_.isNaN` without support for number objects.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     */
    function baseIsNaN(value) {
      return value !== value;
    }

    var _baseIsNaN = baseIsNaN;

    /**
     * A specialized version of `_.indexOf` which performs strict equality
     * comparisons of values, i.e. `===`.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} fromIndex The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function strictIndexOf(array, value, fromIndex) {
      var index = fromIndex - 1,
          length = array.length;

      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }

    var _strictIndexOf = strictIndexOf;

    /**
     * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} fromIndex The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function baseIndexOf(array, value, fromIndex) {
      return value === value
        ? _strictIndexOf(array, value, fromIndex)
        : _baseFindIndex(array, _baseIsNaN, fromIndex);
    }

    var _baseIndexOf = baseIndexOf;

    /**
     * A specialized version of `_.includes` for arrays without support for
     * specifying an index to search from.
     *
     * @private
     * @param {Array} [array] The array to inspect.
     * @param {*} target The value to search for.
     * @returns {boolean} Returns `true` if `target` is found, else `false`.
     */
    function arrayIncludes(array, value) {
      var length = array == null ? 0 : array.length;
      return !!length && _baseIndexOf(array, value, 0) > -1;
    }

    var _arrayIncludes = arrayIncludes;

    /** Used to compose bitmasks for function metadata. */
    var WRAP_BIND_FLAG$1 = 1,
        WRAP_BIND_KEY_FLAG = 2,
        WRAP_CURRY_FLAG = 8,
        WRAP_CURRY_RIGHT_FLAG = 16,
        WRAP_PARTIAL_FLAG = 32,
        WRAP_PARTIAL_RIGHT_FLAG = 64,
        WRAP_ARY_FLAG = 128,
        WRAP_REARG_FLAG = 256,
        WRAP_FLIP_FLAG = 512;

    /** Used to associate wrap methods with their bit flags. */
    var wrapFlags = [
      ['ary', WRAP_ARY_FLAG],
      ['bind', WRAP_BIND_FLAG$1],
      ['bindKey', WRAP_BIND_KEY_FLAG],
      ['curry', WRAP_CURRY_FLAG],
      ['curryRight', WRAP_CURRY_RIGHT_FLAG],
      ['flip', WRAP_FLIP_FLAG],
      ['partial', WRAP_PARTIAL_FLAG],
      ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
      ['rearg', WRAP_REARG_FLAG]
    ];

    /**
     * Updates wrapper `details` based on `bitmask` flags.
     *
     * @private
     * @returns {Array} details The details to modify.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Array} Returns `details`.
     */
    function updateWrapDetails(details, bitmask) {
      _arrayEach(wrapFlags, function(pair) {
        var value = '_.' + pair[0];
        if ((bitmask & pair[1]) && !_arrayIncludes(details, value)) {
          details.push(value);
        }
      });
      return details.sort();
    }

    var _updateWrapDetails = updateWrapDetails;

    /**
     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
     * with wrapper details in a comment at the top of the source body.
     *
     * @private
     * @param {Function} wrapper The function to modify.
     * @param {Function} reference The reference function.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Function} Returns `wrapper`.
     */
    function setWrapToString(wrapper, reference, bitmask) {
      var source = (reference + '');
      return _setToString(wrapper, _insertWrapDetails(source, _updateWrapDetails(_getWrapDetails(source), bitmask)));
    }

    var _setWrapToString = setWrapToString;

    /** Used to compose bitmasks for function metadata. */
    var WRAP_BIND_FLAG$2 = 1,
        WRAP_BIND_KEY_FLAG$1 = 2,
        WRAP_CURRY_BOUND_FLAG = 4,
        WRAP_CURRY_FLAG$1 = 8,
        WRAP_PARTIAL_FLAG$1 = 32,
        WRAP_PARTIAL_RIGHT_FLAG$1 = 64;

    /**
     * Creates a function that wraps `func` to continue currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {Function} wrapFunc The function to create the `func` wrapper.
     * @param {*} placeholder The placeholder value.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
      var isCurry = bitmask & WRAP_CURRY_FLAG$1,
          newHolders = isCurry ? holders : undefined,
          newHoldersRight = isCurry ? undefined : holders,
          newPartials = isCurry ? partials : undefined,
          newPartialsRight = isCurry ? undefined : partials;

      bitmask |= (isCurry ? WRAP_PARTIAL_FLAG$1 : WRAP_PARTIAL_RIGHT_FLAG$1);
      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG$1 : WRAP_PARTIAL_FLAG$1);

      if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
        bitmask &= ~(WRAP_BIND_FLAG$2 | WRAP_BIND_KEY_FLAG$1);
      }
      var newData = [
        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
        newHoldersRight, argPos, ary, arity
      ];

      var result = wrapFunc.apply(undefined, newData);
      if (_isLaziable(func)) {
        _setData(result, newData);
      }
      result.placeholder = placeholder;
      return _setWrapToString(result, func, bitmask);
    }

    var _createRecurry = createRecurry;

    /**
     * Gets the argument placeholder value for `func`.
     *
     * @private
     * @param {Function} func The function to inspect.
     * @returns {*} Returns the placeholder value.
     */
    function getHolder(func) {
      var object = func;
      return object.placeholder;
    }

    var _getHolder = getHolder;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeMin = Math.min;

    /**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */
    function reorder(array, indexes) {
      var arrLength = array.length,
          length = nativeMin(indexes.length, arrLength),
          oldArray = _copyArray(array);

      while (length--) {
        var index = indexes[length];
        array[length] = _isIndex(index, arrLength) ? oldArray[index] : undefined;
      }
      return array;
    }

    var _reorder = reorder;

    /** Used as the internal argument placeholder. */
    var PLACEHOLDER = '__lodash_placeholder__';

    /**
     * Replaces all `placeholder` elements in `array` with an internal placeholder
     * and returns an array of their indexes.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {*} placeholder The placeholder to replace.
     * @returns {Array} Returns the new array of placeholder indexes.
     */
    function replaceHolders(array, placeholder) {
      var index = -1,
          length = array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value === placeholder || value === PLACEHOLDER) {
          array[index] = PLACEHOLDER;
          result[resIndex++] = index;
        }
      }
      return result;
    }

    var _replaceHolders = replaceHolders;

    /** Used to compose bitmasks for function metadata. */
    var WRAP_BIND_FLAG$3 = 1,
        WRAP_BIND_KEY_FLAG$2 = 2,
        WRAP_CURRY_FLAG$2 = 8,
        WRAP_CURRY_RIGHT_FLAG$1 = 16,
        WRAP_ARY_FLAG$1 = 128,
        WRAP_FLIP_FLAG$1 = 512;

    /**
     * Creates a function that wraps `func` to invoke it with optional `this`
     * binding of `thisArg`, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided
     *  to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
      var isAry = bitmask & WRAP_ARY_FLAG$1,
          isBind = bitmask & WRAP_BIND_FLAG$3,
          isBindKey = bitmask & WRAP_BIND_KEY_FLAG$2,
          isCurried = bitmask & (WRAP_CURRY_FLAG$2 | WRAP_CURRY_RIGHT_FLAG$1),
          isFlip = bitmask & WRAP_FLIP_FLAG$1,
          Ctor = isBindKey ? undefined : _createCtor(func);

      function wrapper() {
        var length = arguments.length,
            args = Array(length),
            index = length;

        while (index--) {
          args[index] = arguments[index];
        }
        if (isCurried) {
          var placeholder = _getHolder(wrapper),
              holdersCount = _countHolders(args, placeholder);
        }
        if (partials) {
          args = _composeArgs(args, partials, holders, isCurried);
        }
        if (partialsRight) {
          args = _composeArgsRight(args, partialsRight, holdersRight, isCurried);
        }
        length -= holdersCount;
        if (isCurried && length < arity) {
          var newHolders = _replaceHolders(args, placeholder);
          return _createRecurry(
            func, bitmask, createHybrid, wrapper.placeholder, thisArg,
            args, newHolders, argPos, ary, arity - length
          );
        }
        var thisBinding = isBind ? thisArg : this,
            fn = isBindKey ? thisBinding[func] : func;

        length = args.length;
        if (argPos) {
          args = _reorder(args, argPos);
        } else if (isFlip && length > 1) {
          args.reverse();
        }
        if (isAry && ary < length) {
          args.length = ary;
        }
        if (this && this !== _root && this instanceof wrapper) {
          fn = Ctor || _createCtor(fn);
        }
        return fn.apply(thisBinding, args);
      }
      return wrapper;
    }

    var _createHybrid = createHybrid;

    /**
     * Creates a function that wraps `func` to enable currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {number} arity The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCurry(func, bitmask, arity) {
      var Ctor = _createCtor(func);

      function wrapper() {
        var length = arguments.length,
            args = Array(length),
            index = length,
            placeholder = _getHolder(wrapper);

        while (index--) {
          args[index] = arguments[index];
        }
        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
          ? []
          : _replaceHolders(args, placeholder);

        length -= holders.length;
        if (length < arity) {
          return _createRecurry(
            func, bitmask, _createHybrid, wrapper.placeholder, undefined,
            args, holders, undefined, undefined, arity - length);
        }
        var fn = (this && this !== _root && this instanceof wrapper) ? Ctor : func;
        return _apply(fn, this, args);
      }
      return wrapper;
    }

    var _createCurry = createCurry;

    /** Used to compose bitmasks for function metadata. */
    var WRAP_BIND_FLAG$4 = 1;

    /**
     * Creates a function that wraps `func` to invoke it with the `this` binding
     * of `thisArg` and `partials` prepended to the arguments it receives.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to
     *  the new function.
     * @returns {Function} Returns the new wrapped function.
     */
    function createPartial(func, bitmask, thisArg, partials) {
      var isBind = bitmask & WRAP_BIND_FLAG$4,
          Ctor = _createCtor(func);

      function wrapper() {
        var argsIndex = -1,
            argsLength = arguments.length,
            leftIndex = -1,
            leftLength = partials.length,
            args = Array(leftLength + argsLength),
            fn = (this && this !== _root && this instanceof wrapper) ? Ctor : func;

        while (++leftIndex < leftLength) {
          args[leftIndex] = partials[leftIndex];
        }
        while (argsLength--) {
          args[leftIndex++] = arguments[++argsIndex];
        }
        return _apply(fn, isBind ? thisArg : this, args);
      }
      return wrapper;
    }

    var _createPartial = createPartial;

    /** Used as the internal argument placeholder. */
    var PLACEHOLDER$1 = '__lodash_placeholder__';

    /** Used to compose bitmasks for function metadata. */
    var WRAP_BIND_FLAG$5 = 1,
        WRAP_BIND_KEY_FLAG$3 = 2,
        WRAP_CURRY_BOUND_FLAG$1 = 4,
        WRAP_CURRY_FLAG$3 = 8,
        WRAP_ARY_FLAG$2 = 128,
        WRAP_REARG_FLAG$1 = 256;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeMin$1 = Math.min;

    /**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers used to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and
     * `_.rearg` modify function arguments, making the order in which they are
     * executed important, preventing the merging of metadata. However, we make
     * an exception for a safe combined case where curried functions have `_.ary`
     * and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */
    function mergeData(data, source) {
      var bitmask = data[1],
          srcBitmask = source[1],
          newBitmask = bitmask | srcBitmask,
          isCommon = newBitmask < (WRAP_BIND_FLAG$5 | WRAP_BIND_KEY_FLAG$3 | WRAP_ARY_FLAG$2);

      var isCombo =
        ((srcBitmask == WRAP_ARY_FLAG$2) && (bitmask == WRAP_CURRY_FLAG$3)) ||
        ((srcBitmask == WRAP_ARY_FLAG$2) && (bitmask == WRAP_REARG_FLAG$1) && (data[7].length <= source[8])) ||
        ((srcBitmask == (WRAP_ARY_FLAG$2 | WRAP_REARG_FLAG$1)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG$3));

      // Exit early if metadata can't be merged.
      if (!(isCommon || isCombo)) {
        return data;
      }
      // Use source `thisArg` if available.
      if (srcBitmask & WRAP_BIND_FLAG$5) {
        data[2] = source[2];
        // Set when currying a bound function.
        newBitmask |= bitmask & WRAP_BIND_FLAG$5 ? 0 : WRAP_CURRY_BOUND_FLAG$1;
      }
      // Compose partial arguments.
      var value = source[3];
      if (value) {
        var partials = data[3];
        data[3] = partials ? _composeArgs(partials, value, source[4]) : value;
        data[4] = partials ? _replaceHolders(data[3], PLACEHOLDER$1) : source[4];
      }
      // Compose partial right arguments.
      value = source[5];
      if (value) {
        partials = data[5];
        data[5] = partials ? _composeArgsRight(partials, value, source[6]) : value;
        data[6] = partials ? _replaceHolders(data[5], PLACEHOLDER$1) : source[6];
      }
      // Use source `argPos` if available.
      value = source[7];
      if (value) {
        data[7] = value;
      }
      // Use source `ary` if it's smaller.
      if (srcBitmask & WRAP_ARY_FLAG$2) {
        data[8] = data[8] == null ? source[8] : nativeMin$1(data[8], source[8]);
      }
      // Use source `arity` if one is not provided.
      if (data[9] == null) {
        data[9] = source[9];
      }
      // Use source `func` and merge bitmasks.
      data[0] = source[0];
      data[1] = newBitmask;

      return data;
    }

    var _mergeData = mergeData;

    /** Used as references for various `Number` constants. */
    var NAN = 0 / 0;

    /** Used to match leading and trailing whitespace. */
    var reTrim = /^\s+|\s+$/g;

    /** Used to detect bad signed hexadecimal string values. */
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

    /** Used to detect binary string values. */
    var reIsBinary = /^0b[01]+$/i;

    /** Used to detect octal string values. */
    var reIsOctal = /^0o[0-7]+$/i;

    /** Built-in method references without a dependency on `root`. */
    var freeParseInt = parseInt;

    /**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */
    function toNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol_1(value)) {
        return NAN;
      }
      if (isObject_1(value)) {
        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
        value = isObject_1(other) ? (other + '') : other;
      }
      if (typeof value != 'string') {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, '');
      var isBinary = reIsBinary.test(value);
      return (isBinary || reIsOctal.test(value))
        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
        : (reIsBadHex.test(value) ? NAN : +value);
    }

    var toNumber_1 = toNumber;

    /** Used as references for various `Number` constants. */
    var INFINITY$2 = 1 / 0,
        MAX_INTEGER = 1.7976931348623157e+308;

    /**
     * Converts `value` to a finite number.
     *
     * @static
     * @memberOf _
     * @since 4.12.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted number.
     * @example
     *
     * _.toFinite(3.2);
     * // => 3.2
     *
     * _.toFinite(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toFinite(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toFinite('3.2');
     * // => 3.2
     */
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber_1(value);
      if (value === INFINITY$2 || value === -INFINITY$2) {
        var sign = (value < 0 ? -1 : 1);
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }

    var toFinite_1 = toFinite;

    /**
     * Converts `value` to an integer.
     *
     * **Note:** This method is loosely based on
     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toInteger(3.2);
     * // => 3
     *
     * _.toInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toInteger(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toInteger('3.2');
     * // => 3
     */
    function toInteger(value) {
      var result = toFinite_1(value),
          remainder = result % 1;

      return result === result ? (remainder ? result - remainder : result) : 0;
    }

    var toInteger_1 = toInteger;

    /** Error message constants. */
    var FUNC_ERROR_TEXT$1 = 'Expected a function';

    /** Used to compose bitmasks for function metadata. */
    var WRAP_BIND_FLAG$6 = 1,
        WRAP_BIND_KEY_FLAG$4 = 2,
        WRAP_CURRY_FLAG$4 = 8,
        WRAP_CURRY_RIGHT_FLAG$2 = 16,
        WRAP_PARTIAL_FLAG$2 = 32,
        WRAP_PARTIAL_RIGHT_FLAG$2 = 64;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeMax$3 = Math.max;

    /**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags.
     *    1 - `_.bind`
     *    2 - `_.bindKey`
     *    4 - `_.curry` or `_.curryRight` of a bound function
     *    8 - `_.curry`
     *   16 - `_.curryRight`
     *   32 - `_.partial`
     *   64 - `_.partialRight`
     *  128 - `_.rearg`
     *  256 - `_.ary`
     *  512 - `_.flip`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG$4;
      if (!isBindKey && typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT$1);
      }
      var length = partials ? partials.length : 0;
      if (!length) {
        bitmask &= ~(WRAP_PARTIAL_FLAG$2 | WRAP_PARTIAL_RIGHT_FLAG$2);
        partials = holders = undefined;
      }
      ary = ary === undefined ? ary : nativeMax$3(toInteger_1(ary), 0);
      arity = arity === undefined ? arity : toInteger_1(arity);
      length -= holders ? holders.length : 0;

      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG$2) {
        var partialsRight = partials,
            holdersRight = holders;

        partials = holders = undefined;
      }
      var data = isBindKey ? undefined : _getData(func);

      var newData = [
        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
        argPos, ary, arity
      ];

      if (data) {
        _mergeData(newData, data);
      }
      func = newData[0];
      bitmask = newData[1];
      thisArg = newData[2];
      partials = newData[3];
      holders = newData[4];
      arity = newData[9] = newData[9] === undefined
        ? (isBindKey ? 0 : func.length)
        : nativeMax$3(newData[9] - length, 0);

      if (!arity && bitmask & (WRAP_CURRY_FLAG$4 | WRAP_CURRY_RIGHT_FLAG$2)) {
        bitmask &= ~(WRAP_CURRY_FLAG$4 | WRAP_CURRY_RIGHT_FLAG$2);
      }
      if (!bitmask || bitmask == WRAP_BIND_FLAG$6) {
        var result = _createBind(func, bitmask, thisArg);
      } else if (bitmask == WRAP_CURRY_FLAG$4 || bitmask == WRAP_CURRY_RIGHT_FLAG$2) {
        result = _createCurry(func, bitmask, arity);
      } else if ((bitmask == WRAP_PARTIAL_FLAG$2 || bitmask == (WRAP_BIND_FLAG$6 | WRAP_PARTIAL_FLAG$2)) && !holders.length) {
        result = _createPartial(func, bitmask, thisArg, partials);
      } else {
        result = _createHybrid.apply(undefined, newData);
      }
      var setter = data ? _baseSetData : _setData;
      return _setWrapToString(setter(result, newData), func, bitmask);
    }

    var _createWrap = createWrap;

    /** Used to compose bitmasks for function metadata. */
    var WRAP_BIND_FLAG$7 = 1,
        WRAP_PARTIAL_FLAG$3 = 32;

    /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and `partials` prepended to the arguments it receives.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * function greet(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * }
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */
    var bind = _baseRest(function(func, thisArg, partials) {
      var bitmask = WRAP_BIND_FLAG$7;
      if (partials.length) {
        var holders = _replaceHolders(partials, _getHolder(bind));
        bitmask |= WRAP_PARTIAL_FLAG$3;
      }
      return _createWrap(func, bitmask, thisArg, partials, holders);
    });

    // Assign default placeholders.
    bind.placeholder = {};

    var bind_1 = bind;

    var global$1 = typeof global !== "undefined" ? global :
                typeof self !== "undefined" ? self :
                typeof window !== "undefined" ? window : {}

    // shim for using process in browser
    // based off https://github.com/defunctzombie/node-process/blob/master/browser.js

    function defaultSetTimout() {
        throw new Error('setTimeout has not been defined');
    }
    function defaultClearTimeout () {
        throw new Error('clearTimeout has not been defined');
    }
    var cachedSetTimeout = defaultSetTimout;
    var cachedClearTimeout = defaultClearTimeout;
    if (typeof global$1.setTimeout === 'function') {
        cachedSetTimeout = setTimeout;
    }
    if (typeof global$1.clearTimeout === 'function') {
        cachedClearTimeout = clearTimeout;
    }

    function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
            //normal enviroments in sane situations
            return setTimeout(fun, 0);
        }
        // if setTimeout wasn't available but was latter defined
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
            cachedSetTimeout = setTimeout;
            return setTimeout(fun, 0);
        }
        try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedSetTimeout(fun, 0);
        } catch(e){
            try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                return cachedSetTimeout.call(null, fun, 0);
            } catch(e){
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                return cachedSetTimeout.call(this, fun, 0);
            }
        }


    }
    function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
            //normal enviroments in sane situations
            return clearTimeout(marker);
        }
        // if clearTimeout wasn't available but was latter defined
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
            cachedClearTimeout = clearTimeout;
            return clearTimeout(marker);
        }
        try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedClearTimeout(marker);
        } catch (e){
            try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                return cachedClearTimeout.call(null, marker);
            } catch (e){
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                return cachedClearTimeout.call(this, marker);
            }
        }



    }
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;

    function cleanUpNextTick() {
        if (!draining || !currentQueue) {
            return;
        }
        draining = false;
        if (currentQueue.length) {
            queue = currentQueue.concat(queue);
        } else {
            queueIndex = -1;
        }
        if (queue.length) {
            drainQueue();
        }
    }

    function drainQueue() {
        if (draining) {
            return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;

        var len = queue.length;
        while(len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
                if (currentQueue) {
                    currentQueue[queueIndex].run();
                }
            }
            queueIndex = -1;
            len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
    }
    function nextTick(fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
                args[i - 1] = arguments[i];
            }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
            runTimeout(drainQueue);
        }
    }
    // v8 likes predictible objects
    function Item(fun, array) {
        this.fun = fun;
        this.array = array;
    }
    Item.prototype.run = function () {
        this.fun.apply(null, this.array);
    };
    var title = 'browser';
    var platform = 'browser';
    var browser = true;
    var env = {};
    var argv = [];
    var version = ''; // empty string to avoid regexp issues
    var versions = {};
    var release = {};
    var config = {};

    function noop$1() {}

    var on = noop$1;
    var addListener = noop$1;
    var once = noop$1;
    var off = noop$1;
    var removeListener = noop$1;
    var removeAllListeners = noop$1;
    var emit = noop$1;

    function binding(name) {
        throw new Error('process.binding is not supported');
    }

    function cwd () { return '/' }
    function chdir (dir) {
        throw new Error('process.chdir is not supported');
    }function umask() { return 0; }

    // from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
    var performance = global$1.performance || {};
    var performanceNow =
      performance.now        ||
      performance.mozNow     ||
      performance.msNow      ||
      performance.oNow       ||
      performance.webkitNow  ||
      function(){ return (new Date()).getTime() };

    // generate timestamp or delta
    // see http://nodejs.org/api/process.html#process_process_hrtime
    function hrtime(previousTimestamp){
      var clocktime = performanceNow.call(performance)*1e-3;
      var seconds = Math.floor(clocktime);
      var nanoseconds = Math.floor((clocktime%1)*1e9);
      if (previousTimestamp) {
        seconds = seconds - previousTimestamp[0];
        nanoseconds = nanoseconds - previousTimestamp[1];
        if (nanoseconds<0) {
          seconds--;
          nanoseconds += 1e9;
        }
      }
      return [seconds,nanoseconds]
    }

    var startTime = new Date();
    function uptime() {
      var currentTime = new Date();
      var dif = currentTime - startTime;
      return dif / 1000;
    }

    var process = {
      nextTick: nextTick,
      title: title,
      browser: browser,
      env: env,
      argv: argv,
      version: version,
      versions: versions,
      on: on,
      addListener: addListener,
      once: once,
      off: off,
      removeListener: removeListener,
      removeAllListeners: removeAllListeners,
      emit: emit,
      binding: binding,
      cwd: cwd,
      chdir: chdir,
      umask: umask,
      hrtime: hrtime,
      platform: platform,
      release: release,
      config: config,
      uptime: uptime
    };

    var axios = createCommonjsModule(function (module, exports) {
    /* axios v0.18.0 | (c) 2018 by Matt Zabriskie */
    (function webpackUniversalModuleDefinition(root, factory) {
    	module.exports = factory();
    })(commonjsGlobal, function() {
    return /******/ (function(modules) { // webpackBootstrap
    /******/ 	// The module cache
    /******/ 	var installedModules = {};
    /******/
    /******/ 	// The require function
    /******/ 	function __webpack_require__(moduleId) {
    /******/
    /******/ 		// Check if module is in cache
    /******/ 		if(installedModules[moduleId])
    /******/ 			return installedModules[moduleId].exports;
    /******/
    /******/ 		// Create a new module (and put it into the cache)
    /******/ 		var module = installedModules[moduleId] = {
    /******/ 			exports: {},
    /******/ 			id: moduleId,
    /******/ 			loaded: false
    /******/ 		};
    /******/
    /******/ 		// Execute the module function
    /******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
    /******/
    /******/ 		// Flag the module as loaded
    /******/ 		module.loaded = true;
    /******/
    /******/ 		// Return the exports of the module
    /******/ 		return module.exports;
    /******/ 	}
    /******/
    /******/
    /******/ 	// expose the modules object (__webpack_modules__)
    /******/ 	__webpack_require__.m = modules;
    /******/
    /******/ 	// expose the module cache
    /******/ 	__webpack_require__.c = installedModules;
    /******/
    /******/ 	// __webpack_public_path__
    /******/ 	__webpack_require__.p = "";
    /******/
    /******/ 	// Load entry module and return exports
    /******/ 	return __webpack_require__(0);
    /******/ })
    /************************************************************************/
    /******/ ([
    /* 0 */
    /***/ (function(module, exports, __webpack_require__) {

    	module.exports = __webpack_require__(1);

    /***/ }),
    /* 1 */
    /***/ (function(module, exports, __webpack_require__) {
    	
    	var utils = __webpack_require__(2);
    	var bind = __webpack_require__(3);
    	var Axios = __webpack_require__(5);
    	var defaults = __webpack_require__(6);
    	
    	/**
    	 * Create an instance of Axios
    	 *
    	 * @param {Object} defaultConfig The default config for the instance
    	 * @return {Axios} A new instance of Axios
    	 */
    	function createInstance(defaultConfig) {
    	  var context = new Axios(defaultConfig);
    	  var instance = bind(Axios.prototype.request, context);
    	
    	  // Copy axios.prototype to instance
    	  utils.extend(instance, Axios.prototype, context);
    	
    	  // Copy context to instance
    	  utils.extend(instance, context);
    	
    	  return instance;
    	}
    	
    	// Create the default instance to be exported
    	var axios = createInstance(defaults);
    	
    	// Expose Axios class to allow class inheritance
    	axios.Axios = Axios;
    	
    	// Factory for creating new instances
    	axios.create = function create(instanceConfig) {
    	  return createInstance(utils.merge(defaults, instanceConfig));
    	};
    	
    	// Expose Cancel & CancelToken
    	axios.Cancel = __webpack_require__(23);
    	axios.CancelToken = __webpack_require__(24);
    	axios.isCancel = __webpack_require__(20);
    	
    	// Expose all/spread
    	axios.all = function all(promises) {
    	  return Promise.all(promises);
    	};
    	axios.spread = __webpack_require__(25);
    	
    	module.exports = axios;
    	
    	// Allow use of default import syntax in TypeScript
    	module.exports.default = axios;


    /***/ }),
    /* 2 */
    /***/ (function(module, exports, __webpack_require__) {
    	
    	var bind = __webpack_require__(3);
    	var isBuffer = __webpack_require__(4);
    	
    	/*global toString:true*/
    	
    	// utils is a library of generic helper functions non-specific to axios
    	
    	var toString = Object.prototype.toString;
    	
    	/**
    	 * Determine if a value is an Array
    	 *
    	 * @param {Object} val The value to test
    	 * @returns {boolean} True if value is an Array, otherwise false
    	 */
    	function isArray(val) {
    	  return toString.call(val) === '[object Array]';
    	}
    	
    	/**
    	 * Determine if a value is an ArrayBuffer
    	 *
    	 * @param {Object} val The value to test
    	 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
    	 */
    	function isArrayBuffer(val) {
    	  return toString.call(val) === '[object ArrayBuffer]';
    	}
    	
    	/**
    	 * Determine if a value is a FormData
    	 *
    	 * @param {Object} val The value to test
    	 * @returns {boolean} True if value is an FormData, otherwise false
    	 */
    	function isFormData(val) {
    	  return (typeof FormData !== 'undefined') && (val instanceof FormData);
    	}
    	
    	/**
    	 * Determine if a value is a view on an ArrayBuffer
    	 *
    	 * @param {Object} val The value to test
    	 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
    	 */
    	function isArrayBufferView(val) {
    	  var result;
    	  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    	    result = ArrayBuffer.isView(val);
    	  } else {
    	    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
    	  }
    	  return result;
    	}
    	
    	/**
    	 * Determine if a value is a String
    	 *
    	 * @param {Object} val The value to test
    	 * @returns {boolean} True if value is a String, otherwise false
    	 */
    	function isString(val) {
    	  return typeof val === 'string';
    	}
    	
    	/**
    	 * Determine if a value is a Number
    	 *
    	 * @param {Object} val The value to test
    	 * @returns {boolean} True if value is a Number, otherwise false
    	 */
    	function isNumber(val) {
    	  return typeof val === 'number';
    	}
    	
    	/**
    	 * Determine if a value is undefined
    	 *
    	 * @param {Object} val The value to test
    	 * @returns {boolean} True if the value is undefined, otherwise false
    	 */
    	function isUndefined(val) {
    	  return typeof val === 'undefined';
    	}
    	
    	/**
    	 * Determine if a value is an Object
    	 *
    	 * @param {Object} val The value to test
    	 * @returns {boolean} True if value is an Object, otherwise false
    	 */
    	function isObject(val) {
    	  return val !== null && typeof val === 'object';
    	}
    	
    	/**
    	 * Determine if a value is a Date
    	 *
    	 * @param {Object} val The value to test
    	 * @returns {boolean} True if value is a Date, otherwise false
    	 */
    	function isDate(val) {
    	  return toString.call(val) === '[object Date]';
    	}
    	
    	/**
    	 * Determine if a value is a File
    	 *
    	 * @param {Object} val The value to test
    	 * @returns {boolean} True if value is a File, otherwise false
    	 */
    	function isFile(val) {
    	  return toString.call(val) === '[object File]';
    	}
    	
    	/**
    	 * Determine if a value is a Blob
    	 *
    	 * @param {Object} val The value to test
    	 * @returns {boolean} True if value is a Blob, otherwise false
    	 */
    	function isBlob(val) {
    	  return toString.call(val) === '[object Blob]';
    	}
    	
    	/**
    	 * Determine if a value is a Function
    	 *
    	 * @param {Object} val The value to test
    	 * @returns {boolean} True if value is a Function, otherwise false
    	 */
    	function isFunction(val) {
    	  return toString.call(val) === '[object Function]';
    	}
    	
    	/**
    	 * Determine if a value is a Stream
    	 *
    	 * @param {Object} val The value to test
    	 * @returns {boolean} True if value is a Stream, otherwise false
    	 */
    	function isStream(val) {
    	  return isObject(val) && isFunction(val.pipe);
    	}
    	
    	/**
    	 * Determine if a value is a URLSearchParams object
    	 *
    	 * @param {Object} val The value to test
    	 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
    	 */
    	function isURLSearchParams(val) {
    	  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
    	}
    	
    	/**
    	 * Trim excess whitespace off the beginning and end of a string
    	 *
    	 * @param {String} str The String to trim
    	 * @returns {String} The String freed of excess whitespace
    	 */
    	function trim(str) {
    	  return str.replace(/^\s*/, '').replace(/\s*$/, '');
    	}
    	
    	/**
    	 * Determine if we're running in a standard browser environment
    	 *
    	 * This allows axios to run in a web worker, and react-native.
    	 * Both environments support XMLHttpRequest, but not fully standard globals.
    	 *
    	 * web workers:
    	 *  typeof window -> undefined
    	 *  typeof document -> undefined
    	 *
    	 * react-native:
    	 *  navigator.product -> 'ReactNative'
    	 */
    	function isStandardBrowserEnv() {
    	  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {
    	    return false;
    	  }
    	  return (
    	    typeof window !== 'undefined' &&
    	    typeof document !== 'undefined'
    	  );
    	}
    	
    	/**
    	 * Iterate over an Array or an Object invoking a function for each item.
    	 *
    	 * If `obj` is an Array callback will be called passing
    	 * the value, index, and complete array for each item.
    	 *
    	 * If 'obj' is an Object callback will be called passing
    	 * the value, key, and complete object for each property.
    	 *
    	 * @param {Object|Array} obj The object to iterate
    	 * @param {Function} fn The callback to invoke for each item
    	 */
    	function forEach(obj, fn) {
    	  // Don't bother if no value provided
    	  if (obj === null || typeof obj === 'undefined') {
    	    return;
    	  }
    	
    	  // Force an array if not already something iterable
    	  if (typeof obj !== 'object') {
    	    /*eslint no-param-reassign:0*/
    	    obj = [obj];
    	  }
    	
    	  if (isArray(obj)) {
    	    // Iterate over array values
    	    for (var i = 0, l = obj.length; i < l; i++) {
    	      fn.call(null, obj[i], i, obj);
    	    }
    	  } else {
    	    // Iterate over object keys
    	    for (var key in obj) {
    	      if (Object.prototype.hasOwnProperty.call(obj, key)) {
    	        fn.call(null, obj[key], key, obj);
    	      }
    	    }
    	  }
    	}
    	
    	/**
    	 * Accepts varargs expecting each argument to be an object, then
    	 * immutably merges the properties of each object and returns result.
    	 *
    	 * When multiple objects contain the same key the later object in
    	 * the arguments list will take precedence.
    	 *
    	 * Example:
    	 *
    	 * ```js
    	 * var result = merge({foo: 123}, {foo: 456});
    	 * console.log(result.foo); // outputs 456
    	 * ```
    	 *
    	 * @param {Object} obj1 Object to merge
    	 * @returns {Object} Result of all merge properties
    	 */
    	function merge(/* obj1, obj2, obj3, ... */) {
    	  var result = {};
    	  function assignValue(val, key) {
    	    if (typeof result[key] === 'object' && typeof val === 'object') {
    	      result[key] = merge(result[key], val);
    	    } else {
    	      result[key] = val;
    	    }
    	  }
    	
    	  for (var i = 0, l = arguments.length; i < l; i++) {
    	    forEach(arguments[i], assignValue);
    	  }
    	  return result;
    	}
    	
    	/**
    	 * Extends object a by mutably adding to it the properties of object b.
    	 *
    	 * @param {Object} a The object to be extended
    	 * @param {Object} b The object to copy properties from
    	 * @param {Object} thisArg The object to bind function to
    	 * @return {Object} The resulting value of object a
    	 */
    	function extend(a, b, thisArg) {
    	  forEach(b, function assignValue(val, key) {
    	    if (thisArg && typeof val === 'function') {
    	      a[key] = bind(val, thisArg);
    	    } else {
    	      a[key] = val;
    	    }
    	  });
    	  return a;
    	}
    	
    	module.exports = {
    	  isArray: isArray,
    	  isArrayBuffer: isArrayBuffer,
    	  isBuffer: isBuffer,
    	  isFormData: isFormData,
    	  isArrayBufferView: isArrayBufferView,
    	  isString: isString,
    	  isNumber: isNumber,
    	  isObject: isObject,
    	  isUndefined: isUndefined,
    	  isDate: isDate,
    	  isFile: isFile,
    	  isBlob: isBlob,
    	  isFunction: isFunction,
    	  isStream: isStream,
    	  isURLSearchParams: isURLSearchParams,
    	  isStandardBrowserEnv: isStandardBrowserEnv,
    	  forEach: forEach,
    	  merge: merge,
    	  extend: extend,
    	  trim: trim
    	};


    /***/ }),
    /* 3 */
    /***/ (function(module, exports) {
    	
    	module.exports = function bind(fn, thisArg) {
    	  return function wrap() {
    	    var args = new Array(arguments.length);
    	    for (var i = 0; i < args.length; i++) {
    	      args[i] = arguments[i];
    	    }
    	    return fn.apply(thisArg, args);
    	  };
    	};


    /***/ }),
    /* 4 */
    /***/ (function(module, exports) {

    	/*!
    	 * Determine if an object is a Buffer
    	 *
    	 * @author   Feross Aboukhadijeh <https://feross.org>
    	 * @license  MIT
    	 */
    	
    	// The _isBuffer check is for Safari 5-7 support, because it's missing
    	// Object.prototype.constructor. Remove this eventually
    	module.exports = function (obj) {
    	  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
    	};
    	
    	function isBuffer (obj) {
    	  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
    	}
    	
    	// For Node v0.10 support. Remove this eventually.
    	function isSlowBuffer (obj) {
    	  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
    	}


    /***/ }),
    /* 5 */
    /***/ (function(module, exports, __webpack_require__) {
    	
    	var defaults = __webpack_require__(6);
    	var utils = __webpack_require__(2);
    	var InterceptorManager = __webpack_require__(17);
    	var dispatchRequest = __webpack_require__(18);
    	
    	/**
    	 * Create a new instance of Axios
    	 *
    	 * @param {Object} instanceConfig The default config for the instance
    	 */
    	function Axios(instanceConfig) {
    	  this.defaults = instanceConfig;
    	  this.interceptors = {
    	    request: new InterceptorManager(),
    	    response: new InterceptorManager()
    	  };
    	}
    	
    	/**
    	 * Dispatch a request
    	 *
    	 * @param {Object} config The config specific for this request (merged with this.defaults)
    	 */
    	Axios.prototype.request = function request(config$$1) {
    	  /*eslint no-param-reassign:0*/
    	  // Allow for axios('example/url'[, config]) a la fetch API
    	  if (typeof config$$1 === 'string') {
    	    config$$1 = utils.merge({
    	      url: arguments[0]
    	    }, arguments[1]);
    	  }
    	
    	  config$$1 = utils.merge(defaults, {method: 'get'}, this.defaults, config$$1);
    	  config$$1.method = config$$1.method.toLowerCase();
    	
    	  // Hook up interceptors middleware
    	  var chain = [dispatchRequest, undefined];
    	  var promise = Promise.resolve(config$$1);
    	
    	  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    	    chain.unshift(interceptor.fulfilled, interceptor.rejected);
    	  });
    	
    	  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    	    chain.push(interceptor.fulfilled, interceptor.rejected);
    	  });
    	
    	  while (chain.length) {
    	    promise = promise.then(chain.shift(), chain.shift());
    	  }
    	
    	  return promise;
    	};
    	
    	// Provide aliases for supported request methods
    	utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
    	  /*eslint func-names:0*/
    	  Axios.prototype[method] = function(url, config$$1) {
    	    return this.request(utils.merge(config$$1 || {}, {
    	      method: method,
    	      url: url
    	    }));
    	  };
    	});
    	
    	utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
    	  /*eslint func-names:0*/
    	  Axios.prototype[method] = function(url, data, config$$1) {
    	    return this.request(utils.merge(config$$1 || {}, {
    	      method: method,
    	      url: url,
    	      data: data
    	    }));
    	  };
    	});
    	
    	module.exports = Axios;


    /***/ }),
    /* 6 */
    /***/ (function(module, exports, __webpack_require__) {
    	
    	var utils = __webpack_require__(2);
    	var normalizeHeaderName = __webpack_require__(7);
    	
    	var DEFAULT_CONTENT_TYPE = {
    	  'Content-Type': 'application/x-www-form-urlencoded'
    	};
    	
    	function setContentTypeIfUnset(headers, value) {
    	  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    	    headers['Content-Type'] = value;
    	  }
    	}
    	
    	function getDefaultAdapter() {
    	  var adapter;
    	  if (typeof XMLHttpRequest !== 'undefined') {
    	    // For browsers use XHR adapter
    	    adapter = __webpack_require__(8);
    	  } else if (typeof process !== 'undefined') {
    	    // For node use HTTP adapter
    	    adapter = __webpack_require__(8);
    	  }
    	  return adapter;
    	}
    	
    	var defaults = {
    	  adapter: getDefaultAdapter(),
    	
    	  transformRequest: [function transformRequest(data, headers) {
    	    normalizeHeaderName(headers, 'Content-Type');
    	    if (utils.isFormData(data) ||
    	      utils.isArrayBuffer(data) ||
    	      utils.isBuffer(data) ||
    	      utils.isStream(data) ||
    	      utils.isFile(data) ||
    	      utils.isBlob(data)
    	    ) {
    	      return data;
    	    }
    	    if (utils.isArrayBufferView(data)) {
    	      return data.buffer;
    	    }
    	    if (utils.isURLSearchParams(data)) {
    	      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
    	      return data.toString();
    	    }
    	    if (utils.isObject(data)) {
    	      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
    	      return JSON.stringify(data);
    	    }
    	    return data;
    	  }],
    	
    	  transformResponse: [function transformResponse(data) {
    	    /*eslint no-param-reassign:0*/
    	    if (typeof data === 'string') {
    	      try {
    	        data = JSON.parse(data);
    	      } catch (e) { /* Ignore */ }
    	    }
    	    return data;
    	  }],
    	
    	  /**
    	   * A timeout in milliseconds to abort a request. If set to 0 (default) a
    	   * timeout is not created.
    	   */
    	  timeout: 0,
    	
    	  xsrfCookieName: 'XSRF-TOKEN',
    	  xsrfHeaderName: 'X-XSRF-TOKEN',
    	
    	  maxContentLength: -1,
    	
    	  validateStatus: function validateStatus(status) {
    	    return status >= 200 && status < 300;
    	  }
    	};
    	
    	defaults.headers = {
    	  common: {
    	    'Accept': 'application/json, text/plain, */*'
    	  }
    	};
    	
    	utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
    	  defaults.headers[method] = {};
    	});
    	
    	utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
    	  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
    	});
    	
    	module.exports = defaults;


    /***/ }),
    /* 7 */
    /***/ (function(module, exports, __webpack_require__) {
    	
    	var utils = __webpack_require__(2);
    	
    	module.exports = function normalizeHeaderName(headers, normalizedName) {
    	  utils.forEach(headers, function processHeader(value, name) {
    	    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
    	      headers[normalizedName] = value;
    	      delete headers[name];
    	    }
    	  });
    	};


    /***/ }),
    /* 8 */
    /***/ (function(module, exports, __webpack_require__) {
    	
    	var utils = __webpack_require__(2);
    	var settle = __webpack_require__(9);
    	var buildURL = __webpack_require__(12);
    	var parseHeaders = __webpack_require__(13);
    	var isURLSameOrigin = __webpack_require__(14);
    	var createError = __webpack_require__(10);
    	var btoa = (typeof window !== 'undefined' && window.btoa && window.btoa.bind(window)) || __webpack_require__(15);
    	
    	module.exports = function xhrAdapter(config$$1) {
    	  return new Promise(function dispatchXhrRequest(resolve, reject) {
    	    var requestData = config$$1.data;
    	    var requestHeaders = config$$1.headers;
    	
    	    if (utils.isFormData(requestData)) {
    	      delete requestHeaders['Content-Type']; // Let the browser set it
    	    }
    	
    	    var request = new XMLHttpRequest();
    	    var loadEvent = 'onreadystatechange';
    	    var xDomain = false;
    	
    	    // For IE 8/9 CORS support
    	    // Only supports POST and GET calls and doesn't returns the response headers.
    	    // DON'T do this for testing b/c XMLHttpRequest is mocked, not XDomainRequest.
    	    if (("production") !== 'test' &&
    	        typeof window !== 'undefined' &&
    	        window.XDomainRequest && !('withCredentials' in request) &&
    	        !isURLSameOrigin(config$$1.url)) {
    	      request = new window.XDomainRequest();
    	      loadEvent = 'onload';
    	      xDomain = true;
    	      request.onprogress = function handleProgress() {};
    	      request.ontimeout = function handleTimeout() {};
    	    }
    	
    	    // HTTP basic authentication
    	    if (config$$1.auth) {
    	      var username = config$$1.auth.username || '';
    	      var password = config$$1.auth.password || '';
    	      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    	    }
    	
    	    request.open(config$$1.method.toUpperCase(), buildURL(config$$1.url, config$$1.params, config$$1.paramsSerializer), true);
    	
    	    // Set the request timeout in MS
    	    request.timeout = config$$1.timeout;
    	
    	    // Listen for ready state
    	    request[loadEvent] = function handleLoad() {
    	      if (!request || (request.readyState !== 4 && !xDomain)) {
    	        return;
    	      }
    	
    	      // The request errored out and we didn't get a response, this will be
    	      // handled by onerror instead
    	      // With one exception: request that using file: protocol, most browsers
    	      // will return status as 0 even though it's a successful request
    	      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
    	        return;
    	      }
    	
    	      // Prepare the response
    	      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
    	      var responseData = !config$$1.responseType || config$$1.responseType === 'text' ? request.responseText : request.response;
    	      var response = {
    	        data: responseData,
    	        // IE sends 1223 instead of 204 (https://github.com/axios/axios/issues/201)
    	        status: request.status === 1223 ? 204 : request.status,
    	        statusText: request.status === 1223 ? 'No Content' : request.statusText,
    	        headers: responseHeaders,
    	        config: config$$1,
    	        request: request
    	      };
    	
    	      settle(resolve, reject, response);
    	
    	      // Clean up request
    	      request = null;
    	    };
    	
    	    // Handle low level network errors
    	    request.onerror = function handleError() {
    	      // Real errors are hidden from us by the browser
    	      // onerror should only fire if it's a network error
    	      reject(createError('Network Error', config$$1, null, request));
    	
    	      // Clean up request
    	      request = null;
    	    };
    	
    	    // Handle timeout
    	    request.ontimeout = function handleTimeout() {
    	      reject(createError('timeout of ' + config$$1.timeout + 'ms exceeded', config$$1, 'ECONNABORTED',
    	        request));
    	
    	      // Clean up request
    	      request = null;
    	    };
    	
    	    // Add xsrf header
    	    // This is only done if running in a standard browser environment.
    	    // Specifically not if we're in a web worker, or react-native.
    	    if (utils.isStandardBrowserEnv()) {
    	      var cookies = __webpack_require__(16);
    	
    	      // Add xsrf header
    	      var xsrfValue = (config$$1.withCredentials || isURLSameOrigin(config$$1.url)) && config$$1.xsrfCookieName ?
    	          cookies.read(config$$1.xsrfCookieName) :
    	          undefined;
    	
    	      if (xsrfValue) {
    	        requestHeaders[config$$1.xsrfHeaderName] = xsrfValue;
    	      }
    	    }
    	
    	    // Add headers to the request
    	    if ('setRequestHeader' in request) {
    	      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
    	        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
    	          // Remove Content-Type if data is undefined
    	          delete requestHeaders[key];
    	        } else {
    	          // Otherwise add header to the request
    	          request.setRequestHeader(key, val);
    	        }
    	      });
    	    }
    	
    	    // Add withCredentials to request if needed
    	    if (config$$1.withCredentials) {
    	      request.withCredentials = true;
    	    }
    	
    	    // Add responseType to request if needed
    	    if (config$$1.responseType) {
    	      try {
    	        request.responseType = config$$1.responseType;
    	      } catch (e) {
    	        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
    	        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
    	        if (config$$1.responseType !== 'json') {
    	          throw e;
    	        }
    	      }
    	    }
    	
    	    // Handle progress if needed
    	    if (typeof config$$1.onDownloadProgress === 'function') {
    	      request.addEventListener('progress', config$$1.onDownloadProgress);
    	    }
    	
    	    // Not all browsers support upload events
    	    if (typeof config$$1.onUploadProgress === 'function' && request.upload) {
    	      request.upload.addEventListener('progress', config$$1.onUploadProgress);
    	    }
    	
    	    if (config$$1.cancelToken) {
    	      // Handle cancellation
    	      config$$1.cancelToken.promise.then(function onCanceled(cancel) {
    	        if (!request) {
    	          return;
    	        }
    	
    	        request.abort();
    	        reject(cancel);
    	        // Clean up request
    	        request = null;
    	      });
    	    }
    	
    	    if (requestData === undefined) {
    	      requestData = null;
    	    }
    	
    	    // Send the request
    	    request.send(requestData);
    	  });
    	};


    /***/ }),
    /* 9 */
    /***/ (function(module, exports, __webpack_require__) {
    	
    	var createError = __webpack_require__(10);
    	
    	/**
    	 * Resolve or reject a Promise based on response status.
    	 *
    	 * @param {Function} resolve A function that resolves the promise.
    	 * @param {Function} reject A function that rejects the promise.
    	 * @param {object} response The response.
    	 */
    	module.exports = function settle(resolve, reject, response) {
    	  var validateStatus = response.config.validateStatus;
    	  // Note: status is not exposed by XDomainRequest
    	  if (!response.status || !validateStatus || validateStatus(response.status)) {
    	    resolve(response);
    	  } else {
    	    reject(createError(
    	      'Request failed with status code ' + response.status,
    	      response.config,
    	      null,
    	      response.request,
    	      response
    	    ));
    	  }
    	};


    /***/ }),
    /* 10 */
    /***/ (function(module, exports, __webpack_require__) {
    	
    	var enhanceError = __webpack_require__(11);
    	
    	/**
    	 * Create an Error with the specified message, config, error code, request and response.
    	 *
    	 * @param {string} message The error message.
    	 * @param {Object} config The config.
    	 * @param {string} [code] The error code (for example, 'ECONNABORTED').
    	 * @param {Object} [request] The request.
    	 * @param {Object} [response] The response.
    	 * @returns {Error} The created error.
    	 */
    	module.exports = function createError(message, config$$1, code, request, response) {
    	  var error = new Error(message);
    	  return enhanceError(error, config$$1, code, request, response);
    	};


    /***/ }),
    /* 11 */
    /***/ (function(module, exports) {
    	
    	/**
    	 * Update an Error with the specified config, error code, and response.
    	 *
    	 * @param {Error} error The error to update.
    	 * @param {Object} config The config.
    	 * @param {string} [code] The error code (for example, 'ECONNABORTED').
    	 * @param {Object} [request] The request.
    	 * @param {Object} [response] The response.
    	 * @returns {Error} The error.
    	 */
    	module.exports = function enhanceError(error, config$$1, code, request, response) {
    	  error.config = config$$1;
    	  if (code) {
    	    error.code = code;
    	  }
    	  error.request = request;
    	  error.response = response;
    	  return error;
    	};


    /***/ }),
    /* 12 */
    /***/ (function(module, exports, __webpack_require__) {
    	
    	var utils = __webpack_require__(2);
    	
    	function encode(val) {
    	  return encodeURIComponent(val).
    	    replace(/%40/gi, '@').
    	    replace(/%3A/gi, ':').
    	    replace(/%24/g, '$').
    	    replace(/%2C/gi, ',').
    	    replace(/%20/g, '+').
    	    replace(/%5B/gi, '[').
    	    replace(/%5D/gi, ']');
    	}
    	
    	/**
    	 * Build a URL by appending params to the end
    	 *
    	 * @param {string} url The base of the url (e.g., http://www.google.com)
    	 * @param {object} [params] The params to be appended
    	 * @returns {string} The formatted url
    	 */
    	module.exports = function buildURL(url, params, paramsSerializer) {
    	  /*eslint no-param-reassign:0*/
    	  if (!params) {
    	    return url;
    	  }
    	
    	  var serializedParams;
    	  if (paramsSerializer) {
    	    serializedParams = paramsSerializer(params);
    	  } else if (utils.isURLSearchParams(params)) {
    	    serializedParams = params.toString();
    	  } else {
    	    var parts = [];
    	
    	    utils.forEach(params, function serialize(val, key) {
    	      if (val === null || typeof val === 'undefined') {
    	        return;
    	      }
    	
    	      if (utils.isArray(val)) {
    	        key = key + '[]';
    	      } else {
    	        val = [val];
    	      }
    	
    	      utils.forEach(val, function parseValue(v) {
    	        if (utils.isDate(v)) {
    	          v = v.toISOString();
    	        } else if (utils.isObject(v)) {
    	          v = JSON.stringify(v);
    	        }
    	        parts.push(encode(key) + '=' + encode(v));
    	      });
    	    });
    	
    	    serializedParams = parts.join('&');
    	  }
    	
    	  if (serializedParams) {
    	    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
    	  }
    	
    	  return url;
    	};


    /***/ }),
    /* 13 */
    /***/ (function(module, exports, __webpack_require__) {
    	
    	var utils = __webpack_require__(2);
    	
    	// Headers whose duplicates are ignored by node
    	// c.f. https://nodejs.org/api/http.html#http_message_headers
    	var ignoreDuplicateOf = [
    	  'age', 'authorization', 'content-length', 'content-type', 'etag',
    	  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
    	  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
    	  'referer', 'retry-after', 'user-agent'
    	];
    	
    	/**
    	 * Parse headers into an object
    	 *
    	 * ```
    	 * Date: Wed, 27 Aug 2014 08:58:49 GMT
    	 * Content-Type: application/json
    	 * Connection: keep-alive
    	 * Transfer-Encoding: chunked
    	 * ```
    	 *
    	 * @param {String} headers Headers needing to be parsed
    	 * @returns {Object} Headers parsed into an object
    	 */
    	module.exports = function parseHeaders(headers) {
    	  var parsed = {};
    	  var key;
    	  var val;
    	  var i;
    	
    	  if (!headers) { return parsed; }
    	
    	  utils.forEach(headers.split('\n'), function parser(line) {
    	    i = line.indexOf(':');
    	    key = utils.trim(line.substr(0, i)).toLowerCase();
    	    val = utils.trim(line.substr(i + 1));
    	
    	    if (key) {
    	      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
    	        return;
    	      }
    	      if (key === 'set-cookie') {
    	        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
    	      } else {
    	        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
    	      }
    	    }
    	  });
    	
    	  return parsed;
    	};


    /***/ }),
    /* 14 */
    /***/ (function(module, exports, __webpack_require__) {
    	
    	var utils = __webpack_require__(2);
    	
    	module.exports = (
    	  utils.isStandardBrowserEnv() ?
    	
    	  // Standard browser envs have full support of the APIs needed to test
    	  // whether the request URL is of the same origin as current location.
    	  (function standardBrowserEnv() {
    	    var msie = /(msie|trident)/i.test(navigator.userAgent);
    	    var urlParsingNode = document.createElement('a');
    	    var originURL;
    	
    	    /**
    	    * Parse a URL to discover it's components
    	    *
    	    * @param {String} url The URL to be parsed
    	    * @returns {Object}
    	    */
    	    function resolveURL(url) {
    	      var href = url;
    	
    	      if (msie) {
    	        // IE needs attribute set twice to normalize properties
    	        urlParsingNode.setAttribute('href', href);
    	        href = urlParsingNode.href;
    	      }
    	
    	      urlParsingNode.setAttribute('href', href);
    	
    	      // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
    	      return {
    	        href: urlParsingNode.href,
    	        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
    	        host: urlParsingNode.host,
    	        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
    	        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
    	        hostname: urlParsingNode.hostname,
    	        port: urlParsingNode.port,
    	        pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
    	                  urlParsingNode.pathname :
    	                  '/' + urlParsingNode.pathname
    	      };
    	    }
    	
    	    originURL = resolveURL(window.location.href);
    	
    	    /**
    	    * Determine if a URL shares the same origin as the current location
    	    *
    	    * @param {String} requestURL The URL to test
    	    * @returns {boolean} True if URL shares the same origin, otherwise false
    	    */
    	    return function isURLSameOrigin(requestURL) {
    	      var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
    	      return (parsed.protocol === originURL.protocol &&
    	            parsed.host === originURL.host);
    	    };
    	  })() :
    	
    	  // Non standard browser envs (web workers, react-native) lack needed support.
    	  (function nonStandardBrowserEnv() {
    	    return function isURLSameOrigin() {
    	      return true;
    	    };
    	  })()
    	);


    /***/ }),
    /* 15 */
    /***/ (function(module, exports) {
    	
    	// btoa polyfill for IE<10 courtesy https://github.com/davidchambers/Base64.js
    	
    	var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
    	
    	function E() {
    	  this.message = 'String contains an invalid character';
    	}
    	E.prototype = new Error;
    	E.prototype.code = 5;
    	E.prototype.name = 'InvalidCharacterError';
    	
    	function btoa(input) {
    	  var str = String(input);
    	  var output = '';
    	  for (
    	    // initialize result and counter
    	    var block, charCode, idx = 0, map = chars;
    	    // if the next str index does not exist:
    	    //   change the mapping table to "="
    	    //   check if d has no fractional digits
    	    str.charAt(idx | 0) || (map = '=', idx % 1);
    	    // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
    	    output += map.charAt(63 & block >> 8 - idx % 1 * 8)
    	  ) {
    	    charCode = str.charCodeAt(idx += 3 / 4);
    	    if (charCode > 0xFF) {
    	      throw new E();
    	    }
    	    block = block << 8 | charCode;
    	  }
    	  return output;
    	}
    	
    	module.exports = btoa;


    /***/ }),
    /* 16 */
    /***/ (function(module, exports, __webpack_require__) {
    	
    	var utils = __webpack_require__(2);
    	
    	module.exports = (
    	  utils.isStandardBrowserEnv() ?
    	
    	  // Standard browser envs support document.cookie
    	  (function standardBrowserEnv() {
    	    return {
    	      write: function write(name, value, expires, path, domain, secure) {
    	        var cookie = [];
    	        cookie.push(name + '=' + encodeURIComponent(value));
    	
    	        if (utils.isNumber(expires)) {
    	          cookie.push('expires=' + new Date(expires).toGMTString());
    	        }
    	
    	        if (utils.isString(path)) {
    	          cookie.push('path=' + path);
    	        }
    	
    	        if (utils.isString(domain)) {
    	          cookie.push('domain=' + domain);
    	        }
    	
    	        if (secure === true) {
    	          cookie.push('secure');
    	        }
    	
    	        document.cookie = cookie.join('; ');
    	      },
    	
    	      read: function read(name) {
    	        var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
    	        return (match ? decodeURIComponent(match[3]) : null);
    	      },
    	
    	      remove: function remove(name) {
    	        this.write(name, '', Date.now() - 86400000);
    	      }
    	    };
    	  })() :
    	
    	  // Non standard browser env (web workers, react-native) lack needed support.
    	  (function nonStandardBrowserEnv() {
    	    return {
    	      write: function write() {},
    	      read: function read() { return null; },
    	      remove: function remove() {}
    	    };
    	  })()
    	);


    /***/ }),
    /* 17 */
    /***/ (function(module, exports, __webpack_require__) {
    	
    	var utils = __webpack_require__(2);
    	
    	function InterceptorManager() {
    	  this.handlers = [];
    	}
    	
    	/**
    	 * Add a new interceptor to the stack
    	 *
    	 * @param {Function} fulfilled The function to handle `then` for a `Promise`
    	 * @param {Function} rejected The function to handle `reject` for a `Promise`
    	 *
    	 * @return {Number} An ID used to remove interceptor later
    	 */
    	InterceptorManager.prototype.use = function use(fulfilled, rejected) {
    	  this.handlers.push({
    	    fulfilled: fulfilled,
    	    rejected: rejected
    	  });
    	  return this.handlers.length - 1;
    	};
    	
    	/**
    	 * Remove an interceptor from the stack
    	 *
    	 * @param {Number} id The ID that was returned by `use`
    	 */
    	InterceptorManager.prototype.eject = function eject(id) {
    	  if (this.handlers[id]) {
    	    this.handlers[id] = null;
    	  }
    	};
    	
    	/**
    	 * Iterate over all the registered interceptors
    	 *
    	 * This method is particularly useful for skipping over any
    	 * interceptors that may have become `null` calling `eject`.
    	 *
    	 * @param {Function} fn The function to call for each interceptor
    	 */
    	InterceptorManager.prototype.forEach = function forEach(fn) {
    	  utils.forEach(this.handlers, function forEachHandler(h) {
    	    if (h !== null) {
    	      fn(h);
    	    }
    	  });
    	};
    	
    	module.exports = InterceptorManager;


    /***/ }),
    /* 18 */
    /***/ (function(module, exports, __webpack_require__) {
    	
    	var utils = __webpack_require__(2);
    	var transformData = __webpack_require__(19);
    	var isCancel = __webpack_require__(20);
    	var defaults = __webpack_require__(6);
    	var isAbsoluteURL = __webpack_require__(21);
    	var combineURLs = __webpack_require__(22);
    	
    	/**
    	 * Throws a `Cancel` if cancellation has been requested.
    	 */
    	function throwIfCancellationRequested(config$$1) {
    	  if (config$$1.cancelToken) {
    	    config$$1.cancelToken.throwIfRequested();
    	  }
    	}
    	
    	/**
    	 * Dispatch a request to the server using the configured adapter.
    	 *
    	 * @param {object} config The config that is to be used for the request
    	 * @returns {Promise} The Promise to be fulfilled
    	 */
    	module.exports = function dispatchRequest(config$$1) {
    	  throwIfCancellationRequested(config$$1);
    	
    	  // Support baseURL config
    	  if (config$$1.baseURL && !isAbsoluteURL(config$$1.url)) {
    	    config$$1.url = combineURLs(config$$1.baseURL, config$$1.url);
    	  }
    	
    	  // Ensure headers exist
    	  config$$1.headers = config$$1.headers || {};
    	
    	  // Transform request data
    	  config$$1.data = transformData(
    	    config$$1.data,
    	    config$$1.headers,
    	    config$$1.transformRequest
    	  );
    	
    	  // Flatten headers
    	  config$$1.headers = utils.merge(
    	    config$$1.headers.common || {},
    	    config$$1.headers[config$$1.method] || {},
    	    config$$1.headers || {}
    	  );
    	
    	  utils.forEach(
    	    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    	    function cleanHeaderConfig(method) {
    	      delete config$$1.headers[method];
    	    }
    	  );
    	
    	  var adapter = config$$1.adapter || defaults.adapter;
    	
    	  return adapter(config$$1).then(function onAdapterResolution(response) {
    	    throwIfCancellationRequested(config$$1);
    	
    	    // Transform response data
    	    response.data = transformData(
    	      response.data,
    	      response.headers,
    	      config$$1.transformResponse
    	    );
    	
    	    return response;
    	  }, function onAdapterRejection(reason) {
    	    if (!isCancel(reason)) {
    	      throwIfCancellationRequested(config$$1);
    	
    	      // Transform response data
    	      if (reason && reason.response) {
    	        reason.response.data = transformData(
    	          reason.response.data,
    	          reason.response.headers,
    	          config$$1.transformResponse
    	        );
    	      }
    	    }
    	
    	    return Promise.reject(reason);
    	  });
    	};


    /***/ }),
    /* 19 */
    /***/ (function(module, exports, __webpack_require__) {
    	
    	var utils = __webpack_require__(2);
    	
    	/**
    	 * Transform the data for a request or a response
    	 *
    	 * @param {Object|String} data The data to be transformed
    	 * @param {Array} headers The headers for the request or response
    	 * @param {Array|Function} fns A single function or Array of functions
    	 * @returns {*} The resulting transformed data
    	 */
    	module.exports = function transformData(data, headers, fns) {
    	  /*eslint no-param-reassign:0*/
    	  utils.forEach(fns, function transform(fn) {
    	    data = fn(data, headers);
    	  });
    	
    	  return data;
    	};


    /***/ }),
    /* 20 */
    /***/ (function(module, exports) {
    	
    	module.exports = function isCancel(value) {
    	  return !!(value && value.__CANCEL__);
    	};


    /***/ }),
    /* 21 */
    /***/ (function(module, exports) {
    	
    	/**
    	 * Determines whether the specified URL is absolute
    	 *
    	 * @param {string} url The URL to test
    	 * @returns {boolean} True if the specified URL is absolute, otherwise false
    	 */
    	module.exports = function isAbsoluteURL(url) {
    	  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
    	  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
    	  // by any combination of letters, digits, plus, period, or hyphen.
    	  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
    	};


    /***/ }),
    /* 22 */
    /***/ (function(module, exports) {
    	
    	/**
    	 * Creates a new URL by combining the specified URLs
    	 *
    	 * @param {string} baseURL The base URL
    	 * @param {string} relativeURL The relative URL
    	 * @returns {string} The combined URL
    	 */
    	module.exports = function combineURLs(baseURL, relativeURL) {
    	  return relativeURL
    	    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    	    : baseURL;
    	};


    /***/ }),
    /* 23 */
    /***/ (function(module, exports) {
    	
    	/**
    	 * A `Cancel` is an object that is thrown when an operation is canceled.
    	 *
    	 * @class
    	 * @param {string=} message The message.
    	 */
    	function Cancel(message) {
    	  this.message = message;
    	}
    	
    	Cancel.prototype.toString = function toString() {
    	  return 'Cancel' + (this.message ? ': ' + this.message : '');
    	};
    	
    	Cancel.prototype.__CANCEL__ = true;
    	
    	module.exports = Cancel;


    /***/ }),
    /* 24 */
    /***/ (function(module, exports, __webpack_require__) {
    	
    	var Cancel = __webpack_require__(23);
    	
    	/**
    	 * A `CancelToken` is an object that can be used to request cancellation of an operation.
    	 *
    	 * @class
    	 * @param {Function} executor The executor function.
    	 */
    	function CancelToken(executor) {
    	  if (typeof executor !== 'function') {
    	    throw new TypeError('executor must be a function.');
    	  }
    	
    	  var resolvePromise;
    	  this.promise = new Promise(function promiseExecutor(resolve) {
    	    resolvePromise = resolve;
    	  });
    	
    	  var token = this;
    	  executor(function cancel(message) {
    	    if (token.reason) {
    	      // Cancellation has already been requested
    	      return;
    	    }
    	
    	    token.reason = new Cancel(message);
    	    resolvePromise(token.reason);
    	  });
    	}
    	
    	/**
    	 * Throws a `Cancel` if cancellation has been requested.
    	 */
    	CancelToken.prototype.throwIfRequested = function throwIfRequested() {
    	  if (this.reason) {
    	    throw this.reason;
    	  }
    	};
    	
    	/**
    	 * Returns an object that contains a new `CancelToken` and a function that, when called,
    	 * cancels the `CancelToken`.
    	 */
    	CancelToken.source = function source() {
    	  var cancel;
    	  var token = new CancelToken(function executor(c) {
    	    cancel = c;
    	  });
    	  return {
    	    token: token,
    	    cancel: cancel
    	  };
    	};
    	
    	module.exports = CancelToken;


    /***/ }),
    /* 25 */
    /***/ (function(module, exports) {
    	
    	/**
    	 * Syntactic sugar for invoking a function and expanding an array for arguments.
    	 *
    	 * Common use case would be to use `Function.prototype.apply`.
    	 *
    	 *  ```js
    	 *  function f(x, y, z) {}
    	 *  var args = [1, 2, 3];
    	 *  f.apply(null, args);
    	 *  ```
    	 *
    	 * With `spread` this example can be re-written.
    	 *
    	 *  ```js
    	 *  spread(function(x, y, z) {})([1, 2, 3]);
    	 *  ```
    	 *
    	 * @param {Function} callback
    	 * @returns {Function}
    	 */
    	module.exports = function spread(callback) {
    	  return function wrap(arr) {
    	    return callback.apply(null, arr);
    	  };
    	};


    /***/ })
    /******/ ])
    });
    //# sourceMappingURL=axios.map
    });

    var PROXY_CONFIG_PROPERTIES = ['headers', 'params', 'data'];
    var PROXY_CONFIG_METHODS = {
      get: function get(prop, context) {
        return function () {
          return context[prop];
        };
      },
      set: function set(prop, context) {
        return function (value) {
          context[prop] = value;
        };
      },
      add: function add(prop, context) {
        return function (key, value) {
          context[prop][key] = value;
        };
      },
      remove: function remove(prop, context) {
        return function (key) {
          delete context[prop][key];
        };
      },
      merge: function merge(prop, context) {
        return function (key, values) {
          extend(context[prop], key);
        };
      }
    };

    var method = function method(action, prop) {
      return camelCase_1([action, prop].join(' '));
    };

    var chainable = function chainable(prop) {
      var _this = this;

      return function (key, value) {
        if (key instanceof FormData) {
          _this[method('set', prop)](key);
        } else if (isObject_1(key)) {
          _this[method('merge', prop)](key);
        } else {
          _this[method('add', prop)](key, value);
        }

        return _this;
      };
    };

    var Request =
    /*#__PURE__*/
    function () {
      function Request(url) {
        var _this2 = this;

        var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        _classCallCheck(this, Request);

        this.$config = extend({
          url: url,
          headers: {},
          params: {},
          data: {}
        }, config);

        each(PROXY_CONFIG_METHODS, function (callback, key) {
          _this2[method(key, 'config')] = bind_1(callback)('$config', _this2);
        });

        this['config'] = bind_1(chainable, this)('config');

        each(PROXY_CONFIG_PROPERTIES, function (prop) {
          each(PROXY_CONFIG_METHODS, function (callback, key) {
            _this2[method(key, prop)] = bind_1(callback)(prop, _this2.$config);
          });

          _this2[prop] = bind_1(chainable, _this2)(prop);
        });

        this.reset();
      }

      _createClass(Request, [{
        key: "reset",
        value: function reset() {
          this.$error = null;
          this.$status = null;
          this.$statusText = null;
          this.$response = null;
          this.$requestSentAt = null;
          this.$responseReceivedAt = null;
        }
      }, {
        key: "hasSent",
        value: function hasSent() {
          return !!this.$requestSentAt;
        }
      }, {
        key: "hasResponse",
        value: function hasResponse() {
          return !!this.$responseReceivedAt;
        }
      }, {
        key: "passed",
        value: function passed() {
          return this.hasResponse() && !this.$error;
        }
      }, {
        key: "failed",
        value: function failed() {
          return this.hasResponse() && !!this.$error;
        }
      }, {
        key: "getUrl",
        value: function getUrl() {
          return this.$url;
        }
      }, {
        key: "setUrl",
        value: function setUrl(url) {
          this.$url = url;
        }
      }, {
        key: "get",
        value: function get() {
          var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          var headers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          return this.params(params).headers(headers).request('get');
        }
      }, {
        key: "post",
        value: function post() {
          var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          var headers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          return this.data(data).headers(headers).request('post');
        }
      }, {
        key: "put",
        value: function put() {
          var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          var headers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          return this.data(data).headers(headers).request('put');
        }
      }, {
        key: "delete",
        value: function _delete() {
          var headers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          return this.headers(headers).request('delete');
        }
      }, {
        key: "request",
        value: function request(method) {
          var _this3 = this;

          this.reset();
          this.$requestSentAt = moment();
          this.addConfig('method', method);
          var promise = new Promise(function (resolve, reject) {
            axios.request(_this3.$config).then(function (response) {
              _this3.$response = response;
              _this3.$responseReceivedAt = moment();
              _this3.$status = response.status;
              _this3.$statusText = response.statusText;
              resolve(response.data);
            }, function (error) {
              _this3.$error = error;
              _this3.$response = error.response;
              _this3.$responseReceivedAt = moment();
              _this3.$status = error.response.status;
              _this3.$statusText = error.response.statusText;
              reject(error.response.data.errors);
            });
          });
          return promise;
        }
      }]);

      return Request;
    }();

    var Model =
    /*#__PURE__*/
    function () {
      /**
       * Initialize the model instance
       *
       * @param data object
       * @return void
       */
      function Model() {
        var _this = this;

        var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        _classCallCheck(this, Model);

        this.$changed = {};
        this.$exists = false;
        this.$attributes = {};
        this.$key = this.key();
        this.$files = this.files();
        this.$table = this.table();
        this.$properties = this.properties();
        this.initialize(data);

        each(params, function (value, key) {
          _this[key] = value;
        });

        if (!this.$table) {
          throw new Error('A table must be defined for every model.');
        }

        this.$initialized = true;
      }
      /**
       * Initialize the model with the given data without considering the data
       * as "changed".
       *
       * @param data object
       * @return this
       */


      _createClass(Model, [{
        key: "initialize",
        value: function initialize(data) {
          this.$initialized = false;
          this.fill(data);
          this.$initialized = true;
          return this;
        }
        /**
         * Define the corresponding database table (aka API endpoint slug).
         *
         * @return string
         */

      }, {
        key: "table",
        value: function table() {} //

        /**
         * Define a primary key. This is used to determine if the model exists and
         * which endpoint to use.
         *
         * @return string
         */

      }, {
        key: "key",
        value: function key() {
          return 'id';
        }
        /**
         * Return an array of properties that are sent to the API. If no properties
         * are defined, then all the attributes will be included in the request.
         *
         * @return array
         */

      }, {
        key: "properties",
        value: function properties() {
          return [];
        }
        /**
         * Return an array of file properties that are sent to the API. If no fies
         * are defined, then request will always be sent with JSON vs. multipart.
         *
         * @return array
         */

      }, {
        key: "files",
        value: function files() {
          return [];
        }
        /**
         * Set the attributes in the model with the data given.
         *
         * @param data object
         * @return this
         */

      }, {
        key: "fill",
        value: function fill(data) {
          this.setAttributes(data);
          return this;
        }
        /**
         * Get one or more attributes from the model.
         *
         * @param data string|array
         * @return array|mixed
         */

      }, {
        key: "get",
        value: function get(key) {
          if (isArray_1(key) || isObject_1(key)) {
            return this.getAttributes().filter(function (value) {
              return data.indexOf(value) !== -1;
            });
          } else {
            return this.getAttribute(key);
          }
        }
        /**
         * Alias for setAttributes() except this method returns `this`. This method
         * also accepts an array of values or key/value pair.
         *
         * @return this
         */

      }, {
        key: "set",
        value: function set(key) {
          var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

          if (isArray_1(key) || isObject_1(key)) {
            this.setAttributes(key);
          } else {
            this.setAttribute(key, value);
          }

          return this;
        }
        /**
         * Get all the defined attributes.
         *
         * @return array
         */

      }, {
        key: "getAttributes",
        value: function getAttributes() {
          return this.$attributes;
        }
        /**
         * Get the changed attributes
         *
         * @return array
         */

      }, {
        key: "getChangedAttributes",
        value: function getChangedAttributes() {
          return keys_1(this.$changed);
        }
        /**
         * Get the changed attributes
         *
         * @return array
         */

      }, {
        key: "getOriginalValue",
        value: function getOriginalValue(key) {
          return this.$changed[key] || this.$attributes[key];
        }
        /**
         * Get the unchanged attributes
         *
         * @return array
         */

      }, {
        key: "getUnchangedAttributes",
        value: function getUnchangedAttributes() {
          var _this2 = this;

          return filter_1(keys_1(this.$attributes), function (key) {
            return !(key in _this2.$changed);
          });
        }
        /**
         * Get an attribute with a given key. If no key is defined
         *
         * @param key string
         * @param default undefined|mixed
         * @return array
         */

      }, {
        key: "getAttribute",
        value: function getAttribute(key) {
          var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
          return this.$attributes[key] || value;
        }
        /**
         * Set an array or object of data as attributes.
         *
         * @param attributes array|object
         * @return void
         */

      }, {
        key: "setAttributes",
        value: function setAttributes(data) {
          var _this3 = this;

          if (!isArray_1(data) && !isObject_1(data)) {
            throw new Error('Attributes must be set with an array or object.');
          }

          each(data, function (value, key) {
            _this3.setAttribute(key, value);
          });
        }
        /**
         * Set an attribute with a given key/value pair. This will track the changes
         * in the model within the `this.$changed` property. If the primary key
         * is set, it will also change the `this.$exists` property.
         *
         * @param key string
         * @param value mixed
         * @return void
         */

      }, {
        key: "setAttribute",
        value: function setAttribute(key, value) {
          if (this.getAttribute(key) !== value) {
            this.handleAttributeChange(key, value);

            if (isUndefined_1(value)) {
              delete this.$attributes[key];
            } else {
              this.$attributes[key] = value;
            }
          }
        }
        /**
         * Revert the model to its original state.
         *
         * @return bool
         */

      }, {
        key: "revert",
        value: function revert() {
          var _this4 = this;

          each(this.$changed, function (value, key) {
            if (!isUndefined_1(value)) {
              _this4.$attributes[key] = value;
            } else {
              delete _this4.$attributes[key];
            }
          });

          this.$changed = {};
        }
        /**
         * Returns if the model has a primary key set.
         *
         * @return bool
         */

      }, {
        key: "exists",
        value: function exists() {
          return !!this.$exists;
        }
        /**
         * Returns the model been changed or not.
         *
         * @return bool
         */

      }, {
        key: "hasChanged",
        value: function hasChanged(key) {
          return !key ? size_1(this.$changed) > 0 : !isUndefined_1(this.$changed[key]);
        }
        /**
         * Does the model have any File objects. If so, need to send as multipart.
         *
         * @return bool
         */

      }, {
        key: "hasFiles",
        value: function hasFiles() {
          function count(files) {
            var total = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            return reduce_1(files, function (carry, value) {
              if (isArray_1(value)) {
                return carry + count(value, total);
              } else if (value instanceof File || value instanceof FileList) {
                return carry + 1;
              } else {
                return carry;
              }
            }, total);
          }

          return count(this.toJSON()) !== 0;
        }
        /**
         * Handle settings the $changed attributes when an attribute value is set.
         *
         * @param key string
         * @param value mixed
         * @return void
         */

      }, {
        key: "handleAttributeChange",
        value: function handleAttributeChange(key, value) {
          if (this.$initialized) {
            if (this.$changed[key] === value) {
              delete this.$changed[key];
            } else if (!(key in this.$changed)) {
              this.$changed[key] = this.getAttribute(key);
            }
          }

          this.handlePrimaryKeyChange(key, value);
        }
        /**
         * Set an array or object of data as attributes.
         *
         * @param key string
         * @param value mixed
         * @return void
         */

      }, {
        key: "handlePrimaryKeyChange",
        value: function handlePrimaryKeyChange(key, value) {
          if (this.$key === key) {
            this.$exists = !isUndefined_1(value) && !isNull_1(value);
          }
        }
        /**
         * Save the model to the database
         *
         * @param data object
         * @return bool
         */

      }, {
        key: "save",
        value: function save() {
          var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          return this.exists() ? this.create(data, config) : this.update(data, config);
        }
        /**
         * Create a new model
         *
         * @param data object
         * @return bool
         */

      }, {
        key: "create",
        value: function create() {
          var _this5 = this;

          var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

          if (this.exists()) {
            return this.update(data, config);
          }

          this.fill(data);
          var request = this.request("/api/".concat(this.table()), extend({
            data: !this.hasFiles() ? this.toJson() : this.toFormData()
          }, config));
          return request.post().then(function (response) {
            return _this5.fill(response);
          });
        }
        /**
         * Update an existing model
         *
         * @param data object
         * @return bool
         */

      }, {
        key: "update",
        value: function update() {
          var _this6 = this;

          var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

          if (!this.exists()) {
            return this.create(data, config);
          }

          this.fill(data);
          var request = this.request("/api/".concat(this.table(), "/").concat(this.get(this.key())), extend({
            data: !this.hasFiles() ? this.toJson() : this.toFormData()
          }, config));
          return request[this.hasFiles() ? 'post' : 'put']().then(function (response) {
            return _this6.fill(response);
          });
        }
        /**
         * Delete an existing model
         *
         * @param data object
         * @return bool
         */

      }, {
        key: "delete",
        value: function _delete() {
          var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

          if (!this.exists()) {
            throw new Error('The model must have a primary key before it can be delete.');
          }

          this.fill(data);
          return this.request("/api/".concat(this.table(), "/").concat(this.get(this.key())), config).delete();
        }
        /**
         * Find an existing model by id
         *
         * @param data object
         * @return bool
         */

      }, {
        key: "search",
        value: function search() {
          var _this7 = this;

          var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          return new Promise(function (resolve, reject) {
            _this7.request("/api/".concat(_this7.table()), extend({
              params: params
            }, config)).get().then(function (response) {
              resolve(map_1(response.data, function (data) {
                return new _this7.constructor(data);
              }));
            }, function (errors) {
              reject(errors);
            });
          });
        }
        /**
         * Find an existing model by id
         *
         * @param data object
         * @return bool
         */

      }, {
        key: "find",
        value: function find(id) {
          var _this8 = this;

          var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          return new Promise(function (resolve, reject) {
            _this8.request("/api/".concat(_this8.table(), "/").concat(id), config).get().then(function (response) {
              resolve(_this8.initialize(response));
            }, function (errors) {
              reject(errors);
            });
          });
        }
        /**
         * Create a request from the model data
         *
         * @param data object
         * @return bool
         */

      }, {
        key: "request",
        value: function request(url) {
          var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          return new Request(url, config);
        }
        /**
         * Convert the Model instance to a FormData instance
         *
         * @return object
         */

      }, {
        key: "toFormData",
        value: function toFormData() {
          var form = new FormData();

          each(this.toJSON(), function (value, key) {
            if (isArray_1(value)) {
              each(value, function (item) {
                if (!(item instanceof File) && (isObject_1(item) || isArray_1(item))) {
                  item = JSON.stringify(item);
                }

                form.append(key.replace(/(.+)(\[.+\]?)$/, '$1') + '[]', item);
              });
            } else if (!(value instanceof File) && isObject_1(value)) {
              form.append(key, JSON.stringify(value));
            } else if (!isNull_1(value)) {
              form.append(key, value);
            }
          });

          return form;
        }
        /**
         * Convert the instance to JSON payload
         *
         * @return object
         */

      }, {
        key: "toJSON",
        value: function toJSON() {
          var _this9 = this;

          return pickBy_1(this.$attributes, function (value, key) {
            return !_this9.$properties.length || key === _this9.key() || _this9.$properties.indexOf(key) !== -1;
          });
        }
        /**
         * Alias for toJSON
         *
         * @return object
         */

      }, {
        key: "toJson",
        value: function toJson() {
          return this.toJSON();
        }
      }]);

      return Model;
    }();

    var BaseForm = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('form', {
          class: {
            'form-inline': _vm.inline
          },
          attrs: {
            "novalidate": _vm.novalidate
          },
          on: {
            "submit": function submit($event) {
              $event.preventDefault();
              return _vm.onSubmit($event);
            }
          }
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      props: {
        /**
         * The Model method used to send the request.
         *
         * @property Boolean
         */
        method: {
          type: String,
          default: 'save',
          validate: function validate(value) {
            return this.model && isFunction_1(this.model[value]);
          }
        },

        /**
         * An object of form data
         *
         * @property Object
         */
        data: {
          type: Object,
          default: function _default() {
            return {};
          }
        },

        /**
         * Display the form fields inline
         *
         * @property Object
         */
        model: {
          type: Object,
          validate: function validate(value) {
            return value instanceof Model;
          }
        },

        /**
         * Display the form fields inline
         *
         * @property Boolean
         */
        inline: Boolean,

        /**
         * A callback function for the `submit` event
         *
         * @property Boolean
         */
        novalidate: {
          type: Boolean,
          default: true
        },

        /**
         * A URI or URL used to redirect user after form submits successfully.
         *
         * @property Function|String
         */
        redirect: [Object, String, Function],

        /**
         * A callback function for the `submit` event
         *
         * @property Function
         */
        onSubmit: {
          type: Function,
          default: function _default(event) {
            this.model && this.submit();
          }
        },

        /**
         * A callback function for the `submit:success` event
         *
         * @property Function
         */
        onSubmitSuccess: {
          type: Function,
          default: function _default(event, data) {
            this.$emit('submit:success', event, data);
            this.$emit('submit:complete', event, true, data);

            if (this.redirect && isFunction_1(this.redirect)) {
              this.redirect(this);
            } else if (this.redirect) {
              this.$router.push(this.redirect);
            }
          }
        },

        /**
         * A callback function for the `submit:success` event
         *
         * @property Function
         */
        onSubmitFailed: {
          type: Function,
          default: function _default(event, errors) {
            this.$emit('submit:failed', event, errors);
            this.$emit('submit:complete', event, false, errors);
          }
        }
      },
      methods: {
        submit: function submit(event) {
          var _this = this;

          this.$emit('submit', event);
          return this.model[this.method](this.data, {
            onUploadProgress: function onUploadProgress(event) {
              _this.$emit('submit:progress', event);
            }
          }).then(function (data) {
            _this.onSubmitSuccess(event, data);
          }, function (errors) {
            _this.onSubmitFailed(event, errors);
          });
        }
      },
      data: function data() {
        return {
          errors: {}
        };
      }
    };

    var plugin$5 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          BaseForm: BaseForm
        });
      }
    });

    var Breadcrumb = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('nav', {
          attrs: {
            "aria-label": "breadcrumb"
          }
        }, [_c('ol', {
          staticClass: "breadcrumb"
        }, [_vm._l(_vm.items, function (item, i) {
          return _vm.items.length ? _c('breadcrumb-item', _vm._b({
            key: i,
            attrs: {
              "current": i === item.length - 1
            }
          }, 'breadcrumb-item', item, false)) : _vm._e();
        }), _vm._v(" "), _vm._t("default")], 2)]);
      },
      staticRenderFns: [],
      name: 'breadcrumb',
      props: {
        /**
         * An array of breadcrumbs
         *
         * @prop {Array}
         */
        items: Array
      }
    };

    var BreadcrumbItem = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('li', {
          staticClass: "breadcrumb-item",
          class: {
            'active': _vm.active
          },
          attrs: {
            "aria-current": _vm.active ? 'page' : false
          }
        }, [!_vm.active && _vm.href ? _c('a', {
          attrs: {
            "href": _vm.href
          }
        }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))])], 2) : [_vm._t("default", [_vm._v(_vm._s(_vm.label))])]], 2);
      },
      staticRenderFns: [],
      name: 'breadcrumb-item',
      props: {
        /**
         * Is the item active?
         *
         * @prop {Boolean}
         */
        active: Boolean,

        /**
         * An href attribute
         *
         * @prop {String}
         */
        href: String,

        /**
         * An breadcrumb label
         *
         * @prop {String}
         */
        label: String
      }
    };

    var plugin$6 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          Breadcrumb: Breadcrumb,
          BreadcrumbItem: BreadcrumbItem
        });
      }
    });

    var Sizeable = {
      props: {
        /**
         * The size of the form control
         *
         * @property String
         */
        size: {
          type: String,
          default: 'md',
          validate: function validate(value) {
            return ['sm', 'md', 'lg'].indexOf(value) !== -1;
          }
        }
      },
      computed: {
        sizeableClass: function sizeableClass() {
          return prefix(this.size, this.$options.name);
        }
      }
    };

    var Btn = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _vm.label ? _c('label', {
          staticClass: "btn",
          class: _vm.classes,
          attrs: {
            "disabled": _vm.disabled
          },
          on: {
            "click": _vm.onClick
          }
        }, [_vm._t("default")], 2) : _vm.href ? _c('a', {
          staticClass: "btn",
          class: _vm.classes,
          attrs: {
            "href": _vm.href,
            "disabled": _vm.disabled
          },
          on: {
            "click": _vm.onClick
          }
        }, [_vm._t("default")], 2) : _c('button', {
          staticClass: "btn",
          class: _vm.classes,
          attrs: {
            "type": _vm.type,
            "disabled": _vm.disabled
          },
          on: {
            "click": _vm.onClick
          }
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'btn',
      mixins: [Variant, Sizeable],
      props: {
        /**
         * Should use <label> as the element for the button. Used for inputs
         * wrappers (toggles).
         *
         * @property Boolean
         */
        label: Boolean,

        /**
         * If an href is passed, button is an anchor element
         *
         * @property Boolean
         */
        href: String,

        /**
         * The type attribute for the button. Not applied if an anchor
         *
         * @property String
         */
        type: {
          type: String,
          default: 'submit'
        },

        /**
         * Display button with active state
         *
         * @property String
         */
        active: Boolean,

        /**
         * Display button with blocked state
         *
         * @property String
         */
        block: Boolean,

        /**
         * Display button with disabled state
         *
         * @property String
         */
        disabled: Boolean,

        /**
         * Display as an outline button
         *
         * @property String
         */
        outline: Boolean
      },
      methods: {
        onClick: function onClick(event) {
          this.$emit('click', event, this);
        }
      },
      computed: {
        variantClassPrefix: function variantClassPrefix() {
          return this.$options.name + (this.outline ? '-outline' : '');
        },
        classes: function classes() {
          return this.$mergeClasses(this.variantClass, this.sizeableClass, this.block ? 'btn-block' : '', this.active ? 'active' : '');
        }
      }
    };

    var plugin$7 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          Btn: Btn
        });
      }
    });

    /** Error message constants. */
    var FUNC_ERROR_TEXT$2 = 'Expected a function';

    /**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new negated function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */
    function negate(predicate) {
      if (typeof predicate != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT$2);
      }
      return function() {
        var args = arguments;
        switch (args.length) {
          case 0: return !predicate.call(this);
          case 1: return !predicate.call(this, args[0]);
          case 2: return !predicate.call(this, args[0], args[1]);
          case 3: return !predicate.call(this, args[0], args[1], args[2]);
        }
        return !predicate.apply(this, args);
      };
    }

    var negate_1 = negate;

    /**
     * The opposite of `_.pickBy`; this method creates an object composed of
     * the own and inherited enumerable string keyed properties of `object` that
     * `predicate` doesn't return truthy for. The predicate is invoked with two
     * arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omitBy(object, _.isNumber);
     * // => { 'b': '2' }
     */
    function omitBy(object, predicate) {
      return pickBy_1(object, negate_1(_baseIteratee(predicate)));
    }

    var omitBy_1 = omitBy;

    var COLORS = ['primary', 'secondary', 'success', 'danger', 'warning', 'info', 'light', 'dark', 'white', 'muted'];
    var props = {};

    each(['border', 'text', 'bg', 'bg-gradient'], function (namespace) {
      each(COLORS, function (color) {
        props[camelCase_1(prefix(color, namespace))] = Boolean;
      });
    });

    function classes(instance, namespace) {
      return filter_1(map_1(COLORS, function (color) {
        return instance[camelCase_1(color = prefix(color, namespace))] ? color : null;
      }));
    }

    var Colorable = {
      props: props,
      methods: {
        textColor: function textColor() {
          return classes(this, 'text');
        },
        bgColor: function bgColor() {
          return classes(this, 'bg');
        },
        borderColor: function borderColor() {
          return classes(this, 'border');
        },
        bgGradientColor: function bgGradientColor() {
          return classes(this, 'bg-gradient');
        }
      },
      computed: {
        textColorClasses: function textColorClasses() {
          return this.textColor().join(' ').trim() || null;
        },
        borderColorClasses: function borderColorClasses() {
          return this.borderColor().join(' ').trim() || null;
        },
        bgColorClasses: function bgColorClasses() {
          return this.bgColor().join(' ').trim() || null;
        },
        bgGradientColorClasses: function bgGradientColorClasses() {
          return this.bgGradientColor().join(' ').trim() || null;
        },
        colorableClasses: function colorableClasses() {
          var classes = {};
          classes[this.textColorClasses] = !!this.textColorClasses;
          classes[this.borderColorClasses] = !!this.borderColorClasses;
          classes[this.bgColorClasses] = !!this.bgColorClasses;
          classes[this.bgGradientColorClasses] = !!this.bgGradientColorClasses;
          return omitBy_1(classes, function (key, value) {
            return !key || !value;
          });
        }
      }
    };

    var BtnGroup = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          class: _vm.classes,
          attrs: {
            "role": "group"
          }
        }, [_vm._l(_vm.buttons, function (button, i) {
          return _vm.buttons ? _c('btn', _vm._b({
            key: i
          }, 'btn', button, false)) : _vm._e();
        }), _vm._v(" "), _vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'btn-group',
      mixins: [Colorable, Sizeable],
      props: {
        /**
         * An array of buttons
         *
         * @prop {Array}
         */
        buttons: Array,

        /**
         * Display the buttons vertically
         *
         * @prop {Boolean}
         */
        vertical: Boolean
      },
      computed: {
        classes: function classes() {
          return this.$mergeClasses(this.sizeableClass, this.colorableClasses, {
            'btn-group': !this.vertical,
            'btn-group-vertical': this.vertical
          });
        }
      }
    };

    var BtnToolbar = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "btn-toolbar",
          attrs: {
            "role": "toolbar"
          }
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'btn-toolbar'
    };

    var plugin$8 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          BtnGroup: BtnGroup,
          BtnToolbar: BtnToolbar
        });
      }
    });

    function uuid() {
      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        var r = Math.random() * 16 | 0,
            v = c == 'x' ? r : r & 0x3 | 0x8;
        return v.toString(16);
      });
    }

    var Proxy = {
      methods: {
        proxy: function proxy(callback, event) {
          if (isFunction_1(callback)) {
            callback.apply(this, [].slice.call(arguments).splice(1));
            event.preventDefault();
          }
        }
      }
    };

    var DropdownMenuItem = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('a', {
          staticClass: "dropdown-item",
          class: {
            'active': _vm.active
          },
          attrs: {
            "href": _vm.href || '#'
          },
          on: {
            "click": function click($event) {
              _vm.proxy(_vm.onClick, $event);

              _vm.onClicked($event);
            }
          }
        }, [_vm.icon ? _c('i', {
          class: _vm.icon
        }) : _vm._e(), _vm._v(" "), _vm._t("default", [_vm._v(_vm._s(_vm.label))])], 2);
      },
      staticRenderFns: [],
      mixins: [Proxy],
      props: {
        /**
         * Is the menu item active.
         *
         * @property Object
         */
        active: Boolean,

        /**
         * The `href` attribute.
         *
         * @property Object
         */
        href: String,

        /**
         * The label of the dropdown menu item.
         *
         * @property Object
         */
        label: String,

        /**
         * The icon of the dropdown menu item.
         *
         * @property Object
         */
        icon: String,

        /**
         * A callback function for the `click` event.
         *
         * @property Object
         */
        onClick: Function
      },
      methods: {
        /**
         * A callback function for the `click` event.
         *
         * @property Object
         */
        onClicked: function onClicked(event) {
          if (!this.href) {
            event.preventDefault();
          }

          this.$emit('click', event);
        }
      }
    };

    var DropdownMenuHeader = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('h5', {
          staticClass: "dropdown-header"
        }, [_vm._v(" " + _vm._s(_vm.header) + " "), _vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'dropdown-menu-header',
      props: {
        /**
         * The value of the header
         *
         * @property Object
         */
        header: String
      }
    };

    var DropdownMenuDivider = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "dropdown-divider"
        });
      },
      staticRenderFns: [],
      name: 'dropdown-menu-divider'
    };

    var DropdownMenu = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "dropdown-menu",
          class: {
            'dropdown-menu-right': _vm.align === 'right',
            'show': _vm.show
          },
          attrs: {
            "aria-labelledby": _vm.id
          }
        }, [_vm._t("default", [_vm._l(_vm.items, function (item) {
          return [_c(_vm.prefix(item.type || 'item', 'dropdown-menu'), _vm._b({
            tag: "component",
            on: {
              "click": function click($event) {
                _vm.onClick($event, item);
              }
            }
          }, 'component', item, false))];
        })])], 2);
      },
      staticRenderFns: [],
      components: {
        DropdownMenuItem: DropdownMenuItem,
        DropdownMenuHeader: DropdownMenuHeader,
        DropdownMenuDivider: DropdownMenuDivider
      },
      props: {
        /**
         * The `id` attribute on the toggle button and aria label. If no `id` is
         * defined, then a UUID will be generated instead.
         *
         * @property Object
         */
        id: {
          type: String,
          default: uuid
        },

        /**
         * Display the dropdown menu aligned left or right
         *
         * @property String
         */
        align: {
          type: String,
          default: 'left',
          validate: function validate(value) {
            return ['left', 'right'].indexOf(value.toLowerCase()) !== -1;
          }
        },

        /**
         * The default visibility of the dropdown menu.
         *
         * @property Object
         */
        show: Boolean,

        /**
         * An array of dropdown items. If an key/value pair isn't defined, the
         * default value will be used. If no items are defined, then the slot
         * named "items" can be used to define the options with HTML.
         *
         * [{
         *      type: 'item', // String [item|header|divider]
         *      href: '#', // String
         *      label: 'Some label', // String
         *      onClick: (event) => {} // Function
         * }]
         *
         * @property Array
         */
        items: Array
      },
      methods: {
        prefix: prefix,

        /**
         * A callback function for the `click` event.
         *
         * @param Object event
         * @param Object item
         * @return void
         */
        onClick: function onClick(event, item) {
          this.$emit('item:click', event, item);
          this.$emit('update:show', false);
        }
      }
    };

    var plugin$9 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          DropdownMenu: DropdownMenu,
          DropdownMenuDivider: DropdownMenuDivider,
          DropdownMenuHeader: DropdownMenuHeader,
          DropdownMenuItem: DropdownMenuItem
        });
      }
    });

    var ButtonDropdown = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "btn-group",
          class: {
            'dropup': _vm.dropup,
            'dropright': _vm.dropright,
            'dropleft': _vm.dropleft
          }
        }, [_vm._t("toggle-button", [_vm.split ? [_vm.href ? _c('a', {
          class: _vm.actionClasses,
          attrs: {
            "href": _vm.href
          },
          on: {
            "click": _vm.onClick
          }
        }, [_vm._t("label-wrapper", [_vm.icon ? _c('i', {
          class: _vm.icon
        }) : _vm._e(), _vm._v(" "), _vm._t("label", [_vm._v(_vm._s(_vm.label))])])], 2) : _c('button', {
          class: _vm.actionClasses,
          attrs: {
            "type": _vm.type
          },
          on: {
            "click": _vm.onClick
          }
        }, [_vm._t("label-wrapper", [_vm.icon ? _c('i', {
          class: _vm.icon
        }) : _vm._e(), _vm._v(" "), _vm._t("label", [_vm._v(_vm._s(_vm.label))])])], 2), _vm._v(" "), _c('button', {
          class: _vm.toggleClasses,
          attrs: {
            "type": "button",
            "aria-haspopup": "true",
            "aria-expanded": _vm.isDropdownShowing,
            "id": _vm.id
          },
          on: {
            "click": function click($event) {
              $event.preventDefault();
              !_vm.isDropdownShowing ? _vm.show() : _vm.hide();
            },
            "blur": _vm.onBlur
          }
        })] : [_c('button', {
          class: _vm.toggleClasses,
          attrs: {
            "aria-haspopup": "true",
            "aria-expanded": _vm.isDropdownShowing,
            "type": _vm.type,
            "id": _vm.id
          },
          on: {
            "click": function click($event) {
              $event.preventDefault();
              !_vm.isDropdownShowing ? _vm.show() : _vm.hide();
            },
            "blur": _vm.onBlur
          }
        }, [_vm._t("label-wrapper", [_vm.icon ? _c('i', {
          class: _vm.icon
        }) : _vm._e(), _vm._v(" "), _vm._t("label", [_vm._v(_vm._s(_vm.label))])])], 2)]]), _vm._v(" "), _vm._t("dropdown-menu", [_c('dropdown-menu', {
          attrs: {
            "id": _vm.id,
            "items": _vm.items,
            "align": _vm.align,
            "show": _vm.isDropdownShowing
          },
          on: {
            "update:show": function updateShow($event) {
              _vm.isDropdownShowing = $event;
            },
            "item:click": _vm.onItemClick
          }
        }, [_vm._t("default")], 2)])], 2);
      },
      staticRenderFns: [],
      name: 'button-dropdown',
      components: {
        DropdownMenu: DropdownMenu
      },
      props: {
        /**
         * An array of dropdown items. If an key/value pair isn't defined, the
         * default value will be used. If no items are defined, then the slot
         * named "items" can be used to define the options with HTML.
         *
         * [{
         *      type: 'item', // String [item|header|divider]
         *      href: '#', // String
         *      label: 'Some label', // String
         *      onClick: (event) => {} // Function
         * }]
         *
         * @property Array
         */
        items: Array,

        /**
         * The `href` attribute on the action button (if a split button).
         *
         * @property String
         */
        href: String,

        /**
         * The button icon that appears before the label.
         *
         * @property String
         */
        icon: String,

        /**
         * The toggle button's label. If not defined as an attribute,
         * you can override with the component's slot (inner html).
         *
         * @property String
         */
        label: String,

        /**
         * The `id` attribute on the toggle button and aria label. If no `id` is
         * defined, then a UUID will be generated instead.
         *
         * @property String
         */
        id: {
          type: String,
          default: uuid
        },

        /**
         * The `type` attribute on the toggle button
         *
         * @property String
         */
        type: {
          type: String,
          default: 'button'
        },

        /**
         * The size class of the toggle button
         *
         * @property String
         */
        size: {
          type: String,
          default: 'md'
        },

        /**
         * The toggle button's variant class.
         *
         * @property String
         */
        variant: {
          type: String,
          default: 'primary'
        },

        /**
         * Display the dropdown menu aligned left or right
         *
         * @property String
         */
        align: {
          type: String,
          default: 'left',
          validate: function validate(value) {
            return ['left', 'right'].indexOf(value.toLowerCase()) !== -1;
          }
        },

        /**
         * Display the dropdown button with a split toggle button.
         *
         * @property Boolean
         */
        split: {
          type: Boolean,
          default: false
        },

        /**
         * Display as a dropup instead of a dropdown.
         *
         * @property Boolean
         */
        dropup: {
          type: Boolean,
          default: false
        },

        /**
         * Display as a dropright instead of a dropdown.
         *
         * @property Boolean
         */
        dropright: {
          type: Boolean,
          default: false
        },

        /**
         * Display as a dropleft instead of a dropdown.
         *
         * @property Boolean
         */
        dropleft: {
          type: Boolean,
          default: false
        }
      },
      methods: {
        /**
         * Toggle the dropdown menu
         *
         * @return void
         */
        toggle: function toggle() {
          !this.isDropdownShowing ? this.show() : this.hide();
        },

        /**
         * Show the dropdown menu
         *
         * @return void
         */
        show: function show() {
          this.$emit('toggle', this.isDropdownShowing = true);
          this.$emit('show');
        },

        /**
         * Hide the dropdown menu
         *
         * @return void
         */
        hide: function hide() {
          this.$emit('toggle', this.isDropdownShowing = false);
          this.$emit('hide');
        },

        /**
         * A callback function for the `click` event for the action button
         *
         * @return void
         */
        onClick: function onClick(event) {
          this.hide();
          this.$emit('click', event);
        },

        /**
         * A callback function for the `blur` event for the action button
         *
         * @return void
         */
        onBlur: function onBlur(event) {
          if (!this.$el.contains(event.relatedTarget)) {
            this.hide();
          }
        },

        /**
         * A callback function for the `item:click` event for the action button
         *
         * @return void
         */
        onItemClick: function onItemClick(event, child) {
          this.$emit('item:click', event, child);
        }
      },
      computed: {
        actionClasses: function actionClasses() {
          return ['btn', prefix(this.size, 'btn'), prefix(this.variant, 'btn')].join(' ');
        },
        toggleClasses: function toggleClasses() {
          return ['btn', 'dropdown-toggle', prefix(this.size, 'btn'), prefix(this.variant, 'btn'), this.split ? 'dropdown-toggle-split' : ''].join(' ');
        }
      },
      data: function data() {
        return {
          isDropdownShowing: false
        };
      }
    };

    var plugin$10 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          ButtonDropdown: ButtonDropdown
        });
      }
    });

    var HasSlots = {
      methods: {
        getSlot: function getSlot(slot) {
          return this.$slots[slot];
        },
        hasSlot: function hasSlot(slot) {
          return !!this.$slots[slot];
        },
        hasSlots: function hasSlots(slots) {
          for (var i in slots) {
            if (!this.hasSlot(slots[i])) {
              return false;
            }
          }
        }
      },
      computed: {
        hasDefaultSlot: function hasDefaultSlot() {
          return this.hasSlot('default');
        }
      }
    };

    var Card = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          class: _vm.$mergeClasses(_vm.className, _vm.colorableClasses)
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'card',
      mixins: [HasSlots, Colorable],
      computed: {
        className: function className() {
          return this.$options.name;
        }
      }
    };

    var CardBody = {
      name: 'card-body',
      extends: Card
    };

    var CardHeader = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c(_vm.element, {
          tag: "component",
          class: _vm.$mergeClasses(_vm.className, _vm.colorableClasses)
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'card-header',
      extends: Card,
      props: {
        /**
         * The alt attribute
         *
         * @property String
         */
        element: {
          type: String,
          default: 'div'
        }
      }
    };

    var CardFooter = {
      name: 'card-footer',
      extends: CardHeader
    };

    var CardImg = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return !_vm.hasDefaultSlot ? _c('img', {
          class: _vm.className,
          attrs: {
            "src": _vm.src,
            "alt": _vm.alt
          }
        }) : _c('div', {
          class: _vm.className
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'card-img',
      extends: Card,
      props: {
        /**
         * The alt attribute
         *
         * @property String
         */
        alt: String,

        /**
         * The src attribute
         *
         * @property String
         */
        src: String
      }
    };

    var CardImgTop = {
      name: 'card-img-top',
      extends: CardImg
    };

    var CardImgBottom = {
      name: 'card-img-bottom',
      extends: CardImg
    };

    var CardImgOverlay = {
      name: 'card-img-overlay',
      extends: Card
    };

    var CardLink = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('a', {
          class: _vm.$mergeClasses(_vm.className, _vm.colorableClasses),
          attrs: {
            "href": _vm.href
          },
          on: {
            "click": _vm.onClick
          }
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'card-title',
      extends: Card,
      props: {
        /**
         * The alt attribute
         *
         * @property String
         */
        alt: String,

        /**
         * The src attribute
         *
         * @property String
         */
        href: String
      },
      methods: {
        onClick: function onClick(event) {
          this.$emit('click', event, this);
        }
      }
    };

    var CardSubtitle = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('h6', {
          class: _vm.$mergeClasses(_vm.className, _vm.colorableClasses)
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'card-subtitle',
      extends: Card
    };

    var CardTitle = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('h5', {
          class: _vm.$mergeClasses(_vm.className, _vm.colorableClasses)
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'card-title',
      mixins: [Card]
    };

    var plugin$11 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          Card: Card,
          CardBody: CardBody,
          CardFooter: CardFooter,
          CardHeader: CardHeader,
          CardImg: CardImg,
          CardImgTop: CardImgTop,
          CardImgBottom: CardImgBottom,
          CardImgOverlay: CardImgOverlay,
          CardLink: CardLink,
          CardSubtitle: CardSubtitle,
          CardTitle: CardTitle
        });
      }
    });

    var FormControl = {
      props: {
        /**
         * The field id attribute value.
         *
         * @property String
         */
        id: [Number, String],

        /**
         * The value of label element. If no value, no label will appear.
         *
         * @property String
         */
        label: [Number, String],

        /**
         * The field name attribute value.
         *
         * @property String
         */
        name: String,

        /**
         * The field id attribute value.
         *
         * @property String
         */
        value: {
          default: null
        },

        /**
         * The placeholder attribute value.
         *
         * @property String
         */
        placeholder: String,

        /**
         * Is the field required.
         *
         * @property String
         */
        required: Boolean,

        /**
         * Add form-group wrapper to input
         *
         * @property String
         */
        group: {
          type: Boolean,
          value: true
        },

        /**
         * The regex pattern for validation.
         *
         * @property String
         */
        pattern: String,

        /**
         * An inline field validation error.
         *
         * @property String|Boolean
         */
        error: String,

        /**
         * An inline field validation errors passed as object with key/value
         * pairs. If errors passed as an object, the form name will be used for
         * the key.
         *
         * @property Object|Boolean
         */
        errors: [Object, Array],

        /**
         * Some feedback to add to the field once the field is successfully
         * valid.
         *
         * @property String
         */
        feedback: [String, Array],

        /**
         * An array of event names that correlate with callback functions
         *
         * @property Function
         */
        bindEvents: {
          type: Array,
          default: function _default() {
            return ['focus', 'blur', 'change', 'click', 'keyup', 'keydown', 'progress'];
          }
        },

        /**
         * The default class name assigned to the control element
         *
         * @property String
         */
        defaultControlClass: {
          type: String,
          default: 'form-control'
        },

        /**
         * Hide the label for browsers, but leave it for screen readers.
         *
         * @property String
         */
        hideLabel: Boolean,

        /**
         * Additional margin/padding classes for fine control of spacing
         *
         * @property String
         */
        spacing: String,

        /**
         * The size of the form control
         *
         * @property String
         */
        size: {
          type: String,
          default: 'md',
          validate: function validate(value) {
            return ['sm', 'md', 'lg'].indexOf(value) !== -1;
          }
        },

        /**
         * Display the form field inline
         *
         * @property String
         */
        inline: Boolean,

        /**
         * If the form control is readonly, display only as text?
         *
         * @property String
         */
        plaintext: Boolean,

        /**
         * Is the form control readonly?
         *
         * @property String
         */
        readonly: Boolean,

        /**
         * Is the form control disabled?
         *
         * @property String
         */
        disabled: Boolean,

        /**
         * Some instructions to appear under the field label
         *
         * @property String
         */
        helpText: String
      },
      directives: {
        bindEvents: {
          bind: function bind(el, binding, vnode) {
            var events = binding.value || vnode.context.bindEvents;

            each(events, function (name) {
              el.addEventListener(name, function (event) {
                vnode.context.$emit(name, event);
              });
            });
          }
        }
      },
      methods: {
        getInputField: function getInputField() {
          return this.$el.querySelector('.form-control, input, select, textarea');
        },
        getFieldErrors: function getFieldErrors() {
          var errors = this.error || this.errors;

          if (isObject_1(this.errors)) {
            errors = this.errors[this.name || this.id];
          }

          return !errors || isArray_1(errors) || isObject_1(errors) ? errors : [errors];
        },
        updated: function updated(value, event) {
          this.$emit(event || 'input', value);
        }
      },
      computed: {
        callbacks: function callbacks() {
          var _this = this;

          return this.bindEvents.map(function (event) {
            return {
              name: event,
              callback: _this[camelCase_1(['on', event].join(' '))]
            };
          }).filter(function (event) {
            return !isUndefined_1(event.callback);
          });
        },
        invalidFeedback: function invalidFeedback() {
          if (this.error) {
            return this.error;
          }

          var errors = this.getFieldErrors();
          return isArray_1(errors) ? errors.join('<br>') : errors;
        },
        validFeedback: function validFeedback() {
          return isArray_1(this.feedback) ? this.feedback.join('<br>') : this.feedback;
        },
        controlClass: function controlClass() {
          return this.defaultControlClass + (this.plaintext ? '-plaintext' : '');
        },
        controlSizeClass: function controlSizeClass() {
          return prefix(this.size, this.controlClass);
        },
        controlClasses: function controlClasses() {
          return [this.controlClass, this.controlSizeClass, this.spacing || '', this.invalidFeedback ? 'is-invalid' : ''].join(' ');
        },
        hasDefaultSlot: function hasDefaultSlot() {
          return !!this.$slots.default;
        }
      }
    };

    var RadioField = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          class: _vm.$mergeClasses(_vm.controlClass, _vm.customControlClass, _vm.sizeableClass, _vm.inline ? _vm.inlineClass : '')
        }, [_vm.custom && _vm.id ? [_c('input', {
          directives: [{
            name: "bind-events",
            rawName: "v-bind-events"
          }],
          class: _vm.$mergeClasses(_vm.inputClass, _vm.invalidFeedback ? 'is-invalid' : ''),
          attrs: {
            "type": "radio",
            "name": _vm.name,
            "id": _vm.id,
            "required": _vm.required,
            "disabled": _vm.disabled || _vm.readonly,
            "readonly": _vm.readonly,
            "pattern": _vm.pattern
          },
          domProps: {
            "value": _vm.value,
            "checked": _vm.checkedValue === _vm.value || _vm.checked
          },
          on: {
            "change": function change($event) {
              _vm.updated($event.target.value, 'change');
            }
          }
        }), _vm._v(" "), _c('label', {
          class: _vm.$mergeClasses(_vm.labelClass, _vm.colorableClasses),
          attrs: {
            "for": _vm.id
          }
        }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))]), _vm._v(" "), _vm._t("feedback", [_vm.validFeedback ? _c('form-feedback', {
          attrs: {
            "valid": ""
          },
          domProps: {
            "innerHTML": _vm._s(_vm.validFeedback)
          }
        }) : _vm._e(), _vm._v(" "), _vm.invalidFeedback ? _c('form-feedback', {
          attrs: {
            "invalid": ""
          },
          domProps: {
            "innerHTML": _vm._s(_vm.invalidFeedback)
          }
        }) : _vm._e()])], 2)] : [_c('label', {
          class: _vm.$mergeClasses(_vm.labelClass, _vm.colorableClasses),
          attrs: {
            "for": _vm.id
          }
        }, [_c('input', {
          directives: [{
            name: "bind-events",
            rawName: "v-bind-events"
          }],
          class: _vm.$mergeClasses(_vm.inputClass, _vm.invalidFeedback ? 'is-invalid' : ''),
          attrs: {
            "type": "radio",
            "name": _vm.name,
            "id": _vm.id,
            "required": _vm.required,
            "disabled": _vm.disabled || _vm.readonly,
            "readonly": _vm.readonly,
            "pattern": _vm.pattern
          },
          domProps: {
            "value": _vm.value,
            "checked": _vm.checkedValue === _vm.value || _vm.checked
          },
          on: {
            "change": function change($event) {
              _vm.updated($event.target.value, 'change');
            }
          }
        }), _vm._v(" "), _vm._t("default", [_vm._v(_vm._s(_vm.label))]), _vm._v(" "), _vm._t("feedback", [_vm.validFeedback ? _c('form-feedback', {
          attrs: {
            "valid": ""
          },
          domProps: {
            "innerHTML": _vm._s(_vm.validFeedback)
          }
        }) : _vm._e(), _vm._v(" "), _vm.invalidFeedback ? _c('form-feedback', {
          attrs: {
            "invalid": ""
          },
          domProps: {
            "innerHTML": _vm._s(_vm.invalidFeedback)
          }
        }) : _vm._e()])], 2)], _vm._v(" "), _vm._t("help", [_vm.helpText ? _c('help-text', {
          domProps: {
            "innerHTML": _vm._s(_vm.helpText)
          }
        }) : _vm._e()])], 2);
      },
      staticRenderFns: [],
      name: 'radio-field',
      mixins: [Colorable, FormControl],
      model: {
        event: 'change',
        prop: 'checkedValue'
      },
      props: {
        /**
         * An array of event names that correlate with callback functions
         *
         * @property Function
         */
        bindEvents: {
          type: Array,
          default: function _default() {
            return ['focus', 'blur', 'input', 'click', 'keyup', 'keydown', 'progress'];
          }
        },

        /**
         * Is this a custom element
         *
         * @property String
         */
        custom: Boolean,

        /**
         * Display the form field and label inline
         *
         * @property Function
         */
        inline: Boolean,

        /**
         * The checked values
         *
         * @property String
         */
        checked: Boolean,

        /**
         * The checked value
         *
         * @property String
         */
        checkedValue: [Boolean, Number, String, Object],

        /**
         * The class name assigned to the control element
         *
         * @property String
         */
        defaultControlClass: {
          type: String,
          default: 'form-check'
        }
      },
      computed: {
        labelClass: function labelClass() {
          return prefix('label', this.controlClass);
        },
        inputClass: function inputClass() {
          return prefix('input', this.controlClass);
        },
        inlineClass: function inlineClass() {
          return prefix('inline', this.controlClass);
        },
        controlClass: function controlClass() {
          return this.custom ? 'custom-control' : this.defaultControlClass;
        },
        customControlClass: function customControlClass() {
          return this.custom ? prefix(this.$options.name.replace('-field', ''), 'custom') : '';
        },
        sizeableClass: function sizeableClass() {
          return prefix(this.size, 'form-control');
        }
      }
    };

    var CheckboxField = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          class: _vm.$mergeClasses(_vm.controlClass, _vm.customControlClass, _vm.sizeableClass, _vm.inline ? _vm.inlineClass : '')
        }, [_vm.custom && _vm.id ? [_c('input', {
          directives: [{
            name: "bind-events",
            rawName: "v-bind-events"
          }],
          class: _vm.$mergeClasses(_vm.inputClass, _vm.invalidFeedback ? 'is-invalid' : ''),
          attrs: {
            "type": "checkbox",
            "name": _vm.name,
            "id": _vm.id,
            "required": _vm.required,
            "disabled": _vm.disabled || _vm.readonly,
            "readonly": _vm.readonly,
            "pattern": _vm.pattern
          },
          domProps: {
            "value": _vm.value,
            "checked": _vm.checkedValue === _vm.value || _vm.checked
          },
          on: {
            "change": function change($event) {
              _vm.updated($event.target.value, 'change');
            }
          }
        }), _vm._v(" "), _c('label', {
          class: _vm.$mergeClasses(_vm.labelClass, _vm.colorableClasses),
          attrs: {
            "for": _vm.id
          }
        }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))]), _vm._v(" "), _vm._t("feedback", [_vm.validFeedback ? _c('form-feedback', {
          attrs: {
            "valid": ""
          },
          domProps: {
            "innerHTML": _vm._s(_vm.validFeedback)
          }
        }) : _vm._e(), _vm._v(" "), _vm.invalidFeedback ? _c('form-feedback', {
          attrs: {
            "invalid": ""
          },
          domProps: {
            "innerHTML": _vm._s(_vm.invalidFeedback)
          }
        }) : _vm._e()])], 2)] : [_c('label', {
          class: _vm.$mergeClasses(_vm.labelClass, _vm.colorableClasses),
          attrs: {
            "for": _vm.id
          }
        }, [_c('input', {
          directives: [{
            name: "bind-events",
            rawName: "v-bind-events"
          }],
          class: _vm.$mergeClasses(_vm.inputClass, _vm.invalidFeedback ? 'is-invalid' : ''),
          attrs: {
            "type": "checkbox",
            "name": _vm.name,
            "id": _vm.id,
            "required": _vm.required,
            "disabled": _vm.disabled || _vm.readonly,
            "readonly": _vm.readonly,
            "pattern": _vm.pattern
          },
          domProps: {
            "value": _vm.value,
            "checked": _vm.checkedValue === _vm.value || _vm.checked
          },
          on: {
            "change": function change($event) {
              _vm.updated($event.target.value, 'change');
            }
          }
        }), _vm._v(" "), _vm._t("default", [_vm._v(_vm._s(_vm.label))]), _vm._v(" "), _vm._t("feedback", [_vm.validFeedback ? _c('form-feedback', {
          attrs: {
            "valid": ""
          },
          domProps: {
            "innerHTML": _vm._s(_vm.validFeedback)
          }
        }) : _vm._e(), _vm._v(" "), _vm.invalidFeedback ? _c('form-feedback', {
          attrs: {
            "invalid": ""
          },
          domProps: {
            "innerHTML": _vm._s(_vm.invalidFeedback)
          }
        }) : _vm._e()])], 2)], _vm._v(" "), _vm._t("help", [_vm.helpText ? _c('help-text', {
          domProps: {
            "innerHTML": _vm._s(_vm.helpText)
          }
        }) : _vm._e()])], 2);
      },
      staticRenderFns: [],
      name: 'checkbox-field',
      extends: RadioField,
      props: {
        /**
         * The checked values
         *
         * @property String
         */
        checkedValue: {
          type: Array,
          default: function _default() {
            return [];
          }
        }
      },
      methods: {
        updated: function updated(value) {
          var checked = this.checkedValue.slice(0);
          var index = this.checkedValue.indexOf(value);

          if (index === -1) {
            checked.push(value);
          } else {
            checked.splice(index, 1);
          }

          this.$emit('change', checked);
        }
      }
    };

    var plugin$12 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          CheckboxField: CheckboxField
        });
      }
    });

    var Container = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "container"
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'container'
    };

    var plugin$13 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          Container: Container
        });
      }
    });

    var InputField = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('form-group', [_vm._t("label", [_vm.label || _vm.hasDefaultSlot ? _c('form-label', {
          attrs: {
            "for": _vm.id
          }
        }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))])], 2) : _vm._e()]), _vm._v(" "), _vm._t("control", [_c('form-control', {
          directives: [{
            name: "bind-events",
            rawName: "v-bind-events",
            value: _vm.bindEvents,
            expression: "bindEvents"
          }],
          class: _vm.$mergeClasses(_vm.controlClasses, _vm.colorableClasses),
          attrs: {
            "id": _vm.id,
            "type": _vm.type,
            "value": _vm.value,
            "errors": _vm.errors,
            "placeholder": _vm.placeholder,
            "required": _vm.required,
            "disabled": _vm.disabled || _vm.readonly,
            "readonly": _vm.readonly,
            "pattern": _vm.pattern,
            "aria-label": _vm.label,
            "aria-describedby": _vm.id
          },
          on: {
            "input": function input($event) {
              _vm.updated($event.target.value);
            }
          }
        })]), _vm._v(" "), _vm._t("help", [_vm.helpText ? _c('help-text', {
          domProps: {
            "innerHTML": _vm._s(_vm.helpText)
          }
        }) : _vm._e()]), _vm._v(" "), _vm._t("feedback", [_vm.validFeedback ? _c('form-feedback', {
          attrs: {
            "valid": ""
          },
          domProps: {
            "innerHTML": _vm._s(_vm.validFeedback)
          }
        }) : _vm._e(), _vm._v(" "), _vm.invalidFeedback ? _c('form-feedback', {
          attrs: {
            "invalid": ""
          },
          domProps: {
            "innerHTML": _vm._s(_vm.invalidFeedback)
          }
        }) : _vm._e()])], 2);
      },
      staticRenderFns: [],
      name: 'input-field',
      mixins: [Colorable, FormControl],
      props: {
        /**
         * The type attribute
         *
         * @property String
         */
        type: {
          type: String,
          default: 'text'
        }
      }
    };

    var FileField = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('form-group', [_vm._t("label", [_vm.label || _vm.hasDefaultSlot ? _c('form-label', {
          attrs: {
            "for": _vm.id
          }
        }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))])], 2) : _vm._e()]), _vm._v(" "), _c('div', {
          staticClass: "custom-file"
        }, [_vm._t("placeholder", [_c('form-label', {
          class: _vm.$mergeClasses(_vm.colorableClasses, 'custom-file-label'),
          attrs: {
            "for": _vm.id
          },
          domProps: {
            "innerHTML": _vm._s(_vm.placeholder || 'Choose file')
          }
        })]), _vm._v(" "), _c('input', {
          directives: [{
            name: "bind-events",
            rawName: "v-bind-events"
          }],
          class: _vm.controlClasses,
          attrs: {
            "type": "file",
            "id": _vm.id,
            "width": _vm.width,
            "height": _vm.height,
            "required": _vm.required,
            "multiple": _vm.multiple,
            "readonly": _vm.readonly
          },
          on: {
            "change": function change($event) {
              _vm.updated($event.target.files, 'change');
            }
          }
        }), _vm._v(" "), _vm._t("help", [_vm.helpText ? _c('help-text', {
          domProps: {
            "innerHTML": _vm._s(_vm.helpText)
          }
        }) : _vm._e()]), _vm._v(" "), _vm._t("feedback", [_vm.validFeedback ? _c('form-feedback', {
          attrs: {
            "valid": ""
          },
          domProps: {
            "innerHTML": _vm._s(_vm.validFeedback)
          }
        }) : _vm._e(), _vm._v(" "), _vm.invalidFeedback ? _c('form-feedback', {
          attrs: {
            "invalid": ""
          },
          domProps: {
            "innerHTML": _vm._s(_vm.invalidFeedback)
          }
        }) : _vm._e()])], 2)], 2);
      },
      staticRenderFns: [],
      name: 'file-field',
      extends: InputField,
      model: {
        event: 'change'
      },
      props: {
        /**
         * An array of event names that correlate with callback functions
         *
         * @property Function
         */
        bindEvents: {
          type: Array,
          default: function _default() {
            return ['focus', 'blur', 'input', 'click', 'keyup', 'keydown', 'progress'];
          }
        },

        /**
         * The class name assigned to the control element
         *
         * @property String
         */
        defaultControlClass: {
          type: String,
          default: 'custom-file-input'
        },

        /**
         * An array of valid extensions
         *
         * @property String
         */
        extensions: Array,

        /**
         * The type attribute
         *
         * @property String
         */
        multiple: Boolean,

        /**
         * The height attribute for the control element
         *
         * @property String
         */
        height: [Number, String],

        /**
         * The width attribute for the control element
         *
         * @property String
         */
        width: [Number, String]
      }
    };

    var FileButton = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('btn', {
          staticClass: "btn-file",
          attrs: {
            "type": _vm.type,
            "variant": _vm.variant,
            "block": _vm.block,
            "size": _vm.size,
            "disabled": _vm.disabled,
            "active": _vm.active
          }
        }, [_vm._t("default"), _vm._v(" "), _c('input', {
          directives: [{
            name: "bind-events",
            rawName: "v-bind-events"
          }],
          class: _vm.controlClasses,
          attrs: {
            "type": "file",
            "id": _vm.id,
            "width": _vm.width,
            "height": _vm.height,
            "required": _vm.required,
            "multiple": _vm.multiple,
            "readonly": _vm.readonly
          },
          on: {
            "change": function change($event) {
              _vm.updated($event.target.files, 'change');
            }
          }
        })], 2);
      },
      staticRenderFns: [],
      name: 'file-field',
      mixins: [Btn, FileField],
      model: {
        event: 'change'
      },
      props: {
        /**
         * The type attribute for the button. Not applied if an anchor
         *
         * @property String
         */
        type: {
          type: String,
          default: 'button'
        }
      }
    };

    var plugin$14 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          FileButton: FileButton
        });
      }
    });

    var plugin$15 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          FileField: FileField
        });
      }
    });

    function readFile(file, progress) {
      return new Promise(function (resolve, reject) {
        var reader = new FileReader();

        reader.onload = function (e) {
          return resolve(e);
        };

        reader.onerror = function (e) {
          return reject(e);
        };

        reader.onabort = function (e) {
          return reject(e);
        };

        reader.onprogress = function (e) {
          return progress(e, reader);
        };

        reader.readAsDataURL(file);
      });
    }

    /** `Object#toString` result references. */
    var numberTag$2 = '[object Number]';

    /**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
     * classified as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(3);
     * // => true
     *
     * _.isNumber(Number.MIN_VALUE);
     * // => true
     *
     * _.isNumber(Infinity);
     * // => true
     *
     * _.isNumber('3');
     * // => false
     */
    function isNumber(value) {
      return typeof value == 'number' ||
        (isObjectLike_1(value) && _baseGetTag(value) == numberTag$2);
    }

    var isNumber_1 = isNumber;

    var ProgressBar = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "progress",
          style: {
            'height': _vm.formattedHeight
          }
        }, [_c('div', {
          staticClass: "progress-bar",
          class: _vm.$mergeClasses(_vm.progressClasses, _vm.variantClass),
          style: {
            'width': _vm.offsetValue + '%'
          },
          attrs: {
            "role": "progressbar",
            "aria-valuenow": _vm.offsetValue,
            "aria-valuemin": _vm.min,
            "aria-valuemax": _vm.max
          }
        }, [_vm.label ? _c('span', [_vm._v(_vm._s(_vm.offsetValue) + "%")]) : _vm._e()])]);
      },
      staticRenderFns: [],
      name: 'progress-bar',
      mixins: [Variant],
      props: {
        /**
         * The progress bar percentage value
         *
         * @property String
         */
        value: {
          type: Number,
          required: true
        },

        /**
         * The height of the progress bar
         *
         * @property String
         */
        height: [Number, String],

        /**
         * Show the progress bar value as a label inside the bar
         *
         * @property String
         */
        label: Boolean,

        /**
         * Should the progress bar appear with stripes
         *
         * @property String
         */
        striped: Boolean,

        /**
         * Should the progress bar appear with animated stripes
         *
         * @property String
         */
        animated: Boolean,

        /**
         * The minimum value
         *
         * @property String
         */
        min: {
          type: Number,
          default: 0
        },

        /**
         * The max value
         *
         * @property String
         */
        max: {
          type: Number,
          default: 100
        }
      },
      computed: {
        variantClassPrefix: function variantClassPrefix() {
          return 'bg';
        },
        offsetValue: function offsetValue() {
          return this.value / this.max * 100;
        },
        formattedHeight: function formattedHeight() {
          return !this.height ? null : isNumber_1(this.height) ? this.height + 'px' : this.height;
        },
        progressClasses: function progressClasses() {
          return {
            'progress-bar-striped': this.striped,
            'progress-bar-animated': this.animated
          };
        }
      }
    };

    var FilePreview = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "file-preview",
          class: {
            'is-image': _vm.isImage
          }
        }, [_c('div', {
          staticClass: "file-preview-inner"
        }, [!_vm.hideClose && (!_vm.isImage || _vm.image) ? _c('a', {
          staticClass: "file-preview-close",
          attrs: {
            "href": "#"
          },
          on: {
            "click": function click($event) {
              $event.preventDefault();

              _vm.$emit('close', _vm.file);
            }
          }
        }, [_c('i', {
          staticClass: "fa fa-times-circle"
        })]) : _vm._e(), _vm._v(" "), _vm.isImage ? _c('div', {
          staticClass: "file-preview-image"
        }, [_vm.image ? _c('img', {
          staticClass: "file-preview-thumbnail",
          attrs: {
            "src": _vm.image
          }
        }) : _c('progress-bar', {
          directives: [{
            name: "ready",
            rawName: "v-ready",
            value: _vm.readFile,
            expression: "readFile"
          }],
          attrs: {
            "value": _vm.loaded,
            "height": 10
          }
        })], 1) : _c('div', {
          staticClass: "file-preview-icon"
        }, [_c('i', {
          staticClass: "fa fa-file-o"
        })]), _vm._v(" "), _c('div', {
          staticClass: "file-preview-filename",
          domProps: {
            "innerHTML": _vm._s(_vm.name)
          }
        }), _vm._v(" "), _c('div', {
          staticClass: "file-preview-filesize"
        }, [_vm._v("(" + _vm._s(_vm.size) + ")")]), _vm._v(" "), _c('div')])]);
      },
      staticRenderFns: [],
      name: 'file-preview',
      components: {
        ProgressBar: ProgressBar
      },
      directives: {
        ready: {
          inserted: function inserted(el, binding) {
            setTimeout(function () {
              if (isFunction_1(binding.value)) {
                binding.value();
              }
            }, 50);
          }
        }
      },
      props: {
        /**
         * Hide the close button for the preview
         *
         * @property Object
         */
        hideClose: Boolean,

        /**
         * The uploaded File object
         *
         * @property Object
         */
        file: {
          type: [Object, File],
          required: true
        },

        /**
         * An array of mime types that should be used to determine if the
         * file is an image.
         *
         * @property Array
         */
        imageMimes: {
          type: Array,
          default: function _default() {
            return ['image/gif', 'image/png', 'image/jpeg', 'image/bmp', 'image/webp'];
          }
        }
      },
      computed: {
        /**
         * Get the file name
         *
         * @property String
         */
        name: function name() {
          return this.file instanceof File ? this.file.name : this.file.orig_filename;
        },

        /**
         * Get the file extension
         *
         * @property String
         */
        extension: function extension() {
          return this.file instanceof File ? this.file.name.split('.').pop().toLowerCase() : this.file.extension;
        },

        /**
         * Get the file formatted size
         *
         * @property String
         */
        size: function size() {
          return this.bytesToSize(this.file instanceof File ? this.file.size : this.file.bytes);
        },

        /**
         * Get the file type
         *
         * @property String
         */
        type: function type() {
          return this.file instanceof File ? this.file.type : this.file.mime;
        },

        /**
         * If the file an image?
         *
         * @property String
         */
        isImage: function isImage() {
          return this.imageMimes.indexOf(this.type) !== -1;
        },

        /**
         * Get the last time the file was modified (as timestamp)
         *
         * @property String
         */
        lastModified: function lastModified() {
          return this.file instanceof File ? this.file.lastModified : null;
        },

        /**
         * Get the last time the file was modified (as Date)
         *
         * @property String
         */
        lastModifiedDate: function lastModifiedDate() {
          return this.file instanceof File ? this.file.lastModifiedDate : null;
        }
      },
      methods: {
        readFile: function readFile$$1() {
          var _this = this;

          if (this.file instanceof File) {
            var start = moment();

            readFile(this.file, function (e) {
              if (e.lengthComputable) {
                _this.loaded = parseInt(e.loaded / e.total * 100, 10);
              }
            }).then(function (event) {
              setTimeout(function () {
                _this.image = event.target.result;

                _this.$emit('loaded', event, _this);
              }, 600 - moment().diff(start));
            }, function (error) {
              _this.$emit('error', error);
            });
          }
        },
        bytesToSize: function bytesToSize(bytes) {
          var sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
          if (bytes == 0) return '0 Byte';
          var i = parseInt(Math.floor(Math.log(bytes) / Math.log(1024)));
          return Math.round(bytes / Math.pow(1024, i), 2) + ' ' + sizes[i];
        }
      },
      data: function data() {
        return {
          loaded: 0,
          image: this.file.url
        };
      }
    };

    var plugin$16 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          FilePreview: FilePreview
        });
      }
    });

    var FormControl$1 = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c(!_vm.select ? 'input' : 'select', {
          directives: [{
            name: "bind-events",
            rawName: "v-bind-events",
            value: _vm.bindEvents,
            expression: "bindEvents"
          }],
          tag: "component",
          class: _vm.$mergeClasses(_vm.controlClasses, _vm.colorableClasses),
          attrs: {
            "id": _vm.id,
            "type": !_vm.select ? _vm.type : false,
            "value": _vm.value,
            "pattern": _vm.pattern,
            "required": _vm.required,
            "readonly": _vm.readonly,
            "placeholder": _vm.placeholder,
            "disabled": _vm.disabled || _vm.readonly,
            "aria-label": _vm.label,
            "aria-describedby": _vm.id
          },
          on: {
            "input": _vm.updated
          }
        }, [_vm.select ? _vm._t("default") : _vm._e()], 2);
      },
      staticRenderFns: [],
      name: 'form-control',
      mixins: [Colorable, FormControl],
      props: {
        /**
         * Is the element a select?
         *
         * @property String
         */
        select: Boolean,

        /**
         * The type attribute
         *
         * @property String
         */
        type: {
          type: String,
          default: 'text'
        }
      }
    };

    var plugin$17 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          FormControl: FormControl$1
        });
      }
    });

    var FormFeedback = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          class: {
            'invalid-feedback': _vm.invalid,
            'valid-feedback': _vm.valid && !_vm.invalid
          }
        }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))])], 2);
      },
      staticRenderFns: [],
      name: 'form-feedback',
      mixins: [Colorable],
      props: {
        /**
         * The value of label element. If no value, no label will appear.
         *
         * @property String
         */
        label: String,

        /**
         * Should the feedback marked as invalid
         *
         * @property String
         */
        invalid: Boolean,

        /**
         * Should the feedback marked as invalid
         *
         * @property String
         */
        valid: Boolean
      }
    };

    var plugin$18 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          FormFeedback: FormFeedback
        });
      }
    });

    var FormGroup = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "form-group"
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'form-group'
    };

    var plugin$19 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          FormGroup: FormGroup
        });
      }
    });

    var Screenreaders = {
      props: {
        /**
         * Should show only for screenreaders
         *
         * @property Boolean
         */
        srOnly: Boolean,

        /**
         * Should be focusable for screenreaders
         *
         * @property Boolean
         */
        srOnlyFocusable: Boolean
      },
      computed: {
        screenreaderClasses: function screenreaderClasses() {
          return {
            'sr-only': this.srOnly,
            'sr-only-focusable': this.srOnlyFocusable
          };
        }
      }
    };

    var FormLabel = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('label', {
          class: _vm.classes
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'form-label',
      mixins: [Colorable, Screenreaders],
      computed: {
        classes: function classes() {
          return extend({}, this.screenreaderClasses, this.colorableClasses);
        }
      }
    };

    var plugin$20 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          FormLabel: FormLabel
        });
      }
    });

    var HelpText = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('small', {
          staticClass: "form-text",
          class: _vm.classes
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'help-text',
      mixins: [Colorable, Screenreaders],
      computed: {
        classes: function classes() {
          return extend({}, this.screenreaderClasses, this.colorableClasses);
        }
      }
    };

    var plugin$21 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          HelpText: HelpText
        });
      }
    });

    var plugin$22 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          InputField: InputField
        });
      }
    });

    var InputGroup = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "input-group",
          class: _vm.$mergeClasses(_vm.colorableClasses, _vm.sizeableClass)
        }, [_vm._t("prepend", [_vm.prepend instanceof Array ? [_c('input-group-prepend', _vm._l(_vm.prepend, function (value) {
          return _c('input-group-text', {
            attrs: {
              "text": value
            }
          });
        }))] : _vm.prepend ? [_c('input-group-prepend', {
          attrs: {
            "text": ""
          }
        }, [_vm._v(_vm._s(_vm.prepend))])] : _vm._e()]), _vm._v(" "), _vm._t("default"), _vm._v(" "), _vm._t("append", [_vm.append instanceof Array ? [_c('input-group-append', _vm._l(_vm.append, function (value) {
          return _c('input-group-text', {
            attrs: {
              "text": value
            }
          });
        }))] : _vm.append ? [_c('input-group-append', {
          attrs: {
            "text": ""
          }
        }, [_vm._v(_vm._s(_vm.append))])] : _vm._e()])], 2);
      },
      staticRenderFns: [],
      name: 'input-group',
      mixins: [HasSlots, Sizeable, Colorable],
      props: {
        append: [Array, Number, String],
        prepend: [Array, Number, String]
      }
    };

    var InputGroupAppend = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "input-group-append"
        }, [_vm.text ? _c('input-group-text', [_vm._t("default")], 2) : _vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'input-group-append',
      props: {
        /**
         * The type attribute
         *
         * @property String
         */
        text: Boolean
      }
    };

    var InputGroupPrepend = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "input-group-prepend"
        }, [_vm.text ? _c('input-group-text', [_vm._t("default")], 2) : _vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'input-group-prepend',
      props: {
        /**
         * The type attribute
         *
         * @property String
         */
        text: Boolean
      }
    };

    var InputGroupText = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('span', {
          staticClass: "input-group-text",
          attrs: {
            "id": _vm.id
          }
        }, [_vm._t("default", [_vm._v(_vm._s(_vm.text))])], 2);
      },
      staticRenderFns: [],
      name: 'input-group-text',
      props: {
        /**
         * The id attribute
         *
         * @property String
         */
        id: String,

        /**
         * The type attribute
         *
         * @property String
         */
        text: [Array, Number, String]
      }
    };

    var plugin$23 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          InputGroup: InputGroup,
          InputGroupAppend: InputGroupAppend,
          InputGroupPrepend: InputGroupPrepend,
          InputGroupText: InputGroupText
        });
      }
    });

    var LightSwitchField = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('form-group', [_vm._t("label", [_vm.label ? _c('form-label', {
          attrs: {
            "for": _vm.id
          },
          domProps: {
            "innerHTML": _vm._s(_vm.label)
          }
        }) : _vm._e()]), _vm._v(" "), _c('div', {
          class: _vm.controlClasses,
          attrs: {
            "tabindex": "0"
          },
          on: {
            "click": function click($event) {
              _vm.toggle();
            },
            "keyup": [function ($event) {
              if (!('button' in $event) && $event.keyCode !== 32) {
                return null;
              }

              _vm.toggle();
            }, function ($event) {
              if (!('button' in $event) && $event.keyCode !== 37) {
                return null;
              }

              _vm.toggle(_vm.offValue);
            }, function ($event) {
              if (!('button' in $event) && $event.keyCode !== 39) {
                return null;
              }

              _vm.toggle(_vm.onValue);
            }]
          }
        }, [_c('div', {
          staticClass: "light-switch-handle"
        }), _vm._v(" "), _c('div', {
          staticClass: "light-switch-container"
        }, [_c('div', {
          staticClass: "light-switch-label on-value"
        }), _vm._v(" "), _c('div', {
          staticClass: "light-switch-label off-value"
        })])]), _vm._v(" "), _c('form-control', {
          staticClass: "d-none",
          attrs: {
            "name": _vm.name,
            "value": _vm.value,
            "id": _vm.id
          }
        }), _vm._v(" "), _vm._t("feedback", [_vm.validFeedback ? _c('form-feedback', {
          attrs: {
            "valid": ""
          },
          domProps: {
            "innerHTML": _vm._s(_vm.validFeedback)
          }
        }) : _vm._e(), _vm._v(" "), _vm.invalidFeedback ? _c('form-feedback', {
          attrs: {
            "invalid": ""
          },
          domProps: {
            "innerHTML": _vm._s(_vm.invalidFeedback)
          }
        }) : _vm._e()]), _vm._v(" "), _vm._t("help", [_vm.helpText ? _c('help-text', {
          domProps: {
            "innerHTML": _vm._s(_vm.helpText)
          }
        }) : _vm._e()])], 2);
      },
      staticRenderFns: [],
      name: 'light-switch-field',
      mixins: [FormControl],
      props: {
        /**
         * The class name assigned to the control element
         *
         * @property String
         */
        defaultControlClass: {
          type: String,
          default: 'form-control light-switch'
        },

        /**
         * The class name assigned to the control element
         *
         * @property String
         */
        activeClass: {
          type: String,
          default: 'on'
        },

        /**
         * The class name assigned to the control element
         *
         * @property String
         */
        onValue: {
          default: 1
        },

        /**
         * The class name assigned to the control element
         *
         * @property String
         */
        offValue: {
          default: 0
        }
      },
      computed: {
        isActive: function isActive() {
          return this.value === this.onValue;
        },
        controlClasses: function controlClasses() {
          return [this.controlClass, this.controlSizeClass, this.spacing || '', this.invalidFeedback ? 'is-invalid' : '', this.dragging ? 'is-dragging' : '', this.isActive ? 'is-active' : ''].join(' ');
        }
      },
      methods: {
        getTransitionInMilliseconds: function getTransitionInMilliseconds() {
          var duration = getComputedStyle(this.$el.querySelector('.light-switch-handle')).transitionDuration;
          var numeric = parseFloat(duration, 10);
          var unit = duration.match(/m?s/);

          switch (unit[0]) {
            case 's':
              return numeric * 1000;

            case 'ms':
              return numeric;
          }

          throw new Error("\"".concat(unit[0], "\" is not a valid unit of measure. Unit must be \"s\" (seconds) or \"ms\" (milliseconds)."));
        },
        toggle: function toggle(value) {
          this.$emit('input', !isUndefined_1(value) ? value : this.isActive ? this.offValue : this.onValue);
        }
      },
      watch: {
        value: function value() {
          var _this = this;

          this.dragging = true;
          setTimeout(function () {
            _this.dragging = false;
          }, this.getTransitionInMilliseconds());
        }
      },
      data: function data() {
        return {
          dragging: false
        };
      }
    };

    var plugin$24 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          LightSwitchField: LightSwitchField
        });
      }
    });

    var ListGroupItem = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _vm.href ? _c('a', {
          staticClass: "list-group-item",
          class: _vm.classes,
          attrs: {
            "href": _vm.href
          },
          on: {
            "click": _vm.onClick
          }
        }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))]), _vm._v(" "), _vm.badge ? _c('badge', _vm._b({}, 'badge', _vm.badgeOptions, false)) : _vm._e()], 2) : _vm.action ? _c('a', {
          staticClass: "list-group-item",
          class: _vm.classes,
          attrs: {
            "href": "#"
          },
          on: {
            "click": function click($event) {
              $event.preventDefault();
              return _vm.onClick($event);
            }
          }
        }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))]), _vm._v(" "), _vm.badge ? _c('badge', _vm._b({}, 'badge', _vm.badgeOptions, false)) : _vm._e()], 2) : _c('div', {
          staticClass: "list-group-item",
          class: _vm.classes,
          on: {
            "click": _vm.onClick
          }
        }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))]), _vm._v(" "), _vm.badge ? _c('badge', _vm._b({}, 'badge', _vm.badgeOptions, false)) : _vm._e()], 2);
      },
      staticRenderFns: [],
      components: {
        Badge: Badge
      },
      props: {
        /**
         * The list item label.
         *
         * @property Object
         */
        label: {
          type: [Number, String],
          value: null
        },

        /**
         * The list group item an action, or clickable item.
         *
         * @property Boolean
         */
        action: {
          type: Boolean,
          default: false
        },

        /**
         * The list group item active.
         *
         * @property Boolean
         */
        active: {
          type: Boolean,
          default: false
        },

        /**
         * The list group item disabled.
         *
         * @property Boolean
         */
        disabled: {
          type: Boolean,
          default: false
        },

        /**
         * The list group item variant.
         *
         * @property String
         */
        variant: String,

        /**
         * The list group item href attribute.
         *
         * @property String
         */
        href: String,

        /**
         * The badge label (if number or string) or object of options to pass to
         * the component.
         *
         * @property String|Object
         */
        badge: [Number, String, Object]
      },
      computed: {
        classes: function classes() {
          var classes = prefix({
            'action': this.action
          }, 'list-group-item');
          classes['active'] = this.isActive;
          classes['disabled'] = this.isDisabled;

          if (this.variant) {
            classes[prefix(this.variant, 'list-group-item')] = true;
          }

          return classes;
        },
        badgeOptions: function badgeOptions() {
          return isObject_1(this.badge) ? this.badge : {
            label: this.badge
          };
        }
      },
      methods: {
        /**
         * Toggle the list item's active class.
         *
         * @return void
         */
        toggle: function toggle() {
          this.isActive = !this.isActive;
        },

        /**
         * Activate the list item.
         *
         * @return void
         */
        activate: function activate() {
          this.isActive = true;
        },

        /**
         * Deactivate the list item.
         *
         * @return void
         */
        deactivate: function deactivate() {
          this.isActive = false;
        },

        /**
         * Activate the list item.
         *
         * @return void
         */
        disable: function disable() {
          this.isDisabled = false;
        },

        /**
         * Deactivate the list item.
         *
         * @return void
         */
        enable: function enable() {
          this.isDisabled = false;
        },

        /**
         * The callback function for the `click` event.
         *
         * @return void
         */
        onClick: function onClick(event) {
          this.$emit('click', event, this);
        }
      },
      watch: {
        isActive: function isActive(value, prevValue) {
          this.$emit('update:active', this.isActive);
          this.$emit('toggle', this.isActive, this);
          this.$emit(value ? 'activate' : 'deactivate', this);
        }
      },
      data: function data() {
        return {
          isActive: this.active,
          isDisabled: this.disabled
        };
      }
    };

    var ListGroup = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "list-group",
          class: _vm.classes
        }, [_vm._t("default", _vm._l(_vm.items, function (item, key) {
          return _c('list-group-item', _vm._b({
            key: key
          }, 'list-group-item', item, false));
        }))], 2);
      },
      staticRenderFns: [],
      components: {
        ListGroupItem: ListGroupItem
      },
      props: {
        /**
         * An array of list item objects.
         *
         * [{label: 'Some Label', badge: 1}]
         *
         * @property Object
         */
        items: Array,

        /**
         * Can the list items be activated.
         *
         * @property Boolean
         */
        activateable: {
          type: Boolean,
          default: false
        },

        /**
         * The list group appear flush (without some borders).
         *
         * @property Boolean
         */
        flush: {
          type: Boolean,
          default: false
        },

        /**
         * Can activate multiple list items
         *
         * @property Boolean
         */
        multiple: {
          type: Boolean,
          default: false
        }
      },
      computed: {
        classes: function classes() {
          return prefix({
            'flush': this.flush
          }, 'list-group');
        }
      },
      methods: {
        bindEventsToChildren: function bindEventsToChildren() {
          var _this = this;

          each(this.$children, function (child) {
            child.$off('click', _this.onClickChild);
            child.$on('click', _this.onClickChild);
            child.$off('activate', _this.onActivate);
            child.$on('activate', _this.onActivate);
            child.$off('deactivate', _this.onDeactivate);
            child.$on('deactivate', _this.onDeactivate);
          });
        },
        onClickChild: function onClickChild(event, child) {
          if (this.activateable) {
            child.toggle();
          }

          this.$emit('click:child', event, child);
        },
        onActivate: function onActivate(item) {
          if (!this.multiple && this.activeItem !== item) {
            if (this.activeItem) {
              this.activeItem.deactivate();
            }

            this.activeItem = item;
          }
        },
        onDeactivate: function onDeactivate(item) {
          if (!this.multiple && this.activeItem === item) {
            this.activeItem = null;
          }
        }
      },
      data: function data() {
        return {
          activeItem: null
        };
      },
      mounted: function mounted() {
        this.bindEventsToChildren();
      },
      updated: function updated() {
        this.bindEventsToChildren();
      }
    };

    var plugin$25 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          ListGroup: ListGroup
        });
      }
    });

    var Navigation = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('nav', {
          staticClass: "nav",
          class: _vm.classes,
          attrs: {
            "role": _vm.role
          }
        }, [_vm._l(_vm.items, function (item, i) {
          return _vm.items ? _c('navigation-item', _vm._b({
            key: i
          }, 'navigation-item', item, false)) : _vm._e();
        }), _vm._v(" "), _vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'navigation',
      mixins: [Colorable],
      props: {
        /**
         * Helper to add the justify-content-X class.
         *
         * @prop {Array}
         */
        align: String,

        /**
         * An array of buttons
         *
         * @prop {Array}
         */
        buttons: Array,

        /**
         * The navigation inside a card
         *
         * @prop {Boolean}
         */
        card: Boolean,

        /**
         * Justify nav items to fill the width equally (using flex).
         *
         * @prop {Array}
         */
        fill: Boolean,

        /**
         * Add `nav-justified` class to the component.
         *
         * @prop {Array}
         */
        justified: Boolean,

        /**
         * Display items as pill shapes
         *
         * @prop {Array}
         */
        pills: Boolean,

        /**
         * Display items as tab shapes
         *
         * @prop {Array}
         */
        tabs: Boolean,

        /**
         * Display the buttons vertically
         *
         * @prop {Boolean}
         */
        vertical: Boolean,

        /**
         * The role attribute
         *
         * @prop {String}
         */
        role: String
      },
      computed: {
        classes: function classes() {
          var _this = this;

          this.$nextTick(function () {
            if (!_this.isCard) {
              _this.isCard = _this.$parent.$el.classList.contains('card-header');
            }
          });
          return this.$mergeClasses(prefix(this.align, 'justify-content'), this.colorableClasses, {
            'card-header-tabs': this.isCard && this.tabs,
            'card-header-pills': this.isCard && this.pills,
            'nav-justified': this.justified,
            'nav-fill': this.fill,
            'nav-pills': this.pills,
            'nav-tabs': this.tabs,
            'flex-column': this.vertical
          });
        }
      },
      data: function data() {
        return {
          isCard: this.card
        };
      }
    };

    var NavigationLink = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('a', {
          class: _vm.classes,
          attrs: {
            "href": _vm.href
          }
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'navigation-link',
      props: {
        /**
         * Is the navigation item active
         *
         * @prop {Boolean}
         */
        active: Boolean,

        /**
         * Is the navigation item disabled
         *
         * @prop {Boolean}
         */
        disabled: Boolean,

        /**
         * The href attribute
         *
         * @prop {String}
         */
        href: String,

        /**
         * Add the nav-item class to the link
         *
         * @prop {Boolean}
         */
        item: {
          type: Boolean,
          default: false
        }
      },
      computed: {
        classes: function classes() {
          var _this = this;

          this.$nextTick(function () {
            if (!_this.isItem) {
              _this.isItem = !_this.$parent.$el.classList.contains('nav-item');
            }
          });
          return {
            'nav-link': this.href,
            'nav-item': this.isItem,
            'active': this.active,
            'disabled': this.disabled
          };
        }
      },
      data: function data() {
        return {
          isItem: this.item
        };
      }
    };

    var NavigationItem = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c(_vm.component, {
          tag: "component",
          class: _vm.classes
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'navigation-item',
      extends: NavigationLink,
      props: {
        /**
         * The HTML element
         *
         * @prop {String}
         */
        element: String,

        /**
         * Is the component a list element
         *
         * @prop {Boolean}
         */
        list: Boolean,

        /**
         * Add the nav-item class to the link
         *
         * @prop {Boolean}
         */
        item: {
          type: Boolean,
          default: true
        }
      },
      computed: {
        component: function component() {
          if (this.element) {
            return this.element;
          } else if (this.href) {
            return 'a';
          } else if (this.list) {
            return 'li';
          }

          return 'div';
        }
      }
    };

    var NavigationDropdown = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('navigation-item', {
          staticClass: "dropdown"
        }, [_vm._t("toggle-button", [_c('navigation-link', {
          staticClass: "dropdown-toggle",
          attrs: {
            "href": "#",
            "data-toggle": "dropdown",
            "role": "button",
            "aria-haspopup": "true",
            "aria-expanded": _vm.isDropdownShowing
          },
          on: {
            "blur": _vm.onBlur
          },
          nativeOn: {
            "click": function click($event) {
              $event.preventDefault();

              _vm.toggle();
            }
          }
        }, [_vm._v(" " + _vm._s(_vm.label) + " ")])]), _vm._v(" "), _vm._t("dropdown-menu", [_c('dropdown-menu', {
          attrs: {
            "id": _vm.id,
            "items": _vm.items,
            "align": _vm.align,
            "show": _vm.isDropdownShowing
          },
          on: {
            "update:show": function updateShow($event) {
              _vm.isDropdownShowing = $event;
            },
            "item:click": _vm.onItemClick
          }
        }, [_vm._t("default")], 2)])], 2);
      },
      staticRenderFns: [],
      name: 'navigation-dropdown',
      extends: ButtonDropdown
    };

    var plugin$26 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          Navigation: Navigation,
          NavigationItem: NavigationItem,
          NavigationLink: NavigationLink,
          NavigationDropdown: NavigationDropdown
        });
      }
    });

    var plugin$27 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          Overlay: Overlay
        });
      }
    });

    var Pagination = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('nav', {
          attrs: {
            "aria-label": "Page navigation example"
          }
        }, [_c('ul', {
          staticClass: "pagination",
          class: _vm.classes
        }, [_c('li', {
          staticClass: "page-item",
          class: {
            'disabled': _vm.currentPage === 1
          }
        }, [_c('a', {
          staticClass: "page-link",
          attrs: {
            "href": "#",
            "aria-label": "Previous"
          },
          on: {
            "click": function click($event) {
              $event.preventDefault();

              _vm.prev($event);
            }
          }
        }, [_c('span', {
          attrs: {
            "aria-hidden": "true"
          }
        }, [_vm._v("«")])])]), _vm._v(" "), _vm._l(_vm.pages, function (item) {
          return _c('li', {
            staticClass: "page-item",
            class: {
              'active': item.page === _vm.currentPage,
              'disabled': !!item.divider
            },
            attrs: {
              "data-page": item.page
            }
          }, [_vm._t("default", [item.divider ? _c('a', {
            staticClass: "page-link"
          }, [_vm._v("…")]) : _c('a', {
            staticClass: "page-link",
            class: item.class,
            attrs: {
              "href": "#",
              "data-label": item.label
            },
            on: {
              "click": function click($event) {
                $event.preventDefault();

                _vm.paginate(item.page, $event);
              }
            }
          }, [item.label ? _c('span', {
            attrs: {
              "aria-hidden": "true"
            },
            domProps: {
              "innerHTML": _vm._s(item.label)
            }
          }) : _vm._e(), _vm._v(" "), item.page ? _c('span', {
            attrs: {
              "aria-hidden": "true"
            },
            domProps: {
              "innerHTML": _vm._s(item.page)
            }
          }) : _vm._e()])], {
            item: item
          })], 2);
        }), _vm._v(" "), _c('li', {
          staticClass: "page-item",
          class: {
            'disabled': _vm.currentPage >= _vm.totalPages
          }
        }, [_c('a', {
          staticClass: "page-link",
          attrs: {
            "href": "#",
            "aria-label": "Next"
          },
          on: {
            "click": function click($event) {
              $event.preventDefault();

              _vm.next($event);
            }
          }
        }, [_c('span', {
          attrs: {
            "aria-hidden": "true"
          }
        }, [_vm._v("»")])])])], 2)]);
      },
      staticRenderFns: [],
      name: 'pagination',
      props: {
        /**
         * The alignment of the pagination component.
         *
         * @prop String
         */
        align: {
          type: String,
          validate: function validate(value) {
            return ['start', 'end', 'center'].indexOf(value) !== -1;
          }
        },

        /**
         * The page on which the paginator should start.
         *
         * @prop String
         */
        page: {
          type: Number,
          default: 1
        },

        /**
         * The total number of pages in the paginator.
         *
         * @prop String
         */
        totalPages: {
          type: Number,
          default: 1
        },

        /**
         * The number of pages to show when the total number of pages is
         * greater than the number of pages that should be shown.
         *
         * @prop String
         */
        showPages: {
          type: Number,
          default: 6
        },
        onPaginate: Function
      },
      methods: {
        next: function next(event) {
          this.paginate(this.currentPage >= this.totalPages ? this.currentPage : this.currentPage + 1, event);
        },
        prev: function prev(event) {
          this.paginate(this.currentPage <= 1 ? this.currentPage : this.currentPage - 1, event);
        },
        paginate: function paginate(page, event) {
          if (event.currentTarget.parentNode.classList.contains('disabled')) {
            return;
          }

          this.setActivePage(page);

          if (this.onPaginate) {
            this.onPaginate(page, event);
          }

          this.$emit('paginate', page, event);
        },
        setActivePage: function setActivePage(page) {
          if (this.currentPage !== page) {
            this.currentPage = page;
          }
        },
        generate: function generate() {
          var pages = [];
          var showPages = this.showPages % 2 ? this.showPages + 1 : this.showPages;
          var startPage = this.currentPage >= showPages ? this.currentPage - showPages / 2 : 1;
          var startOffset = showPages + startPage;
          var endPage = this.totalPages < startOffset ? this.totalPages : startOffset;
          var diff = startPage - endPage + showPages;
          startPage -= startPage - diff > 0 ? diff : 0;

          if (startPage > 1) {
            pages.push({
              page: 1
            });
          }

          if (startPage > 2) {
            pages.push({
              divider: true
            });
          }

          for (var i = startPage; i < endPage; i++) {
            pages.push({
              page: i
            });
          }

          if (endPage <= this.totalPages) {
            if (this.totalPages - 1 > endPage) {
              pages.push({
                divider: true
              });
            }

            pages.push({
              page: this.totalPages
            });
          }

          return pages;
        }
      },
      computed: {
        pages: function pages() {
          return this.generate();
        },
        classes: function classes() {
          var classes = {};
          classes['justify-content-' + this.align] = true;
          return classes;
        }
      },
      data: function data() {
        return {
          currentPage: this.page
        };
      }
    };

    var plugin$28 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          Pagination: Pagination
        });
      }
    });

    var plugin$29 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          ProgressBar: ProgressBar
        });
      }
    });

    var plugin$30 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          RadioField: RadioField
        });
      }
    });

    //import BaseField from './BaseField';
    var CUSTOM_SELECT_PREFIX = 'custom-select-';
    var SelectField = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('form-group', [_vm._t("label", [_vm.label ? _c('form-label', {
          attrs: {
            "for": _vm.id
          },
          domProps: {
            "innerHTML": _vm._s(_vm.label)
          }
        }) : _vm._e()]), _vm._v(" "), _vm._t("control", [_c('select', {
          class: _vm.$mergeClasses(_vm.controlClasses, _vm.colorableClasses),
          attrs: {
            "id": _vm.id,
            "required": _vm.required,
            "disabled": _vm.disabled || _vm.readonly,
            "readonly": _vm.readonly,
            "pattern": _vm.pattern
          },
          domProps: {
            "value": _vm.value
          },
          on: {
            "input": function input($event) {
              _vm.updated($event.target.value);
            }
          }
        }, [_vm._t("default")], 2)]), _vm._v(" "), _vm._t("help", [_vm.helpText ? _c('help-text', {
          domProps: {
            "innerHTML": _vm._s(_vm.helpText)
          }
        }) : _vm._e()]), _vm._v(" "), _vm._t("feedback", [_vm.validFeedback ? _c('form-feedback', {
          attrs: {
            "valid": ""
          },
          domProps: {
            "innerHTML": _vm._s(_vm.validFeedback)
          }
        }) : _vm._e(), _vm._v(" "), _vm.invalidFeedback ? _c('form-feedback', {
          attrs: {
            "invalid": ""
          },
          domProps: {
            "innerHTML": _vm._s(_vm.invalidFeedback)
          }
        }) : _vm._e()])], 2);
      },
      staticRenderFns: [],
      name: 'select-field',
      extends: FormControl,
      mixins: [FormControl, Colorable],
      props: {
        /**
         * Add `custom-select` to the form control if true.
         *
         * @property String
         */
        custom: Boolean
      },
      computed: {
        controlClass: function controlClass() {
          var controlClass = this.custom ? 'custom-select' : this.defaultControlClass;
          return this.plaintext ? "".concat(controlClass, "-plaintext") : controlClass;
        },
        customSelectClasses: function customSelectClasses() {
          return [CUSTOM_SELECT_PREFIX.replace(/\-$/, '') + (this.plaintext ? '-plaintext' : ''), this.customSelectSizeClass, this.spacing || ''].join(' ');
        }
      }
    };

    var plugin$31 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          SelectField: SelectField
        });
      }
    });

    var Transformer =
    /*#__PURE__*/
    function () {
      /**
       * Initialize the transformer instance using an HTTP response object.
       *
       * @param data object
       * @return void
       */
      function Transformer(response) {
        _classCallCheck(this, Transformer);

        if (!isObject_1(this.$originalResponse = response)) {
          throw new Error('The transformer must be instantiated with a response object.');
        }

        if (!isArray_1(this.$required = this.required()) || !this.$required.length) {
          throw new Error('A transformer must have at least one required property.');
        }

        this.$transformedResponse = this.transform(response);
        this.validate();
        this.initialize();
      }
      /**
       * A method to override to perform logic to finished initializing.
       *
       * @return void
       */


      _createClass(Transformer, [{
        key: "initialize",
        value: function initialize() {} //

        /**
         * Define an array of required propertie with at least one value.
         *
         * @return void
         */

      }, {
        key: "required",
        value: function required() {} //

        /**
         * Tranform the response object
         *
         * @property String
         */

      }, {
        key: "transform",
        value: function transform(response) {
          return response;
        }
        /**
         * Get the tranformed response
         *
         * @property String
         */

      }, {
        key: "response",
        value: function response() {
          return this.$transformedResponse;
        }
        /**
         * Validate the tranformed response.
         *
         * @return void
         */

      }, {
        key: "validate",
        value: function validate() {
          var _this = this;

          if (!isObject_1(this.$transformedResponse)) {
            throw new Error('The transformed response must be an object.');
          }

          each(this.$required, function (key) {
            if (!(key in _this.$transformedResponse)) {
              throw new Error("\"".concat(key, "\" is a required property and does not exist in the tranformed response."));
            }
          });
        }
      }]);

      return Transformer;
    }();

    var TableViewTransformer =
    /*#__PURE__*/
    function (_Transformer) {
      _inherits(TableViewTransformer, _Transformer);

      function TableViewTransformer() {
        _classCallCheck(this, TableViewTransformer);

        return _possibleConstructorReturn(this, (TableViewTransformer.__proto__ || Object.getPrototypeOf(TableViewTransformer)).apply(this, arguments));
      }

      _createClass(TableViewTransformer, [{
        key: "required",
        value: function required() {
          return [// The end of the count of the paginated list.
          'to', // The start of the count of the paginated list.
          'from', // The total number of items (not just included in the pagination)
          'total', // The number of items per page
          'per_page', // The last page number (or total pages)
          'last_page', // The current page number
          'current_page', // The actual response data to appear in the table
          'data'];
        }
      }, {
        key: "data",
        value: function data() {
          return this.$transformedResponse.data;
        }
      }, {
        key: "initialize",
        value: function initialize() {
          if (!isArray_1(this.data())) {
            throw new Error('The data property must be an array.');
          }
        }
      }]);

      return TableViewTransformer;
    }(Transformer);

    var TableView = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "table-view"
        }, [_c('div', {
          staticClass: "d-flex justify-content-between align-items-center"
        }, [_vm._t("header", [_c('div', {
          staticClass: "table-view-header"
        }, [_vm._t("heading", [_vm.heading ? _c('h3', {
          domProps: {
            "innerHTML": _vm._s(_vm.heading)
          }
        }) : _vm._e()]), _vm._v(" "), _vm._t("description", [_vm.description ? _c('p', {
          domProps: {
            "innerHTML": _vm._s(_vm.description)
          }
        }) : _vm._e()])], 2)]), _vm._v(" "), _vm._t("buttons", [_vm.buttons.length ? _c('div', {
          staticClass: "buttons-wrapper my-3"
        }, [_c('span', _vm._l(_vm.buttons, function (button, key) {
          return _c('a', {
            class: button.className || 'btn btn-primary',
            attrs: {
              "href": button.href || '#'
            },
            on: {
              "click": function click($event) {
                _vm.proxy(button.onClick, $event);
              }
            }
          }, [button.icon ? _c('i', {
            class: button.icon
          }) : _vm._e(), _vm._v(" "), _c('span', {
            domProps: {
              "innerHTML": _vm._s(button.label)
            }
          })]);
        }))]) : _vm._e()])], 2), _vm._v(" "), _c('table', {
          staticClass: "table",
          class: {
            'table-hover': _vm.hover && !_vm.loading && _vm.data.length
          }
        }, [_vm._t("thead", [_c('thead', [_c('tr', _vm._l(_vm.tableColumns, function (column) {
          return _c('th', {
            attrs: {
              "scope": "col",
              "width": column.width
            }
          }, [column.id ? _c('div', [_c('a', {
            staticClass: "sort",
            attrs: {
              "href": "#",
              "data-id": column.id
            },
            domProps: {
              "innerHTML": _vm._s(column.name || column.id)
            },
            on: {
              "click": function click($event) {
                $event.preventDefault();

                _vm.orderBy(column.id);
              }
            }
          }), _vm._v(" "), _vm.request.params.order === column.id && _vm.request.params.sort === 'asc' ? _c('i', {
            staticClass: "sort-icon fa fa-sort-asc"
          }) : _vm._e(), _vm._v(" "), _vm.request.params.order === column.id && _vm.request.params.sort === 'desc' ? _c('i', {
            staticClass: "sort-icon fa fa-sort-desc"
          }) : _vm._e()]) : _c('div', {
            domProps: {
              "innerHTML": _vm._s(column.name)
            }
          })]);
        }))])]), _vm._v(" "), _vm._t("tbody", [_c('tbody', [_vm.loading ? _c('tr', [_c('td', {
          staticClass: "position-relative",
          style: {
            'height': _vm.height(_vm.minHeight)
          },
          attrs: {
            "colspan": _vm.tableColumns.length
          }
        }, [_c('activity-indicator', {
          attrs: {
            "center": true
          }
        })], 1)]) : !_vm.data.length ? _c('tr', [_c('td', {
          staticClass: "position-relative",
          attrs: {
            "colspan": _vm.tableColumns.length
          }
        }, [_c('alert', {
          staticClass: "my-3",
          attrs: {
            "variant": "warning"
          }
        }, [_c('i', {
          staticClass: "fa fa-warning"
        }), _vm._v(" There are no results found. ")])], 1)]) : _vm._t("default", _vm._l(_vm.data, function (row, i) {
          return _c('tr', _vm._l(_vm.tableColumns, function (column) {
            return _c('td', {
              domProps: {
                "innerHTML": _vm._s(row[column.id] || row[column.name])
              }
            });
          }));
        }), {
          data: _vm.data,
          columns: _vm.tableColumns
        })], 2)]), _vm._v(" "), _vm._t("tfoot", [_c('tfoot', [_c('td', {
          staticClass: "table-view-footer",
          attrs: {
            "colspan": _vm.tableColumns.length
          }
        }, [_vm._t("pagination", [_vm.paginate && _vm.response ? _c('pagination', {
          attrs: {
            "align": "center",
            "page": _vm.response.current_page,
            "total-pages": _vm.response.last_page,
            "on-paginate": _vm.onPaginate
          }
        }) : _vm._e()])], 2)])])], 2)]);
      },
      staticRenderFns: [],
      name: 'table-view',
      mixins: [Proxy],
      components: {
        Pagination: Pagination,
        ActivityIndicator: ActivityIndicator
      },
      props: {
        // (string) A relative or absolute endpoint URL used to fetch data
        url: {
          type: String,
          required: true
        },
        // (integer) The starting page of the table
        page: {
          type: Number,
          default: 1
        },
        // (integer) The total number of results per page
        limit: {
          type: Number,
          default: 20
        },
        // (string) The column used to order the data
        order: String,
        // (string) The sort direction (asc|desc)
        sort: {
          type: String,
          validate: function validate(value) {
            return ['asc', 'desc'].indexOf(value) !== -1;
          }
        },
        // (integer) The minimum height of the row when loading data
        minHeight: {
          type: Number,
          default: 400
        },
        // (array) An array of button objects
        // [{href: 'test-123', label: 'Test 123'}]
        buttons: {
          type: Array,
          default: function _default() {
            return [];
          }
        },
        // (array) An array of table column
        // [{id: 'database_id', name: 'Database id', width: '20%'}]
        columns: {
          type: Array,
          default: function _default() {
            return [];
          }
        },
        // (string) The table heading
        heading: String,
        // (string) Add table-hover to the table element
        hover: {
          type: Boolean,
          default: true
        },
        // (string) The table description
        description: String,
        // (bool) Should show the pagination for this table
        paginate: {
          type: Boolean,
          default: true
        },
        // (object) The HTTP response transformer instance
        transformer: {
          type: Object,
          validate: function validate(value) {
            return value instanceof TableViewTransformer;
          }
        }
      },
      computed: {
        tableColumns: function tableColumns() {
          var columns = this.columns;

          if (!columns || !columns.length) {
            columns = keys_1(this.data[0]);
          }

          return columns.map(function (column) {
            return isObject_1(column) ? column : {
              name: column
            };
          });
        }
      },
      methods: {
        orderBy: function orderBy(order) {
          var defaultSort = 'desc';
          var currentSort = this.getRequestParam('sort');
          var currentOrder = this.getRequestParam('order');
          this.addRequestParam('order', order);
          this.addRequestParam('sort', currentOrder !== order || !currentSort ? defaultSort : currentSort === defaultSort ? 'asc' : null);
          this.fetch();
        },
        getRequestHeader: function getRequestHeader(key, value) {
          return this.request.headers[key] || value;
        },
        addRequestHeader: function addRequestHeader(key, value) {
          if (!this.request.headers) {
            this.request.headers = {};
          }

          this.request.headers[key] = value;
        },
        getRequestParam: function getRequestParam(key, value) {
          return this.request.params[key] || value;
        },
        addRequestParam: function addRequestParam(key, value) {
          if (!this.request.params) {
            this.request.params = {};
          }

          this.request.params[key] = value;
        },
        fetch: function fetch() {
          var _this = this;

          var request = new Request(this.url, this.request);
          this.loading = true;
          return request.get().then(function (response) {
            var transformer = _this.transformer || new TableViewTransformer(response);
            _this.response = transformer.response();
            _this.data = transformer.data();
            _this.loading = false;
          }, function (errors) {
            _this.loading = false;
          });
        },
        height: function height(min) {
          var elements = [// this.$el.querySelector('thead'),
          this.$el.querySelector('tbody')];
          var height = 0;

          each(elements, function (el) {
            height += el.getBoundingClientRect().height;
          });

          return Math.max(min, height) + 'px';
        },
        onPaginate: function onPaginate(page, event) {
          if (!this.request.params) {
            this.request.params = {};
          }

          this.request.params.page = page;
          this.fetch();
        }
      },
      data: function data() {
        return {
          // (array) The dataset for the table
          data: this.$attrs.data || [],
          // (bool) Is the table currently loading data
          loading: false,
          // (null|object) The response object
          response: null,
          // (object) The HTTP request object
          request: extend({
            headers: {},
            params: {
              page: this.page,
              limit: this.limit,
              order: this.order,
              sort: this.sort
            }
          }, this.$attrs.request)
        };
      },
      mounted: function mounted() {
        this.fetch();
      },

      /*
      data() {
          return extend({
              buttons: [],
               columns: [],
               header: false,
               description: false,
               // (bool) Should show the pagination for this table
              paginate: true,
               // (bool) Is the table currently loading data
              loading: false,
               // (object) An object with key/value pairs for components used in the template
              components: {
                  // (string) The name of the component used for the table header
                  header: 'table-view-header',
                   // (string) The name of the component used for the table row
                  row: 'table-view-row',
                   // (string) The name of the component used for the table row
                  footer: 'table-view-footer'
              },
               // (int) The starting page
              // page: 1,
               // (string) The order of the date being returned
              // order: null,
               // (string) Either asc or desc sorting order
              // sort: null,
               // (int) The numbers of rows per page
              // limit: 20,
               // (bool) Fetch the data when table is shown
              // fetchOnRender: true,
               // (array) An array of headers appended to the request
              // requestHeaders: [],
               // (array) The default options used to generate the query string
              // defaultRequestDataOptions: [
              //    'page',
              //    'limit',
              //    'order',
              //    'sort'
              // ],
               // (object) An option to pass an object with request data
              // requestData: {},
               // (array) Additional options used to generate the query string
              // requestDataOptions: [],
               // (object) The body view options object
              // bodyViewOptions: false,
               // (object) The pagination view class
              // footerView: 'pagination',
               // (object) The pagination view options object
              // footerViewOptions: false,
               // (string) The table footer class name
              // footerClassName: 'table-header',
               // (string) The table header
              // header: false,
               // (string) The table header tag name
              // headerTagName: 'h3',
               // (string) The table header class name
              // headerClassName: 'table-header',
               // (object) The header view class
              // headerView: false,
               // (object) The header view options object
              // headerViewOptions: false,
               // (string) The table description
              // description: false,
               // (string) The table description tag
              // descriptionTag: 'p',
               // (string) The table description tag
              // descriptionClassName: 'description row col-sm-6',
               // (string) The table class name
              // tableClassName: 'table',
               // (string) The loading class name
              // loadingClassName: 'loading',
               // (string) The name of the property in the model storing the columns
              // childViewColumnsProperty: 'columns',
               // (object) The activity indicator options
              // indicatorOptions: {
              //     indicator: 'small'
              // },
               // (string) The message to display if there are no table rows
              // emptyMessage: 'No rows found',
               // (string) The name of the class appended to the buttons
              // buttonClassName: 'btn btn-default',
          }, this.$attrs);
      },
      */
      beforeDestroy: function beforeDestroy() {
        this.$off();
      }
    };

    var plugin$32 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          TableView: TableView
        });
      }
    });

    var TextareaField = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('form-group', [_vm._t("label", [_vm.label || _vm.hasDefaultSlot ? _c('form-label', {
          attrs: {
            "for": _vm.id
          }
        }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))])], 2) : _vm._e()]), _vm._v(" "), _vm._t("control", [_c('textarea', {
          directives: [{
            name: "bind-events",
            rawName: "v-bind-events",
            value: _vm.bindEvents,
            expression: "bindEvents"
          }],
          class: _vm.$mergeClasses(_vm.controlClasses, _vm.colorableClasses),
          attrs: {
            "id": _vm.id,
            "errors": _vm.errors,
            "placeholder": _vm.placeholder,
            "required": _vm.required,
            "disabled": _vm.disabled || _vm.readonly,
            "readonly": _vm.readonly,
            "pattern": _vm.pattern
          },
          domProps: {
            "value": _vm.value
          },
          on: {
            "input": function input($event) {
              _vm.updated($event.target.value);
            }
          }
        })]), _vm._v(" "), _vm._t("help", [_vm.helpText ? _c('help-text', {
          domProps: {
            "innerHTML": _vm._s(_vm.helpText)
          }
        }) : _vm._e()]), _vm._v(" "), _vm._t("feedback", [_vm.validFeedback ? _c('form-feedback', {
          attrs: {
            "valid": ""
          },
          domProps: {
            "innerHTML": _vm._s(_vm.validFeedback)
          }
        }) : _vm._e(), _vm._v(" "), _vm.invalidFeedback ? _c('form-feedback', {
          attrs: {
            "invalid": ""
          },
          domProps: {
            "innerHTML": _vm._s(_vm.invalidFeedback)
          }
        }) : _vm._e()])], 2);
      },
      staticRenderFns: [],
      name: 'textarea-field',
      mixins: [Colorable, FormControl],
      props: {
        /**
         * The type attribute
         *
         * @property String
         */
        type: {
          type: String,
          default: 'text'
        }
      }
    };

    var plugin$33 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          TextareaField: TextareaField
        });
      }
    });

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeMax$4 = Math.max;

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(o) { return o.user == 'barney'; });
     * // => 0
     *
     * // The `_.matches` iteratee shorthand.
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findIndex(users, ['active', false]);
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.findIndex(users, 'active');
     * // => 2
     */
    function findIndex(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger_1(fromIndex);
      if (index < 0) {
        index = nativeMax$4(length + index, 0);
      }
      return _baseFindIndex(array, _baseIteratee(predicate, 3), index);
    }

    var findIndex_1 = findIndex;

    /**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */
    function last(array) {
      var length = array == null ? 0 : array.length;
      return length ? array[length - 1] : undefined;
    }

    var last_1 = last;

    /**
     * Gets the parent value at `path` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} path The path to get the parent value of.
     * @returns {*} Returns the parent value.
     */
    function parent(object, path) {
      return path.length < 2 ? object : _baseGet(object, _baseSlice(path, 0, -1));
    }

    var _parent = parent;

    /**
     * The base implementation of `_.unset`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The property path to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     */
    function baseUnset(object, path) {
      path = _castPath(path, object);
      object = _parent(object, path);
      return object == null || delete object[_toKey(last_1(path))];
    }

    var _baseUnset = baseUnset;

    /** Used for built-in method references. */
    var arrayProto$1 = Array.prototype;

    /** Built-in value references. */
    var splice$1 = arrayProto$1.splice;

    /**
     * The base implementation of `_.pullAt` without support for individual
     * indexes or capturing the removed elements.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {number[]} indexes The indexes of elements to remove.
     * @returns {Array} Returns `array`.
     */
    function basePullAt(array, indexes) {
      var length = array ? indexes.length : 0,
          lastIndex = length - 1;

      while (length--) {
        var index = indexes[length];
        if (length == lastIndex || index !== previous) {
          var previous = index;
          if (_isIndex(index)) {
            splice$1.call(array, index, 1);
          } else {
            _baseUnset(array, index);
          }
        }
      }
      return array;
    }

    var _basePullAt = basePullAt;

    /**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is invoked
     * with three arguments: (value, index, array).
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
     * to pull elements from an array by value.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */
    function remove(array, predicate) {
      var result = [];
      if (!(array && array.length)) {
        return result;
      }
      var index = -1,
          indexes = [],
          length = array.length;

      predicate = _baseIteratee(predicate, 3);
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result.push(value);
          indexes.push(index);
        }
      }
      _basePullAt(array, indexes);
      return result;
    }

    var remove_1 = remove;

    var UploadField = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('form-group', {
          staticClass: "upload-field",
          class: {
            'enable-dropzone': _vm.dropzone,
            'enable-multiple': _vm.multiple
          },
          on: {
            "dragenter": function dragenter($event) {
              $event.preventDefault();
              return _vm.onDragEnter($event);
            },
            "dragover": function dragover($event) {
              $event.preventDefault();
              return _vm.onDragOver($event);
            },
            "dragleave": function dragleave($event) {
              $event.preventDefault();
              return _vm.onDragLeave($event);
            }
          }
        }, [_vm.multiple && (!_vm.maxUploads || _vm.maxUploads > _vm.value.length) || !_vm.multiple && !_vm.value ? _c('file-field', {
          attrs: {
            "name": _vm.name,
            "label": _vm.label,
            "placeholder": _vm.placeholder,
            "help-text": _vm.helpText,
            "multiple": _vm.multiple,
            "width": _vm.width,
            "height": _vm.height,
            "errors": _vm.errors
          },
          on: {
            "change": _vm.onChange
          }
        }) : _vm._e(), _vm._v(" "), _vm.multiple && _vm.value && _vm.value.length ? _c('div', {
          staticClass: "upload-field-preview mt-4"
        }, _vm._l(_vm.value, function (file, key) {
          return _c('file-preview', {
            key: file.id || key,
            attrs: {
              "file": file
            },
            on: {
              "close": function close($event) {
                _vm.removeFile(file);
              }
            }
          });
        })) : !_vm.multiple && _vm.value ? _c('div', {
          staticClass: "upload-field-preview mt-4"
        }, [_c('file-preview', {
          attrs: {
            "file": _vm.value
          },
          on: {
            "close": function close($event) {
              _vm.removeFile(_vm.value);
            }
          }
        })], 1) : _vm._e(), _vm._v(" "), _vm.showDropElement ? _c('div', {
          staticClass: "upload-field-dropzone",
          style: {
            'min-height': _vm.dropzoneMinHeight
          },
          on: {
            "drop": function drop($event) {
              $event.preventDefault();
              return _vm.onDrop($event);
            }
          }
        }, [_c('i', {
          staticClass: "fa fa-cloud-upload"
        }), _vm._v(" "), _c('div', [_vm._v("Drag and drop files to upload")])]) : _vm._e()], 1);
      },
      staticRenderFns: [],
      name: 'upload-field',
      mixins: [FormControl],
      components: {
        FileField: FileField,
        FilePreview: FilePreview
      },
      model: {
        prop: 'value',
        event: 'change'
      },
      props: {
        /**
         * Can user upload multiple files
         *
         * @property String
         */
        multiple: Boolean,

        /**
         * The maximum number of files that a user can upload
         *
         * @property String
         */
        maxUploads: Number,

        /**
         * The height attribute for the control element
         *
         * @property String
         */
        height: [Number, String],

        /**
         * The width attribute for the control element
         *
         * @property String
         */
        width: [Number, String],

        /**
         * Can user drag/drop files into browser to upload them.
         *
         * @property String
         */
        dropzoneMinHeight: [Number, String],

        /**
         * Is the user dragging a file over the dropzone
         *
         * @property String
         */
        dragging: {
          type: [String, Boolean],
          default: function _default() {
            return undefined;
          }
        },

        /**
         * Can user drag/drop files into browser to upload them.
         *
         * @property String
         */
        dropzone: {
          type: Boolean,
          default: true
        },

        /**
         * The data attribute
         *
         * @property File|FileList|Array
         */
        value: {
          type: [Object, File, FileList, Array],
          default: function _default() {
            return !this.multiple ? null : [];
          }
        }
      },
      methods: {
        removeFile: function removeFile(data) {
          if (this.multiple) {
            var files = isArray_1(this.value) ? this.value.slice(0) : [];

            if (data instanceof File) {
              remove_1(files, {
                name: data.name,
                size: data.size,
                lastModified: data.lastModified
              });
            } else {
              remove_1(files, data);
            }

            this.$emit('change', files);
          } else {
            this.$emit('change', null);
          }
        },
        addFile: function addFile(file, subject) {
          var data = {
            name: file.name,
            lastModified: file.lastModified,
            lastModifiedDate: file.lastModifiedDate,
            size: file.size,
            type: file.type
          };

          if (this.multiple) {
            var files = subject || (isArray_1(this.value) ? this.value.slice(0) : []);

            if (!this.maxUploads || this.maxUploads > files.length) {
              if (findIndex_1(files, data) === -1) {
                files.push(file);
              }

              this.$emit('change', files);
            }
          } else {
            this.$emit('change', file);
          }
        },
        addFiles: function addFiles(files) {
          var _this = this;

          var subject = isArray_1(this.value) ? this.value.slice(0) : [];

          each(files, function (file) {
            _this.addFile(file, subject);
          });

          event.target.value = null;
        },
        onChange: function onChange(files) {
          if (files instanceof FileList) {
            this.addFiles(files);
          } else {
            this.addFile(files);
          }
        },

        /**
         * The `dragover` event callback.
         *
         * @property String
         */
        onDragOver: function onDragOver(event) {
          this.isDraggingInside = true;
          this.$emit('update:dragging', true);
          this.$emit('drag:over', event);
        },

        /**
         * The `dragover` event callback.
         *
         * @property String
         */
        onDragEnter: function onDragEnter(event) {
          this.isDraggingInside = true;
          this.$emit('update:dragging', true);
          this.$emit('drag:enter', event);
        },

        /**
         * The `dragleave` event callback.
         *
         * @property String
         */
        onDragLeave: function onDragLeave(event) {
          this.isDraggingInside = false;
          this.$emit('update:dragging', false);
          this.$emit('drag:leave', event);
        },

        /**
         * The `drop` event callback.
         *
         * @property String
         */
        onDrop: function onDrop(event) {
          this.isDraggingInside = false;
          this.addFiles(event.dataTransfer.files);
          this.$emit('update:dragging', false);
          this.$emit('drop', event);
        }
      },
      computed: {
        showDropElement: function showDropElement() {
          return !isUndefined_1(this.dragging) ? this.dragging : this.isDraggingInside;
        }
      },
      data: function data() {
        return {
          isDraggingInside: false
        };
      }
    };

    var plugin$34 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          UploadField: UploadField
        });
      }
    });



    var components$1 = /*#__PURE__*/Object.freeze({
        ActivityButton: ActivityButton,
        ActivityIndicator: ActivityIndicator,
        Alert: Alert,
        AlertClose: AlertClose,
        AlertHeading: AlertHeading,
        AlertLink: AlertLink,
        Badge: Badge,
        BaseForm: BaseForm,
        Breadcrumb: Breadcrumb,
        BreadcrumbItem: BreadcrumbItem,
        Btn: Btn,
        BtnGroup: BtnGroup,
        BtnToolbar: BtnToolbar,
        ButtonDropdown: ButtonDropdown,
        Card: Card,
        CardBody: CardBody,
        CardFooter: CardFooter,
        CardHeader: CardHeader,
        CardImg: CardImg,
        CardImgTop: CardImgTop,
        CardImgBottom: CardImgBottom,
        CardImgOverlay: CardImgOverlay,
        CardLink: CardLink,
        CardSubtitle: CardSubtitle,
        CardTitle: CardTitle,
        CheckboxField: CheckboxField,
        Container: Container,
        DropdownMenu: DropdownMenu,
        DropdownMenuItem: DropdownMenuItem,
        DropdownMenuHeader: DropdownMenuHeader,
        DropdownMenuDivider: DropdownMenuDivider,
        FileButton: FileButton,
        FileField: FileField,
        FilePreview: FilePreview,
        FormControl: FormControl$1,
        FormFeedback: FormFeedback,
        FormGroup: FormGroup,
        FormLabel: FormLabel,
        HelpText: HelpText,
        InputField: InputField,
        InputGroup: InputGroup,
        InputGroupAppend: InputGroupAppend,
        InputGroupPrepend: InputGroupPrepend,
        InputGroupText: InputGroupText,
        LightSwitchField: LightSwitchField,
        ListGroup: ListGroup,
        ListGroupItem: ListGroupItem,
        Navigation: Navigation,
        NavigationItem: NavigationItem,
        NavigationLink: NavigationLink,
        NavigationDropdown: NavigationDropdown,
        Overlay: Overlay,
        Pagination: Pagination,
        ProgressBar: ProgressBar,
        RadioField: RadioField,
        SelectField: SelectField,
        TableView: TableView,
        TextareaField: TextareaField,
        UploadField: UploadField
    });

    var ResponseTransformer = function ResponseTransformer(response) {
      _classCallCheck(this, ResponseTransformer);

      this.$response = response;
    };

    function blob(url, progress) {
      return new Promise(function (resolve, reject) {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, true);
        xhr.responseType = 'blob';

        if (isFunction_1(progress)) {
          xhr.onprogress = function (e) {
            return progress(e, xhr);
          };
        }

        xhr.onerror = function (e) {
          return reject(e);
        };

        xhr.onabort = function (e) {
          return reject(e);
        };

        xhr.onload = function (e) {
          if (this.status === 200) {
            resolve(this.response);
          } else {
            reject(e);
          }
        };

        xhr.send();
      });
    }

    var main = VueInstaller.use({
      install: function install(Vue) {
        {
          var domain = (location.host || 'localhost').split(':')[0];
          var port = {
            "watch": "/Users/justinkimbrell/Github/vue-toolbox/src/",
            "port": 35730
          } && {
            "watch": "/Users/justinkimbrell/Github/vue-toolbox/src/",
            "port": 35730
          }.port;
          VueInstaller.script("http://".concat(domain, ":").concat(port, "/livereload.js?snipver=1"));
        }

        VueInstaller.plugins(Vue, plugins);
        VueInstaller.components(Vue, components$1);
        VueInstaller.filters(Vue, filters);
      }
    });

    exports.default = main;
    exports.Model = Model;
    exports.Request = Request;
    exports.ResponseTransformer = ResponseTransformer;
    exports.TableViewTransformer = TableViewTransformer;
    exports.Transformer = Transformer;
    exports.Colorable = Colorable;
    exports.FormControlMixin = FormControl;
    exports.HasSlots = HasSlots;
    exports.Proxy = Proxy;
    exports.Screenreaders = Screenreaders;
    exports.Sizeable = Sizeable;
    exports.Variant = Variant;
    exports.mergeClasses = MergeClasses;
    exports.overlay = overlay;
    exports.ActivityButton = ActivityButton;
    exports.ActivityIndicator = ActivityIndicator;
    exports.Alert = Alert;
    exports.AlertClose = AlertClose;
    exports.AlertHeading = AlertHeading;
    exports.AlertLink = AlertLink;
    exports.Badge = Badge;
    exports.BaseForm = BaseForm;
    exports.Breadcrumb = Breadcrumb;
    exports.BreadcrumbItem = BreadcrumbItem;
    exports.Btn = Btn;
    exports.BtnGroup = BtnGroup;
    exports.BtnToolbar = BtnToolbar;
    exports.ButtonDropdown = ButtonDropdown;
    exports.Card = Card;
    exports.CardBody = CardBody;
    exports.CardFooter = CardFooter;
    exports.CardHeader = CardHeader;
    exports.CardImg = CardImg;
    exports.CardImgTop = CardImgTop;
    exports.CardImgBottom = CardImgBottom;
    exports.CardImgOverlay = CardImgOverlay;
    exports.CardLink = CardLink;
    exports.CardSubtitle = CardSubtitle;
    exports.CardTitle = CardTitle;
    exports.CheckboxField = CheckboxField;
    exports.Container = Container;
    exports.DropdownMenu = DropdownMenu;
    exports.DropdownMenuItem = DropdownMenuItem;
    exports.DropdownMenuHeader = DropdownMenuHeader;
    exports.DropdownMenuDivider = DropdownMenuDivider;
    exports.FileButton = FileButton;
    exports.FileField = FileField;
    exports.FilePreview = FilePreview;
    exports.FormControl = FormControl$1;
    exports.FormFeedback = FormFeedback;
    exports.FormGroup = FormGroup;
    exports.FormLabel = FormLabel;
    exports.HelpText = HelpText;
    exports.InputField = InputField;
    exports.InputGroup = InputGroup;
    exports.InputGroupAppend = InputGroupAppend;
    exports.InputGroupPrepend = InputGroupPrepend;
    exports.InputGroupText = InputGroupText;
    exports.LightSwitchField = LightSwitchField;
    exports.ListGroup = ListGroup;
    exports.ListGroupItem = ListGroupItem;
    exports.Navigation = Navigation;
    exports.NavigationItem = NavigationItem;
    exports.NavigationLink = NavigationLink;
    exports.NavigationDropdown = NavigationDropdown;
    exports.Overlay = Overlay;
    exports.Pagination = Pagination;
    exports.ProgressBar = ProgressBar;
    exports.RadioField = RadioField;
    exports.SelectField = SelectField;
    exports.TableView = TableView;
    exports.TextareaField = TextareaField;
    exports.UploadField = UploadField;
    exports.DateFilter = index;
    exports.MomentFilter = index;
    exports.blob = blob;
    exports.prefix = prefix;
    exports.readFile = readFile;
    exports.script = script;
    exports.transition = transition;
    exports.uuid = uuid;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidnVlLXRvb2xib3guanMiLCJzb3VyY2VzIjpbIi4uL3NyYy9GaWx0ZXJzL0RhdGUvRGF0ZUZpbHRlci5qcyIsIi4uL3NyYy9GaWx0ZXJzL0RhdGUvTW9tZW50RmlsdGVyLmpzIiwiLi4vc3JjL0ZpbHRlcnMvRGF0ZS9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3QuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19mcmVlR2xvYmFsLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fcm9vdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1N5bWJvbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFJhd1RhZy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX29iamVjdFRvU3RyaW5nLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUdldFRhZy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNGdW5jdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcmVKc0RhdGEuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc01hc2tlZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3RvU291cmNlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzTmF0aXZlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0VmFsdWUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXROYXRpdmUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19kZWZpbmVQcm9wZXJ0eS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VBc3NpZ25WYWx1ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvZXEuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hc3NpZ25WYWx1ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcHlPYmplY3QuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lkZW50aXR5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXBwbHkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19vdmVyUmVzdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvY29uc3RhbnQuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlU2V0VG9TdHJpbmcuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zaG9ydE91dC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldFRvU3RyaW5nLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVJlc3QuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzTGVuZ3RoLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5TGlrZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzSW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0l0ZXJhdGVlQ2FsbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZUFzc2lnbmVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVRpbWVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc09iamVjdExpa2UuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNBcmd1bWVudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJndW1lbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9zdHViRmFsc2UuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQnVmZmVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzVHlwZWRBcnJheS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VVbmFyeS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX25vZGVVdGlsLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1R5cGVkQXJyYXkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUxpa2VLZXlzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNQcm90b3R5cGUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVLZXlzSW4uanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlS2V5c0luLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9rZXlzSW4uanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL2Fzc2lnbkluLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9leHRlbmQuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVDbGVhci5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Fzc29jSW5kZXhPZi5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZURlbGV0ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUdldC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUhhcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZVNldC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX0xpc3RDYWNoZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrQ2xlYXIuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0RlbGV0ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrR2V0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tIYXMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19NYXAuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVDcmVhdGUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoQ2xlYXIuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoRGVsZXRlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaEdldC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hIYXMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoU2V0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fSGFzaC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlQ2xlYXIuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0tleWFibGUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRNYXBEYXRhLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVEZWxldGUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUdldC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlSGFzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVTZXQuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19NYXBDYWNoZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrU2V0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU3RhY2suanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hc3NpZ25NZXJnZVZhbHVlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlQmFzZUZvci5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VGb3IuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZUJ1ZmZlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1VpbnQ4QXJyYXkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZUFycmF5QnVmZmVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVUeXBlZEFycmF5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY29weUFycmF5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUNyZWF0ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX292ZXJBcmcuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRQcm90b3R5cGUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pbml0Q2xvbmVPYmplY3QuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXlMaWtlT2JqZWN0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1BsYWluT2JqZWN0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc2FmZUdldC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvdG9QbGFpbk9iamVjdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VNZXJnZURlZXAuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlTWVyZ2UuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL21lcmdlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlFYWNoLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbmF0aXZlS2V5cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VLZXlzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9rZXlzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUZvck93bi5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZUJhc2VFYWNoLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUVhY2guanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jYXN0RnVuY3Rpb24uanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL2ZvckVhY2guanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL2VhY2guanMiLCIuLi9zcmMvUGx1Z2lucy9NZXJnZUNsYXNzZXMvTWVyZ2VDbGFzc2VzLmpzIiwiLi4vc3JjL0NvbXBvbmVudHMvT3ZlcmxheS9PdmVybGF5LnZ1ZSIsIi4uL3NyYy9QbHVnaW5zL092ZXJsYXkvT3ZlcmxheS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5UmVkdWNlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVByb3BlcnR5T2YuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19kZWJ1cnJMZXR0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheU1hcC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNTeW1ib2wuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVG9TdHJpbmcuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL3RvU3RyaW5nLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9kZWJ1cnIuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hc2NpaVdvcmRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzVW5pY29kZVdvcmQuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL191bmljb2RlV29yZHMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL3dvcmRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlQ29tcG91bmRlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gva2ViYWJDYXNlLmpzIiwiLi4vc3JjL0NvbXBvbmVudHMvQWN0aXZpdHlJbmRpY2F0b3IvVHlwZXMvQmFzZVR5cGUudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvQWN0aXZpdHlJbmRpY2F0b3IvVHlwZXMvRG90cy52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9BY3Rpdml0eUluZGljYXRvci9UeXBlcy9TcGlubmVyLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL0FjdGl2aXR5SW5kaWNhdG9yL0FjdGl2aXR5SW5kaWNhdG9yLnZ1ZSIsIi4uL3NyYy9IZWxwZXJzL1NjcmlwdC9TY3JpcHQuanMiLCIuLi9zcmMvSGVscGVycy9WdWVJbnN0YWxsZXIvVnVlSW5zdGFsbGVyLmpzIiwiLi4vc3JjL0NvbXBvbmVudHMvQWN0aXZpdHlJbmRpY2F0b3IvaW5kZXguanMiLCIuLi9zcmMvQ29tcG9uZW50cy9BY3Rpdml0eUJ1dHRvbi9BY3Rpdml0eUJ1dHRvbi52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9BY3Rpdml0eUJ1dHRvbi9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNVbmRlZmluZWQuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zZXRDYWNoZUFkZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldENhY2hlSGFzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU2V0Q2FjaGUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheVNvbWUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jYWNoZUhhcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2VxdWFsQXJyYXlzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwVG9BcnJheS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldFRvQXJyYXkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19lcXVhbEJ5VGFnLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlQdXNoLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUdldEFsbEtleXMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUZpbHRlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvc3R1YkFycmF5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0U3ltYm9scy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldEFsbEtleXMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19lcXVhbE9iamVjdHMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19EYXRhVmlldy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1Byb21pc2UuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19TZXQuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19XZWFrTWFwLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0VGFnLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzRXF1YWxEZWVwLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzRXF1YWwuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNNYXRjaC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzU3RyaWN0Q29tcGFyYWJsZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldE1hdGNoRGF0YS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZU1hdGNoZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0tleS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvbWVtb2l6ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21lbW9pemVDYXBwZWQuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdHJpbmdUb1BhdGguanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jYXN0UGF0aC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3RvS2V5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUdldC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvZ2V0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUhhc0luLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzUGF0aC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaGFzSW4uanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlTWF0Y2hlc1Byb3BlcnR5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVByb3BlcnR5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVByb3BlcnR5RGVlcC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvcHJvcGVydHkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXRlcmF0ZWUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL21hcEtleXMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzTnVsbC5qcyIsIi4uL3NyYy9IZWxwZXJzL1ByZWZpeC9QcmVmaXguanMiLCIuLi9zcmMvTWl4aW5zL1ZhcmlhbnQvVmFyaWFudC5qcyIsIi4uL3NyYy9IZWxwZXJzL1RyYW5zaXRpb24vVHJhbnNpdGlvbi5qcyIsIi4uL3NyYy9Db21wb25lbnRzL0FsZXJ0L0FsZXJ0LnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL0FsZXJ0L0FsZXJ0TGluay52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9BbGVydC9BbGVydENsb3NlLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL0FsZXJ0L0FsZXJ0SGVhZGluZy52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9BbGVydC9pbmRleC5qcyIsIi4uL3NyYy9Db21wb25lbnRzL0JhZGdlL0JhZGdlLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL0JhZGdlL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVJlZHVjZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvcmVkdWNlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVNldC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VQaWNrQnkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRTeW1ib2xzSW4uanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRBbGxLZXlzSW4uanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL3BpY2tCeS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VGaWx0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL2ZpbHRlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNTdHJpbmcuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hc2NpaVNpemUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNVbmljb2RlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fdW5pY29kZVNpemUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdHJpbmdTaXplLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9zaXplLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZU1hcC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvbWFwLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVNsaWNlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2FzdFNsaWNlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXNjaWlUb0FycmF5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fdW5pY29kZVRvQXJyYXkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdHJpbmdUb0FycmF5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlQ2FzZUZpcnN0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC91cHBlckZpcnN0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9jYXBpdGFsaXplLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9jYW1lbENhc2UuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tZXRhTWFwLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVNldERhdGEuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jcmVhdGVDdG9yLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlQmluZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvbXBvc2VBcmdzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY29tcG9zZUFyZ3NSaWdodC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvdW50SG9sZGVycy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VMb2Rhc2guanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19MYXp5V3JhcHBlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvbm9vcC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldERhdGEuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19yZWFsTmFtZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRGdW5jTmFtZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX0xvZGFzaFdyYXBwZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL193cmFwcGVyQ2xvbmUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL3dyYXBwZXJMb2Rhc2guanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0xhemlhYmxlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc2V0RGF0YS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFdyYXBEZXRhaWxzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faW5zZXJ0V3JhcERldGFpbHMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRmluZEluZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzTmFOLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RyaWN0SW5kZXhPZi5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJbmRleE9mLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlJbmNsdWRlcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3VwZGF0ZVdyYXBEZXRhaWxzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc2V0V3JhcFRvU3RyaW5nLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlUmVjdXJyeS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldEhvbGRlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3Jlb3JkZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19yZXBsYWNlSG9sZGVycy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZUh5YnJpZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZUN1cnJ5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlUGFydGlhbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21lcmdlRGF0YS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvdG9OdW1iZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL3RvRmluaXRlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC90b0ludGVnZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jcmVhdGVXcmFwLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9iaW5kLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3JvbGx1cC1wbHVnaW4tbm9kZS1nbG9iYWxzL3NyYy9nbG9iYWwuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy1lczYvYnJvd3Nlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9heGlvcy9kaXN0L2F4aW9zLmpzIiwiLi4vc3JjL0h0dHAvUmVxdWVzdC9SZXF1ZXN0LmpzIiwiLi4vc3JjL0h0dHAvTW9kZWwvTW9kZWwuanMiLCIuLi9zcmMvQ29tcG9uZW50cy9CYXNlRm9ybS9CYXNlRm9ybS52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9CYXNlRm9ybS9pbmRleC5qcyIsIi4uL3NyYy9Db21wb25lbnRzL0JyZWFkY3J1bWIvQnJlYWRjcnVtYi52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9CcmVhZGNydW1iL0JyZWFkY3J1bWJJdGVtLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL0JyZWFkY3J1bWIvaW5kZXguanMiLCIuLi9zcmMvTWl4aW5zL1NpemVhYmxlL1NpemVhYmxlLmpzIiwiLi4vc3JjL0NvbXBvbmVudHMvQnRuL0J0bi52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9CdG4vaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL25lZ2F0ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvb21pdEJ5LmpzIiwiLi4vc3JjL01peGlucy9Db2xvcmFibGUvQ29sb3JhYmxlLmpzIiwiLi4vc3JjL0NvbXBvbmVudHMvQnRuR3JvdXAvQnRuR3JvdXAudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvQnRuR3JvdXAvQnRuVG9vbGJhci52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9CdG5Hcm91cC9pbmRleC5qcyIsIi4uL3NyYy9IZWxwZXJzL1V1aWQvVXVpZC5qcyIsIi4uL3NyYy9NaXhpbnMvUHJveHkvUHJveHkuanMiLCIuLi9zcmMvQ29tcG9uZW50cy9Ecm9wZG93bk1lbnUvRHJvcGRvd25NZW51SXRlbS52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9Ecm9wZG93bk1lbnUvRHJvcGRvd25NZW51SGVhZGVyLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL0Ryb3Bkb3duTWVudS9Ecm9wZG93bk1lbnVEaXZpZGVyLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL0Ryb3Bkb3duTWVudS9Ecm9wZG93bk1lbnUudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvRHJvcGRvd25NZW51L2luZGV4LmpzIiwiLi4vc3JjL0NvbXBvbmVudHMvQnV0dG9uRHJvcGRvd24vQnV0dG9uRHJvcGRvd24udnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvQnV0dG9uRHJvcGRvd24vaW5kZXguanMiLCIuLi9zcmMvTWl4aW5zL0hhc1Nsb3RzL0hhc1Nsb3RzLmpzIiwiLi4vc3JjL0NvbXBvbmVudHMvQ2FyZC9DYXJkLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL0NhcmQvQ2FyZEJvZHkudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvQ2FyZC9DYXJkSGVhZGVyLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL0NhcmQvQ2FyZEZvb3Rlci52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9DYXJkL0NhcmRJbWcudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvQ2FyZC9DYXJkSW1nVG9wLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL0NhcmQvQ2FyZEltZ0JvdHRvbS52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9DYXJkL0NhcmRJbWdPdmVybGF5LnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL0NhcmQvQ2FyZExpbmsudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvQ2FyZC9DYXJkU3VidGl0bGUudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvQ2FyZC9DYXJkVGl0bGUudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvQ2FyZC9pbmRleC5qcyIsIi4uL3NyYy9NaXhpbnMvRm9ybUNvbnRyb2wvRm9ybUNvbnRyb2wuanMiLCIuLi9zcmMvQ29tcG9uZW50cy9SYWRpb0ZpZWxkL1JhZGlvRmllbGQudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvQ2hlY2tib3hGaWVsZC9DaGVja2JveEZpZWxkLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL0NoZWNrYm94RmllbGQvaW5kZXguanMiLCIuLi9zcmMvQ29tcG9uZW50cy9Db250YWluZXIvQ29udGFpbmVyLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL0NvbnRhaW5lci9pbmRleC5qcyIsIi4uL3NyYy9Db21wb25lbnRzL0lucHV0RmllbGQvSW5wdXRGaWVsZC52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9GaWxlRmllbGQvRmlsZUZpZWxkLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL0ZpbGVCdXR0b24vRmlsZUJ1dHRvbi52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9GaWxlQnV0dG9uL2luZGV4LmpzIiwiLi4vc3JjL0NvbXBvbmVudHMvRmlsZUZpZWxkL2luZGV4LmpzIiwiLi4vc3JjL0hlbHBlcnMvUmVhZEZpbGUvUmVhZEZpbGUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzTnVtYmVyLmpzIiwiLi4vc3JjL0NvbXBvbmVudHMvUHJvZ3Jlc3NCYXIvUHJvZ3Jlc3NCYXIudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvRmlsZVByZXZpZXcvRmlsZVByZXZpZXcudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvRmlsZVByZXZpZXcvaW5kZXguanMiLCIuLi9zcmMvQ29tcG9uZW50cy9Gb3JtQ29udHJvbC9Gb3JtQ29udHJvbC52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9Gb3JtQ29udHJvbC9pbmRleC5qcyIsIi4uL3NyYy9Db21wb25lbnRzL0Zvcm1GZWVkYmFjay9Gb3JtRmVlZGJhY2sudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvRm9ybUZlZWRiYWNrL2luZGV4LmpzIiwiLi4vc3JjL0NvbXBvbmVudHMvRm9ybUdyb3VwL0Zvcm1Hcm91cC52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9Gb3JtR3JvdXAvaW5kZXguanMiLCIuLi9zcmMvTWl4aW5zL1NjcmVlbnJlYWRlcnMvU2NyZWVucmVhZGVycy5qcyIsIi4uL3NyYy9Db21wb25lbnRzL0Zvcm1MYWJlbC9Gb3JtTGFiZWwudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvRm9ybUxhYmVsL2luZGV4LmpzIiwiLi4vc3JjL0NvbXBvbmVudHMvSGVscFRleHQvSGVscFRleHQudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvSGVscFRleHQvaW5kZXguanMiLCIuLi9zcmMvQ29tcG9uZW50cy9JbnB1dEZpZWxkL2luZGV4LmpzIiwiLi4vc3JjL0NvbXBvbmVudHMvSW5wdXRHcm91cC9JbnB1dEdyb3VwLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL0lucHV0R3JvdXAvSW5wdXRHcm91cEFwcGVuZC52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9JbnB1dEdyb3VwL0lucHV0R3JvdXBQcmVwZW5kLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL0lucHV0R3JvdXAvSW5wdXRHcm91cFRleHQudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvSW5wdXRHcm91cC9pbmRleC5qcyIsIi4uL3NyYy9Db21wb25lbnRzL0xpZ2h0U3dpdGNoRmllbGQvTGlnaHRTd2l0Y2hGaWVsZC52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9MaWdodFN3aXRjaEZpZWxkL2luZGV4LmpzIiwiLi4vc3JjL0NvbXBvbmVudHMvTGlzdEdyb3VwL0xpc3RHcm91cEl0ZW0udnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvTGlzdEdyb3VwL0xpc3RHcm91cC52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9MaXN0R3JvdXAvaW5kZXguanMiLCIuLi9zcmMvQ29tcG9uZW50cy9OYXZpZ2F0aW9uL05hdmlnYXRpb24udnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvTmF2aWdhdGlvbi9OYXZpZ2F0aW9uTGluay52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9OYXZpZ2F0aW9uL05hdmlnYXRpb25JdGVtLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL05hdmlnYXRpb24vTmF2aWdhdGlvbkRyb3Bkb3duLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL05hdmlnYXRpb24vaW5kZXguanMiLCIuLi9zcmMvQ29tcG9uZW50cy9PdmVybGF5L2luZGV4LmpzIiwiLi4vc3JjL0NvbXBvbmVudHMvUGFnaW5hdGlvbi9QYWdpbmF0aW9uLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL1BhZ2luYXRpb24vaW5kZXguanMiLCIuLi9zcmMvQ29tcG9uZW50cy9Qcm9ncmVzc0Jhci9pbmRleC5qcyIsIi4uL3NyYy9Db21wb25lbnRzL1JhZGlvRmllbGQvaW5kZXguanMiLCIuLi9zcmMvQ29tcG9uZW50cy9TZWxlY3RGaWVsZC9TZWxlY3RGaWVsZC52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9TZWxlY3RGaWVsZC9pbmRleC5qcyIsIi4uL3NyYy9IdHRwL1RyYW5zZm9ybWVyL1RyYW5zZm9ybWVyLmpzIiwiLi4vc3JjL0h0dHAvVGFibGVWaWV3VHJhbnNmb3JtZXIvVGFibGVWaWV3VHJhbnNmb3JtZXIuanMiLCIuLi9zcmMvQ29tcG9uZW50cy9UYWJsZVZpZXcvVGFibGVWaWV3LnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL1RhYmxlVmlldy9pbmRleC5qcyIsIi4uL3NyYy9Db21wb25lbnRzL1RleHRhcmVhRmllbGQvVGV4dGFyZWFGaWVsZC52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9UZXh0YXJlYUZpZWxkL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9maW5kSW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL2xhc3QuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19wYXJlbnQuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVW5zZXQuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlUHVsbEF0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9yZW1vdmUuanMiLCIuLi9zcmMvQ29tcG9uZW50cy9VcGxvYWRGaWVsZC9VcGxvYWRGaWVsZC52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9VcGxvYWRGaWVsZC9pbmRleC5qcyIsIi4uL3NyYy9IdHRwL1Jlc3BvbnNlVHJhbnNmb3JtZXIvUmVzcG9uc2VUcmFuc2Zvcm1lci5qcyIsIi4uL3NyYy9IZWxwZXJzL0Jsb2IvQmxvYi5qcyIsIi4uL3NyYy9tYWluLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtb21lbnQgZnJvbSAnbW9tZW50JztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWUsIGZvcm1hdCkge1xuICAgIGlmKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBtb21lbnQoU3RyaW5nKHZhbHVlKSkuZm9ybWF0KGZvcm1hdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xufVxuIiwiaW1wb3J0IG1vbWVudCBmcm9tICdtb21lbnQnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZSwgZm9ybWF0KSB7XG4gICAgaWYodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG1vbWVudChTdHJpbmcodmFsdWUpKS5mb3JtYXQoZm9ybWF0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG59XG4iLCJpbXBvcnQgRGF0ZUZpbHRlciBmcm9tICcuL0RhdGVGaWx0ZXInO1xuaW1wb3J0IE1vbWVudEZpbHRlciBmcm9tICcuL01vbWVudEZpbHRlcic7XG5cbmV4cG9ydCB7XG4gICAgRGF0ZUZpbHRlcixcbiAgICBNb21lbnRGaWx0ZXJcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKFZ1ZSwgb3B0aW9ucykge1xuICAgIFZ1ZS5maWx0ZXIoJ2RhdGUnLCBEYXRlRmlsdGVyKTtcbiAgICBWdWUuZmlsdGVyKCdtb21lbnQnLCBNb21lbnRGaWx0ZXIpO1xufTtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheTtcbiIsIi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbm1vZHVsZS5leHBvcnRzID0gZnJlZUdsb2JhbDtcbiIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gcm9vdDtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW1ib2w7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRSYXdUYWc7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvYmplY3RUb1N0cmluZztcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBnZXRSYXdUYWcgPSByZXF1aXJlKCcuL19nZXRSYXdUYWcnKSxcbiAgICBvYmplY3RUb1N0cmluZyA9IHJlcXVpcmUoJy4vX29iamVjdFRvU3RyaW5nJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gIH1cbiAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgID8gZ2V0UmF3VGFnKHZhbHVlKVxuICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXRUYWc7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0Z1bmN0aW9uO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbnZhciBjb3JlSnNEYXRhID0gcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbm1vZHVsZS5leHBvcnRzID0gY29yZUpzRGF0YTtcbiIsInZhciBjb3JlSnNEYXRhID0gcmVxdWlyZSgnLi9fY29yZUpzRGF0YScpO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xudmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbn0oKSk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTWFza2VkO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvU291cmNlO1xuIiwidmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2lzRnVuY3Rpb24nKSxcbiAgICBpc01hc2tlZCA9IHJlcXVpcmUoJy4vX2lzTWFza2VkJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgdG9Tb3VyY2UgPSByZXF1aXJlKCcuL190b1NvdXJjZScpO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb24odmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc05hdGl2ZTtcbiIsIi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFZhbHVlO1xuIiwidmFyIGJhc2VJc05hdGl2ZSA9IHJlcXVpcmUoJy4vX2Jhc2VJc05hdGl2ZScpLFxuICAgIGdldFZhbHVlID0gcmVxdWlyZSgnLi9fZ2V0VmFsdWUnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcbiAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXROYXRpdmU7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyk7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgZnVuYyA9IGdldE5hdGl2ZShPYmplY3QsICdkZWZpbmVQcm9wZXJ0eScpO1xuICAgIGZ1bmMoe30sICcnLCB7fSk7XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmluZVByb3BlcnR5O1xuIiwidmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fZGVmaW5lUHJvcGVydHknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYXNzaWduVmFsdWVgIGFuZCBgYXNzaWduTWVyZ2VWYWx1ZWAgd2l0aG91dFxuICogdmFsdWUgY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSA9PSAnX19wcm90b19fJyAmJiBkZWZpbmVQcm9wZXJ0eSkge1xuICAgIGRlZmluZVByb3BlcnR5KG9iamVjdCwga2V5LCB7XG4gICAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAgICdlbnVtZXJhYmxlJzogdHJ1ZSxcbiAgICAgICd2YWx1ZSc6IHZhbHVlLFxuICAgICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQXNzaWduVmFsdWU7XG4iLCIvKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcTtcbiIsInZhciBiYXNlQXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19iYXNlQXNzaWduVmFsdWUnKSxcbiAgICBlcSA9IHJlcXVpcmUoJy4vZXEnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBc3NpZ25zIGB2YWx1ZWAgdG8gYGtleWAgb2YgYG9iamVjdGAgaWYgdGhlIGV4aXN0aW5nIHZhbHVlIGlzIG5vdCBlcXVpdmFsZW50XG4gKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgaWYgKCEoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYgZXEob2JqVmFsdWUsIHZhbHVlKSkgfHxcbiAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NpZ25WYWx1ZTtcbiIsInZhciBhc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnblZhbHVlJyksXG4gICAgYmFzZUFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnblZhbHVlJyk7XG5cbi8qKlxuICogQ29waWVzIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycyB0byBjb3B5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29waWVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlPYmplY3Qoc291cmNlLCBwcm9wcywgb2JqZWN0LCBjdXN0b21pemVyKSB7XG4gIHZhciBpc05ldyA9ICFvYmplY3Q7XG4gIG9iamVjdCB8fCAob2JqZWN0ID0ge30pO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcblxuICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgID8gY3VzdG9taXplcihvYmplY3Rba2V5XSwgc291cmNlW2tleV0sIGtleSwgb2JqZWN0LCBzb3VyY2UpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBuZXdWYWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgICBpZiAoaXNOZXcpIHtcbiAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqZWN0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlPYmplY3Q7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IGl0IHJlY2VpdmVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICpcbiAqIGNvbnNvbGUubG9nKF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlkZW50aXR5O1xuIiwiLyoqXG4gKiBBIGZhc3RlciBhbHRlcm5hdGl2ZSB0byBgRnVuY3Rpb24jYXBwbHlgLCB0aGlzIGZ1bmN0aW9uIGludm9rZXMgYGZ1bmNgXG4gKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2AgYW5kIHRoZSBhcmd1bWVudHMgb2YgYGFyZ3NgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGBmdW5jYC5cbiAqL1xuZnVuY3Rpb24gYXBwbHkoZnVuYywgdGhpc0FyZywgYXJncykge1xuICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcpO1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICB9XG4gIHJldHVybiBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFwcGx5O1xuIiwidmFyIGFwcGx5ID0gcmVxdWlyZSgnLi9fYXBwbHknKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIHRyYW5zZm9ybXMgdGhlIHJlc3QgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIHJlc3QgYXJyYXkgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCB0cmFuc2Zvcm0pIHtcbiAgc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQgPT09IHVuZGVmaW5lZCA/IChmdW5jLmxlbmd0aCAtIDEpIDogc3RhcnQsIDApO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIHN0YXJ0LCAwKSxcbiAgICAgICAgYXJyYXkgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGFycmF5W2luZGV4XSA9IGFyZ3Nbc3RhcnQgKyBpbmRleF07XG4gICAgfVxuICAgIGluZGV4ID0gLTE7XG4gICAgdmFyIG90aGVyQXJncyA9IEFycmF5KHN0YXJ0ICsgMSk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBzdGFydCkge1xuICAgICAgb3RoZXJBcmdzW2luZGV4XSA9IGFyZ3NbaW5kZXhdO1xuICAgIH1cbiAgICBvdGhlckFyZ3Nbc3RhcnRdID0gdHJhbnNmb3JtKGFycmF5KTtcbiAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgb3RoZXJBcmdzKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvdmVyUmVzdDtcbiIsIi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgdmFsdWVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4gZnJvbSB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29uc3RhbnQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gXy50aW1lcygyLCBfLmNvbnN0YW50KHsgJ2EnOiAxIH0pKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhvYmplY3RzKTtcbiAqIC8vID0+IFt7ICdhJzogMSB9LCB7ICdhJzogMSB9XVxuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHNbMF0gPT09IG9iamVjdHNbMV0pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBjb25zdGFudCh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnN0YW50O1xuIiwidmFyIGNvbnN0YW50ID0gcmVxdWlyZSgnLi9jb25zdGFudCcpLFxuICAgIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fZGVmaW5lUHJvcGVydHknKSxcbiAgICBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgc2V0VG9TdHJpbmdgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaG90IGxvb3Agc2hvcnRpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovXG52YXIgYmFzZVNldFRvU3RyaW5nID0gIWRlZmluZVByb3BlcnR5ID8gaWRlbnRpdHkgOiBmdW5jdGlvbihmdW5jLCBzdHJpbmcpIHtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5KGZ1bmMsICd0b1N0cmluZycsIHtcbiAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAnZW51bWVyYWJsZSc6IGZhbHNlLFxuICAgICd2YWx1ZSc6IGNvbnN0YW50KHN0cmluZyksXG4gICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVNldFRvU3RyaW5nO1xuIiwiLyoqIFVzZWQgdG8gZGV0ZWN0IGhvdCBmdW5jdGlvbnMgYnkgbnVtYmVyIG9mIGNhbGxzIHdpdGhpbiBhIHNwYW4gb2YgbWlsbGlzZWNvbmRzLiAqL1xudmFyIEhPVF9DT1VOVCA9IDgwMCxcbiAgICBIT1RfU1BBTiA9IDE2O1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTm93ID0gRGF0ZS5ub3c7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQnbGwgc2hvcnQgb3V0IGFuZCBpbnZva2UgYGlkZW50aXR5YCBpbnN0ZWFkXG4gKiBvZiBgZnVuY2Agd2hlbiBpdCdzIGNhbGxlZCBgSE9UX0NPVU5UYCBvciBtb3JlIHRpbWVzIGluIGBIT1RfU1BBTmBcbiAqIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzaG9ydGFibGUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHNob3J0T3V0KGZ1bmMpIHtcbiAgdmFyIGNvdW50ID0gMCxcbiAgICAgIGxhc3RDYWxsZWQgPSAwO1xuXG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RhbXAgPSBuYXRpdmVOb3coKSxcbiAgICAgICAgcmVtYWluaW5nID0gSE9UX1NQQU4gLSAoc3RhbXAgLSBsYXN0Q2FsbGVkKTtcblxuICAgIGxhc3RDYWxsZWQgPSBzdGFtcDtcbiAgICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgICAgaWYgKCsrY291bnQgPj0gSE9UX0NPVU5UKSB7XG4gICAgICAgIHJldHVybiBhcmd1bWVudHNbMF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvdW50ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3J0T3V0O1xuIiwidmFyIGJhc2VTZXRUb1N0cmluZyA9IHJlcXVpcmUoJy4vX2Jhc2VTZXRUb1N0cmluZycpLFxuICAgIHNob3J0T3V0ID0gcmVxdWlyZSgnLi9fc2hvcnRPdXQnKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBgdG9TdHJpbmdgIG1ldGhvZCBvZiBgZnVuY2AgdG8gcmV0dXJuIGBzdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIHNldFRvU3RyaW5nID0gc2hvcnRPdXQoYmFzZVNldFRvU3RyaW5nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBzZXRUb1N0cmluZztcbiIsInZhciBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKSxcbiAgICBvdmVyUmVzdCA9IHJlcXVpcmUoJy4vX292ZXJSZXN0JyksXG4gICAgc2V0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19zZXRUb1N0cmluZycpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlc3RgIHdoaWNoIGRvZXNuJ3QgdmFsaWRhdGUgb3IgY29lcmNlIGFyZ3VtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUmVzdChmdW5jLCBzdGFydCkge1xuICByZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYywgc3RhcnQsIGlkZW50aXR5KSwgZnVuYyArICcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUmVzdDtcbiIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0xlbmd0aDtcbiIsInZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXlMaWtlO1xuIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG5cbiAgcmV0dXJuICEhbGVuZ3RoICYmXG4gICAgKHR5cGUgPT0gJ251bWJlcicgfHxcbiAgICAgICh0eXBlICE9ICdzeW1ib2wnICYmIHJlSXNVaW50LnRlc3QodmFsdWUpKSkgJiZcbiAgICAgICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzSW5kZXg7XG4iLCJ2YXIgZXEgPSByZXF1aXJlKCcuL2VxJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgdmFsdWUgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IGluZGV4IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgaW5kZXggb3Iga2V5IGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBvYmplY3QgYXJndW1lbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIGluZGV4O1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJ1xuICAgICAgICA/IChpc0FycmF5TGlrZShvYmplY3QpICYmIGlzSW5kZXgoaW5kZXgsIG9iamVjdC5sZW5ndGgpKVxuICAgICAgICA6ICh0eXBlID09ICdzdHJpbmcnICYmIGluZGV4IGluIG9iamVjdClcbiAgICAgICkge1xuICAgIHJldHVybiBlcShvYmplY3RbaW5kZXhdLCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzSXRlcmF0ZWVDYWxsO1xuIiwidmFyIGJhc2VSZXN0ID0gcmVxdWlyZSgnLi9fYmFzZVJlc3QnKSxcbiAgICBpc0l0ZXJhdGVlQ2FsbCA9IHJlcXVpcmUoJy4vX2lzSXRlcmF0ZWVDYWxsJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uYXNzaWduYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gYXNzaWduZXIgVGhlIGZ1bmN0aW9uIHRvIGFzc2lnbiB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhc3NpZ25lciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQXNzaWduZXIoYXNzaWduZXIpIHtcbiAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwgc291cmNlcykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBzb3VyY2VzLmxlbmd0aCxcbiAgICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA+IDEgPyBzb3VyY2VzW2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkLFxuICAgICAgICBndWFyZCA9IGxlbmd0aCA+IDIgPyBzb3VyY2VzWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgY3VzdG9taXplciA9IChhc3NpZ25lci5sZW5ndGggPiAzICYmIHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicpXG4gICAgICA/IChsZW5ndGgtLSwgY3VzdG9taXplcilcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiBjdXN0b21pemVyO1xuICAgICAgbGVuZ3RoID0gMTtcbiAgICB9XG4gICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgYXNzaWduZXIob2JqZWN0LCBzb3VyY2UsIGluZGV4LCBjdXN0b21pemVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQXNzaWduZXI7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VUaW1lcztcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0TGlrZTtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqL1xuZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzQXJndW1lbnRzO1xuIiwidmFyIGJhc2VJc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vX2Jhc2VJc0FyZ3VtZW50cycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA/IGJhc2VJc0FyZ3VtZW50cyA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJndW1lbnRzO1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8uc3R1YkZhbHNlKTtcbiAqIC8vID0+IFtmYWxzZSwgZmFsc2VdXG4gKi9cbmZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0dWJGYWxzZTtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpLFxuICAgIHN0dWJGYWxzZSA9IHJlcXVpcmUoJy4vc3R1YkZhbHNlJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0J1ZmZlcjtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xudHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG50eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG50eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG50eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG50eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG50eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG50eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNUeXBlZEFycmF5O1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VVbmFyeTtcbiIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTtcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gbm9kZVV0aWw7XG4iLCJ2YXIgYmFzZUlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vX2Jhc2VJc1R5cGVkQXJyYXknKSxcbiAgICBiYXNlVW5hcnkgPSByZXF1aXJlKCcuL19iYXNlVW5hcnknKSxcbiAgICBub2RlVXRpbCA9IHJlcXVpcmUoJy4vX25vZGVVdGlsJyk7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVHlwZWRBcnJheTtcbiIsInZhciBiYXNlVGltZXMgPSByZXF1aXJlKCcuL19iYXNlVGltZXMnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzVHlwZWRBcnJheScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksXG4gICAgICBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50cyh2YWx1ZSksXG4gICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyKHZhbHVlKSxcbiAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLFxuICAgICAgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLFxuICAgICAgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxuICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XG4gICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbiAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcbiAgICAgICAgKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlMaWtlS2V5cztcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1Byb3RvdHlwZTtcbiIsIi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlXG4gKiBbYE9iamVjdC5rZXlzYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBleGNlcHQgdGhhdCBpdCBpbmNsdWRlcyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBuYXRpdmVLZXlzSW4ob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUtleXNJbjtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBpc1Byb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2lzUHJvdG90eXBlJyksXG4gICAgbmF0aXZlS2V5c0luID0gcmVxdWlyZSgnLi9fbmF0aXZlS2V5c0luJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c0luYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzSW4ob2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzSW4ob2JqZWN0KTtcbiAgfVxuICB2YXIgaXNQcm90byA9IGlzUHJvdG90eXBlKG9iamVjdCksXG4gICAgICByZXN1bHQgPSBbXTtcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKCEoa2V5ID09ICdjb25zdHJ1Y3RvcicgJiYgKGlzUHJvdG8gfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUtleXNJbjtcbiIsInZhciBhcnJheUxpa2VLZXlzID0gcmVxdWlyZSgnLi9fYXJyYXlMaWtlS2V5cycpLFxuICAgIGJhc2VLZXlzSW4gPSByZXF1aXJlKCcuL19iYXNlS2V5c0luJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXNJbihuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJywgJ2MnXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICovXG5mdW5jdGlvbiBrZXlzSW4ob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QsIHRydWUpIDogYmFzZUtleXNJbihvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXNJbjtcbiIsInZhciBjb3B5T2JqZWN0ID0gcmVxdWlyZSgnLi9fY29weU9iamVjdCcpLFxuICAgIGNyZWF0ZUFzc2lnbmVyID0gcmVxdWlyZSgnLi9fY3JlYXRlQXNzaWduZXInKSxcbiAgICBrZXlzSW4gPSByZXF1aXJlKCcuL2tleXNJbicpO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYXNzaWduYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIG93biBhbmRcbiAqIGluaGVyaXRlZCBzb3VyY2UgcHJvcGVydGllcy5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAYWxpYXMgZXh0ZW5kXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKiBAc2VlIF8uYXNzaWduXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqIH1cbiAqXG4gKiBmdW5jdGlvbiBCYXIoKSB7XG4gKiAgIHRoaXMuYyA9IDM7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5iID0gMjtcbiAqIEJhci5wcm90b3R5cGUuZCA9IDQ7XG4gKlxuICogXy5hc3NpZ25Jbih7ICdhJzogMCB9LCBuZXcgRm9vLCBuZXcgQmFyKTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMywgJ2QnOiA0IH1cbiAqL1xudmFyIGFzc2lnbkluID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UpIHtcbiAgY29weU9iamVjdChzb3VyY2UsIGtleXNJbihzb3VyY2UpLCBvYmplY3QpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzaWduSW47XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vYXNzaWduSW4nKTtcbiIsIi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVDbGVhcjtcbiIsInZhciBlcSA9IHJlcXVpcmUoJy4vZXEnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NvY0luZGV4T2Y7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZTtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgIGRhdGEucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICB9XG4gIC0tdGhpcy5zaXplO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVEZWxldGU7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlR2V0O1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVIYXM7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgKyt0aGlzLnNpemU7XG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVTZXQ7XG4iLCJ2YXIgbGlzdENhY2hlQ2xlYXIgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVDbGVhcicpLFxuICAgIGxpc3RDYWNoZURlbGV0ZSA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZURlbGV0ZScpLFxuICAgIGxpc3RDYWNoZUdldCA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUdldCcpLFxuICAgIGxpc3RDYWNoZUhhcyA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUhhcycpLFxuICAgIGxpc3RDYWNoZVNldCA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZVNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbkxpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gTGlzdENhY2hlO1xuIiwidmFyIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIFN0YWNrXG4gKi9cbmZ1bmN0aW9uIHN0YWNrQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrQ2xlYXI7XG4iLCIvKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0RlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgcmVzdWx0ID0gZGF0YVsnZGVsZXRlJ10oa2V5KTtcblxuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tEZWxldGU7XG4iLCIvKipcbiAqIEdldHMgdGhlIHN0YWNrIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzdGFja0dldChrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tHZXQ7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBhIHN0YWNrIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tIYXMoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrSGFzO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcDtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVDcmVhdGU7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hDbGVhcjtcbiIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaERlbGV0ZTtcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hHZXQ7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gKGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoSGFzO1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhrZXkpID8gMCA6IDE7XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoU2V0O1xuIiwidmFyIGhhc2hDbGVhciA9IHJlcXVpcmUoJy4vX2hhc2hDbGVhcicpLFxuICAgIGhhc2hEZWxldGUgPSByZXF1aXJlKCcuL19oYXNoRGVsZXRlJyksXG4gICAgaGFzaEdldCA9IHJlcXVpcmUoJy4vX2hhc2hHZXQnKSxcbiAgICBoYXNoSGFzID0gcmVxdWlyZSgnLi9faGFzaEhhcycpLFxuICAgIGhhc2hTZXQgPSByZXF1aXJlKCcuL19oYXNoU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhhc2g7XG4iLCJ2YXIgSGFzaCA9IHJlcXVpcmUoJy4vX0hhc2gnKSxcbiAgICBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKSxcbiAgICBNYXAgPSByZXF1aXJlKCcuL19NYXAnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgdGhpcy5zaXplID0gMDtcbiAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpLFxuICAgICdzdHJpbmcnOiBuZXcgSGFzaFxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlQ2xlYXI7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nKVxuICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNLZXlhYmxlO1xuIiwidmFyIGlzS2V5YWJsZSA9IHJlcXVpcmUoJy4vX2lzS2V5YWJsZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TWFwRGF0YTtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZURlbGV0ZTtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVHZXQ7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUhhcztcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVTZXQ7XG4iLCJ2YXIgbWFwQ2FjaGVDbGVhciA9IHJlcXVpcmUoJy4vX21hcENhY2hlQ2xlYXInKSxcbiAgICBtYXBDYWNoZURlbGV0ZSA9IHJlcXVpcmUoJy4vX21hcENhY2hlRGVsZXRlJyksXG4gICAgbWFwQ2FjaGVHZXQgPSByZXF1aXJlKCcuL19tYXBDYWNoZUdldCcpLFxuICAgIG1hcENhY2hlSGFzID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVIYXMnKSxcbiAgICBtYXBDYWNoZVNldCA9IHJlcXVpcmUoJy4vX21hcENhY2hlU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5NYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcENhY2hlO1xuIiwidmFyIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpLFxuICAgIE1hcENhY2hlID0gcmVxdWlyZSgnLi9fTWFwQ2FjaGUnKTtcblxuLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG52YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuLyoqXG4gKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBzdGFjayBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgTGlzdENhY2hlKSB7XG4gICAgdmFyIHBhaXJzID0gZGF0YS5fX2RhdGFfXztcbiAgICBpZiAoIU1hcCB8fCAocGFpcnMubGVuZ3RoIDwgTEFSR0VfQVJSQVlfU0laRSAtIDEpKSB7XG4gICAgICBwYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICB0aGlzLnNpemUgPSArK2RhdGEuc2l6ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZShwYWlycyk7XG4gIH1cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tTZXQ7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgc3RhY2tDbGVhciA9IHJlcXVpcmUoJy4vX3N0YWNrQ2xlYXInKSxcbiAgICBzdGFja0RlbGV0ZSA9IHJlcXVpcmUoJy4vX3N0YWNrRGVsZXRlJyksXG4gICAgc3RhY2tHZXQgPSByZXF1aXJlKCcuL19zdGFja0dldCcpLFxuICAgIHN0YWNrSGFzID0gcmVxdWlyZSgnLi9fc3RhY2tIYXMnKSxcbiAgICBzdGFja1NldCA9IHJlcXVpcmUoJy4vX3N0YWNrU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFN0YWNrKGVudHJpZXMpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZShlbnRyaWVzKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxuU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcblN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcblN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcblN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcblN0YWNrLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcblxubW9kdWxlLmV4cG9ydHMgPSBTdGFjaztcbiIsInZhciBiYXNlQXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19iYXNlQXNzaWduVmFsdWUnKSxcbiAgICBlcSA9IHJlcXVpcmUoJy4vZXEnKTtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGFzc2lnblZhbHVlYCBleGNlcHQgdGhhdCBpdCBkb2Vzbid0IGFzc2lnblxuICogYHVuZGVmaW5lZGAgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIGlmICgodmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZXEob2JqZWN0W2tleV0sIHZhbHVlKSkgfHxcbiAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NpZ25NZXJnZVZhbHVlO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgYmFzZSBmdW5jdGlvbiBmb3IgbWV0aG9kcyBsaWtlIGBfLmZvckluYCBhbmQgYF8uZm9yT3duYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVCYXNlRm9yKGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSwga2V5c0Z1bmMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgaXRlcmFibGUgPSBPYmplY3Qob2JqZWN0KSxcbiAgICAgICAgcHJvcHMgPSBrZXlzRnVuYyhvYmplY3QpLFxuICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wc1tmcm9tUmlnaHQgPyBsZW5ndGggOiArK2luZGV4XTtcbiAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQmFzZUZvcjtcbiIsInZhciBjcmVhdGVCYXNlRm9yID0gcmVxdWlyZSgnLi9fY3JlYXRlQmFzZUZvcicpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBiYXNlRm9yT3duYCB3aGljaCBpdGVyYXRlcyBvdmVyIGBvYmplY3RgXG4gKiBwcm9wZXJ0aWVzIHJldHVybmVkIGJ5IGBrZXlzRnVuY2AgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xudmFyIGJhc2VGb3IgPSBjcmVhdGVCYXNlRm9yKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZvcjtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICBhbGxvY1Vuc2FmZSA9IEJ1ZmZlciA/IEJ1ZmZlci5hbGxvY1Vuc2FmZSA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgIGBidWZmZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIFRoZSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge0J1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY2xvbmVCdWZmZXIoYnVmZmVyLCBpc0RlZXApIHtcbiAgaWYgKGlzRGVlcCkge1xuICAgIHJldHVybiBidWZmZXIuc2xpY2UoKTtcbiAgfVxuICB2YXIgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGFsbG9jVW5zYWZlID8gYWxsb2NVbnNhZmUobGVuZ3RoKSA6IG5ldyBidWZmZXIuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICBidWZmZXIuY29weShyZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lQnVmZmVyO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFVpbnQ4QXJyYXkgPSByb290LlVpbnQ4QXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gVWludDhBcnJheTtcbiIsInZhciBVaW50OEFycmF5ID0gcmVxdWlyZSgnLi9fVWludDhBcnJheScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgYXJyYXlCdWZmZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBhcnJheUJ1ZmZlciBUaGUgYXJyYXkgYnVmZmVyIHRvIGNsb25lLlxuICogQHJldHVybnMge0FycmF5QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYXJyYXkgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBjbG9uZUFycmF5QnVmZmVyKGFycmF5QnVmZmVyKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgYXJyYXlCdWZmZXIuY29uc3RydWN0b3IoYXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCk7XG4gIG5ldyBVaW50OEFycmF5KHJlc3VsdCkuc2V0KG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVBcnJheUJ1ZmZlcjtcbiIsInZhciBjbG9uZUFycmF5QnVmZmVyID0gcmVxdWlyZSgnLi9fY2xvbmVBcnJheUJ1ZmZlcicpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgdHlwZWRBcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlZEFycmF5IFRoZSB0eXBlZCBhcnJheSB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgdHlwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNsb25lVHlwZWRBcnJheSh0eXBlZEFycmF5LCBpc0RlZXApIHtcbiAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIodHlwZWRBcnJheS5idWZmZXIpIDogdHlwZWRBcnJheS5idWZmZXI7XG4gIHJldHVybiBuZXcgdHlwZWRBcnJheS5jb25zdHJ1Y3RvcihidWZmZXIsIHR5cGVkQXJyYXkuYnl0ZU9mZnNldCwgdHlwZWRBcnJheS5sZW5ndGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lVHlwZWRBcnJheTtcbiIsIi8qKlxuICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgYHNvdXJjZWAgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgdG8uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gY29weUFycmF5KHNvdXJjZSwgYXJyYXkpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuXG4gIGFycmF5IHx8IChhcnJheSA9IEFycmF5KGxlbmd0aCkpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlBcnJheTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jcmVhdGVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXNzaWduaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xudmFyIGJhc2VDcmVhdGUgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIG9iamVjdCgpIHt9XG4gIHJldHVybiBmdW5jdGlvbihwcm90bykge1xuICAgIGlmICghaXNPYmplY3QocHJvdG8pKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGlmIChvYmplY3RDcmVhdGUpIHtcbiAgICAgIHJldHVybiBvYmplY3RDcmVhdGUocHJvdG8pO1xuICAgIH1cbiAgICBvYmplY3QucHJvdG90eXBlID0gcHJvdG87XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBvYmplY3Q7XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQ3JlYXRlO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlckFyZztcbiIsInZhciBvdmVyQXJnID0gcmVxdWlyZSgnLi9fb3ZlckFyZycpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBnZXRQcm90b3R5cGUgPSBvdmVyQXJnKE9iamVjdC5nZXRQcm90b3R5cGVPZiwgT2JqZWN0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRQcm90b3R5cGU7XG4iLCJ2YXIgYmFzZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX2Jhc2VDcmVhdGUnKSxcbiAgICBnZXRQcm90b3R5cGUgPSByZXF1aXJlKCcuL19nZXRQcm90b3R5cGUnKSxcbiAgICBpc1Byb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2lzUHJvdG90eXBlJyk7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lT2JqZWN0KG9iamVjdCkge1xuICByZXR1cm4gKHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNQcm90b3R5cGUob2JqZWN0KSlcbiAgICA/IGJhc2VDcmVhdGUoZ2V0UHJvdG90eXBlKG9iamVjdCkpXG4gICAgOiB7fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbml0Q2xvbmVPYmplY3Q7XG4iLCJ2YXIgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmlzQXJyYXlMaWtlYCBleGNlcHQgdGhhdCBpdCBhbHNvIGNoZWNrcyBpZiBgdmFsdWVgXG4gKiBpcyBhbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXktbGlrZSBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNBcnJheUxpa2UodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXlMaWtlT2JqZWN0O1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgZ2V0UHJvdG90eXBlID0gcmVxdWlyZSgnLi9fZ2V0UHJvdG90eXBlJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gaW5mZXIgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yLiAqL1xudmFyIG9iamVjdEN0b3JTdHJpbmcgPSBmdW5jVG9TdHJpbmcuY2FsbChPYmplY3QpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGF0IGlzLCBhbiBvYmplY3QgY3JlYXRlZCBieSB0aGVcbiAqIGBPYmplY3RgIGNvbnN0cnVjdG9yIG9yIG9uZSB3aXRoIGEgYFtbUHJvdG90eXBlXV1gIG9mIGBudWxsYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuOC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiB9XG4gKlxuICogXy5pc1BsYWluT2JqZWN0KG5ldyBGb28pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KHsgJ3gnOiAwLCAneSc6IDAgfSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3RMaWtlKHZhbHVlKSB8fCBiYXNlR2V0VGFnKHZhbHVlKSAhPSBvYmplY3RUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHByb3RvID0gZ2V0UHJvdG90eXBlKHZhbHVlKTtcbiAgaWYgKHByb3RvID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIEN0b3IgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCAnY29uc3RydWN0b3InKSAmJiBwcm90by5jb25zdHJ1Y3RvcjtcbiAgcmV0dXJuIHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3RvciBpbnN0YW5jZW9mIEN0b3IgJiZcbiAgICBmdW5jVG9TdHJpbmcuY2FsbChDdG9yKSA9PSBvYmplY3RDdG9yU3RyaW5nO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUGxhaW5PYmplY3Q7XG4iLCIvKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgLCB1bmxlc3MgYGtleWAgaXMgXCJfX3Byb3RvX19cIi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHNhZmVHZXQob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIGtleSA9PSAnX19wcm90b19fJ1xuICAgID8gdW5kZWZpbmVkXG4gICAgOiBvYmplY3Rba2V5XTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzYWZlR2V0O1xuIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAga2V5c0luID0gcmVxdWlyZSgnLi9rZXlzSW4nKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgcGxhaW4gb2JqZWN0IGZsYXR0ZW5pbmcgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nXG4gKiBrZXllZCBwcm9wZXJ0aWVzIG9mIGB2YWx1ZWAgdG8gb3duIHByb3BlcnRpZXMgb2YgdGhlIHBsYWluIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBwbGFpbiBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIG5ldyBGb28pO1xuICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gKlxuICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgXy50b1BsYWluT2JqZWN0KG5ldyBGb28pKTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9XG4gKi9cbmZ1bmN0aW9uIHRvUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGNvcHlPYmplY3QodmFsdWUsIGtleXNJbih2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvUGxhaW5PYmplY3Q7XG4iLCJ2YXIgYXNzaWduTWVyZ2VWYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnbk1lcmdlVmFsdWUnKSxcbiAgICBjbG9uZUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQnVmZmVyJyksXG4gICAgY2xvbmVUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9fY2xvbmVUeXBlZEFycmF5JyksXG4gICAgY29weUFycmF5ID0gcmVxdWlyZSgnLi9fY29weUFycmF5JyksXG4gICAgaW5pdENsb25lT2JqZWN0ID0gcmVxdWlyZSgnLi9faW5pdENsb25lT2JqZWN0JyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQXJyYXlMaWtlT2JqZWN0ID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZU9iamVjdCcpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2lzRnVuY3Rpb24nKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBpc1BsYWluT2JqZWN0ID0gcmVxdWlyZSgnLi9pc1BsYWluT2JqZWN0JyksXG4gICAgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9pc1R5cGVkQXJyYXknKSxcbiAgICBzYWZlR2V0ID0gcmVxdWlyZSgnLi9fc2FmZUdldCcpLFxuICAgIHRvUGxhaW5PYmplY3QgPSByZXF1aXJlKCcuL3RvUGxhaW5PYmplY3QnKTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VNZXJnZWAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICogZGVlcCBtZXJnZXMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAqIHJlZmVyZW5jZXMgdG8gYmUgbWVyZ2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBtZXJnZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzcmNJbmRleCBUaGUgaW5kZXggb2YgYHNvdXJjZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXJnZUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1lcmdlIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkXG4gKiAgY291bnRlcnBhcnRzLlxuICovXG5mdW5jdGlvbiBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIHNyY0luZGV4LCBtZXJnZUZ1bmMsIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIHZhciBvYmpWYWx1ZSA9IHNhZmVHZXQob2JqZWN0LCBrZXkpLFxuICAgICAgc3JjVmFsdWUgPSBzYWZlR2V0KHNvdXJjZSwga2V5KSxcbiAgICAgIHN0YWNrZWQgPSBzdGFjay5nZXQoc3JjVmFsdWUpO1xuXG4gIGlmIChzdGFja2VkKSB7XG4gICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgc3RhY2tlZCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCAoa2V5ICsgJycpLCBvYmplY3QsIHNvdXJjZSwgc3RhY2spXG4gICAgOiB1bmRlZmluZWQ7XG5cbiAgdmFyIGlzQ29tbW9uID0gbmV3VmFsdWUgPT09IHVuZGVmaW5lZDtcblxuICBpZiAoaXNDb21tb24pIHtcbiAgICB2YXIgaXNBcnIgPSBpc0FycmF5KHNyY1ZhbHVlKSxcbiAgICAgICAgaXNCdWZmID0gIWlzQXJyICYmIGlzQnVmZmVyKHNyY1ZhbHVlKSxcbiAgICAgICAgaXNUeXBlZCA9ICFpc0FyciAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheShzcmNWYWx1ZSk7XG5cbiAgICBuZXdWYWx1ZSA9IHNyY1ZhbHVlO1xuICAgIGlmIChpc0FyciB8fCBpc0J1ZmYgfHwgaXNUeXBlZCkge1xuICAgICAgaWYgKGlzQXJyYXkob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gb2JqVmFsdWU7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc0FycmF5TGlrZU9iamVjdChvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBjb3B5QXJyYXkob2JqVmFsdWUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNCdWZmKSB7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIG5ld1ZhbHVlID0gY2xvbmVCdWZmZXIoc3JjVmFsdWUsIHRydWUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNUeXBlZCkge1xuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICBuZXdWYWx1ZSA9IGNsb25lVHlwZWRBcnJheShzcmNWYWx1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbmV3VmFsdWUgPSBbXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNQbGFpbk9iamVjdChzcmNWYWx1ZSkgfHwgaXNBcmd1bWVudHMoc3JjVmFsdWUpKSB7XG4gICAgICBuZXdWYWx1ZSA9IG9ialZhbHVlO1xuICAgICAgaWYgKGlzQXJndW1lbnRzKG9ialZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IHRvUGxhaW5PYmplY3Qob2JqVmFsdWUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoIWlzT2JqZWN0KG9ialZhbHVlKSB8fCAoc3JjSW5kZXggJiYgaXNGdW5jdGlvbihvYmpWYWx1ZSkpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gaW5pdENsb25lT2JqZWN0KHNyY1ZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAoaXNDb21tb24pIHtcbiAgICAvLyBSZWN1cnNpdmVseSBtZXJnZSBvYmplY3RzIGFuZCBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBzdGFjay5zZXQoc3JjVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICBtZXJnZUZ1bmMobmV3VmFsdWUsIHNyY1ZhbHVlLCBzcmNJbmRleCwgY3VzdG9taXplciwgc3RhY2spO1xuICAgIHN0YWNrWydkZWxldGUnXShzcmNWYWx1ZSk7XG4gIH1cbiAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNZXJnZURlZXA7XG4iLCJ2YXIgU3RhY2sgPSByZXF1aXJlKCcuL19TdGFjaycpLFxuICAgIGFzc2lnbk1lcmdlVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25NZXJnZVZhbHVlJyksXG4gICAgYmFzZUZvciA9IHJlcXVpcmUoJy4vX2Jhc2VGb3InKSxcbiAgICBiYXNlTWVyZ2VEZWVwID0gcmVxdWlyZSgnLi9fYmFzZU1lcmdlRGVlcCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGtleXNJbiA9IHJlcXVpcmUoJy4va2V5c0luJyksXG4gICAgc2FmZUdldCA9IHJlcXVpcmUoJy4vX3NhZmVHZXQnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tZXJnZWAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtudW1iZXJ9IHNyY0luZGV4IFRoZSBpbmRleCBvZiBgc291cmNlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIG1lcmdlZCB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICogIGNvdW50ZXJwYXJ0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplciwgc3RhY2spIHtcbiAgaWYgKG9iamVjdCA9PT0gc291cmNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGJhc2VGb3Ioc291cmNlLCBmdW5jdGlvbihzcmNWYWx1ZSwga2V5KSB7XG4gICAgaWYgKGlzT2JqZWN0KHNyY1ZhbHVlKSkge1xuICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIGJhc2VNZXJnZSwgY3VzdG9taXplciwgc3RhY2spO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgICAgPyBjdXN0b21pemVyKHNhZmVHZXQob2JqZWN0LCBrZXkpLCBzcmNWYWx1ZSwgKGtleSArICcnKSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKVxuICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBzcmNWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH0sIGtleXNJbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1lcmdlO1xuIiwidmFyIGJhc2VNZXJnZSA9IHJlcXVpcmUoJy4vX2Jhc2VNZXJnZScpLFxuICAgIGNyZWF0ZUFzc2lnbmVyID0gcmVxdWlyZSgnLi9fY3JlYXRlQXNzaWduZXInKTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbmAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgbWVyZ2VzIG93biBhbmRcbiAqIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3RzIGludG8gdGhlXG4gKiBkZXN0aW5hdGlvbiBvYmplY3QuIFNvdXJjZSBwcm9wZXJ0aWVzIHRoYXQgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYCBhcmVcbiAqIHNraXBwZWQgaWYgYSBkZXN0aW5hdGlvbiB2YWx1ZSBleGlzdHMuIEFycmF5IGFuZCBwbGFpbiBvYmplY3QgcHJvcGVydGllc1xuICogYXJlIG1lcmdlZCByZWN1cnNpdmVseS4gT3RoZXIgb2JqZWN0cyBhbmQgdmFsdWUgdHlwZXMgYXJlIG92ZXJyaWRkZW4gYnlcbiAqIGFzc2lnbm1lbnQuIFNvdXJjZSBvYmplY3RzIGFyZSBhcHBsaWVkIGZyb20gbGVmdCB0byByaWdodC4gU3Vic2VxdWVudFxuICogc291cmNlcyBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgc291cmNlcy5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuNS4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7XG4gKiAgICdhJzogW3sgJ2InOiAyIH0sIHsgJ2QnOiA0IH1dXG4gKiB9O1xuICpcbiAqIHZhciBvdGhlciA9IHtcbiAqICAgJ2EnOiBbeyAnYyc6IDMgfSwgeyAnZSc6IDUgfV1cbiAqIH07XG4gKlxuICogXy5tZXJnZShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IHsgJ2EnOiBbeyAnYic6IDIsICdjJzogMyB9LCB7ICdkJzogNCwgJ2UnOiA1IH1dIH1cbiAqL1xudmFyIG1lcmdlID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4KSB7XG4gIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gbWVyZ2U7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlFYWNoKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSA9PT0gZmFsc2UpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlFYWNoO1xuIiwidmFyIG92ZXJBcmcgPSByZXF1aXJlKCcuL19vdmVyQXJnJyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVLZXlzO1xuIiwidmFyIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKSxcbiAgICBuYXRpdmVLZXlzID0gcmVxdWlyZSgnLi9fbmF0aXZlS2V5cycpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNgIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXMob2JqZWN0KSB7XG4gIGlmICghaXNQcm90b3R5cGUob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYga2V5ICE9ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUtleXM7XG4iLCJ2YXIgYXJyYXlMaWtlS2V5cyA9IHJlcXVpcmUoJy4vX2FycmF5TGlrZUtleXMnKSxcbiAgICBiYXNlS2V5cyA9IHJlcXVpcmUoJy4vX2Jhc2VLZXlzJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8ua2V5cygnaGknKTtcbiAqIC8vID0+IFsnMCcsICcxJ11cbiAqL1xuZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXM7XG4iLCJ2YXIgYmFzZUZvciA9IHJlcXVpcmUoJy4vX2Jhc2VGb3InKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yT3duYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUZvck93bihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gIHJldHVybiBvYmplY3QgJiYgYmFzZUZvcihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRm9yT3duO1xuIiwidmFyIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBgYmFzZUVhY2hgIG9yIGBiYXNlRWFjaFJpZ2h0YCBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBhIGNvbGxlY3Rpb24uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VFYWNoKGVhY2hGdW5jLCBmcm9tUmlnaHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgfVxuICAgIGlmICghaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBlYWNoRnVuYyhjb2xsZWN0aW9uLCBpdGVyYXRlZSk7XG4gICAgfVxuICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aCxcbiAgICAgICAgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMSxcbiAgICAgICAgaXRlcmFibGUgPSBPYmplY3QoY29sbGVjdGlvbik7XG5cbiAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2luZGV4XSwgaW5kZXgsIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUJhc2VFYWNoO1xuIiwidmFyIGJhc2VGb3JPd24gPSByZXF1aXJlKCcuL19iYXNlRm9yT3duJyksXG4gICAgY3JlYXRlQmFzZUVhY2ggPSByZXF1aXJlKCcuL19jcmVhdGVCYXNlRWFjaCcpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckVhY2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICovXG52YXIgYmFzZUVhY2ggPSBjcmVhdGVCYXNlRWFjaChiYXNlRm9yT3duKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRWFjaDtcbiIsInZhciBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKTtcblxuLyoqXG4gKiBDYXN0cyBgdmFsdWVgIHRvIGBpZGVudGl0eWAgaWYgaXQncyBub3QgYSBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBjYXN0IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjYXN0RnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nID8gdmFsdWUgOiBpZGVudGl0eTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYXN0RnVuY3Rpb247XG4iLCJ2YXIgYXJyYXlFYWNoID0gcmVxdWlyZSgnLi9fYXJyYXlFYWNoJyksXG4gICAgYmFzZUVhY2ggPSByZXF1aXJlKCcuL19iYXNlRWFjaCcpLFxuICAgIGNhc3RGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2Nhc3RGdW5jdGlvbicpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqXG4gKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIGVsZW1lbnQuXG4gKiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICpcbiAqICoqTm90ZToqKiBBcyB3aXRoIG90aGVyIFwiQ29sbGVjdGlvbnNcIiBtZXRob2RzLCBvYmplY3RzIHdpdGggYSBcImxlbmd0aFwiXG4gKiBwcm9wZXJ0eSBhcmUgaXRlcmF0ZWQgbGlrZSBhcnJheXMuIFRvIGF2b2lkIHRoaXMgYmVoYXZpb3IgdXNlIGBfLmZvckluYFxuICogb3IgYF8uZm9yT3duYCBmb3Igb2JqZWN0IGl0ZXJhdGlvbi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAYWxpYXMgZWFjaFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gKiBAc2VlIF8uZm9yRWFjaFJpZ2h0XG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZm9yRWFjaChbMSwgMl0sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gKiAgIGNvbnNvbGUubG9nKHZhbHVlKTtcbiAqIH0pO1xuICogLy8gPT4gTG9ncyBgMWAgdGhlbiBgMmAuXG4gKlxuICogXy5mb3JFYWNoKHsgJ2EnOiAxLCAnYic6IDIgfSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICogICBjb25zb2xlLmxvZyhrZXkpO1xuICogfSk7XG4gKiAvLyA9PiBMb2dzICdhJyB0aGVuICdiJyAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKS5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUVhY2ggOiBiYXNlRWFjaDtcbiAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgY2FzdEZ1bmN0aW9uKGl0ZXJhdGVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZm9yRWFjaDtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mb3JFYWNoJyk7XG4iLCJpbXBvcnQgeyBlYWNoIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IHNpemUgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgbWVyZ2UgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgZXh0ZW5kIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IGlzQXJyYXkgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgaXNPYmplY3QgfSBmcm9tICdsb2Rhc2gnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihWdWUsIG9wdGlvbnMpIHtcblxuICAgIFZ1ZS5wcm90b3R5cGUuJG1lcmdlQ2xhc3NlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCBjbGFzc2VzID0ge307XG5cbiAgICAgICAgZWFjaChbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyksIGFyZyA9PiB7XG4gICAgICAgICAgICBpZihpc09iamVjdChhcmcpKSB7XG4gICAgICAgICAgICAgICAgZXh0ZW5kKGNsYXNzZXMsIGFyZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKGlzQXJyYXkoYXJnKSkge1xuICAgICAgICAgICAgICAgIG1lcmdlKGNsYXNzZXMsIGFyZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKGFyZykge1xuICAgICAgICAgICAgICAgIGNsYXNzZXNbYXJnXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBjbGFzc2VzO1xuICAgIH07XG5cbn1cbiIsIjx0ZW1wbGF0ZT5cbiAgICA8ZGl2IGNsYXNzPVwib3ZlcmxheVwiIDpjbGFzcz1cInsnc2hvdyc6IGlzVmlzaWJsZX1cIiA6c3R5bGU9XCJ7YmFja2dyb3VuZDogYmFja2dyb3VuZH1cIiBAa2V5dXAuZXNjPVwiaGlkZVwiPlxuICAgICAgICA8YnV0dG9uIHYtaWY9XCJjbG9zZUJ1dHRvblwiIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tbGluayBvdmVybGF5LWNsb3NlXCIgQGNsaWNrPVwib25DbGlja0Nsb3NlXCI+XG4gICAgICAgICAgICA8aSBjbGFzcz1cImZhIGZhLXRpbWVzLWNpcmNsZVwiPjwvaT5cbiAgICAgICAgPC9idXR0b24+XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cIm92ZXJsYXktY29udGVudCBjb250YWluZXJcIiA6Y2xhc3M9XCJ7J2ZpeGVkJzogZml4ZWRDb250ZW50fVwiIDpzdHlsZT1cInttaW5IZWlnaHQ6IG1pbkhlaWdodH1cIj5cbiAgICAgICAgICAgIDxzbG90Lz5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IHsgZXh0ZW5kIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IGlzT2JqZWN0IH0gZnJvbSAnbG9kYXNoJztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ292ZXJsYXknLFxuXG4gICAgcHJvcHM6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG92ZXJsYXkgYmFja2dyb3VuZCBjb2xvci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgYmFja2dyb3VuZDoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgLjkyNSknXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElzIHRoZSBvdmVybGF5IHNob3dpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBCb29sZWFuXG4gICAgICAgICAqL1xuICAgICAgICB2aXNpYmxlOiBCb29sZWFuLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJcyB0aGUgb3ZlcmxheSBjb250ZW50IGZpeGVkIHBvc2l0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBCb29sZWFuXG4gICAgICAgICAqL1xuICAgICAgICBmaXhlZENvbnRlbnQ6IEJvb2xlYW4sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElzIHRoZSBvdmVybGF5IGNvbnRlbnQgZml4ZWQgcG9zaXRpb25cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IEJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIGNsb3NlQnV0dG9uOiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJcyB0aGUgb3ZlcmxheSBjb250ZW50IG1pbmltdW0gaGVpZ2h0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgQm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgbWluSGVpZ2h0OiBbU3RyaW5nLCBOdW1iZXJdXG5cbiAgICB9LFxuXG4gICAgd2F0Y2g6IHtcbiAgICAgICAgdmlzaWJsZSh2YWx1ZSkge1xuICAgICAgICAgICAgKHRoaXMuaXNWaXNpYmxlID0gdmFsdWUpICYmIHRoaXMuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtZXRob2RzOiB7XG5cbiAgICAgICAgZm9jdXMoKSB7XG4gICAgICAgICAgICBjb25zdCBlbCA9IHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3IoJy5mb3JtLWNvbnRyb2wsIGlucHV0LCBzZWxlY3QsIHRleHRhcmVhJyk7XG5cbiAgICAgICAgICAgIGlmKGVsKSB7XG4gICAgICAgICAgICAgICAgZWwuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvdyB0aGUgb3ZlcmxheVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgICAgICovXG4gICAgICAgIHNob3coY29udGVudHMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuJG1vdW50KGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykpKTtcblxuICAgICAgICAgICAgaWYoY29udGVudHMuJG1vdW50KSB7XG4gICAgICAgICAgICAgICAgY29udGVudHMuJHBhcmVudCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgY29udGVudHMuJG1vdW50KFxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yKCcub3ZlcmxheS1jb250ZW50JykuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5mb2N1cygpO1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgnc2hvdycpO1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgndXBkYXRlOnZpc2libGUnLCB0aGlzLmlzVmlzaWJsZSA9IHRydWUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIaWRlIHRoZSBvdmVybGF5XG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAgICAgKi9cbiAgICAgICAgaGlkZSgpIHtcbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2hpZGUnKTtcbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ3VwZGF0ZTp2aXNpYmxlJywgdGhpcy5pc1Zpc2libGUgPSBmYWxzZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjYWxsYmFjayBmb3IgdGhlIGBjbGlja2AgZXZlbnQgb24gdGhlIGNsb3NlIGJ1dHRvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB2b2lkXG4gICAgICAgICAqL1xuICAgICAgICBvbkNsaWNrQ2xvc2UoKSB7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCdjbGljazpjbG9zZScpO1xuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBtb3VudGVkKCkge1xuICAgICAgICB0aGlzLnZpc2libGUgJiYgdGhpcy5mb2N1cygpO1xuICAgIH0sXG5cbiAgICBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNWaXNpYmxlOiB0aGlzLnZpc2libGVcbiAgICAgICAgfVxuICAgIH1cblxufVxuXG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJzY3NzXCI+XG5AaW1wb3J0ICcuL25vZGVfbW9kdWxlcy9ib290c3RyYXAvc2Nzcy9ib290c3RyYXAtcmVib290LnNjc3MnO1xuXG4ub3ZlcmxheSB7XG4gICAgcG9zaXRpb246IGZpeGVkO1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgbWluLWhlaWdodDogMDtcbiAgICB0b3A6IDA7XG4gICAgbGVmdDogMDtcbiAgICB6LWluZGV4OiAtMTtcbiAgICBvcGFjaXR5OiAwO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogMTAwJTtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGFsaWduLWNvbnRlbnQ6IGNlbnRlcjtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIHRyYW5zaXRpb246IGFsbCAzMzNtcyBlYXNlLW91dDtcblxuICAgICYuc2hvdyB7XG4gICAgICAgIHotaW5kZXg6IDEwMDAwO1xuICAgICAgICBvcGFjaXR5OiAxMDA7XG4gICAgfVxuXG4gICAgLm92ZXJsYXktaGVhZGVyIHtcbiAgICAgICAgbWFyZ2luLXRvcDogJGZvbnQtc2l6ZS1iYXNlICogMS41O1xuICAgIH1cblxuICAgIC5vdmVybGF5LWNsb3NlIHtcbiAgICAgICAgZm9udC1zaXplOiAkZm9udC1zaXplLWJhc2UgKiAxLjI1O1xuICAgICAgICBjb2xvcjogJGdyYXktNzAwO1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogJGZvbnQtc2l6ZS1iYXNlO1xuICAgICAgICByaWdodDogJGZvbnQtc2l6ZS1iYXNlO1xuICAgICAgICB6LWluZGV4OiAxO1xuICAgIH1cblxuICAgIC5vdmVybGF5LWNvbnRlbnQge1xuICAgICAgICBvdmVyZmxvdy15OiBhdXRvO1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBtYXJnaW46IDAgYXV0bztcbiAgICAgICAgcGFkZGluZy1ib3R0b206ICRmb250LXNpemUtYmFzZSAqIDY7XG5cbiAgICAgICAgJi5maXhlZCB7XG4gICAgICAgICAgICB0b3A6IDA7XG4gICAgICAgICAgICBsZWZ0OiAwO1xuICAgICAgICAgICAgcGFkZGluZzogMDtcbiAgICAgICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgICAgICAgIG1heC13aWR0aDogbm9uZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC5vdmVybGF5LWNvbnRyb2xzIHtcbiAgICAgICAgICAgIGZsb2F0OiByaWdodDtcbiAgICAgICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgICAgIHRvcDogNHB4O1xuICAgICAgICAgICAgcGFkZGluZy1yaWdodDogMDtcbiAgICAgICAgICAgIHBhZGRpbmctYm90dG9tOiAkZm9udC1zaXplLWJhc2U7XG5cbiAgICAgICAgICAgICYubGVmdCB7XG4gICAgICAgICAgICAgICAgbGVmdDogMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICYucmlnaHQge1xuICAgICAgICAgICAgICAgIHJpZ2h0OiAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAmICsgKiB7XG4gICAgICAgICAgICAgICAgY2xlYXI6IGJvdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG48L3N0eWxlPlxuIiwiaW1wb3J0IHsgaXNPYmplY3QgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgaXNGdW5jdGlvbiB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgT3ZlcmxheSBmcm9tICdAL0NvbXBvbmVudHMvT3ZlcmxheS9PdmVybGF5JztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oVnVlLCBvcHRpb25zKSB7XG4gICAgVnVlLnByb3RvdHlwZS4kb3ZlcmxheSA9IGZ1bmN0aW9uKENvbnRlbnRDb21wb25lbnQsIG9wdGlvbnMsIG92ZXJsYXlPcHRpb25zLCBPdmVybGF5Q29tcG9uZW50KSB7XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudCA9ICh2dWUsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgIGlmKCEodnVlIGluc3RhbmNlb2YgVnVlKSAmJiBpc09iamVjdCh2dWUpKSB7XG4gICAgICAgICAgICAgICAgdnVlID0gVnVlLmV4dGVuZCh2dWUpO1xuICAgICAgICAgICAgICAgIHZ1ZS5vcHRpb25zLnJvdXRlID0gdGhpcy4kcm91dGU7XG4gICAgICAgICAgICAgICAgdnVlLm9wdGlvbnMucm91dGVyID0gdGhpcy4kcm91dGVyO1xuICAgICAgICAgICAgfSAgIFxuXG4gICAgICAgICAgICByZXR1cm4gaXNGdW5jdGlvbih2dWUpID8gbmV3IHZ1ZShvcHRpb25zKSA6IHZ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG92ZXJsYXkgPSBjb21wb25lbnQoT3ZlcmxheUNvbXBvbmVudCB8fCBPdmVybGF5LCBvdmVybGF5T3B0aW9ucyk7XG5cblxuXG5cbiAgICAgICAgb3ZlcmxheS4kY29udGVudCA9IGNvbXBvbmVudChDb250ZW50Q29tcG9uZW50LCBvcHRpb25zKTtcbiAgICAgICAgb3ZlcmxheS5zaG93KG92ZXJsYXkuJGNvbnRlbnQpO1xuICAgICAgICByZXR1cm4gb3ZlcmxheTtcbiAgICB9O1xufVxuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ucmVkdWNlYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbml0QWNjdW1dIFNwZWNpZnkgdXNpbmcgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YCBhc1xuICogIHRoZSBpbml0aWFsIHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBhcnJheVJlZHVjZShhcnJheSwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0pIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICBpZiAoaW5pdEFjY3VtICYmIGxlbmd0aCkge1xuICAgIGFjY3VtdWxhdG9yID0gYXJyYXlbKytpbmRleF07XG4gIH1cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhY2N1bXVsYXRvciA9IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCBhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIGFjY3VtdWxhdG9yO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5UmVkdWNlO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eU9mYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHlPZihvYmplY3QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VQcm9wZXJ0eU9mO1xuIiwidmFyIGJhc2VQcm9wZXJ0eU9mID0gcmVxdWlyZSgnLi9fYmFzZVByb3BlcnR5T2YnKTtcblxuLyoqIFVzZWQgdG8gbWFwIExhdGluIFVuaWNvZGUgbGV0dGVycyB0byBiYXNpYyBMYXRpbiBsZXR0ZXJzLiAqL1xudmFyIGRlYnVycmVkTGV0dGVycyA9IHtcbiAgLy8gTGF0aW4tMSBTdXBwbGVtZW50IGJsb2NrLlxuICAnXFx4YzAnOiAnQScsICAnXFx4YzEnOiAnQScsICdcXHhjMic6ICdBJywgJ1xceGMzJzogJ0EnLCAnXFx4YzQnOiAnQScsICdcXHhjNSc6ICdBJyxcbiAgJ1xceGUwJzogJ2EnLCAgJ1xceGUxJzogJ2EnLCAnXFx4ZTInOiAnYScsICdcXHhlMyc6ICdhJywgJ1xceGU0JzogJ2EnLCAnXFx4ZTUnOiAnYScsXG4gICdcXHhjNyc6ICdDJywgICdcXHhlNyc6ICdjJyxcbiAgJ1xceGQwJzogJ0QnLCAgJ1xceGYwJzogJ2QnLFxuICAnXFx4YzgnOiAnRScsICAnXFx4YzknOiAnRScsICdcXHhjYSc6ICdFJywgJ1xceGNiJzogJ0UnLFxuICAnXFx4ZTgnOiAnZScsICAnXFx4ZTknOiAnZScsICdcXHhlYSc6ICdlJywgJ1xceGViJzogJ2UnLFxuICAnXFx4Y2MnOiAnSScsICAnXFx4Y2QnOiAnSScsICdcXHhjZSc6ICdJJywgJ1xceGNmJzogJ0knLFxuICAnXFx4ZWMnOiAnaScsICAnXFx4ZWQnOiAnaScsICdcXHhlZSc6ICdpJywgJ1xceGVmJzogJ2knLFxuICAnXFx4ZDEnOiAnTicsICAnXFx4ZjEnOiAnbicsXG4gICdcXHhkMic6ICdPJywgICdcXHhkMyc6ICdPJywgJ1xceGQ0JzogJ08nLCAnXFx4ZDUnOiAnTycsICdcXHhkNic6ICdPJywgJ1xceGQ4JzogJ08nLFxuICAnXFx4ZjInOiAnbycsICAnXFx4ZjMnOiAnbycsICdcXHhmNCc6ICdvJywgJ1xceGY1JzogJ28nLCAnXFx4ZjYnOiAnbycsICdcXHhmOCc6ICdvJyxcbiAgJ1xceGQ5JzogJ1UnLCAgJ1xceGRhJzogJ1UnLCAnXFx4ZGInOiAnVScsICdcXHhkYyc6ICdVJyxcbiAgJ1xceGY5JzogJ3UnLCAgJ1xceGZhJzogJ3UnLCAnXFx4ZmInOiAndScsICdcXHhmYyc6ICd1JyxcbiAgJ1xceGRkJzogJ1knLCAgJ1xceGZkJzogJ3knLCAnXFx4ZmYnOiAneScsXG4gICdcXHhjNic6ICdBZScsICdcXHhlNic6ICdhZScsXG4gICdcXHhkZSc6ICdUaCcsICdcXHhmZSc6ICd0aCcsXG4gICdcXHhkZic6ICdzcycsXG4gIC8vIExhdGluIEV4dGVuZGVkLUEgYmxvY2suXG4gICdcXHUwMTAwJzogJ0EnLCAgJ1xcdTAxMDInOiAnQScsICdcXHUwMTA0JzogJ0EnLFxuICAnXFx1MDEwMSc6ICdhJywgICdcXHUwMTAzJzogJ2EnLCAnXFx1MDEwNSc6ICdhJyxcbiAgJ1xcdTAxMDYnOiAnQycsICAnXFx1MDEwOCc6ICdDJywgJ1xcdTAxMGEnOiAnQycsICdcXHUwMTBjJzogJ0MnLFxuICAnXFx1MDEwNyc6ICdjJywgICdcXHUwMTA5JzogJ2MnLCAnXFx1MDEwYic6ICdjJywgJ1xcdTAxMGQnOiAnYycsXG4gICdcXHUwMTBlJzogJ0QnLCAgJ1xcdTAxMTAnOiAnRCcsICdcXHUwMTBmJzogJ2QnLCAnXFx1MDExMSc6ICdkJyxcbiAgJ1xcdTAxMTInOiAnRScsICAnXFx1MDExNCc6ICdFJywgJ1xcdTAxMTYnOiAnRScsICdcXHUwMTE4JzogJ0UnLCAnXFx1MDExYSc6ICdFJyxcbiAgJ1xcdTAxMTMnOiAnZScsICAnXFx1MDExNSc6ICdlJywgJ1xcdTAxMTcnOiAnZScsICdcXHUwMTE5JzogJ2UnLCAnXFx1MDExYic6ICdlJyxcbiAgJ1xcdTAxMWMnOiAnRycsICAnXFx1MDExZSc6ICdHJywgJ1xcdTAxMjAnOiAnRycsICdcXHUwMTIyJzogJ0cnLFxuICAnXFx1MDExZCc6ICdnJywgICdcXHUwMTFmJzogJ2cnLCAnXFx1MDEyMSc6ICdnJywgJ1xcdTAxMjMnOiAnZycsXG4gICdcXHUwMTI0JzogJ0gnLCAgJ1xcdTAxMjYnOiAnSCcsICdcXHUwMTI1JzogJ2gnLCAnXFx1MDEyNyc6ICdoJyxcbiAgJ1xcdTAxMjgnOiAnSScsICAnXFx1MDEyYSc6ICdJJywgJ1xcdTAxMmMnOiAnSScsICdcXHUwMTJlJzogJ0knLCAnXFx1MDEzMCc6ICdJJyxcbiAgJ1xcdTAxMjknOiAnaScsICAnXFx1MDEyYic6ICdpJywgJ1xcdTAxMmQnOiAnaScsICdcXHUwMTJmJzogJ2knLCAnXFx1MDEzMSc6ICdpJyxcbiAgJ1xcdTAxMzQnOiAnSicsICAnXFx1MDEzNSc6ICdqJyxcbiAgJ1xcdTAxMzYnOiAnSycsICAnXFx1MDEzNyc6ICdrJywgJ1xcdTAxMzgnOiAnaycsXG4gICdcXHUwMTM5JzogJ0wnLCAgJ1xcdTAxM2InOiAnTCcsICdcXHUwMTNkJzogJ0wnLCAnXFx1MDEzZic6ICdMJywgJ1xcdTAxNDEnOiAnTCcsXG4gICdcXHUwMTNhJzogJ2wnLCAgJ1xcdTAxM2MnOiAnbCcsICdcXHUwMTNlJzogJ2wnLCAnXFx1MDE0MCc6ICdsJywgJ1xcdTAxNDInOiAnbCcsXG4gICdcXHUwMTQzJzogJ04nLCAgJ1xcdTAxNDUnOiAnTicsICdcXHUwMTQ3JzogJ04nLCAnXFx1MDE0YSc6ICdOJyxcbiAgJ1xcdTAxNDQnOiAnbicsICAnXFx1MDE0Nic6ICduJywgJ1xcdTAxNDgnOiAnbicsICdcXHUwMTRiJzogJ24nLFxuICAnXFx1MDE0Yyc6ICdPJywgICdcXHUwMTRlJzogJ08nLCAnXFx1MDE1MCc6ICdPJyxcbiAgJ1xcdTAxNGQnOiAnbycsICAnXFx1MDE0Zic6ICdvJywgJ1xcdTAxNTEnOiAnbycsXG4gICdcXHUwMTU0JzogJ1InLCAgJ1xcdTAxNTYnOiAnUicsICdcXHUwMTU4JzogJ1InLFxuICAnXFx1MDE1NSc6ICdyJywgICdcXHUwMTU3JzogJ3InLCAnXFx1MDE1OSc6ICdyJyxcbiAgJ1xcdTAxNWEnOiAnUycsICAnXFx1MDE1Yyc6ICdTJywgJ1xcdTAxNWUnOiAnUycsICdcXHUwMTYwJzogJ1MnLFxuICAnXFx1MDE1Yic6ICdzJywgICdcXHUwMTVkJzogJ3MnLCAnXFx1MDE1Zic6ICdzJywgJ1xcdTAxNjEnOiAncycsXG4gICdcXHUwMTYyJzogJ1QnLCAgJ1xcdTAxNjQnOiAnVCcsICdcXHUwMTY2JzogJ1QnLFxuICAnXFx1MDE2Myc6ICd0JywgICdcXHUwMTY1JzogJ3QnLCAnXFx1MDE2Nyc6ICd0JyxcbiAgJ1xcdTAxNjgnOiAnVScsICAnXFx1MDE2YSc6ICdVJywgJ1xcdTAxNmMnOiAnVScsICdcXHUwMTZlJzogJ1UnLCAnXFx1MDE3MCc6ICdVJywgJ1xcdTAxNzInOiAnVScsXG4gICdcXHUwMTY5JzogJ3UnLCAgJ1xcdTAxNmInOiAndScsICdcXHUwMTZkJzogJ3UnLCAnXFx1MDE2Zic6ICd1JywgJ1xcdTAxNzEnOiAndScsICdcXHUwMTczJzogJ3UnLFxuICAnXFx1MDE3NCc6ICdXJywgICdcXHUwMTc1JzogJ3cnLFxuICAnXFx1MDE3Nic6ICdZJywgICdcXHUwMTc3JzogJ3knLCAnXFx1MDE3OCc6ICdZJyxcbiAgJ1xcdTAxNzknOiAnWicsICAnXFx1MDE3Yic6ICdaJywgJ1xcdTAxN2QnOiAnWicsXG4gICdcXHUwMTdhJzogJ3onLCAgJ1xcdTAxN2MnOiAneicsICdcXHUwMTdlJzogJ3onLFxuICAnXFx1MDEzMic6ICdJSicsICdcXHUwMTMzJzogJ2lqJyxcbiAgJ1xcdTAxNTInOiAnT2UnLCAnXFx1MDE1Myc6ICdvZScsXG4gICdcXHUwMTQ5JzogXCInblwiLCAnXFx1MDE3Zic6ICdzJ1xufTtcblxuLyoqXG4gKiBVc2VkIGJ5IGBfLmRlYnVycmAgdG8gY29udmVydCBMYXRpbi0xIFN1cHBsZW1lbnQgYW5kIExhdGluIEV4dGVuZGVkLUFcbiAqIGxldHRlcnMgdG8gYmFzaWMgTGF0aW4gbGV0dGVycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGxldHRlciBUaGUgbWF0Y2hlZCBsZXR0ZXIgdG8gZGVidXJyLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZGVidXJyZWQgbGV0dGVyLlxuICovXG52YXIgZGVidXJyTGV0dGVyID0gYmFzZVByb3BlcnR5T2YoZGVidXJyZWRMZXR0ZXJzKTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWJ1cnJMZXR0ZXI7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5TWFwO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU3ltYm9sO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGFycmF5TWFwID0gcmVxdWlyZSgnLi9fYXJyYXlNYXAnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xUb1N0cmluZyA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udG9TdHJpbmcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9TdHJpbmdgIHdoaWNoIGRvZXNuJ3QgY29udmVydCBudWxsaXNoXG4gKiB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5ncy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgY29udmVydCB2YWx1ZXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICByZXR1cm4gYXJyYXlNYXAodmFsdWUsIGJhc2VUb1N0cmluZykgKyAnJztcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN5bWJvbFRvU3RyaW5nID8gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVRvU3RyaW5nO1xuIiwidmFyIGJhc2VUb1N0cmluZyA9IHJlcXVpcmUoJy4vX2Jhc2VUb1N0cmluZycpO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBmb3IgYG51bGxgXG4gKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9TdHJpbmcobnVsbCk7XG4gKiAvLyA9PiAnJ1xuICpcbiAqIF8udG9TdHJpbmcoLTApO1xuICogLy8gPT4gJy0wJ1xuICpcbiAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcbiAqIC8vID0+ICcxLDIsMydcbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9TdHJpbmc7XG4iLCJ2YXIgZGVidXJyTGV0dGVyID0gcmVxdWlyZSgnLi9fZGVidXJyTGV0dGVyJyksXG4gICAgdG9TdHJpbmcgPSByZXF1aXJlKCcuL3RvU3RyaW5nJyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIExhdGluIFVuaWNvZGUgbGV0dGVycyAoZXhjbHVkaW5nIG1hdGhlbWF0aWNhbCBvcGVyYXRvcnMpLiAqL1xudmFyIHJlTGF0aW4gPSAvW1xceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHhmZlxcdTAxMDAtXFx1MDE3Zl0vZztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNoYXJhY3RlciBjbGFzc2VzLiAqL1xudmFyIHJzQ29tYm9NYXJrc1JhbmdlID0gJ1xcXFx1MDMwMC1cXFxcdTAzNmYnLFxuICAgIHJlQ29tYm9IYWxmTWFya3NSYW5nZSA9ICdcXFxcdWZlMjAtXFxcXHVmZTJmJyxcbiAgICByc0NvbWJvU3ltYm9sc1JhbmdlID0gJ1xcXFx1MjBkMC1cXFxcdTIwZmYnLFxuICAgIHJzQ29tYm9SYW5nZSA9IHJzQ29tYm9NYXJrc1JhbmdlICsgcmVDb21ib0hhbGZNYXJrc1JhbmdlICsgcnNDb21ib1N5bWJvbHNSYW5nZTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNhcHR1cmUgZ3JvdXBzLiAqL1xudmFyIHJzQ29tYm8gPSAnWycgKyByc0NvbWJvUmFuZ2UgKyAnXSc7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBbY29tYmluaW5nIGRpYWNyaXRpY2FsIG1hcmtzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3MpIGFuZFxuICogW2NvbWJpbmluZyBkaWFjcml0aWNhbCBtYXJrcyBmb3Igc3ltYm9sc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzX2Zvcl9TeW1ib2xzKS5cbiAqL1xudmFyIHJlQ29tYm9NYXJrID0gUmVnRXhwKHJzQ29tYm8sICdnJyk7XG5cbi8qKlxuICogRGVidXJycyBgc3RyaW5nYCBieSBjb252ZXJ0aW5nXG4gKiBbTGF0aW4tMSBTdXBwbGVtZW50XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MYXRpbi0xX1N1cHBsZW1lbnRfKFVuaWNvZGVfYmxvY2spI0NoYXJhY3Rlcl90YWJsZSlcbiAqIGFuZCBbTGF0aW4gRXh0ZW5kZWQtQV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGF0aW5fRXh0ZW5kZWQtQSlcbiAqIGxldHRlcnMgdG8gYmFzaWMgTGF0aW4gbGV0dGVycyBhbmQgcmVtb3ZpbmdcbiAqIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3NdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrcykuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gZGVidXJyLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZGVidXJyZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmRlYnVycignZMOpasOgIHZ1Jyk7XG4gKiAvLyA9PiAnZGVqYSB2dSdcbiAqL1xuZnVuY3Rpb24gZGVidXJyKHN0cmluZykge1xuICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICByZXR1cm4gc3RyaW5nICYmIHN0cmluZy5yZXBsYWNlKHJlTGF0aW4sIGRlYnVyckxldHRlcikucmVwbGFjZShyZUNvbWJvTWFyaywgJycpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRlYnVycjtcbiIsIi8qKiBVc2VkIHRvIG1hdGNoIHdvcmRzIGNvbXBvc2VkIG9mIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzLiAqL1xudmFyIHJlQXNjaWlXb3JkID0gL1teXFx4MDAtXFx4MmZcXHgzYS1cXHg0MFxceDViLVxceDYwXFx4N2ItXFx4N2ZdKy9nO1xuXG4vKipcbiAqIFNwbGl0cyBhbiBBU0NJSSBgc3RyaW5nYCBpbnRvIGFuIGFycmF5IG9mIGl0cyB3b3Jkcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgd29yZHMgb2YgYHN0cmluZ2AuXG4gKi9cbmZ1bmN0aW9uIGFzY2lpV29yZHMoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcubWF0Y2gocmVBc2NpaVdvcmQpIHx8IFtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzY2lpV29yZHM7XG4iLCIvKiogVXNlZCB0byBkZXRlY3Qgc3RyaW5ncyB0aGF0IG5lZWQgYSBtb3JlIHJvYnVzdCByZWdleHAgdG8gbWF0Y2ggd29yZHMuICovXG52YXIgcmVIYXNVbmljb2RlV29yZCA9IC9bYS16XVtBLVpdfFtBLVpdezIsfVthLXpdfFswLTldW2EtekEtWl18W2EtekEtWl1bMC05XXxbXmEtekEtWjAtOSBdLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHN0cmluZ2AgY29udGFpbnMgYSB3b3JkIGNvbXBvc2VkIG9mIFVuaWNvZGUgc3ltYm9scy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYSB3b3JkIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc1VuaWNvZGVXb3JkKHN0cmluZykge1xuICByZXR1cm4gcmVIYXNVbmljb2RlV29yZC50ZXN0KHN0cmluZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzVW5pY29kZVdvcmQ7XG4iLCIvKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2hhcmFjdGVyIGNsYXNzZXMuICovXG52YXIgcnNBc3RyYWxSYW5nZSA9ICdcXFxcdWQ4MDAtXFxcXHVkZmZmJyxcbiAgICByc0NvbWJvTWFya3NSYW5nZSA9ICdcXFxcdTAzMDAtXFxcXHUwMzZmJyxcbiAgICByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgPSAnXFxcXHVmZTIwLVxcXFx1ZmUyZicsXG4gICAgcnNDb21ib1N5bWJvbHNSYW5nZSA9ICdcXFxcdTIwZDAtXFxcXHUyMGZmJyxcbiAgICByc0NvbWJvUmFuZ2UgPSByc0NvbWJvTWFya3NSYW5nZSArIHJlQ29tYm9IYWxmTWFya3NSYW5nZSArIHJzQ29tYm9TeW1ib2xzUmFuZ2UsXG4gICAgcnNEaW5nYmF0UmFuZ2UgPSAnXFxcXHUyNzAwLVxcXFx1MjdiZicsXG4gICAgcnNMb3dlclJhbmdlID0gJ2EtelxcXFx4ZGYtXFxcXHhmNlxcXFx4ZjgtXFxcXHhmZicsXG4gICAgcnNNYXRoT3BSYW5nZSA9ICdcXFxceGFjXFxcXHhiMVxcXFx4ZDdcXFxceGY3JyxcbiAgICByc05vbkNoYXJSYW5nZSA9ICdcXFxceDAwLVxcXFx4MmZcXFxceDNhLVxcXFx4NDBcXFxceDViLVxcXFx4NjBcXFxceDdiLVxcXFx4YmYnLFxuICAgIHJzUHVuY3R1YXRpb25SYW5nZSA9ICdcXFxcdTIwMDAtXFxcXHUyMDZmJyxcbiAgICByc1NwYWNlUmFuZ2UgPSAnIFxcXFx0XFxcXHgwYlxcXFxmXFxcXHhhMFxcXFx1ZmVmZlxcXFxuXFxcXHJcXFxcdTIwMjhcXFxcdTIwMjlcXFxcdTE2ODBcXFxcdTE4MGVcXFxcdTIwMDBcXFxcdTIwMDFcXFxcdTIwMDJcXFxcdTIwMDNcXFxcdTIwMDRcXFxcdTIwMDVcXFxcdTIwMDZcXFxcdTIwMDdcXFxcdTIwMDhcXFxcdTIwMDlcXFxcdTIwMGFcXFxcdTIwMmZcXFxcdTIwNWZcXFxcdTMwMDAnLFxuICAgIHJzVXBwZXJSYW5nZSA9ICdBLVpcXFxceGMwLVxcXFx4ZDZcXFxceGQ4LVxcXFx4ZGUnLFxuICAgIHJzVmFyUmFuZ2UgPSAnXFxcXHVmZTBlXFxcXHVmZTBmJyxcbiAgICByc0JyZWFrUmFuZ2UgPSByc01hdGhPcFJhbmdlICsgcnNOb25DaGFyUmFuZ2UgKyByc1B1bmN0dWF0aW9uUmFuZ2UgKyByc1NwYWNlUmFuZ2U7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjYXB0dXJlIGdyb3Vwcy4gKi9cbnZhciByc0Fwb3MgPSBcIlsnXFx1MjAxOV1cIixcbiAgICByc0JyZWFrID0gJ1snICsgcnNCcmVha1JhbmdlICsgJ10nLFxuICAgIHJzQ29tYm8gPSAnWycgKyByc0NvbWJvUmFuZ2UgKyAnXScsXG4gICAgcnNEaWdpdHMgPSAnXFxcXGQrJyxcbiAgICByc0RpbmdiYXQgPSAnWycgKyByc0RpbmdiYXRSYW5nZSArICddJyxcbiAgICByc0xvd2VyID0gJ1snICsgcnNMb3dlclJhbmdlICsgJ10nLFxuICAgIHJzTWlzYyA9ICdbXicgKyByc0FzdHJhbFJhbmdlICsgcnNCcmVha1JhbmdlICsgcnNEaWdpdHMgKyByc0RpbmdiYXRSYW5nZSArIHJzTG93ZXJSYW5nZSArIHJzVXBwZXJSYW5nZSArICddJyxcbiAgICByc0ZpdHogPSAnXFxcXHVkODNjW1xcXFx1ZGZmYi1cXFxcdWRmZmZdJyxcbiAgICByc01vZGlmaWVyID0gJyg/OicgKyByc0NvbWJvICsgJ3wnICsgcnNGaXR6ICsgJyknLFxuICAgIHJzTm9uQXN0cmFsID0gJ1teJyArIHJzQXN0cmFsUmFuZ2UgKyAnXScsXG4gICAgcnNSZWdpb25hbCA9ICcoPzpcXFxcdWQ4M2NbXFxcXHVkZGU2LVxcXFx1ZGRmZl0pezJ9JyxcbiAgICByc1N1cnJQYWlyID0gJ1tcXFxcdWQ4MDAtXFxcXHVkYmZmXVtcXFxcdWRjMDAtXFxcXHVkZmZmXScsXG4gICAgcnNVcHBlciA9ICdbJyArIHJzVXBwZXJSYW5nZSArICddJyxcbiAgICByc1pXSiA9ICdcXFxcdTIwMGQnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgcmVnZXhlcy4gKi9cbnZhciByc01pc2NMb3dlciA9ICcoPzonICsgcnNMb3dlciArICd8JyArIHJzTWlzYyArICcpJyxcbiAgICByc01pc2NVcHBlciA9ICcoPzonICsgcnNVcHBlciArICd8JyArIHJzTWlzYyArICcpJyxcbiAgICByc09wdENvbnRyTG93ZXIgPSAnKD86JyArIHJzQXBvcyArICcoPzpkfGxsfG18cmV8c3x0fHZlKSk/JyxcbiAgICByc09wdENvbnRyVXBwZXIgPSAnKD86JyArIHJzQXBvcyArICcoPzpEfExMfE18UkV8U3xUfFZFKSk/JyxcbiAgICByZU9wdE1vZCA9IHJzTW9kaWZpZXIgKyAnPycsXG4gICAgcnNPcHRWYXIgPSAnWycgKyByc1ZhclJhbmdlICsgJ10/JyxcbiAgICByc09wdEpvaW4gPSAnKD86JyArIHJzWldKICsgJyg/OicgKyBbcnNOb25Bc3RyYWwsIHJzUmVnaW9uYWwsIHJzU3VyclBhaXJdLmpvaW4oJ3wnKSArICcpJyArIHJzT3B0VmFyICsgcmVPcHRNb2QgKyAnKSonLFxuICAgIHJzT3JkTG93ZXIgPSAnXFxcXGQqKD86MXN0fDJuZHwzcmR8KD8hWzEyM10pXFxcXGR0aCkoPz1cXFxcYnxbQS1aX10pJyxcbiAgICByc09yZFVwcGVyID0gJ1xcXFxkKig/OjFTVHwyTkR8M1JEfCg/IVsxMjNdKVxcXFxkVEgpKD89XFxcXGJ8W2Etel9dKScsXG4gICAgcnNTZXEgPSByc09wdFZhciArIHJlT3B0TW9kICsgcnNPcHRKb2luLFxuICAgIHJzRW1vamkgPSAnKD86JyArIFtyc0RpbmdiYXQsIHJzUmVnaW9uYWwsIHJzU3VyclBhaXJdLmpvaW4oJ3wnKSArICcpJyArIHJzU2VxO1xuXG4vKiogVXNlZCB0byBtYXRjaCBjb21wbGV4IG9yIGNvbXBvdW5kIHdvcmRzLiAqL1xudmFyIHJlVW5pY29kZVdvcmQgPSBSZWdFeHAoW1xuICByc1VwcGVyICsgJz8nICsgcnNMb3dlciArICcrJyArIHJzT3B0Q29udHJMb3dlciArICcoPz0nICsgW3JzQnJlYWssIHJzVXBwZXIsICckJ10uam9pbignfCcpICsgJyknLFxuICByc01pc2NVcHBlciArICcrJyArIHJzT3B0Q29udHJVcHBlciArICcoPz0nICsgW3JzQnJlYWssIHJzVXBwZXIgKyByc01pc2NMb3dlciwgJyQnXS5qb2luKCd8JykgKyAnKScsXG4gIHJzVXBwZXIgKyAnPycgKyByc01pc2NMb3dlciArICcrJyArIHJzT3B0Q29udHJMb3dlcixcbiAgcnNVcHBlciArICcrJyArIHJzT3B0Q29udHJVcHBlcixcbiAgcnNPcmRVcHBlcixcbiAgcnNPcmRMb3dlcixcbiAgcnNEaWdpdHMsXG4gIHJzRW1vamlcbl0uam9pbignfCcpLCAnZycpO1xuXG4vKipcbiAqIFNwbGl0cyBhIFVuaWNvZGUgYHN0cmluZ2AgaW50byBhbiBhcnJheSBvZiBpdHMgd29yZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdvcmRzIG9mIGBzdHJpbmdgLlxuICovXG5mdW5jdGlvbiB1bmljb2RlV29yZHMoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcubWF0Y2gocmVVbmljb2RlV29yZCkgfHwgW107XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdW5pY29kZVdvcmRzO1xuIiwidmFyIGFzY2lpV29yZHMgPSByZXF1aXJlKCcuL19hc2NpaVdvcmRzJyksXG4gICAgaGFzVW5pY29kZVdvcmQgPSByZXF1aXJlKCcuL19oYXNVbmljb2RlV29yZCcpLFxuICAgIHRvU3RyaW5nID0gcmVxdWlyZSgnLi90b1N0cmluZycpLFxuICAgIHVuaWNvZGVXb3JkcyA9IHJlcXVpcmUoJy4vX3VuaWNvZGVXb3JkcycpO1xuXG4vKipcbiAqIFNwbGl0cyBgc3RyaW5nYCBpbnRvIGFuIGFycmF5IG9mIGl0cyB3b3Jkcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtSZWdFeHB8c3RyaW5nfSBbcGF0dGVybl0gVGhlIHBhdHRlcm4gdG8gbWF0Y2ggd29yZHMuXG4gKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB3b3JkcyBvZiBgc3RyaW5nYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy53b3JkcygnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnKTtcbiAqIC8vID0+IFsnZnJlZCcsICdiYXJuZXknLCAncGViYmxlcyddXG4gKlxuICogXy53b3JkcygnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnLCAvW14sIF0rL2cpO1xuICogLy8gPT4gWydmcmVkJywgJ2Jhcm5leScsICcmJywgJ3BlYmJsZXMnXVxuICovXG5mdW5jdGlvbiB3b3JkcyhzdHJpbmcsIHBhdHRlcm4sIGd1YXJkKSB7XG4gIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gIHBhdHRlcm4gPSBndWFyZCA/IHVuZGVmaW5lZCA6IHBhdHRlcm47XG5cbiAgaWYgKHBhdHRlcm4gPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBoYXNVbmljb2RlV29yZChzdHJpbmcpID8gdW5pY29kZVdvcmRzKHN0cmluZykgOiBhc2NpaVdvcmRzKHN0cmluZyk7XG4gIH1cbiAgcmV0dXJuIHN0cmluZy5tYXRjaChwYXR0ZXJuKSB8fCBbXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3b3JkcztcbiIsInZhciBhcnJheVJlZHVjZSA9IHJlcXVpcmUoJy4vX2FycmF5UmVkdWNlJyksXG4gICAgZGVidXJyID0gcmVxdWlyZSgnLi9kZWJ1cnInKSxcbiAgICB3b3JkcyA9IHJlcXVpcmUoJy4vd29yZHMnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNhcHR1cmUgZ3JvdXBzLiAqL1xudmFyIHJzQXBvcyA9IFwiWydcXHUyMDE5XVwiO1xuXG4vKiogVXNlZCB0byBtYXRjaCBhcG9zdHJvcGhlcy4gKi9cbnZhciByZUFwb3MgPSBSZWdFeHAocnNBcG9zLCAnZycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmNhbWVsQ2FzZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBjb21iaW5lIGVhY2ggd29yZC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbXBvdW5kZXIgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvdW5kZXIoY2FsbGJhY2spIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHJldHVybiBhcnJheVJlZHVjZSh3b3JkcyhkZWJ1cnIoc3RyaW5nKS5yZXBsYWNlKHJlQXBvcywgJycpKSwgY2FsbGJhY2ssICcnKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVDb21wb3VuZGVyO1xuIiwidmFyIGNyZWF0ZUNvbXBvdW5kZXIgPSByZXF1aXJlKCcuL19jcmVhdGVDb21wb3VuZGVyJyk7XG5cbi8qKlxuICogQ29udmVydHMgYHN0cmluZ2AgdG9cbiAqIFtrZWJhYiBjYXNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MZXR0ZXJfY2FzZSNTcGVjaWFsX2Nhc2Vfc3R5bGVzKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUga2ViYWIgY2FzZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmtlYmFiQ2FzZSgnRm9vIEJhcicpO1xuICogLy8gPT4gJ2Zvby1iYXInXG4gKlxuICogXy5rZWJhYkNhc2UoJ2Zvb0JhcicpO1xuICogLy8gPT4gJ2Zvby1iYXInXG4gKlxuICogXy5rZWJhYkNhc2UoJ19fRk9PX0JBUl9fJyk7XG4gKiAvLyA9PiAnZm9vLWJhcidcbiAqL1xudmFyIGtlYmFiQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJy0nIDogJycpICsgd29yZC50b0xvd2VyQ2FzZSgpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0ga2ViYWJDYXNlO1xuIiwiPHRlbXBsYXRlPlxuICAgIDxkaXYgY2xhc3M9XCJhY3Rpdml0eS1pbmRpY2F0b3JcIiA6Y2xhc3M9XCJjbGFzc2VzXCI+XG4gICAgICAgIDxkaXYgdi1mb3I9XCJpIGluIG5vZGVzXCI+PC9kaXY+XG4gICAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgcHJvcHM6IHtcbiAgICAgICAgbm9kZXM6IHtcbiAgICAgICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgICAgIGRlZmF1bHQ6IDNcbiAgICAgICAgfSxcbiAgICAgICAgc2l6ZToge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJydcbiAgICAgICAgfSxcbiAgICAgICAgcHJlZml4OiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAnYWN0aXZpdHktaW5kaWNhdG9yLSdcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBjb21wdXRlZDoge1xuICAgICAgICBjbGFzc2VzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNvbnN0IGNsYXNzZXMgPSB7fTtcblxuICAgICAgICAgICAgY2xhc3Nlc1t0aGlzLiRvcHRpb25zLm5hbWVdID0gISF0aGlzLiRvcHRpb25zLm5hbWU7XG4gICAgICAgICAgICBjbGFzc2VzW3RoaXMucHJlZml4ICsgdGhpcy5zaXplLnJlcGxhY2UodGhpcy5wcmVmaXgsICcnKV0gPSAhIXRoaXMuc2l6ZTtcblxuICAgICAgICAgICAgcmV0dXJuIGNsYXNzZXM7XG4gICAgICAgIH1cbiAgICB9XG5cbn1cbjwvc2NyaXB0PlxuIiwiPHNjcmlwdD5cbmltcG9ydCBCYXNlVHlwZSBmcm9tICcuL0Jhc2VUeXBlJztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ2FjdGl2aXR5LWluZGljYXRvci1kb3RzJyxcblxuICAgIGV4dGVuZHM6IEJhc2VUeXBlXG59XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJzY3NzXCI+XG5AaW1wb3J0ICcuL25vZGVfbW9kdWxlcy9ib290c3RyYXAvc2Nzcy9ib290c3RyYXAtcmVib290LnNjc3MnO1xuXG4kYWN0aXZpdHktaW5kaWNhdG9yLWRvdC1zaXplOiAuNnJlbTtcblxuLmFjdGl2aXR5LWluZGljYXRvci1kb3RzIHtcblxuICAgICYgPiBkaXYge1xuICAgICAgICBib3JkZXItcmFkaXVzOiAxMDAlO1xuICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICRncmF5LTkwMDtcbiAgICAgICAgd2lkdGg6ICRhY3Rpdml0eS1pbmRpY2F0b3ItZG90LXNpemU7XG4gICAgICAgIGhlaWdodDogJGFjdGl2aXR5LWluZGljYXRvci1kb3Qtc2l6ZTtcbiAgICAgICAgYW5pbWF0aW9uOiBhY3Rpdml0eS1pbmRpY2F0b3ItZG90cyAxLjRzIGluZmluaXRlIGVhc2UtaW4tb3V0IGJvdGg7XG4gICAgfVxuXG4gICAgJiA+IGRpdjpub3QoOmxhc3QtY2hpbGQpIHtcbiAgICAgICAgbWFyZ2luLXJpZ2h0OiAkYWN0aXZpdHktaW5kaWNhdG9yLWRvdC1zaXplICogLjMzO1xuICAgIH1cblxuICAgICYuYWN0aXZpdHktaW5kaWNhdG9yLXhzID4gZGl2IHtcbiAgICAgICAgd2lkdGg6ICRhY3Rpdml0eS1pbmRpY2F0b3ItZG90LXNpemUgKiAuNTtcbiAgICAgICAgaGVpZ2h0OiAkYWN0aXZpdHktaW5kaWNhdG9yLWRvdC1zaXplICogLjU7XG4gICAgfVxuXG4gICAgJi5hY3Rpdml0eS1pbmRpY2F0b3Itc20gPiBkaXYge1xuICAgICAgICB3aWR0aDogJGFjdGl2aXR5LWluZGljYXRvci1kb3Qtc2l6ZSAqIC43NTtcbiAgICAgICAgaGVpZ2h0OiAkYWN0aXZpdHktaW5kaWNhdG9yLWRvdC1zaXplICogLjc1O1xuICAgIH1cblxuICAgICYuYWN0aXZpdHktaW5kaWNhdG9yLW1kID4gZGl2IHtcbiAgICAgICAgd2lkdGg6ICRhY3Rpdml0eS1pbmRpY2F0b3ItZG90LXNpemUgKiAxO1xuICAgICAgICBoZWlnaHQ6ICRhY3Rpdml0eS1pbmRpY2F0b3ItZG90LXNpemUgKiAxO1xuICAgIH1cblxuICAgICYuYWN0aXZpdHktaW5kaWNhdG9yLWxnID4gZGl2IHtcbiAgICAgICAgd2lkdGg6ICRhY3Rpdml0eS1pbmRpY2F0b3ItZG90LXNpemUgKiAxLjU7XG4gICAgICAgIGhlaWdodDogJGFjdGl2aXR5LWluZGljYXRvci1kb3Qtc2l6ZSAqIDEuNTtcbiAgICB9XG5cbiAgICAmLmFjdGl2aXR5LWluZGljYXRvci14bCA+IGRpdiB7XG4gICAgICAgIHdpZHRoOiAkYWN0aXZpdHktaW5kaWNhdG9yLWRvdC1zaXplICogMjtcbiAgICAgICAgaGVpZ2h0OiAkYWN0aXZpdHktaW5kaWNhdG9yLWRvdC1zaXplICogMjtcbiAgICB9XG5cbiAgICBAZm9yICRpIGZyb20gMCB0aHJvdWdoIDEyIHtcbiAgICAgICAgJiA+IGRpdjpudGgtY2hpbGQoI3skaSArIDF9KSB7XG4gICAgICAgICAgICBhbmltYXRpb24tZGVsYXk6ICRpICogLjE2cztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIEBrZXlmcmFtZXMgYWN0aXZpdHktaW5kaWNhdG9yLWRvdHMge1xuICAgICAgICAwJSwgODAlLCAxMDAlIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMCk7XG4gICAgICAgIH0gNDAlIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMS4wKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyB7XG4gICAgJjpub3QoLmJ0bi13YXJuaW5nKSAuYWN0aXZpdHktaW5kaWNhdG9yLWRvdHMgPiBkaXYge1xuICAgICAgICBiYWNrZ3JvdW5kOiB3aGl0ZTtcbiAgICB9XG59XG5cbjwvc3R5bGU+XG4iLCI8c2NyaXB0PlxuaW1wb3J0IEJhc2VUeXBlIGZyb20gJy4vQmFzZVR5cGUnO1xuaW1wb3J0IHsgZXh0ZW5kIH0gZnJvbSAnbG9kYXNoJztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ2FjdGl2aXR5LWluZGljYXRvci1zcGlubmVyJyxcblxuICAgIGV4dGVuZHM6IEJhc2VUeXBlLFxuXG4gICAgcHJvcHM6IGV4dGVuZCh7fSwgQmFzZVR5cGUucHJvcHMsIHtcbiAgICAgICAgbm9kZXM6IHtcbiAgICAgICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgICAgIGRlZmF1bHQ6IDEyXG4gICAgICAgIH1cbiAgICB9KVxufVxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwic2Nzc1wiPlxuQGltcG9ydCAnLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwL3Njc3MvYm9vdHN0cmFwLXJlYm9vdC5zY3NzJztcblxuJGFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyLXNpemU6ICRmb250LXNpemUtYmFzZSAqIDIuMjU7XG4kYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXItd2lkdGg6IDEwJTtcbiRhY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lci1oZWlnaHQ6IDMwJTtcbiRhY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lci1kZWxheTogMXM7XG5cbkBtaXhpbiBzcGlubmVyLXJvdGF0ZS1zZWxlY3RvcnMoJHN0YXJ0OjEsICRlbmQ6MTYsICRkZWxheToxLjJzKSB7XG4gICAgQGZvciAkaSBmcm9tICRzdGFydCB0aHJvdWdoICRlbmQge1xuICAgICAgICAmID4gZGl2OmZpcnN0LWNoaWxkOm50aC1sYXN0LWNoaWxkKCN7JGl9KSxcbiAgICAgICAgJiA+IGRpdjpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCgjeyRpfSkgfiBkaXYge1xuICAgICAgICAgICAgQGluY2x1ZGUgc3Bpbm5lci1yb3RhdGUtdHJhbnNmb3JtKCRpLCAkZGVsYXkpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5AbWl4aW4gc3Bpbm5lci1yb3RhdGUtdHJhbnNmb3JtKCR0b3RhbCwgJGRlbGF5OjEuMnMpIHtcbiAgICBAZm9yICRpIGZyb20gMSB0aHJvdWdoICR0b3RhbCB7XG4gICAgICAgICY6bnRoLWNoaWxkKCN7JGl9KSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgjezM2MCAvICR0b3RhbCAqICRpfWRlZyk7XG5cbiAgICAgICAgICAgICY6YmVmb3JlIHtcbiAgICAgICAgICAgICAgICBhbmltYXRpb24tZGVsYXk6IC0jeyRkZWxheSAtICgkZGVsYXkgLyAkdG90YWwgKiAoJGkgLSAxKSl9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG4uYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIge1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICB3aWR0aDogJGFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyLXNpemU7XG4gICAgaGVpZ2h0OiAkYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXItc2l6ZTtcblxuICAgICYgPiBkaXYgIHtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICBsZWZ0OiAwO1xuICAgICAgICB0b3A6IDA7XG5cbiAgICAgICAgJjpiZWZvcmUge1xuICAgICAgICAgICAgY29udGVudDogJyc7XG4gICAgICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgICAgIG1hcmdpbjogMCBhdXRvO1xuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogJGdyYXktOTAwO1xuICAgICAgICAgICAgd2lkdGg6ICRhY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lci13aWR0aDtcbiAgICAgICAgICAgIGhlaWdodDogJGFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyLWhlaWdodDtcbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDVweDtcbiAgICAgICAgICAgIGFuaW1hdGlvbjogYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIgJGFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyLWRlbGF5IGluZmluaXRlIGVhc2UtaW4tb3V0IGJvdGg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAmLmFjdGl2aXR5LWluZGljYXRvci14cyB7XG4gICAgICAgIHdpZHRoOiAkYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXItc2l6ZSAqIC41O1xuICAgICAgICBoZWlnaHQ6ICRhY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lci1zaXplICogLjU7XG4gICAgfVxuICAgICYuYWN0aXZpdHktaW5kaWNhdG9yLXNtIHtcbiAgICAgICAgd2lkdGg6ICRhY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lci1zaXplICogLjc1O1xuICAgICAgICBoZWlnaHQ6ICRhY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lci1zaXplICogLjc1O1xuICAgIH1cbiAgICAmLmFjdGl2aXR5LWluZGljYXRvci1tZCB7XG4gICAgICAgIHdpZHRoOiAkYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXItc2l6ZSAqIDE7XG4gICAgICAgIGhlaWdodDogJGFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyLXNpemUgKiAxO1xuICAgIH1cbiAgICAmLmFjdGl2aXR5LWluZGljYXRvci1sZyB7XG4gICAgICAgIHdpZHRoOiAkYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXItc2l6ZSAqIDEuNTtcbiAgICAgICAgaGVpZ2h0OiAkYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXItc2l6ZSAqIDEuNTtcbiAgICB9XG4gICAgJi5hY3Rpdml0eS1pbmRpY2F0b3IteGwge1xuICAgICAgICB3aWR0aDogJGFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyLXNpemUgKiAyO1xuICAgICAgICBoZWlnaHQ6ICRhY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lci1zaXplICogMjtcbiAgICB9XG5cbiAgICBAaW5jbHVkZSBzcGlubmVyLXJvdGF0ZS1zZWxlY3RvcnMoMSwgMTIsICRhY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lci1kZWxheSk7XG5cbiAgICBAa2V5ZnJhbWVzIGFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyIHtcbiAgICAgICAgMCUsIDM5JSwgMTAwJSB7IG9wYWNpdHk6IDA7IH1cbiAgICAgICAgNDAlIHsgb3BhY2l0eTogMTsgfVxuICAgIH1cbn1cblxuLmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lciB7XG4gICAgJjpub3QoLmJ0bi13YXJuaW5nKSAuYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIgPiBkaXY6YmVmb3JlIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XG4gICAgfVxufVxuXG48L3N0eWxlPlxuIiwiPHRlbXBsYXRlPlxuICAgIDxkaXYgdi1pZj1cImNlbnRlclwiIGNsYXNzPVwiY2VudGVyLXdyYXBwZXJcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImNlbnRlci1jb250ZW50XCI+XG4gICAgICAgICAgICA8Y29tcG9uZW50IDppcz1cImNvbXBvbmVudFwiIDpzaXplPVwic2l6ZVwiIDpwcmVmaXg9XCJwcmVmaXhcIj48L2NvbXBvbmVudD5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICAgPGNvbXBvbmVudCB2LWVsc2UgOmlzPVwiY29tcG9uZW50XCIgOnNpemU9XCJzaXplXCIgIDpwcmVmaXg9XCJwcmVmaXhcIj48L2NvbXBvbmVudD5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgeyBleHRlbmQgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsga2ViYWJDYXNlIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBCYXNlVHlwZSBmcm9tICcuL1R5cGVzL0Jhc2VUeXBlJztcbmltcG9ydCBBY3Rpdml0eUluZGljYXRvckRvdHMgZnJvbSAnLi9UeXBlcy9Eb3RzJztcbmltcG9ydCBBY3Rpdml0eUluZGljYXRvclNwaW5uZXIgZnJvbSAnLi9UeXBlcy9TcGlubmVyJztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ2FjdGl2aXR5LWluZGljYXRvcicsXG5cbiAgICBleHRlbmRzOiBCYXNlVHlwZSxcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgY2VudGVyOiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgICAgfSxcblxuICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAnZG90cydcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgICAgQWN0aXZpdHlJbmRpY2F0b3JEb3RzLFxuICAgICAgICBBY3Rpdml0eUluZGljYXRvclNwaW5uZXJcbiAgICB9LFxuXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgY29tcG9uZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBrZWJhYkNhc2UodGhpcy5wcmVmaXggKyB0aGlzLnR5cGUucmVwbGFjZSh0aGlzLnByZWZpeCwgJycpKTtcbiAgICAgICAgfVxuICAgIH1cblxufVxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwic2Nzc1wiPlxuQGltcG9ydCAnLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwL3Njc3MvYm9vdHN0cmFwLXJlYm9vdC5zY3NzJztcblxuLy8gQWN0aXZpdHlJbmRpY2F0b3JzIE1peGluc1xuXG5AbWl4aW4gc3Bpbm5lci1jb2xvcigkY29sb3IpIHtcblxufVxuXG5Aa2V5ZnJhbWVzIGFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyIHtcbiAgICAwJSwgMzklLCAxMDAlIHsgb3BhY2l0eTogMDsgfVxuICAgIDQwJSB7IG9wYWNpdHk6IDE7IH1cbn1cblxuLy8gQ29udGVudCBQb3NpdGlvbmluZyBIZWxwZXJzXG4uY2VudGVyLXdyYXBwZXIge1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB0b3A6IDA7XG4gICAgbGVmdDogMDtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBoZWlnaHQ6IDEwMCU7XG59XG4uY2VudGVyLWNvbnRlbnQge1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB0b3A6IDUwJTtcbiAgICBsZWZ0OiA1MCU7XG4gICAgbWFyZ2luLXJpZ2h0OiAtNTAlO1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIC01MCUpXG59XG5cbjwvc3R5bGU+XG4iLCJpbXBvcnQgeyBpc0Z1bmN0aW9uIH0gZnJvbSAnbG9kYXNoJztcblxuY29uc3QgbG9hZGVkID0ge307XG5cbmZ1bmN0aW9uIGVsZW1lbnQodXJsKSB7XG4gICAgY29uc3Qgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgc2NyaXB0LnNldEF0dHJpYnV0ZSgnc3JjJywgdXJsKTtcbiAgICBzY3JpcHQuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQvamF2YXNjcmlwdCcpO1xuICAgIHNjcmlwdC5zZXRBdHRyaWJ1dGUoJ2NoYXJzZXQnLCAndXRmLTgnKTtcbiAgICByZXR1cm4gc2NyaXB0O1xufVxuXG5mdW5jdGlvbiBhcHBlbmQoc2NyaXB0KSB7XG4gICAgaWYoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaGVhZCcpKSB7XG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2hlYWQnKS5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYm9keScpLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNjcmlwdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2NyaXB0KHVybCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZighbG9hZGVkW3VybF0pIHtcbiAgICAgICAgICAgICAgICBhcHBlbmQoZWxlbWVudCh1cmwpKS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUobG9hZGVkW3VybF0gPSBlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc29sdmUobG9hZGVkW3VybF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoKGUpIHtcbiAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuIiwiaW1wb3J0IHsgZWFjaCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgc2NyaXB0IGZyb20gJy4uL1NjcmlwdCc7XG5cbmNvbnN0IFZ1ZUluc3RhbGxlciA9IHtcbiAgICB1c2UsXG4gICAgc2NyaXB0LFxuICAgIHBsdWdpbixcbiAgICBwbHVnaW5zLFxuICAgIGZpbHRlcixcbiAgICBmaWx0ZXJzLFxuICAgIGNvbXBvbmVudCxcbiAgICBjb21wb25lbnRzLFxuICAgIGRpcmVjdGl2ZSxcbiAgICBkaXJlY3RpdmVzLFxuICAgICRwbHVnaW5zOiB7fSxcbiAgICAkZmlsdGVyczoge30sXG4gICAgJGRpcmVjdGl2ZXM6IHt9LFxuICAgICRjb21wb25lbnRzOiB7fSxcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2UocGx1Z2luKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5WdWUpIHtcbiAgICAgICAgd2luZG93LlZ1ZS51c2UocGx1Z2luKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGx1Z2luO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGx1Z2luKFZ1ZSwgbmFtZSwgZGVmKSB7XG4gICAgaWYoIVZ1ZUluc3RhbGxlci4kcGx1Z2luc1tuYW1lXSkge1xuICAgICAgICBWdWUudXNlKFZ1ZUluc3RhbGxlci4kcGx1Z2luc1tuYW1lXSA9IGRlZik7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcGx1Z2lucyhWdWUsIHBsdWdpbnMpIHtcbiAgICBlYWNoKHBsdWdpbnMsIChkZWYsIG5hbWUpID0+IHtcbiAgICAgICAgcGx1Z2luKFZ1ZSwgbmFtZSwgZGVmKTtcbiAgICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlcihWdWUsIG5hbWUsIGRlZikge1xuICAgIGlmKCFWdWVJbnN0YWxsZXIuJGZpbHRlcnNbbmFtZV0pIHtcbiAgICAgICAgVnVlLnVzZShWdWVJbnN0YWxsZXIuJGZpbHRlcnNbbmFtZV0gPSBkZWYpO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlcnMoVnVlLCBmaWx0ZXJzKSB7XG4gICAgZWFjaChmaWx0ZXJzLCAoZGVmLCBuYW1lKSA9PiB7XG4gICAgICAgIGZpbHRlcihWdWUsIG5hbWUsIGRlZik7XG4gICAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wb25lbnQoVnVlLCBuYW1lLCBkZWYpIHtcbiAgICBpZighVnVlSW5zdGFsbGVyLiRjb21wb25lbnRzW25hbWVdKSB7XG4gICAgICAgIFZ1ZS5jb21wb25lbnQobmFtZSwgVnVlSW5zdGFsbGVyLiRjb21wb25lbnRzW25hbWVdID0gZGVmKTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wb25lbnRzKFZ1ZSwgY29tcG9uZW50cykge1xuICAgIGVhY2goY29tcG9uZW50cywgKGRlZiwgbmFtZSkgPT4ge1xuICAgICAgICBjb21wb25lbnQoVnVlLCBuYW1lLCBkZWYpO1xuICAgIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGlyZWN0aXZlKFZ1ZSwgbmFtZSwgZGVmKSB7XG4gICAgaWYoIVZ1ZUluc3RhbGxlci4kZGlyZWN0aXZlc1tuYW1lXSkge1xuICAgICAgICBWdWUuZGlyZWN0aXZlKG5hbWUsIFZ1ZUluc3RhbGxlci4kZGlyZWN0aXZlc1tuYW1lXSA9IGRlZik7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGlyZWN0aXZlcyhWdWUsIGRpcmVjdGl2ZXMpIHtcbiAgICBlYWNoKGRpcmVjdGl2ZXMsIChkZWYsIG5hbWUpID0+IHtcbiAgICAgICAgZGlyZWN0aXZlKFZ1ZSwgbmFtZSwgZGVmKTtcbiAgICB9KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgVnVlSW5zdGFsbGVyO1xuIiwiaW1wb3J0IEFjdGl2aXR5SW5kaWNhdG9yIGZyb20gJy4vQWN0aXZpdHlJbmRpY2F0b3InO1xuaW1wb3J0IFZ1ZUluc3RhbGxlciBmcm9tICdAL0hlbHBlcnMvVnVlSW5zdGFsbGVyL1Z1ZUluc3RhbGxlcic7XG5cbmNvbnN0IHBsdWdpbiA9IFZ1ZUluc3RhbGxlci51c2Uoe1xuXG4gICAgaW5zdGFsbChWdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgVnVlSW5zdGFsbGVyLmNvbXBvbmVudHMoe1xuICAgICAgICAgICAgQWN0aXZpdHlJbmRpY2F0b3JcbiAgICAgICAgfSk7XG4gICAgfVxuXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgQWN0aXZpdHlJbmRpY2F0b3I7XG4iLCI8dGVtcGxhdGU+XG4gICAgPGJ1dHRvbiA6dHlwZT1cInR5cGVcIiBjbGFzcz1cImJ0blwiIDpjbGFzcz1cImNsYXNzZXNcIiBAY2xpY2s9XCJvbkNsaWNrXCI+XG4gICAgICAgIDxzbG90PjxpIHYtaWY9XCJpY29uXCIgOmNsYXNzPVwiaWNvblwiLz4ge3tsYWJlbH19PC9zbG90PlxuICAgICAgICA8YWN0aXZpdHktaW5kaWNhdG9yIDp0eXBlPVwiaW5kaWNhdG9yXCIgLz5cbiAgICA8L2J1dHRvbj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgeyBleHRlbmQgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IEFjdGl2aXR5SW5kaWNhdG9yIGZyb20gJy4uL0FjdGl2aXR5SW5kaWNhdG9yJztcblxuY29uc3QgY29udmVydEFuaW1hdGlvbkRlbGF5VG9JbnQgPSBmdW5jdGlvbihkZWxheSkge1xuICAgIGNvbnN0IG51bSA9IHBhcnNlRmxvYXQoZGVsYXksIDEwKTtcbiAgICBjb25zdCBtYXRjaGVzID0gZGVsYXkubWF0Y2goL20/cy8pO1xuICAgIGNvbnN0IHVuaXQgPSBtYXRjaGVzID8gbWF0Y2hlc1swXSA6IGZhbHNlO1xuXG4gICAgbGV0IG1pbGxpc2Vjb25kcztcblxuICAgIHN3aXRjaCAodW5pdCkge1xuICAgICAgICBjYXNlIFwic1wiOiAvLyBzZWNvbmRzXG4gICAgICAgICAgICBtaWxsaXNlY29uZHMgPSBudW0gKiAxMDAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJtc1wiOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gbnVtO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1pbGxpc2Vjb25kcyB8fCAwO1xufTtcblxuY29uc3QgYW5pbWF0ZWQgPSBmdW5jdGlvbihlbCwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBkZWZhdWx0VmlldyA9IChlbC5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50KS5kZWZhdWx0VmlldztcblxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjYWxsYmFjay5hcHBseSgpO1xuICAgIH0sIGNvbnZlcnRBbmltYXRpb25EZWxheVRvSW50KGRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoZWwpLmFuaW1hdGlvbkR1cmF0aW9uKSk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAnYWN0aXZpdHktYnV0dG9uJyxcblxuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgICAgQWN0aXZpdHlJbmRpY2F0b3JcbiAgICB9LFxuXG4gICAgcHJvcHM6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvdWxkIHNob3cgdGhlIGFjdGl2aXR5IGluZGljYXRvciBpbnNpZGUgdGhlIGJ1dHRvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IEJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIGFjdGl2aXR5OiBCb29sZWFuLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG91bGQgc2hvdyB0aGUgYnV0dG9uIGFzIGRpc2FibGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgQm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgZGlzYWJsZWQ6IEJvb2xlYW4sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc3BsYXkgdGhlIGJ1dHRvbiBhcyBibG9jayB3aWR0aC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IEJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIGJsb2NrOiBCb29sZWFuLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYnV0dG9uIGxhYmVsLiBJZiBub3QgcGFzc2VkIGFzIGEgcHJvcGVydHksIGxhYmVsIG11c3QgYmUgcGFzc2VkXG4gICAgICAgICAqIGluc2lkZSB0aGUgZWxlbWVudCdzIGh0bWwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGxhYmVsOiBTdHJpbmcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBidXR0b24gaWNvblxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBpY29uOiBTdHJpbmcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzaXplIG9mIHRoZSBidXR0b24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHNpemU6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdtZCdcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGJvb3RzdHJhcCB2YXJpYW50IG9mIHRoZSBidXR0b24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHZhcmlhbnQ6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdwcmltYXJ5J1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYHR5cGVgIGF0dHJpYnV0ZSBmb3IgdGhlIGJ1dHRvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJ2J1dHRvbidcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHR5cGUgb2YgYWN0aXZpdHkgaW5kaWNhdG9yIGluc2lkZSB0aGUgYnV0dG9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBpbmRpY2F0b3I6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdzcGlubmVyJ1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgb3JpZW50YXRpb24gb2YgdGhlIGFjdGl2aXR5IGJ1dHRvbiBpbnNpZGUgdGhlIGJ1dHRvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgb3JpZW50YXRpb246IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdyaWdodCdcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtZXRob2RzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc2FibGUgdGhlIGJ1dHRvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB2b2lkXG4gICAgICAgICAqL1xuICAgICAgICBkaXNhYmxlKCkge1xuICAgICAgICAgICAgdGhpcy4kZWwuZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmFibGUgdGhlIGJ1dHRvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB2b2lkXG4gICAgICAgICAqL1xuICAgICAgICBlbmFibGUoKSB7XG4gICAgICAgICAgICB0aGlzLiRlbC5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG93IHRoZSBhY3Rpdml0eSBpbmRpY2F0b3IgaW5zaWRlIHRoZSBidXR0b24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAgICAgKi9cbiAgICAgICAgc2hvd0FjdGl2aXR5KCkge1xuICAgICAgICAgICAgdGhpcy5kaXNhYmxlKCk7XG5cbiAgICAgICAgICAgIGFuaW1hdGVkKHRoaXMuJGVsLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy4kZWwuY2xhc3NMaXN0LmFkZCgnYnRuLWFjdGl2aXR5Jyk7XG4gICAgICAgICAgICAgICAgdGhpcy4kZW1pdCgnYWN0aXZpdHk6c2hvdycpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhpZGUgdGhlIGFjdGl2aXR5IGluZGljYXRvciBpbnNpZGUgdGhlIGJ1dHRvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB2b2lkXG4gICAgICAgICAqL1xuICAgICAgICBoaWRlQWN0aXZpdHkoKSB7XG4gICAgICAgICAgICB0aGlzLiRlbC5jbGFzc0xpc3QuYWRkKCdidG4taGlkZS1hY3Rpdml0eScpO1xuXG4gICAgICAgICAgICBhbmltYXRlZCh0aGlzLiRlbCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZW5hYmxlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy4kZWwuY2xhc3NMaXN0LnJlbW92ZSgnYnRuLWFjdGl2aXR5JywgJ2J0bi1oaWRlLWFjdGl2aXR5Jyk7XG4gICAgICAgICAgICAgICAgdGhpcy4kZW1pdCgnYWN0aXZpdHk6aGlkZScpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc2FibGUgdGhlIGJ1dHRvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB2b2lkXG4gICAgICAgICAqL1xuICAgICAgICBvbkNsaWNrKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCdjbGljaycsIGV2ZW50LCB0aGlzKTtcbiAgICAgICAgfSxcbiAgICB9LFxuXG4gICAgY29tcHV0ZWQ6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gb2JqZWN0IG9mIGNsYXNzZXMgdG8gYXBwZW5kIHRvIHRoZSBidXR0b24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NlcygpIHtcbiAgICAgICAgICAgIGNvbnN0IGNsYXNzZXMgPSB7XG4gICAgICAgICAgICAgICAgJ2J0bi1ibG9jayc6IHRoaXMuYmxvY2ssXG4gICAgICAgICAgICAgICAgJ2J0bi1hY3Rpdml0eSc6IHRoaXMuYWN0aXZpdHlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGNsYXNzZXNbJ2J0bi0nICsgdGhpcy5zaXplLnJlcGxhY2UoJ2J0bi0nLCAnJyldID0gISF0aGlzLnNpemU7XG4gICAgICAgICAgICBjbGFzc2VzWydidG4tJyArIHRoaXMudmFyaWFudC5yZXBsYWNlKCdidG4tJywgJycpXSA9ICEhdGhpcy52YXJpYW50O1xuICAgICAgICAgICAgY2xhc3Nlc1snYnRuLWFjdGl2aXR5LScgKyB0aGlzLm9yaWVudGF0aW9uLnJlcGxhY2UoJ2J0bi1hY3Rpdml0eS0nLCAnJyldID0gISF0aGlzLm9yaWVudGF0aW9uO1xuICAgICAgICAgICAgY2xhc3Nlc1snYnRuLWFjdGl2aXR5LWluZGljYXRvci0nICsgdGhpcy5pbmRpY2F0b3IucmVwbGFjZSgnYnRuLWFjdGl2aXR5LWluZGljYXRvci0nLCAnJyldID0gISF0aGlzLmluZGljYXRvcjtcblxuICAgICAgICAgICAgcmV0dXJuIGNsYXNzZXM7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgd2F0Y2g6IHtcblxuICAgICAgICBhY3Rpdml0eSh2YWx1ZSkge1xuICAgICAgICAgICAgaWYodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNob3dBY3Rpdml0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWRlQWN0aXZpdHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfVxuXG59XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJzY3NzXCI+XG5AaW1wb3J0ICcuL25vZGVfbW9kdWxlcy9ib290c3RyYXAvc2Nzcy9ib290c3RyYXAtcmVib290LnNjc3MnO1xuXG4vLyBBY3Rpdml0eSBJbmRpY2F0b3IgdmFyaWFibGVzXG4kYWN0aXZpdHktaW5kaWNhdG9yLWFuaW1hdGVkLWRlbGF5LWluOiAzMzNtcztcbiRhY3Rpdml0eS1pbmRpY2F0b3ItYW5pbWF0ZWQtZGVsYXktb3V0OiAzMzNtcztcblxuJGFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyLXNpemU6ICRmb250LXNpemUtYmFzZSAqIDIuMjU7XG4kYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXItd2lkdGg6IDEwJTtcbiRhY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lci1oZWlnaHQ6IDMwJTtcbiRhY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lci1kZWxheTogMXM7XG5cbkBrZXlmcmFtZXMgYnRuLWFjdGl2aXR5LWluIHtcbiAgICAwJSwgMTAwJSB7XG4gICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMSk7XG4gICAgfSAzMCUge1xuICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKC45OCk7XG4gICAgfVxufVxuXG5Aa2V5ZnJhbWVzIGJ0bi1hY3Rpdml0eS1vdXQge1xuICAgIDAlLCAxMDAlIHtcbiAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgxKTtcbiAgICB9IDcwJSB7XG4gICAgICAgIHRyYW5zZm9ybTogc2NhbGUoLjk4KTtcbiAgICB9XG59XG5cbi8vIEFjdGl2aXR5IEluZGljYXRvciBCdXR0b25cbi5idG4tYWN0aXZpdHktdG9wLFxuLmJ0bi1hY3Rpdml0eS1ib3R0b20sXG4uYnRuLWFjdGl2aXR5LWxlZnQsXG4uYnRuLWFjdGl2aXR5LXJpZ2h0IHtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgdHJhbnNpdGlvbjogcGFkZGluZyAoJGFjdGl2aXR5LWluZGljYXRvci1hbmltYXRlZC1kZWxheS1pbiAvIDIpIGVhc2UtaW47XG5cbiAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICBvcGFjaXR5OiAwO1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcbiAgICAgICAgdHJhbnNpdGlvbjogb3BhY2l0eSAkYWN0aXZpdHktaW5kaWNhdG9yLWFuaW1hdGVkLWRlbGF5LW91dCBlYXNlLWluO1xuICAgIH1cbn1cblxuLmJ0bi1hY3Rpdml0eS10b3AgLmFjdGl2aXR5LWluZGljYXRvcixcbi5idG4tYWN0aXZpdHktYm90dG9tIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgIGxlZnQ6IDUwJTtcbiAgICBtYXJnaW4tcmlnaHQ6IC01MCU7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MCUpO1xufVxuLmJ0bi1hY3Rpdml0eS1sZWZ0IC5hY3Rpdml0eS1pbmRpY2F0b3IsXG4uYnRuLWFjdGl2aXR5LXJpZ2h0IC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgIHRvcDogNTAlO1xuICAgIG1hcmdpbi1ib3R0b206IC01MCU7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC01MCUpO1xufVxuXG4uYnRuLWFjdGl2aXR5Om5vdCguYnRuLWxpbmspIHtcbiAgICBhbmltYXRpb246IGJ0bi1hY3Rpdml0eS1pbiAkYWN0aXZpdHktaW5kaWNhdG9yLWFuaW1hdGVkLWRlbGF5LWluO1xufVxuLmJ0bi1oaWRlLWFjdGl2aXR5Om5vdCguYnRuLWxpbmspIHtcbiAgICBhbmltYXRpb246IGJ0bi1hY3Rpdml0eS1vdXQgJGFjdGl2aXR5LWluZGljYXRvci1hbmltYXRlZC1kZWxheS1vdXQ7XG59XG5cbi5idG4tYWN0aXZpdHkge1xuXG4gICAgJi5idG4taGlkZS1hY3Rpdml0eSAuYWN0aXZpdHktaW5kaWNhdG9yIHtcbiAgICAgICAgb3BhY2l0eTogMDtcbiAgICB9XG5cbiAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICBvcGFjaXR5OiAxO1xuICAgICAgICB2aXNpYmlsaXR5OiB2aXNpYmxlO1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgfVxuXG4gICAgJi5idG4tb3V0bGluZS1wcmltYXJ5LmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lciAuYWN0aXZpdHktaW5kaWNhdG9yID4gZGl2OmJlZm9yZSB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICRwcmltYXJ5O1xuICAgIH1cbiAgICAmLmJ0bi1vdXRsaW5lLXNlY29uZGFyeS5idG4tYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIgLmFjdGl2aXR5LWluZGljYXRvciA+IGRpdjpiZWZvcmUge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkc3VjY2VzcztcbiAgICB9XG4gICAgJi5idG4tb3V0bGluZS1kYW5nZXIuYnRuLWFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyIC5hY3Rpdml0eS1pbmRpY2F0b3IgPiBkaXY6YmVmb3JlIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogJGRhbmdlcjtcbiAgICB9XG4gICAgJi5idG4tb3V0bGluZS1zdWNjZXNzLmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lciAuYWN0aXZpdHktaW5kaWNhdG9yID4gZGl2OmJlZm9yZSB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICRzdWNjZXNzO1xuICAgIH1cbiAgICAmLmJ0bi1vdXRsaW5lLXdhcm5pbmcuYnRuLWFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyIC5hY3Rpdml0eS1pbmRpY2F0b3IgPiBkaXY6YmVmb3JlIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogJHdhcm5pbmc7XG4gICAgfVxuICAgICYuYnRuLW91dGxpbmUtaW5mby5idG4tYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIgLmFjdGl2aXR5LWluZGljYXRvciA+IGRpdjpiZWZvcmUge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkaW5mbztcbiAgICB9XG4gICAgJi5idG4tb3V0bGluZS1saW5rLmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lciAuYWN0aXZpdHktaW5kaWNhdG9yID4gZGl2OmJlZm9yZSB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICRsaW5rLWNvbG9yO1xuICAgIH1cblxuICAgICYuYnRuLXhzIHtcbiAgICAgICAgJi5idG4tYWN0aXZpdHktdG9wLmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyB7XG4gICAgICAgICAgICBwYWRkaW5nLXRvcDogJGZvbnQtc2l6ZS1iYXNlICogMS4yNTtcblxuICAgICAgICAgICAgJiAuYWN0aXZpdHktaW5kaWNhdG9yIHtcbiAgICAgICAgICAgICAgICB0b3A6ICRmb250LXNpemUtYmFzZSAqIC41O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJi5idG4tYWN0aXZpdHktYm90dG9tLmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyB7XG4gICAgICAgICAgICBwYWRkaW5nLWJvdHRvbTogJGZvbnQtc2l6ZS1iYXNlICogMS4yNTtcblxuICAgICAgICAgICAgJiAuYWN0aXZpdHktaW5kaWNhdG9yIHtcbiAgICAgICAgICAgICAgICBib3R0b206ICRmb250LXNpemUtYmFzZSAqIC41O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJi5idG4tYWN0aXZpdHktbGVmdC5idG4tYWN0aXZpdHktaW5kaWNhdG9yLWRvdHMge1xuICAgICAgICAgICAgcGFkZGluZy1sZWZ0OiAkZm9udC1zaXplLWJhc2UgKiAyLjMzO1xuXG4gICAgICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICAgICAgICAgIGxlZnQ6ICRmb250LXNpemUtYmFzZSAqIC41O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJi5idG4tYWN0aXZpdHktcmlnaHQuYnRuLWFjdGl2aXR5LWluZGljYXRvci1kb3RzIHtcbiAgICAgICAgICAgIHBhZGRpbmctcmlnaHQ6ICRmb250LXNpemUtYmFzZSAqIDIuMzM7XG5cbiAgICAgICAgICAgICYgLmFjdGl2aXR5LWluZGljYXRvciB7XG4gICAgICAgICAgICAgICAgcmlnaHQ6ICRmb250LXNpemUtYmFzZSAqIC41O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJi5idG4tYWN0aXZpdHktaW5kaWNhdG9yLWRvdHMgLmFjdGl2aXR5LWluZGljYXRvciA+IGRpdixcbiAgICAgICAgJiAuYWN0aXZpdHktaW5kaWNhdG9yLWRvdHMgPiBkaXYge1xuICAgICAgICAgICAgd2lkdGg6ICRmb250LXNpemUtYmFzZSAvIDM7XG4gICAgICAgICAgICBoZWlnaHQ6ICRmb250LXNpemUtYmFzZSAvIDM7XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS10b3AuYnRuLWFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyIHtcbiAgICAgICAgICAgIHBhZGRpbmctdG9wOiAkZm9udC1zaXplLWJhc2UgKiAxLjY2O1xuXG4gICAgICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICAgICAgICAgIHRvcDogJGZvbnQtc2l6ZS1iYXNlICogLjI1O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJi5idG4tYWN0aXZpdHktYm90dG9tLmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lciB7XG4gICAgICAgICAgICBwYWRkaW5nLWJvdHRvbTogJGZvbnQtc2l6ZS1iYXNlICogMS42NjtcblxuICAgICAgICAgICAgJiAuYWN0aXZpdHktaW5kaWNhdG9yIHtcbiAgICAgICAgICAgICAgICBib3R0b206ICRmb250LXNpemUtYmFzZSAqIC4yNTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICYuYnRuLWFjdGl2aXR5LWxlZnQuYnRuLWFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyIHtcbiAgICAgICAgICAgIHBhZGRpbmctbGVmdDogJGZvbnQtc2l6ZS1iYXNlICogMS42NjtcblxuICAgICAgICAgICAgJiAuYWN0aXZpdHktaW5kaWNhdG9yIHtcbiAgICAgICAgICAgICAgICBsZWZ0OiAkZm9udC1zaXplLWJhc2UgKiAuMjU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1yaWdodC5idG4tYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIge1xuICAgICAgICAgICAgcGFkZGluZy1yaWdodDogJGZvbnQtc2l6ZS1iYXNlICogMS42NjtcblxuICAgICAgICAgICAgJiAuYWN0aXZpdHktaW5kaWNhdG9yIHtcbiAgICAgICAgICAgICAgICByaWdodDogJGZvbnQtc2l6ZS1iYXNlICogLjI1O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJi5idG4tYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIgLmFjdGl2aXR5LWluZGljYXRvcixcbiAgICAgICAgJiAuYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIge1xuICAgICAgICAgICAgd2lkdGg6ICRmb250LXNpemUtYmFzZSAqIDE7XG4gICAgICAgICAgICBoZWlnaHQ6ICRmb250LXNpemUtYmFzZSAqIDE7XG5cbiAgICAgICAgICAgICYgPiBkaXY6YmVmb3JlIHtcbiAgICAgICAgICAgICAgICAvL3dpZHRoOiAkYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXItd2lkdGggKiAuNjM7XG4gICAgICAgICAgICAgICAgLy9oZWlnaHQ6ICRhY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lci1oZWlnaHQgKiAuNjY7XG4gICAgICAgICAgICAgICAgd2lkdGg6ICRhY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lci13aWR0aCAqIC44NDtcbiAgICAgICAgICAgICAgICBoZWlnaHQ6ICRhY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lci1oZWlnaHQgKiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgJi5idG4tc20ge1xuICAgICAgICAmLmJ0bi1hY3Rpdml0eS10b3AuYnRuLWFjdGl2aXR5LWluZGljYXRvci1kb3RzIHtcbiAgICAgICAgICAgIHBhZGRpbmctdG9wOiAkZm9udC1zaXplLWJhc2UgKiAxLjc1O1xuXG4gICAgICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICAgICAgICAgIHRvcDogJGZvbnQtc2l6ZS1iYXNlICogLjU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1ib3R0b20uYnRuLWFjdGl2aXR5LWluZGljYXRvci1kb3RzIHtcbiAgICAgICAgICAgIHBhZGRpbmctYm90dG9tOiAkZm9udC1zaXplLWJhc2UgKiAxLjc1O1xuXG4gICAgICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICAgICAgICAgIGJvdHRvbTogJGZvbnQtc2l6ZS1iYXNlICogLjU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1sZWZ0LmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyB7XG4gICAgICAgICAgICBwYWRkaW5nLWxlZnQ6ICRmb250LXNpemUtYmFzZSAqIDM7XG5cbiAgICAgICAgICAgICYgLmFjdGl2aXR5LWluZGljYXRvciB7XG4gICAgICAgICAgICAgICAgbGVmdDogJGZvbnQtc2l6ZS1iYXNlICogLjU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1yaWdodC5idG4tYWN0aXZpdHktaW5kaWNhdG9yLWRvdHMge1xuICAgICAgICAgICAgcGFkZGluZy1yaWdodDogJGZvbnQtc2l6ZS1iYXNlICogMztcblxuICAgICAgICAgICAgJiAuYWN0aXZpdHktaW5kaWNhdG9yIHtcbiAgICAgICAgICAgICAgICByaWdodDogJGZvbnQtc2l6ZS1iYXNlICogLjU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyAuYWN0aXZpdHktaW5kaWNhdG9yID4gZGl2LFxuICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyA+IGRpdiB7XG4gICAgICAgICAgICB3aWR0aDogJGZvbnQtc2l6ZS1iYXNlIC8gMjtcbiAgICAgICAgICAgIGhlaWdodDogJGZvbnQtc2l6ZS1iYXNlIC8gMjtcbiAgICAgICAgfVxuXG4gICAgICAgICYuYnRuLWFjdGl2aXR5LXRvcC5idG4tYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIge1xuICAgICAgICAgICAgcGFkZGluZy10b3A6ICRmb250LXNpemUtYmFzZSAqIDI7XG5cbiAgICAgICAgICAgICYgLmFjdGl2aXR5LWluZGljYXRvciB7XG4gICAgICAgICAgICAgICAgdG9wOiAkZm9udC1zaXplLWJhc2UgKiAuMzM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1ib3R0b20uYnRuLWFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyIHtcbiAgICAgICAgICAgIHBhZGRpbmctYm90dG9tOiAkZm9udC1zaXplLWJhc2UgKiAyO1xuXG4gICAgICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICAgICAgICAgIGJvdHRvbTogJGZvbnQtc2l6ZS1iYXNlICogLjMzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJi5idG4tYWN0aXZpdHktbGVmdC5idG4tYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIge1xuICAgICAgICAgICAgcGFkZGluZy1sZWZ0OiAkZm9udC1zaXplLWJhc2UgKiAyLjU7XG5cbiAgICAgICAgICAgICYgLmFjdGl2aXR5LWluZGljYXRvciB7XG4gICAgICAgICAgICAgICAgbGVmdDogJGZvbnQtc2l6ZS1iYXNlICogLjU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1yaWdodC5idG4tYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIge1xuICAgICAgICAgICAgcGFkZGluZy1yaWdodDogJGZvbnQtc2l6ZS1iYXNlICogMi41O1xuXG4gICAgICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICAgICAgICAgIHJpZ2h0OiAkZm9udC1zaXplLWJhc2UgKiAuNTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICYuYnRuLWFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyIC5hY3Rpdml0eS1pbmRpY2F0b3IsXG4gICAgICAgICYgLmFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyIHtcbiAgICAgICAgICAgIHdpZHRoOiAkZm9udC1zaXplLWJhc2UgKiAxLjU7XG4gICAgICAgICAgICBoZWlnaHQ6ICRmb250LXNpemUtYmFzZSAqIDEuNTtcblxuICAgICAgICAgICAgJiA+IGRpdjpiZWZvcmUge1xuICAgICAgICAgICAgICAgIHdpZHRoOiAkYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXItd2lkdGggKiAuNTY7XG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAkYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXItaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgJjpub3QoLmJ0bi14cyk6bm90KC5idG4tc20pOm5vdCguYnRuLW1kKTpub3QoLmJ0bi1sZyk6bm90KC5idG4teGwpLFxuICAgICYuYnRuLW1kIHtcbiAgICAgICAgJi5idG4tYWN0aXZpdHktdG9wLmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyB7XG4gICAgICAgICAgICBwYWRkaW5nLXRvcDogJGZvbnQtc2l6ZS1iYXNlICogMjtcblxuICAgICAgICAgICAgJiAuYWN0aXZpdHktaW5kaWNhdG9yIHtcbiAgICAgICAgICAgICAgICB0b3A6ICRmb250LXNpemUtYmFzZSAqIC42NjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICYuYnRuLWFjdGl2aXR5LWJvdHRvbS5idG4tYWN0aXZpdHktaW5kaWNhdG9yLWRvdHMge1xuICAgICAgICAgICAgcGFkZGluZy1ib3R0b206ICRmb250LXNpemUtYmFzZSAqIDI7XG5cbiAgICAgICAgICAgICYgLmFjdGl2aXR5LWluZGljYXRvciB7XG4gICAgICAgICAgICAgICAgYm90dG9tOiAkZm9udC1zaXplLWJhc2UgKiAuNjY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1sZWZ0LmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyB7XG4gICAgICAgICAgICBwYWRkaW5nLWxlZnQ6ICRmb250LXNpemUtYmFzZSAqIDQ7XG5cbiAgICAgICAgICAgICYgLmFjdGl2aXR5LWluZGljYXRvciB7XG4gICAgICAgICAgICAgICAgbGVmdDogJGZvbnQtc2l6ZS1iYXNlICogLjU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1yaWdodC5idG4tYWN0aXZpdHktaW5kaWNhdG9yLWRvdHMge1xuICAgICAgICAgICAgcGFkZGluZy1yaWdodDogJGZvbnQtc2l6ZS1iYXNlICogNDtcblxuICAgICAgICAgICAgJiAuYWN0aXZpdHktaW5kaWNhdG9yIHtcbiAgICAgICAgICAgICAgICByaWdodDogJGZvbnQtc2l6ZS1iYXNlICogLjU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyAuYWN0aXZpdHktaW5kaWNhdG9yID4gZGl2LFxuICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyA+IGRpdiB7XG4gICAgICAgICAgICB3aWR0aDogJGZvbnQtc2l6ZS1iYXNlIC8gMS4yNTtcbiAgICAgICAgICAgIGhlaWdodDogJGZvbnQtc2l6ZS1iYXNlIC8gMS4yNTtcbiAgICAgICAgfVxuXG4gICAgICAgICYuYnRuLWFjdGl2aXR5LXRvcC5idG4tYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIge1xuICAgICAgICAgICAgcGFkZGluZy10b3A6ICRmb250LXNpemUtYmFzZSAqIDIuNzU7XG5cbiAgICAgICAgICAgICYgLmFjdGl2aXR5LWluZGljYXRvciB7XG4gICAgICAgICAgICAgICAgdG9wOiAkZm9udC1zaXplLWJhc2UgKiAuMzM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1ib3R0b20uYnRuLWFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyIHtcbiAgICAgICAgICAgIHBhZGRpbmctYm90dG9tOiAkZm9udC1zaXplLWJhc2UgKiAyLjc1O1xuXG4gICAgICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICAgICAgICAgIGJvdHRvbTogJGZvbnQtc2l6ZS1iYXNlICogLjMzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJi5idG4tYWN0aXZpdHktbGVmdC5idG4tYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIge1xuICAgICAgICAgICAgcGFkZGluZy1sZWZ0OiAkZm9udC1zaXplLWJhc2UgKiAyLjc1O1xuXG4gICAgICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICAgICAgICAgIGxlZnQ6ICRmb250LXNpemUtYmFzZSAqIC41O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJi5idG4tYWN0aXZpdHktcmlnaHQuYnRuLWFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyIHtcbiAgICAgICAgICAgIHBhZGRpbmctcmlnaHQ6ICRmb250LXNpemUtYmFzZSAqIDIuNzU7XG5cbiAgICAgICAgICAgICYgLmFjdGl2aXR5LWluZGljYXRvciB7XG4gICAgICAgICAgICAgICAgcmlnaHQ6ICRmb250LXNpemUtYmFzZSAqIC41O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJi5idG4tYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIgLmFjdGl2aXR5LWluZGljYXRvcixcbiAgICAgICAgJiAuYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIge1xuICAgICAgICAgICAgd2lkdGg6ICRmb250LXNpemUtYmFzZSAqIDEuNzU7XG4gICAgICAgICAgICBoZWlnaHQ6ICRmb250LXNpemUtYmFzZSAqIDEuNzU7XG5cbiAgICAgICAgICAgICYgPiBkaXY6YmVmb3JlIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogJGFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyLXdpZHRoICogLjY2O1xuICAgICAgICAgICAgICAgIGhlaWdodDogJGFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyLWhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgICYuYnRuLWxnIHtcbiAgICAgICAgJi5idG4tYWN0aXZpdHktdG9wLmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyB7XG4gICAgICAgICAgICBwYWRkaW5nLXRvcDogJGZvbnQtc2l6ZS1iYXNlICogMi43NTtcblxuICAgICAgICAgICAgJiAuYWN0aXZpdHktaW5kaWNhdG9yIHtcbiAgICAgICAgICAgICAgICB0b3A6ICRmb250LXNpemUtYmFzZSAqIC42NjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICYuYnRuLWFjdGl2aXR5LWJvdHRvbS5idG4tYWN0aXZpdHktaW5kaWNhdG9yLWRvdHMge1xuICAgICAgICAgICAgcGFkZGluZy1ib3R0b206ICRmb250LXNpemUtYmFzZSAqIDIuNzU7XG5cbiAgICAgICAgICAgICYgLmFjdGl2aXR5LWluZGljYXRvciB7XG4gICAgICAgICAgICAgICAgYm90dG9tOiAkZm9udC1zaXplLWJhc2UgKiAuNjY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1sZWZ0LmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyB7XG4gICAgICAgICAgICBwYWRkaW5nLWxlZnQ6ICRmb250LXNpemUtYmFzZSAqIDU7XG5cbiAgICAgICAgICAgICYgLmFjdGl2aXR5LWluZGljYXRvciB7XG4gICAgICAgICAgICAgICAgbGVmdDogJGZvbnQtc2l6ZS1iYXNlICogLjU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1yaWdodC5idG4tYWN0aXZpdHktaW5kaWNhdG9yLWRvdHMge1xuICAgICAgICAgICAgcGFkZGluZy1yaWdodDogJGZvbnQtc2l6ZS1iYXNlICogNTtcblxuICAgICAgICAgICAgJiAuYWN0aXZpdHktaW5kaWNhdG9yIHtcbiAgICAgICAgICAgICAgICByaWdodDogJGZvbnQtc2l6ZS1iYXNlICogLjU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyAuYWN0aXZpdHktaW5kaWNhdG9yID4gZGl2LFxuICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyA+IGRpdiB7XG4gICAgICAgICAgICB3aWR0aDogJGZvbnQtc2l6ZS1iYXNlICogMS4xO1xuICAgICAgICAgICAgaGVpZ2h0OiAkZm9udC1zaXplLWJhc2UgKiAxLjE7XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS10b3AuYnRuLWFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyIHtcbiAgICAgICAgICAgIHBhZGRpbmctdG9wOiAkZm9udC1zaXplLWJhc2UgKiAzLjU7XG5cbiAgICAgICAgICAgICYgLmFjdGl2aXR5LWluZGljYXRvciB7XG4gICAgICAgICAgICAgICAgdG9wOiAkZm9udC1zaXplLWJhc2UgKiAuNTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICYuYnRuLWFjdGl2aXR5LWJvdHRvbS5idG4tYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIge1xuICAgICAgICAgICAgcGFkZGluZy1ib3R0b206ICRmb250LXNpemUtYmFzZSAqIDMuNTtcblxuICAgICAgICAgICAgJiAuYWN0aXZpdHktaW5kaWNhdG9yIHtcbiAgICAgICAgICAgICAgICBib3R0b206ICRmb250LXNpemUtYmFzZSAqIC41O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJi5idG4tYWN0aXZpdHktbGVmdC5idG4tYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIge1xuICAgICAgICAgICAgcGFkZGluZy1sZWZ0OiAkZm9udC1zaXplLWJhc2UgKiAzLjI1O1xuXG4gICAgICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICAgICAgICAgIGxlZnQ6ICRmb250LXNpemUtYmFzZSAqIC41O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJi5idG4tYWN0aXZpdHktcmlnaHQuYnRuLWFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyIHtcbiAgICAgICAgICAgIHBhZGRpbmctcmlnaHQ6ICRmb250LXNpemUtYmFzZSAqIDMuMjU7XG5cbiAgICAgICAgICAgICYgLmFjdGl2aXR5LWluZGljYXRvciB7XG4gICAgICAgICAgICAgICAgcmlnaHQ6ICRmb250LXNpemUtYmFzZSAqIC41O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJi5idG4tYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIgLmFjdGl2aXR5LWluZGljYXRvcixcbiAgICAgICAgJiAuYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIge1xuICAgICAgICAgICAgd2lkdGg6ICRmb250LXNpemUtYmFzZSAqIDIuMTU7XG4gICAgICAgICAgICBoZWlnaHQ6ICRmb250LXNpemUtYmFzZSAqIDIuMTU7XG5cbiAgICAgICAgICAgICYgPiBkaXY6YmVmb3JlIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogJGFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyLXdpZHRoICogLjc1O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgJi5idG4teGwge1xuICAgICAgICAmLmJ0bi1hY3Rpdml0eS10b3AuYnRuLWFjdGl2aXR5LWluZGljYXRvci1kb3RzIHtcbiAgICAgICAgICAgIHBhZGRpbmctdG9wOiAkZm9udC1zaXplLWJhc2UgKiAzLjc1O1xuXG4gICAgICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICAgICAgICAgIHRvcDogJGZvbnQtc2l6ZS1iYXNlICogMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICYuYnRuLWFjdGl2aXR5LWJvdHRvbS5idG4tYWN0aXZpdHktaW5kaWNhdG9yLWRvdHMge1xuICAgICAgICAgICAgcGFkZGluZy1ib3R0b206ICRmb250LXNpemUtYmFzZSAqIDMuNzU7XG5cbiAgICAgICAgICAgICYgLmFjdGl2aXR5LWluZGljYXRvciB7XG4gICAgICAgICAgICAgICAgYm90dG9tOiAkZm9udC1zaXplLWJhc2UgKiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJi5idG4tYWN0aXZpdHktbGVmdC5idG4tYWN0aXZpdHktaW5kaWNhdG9yLWRvdHMge1xuICAgICAgICAgICAgcGFkZGluZy1sZWZ0OiAkZm9udC1zaXplLWJhc2UgKiA2O1xuXG4gICAgICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICAgICAgICAgIGxlZnQ6ICRmb250LXNpemUtYmFzZSAqIC43NTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICYuYnRuLWFjdGl2aXR5LXJpZ2h0LmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyB7XG4gICAgICAgICAgICBwYWRkaW5nLXJpZ2h0OiAkZm9udC1zaXplLWJhc2UgKiA2O1xuXG4gICAgICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICAgICAgICAgIHJpZ2h0OiAkZm9udC1zaXplLWJhc2UgKiAuNzU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyAuYWN0aXZpdHktaW5kaWNhdG9yID4gZGl2LFxuICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyA+IGRpdiB7XG4gICAgICAgICAgICB3aWR0aDogJGZvbnQtc2l6ZS1iYXNlICogMS4yNTtcbiAgICAgICAgICAgIGhlaWdodDogJGZvbnQtc2l6ZS1iYXNlICogMS4yNTtcbiAgICAgICAgfVxuXG4gICAgICAgICYuYnRuLWFjdGl2aXR5LXRvcC5idG4tYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIge1xuICAgICAgICAgICAgcGFkZGluZy10b3A6ICRmb250LXNpemUtYmFzZSAqIDQuMjU7XG5cbiAgICAgICAgICAgICYgLmFjdGl2aXR5LWluZGljYXRvciB7XG4gICAgICAgICAgICAgICAgdG9wOiAkZm9udC1zaXplLWJhc2UgKiAuNjY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1ib3R0b20uYnRuLWFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyIHtcbiAgICAgICAgICAgIHBhZGRpbmctYm90dG9tOiAkZm9udC1zaXplLWJhc2UgKiA0LjI1O1xuXG4gICAgICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICAgICAgICAgIGJvdHRvbTogJGZvbnQtc2l6ZS1iYXNlICogLjY2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJi5idG4tYWN0aXZpdHktbGVmdC5idG4tYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIge1xuICAgICAgICAgICAgcGFkZGluZy1sZWZ0OiAkZm9udC1zaXplLWJhc2UgKiA0O1xuXG4gICAgICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICAgICAgICAgIGxlZnQ6ICRmb250LXNpemUtYmFzZSAqIC43NTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICYuYnRuLWFjdGl2aXR5LXJpZ2h0LmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lciB7XG4gICAgICAgICAgICBwYWRkaW5nLXJpZ2h0OiAkZm9udC1zaXplLWJhc2UgKiA0O1xuXG4gICAgICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICAgICAgICAgIHJpZ2h0OiAkZm9udC1zaXplLWJhc2UgKiAuNzU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lciAuYWN0aXZpdHktaW5kaWNhdG9yLFxuICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lciB7XG4gICAgICAgICAgICB3aWR0aDogJGZvbnQtc2l6ZS1iYXNlICogMi41O1xuICAgICAgICAgICAgaGVpZ2h0OiAkZm9udC1zaXplLWJhc2UgKiAyLjU7XG5cbiAgICAgICAgICAgICYgPiBkaXY6YmVmb3JlIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogJGFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyLXdpZHRoICogLjc1O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG59XG48L3N0eWxlPlxuIiwiaW1wb3J0IEFjdGl2aXR5QnV0dG9uIGZyb20gJy4vQWN0aXZpdHlCdXR0b24nO1xuaW1wb3J0IFZ1ZUluc3RhbGxlciBmcm9tICdAL0hlbHBlcnMvVnVlSW5zdGFsbGVyL1Z1ZUluc3RhbGxlcic7XG5cbmNvbnN0IHBsdWdpbiA9IFZ1ZUluc3RhbGxlci51c2Uoe1xuXG4gICAgaW5zdGFsbChWdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgVnVlSW5zdGFsbGVyLmNvbXBvbmVudHMoe1xuICAgICAgICAgICAgQWN0aXZpdHlCdXR0b25cbiAgICAgICAgfSlcbiAgICB9XG5cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBBY3Rpdml0eUJ1dHRvbjtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYHVuZGVmaW5lZGAuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYHVuZGVmaW5lZGAsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1VuZGVmaW5lZCh2b2lkIDApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNVbmRlZmluZWQobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1VuZGVmaW5lZDtcbiIsIi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqXG4gKiBBZGRzIGB2YWx1ZWAgdG8gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBhZGRcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQGFsaWFzIHB1c2hcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNhY2hlLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlQWRkKHZhbHVlKSB7XG4gIHRoaXMuX19kYXRhX18uc2V0KHZhbHVlLCBIQVNIX1VOREVGSU5FRCk7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldENhY2hlQWRkO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBpbiB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUhhcyh2YWx1ZSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXModmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldENhY2hlSGFzO1xuIiwidmFyIE1hcENhY2hlID0gcmVxdWlyZSgnLi9fTWFwQ2FjaGUnKSxcbiAgICBzZXRDYWNoZUFkZCA9IHJlcXVpcmUoJy4vX3NldENhY2hlQWRkJyksXG4gICAgc2V0Q2FjaGVIYXMgPSByZXF1aXJlKCcuL19zZXRDYWNoZUhhcycpO1xuXG4vKipcbiAqXG4gKiBDcmVhdGVzIGFuIGFycmF5IGNhY2hlIG9iamVjdCB0byBzdG9yZSB1bmlxdWUgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFNldENhY2hlKHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcyA9PSBudWxsID8gMCA6IHZhbHVlcy5sZW5ndGg7XG5cbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB0aGlzLmFkZCh2YWx1ZXNbaW5kZXhdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU2V0Q2FjaGVgLlxuU2V0Q2FjaGUucHJvdG90eXBlLmFkZCA9IFNldENhY2hlLnByb3RvdHlwZS5wdXNoID0gc2V0Q2FjaGVBZGQ7XG5TZXRDYWNoZS5wcm90b3R5cGUuaGFzID0gc2V0Q2FjaGVIYXM7XG5cbm1vZHVsZS5leHBvcnRzID0gU2V0Q2FjaGU7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zb21lYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlTb21lKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5U29tZTtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGEgYGNhY2hlYCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gY2FjaGUgVGhlIGNhY2hlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGNhY2hlSGFzKGNhY2hlLCBrZXkpIHtcbiAgcmV0dXJuIGNhY2hlLmhhcyhrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhY2hlSGFzO1xuIiwidmFyIFNldENhY2hlID0gcmVxdWlyZSgnLi9fU2V0Q2FjaGUnKSxcbiAgICBhcnJheVNvbWUgPSByZXF1aXJlKCcuL19hcnJheVNvbWUnKSxcbiAgICBjYWNoZUhhcyA9IHJlcXVpcmUoJy4vX2NhY2hlSGFzJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGFycmF5cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtBcnJheX0gb3RoZXIgVGhlIG90aGVyIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBhcnJheWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJyYXlzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQXJyYXlzKGFycmF5LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuXG4gIGlmIChhcnJMZW5ndGggIT0gb3RoTGVuZ3RoICYmICEoaXNQYXJ0aWFsICYmIG90aExlbmd0aCA+IGFyckxlbmd0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChhcnJheSk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IHRydWUsXG4gICAgICBzZWVuID0gKGJpdG1hc2sgJiBDT01QQVJFX1VOT1JERVJFRF9GTEFHKSA/IG5ldyBTZXRDYWNoZSA6IHVuZGVmaW5lZDtcblxuICBzdGFjay5zZXQoYXJyYXksIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBhcnJheSk7XG5cbiAgLy8gSWdub3JlIG5vbi1pbmRleCBwcm9wZXJ0aWVzLlxuICB3aGlsZSAoKytpbmRleCA8IGFyckxlbmd0aCkge1xuICAgIHZhciBhcnJWYWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltpbmRleF07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgYXJyVmFsdWUsIGluZGV4LCBvdGhlciwgYXJyYXksIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIoYXJyVmFsdWUsIG90aFZhbHVlLCBpbmRleCwgYXJyYXksIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIGlmIChjb21wYXJlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoY29tcGFyZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmIChzZWVuKSB7XG4gICAgICBpZiAoIWFycmF5U29tZShvdGhlciwgZnVuY3Rpb24ob3RoVmFsdWUsIG90aEluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIWNhY2hlSGFzKHNlZW4sIG90aEluZGV4KSAmJlxuICAgICAgICAgICAgICAgIChhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKSkge1xuICAgICAgICAgICAgICByZXR1cm4gc2Vlbi5wdXNoKG90aEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSkge1xuICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghKFxuICAgICAgICAgIGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fFxuICAgICAgICAgICAgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHN0YWNrWydkZWxldGUnXShhcnJheSk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXF1YWxBcnJheXM7XG4iLCIvKipcbiAqIENvbnZlcnRzIGBtYXBgIHRvIGl0cyBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gKi9cbmZ1bmN0aW9uIG1hcFRvQXJyYXkobWFwKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobWFwLnNpemUpO1xuXG4gIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSBba2V5LCB2YWx1ZV07XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcFRvQXJyYXk7XG4iLCIvKipcbiAqIENvbnZlcnRzIGBzZXRgIHRvIGFuIGFycmF5IG9mIGl0cyB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIHNldFRvQXJyYXkoc2V0KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkoc2V0LnNpemUpO1xuXG4gIHNldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldFRvQXJyYXk7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgVWludDhBcnJheSA9IHJlcXVpcmUoJy4vX1VpbnQ4QXJyYXknKSxcbiAgICBlcSA9IHJlcXVpcmUoJy4vZXEnKSxcbiAgICBlcXVhbEFycmF5cyA9IHJlcXVpcmUoJy4vX2VxdWFsQXJyYXlzJyksXG4gICAgbWFwVG9BcnJheSA9IHJlcXVpcmUoJy4vX21hcFRvQXJyYXknKSxcbiAgICBzZXRUb0FycmF5ID0gcmVxdWlyZSgnLi9fc2V0VG9BcnJheScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJztcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBjb21wYXJpbmcgb2JqZWN0cyBvZlxuICogdGhlIHNhbWUgYHRvU3RyaW5nVGFnYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNvbXBhcmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBvciBgU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0cyB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgdGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAob2JqZWN0LmJ5dGVPZmZzZXQgIT0gb3RoZXIuYnl0ZU9mZnNldCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgb2JqZWN0ID0gb2JqZWN0LmJ1ZmZlcjtcbiAgICAgIG90aGVyID0gb3RoZXIuYnVmZmVyO1xuXG4gICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAhZXF1YWxGdW5jKG5ldyBVaW50OEFycmF5KG9iamVjdCksIG5ldyBVaW50OEFycmF5KG90aGVyKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICBjYXNlIGJvb2xUYWc6XG4gICAgY2FzZSBkYXRlVGFnOlxuICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgLy8gQ29lcmNlIGJvb2xlYW5zIHRvIGAxYCBvciBgMGAgYW5kIGRhdGVzIHRvIG1pbGxpc2Vjb25kcy5cbiAgICAgIC8vIEludmFsaWQgZGF0ZXMgYXJlIGNvZXJjZWQgdG8gYE5hTmAuXG4gICAgICByZXR1cm4gZXEoK29iamVjdCwgK290aGVyKTtcblxuICAgIGNhc2UgZXJyb3JUYWc6XG4gICAgICByZXR1cm4gb2JqZWN0Lm5hbWUgPT0gb3RoZXIubmFtZSAmJiBvYmplY3QubWVzc2FnZSA9PSBvdGhlci5tZXNzYWdlO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAvLyBDb2VyY2UgcmVnZXhlcyB0byBzdHJpbmdzIGFuZCB0cmVhdCBzdHJpbmdzLCBwcmltaXRpdmVzIGFuZCBvYmplY3RzLFxuICAgICAgLy8gYXMgZXF1YWwuIFNlZSBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcmVnZXhwLnByb3RvdHlwZS50b3N0cmluZ1xuICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIHJldHVybiBvYmplY3QgPT0gKG90aGVyICsgJycpO1xuXG4gICAgY2FzZSBtYXBUYWc6XG4gICAgICB2YXIgY29udmVydCA9IG1hcFRvQXJyYXk7XG5cbiAgICBjYXNlIHNldFRhZzpcbiAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUc7XG4gICAgICBjb252ZXJ0IHx8IChjb252ZXJ0ID0gc2V0VG9BcnJheSk7XG5cbiAgICAgIGlmIChvYmplY3Quc2l6ZSAhPSBvdGhlci5zaXplICYmICFpc1BhcnRpYWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgICAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICAgICAgfVxuICAgICAgYml0bWFzayB8PSBDT01QQVJFX1VOT1JERVJFRF9GTEFHO1xuXG4gICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgICAgIHZhciByZXN1bHQgPSBlcXVhbEFycmF5cyhjb252ZXJ0KG9iamVjdCksIGNvbnZlcnQob3RoZXIpLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICAgIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgaWYgKHN5bWJvbFZhbHVlT2YpIHtcbiAgICAgICAgcmV0dXJuIHN5bWJvbFZhbHVlT2YuY2FsbChvYmplY3QpID09IHN5bWJvbFZhbHVlT2YuY2FsbChvdGhlcik7XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxdWFsQnlUYWc7XG4iLCIvKipcbiAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlQdXNoO1xuIiwidmFyIGFycmF5UHVzaCA9IHJlcXVpcmUoJy4vX2FycmF5UHVzaCcpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0QWxsS2V5c2AgYW5kIGBnZXRBbGxLZXlzSW5gIHdoaWNoIHVzZXNcbiAqIGBrZXlzRnVuY2AgYW5kIGBzeW1ib2xzRnVuY2AgdG8gZ2V0IHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN5bWJvbHNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNGdW5jLCBzeW1ib2xzRnVuYykge1xuICB2YXIgcmVzdWx0ID0ga2V5c0Z1bmMob2JqZWN0KTtcbiAgcmV0dXJuIGlzQXJyYXkob2JqZWN0KSA/IHJlc3VsdCA6IGFycmF5UHVzaChyZXN1bHQsIHN5bWJvbHNGdW5jKG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXRBbGxLZXlzO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZmlsdGVyYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RmlsdGVyKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5RmlsdGVyO1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGVtcHR5IGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZW1wdHkgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBhcnJheXMgPSBfLnRpbWVzKDIsIF8uc3R1YkFycmF5KTtcbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXMpO1xuICogLy8gPT4gW1tdLCBbXV1cbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXNbMF0gPT09IGFycmF5c1sxXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBzdHViQXJyYXkoKSB7XG4gIHJldHVybiBbXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHViQXJyYXk7XG4iLCJ2YXIgYXJyYXlGaWx0ZXIgPSByZXF1aXJlKCcuL19hcnJheUZpbHRlcicpLFxuICAgIHN0dWJBcnJheSA9IHJlcXVpcmUoJy4vc3R1YkFycmF5Jyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICByZXR1cm4gYXJyYXlGaWx0ZXIobmF0aXZlR2V0U3ltYm9scyhvYmplY3QpLCBmdW5jdGlvbihzeW1ib2wpIHtcbiAgICByZXR1cm4gcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsIHN5bWJvbCk7XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRTeW1ib2xzO1xuIiwidmFyIGJhc2VHZXRBbGxLZXlzID0gcmVxdWlyZSgnLi9fYmFzZUdldEFsbEtleXMnKSxcbiAgICBnZXRTeW1ib2xzID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9scycpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRBbGxLZXlzKG9iamVjdCkge1xuICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzLCBnZXRTeW1ib2xzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRBbGxLZXlzO1xuIiwidmFyIGdldEFsbEtleXMgPSByZXF1aXJlKCcuL19nZXRBbGxLZXlzJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIG9iamVjdHMgd2l0aCBzdXBwb3J0IGZvclxuICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcbiAgICAgIG9ialByb3BzID0gZ2V0QWxsS2V5cyhvYmplY3QpLFxuICAgICAgb2JqTGVuZ3RoID0gb2JqUHJvcHMubGVuZ3RoLFxuICAgICAgb3RoUHJvcHMgPSBnZXRBbGxLZXlzKG90aGVyKSxcbiAgICAgIG90aExlbmd0aCA9IG90aFByb3BzLmxlbmd0aDtcblxuICBpZiAob2JqTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBpbmRleCA9IG9iakxlbmd0aDtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIGlmICghKGlzUGFydGlhbCA/IGtleSBpbiBvdGhlciA6IGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsIGtleSkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICB9XG4gIHZhciByZXN1bHQgPSB0cnVlO1xuICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gIHN0YWNrLnNldChvdGhlciwgb2JqZWN0KTtcblxuICB2YXIgc2tpcEN0b3IgPSBpc1BhcnRpYWw7XG4gIHdoaWxlICgrK2luZGV4IDwgb2JqTGVuZ3RoKSB7XG4gICAga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2tleV07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgb2JqVmFsdWUsIGtleSwgb3RoZXIsIG9iamVjdCwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihvYmpWYWx1ZSwgb3RoVmFsdWUsIGtleSwgb2JqZWN0LCBvdGhlciwgc3RhY2spO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBpZiAoIShjb21wYXJlZCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyAob2JqVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhvYmpWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSlcbiAgICAgICAgICA6IGNvbXBhcmVkXG4gICAgICAgICkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHNraXBDdG9yIHx8IChza2lwQ3RvciA9IGtleSA9PSAnY29uc3RydWN0b3InKTtcbiAgfVxuICBpZiAocmVzdWx0ICYmICFza2lwQ3Rvcikge1xuICAgIHZhciBvYmpDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICBvdGhDdG9yID0gb3RoZXIuY29uc3RydWN0b3I7XG5cbiAgICAvLyBOb24gYE9iamVjdGAgb2JqZWN0IGluc3RhbmNlcyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVhbC5cbiAgICBpZiAob2JqQ3RvciAhPSBvdGhDdG9yICYmXG4gICAgICAgICgnY29uc3RydWN0b3InIGluIG9iamVjdCAmJiAnY29uc3RydWN0b3InIGluIG90aGVyKSAmJlxuICAgICAgICAhKHR5cGVvZiBvYmpDdG9yID09ICdmdW5jdGlvbicgJiYgb2JqQ3RvciBpbnN0YW5jZW9mIG9iakN0b3IgJiZcbiAgICAgICAgICB0eXBlb2Ygb3RoQ3RvciA9PSAnZnVuY3Rpb24nICYmIG90aEN0b3IgaW5zdGFuY2VvZiBvdGhDdG9yKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxdWFsT2JqZWN0cztcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgRGF0YVZpZXcgPSBnZXROYXRpdmUocm9vdCwgJ0RhdGFWaWV3Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YVZpZXc7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFByb21pc2UgPSBnZXROYXRpdmUocm9vdCwgJ1Byb21pc2UnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9taXNlO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBTZXQgPSBnZXROYXRpdmUocm9vdCwgJ1NldCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNldDtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgV2Vha01hcCA9IGdldE5hdGl2ZShyb290LCAnV2Vha01hcCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYWtNYXA7XG4iLCJ2YXIgRGF0YVZpZXcgPSByZXF1aXJlKCcuL19EYXRhVmlldycpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpLFxuICAgIFByb21pc2UgPSByZXF1aXJlKCcuL19Qcm9taXNlJyksXG4gICAgU2V0ID0gcmVxdWlyZSgnLi9fU2V0JyksXG4gICAgV2Vha01hcCA9IHJlcXVpcmUoJy4vX1dlYWtNYXAnKSxcbiAgICBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIHRvU291cmNlID0gcmVxdWlyZSgnLi9fdG9Tb3VyY2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHByb21pc2VUYWcgPSAnW29iamVjdCBQcm9taXNlXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1hcHMsIHNldHMsIGFuZCB3ZWFrbWFwcy4gKi9cbnZhciBkYXRhVmlld0N0b3JTdHJpbmcgPSB0b1NvdXJjZShEYXRhVmlldyksXG4gICAgbWFwQ3RvclN0cmluZyA9IHRvU291cmNlKE1hcCksXG4gICAgcHJvbWlzZUN0b3JTdHJpbmcgPSB0b1NvdXJjZShQcm9taXNlKSxcbiAgICBzZXRDdG9yU3RyaW5nID0gdG9Tb3VyY2UoU2V0KSxcbiAgICB3ZWFrTWFwQ3RvclN0cmluZyA9IHRvU291cmNlKFdlYWtNYXApO1xuXG4vKipcbiAqIEdldHMgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG52YXIgZ2V0VGFnID0gYmFzZUdldFRhZztcblxuLy8gRmFsbGJhY2sgZm9yIGRhdGEgdmlld3MsIG1hcHMsIHNldHMsIGFuZCB3ZWFrIG1hcHMgaW4gSUUgMTEgYW5kIHByb21pc2VzIGluIE5vZGUuanMgPCA2LlxuaWYgKChEYXRhVmlldyAmJiBnZXRUYWcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSkpICE9IGRhdGFWaWV3VGFnKSB8fFxuICAgIChNYXAgJiYgZ2V0VGFnKG5ldyBNYXApICE9IG1hcFRhZykgfHxcbiAgICAoUHJvbWlzZSAmJiBnZXRUYWcoUHJvbWlzZS5yZXNvbHZlKCkpICE9IHByb21pc2VUYWcpIHx8XG4gICAgKFNldCAmJiBnZXRUYWcobmV3IFNldCkgIT0gc2V0VGFnKSB8fFxuICAgIChXZWFrTWFwICYmIGdldFRhZyhuZXcgV2Vha01hcCkgIT0gd2Vha01hcFRhZykpIHtcbiAgZ2V0VGFnID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gYmFzZUdldFRhZyh2YWx1ZSksXG4gICAgICAgIEN0b3IgPSByZXN1bHQgPT0gb2JqZWN0VGFnID8gdmFsdWUuY29uc3RydWN0b3IgOiB1bmRlZmluZWQsXG4gICAgICAgIGN0b3JTdHJpbmcgPSBDdG9yID8gdG9Tb3VyY2UoQ3RvcikgOiAnJztcblxuICAgIGlmIChjdG9yU3RyaW5nKSB7XG4gICAgICBzd2l0Y2ggKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgY2FzZSBkYXRhVmlld0N0b3JTdHJpbmc6IHJldHVybiBkYXRhVmlld1RhZztcbiAgICAgICAgY2FzZSBtYXBDdG9yU3RyaW5nOiByZXR1cm4gbWFwVGFnO1xuICAgICAgICBjYXNlIHByb21pc2VDdG9yU3RyaW5nOiByZXR1cm4gcHJvbWlzZVRhZztcbiAgICAgICAgY2FzZSBzZXRDdG9yU3RyaW5nOiByZXR1cm4gc2V0VGFnO1xuICAgICAgICBjYXNlIHdlYWtNYXBDdG9yU3RyaW5nOiByZXR1cm4gd2Vha01hcFRhZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRUYWc7XG4iLCJ2YXIgU3RhY2sgPSByZXF1aXJlKCcuL19TdGFjaycpLFxuICAgIGVxdWFsQXJyYXlzID0gcmVxdWlyZSgnLi9fZXF1YWxBcnJheXMnKSxcbiAgICBlcXVhbEJ5VGFnID0gcmVxdWlyZSgnLi9fZXF1YWxCeVRhZycpLFxuICAgIGVxdWFsT2JqZWN0cyA9IHJlcXVpcmUoJy4vX2VxdWFsT2JqZWN0cycpLFxuICAgIGdldFRhZyA9IHJlcXVpcmUoJy4vX2dldFRhZycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJy4vaXNCdWZmZXInKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzVHlwZWRBcnJheScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDE7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAqIGRlZXAgY29tcGFyaXNvbnMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAqIHJlZmVyZW5jZXMgdG8gYmUgY29tcGFyZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsRGVlcChvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBvYmpJc0FyciA9IGlzQXJyYXkob2JqZWN0KSxcbiAgICAgIG90aElzQXJyID0gaXNBcnJheShvdGhlciksXG4gICAgICBvYmpUYWcgPSBvYmpJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG9iamVjdCksXG4gICAgICBvdGhUYWcgPSBvdGhJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG90aGVyKTtcblxuICBvYmpUYWcgPSBvYmpUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG9ialRhZztcbiAgb3RoVGFnID0gb3RoVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvdGhUYWc7XG5cbiAgdmFyIG9iaklzT2JqID0gb2JqVGFnID09IG9iamVjdFRhZyxcbiAgICAgIG90aElzT2JqID0gb3RoVGFnID09IG9iamVjdFRhZyxcbiAgICAgIGlzU2FtZVRhZyA9IG9ialRhZyA9PSBvdGhUYWc7XG5cbiAgaWYgKGlzU2FtZVRhZyAmJiBpc0J1ZmZlcihvYmplY3QpKSB7XG4gICAgaWYgKCFpc0J1ZmZlcihvdGhlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgb2JqSXNBcnIgPSB0cnVlO1xuICAgIG9iaklzT2JqID0gZmFsc2U7XG4gIH1cbiAgaWYgKGlzU2FtZVRhZyAmJiAhb2JqSXNPYmopIHtcbiAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgIHJldHVybiAob2JqSXNBcnIgfHwgaXNUeXBlZEFycmF5KG9iamVjdCkpXG4gICAgICA/IGVxdWFsQXJyYXlzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spXG4gICAgICA6IGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgb2JqVGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgfVxuICBpZiAoIShiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcpKSB7XG4gICAgdmFyIG9iaklzV3JhcHBlZCA9IG9iaklzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCAnX193cmFwcGVkX18nKSxcbiAgICAgICAgb3RoSXNXcmFwcGVkID0gb3RoSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwgJ19fd3JhcHBlZF9fJyk7XG5cbiAgICBpZiAob2JqSXNXcmFwcGVkIHx8IG90aElzV3JhcHBlZCkge1xuICAgICAgdmFyIG9ialVud3JhcHBlZCA9IG9iaklzV3JhcHBlZCA/IG9iamVjdC52YWx1ZSgpIDogb2JqZWN0LFxuICAgICAgICAgIG90aFVud3JhcHBlZCA9IG90aElzV3JhcHBlZCA/IG90aGVyLnZhbHVlKCkgOiBvdGhlcjtcblxuICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgIHJldHVybiBlcXVhbEZ1bmMob2JqVW53cmFwcGVkLCBvdGhVbndyYXBwZWQsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFpc1NhbWVUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgcmV0dXJuIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNFcXVhbERlZXA7XG4iLCJ2YXIgYmFzZUlzRXF1YWxEZWVwID0gcmVxdWlyZSgnLi9fYmFzZUlzRXF1YWxEZWVwJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0VxdWFsYCB3aGljaCBzdXBwb3J0cyBwYXJ0aWFsIGNvbXBhcmlzb25zXG4gKiBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAqICAxIC0gVW5vcmRlcmVkIGNvbXBhcmlzb25cbiAqICAyIC0gUGFydGlhbCBjb21wYXJpc29uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykge1xuICBpZiAodmFsdWUgPT09IG90aGVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgfHwgb3RoZXIgPT0gbnVsbCB8fCAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgIWlzT2JqZWN0TGlrZShvdGhlcikpKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG4gIH1cbiAgcmV0dXJuIGJhc2VJc0VxdWFsRGVlcCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGJhc2VJc0VxdWFsLCBzdGFjayk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzRXF1YWw7XG4iLCJ2YXIgU3RhY2sgPSByZXF1aXJlKCcuL19TdGFjaycpLFxuICAgIGJhc2VJc0VxdWFsID0gcmVxdWlyZSgnLi9fYmFzZUlzRXF1YWwnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWF0Y2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtBcnJheX0gbWF0Y2hEYXRhIFRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSwgY3VzdG9taXplcikge1xuICB2YXIgaW5kZXggPSBtYXRjaERhdGEubGVuZ3RoLFxuICAgICAgbGVuZ3RoID0gaW5kZXgsXG4gICAgICBub0N1c3RvbWl6ZXIgPSAhY3VzdG9taXplcjtcblxuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gIWxlbmd0aDtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgaWYgKChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSlcbiAgICAgICAgICA/IGRhdGFbMV0gIT09IG9iamVjdFtkYXRhWzBdXVxuICAgICAgICAgIDogIShkYXRhWzBdIGluIG9iamVjdClcbiAgICAgICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgdmFyIGtleSA9IGRhdGFbMF0sXG4gICAgICAgIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIHNyY1ZhbHVlID0gZGF0YVsxXTtcblxuICAgIGlmIChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSkge1xuICAgICAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzdGFjayA9IG5ldyBTdGFjaztcbiAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spO1xuICAgICAgfVxuICAgICAgaWYgKCEocmVzdWx0ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcsIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICAgICAgOiByZXN1bHRcbiAgICAgICAgICApKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzTWF0Y2g7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpZiBzdWl0YWJsZSBmb3Igc3RyaWN0XG4gKiAgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgJiYgIWlzT2JqZWN0KHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1N0cmljdENvbXBhcmFibGU7XG4iLCJ2YXIgaXNTdHJpY3RDb21wYXJhYmxlID0gcmVxdWlyZSgnLi9faXNTdHJpY3RDb21wYXJhYmxlJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIEdldHMgdGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG1hdGNoIGRhdGEgb2YgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGdldE1hdGNoRGF0YShvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXMob2JqZWN0KSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgdmFyIGtleSA9IHJlc3VsdFtsZW5ndGhdLFxuICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgcmVzdWx0W2xlbmd0aF0gPSBba2V5LCB2YWx1ZSwgaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKV07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRNYXRjaERhdGE7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgbWF0Y2hlc1Byb3BlcnR5YCBmb3Igc291cmNlIHZhbHVlcyBzdWl0YWJsZVxuICogZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKGtleSwgc3JjVmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0W2tleV0gPT09IHNyY1ZhbHVlICYmXG4gICAgICAoc3JjVmFsdWUgIT09IHVuZGVmaW5lZCB8fCAoa2V5IGluIE9iamVjdChvYmplY3QpKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWF0Y2hlc1N0cmljdENvbXBhcmFibGU7XG4iLCJ2YXIgYmFzZUlzTWF0Y2ggPSByZXF1aXJlKCcuL19iYXNlSXNNYXRjaCcpLFxuICAgIGdldE1hdGNoRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hdGNoRGF0YScpLFxuICAgIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlID0gcmVxdWlyZSgnLi9fbWF0Y2hlc1N0cmljdENvbXBhcmFibGUnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzYCB3aGljaCBkb2Vzbid0IGNsb25lIGBzb3VyY2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hdGNoZXMoc291cmNlKSB7XG4gIHZhciBtYXRjaERhdGEgPSBnZXRNYXRjaERhdGEoc291cmNlKTtcbiAgaWYgKG1hdGNoRGF0YS5sZW5ndGggPT0gMSAmJiBtYXRjaERhdGFbMF1bMl0pIHtcbiAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUobWF0Y2hEYXRhWzBdWzBdLCBtYXRjaERhdGFbMF1bMV0pO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09PSBzb3VyY2UgfHwgYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1hdGNoZXM7XG4iLCJ2YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVJc0RlZXBQcm9wID0gL1xcLnxcXFsoPzpbXltcXF1dKnwoW1wiJ10pKD86KD8hXFwxKVteXFxcXF18XFxcXC4pKj9cXDEpXFxdLyxcbiAgICByZUlzUGxhaW5Qcm9wID0gL15cXHcqJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lIGFuZCBub3QgYSBwcm9wZXJ0eSBwYXRoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXkodmFsdWUsIG9iamVjdCkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGlmICh0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicgfHxcbiAgICAgIHZhbHVlID09IG51bGwgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIHJlSXNQbGFpblByb3AudGVzdCh2YWx1ZSkgfHwgIXJlSXNEZWVwUHJvcC50ZXN0KHZhbHVlKSB8fFxuICAgIChvYmplY3QgIT0gbnVsbCAmJiB2YWx1ZSBpbiBPYmplY3Qob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNLZXk7XG4iLCJ2YXIgTWFwQ2FjaGUgPSByZXF1aXJlKCcuL19NYXBDYWNoZScpO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gKiBwcm92aWRlZCwgaXQgZGV0ZXJtaW5lcyB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHQgYmFzZWQgb24gdGhlXG4gKiBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgYXJndW1lbnRcbiAqIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBtYXAgY2FjaGUga2V5LiBUaGUgYGZ1bmNgXG4gKiBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXG4gKiBmdW5jdGlvbi4gSXRzIGNyZWF0aW9uIG1heSBiZSBjdXN0b21pemVkIGJ5IHJlcGxhY2luZyB0aGUgYF8ubWVtb2l6ZS5DYWNoZWBcbiAqIGNvbnN0cnVjdG9yIHdpdGggb25lIHdob3NlIGluc3RhbmNlcyBpbXBsZW1lbnQgdGhlXG4gKiBbYE1hcGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLW1hcC1wcm90b3R5cGUtb2JqZWN0KVxuICogbWV0aG9kIGludGVyZmFjZSBvZiBgY2xlYXJgLCBgZGVsZXRlYCwgYGdldGAsIGBoYXNgLCBhbmQgYHNldGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2MnOiAzLCAnZCc6IDQgfTtcbiAqXG4gKiB2YXIgdmFsdWVzID0gXy5tZW1vaXplKF8udmFsdWVzKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogdmFsdWVzKG90aGVyKTtcbiAqIC8vID0+IFszLCA0XVxuICpcbiAqIG9iamVjdC5hID0gMjtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogLy8gTW9kaWZ5IHRoZSByZXN1bHQgY2FjaGUuXG4gKiB2YWx1ZXMuY2FjaGUuc2V0KG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsnYScsICdiJ11cbiAqXG4gKiAvLyBSZXBsYWNlIGBfLm1lbW9pemUuQ2FjaGVgLlxuICogXy5tZW1vaXplLkNhY2hlID0gV2Vha01hcDtcbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJyB8fCAocmVzb2x2ZXIgIT0gbnVsbCAmJiB0eXBlb2YgcmVzb2x2ZXIgIT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuICAgICAgICBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuXG4gICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KSB8fCBjYWNoZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBtZW1vaXplZC5jYWNoZSA9IG5ldyAobWVtb2l6ZS5DYWNoZSB8fCBNYXBDYWNoZSk7XG4gIHJldHVybiBtZW1vaXplZDtcbn1cblxuLy8gRXhwb3NlIGBNYXBDYWNoZWAuXG5tZW1vaXplLkNhY2hlID0gTWFwQ2FjaGU7XG5cbm1vZHVsZS5leHBvcnRzID0gbWVtb2l6ZTtcbiIsInZhciBtZW1vaXplID0gcmVxdWlyZSgnLi9tZW1vaXplJyk7XG5cbi8qKiBVc2VkIGFzIHRoZSBtYXhpbXVtIG1lbW9pemUgY2FjaGUgc2l6ZS4gKi9cbnZhciBNQVhfTUVNT0laRV9TSVpFID0gNTAwO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tZW1vaXplYCB3aGljaCBjbGVhcnMgdGhlIG1lbW9pemVkIGZ1bmN0aW9uJ3NcbiAqIGNhY2hlIHdoZW4gaXQgZXhjZWVkcyBgTUFYX01FTU9JWkVfU0laRWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtZW1vaXplQ2FwcGVkKGZ1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IG1lbW9pemUoZnVuYywgZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKGNhY2hlLnNpemUgPT09IE1BWF9NRU1PSVpFX1NJWkUpIHtcbiAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgfVxuICAgIHJldHVybiBrZXk7XG4gIH0pO1xuXG4gIHZhciBjYWNoZSA9IHJlc3VsdC5jYWNoZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplQ2FwcGVkO1xuIiwidmFyIG1lbW9pemVDYXBwZWQgPSByZXF1aXJlKCcuL19tZW1vaXplQ2FwcGVkJyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZVByb3BOYW1lID0gL1teLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCQpKS9nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG52YXIgc3RyaW5nVG9QYXRoID0gbWVtb2l6ZUNhcHBlZChmdW5jdGlvbihzdHJpbmcpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAoc3RyaW5nLmNoYXJDb2RlQXQoMCkgPT09IDQ2IC8qIC4gKi8pIHtcbiAgICByZXN1bHQucHVzaCgnJyk7XG4gIH1cbiAgc3RyaW5nLnJlcGxhY2UocmVQcm9wTmFtZSwgZnVuY3Rpb24obWF0Y2gsIG51bWJlciwgcXVvdGUsIHN1YlN0cmluZykge1xuICAgIHJlc3VsdC5wdXNoKHF1b3RlID8gc3ViU3RyaW5nLnJlcGxhY2UocmVFc2NhcGVDaGFyLCAnJDEnKSA6IChudW1iZXIgfHwgbWF0Y2gpKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpbmdUb1BhdGg7XG4iLCJ2YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzS2V5ID0gcmVxdWlyZSgnLi9faXNLZXknKSxcbiAgICBzdHJpbmdUb1BhdGggPSByZXF1aXJlKCcuL19zdHJpbmdUb1BhdGgnKSxcbiAgICB0b1N0cmluZyA9IHJlcXVpcmUoJy4vdG9TdHJpbmcnKTtcblxuLyoqXG4gKiBDYXN0cyBgdmFsdWVgIHRvIGEgcGF0aCBhcnJheSBpZiBpdCdzIG5vdCBvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNhc3RQYXRoKHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiBpc0tleSh2YWx1ZSwgb2JqZWN0KSA/IFt2YWx1ZV0gOiBzdHJpbmdUb1BhdGgodG9TdHJpbmcodmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYXN0UGF0aDtcbiIsInZhciBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIGtleSBpZiBpdCdzIG5vdCBhIHN0cmluZyBvciBzeW1ib2wuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7c3RyaW5nfHN5bWJvbH0gUmV0dXJucyB0aGUga2V5LlxuICovXG5mdW5jdGlvbiB0b0tleSh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9LZXk7XG4iLCJ2YXIgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5nZXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVmYXVsdCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXQob2JqZWN0LCBwYXRoKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IDAsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICB3aGlsZSAob2JqZWN0ICE9IG51bGwgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICBvYmplY3QgPSBvYmplY3RbdG9LZXkocGF0aFtpbmRleCsrXSldO1xuICB9XG4gIHJldHVybiAoaW5kZXggJiYgaW5kZXggPT0gbGVuZ3RoKSA/IG9iamVjdCA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0O1xuIiwidmFyIGJhc2VHZXQgPSByZXF1aXJlKCcuL19iYXNlR2V0Jyk7XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXNcbiAqIGB1bmRlZmluZWRgLCB0aGUgYGRlZmF1bHRWYWx1ZWAgaXMgcmV0dXJuZWQgaW4gaXRzIHBsYWNlLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy43LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSByZXR1cm5lZCBmb3IgYHVuZGVmaW5lZGAgcmVzb2x2ZWQgdmFsdWVzLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2FbMF0uYi5jJyk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCBbJ2EnLCAnMCcsICdiJywgJ2MnXSk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCAnYS5iLmMnLCAnZGVmYXVsdCcpO1xuICogLy8gPT4gJ2RlZmF1bHQnXG4gKi9cbmZ1bmN0aW9uIGdldChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXQ7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc0luYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IGtleSBUaGUga2V5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSGFzSW4ob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGtleSBpbiBPYmplY3Qob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSGFzSW47XG4iLCJ2YXIgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGV4aXN0cyBvbiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYXNGdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjayBwcm9wZXJ0aWVzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzUGF0aChvYmplY3QsIHBhdGgsIGhhc0Z1bmMpIHtcbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKTtcbiAgICBpZiAoIShyZXN1bHQgPSBvYmplY3QgIT0gbnVsbCAmJiBoYXNGdW5jKG9iamVjdCwga2V5KSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBvYmplY3QgPSBvYmplY3Rba2V5XTtcbiAgfVxuICBpZiAocmVzdWx0IHx8ICsraW5kZXggIT0gbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBsZW5ndGggPSBvYmplY3QgPT0gbnVsbCA/IDAgOiBvYmplY3QubGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJiBpc0luZGV4KGtleSwgbGVuZ3RoKSAmJlxuICAgIChpc0FycmF5KG9iamVjdCkgfHwgaXNBcmd1bWVudHMob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzUGF0aDtcbiIsInZhciBiYXNlSGFzSW4gPSByZXF1aXJlKCcuL19iYXNlSGFzSW4nKSxcbiAgICBoYXNQYXRoID0gcmVxdWlyZSgnLi9faGFzUGF0aCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgaXMgYSBkaXJlY3Qgb3IgaW5oZXJpdGVkIHByb3BlcnR5IG9mIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IF8uY3JlYXRlKHsgJ2EnOiBfLmNyZWF0ZSh7ICdiJzogMiB9KSB9KTtcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EuYicpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2InKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGhhc0luKG9iamVjdCwgcGF0aCkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzUGF0aChvYmplY3QsIHBhdGgsIGJhc2VIYXNJbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzSW47XG4iLCJ2YXIgYmFzZUlzRXF1YWwgPSByZXF1aXJlKCcuL19iYXNlSXNFcXVhbCcpLFxuICAgIGdldCA9IHJlcXVpcmUoJy4vZ2V0JyksXG4gICAgaGFzSW4gPSByZXF1aXJlKCcuL2hhc0luJyksXG4gICAgaXNLZXkgPSByZXF1aXJlKCcuL19pc0tleScpLFxuICAgIGlzU3RyaWN0Q29tcGFyYWJsZSA9IHJlcXVpcmUoJy4vX2lzU3RyaWN0Q29tcGFyYWJsZScpLFxuICAgIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlID0gcmVxdWlyZSgnLi9fbWF0Y2hlc1N0cmljdENvbXBhcmFibGUnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzUHJvcGVydHlgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNyY1ZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuICBpZiAoaXNLZXkocGF0aCkgJiYgaXNTdHJpY3RDb21wYXJhYmxlKHNyY1ZhbHVlKSkge1xuICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSh0b0tleShwYXRoKSwgc3JjVmFsdWUpO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIgb2JqVmFsdWUgPSBnZXQob2JqZWN0LCBwYXRoKTtcbiAgICByZXR1cm4gKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgb2JqVmFsdWUgPT09IHNyY1ZhbHVlKVxuICAgICAgPyBoYXNJbihvYmplY3QsIHBhdGgpXG4gICAgICA6IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlTWF0Y2hlc1Byb3BlcnR5O1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eWAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHkoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUHJvcGVydHk7XG4iLCJ2YXIgYmFzZUdldCA9IHJlcXVpcmUoJy4vX2Jhc2VHZXQnKTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VQcm9wZXJ0eWAgd2hpY2ggc3VwcG9ydHMgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVByb3BlcnR5RGVlcDtcbiIsInZhciBiYXNlUHJvcGVydHkgPSByZXF1aXJlKCcuL19iYXNlUHJvcGVydHknKSxcbiAgICBiYXNlUHJvcGVydHlEZWVwID0gcmVxdWlyZSgnLi9fYmFzZVByb3BlcnR5RGVlcCcpLFxuICAgIGlzS2V5ID0gcmVxdWlyZSgnLi9faXNLZXknKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGEgZ2l2ZW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gW1xuICogICB7ICdhJzogeyAnYic6IDIgfSB9LFxuICogICB7ICdhJzogeyAnYic6IDEgfSB9XG4gKiBdO1xuICpcbiAqIF8ubWFwKG9iamVjdHMsIF8ucHJvcGVydHkoJ2EuYicpKTtcbiAqIC8vID0+IFsyLCAxXVxuICpcbiAqIF8ubWFwKF8uc29ydEJ5KG9iamVjdHMsIF8ucHJvcGVydHkoWydhJywgJ2InXSkpLCAnYS5iJyk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqL1xuZnVuY3Rpb24gcHJvcGVydHkocGF0aCkge1xuICByZXR1cm4gaXNLZXkocGF0aCkgPyBiYXNlUHJvcGVydHkodG9LZXkocGF0aCkpIDogYmFzZVByb3BlcnR5RGVlcChwYXRoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwcm9wZXJ0eTtcbiIsInZhciBiYXNlTWF0Y2hlcyA9IHJlcXVpcmUoJy4vX2Jhc2VNYXRjaGVzJyksXG4gICAgYmFzZU1hdGNoZXNQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2Jhc2VNYXRjaGVzUHJvcGVydHknKSxcbiAgICBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgcHJvcGVydHkgPSByZXF1aXJlKCcuL3Byb3BlcnR5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXRlcmF0ZWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IFt2YWx1ZT1fLmlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhbiBpdGVyYXRlZS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgaXRlcmF0ZWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJdGVyYXRlZSh2YWx1ZSkge1xuICAvLyBEb24ndCBzdG9yZSB0aGUgYHR5cGVvZmAgcmVzdWx0IGluIGEgdmFyaWFibGUgdG8gYXZvaWQgYSBKSVQgYnVnIGluIFNhZmFyaSA5LlxuICAvLyBTZWUgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE1NjAzNCBmb3IgbW9yZSBkZXRhaWxzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gaWRlbnRpdHk7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBpc0FycmF5KHZhbHVlKVxuICAgICAgPyBiYXNlTWF0Y2hlc1Byb3BlcnR5KHZhbHVlWzBdLCB2YWx1ZVsxXSlcbiAgICAgIDogYmFzZU1hdGNoZXModmFsdWUpO1xuICB9XG4gIHJldHVybiBwcm9wZXJ0eSh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUl0ZXJhdGVlO1xuIiwidmFyIGJhc2VBc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25WYWx1ZScpLFxuICAgIGJhc2VGb3JPd24gPSByZXF1aXJlKCcuL19iYXNlRm9yT3duJyksXG4gICAgYmFzZUl0ZXJhdGVlID0gcmVxdWlyZSgnLi9fYmFzZUl0ZXJhdGVlJyk7XG5cbi8qKlxuICogVGhlIG9wcG9zaXRlIG9mIGBfLm1hcFZhbHVlc2A7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYW4gb2JqZWN0IHdpdGggdGhlXG4gKiBzYW1lIHZhbHVlcyBhcyBgb2JqZWN0YCBhbmQga2V5cyBnZW5lcmF0ZWQgYnkgcnVubmluZyBlYWNoIG93biBlbnVtZXJhYmxlXG4gKiBzdHJpbmcga2V5ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAgdGhydSBgaXRlcmF0ZWVgLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZFxuICogd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwga2V5LCBvYmplY3QpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy44LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgb2JqZWN0LlxuICogQHNlZSBfLm1hcFZhbHVlc1xuICogQGV4YW1wbGVcbiAqXG4gKiBfLm1hcEtleXMoeyAnYSc6IDEsICdiJzogMiB9LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gKiAgIHJldHVybiBrZXkgKyB2YWx1ZTtcbiAqIH0pO1xuICogLy8gPT4geyAnYTEnOiAxLCAnYjInOiAyIH1cbiAqL1xuZnVuY3Rpb24gbWFwS2V5cyhvYmplY3QsIGl0ZXJhdGVlKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgaXRlcmF0ZWUgPSBiYXNlSXRlcmF0ZWUoaXRlcmF0ZWUsIDMpO1xuXG4gIGJhc2VGb3JPd24ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICBiYXNlQXNzaWduVmFsdWUocmVzdWx0LCBpdGVyYXRlZSh2YWx1ZSwga2V5LCBvYmplY3QpLCB2YWx1ZSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcEtleXM7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGBudWxsYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgbnVsbGAsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc051bGwobnVsbCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc051bGwodm9pZCAwKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTnVsbCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNOdWxsO1xuIiwiaW1wb3J0IHsgaXNOdWxsIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IG1hcEtleXMgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgaXNPYmplY3QgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgaXNVbmRlZmluZWQgfSBmcm9tICdsb2Rhc2gnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwcmVmaXgoc3ViamVjdCwgcHJlZml4LCBkZWxpbWV0ZXIgPSAnLScpIHtcbiAgICBjb25zdCBwcmVmaXhlciA9ICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIGNvbnN0IHN0cmluZyA9IGtleSB8fCB2YWx1ZTtcblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgcHJlZml4LFxuICAgICAgICAgICAgc3RyaW5nLnJlcGxhY2UobmV3IFJlZ0V4cChgXiR7cHJlZml4fSR7ZGVsaW1ldGVyfT9gKSwgJycpXG4gICAgICAgIF0uam9pbihkZWxpbWV0ZXIpO1xuICAgIH1cblxuICAgIGlmKGlzTnVsbChzdWJqZWN0KSB8fCBpc1VuZGVmaW5lZChzdWJqZWN0KSl7XG4gICAgICAgIHJldHVybiBzdWJqZWN0O1xuICAgIH1cblxuICAgIGlmKGlzT2JqZWN0KHN1YmplY3QpKSB7XG4gICAgICAgIHJldHVybiBtYXBLZXlzKHN1YmplY3QsIHByZWZpeGVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJlZml4ZXIoc3ViamVjdCk7XG59XG4iLCJpbXBvcnQgcHJlZml4IGZyb20gJ0AvSGVscGVycy9QcmVmaXgvUHJlZml4JztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgcHJvcHM6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHZhcmlhbnQgYXR0cmlidXRlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHZhcmlhbnQ6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdwcmltYXJ5J1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgY29tcHV0ZWQ6IHtcblxuICAgICAgICB2YXJpYW50Q2xhc3NQcmVmaXgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kb3B0aW9ucy5uYW1lO1xuICAgICAgICB9LFxuXG4gICAgICAgIHZhcmlhbnRDbGFzcygpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmVmaXgodGhpcy52YXJpYW50LCB0aGlzLnZhcmlhbnRDbGFzc1ByZWZpeCk7XG4gICAgICAgIH1cblxuICAgIH1cblxufVxuIiwiZnVuY3Rpb24gZHVyYXRpb24oZWwpIHtcbiAgICBjb25zdCBkdXJhdGlvbiA9IGdldENvbXB1dGVkU3R5bGUoZWwpLnRyYW5zaXRpb25EdXJhdGlvbjtcbiAgICBjb25zdCBudW1lcmljID0gcGFyc2VGbG9hdChkdXJhdGlvbiwgMTApIHx8IDA7XG4gICAgY29uc3QgdW5pdCA9IGR1cmF0aW9uLm1hdGNoKC9tP3MvKTtcblxuICAgIHN3aXRjaCAodW5pdFswXSkge1xuICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgIHJldHVybiBudW1lcmljICogMTAwMDtcbiAgICAgICAgY2FzZSAnbXMnOlxuICAgICAgICAgICAgcmV0dXJuIG51bWVyaWM7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0cmFuc2l0aW9uKGVsKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGRlbGF5ID0gZHVyYXRpb24oZWwpO1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiByZXNvbHZlKGRlbGF5KSwgZGVsYXkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoKGUpIHtcbiAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuIiwiPHRlbXBsYXRlPlxuICAgIDxkaXYgY2xhc3M9XCJhbGVydFwiIDpjbGFzcz1cIiRtZXJnZUNsYXNzZXModmFyaWFudENsYXNzLCB7c2hvdzogaXNWaXNpYmxlLCBmYWRlOiBmYWRlfSlcIiByb2xlPVwiYWxlcnRcIj5cbiAgICAgICAgPHNsb3QvPlxuICAgICAgICA8YWxlcnQtY2xvc2Ugdi1pZj1cImRpc21pc3NpYmxlXCIgQGNsaWNrPVwiZGlzbWlzcygpXCIvPlxuICAgICAgICA8cHJvZ3Jlc3MtYmFyIHYtaWY9XCJ0eXBlb2Ygc2hvdyA9PT0gJ251bWJlcidcIiA6dmFyaWFudD1cInZhcmlhbnRcIiA6aGVpZ2h0PVwiNVwiIDp2YWx1ZT1cImRpc21pc3NDb3VudFwiIDptYXg9XCJzaG93XCIgY2xhc3M9XCJteS0zXCIvPlxuICAgIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBWYXJpYW50IGZyb20gJ0AvTWl4aW5zL1ZhcmlhbnQvVmFyaWFudCc7XG5pbXBvcnQgdHJhbnNpdGlvbiBmcm9tICdAL0hlbHBlcnMvVHJhbnNpdGlvbi9UcmFuc2l0aW9uJztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ2FsZXJ0JyxcblxuICAgIG1peGluczogW1xuICAgICAgICBWYXJpYW50XG4gICAgXSxcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElzIHRoZSBhbGVydCBkaXNtaXNzaWJsZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgQm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgZGlzbWlzc2libGU6IEJvb2xlYW4sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3VsZCB0aGUgYWxlcnQgZmFkZSB3aGVuIGhpZGRlblxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgQm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgZmFkZToge1xuICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvdWxkIHRoZSBhbGVydCBiZSB2aXNpYmxlIGJ5IGRlZmF1bHQuIElmIHBhc3NlZCBhIG51bWJlciwgYWxlcnRcbiAgICAgICAgICogd2lsbCBiZSBzaG93biBmb3IgdGhlIG51bWJlciBvZiBzZWNvbmRzIHRoYXQgYXJlIHBhc3NlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IEJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIHNob3c6IHtcbiAgICAgICAgICAgIHR5cGU6IFtOdW1iZXIsIEJvb2xlYW5dLFxuICAgICAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgbWV0aG9kczoge1xuXG4gICAgICAgIGRpc21pc3MoKSB7XG4gICAgICAgICAgICB0cmFuc2l0aW9uKHRoaXMuJGVsKS50aGVuKGRlbGF5ID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdkaXNtaXNzZWQnKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLiRlbWl0KCd1cGRhdGU6dmlzaWJsZScsIHRoaXMuaXNWaXNpYmxlID0gZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgbW91bnRlZCgpIHtcbiAgICAgICAgaWYodHlwZW9mIHRoaXMuc2hvdyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGNvbnN0IGVsID0gdGhpcy4kZWwucXVlcnlTZWxlY3RvcignLnByb2dyZXNzLWJhcicpO1xuXG4gICAgICAgICAgICB0aGlzLiRlbWl0KCdkaXNtaXNzLWNvdW50ZG93bicsIHRoaXMuZGlzbWlzc0NvdW50ID0gdGhpcy5zaG93KTtcblxuICAgICAgICAgICAgY29uc3QgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy4kZW1pdCgnZGlzbWlzcy1jb3VudGRvd24nLCB0aGlzLmRpc21pc3NDb3VudCAtPSAxKTtcblxuICAgICAgICAgICAgICAgIGlmKCF0aGlzLmRpc21pc3NDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbihlbCkudGhlbihkZWxheSA9PiB0aGlzLmRpc21pc3MoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgMTAwMCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpc21pc3NDb3VudDogdGhpcy5zaG93LFxuICAgICAgICAgICAgaXNWaXNpYmxlOiB0aGlzLnNob3dcbiAgICAgICAgfVxuICAgIH1cblxufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gICAgPGEgY2xhc3M9XCJhbGVydC1saW5rXCI+PHNsb3QvPjwvYT5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAnYWxlcnQtbGluaydcblxufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJjbG9zZVwiIGRhdGEtZGlzbWlzcz1cImFsZXJ0XCIgYXJpYS1sYWJlbD1cIkNsb3NlXCIgQGNsaWNrPVwib25DbGlja1wiPlxuICAgICAgICA8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj4mdGltZXM7PC9zcGFuPlxuICAgIDwvYnV0dG9uPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdhbGVydC1jbG9zZScsXG5cbiAgICBtZXRob2RzOiB7XG5cbiAgICAgICAgb25DbGljayhldmVudCkge1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgnY2xpY2snLCBldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgfVxuXG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgICA8aDQgY2xhc3M9XCJhbGVydC1oZWFkaW5nXCI+PHNsb3QvPjwvaDQ+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ2FsZXJ0LWhlYWRpbmcnXG5cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IEFsZXJ0IGZyb20gJy4vQWxlcnQnO1xuaW1wb3J0IEFsZXJ0TGluayBmcm9tICcuL0FsZXJ0TGluayc7XG5pbXBvcnQgQWxlcnRDbG9zZSBmcm9tICcuL0FsZXJ0Q2xvc2UnO1xuaW1wb3J0IEFsZXJ0SGVhZGluZyBmcm9tICcuL0FsZXJ0SGVhZGluZyc7XG5pbXBvcnQgVnVlSW5zdGFsbGVyIGZyb20gJ0AvSGVscGVycy9WdWVJbnN0YWxsZXIvVnVlSW5zdGFsbGVyJztcblxuY29uc3QgcGx1Z2luID0gVnVlSW5zdGFsbGVyLnVzZSh7XG5cbiAgICBpbnN0YWxsKFZ1ZSwgb3B0aW9ucykge1xuICAgICAgICBWdWVJbnN0YWxsZXIuY29tcG9uZW50cyh7XG4gICAgICAgICAgICBBbGVydCxcbiAgICAgICAgICAgIEFsZXJ0TGluayxcbiAgICAgICAgICAgIEFsZXJ0Q2xvc2UsXG4gICAgICAgICAgICBBbGVydEhlYWRpbmdcbiAgICAgICAgfSk7XG4gICAgfVxuXG59KTtcblxuZXhwb3J0ICogZnJvbSAnLi9BbGVydExpbmsnO1xuZXhwb3J0ICogZnJvbSAnLi9BbGVydENsb3NlJztcbmV4cG9ydCAqIGZyb20gJy4vQWxlcnRIZWFkaW5nJztcbmV4cG9ydCBkZWZhdWx0IEFsZXJ0O1xuIiwiPHRlbXBsYXRlPlxuICAgIDxhIHYtaWY9XCJocmVmXCIgOmhyZWY9XCJocmVmXCIgY2xhc3M9XCJiYWRnZVwiIDpjbGFzcz1cIiRtZXJnZUNsYXNzZXMoY2xhc3NlcywgdmFyaWFudENsYXNzKVwiPlxuICAgICAgICA8c2xvdD57e2xhYmVsfX08L3Nsb3Q+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwic3Itb25seVwiIHYtaHRtbD1cImFjY2Vzc2liaWxpdHlcIi8+XG4gICAgPC9hPlxuICAgIDxzcGFuIHYtZWxzZSBjbGFzcz1cImJhZGdlXCIgOmNsYXNzPVwiJG1lcmdlQ2xhc3NlcyhjbGFzc2VzLCB2YXJpYW50Q2xhc3MpXCI+XG4gICAgICAgIDxzbG90Pnt7bGFiZWx9fTwvc2xvdD5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJzci1vbmx5XCIgdi1odG1sPVwiYWNjZXNzaWJpbGl0eVwiLz5cbiAgICA8L3NwYW4+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuXG5pbXBvcnQgcHJlZml4IGZyb20gJ0AvSGVscGVycy9QcmVmaXgvUHJlZml4JztcbmltcG9ydCBWYXJpYW50IGZyb20gJ0AvTWl4aW5zL1ZhcmlhbnQvVmFyaWFudCc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdiYWRnZScsXG5cbiAgICBtaXhpbnM6IFtcbiAgICAgICAgVmFyaWFudFxuICAgIF0sXG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc2NyZWVuIHJlYWRlciBhY2Nlc3NpYmlsaXR5IGxhYmVsLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBhY2Nlc3NpYmlsaXR5OiBTdHJpbmcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGFuIGhyZWYgYXR0cmlidXRlIGlzIHBhc3NlZCwgdGhlIGJhZGdlIGJlY29tZXMgYW4gYW5jaG9yLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBocmVmOiBTdHJpbmcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBiYWRnZSBhcHBlYXIgYXMgcGlsbCBzaGFwZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHBpbGw6IEJvb2xlYW4sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBiYWRnZSBsYWJlbC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgbGFiZWw6IFtOdW1iZXIsIFN0cmluZ10sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBiYWRnZSBhcHBlYXIgYXMgc2Vjb25kYXJ5IGluIHNpemUgdG8gdGhlIHBhcmVudCBlbGVtZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBzZWNvbmRhcnk6IEJvb2xlYW5cblxuICAgIH0sXG5cbiAgICBjb21wdXRlZDoge1xuXG4gICAgICAgIGNsYXNzZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJlZml4KHtcbiAgICAgICAgICAgICAgICAncGlsbCc6IHRoaXMucGlsbCxcbiAgICAgICAgICAgICAgICAnc2Vjb25kYXJ5JzogdGhpcy5zZWNvbmRhcnlcbiAgICAgICAgICAgIH0sIHRoaXMuJG9wdGlvbnMubmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IEJhZGdlIGZyb20gJy4vQmFkZ2UnO1xuaW1wb3J0IFZ1ZUluc3RhbGxlciBmcm9tICdAL0hlbHBlcnMvVnVlSW5zdGFsbGVyL1Z1ZUluc3RhbGxlcic7XG5cbmNvbnN0IHBsdWdpbiA9IFZ1ZUluc3RhbGxlci51c2Uoe1xuXG4gICAgaW5zdGFsbChWdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgVnVlSW5zdGFsbGVyLmNvbXBvbmVudHMoe1xuICAgICAgICAgICAgQmFkZ2VcbiAgICAgICAgfSk7XG4gICAgfVxuXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgQmFkZ2U7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlZHVjZWAgYW5kIGBfLnJlZHVjZVJpZ2h0YCwgd2l0aG91dCBzdXBwb3J0XG4gKiBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcywgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgY29sbGVjdGlvbmAgdXNpbmcgYGVhY2hGdW5jYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7Kn0gYWNjdW11bGF0b3IgVGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaXRBY2N1bSBTcGVjaWZ5IHVzaW5nIHRoZSBmaXJzdCBvciBsYXN0IGVsZW1lbnQgb2ZcbiAqICBgY29sbGVjdGlvbmAgYXMgdGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGBjb2xsZWN0aW9uYC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZVJlZHVjZShjb2xsZWN0aW9uLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSwgZWFjaEZ1bmMpIHtcbiAgZWFjaEZ1bmMoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgYWNjdW11bGF0b3IgPSBpbml0QWNjdW1cbiAgICAgID8gKGluaXRBY2N1bSA9IGZhbHNlLCB2YWx1ZSlcbiAgICAgIDogaXRlcmF0ZWUoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gIH0pO1xuICByZXR1cm4gYWNjdW11bGF0b3I7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVJlZHVjZTtcbiIsInZhciBhcnJheVJlZHVjZSA9IHJlcXVpcmUoJy4vX2FycmF5UmVkdWNlJyksXG4gICAgYmFzZUVhY2ggPSByZXF1aXJlKCcuL19iYXNlRWFjaCcpLFxuICAgIGJhc2VJdGVyYXRlZSA9IHJlcXVpcmUoJy4vX2Jhc2VJdGVyYXRlZScpLFxuICAgIGJhc2VSZWR1Y2UgPSByZXF1aXJlKCcuL19iYXNlUmVkdWNlJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xuXG4vKipcbiAqIFJlZHVjZXMgYGNvbGxlY3Rpb25gIHRvIGEgdmFsdWUgd2hpY2ggaXMgdGhlIGFjY3VtdWxhdGVkIHJlc3VsdCBvZiBydW5uaW5nXG4gKiBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gIHRocnUgYGl0ZXJhdGVlYCwgd2hlcmUgZWFjaCBzdWNjZXNzaXZlXG4gKiBpbnZvY2F0aW9uIGlzIHN1cHBsaWVkIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHByZXZpb3VzLiBJZiBgYWNjdW11bGF0b3JgXG4gKiBpcyBub3QgZ2l2ZW4sIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCBpcyB1c2VkIGFzIHRoZSBpbml0aWFsXG4gKiB2YWx1ZS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBmb3VyIGFyZ3VtZW50czpcbiAqIChhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gKlxuICogTWFueSBsb2Rhc2ggbWV0aG9kcyBhcmUgZ3VhcmRlZCB0byB3b3JrIGFzIGl0ZXJhdGVlcyBmb3IgbWV0aG9kcyBsaWtlXG4gKiBgXy5yZWR1Y2VgLCBgXy5yZWR1Y2VSaWdodGAsIGFuZCBgXy50cmFuc2Zvcm1gLlxuICpcbiAqIFRoZSBndWFyZGVkIG1ldGhvZHMgYXJlOlxuICogYGFzc2lnbmAsIGBkZWZhdWx0c2AsIGBkZWZhdWx0c0RlZXBgLCBgaW5jbHVkZXNgLCBgbWVyZ2VgLCBgb3JkZXJCeWAsXG4gKiBhbmQgYHNvcnRCeWBcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gKiBAc2VlIF8ucmVkdWNlUmlnaHRcbiAqIEBleGFtcGxlXG4gKlxuICogXy5yZWR1Y2UoWzEsIDJdLCBmdW5jdGlvbihzdW0sIG4pIHtcbiAqICAgcmV0dXJuIHN1bSArIG47XG4gKiB9LCAwKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLnJlZHVjZSh7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDEgfSwgZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gKiAgIChyZXN1bHRbdmFsdWVdIHx8IChyZXN1bHRbdmFsdWVdID0gW10pKS5wdXNoKGtleSk7XG4gKiAgIHJldHVybiByZXN1bHQ7XG4gKiB9LCB7fSk7XG4gKiAvLyA9PiB7ICcxJzogWydhJywgJ2MnXSwgJzInOiBbJ2InXSB9IChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKi9cbmZ1bmN0aW9uIHJlZHVjZShjb2xsZWN0aW9uLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlSZWR1Y2UgOiBiYXNlUmVkdWNlLFxuICAgICAgaW5pdEFjY3VtID0gYXJndW1lbnRzLmxlbmd0aCA8IDM7XG5cbiAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgYmFzZUl0ZXJhdGVlKGl0ZXJhdGVlLCA0KSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSwgYmFzZUVhY2gpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlZHVjZTtcbiIsInZhciBhc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnblZhbHVlJyksXG4gICAgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNldGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgcGF0aCBjcmVhdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VTZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSwgY3VzdG9taXplcikge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICBsYXN0SW5kZXggPSBsZW5ndGggLSAxLFxuICAgICAgbmVzdGVkID0gb2JqZWN0O1xuXG4gIHdoaWxlIChuZXN0ZWQgIT0gbnVsbCAmJiArK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKSxcbiAgICAgICAgbmV3VmFsdWUgPSB2YWx1ZTtcblxuICAgIGlmIChpbmRleCAhPSBsYXN0SW5kZXgpIHtcbiAgICAgIHZhciBvYmpWYWx1ZSA9IG5lc3RlZFtrZXldO1xuICAgICAgbmV3VmFsdWUgPSBjdXN0b21pemVyID8gY3VzdG9taXplcihvYmpWYWx1ZSwga2V5LCBuZXN0ZWQpIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBpc09iamVjdChvYmpWYWx1ZSlcbiAgICAgICAgICA/IG9ialZhbHVlXG4gICAgICAgICAgOiAoaXNJbmRleChwYXRoW2luZGV4ICsgMV0pID8gW10gOiB7fSk7XG4gICAgICB9XG4gICAgfVxuICAgIGFzc2lnblZhbHVlKG5lc3RlZCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgbmVzdGVkID0gbmVzdGVkW2tleV07XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlU2V0O1xuIiwidmFyIGJhc2VHZXQgPSByZXF1aXJlKCcuL19iYXNlR2V0JyksXG4gICAgYmFzZVNldCA9IHJlcXVpcmUoJy4vX2Jhc2VTZXQnKSxcbiAgICBjYXN0UGF0aCA9IHJlcXVpcmUoJy4vX2Nhc3RQYXRoJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgIGBfLnBpY2tCeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aHMgVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIHByb3BlcnR5LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYmFzZVBpY2tCeShvYmplY3QsIHBhdGhzLCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRocy5sZW5ndGgsXG4gICAgICByZXN1bHQgPSB7fTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBwYXRoID0gcGF0aHNbaW5kZXhdLFxuICAgICAgICB2YWx1ZSA9IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcblxuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIHBhdGgpKSB7XG4gICAgICBiYXNlU2V0KHJlc3VsdCwgY2FzdFBhdGgocGF0aCwgb2JqZWN0KSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VQaWNrQnk7XG4iLCJ2YXIgYXJyYXlQdXNoID0gcmVxdWlyZSgnLi9fYXJyYXlQdXNoJyksXG4gICAgZ2V0UHJvdG90eXBlID0gcmVxdWlyZSgnLi9fZ2V0UHJvdG90eXBlJyksXG4gICAgZ2V0U3ltYm9scyA9IHJlcXVpcmUoJy4vX2dldFN5bWJvbHMnKSxcbiAgICBzdHViQXJyYXkgPSByZXF1aXJlKCcuL3N0dWJBcnJheScpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzSW4gPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHdoaWxlIChvYmplY3QpIHtcbiAgICBhcnJheVB1c2gocmVzdWx0LCBnZXRTeW1ib2xzKG9iamVjdCkpO1xuICAgIG9iamVjdCA9IGdldFByb3RvdHlwZShvYmplY3QpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFN5bWJvbHNJbjtcbiIsInZhciBiYXNlR2V0QWxsS2V5cyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRBbGxLZXlzJyksXG4gICAgZ2V0U3ltYm9sc0luID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9sc0luJyksXG4gICAga2V5c0luID0gcmVxdWlyZSgnLi9rZXlzSW4nKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRBbGxLZXlzSW4ob2JqZWN0KSB7XG4gIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNJbiwgZ2V0U3ltYm9sc0luKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRBbGxLZXlzSW47XG4iLCJ2YXIgYXJyYXlNYXAgPSByZXF1aXJlKCcuL19hcnJheU1hcCcpLFxuICAgIGJhc2VJdGVyYXRlZSA9IHJlcXVpcmUoJy4vX2Jhc2VJdGVyYXRlZScpLFxuICAgIGJhc2VQaWNrQnkgPSByZXF1aXJlKCcuL19iYXNlUGlja0J5JyksXG4gICAgZ2V0QWxsS2V5c0luID0gcmVxdWlyZSgnLi9fZ2V0QWxsS2V5c0luJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIGBvYmplY3RgIHByb3BlcnRpZXMgYHByZWRpY2F0ZWAgcmV0dXJuc1xuICogdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50czogKHZhbHVlLCBrZXkpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBwcm9wZXJ0eS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAnMicsICdjJzogMyB9O1xuICpcbiAqIF8ucGlja0J5KG9iamVjdCwgXy5pc051bWJlcik7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2MnOiAzIH1cbiAqL1xuZnVuY3Rpb24gcGlja0J5KG9iamVjdCwgcHJlZGljYXRlKSB7XG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICB2YXIgcHJvcHMgPSBhcnJheU1hcChnZXRBbGxLZXlzSW4ob2JqZWN0KSwgZnVuY3Rpb24ocHJvcCkge1xuICAgIHJldHVybiBbcHJvcF07XG4gIH0pO1xuICBwcmVkaWNhdGUgPSBiYXNlSXRlcmF0ZWUocHJlZGljYXRlKTtcbiAgcmV0dXJuIGJhc2VQaWNrQnkob2JqZWN0LCBwcm9wcywgZnVuY3Rpb24odmFsdWUsIHBhdGgpIHtcbiAgICByZXR1cm4gcHJlZGljYXRlKHZhbHVlLCBwYXRoWzBdKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGlja0J5O1xuIiwidmFyIGJhc2VFYWNoID0gcmVxdWlyZSgnLi9fYmFzZUVhY2gnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maWx0ZXJgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZUZpbHRlcihjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGaWx0ZXI7XG4iLCJ2YXIgYXJyYXlGaWx0ZXIgPSByZXF1aXJlKCcuL19hcnJheUZpbHRlcicpLFxuICAgIGJhc2VGaWx0ZXIgPSByZXF1aXJlKCcuL19iYXNlRmlsdGVyJyksXG4gICAgYmFzZUl0ZXJhdGVlID0gcmVxdWlyZSgnLi9fYmFzZUl0ZXJhdGVlJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xuXG4vKipcbiAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gLCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgYWxsIGVsZW1lbnRzXG4gKiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHRocmVlXG4gKiBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAqXG4gKiAqKk5vdGU6KiogVW5saWtlIGBfLnJlbW92ZWAsIHRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICogQHNlZSBfLnJlamVjdFxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgdXNlcnMgPSBbXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAqIF07XG4gKlxuICogXy5maWx0ZXIodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XG4gKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnXVxuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbHRlcih1c2VycywgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0pO1xuICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmlsdGVyKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnXVxuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maWx0ZXIodXNlcnMsICdhY3RpdmUnKTtcbiAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAqL1xuZnVuY3Rpb24gZmlsdGVyKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUZpbHRlciA6IGJhc2VGaWx0ZXI7XG4gIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGJhc2VJdGVyYXRlZShwcmVkaWNhdGUsIDMpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmaWx0ZXI7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3RyaW5nYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3RyaW5nLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTdHJpbmcoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTdHJpbmcoMSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8XG4gICAgKCFpc0FycmF5KHZhbHVlKSAmJiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN0cmluZ1RhZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTdHJpbmc7XG4iLCJ2YXIgYmFzZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fYmFzZVByb3BlcnR5Jyk7XG5cbi8qKlxuICogR2V0cyB0aGUgc2l6ZSBvZiBhbiBBU0NJSSBgc3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdHJpbmcgc2l6ZS5cbiAqL1xudmFyIGFzY2lpU2l6ZSA9IGJhc2VQcm9wZXJ0eSgnbGVuZ3RoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gYXNjaWlTaXplO1xuIiwiLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNoYXJhY3RlciBjbGFzc2VzLiAqL1xudmFyIHJzQXN0cmFsUmFuZ2UgPSAnXFxcXHVkODAwLVxcXFx1ZGZmZicsXG4gICAgcnNDb21ib01hcmtzUmFuZ2UgPSAnXFxcXHUwMzAwLVxcXFx1MDM2ZicsXG4gICAgcmVDb21ib0hhbGZNYXJrc1JhbmdlID0gJ1xcXFx1ZmUyMC1cXFxcdWZlMmYnLFxuICAgIHJzQ29tYm9TeW1ib2xzUmFuZ2UgPSAnXFxcXHUyMGQwLVxcXFx1MjBmZicsXG4gICAgcnNDb21ib1JhbmdlID0gcnNDb21ib01hcmtzUmFuZ2UgKyByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgKyByc0NvbWJvU3ltYm9sc1JhbmdlLFxuICAgIHJzVmFyUmFuZ2UgPSAnXFxcXHVmZTBlXFxcXHVmZTBmJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNhcHR1cmUgZ3JvdXBzLiAqL1xudmFyIHJzWldKID0gJ1xcXFx1MjAwZCc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBzdHJpbmdzIHdpdGggW3plcm8td2lkdGggam9pbmVycyBvciBjb2RlIHBvaW50cyBmcm9tIHRoZSBhc3RyYWwgcGxhbmVzXShodHRwOi8vZWV2LmVlL2Jsb2cvMjAxNS8wOS8xMi9kYXJrLWNvcm5lcnMtb2YtdW5pY29kZS8pLiAqL1xudmFyIHJlSGFzVW5pY29kZSA9IFJlZ0V4cCgnWycgKyByc1pXSiArIHJzQXN0cmFsUmFuZ2UgICsgcnNDb21ib1JhbmdlICsgcnNWYXJSYW5nZSArICddJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBzdHJpbmdgIGNvbnRhaW5zIFVuaWNvZGUgc3ltYm9scy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYSBzeW1ib2wgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzVW5pY29kZShzdHJpbmcpIHtcbiAgcmV0dXJuIHJlSGFzVW5pY29kZS50ZXN0KHN0cmluZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzVW5pY29kZTtcbiIsIi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjaGFyYWN0ZXIgY2xhc3Nlcy4gKi9cbnZhciByc0FzdHJhbFJhbmdlID0gJ1xcXFx1ZDgwMC1cXFxcdWRmZmYnLFxuICAgIHJzQ29tYm9NYXJrc1JhbmdlID0gJ1xcXFx1MDMwMC1cXFxcdTAzNmYnLFxuICAgIHJlQ29tYm9IYWxmTWFya3NSYW5nZSA9ICdcXFxcdWZlMjAtXFxcXHVmZTJmJyxcbiAgICByc0NvbWJvU3ltYm9sc1JhbmdlID0gJ1xcXFx1MjBkMC1cXFxcdTIwZmYnLFxuICAgIHJzQ29tYm9SYW5nZSA9IHJzQ29tYm9NYXJrc1JhbmdlICsgcmVDb21ib0hhbGZNYXJrc1JhbmdlICsgcnNDb21ib1N5bWJvbHNSYW5nZSxcbiAgICByc1ZhclJhbmdlID0gJ1xcXFx1ZmUwZVxcXFx1ZmUwZic7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjYXB0dXJlIGdyb3Vwcy4gKi9cbnZhciByc0FzdHJhbCA9ICdbJyArIHJzQXN0cmFsUmFuZ2UgKyAnXScsXG4gICAgcnNDb21ibyA9ICdbJyArIHJzQ29tYm9SYW5nZSArICddJyxcbiAgICByc0ZpdHogPSAnXFxcXHVkODNjW1xcXFx1ZGZmYi1cXFxcdWRmZmZdJyxcbiAgICByc01vZGlmaWVyID0gJyg/OicgKyByc0NvbWJvICsgJ3wnICsgcnNGaXR6ICsgJyknLFxuICAgIHJzTm9uQXN0cmFsID0gJ1teJyArIHJzQXN0cmFsUmFuZ2UgKyAnXScsXG4gICAgcnNSZWdpb25hbCA9ICcoPzpcXFxcdWQ4M2NbXFxcXHVkZGU2LVxcXFx1ZGRmZl0pezJ9JyxcbiAgICByc1N1cnJQYWlyID0gJ1tcXFxcdWQ4MDAtXFxcXHVkYmZmXVtcXFxcdWRjMDAtXFxcXHVkZmZmXScsXG4gICAgcnNaV0ogPSAnXFxcXHUyMDBkJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIHJlZ2V4ZXMuICovXG52YXIgcmVPcHRNb2QgPSByc01vZGlmaWVyICsgJz8nLFxuICAgIHJzT3B0VmFyID0gJ1snICsgcnNWYXJSYW5nZSArICddPycsXG4gICAgcnNPcHRKb2luID0gJyg/OicgKyByc1pXSiArICcoPzonICsgW3JzTm9uQXN0cmFsLCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyXS5qb2luKCd8JykgKyAnKScgKyByc09wdFZhciArIHJlT3B0TW9kICsgJykqJyxcbiAgICByc1NlcSA9IHJzT3B0VmFyICsgcmVPcHRNb2QgKyByc09wdEpvaW4sXG4gICAgcnNTeW1ib2wgPSAnKD86JyArIFtyc05vbkFzdHJhbCArIHJzQ29tYm8gKyAnPycsIHJzQ29tYm8sIHJzUmVnaW9uYWwsIHJzU3VyclBhaXIsIHJzQXN0cmFsXS5qb2luKCd8JykgKyAnKSc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIFtzdHJpbmcgc3ltYm9sc10oaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtdW5pY29kZSkuICovXG52YXIgcmVVbmljb2RlID0gUmVnRXhwKHJzRml0eiArICcoPz0nICsgcnNGaXR6ICsgJyl8JyArIHJzU3ltYm9sICsgcnNTZXEsICdnJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgc2l6ZSBvZiBhIFVuaWNvZGUgYHN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyBpbnNwZWN0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3RyaW5nIHNpemUuXG4gKi9cbmZ1bmN0aW9uIHVuaWNvZGVTaXplKHN0cmluZykge1xuICB2YXIgcmVzdWx0ID0gcmVVbmljb2RlLmxhc3RJbmRleCA9IDA7XG4gIHdoaWxlIChyZVVuaWNvZGUudGVzdChzdHJpbmcpKSB7XG4gICAgKytyZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB1bmljb2RlU2l6ZTtcbiIsInZhciBhc2NpaVNpemUgPSByZXF1aXJlKCcuL19hc2NpaVNpemUnKSxcbiAgICBoYXNVbmljb2RlID0gcmVxdWlyZSgnLi9faGFzVW5pY29kZScpLFxuICAgIHVuaWNvZGVTaXplID0gcmVxdWlyZSgnLi9fdW5pY29kZVNpemUnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBudW1iZXIgb2Ygc3ltYm9scyBpbiBgc3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdHJpbmcgc2l6ZS5cbiAqL1xuZnVuY3Rpb24gc3RyaW5nU2l6ZShzdHJpbmcpIHtcbiAgcmV0dXJuIGhhc1VuaWNvZGUoc3RyaW5nKVxuICAgID8gdW5pY29kZVNpemUoc3RyaW5nKVxuICAgIDogYXNjaWlTaXplKHN0cmluZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RyaW5nU2l6ZTtcbiIsInZhciBiYXNlS2V5cyA9IHJlcXVpcmUoJy4vX2Jhc2VLZXlzJyksXG4gICAgZ2V0VGFnID0gcmVxdWlyZSgnLi9fZ2V0VGFnJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyksXG4gICAgaXNTdHJpbmcgPSByZXF1aXJlKCcuL2lzU3RyaW5nJyksXG4gICAgc3RyaW5nU2l6ZSA9IHJlcXVpcmUoJy4vX3N0cmluZ1NpemUnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nO1xuXG4vKipcbiAqIEdldHMgdGhlIHNpemUgb2YgYGNvbGxlY3Rpb25gIGJ5IHJldHVybmluZyBpdHMgbGVuZ3RoIGZvciBhcnJheS1saWtlXG4gKiB2YWx1ZXMgb3IgdGhlIG51bWJlciBvZiBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBmb3Igb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb2xsZWN0aW9uIHNpemUuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uc2l6ZShbMSwgMiwgM10pO1xuICogLy8gPT4gM1xuICpcbiAqIF8uc2l6ZSh7ICdhJzogMSwgJ2InOiAyIH0pO1xuICogLy8gPT4gMlxuICpcbiAqIF8uc2l6ZSgncGViYmxlcycpO1xuICogLy8gPT4gN1xuICovXG5mdW5jdGlvbiBzaXplKGNvbGxlY3Rpb24pIHtcbiAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGlmIChpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgIHJldHVybiBpc1N0cmluZyhjb2xsZWN0aW9uKSA/IHN0cmluZ1NpemUoY29sbGVjdGlvbikgOiBjb2xsZWN0aW9uLmxlbmd0aDtcbiAgfVxuICB2YXIgdGFnID0gZ2V0VGFnKGNvbGxlY3Rpb24pO1xuICBpZiAodGFnID09IG1hcFRhZyB8fCB0YWcgPT0gc2V0VGFnKSB7XG4gICAgcmV0dXJuIGNvbGxlY3Rpb24uc2l6ZTtcbiAgfVxuICByZXR1cm4gYmFzZUtleXMoY29sbGVjdGlvbikubGVuZ3RoO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNpemU7XG4iLCJ2YXIgYmFzZUVhY2ggPSByZXF1aXJlKCcuL19iYXNlRWFjaCcpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hcGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlTWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gaXNBcnJheUxpa2UoY29sbGVjdGlvbikgPyBBcnJheShjb2xsZWN0aW9uLmxlbmd0aCkgOiBbXTtcblxuICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gaXRlcmF0ZWUodmFsdWUsIGtleSwgY29sbGVjdGlvbik7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNYXA7XG4iLCJ2YXIgYXJyYXlNYXAgPSByZXF1aXJlKCcuL19hcnJheU1hcCcpLFxuICAgIGJhc2VJdGVyYXRlZSA9IHJlcXVpcmUoJy4vX2Jhc2VJdGVyYXRlZScpLFxuICAgIGJhc2VNYXAgPSByZXF1aXJlKCcuL19iYXNlTWFwJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdmFsdWVzIGJ5IHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCB0aHJ1XG4gKiBgaXRlcmF0ZWVgLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAqICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAqXG4gKiBNYW55IGxvZGFzaCBtZXRob2RzIGFyZSBndWFyZGVkIHRvIHdvcmsgYXMgaXRlcmF0ZWVzIGZvciBtZXRob2RzIGxpa2VcbiAqIGBfLmV2ZXJ5YCwgYF8uZmlsdGVyYCwgYF8ubWFwYCwgYF8ubWFwVmFsdWVzYCwgYF8ucmVqZWN0YCwgYW5kIGBfLnNvbWVgLlxuICpcbiAqIFRoZSBndWFyZGVkIG1ldGhvZHMgYXJlOlxuICogYGFyeWAsIGBjaHVua2AsIGBjdXJyeWAsIGBjdXJyeVJpZ2h0YCwgYGRyb3BgLCBgZHJvcFJpZ2h0YCwgYGV2ZXJ5YCxcbiAqIGBmaWxsYCwgYGludmVydGAsIGBwYXJzZUludGAsIGByYW5kb21gLCBgcmFuZ2VgLCBgcmFuZ2VSaWdodGAsIGByZXBlYXRgLFxuICogYHNhbXBsZVNpemVgLCBgc2xpY2VgLCBgc29tZWAsIGBzb3J0QnlgLCBgc3BsaXRgLCBgdGFrZWAsIGB0YWtlUmlnaHRgLFxuICogYHRlbXBsYXRlYCwgYHRyaW1gLCBgdHJpbUVuZGAsIGB0cmltU3RhcnRgLCBhbmQgYHdvcmRzYFxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAqICAgcmV0dXJuIG4gKiBuO1xuICogfVxuICpcbiAqIF8ubWFwKFs0LCA4XSwgc3F1YXJlKTtcbiAqIC8vID0+IFsxNiwgNjRdXG4gKlxuICogXy5tYXAoeyAnYSc6IDQsICdiJzogOCB9LCBzcXVhcmUpO1xuICogLy8gPT4gWzE2LCA2NF0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiB2YXIgdXNlcnMgPSBbXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JyB9LFxuICogICB7ICd1c2VyJzogJ2ZyZWQnIH1cbiAqIF07XG4gKlxuICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLm1hcCh1c2VycywgJ3VzZXInKTtcbiAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICovXG5mdW5jdGlvbiBtYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlNYXAgOiBiYXNlTWFwO1xuICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBiYXNlSXRlcmF0ZWUoaXRlcmF0ZWUsIDMpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXA7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNsaWNlYCB3aXRob3V0IGFuIGl0ZXJhdGVlIGNhbGwgZ3VhcmQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzbGljZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBiYXNlU2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gLXN0YXJ0ID4gbGVuZ3RoID8gMCA6IChsZW5ndGggKyBzdGFydCk7XG4gIH1cbiAgZW5kID0gZW5kID4gbGVuZ3RoID8gbGVuZ3RoIDogZW5kO1xuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5ndGg7XG4gIH1cbiAgbGVuZ3RoID0gc3RhcnQgPiBlbmQgPyAwIDogKChlbmQgLSBzdGFydCkgPj4+IDApO1xuICBzdGFydCA+Pj49IDA7XG5cbiAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGFycmF5W2luZGV4ICsgc3RhcnRdO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVNsaWNlO1xuIiwidmFyIGJhc2VTbGljZSA9IHJlcXVpcmUoJy4vX2Jhc2VTbGljZScpO1xuXG4vKipcbiAqIENhc3RzIGBhcnJheWAgdG8gYSBzbGljZSBpZiBpdCdzIG5lZWRlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IHNsaWNlLlxuICovXG5mdW5jdGlvbiBjYXN0U2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiBlbmQ7XG4gIHJldHVybiAoIXN0YXJ0ICYmIGVuZCA+PSBsZW5ndGgpID8gYXJyYXkgOiBiYXNlU2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhc3RTbGljZTtcbiIsIi8qKlxuICogQ29udmVydHMgYW4gQVNDSUkgYHN0cmluZ2AgdG8gYW4gYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFzY2lpVG9BcnJheShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5zcGxpdCgnJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNjaWlUb0FycmF5O1xuIiwiLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNoYXJhY3RlciBjbGFzc2VzLiAqL1xudmFyIHJzQXN0cmFsUmFuZ2UgPSAnXFxcXHVkODAwLVxcXFx1ZGZmZicsXG4gICAgcnNDb21ib01hcmtzUmFuZ2UgPSAnXFxcXHUwMzAwLVxcXFx1MDM2ZicsXG4gICAgcmVDb21ib0hhbGZNYXJrc1JhbmdlID0gJ1xcXFx1ZmUyMC1cXFxcdWZlMmYnLFxuICAgIHJzQ29tYm9TeW1ib2xzUmFuZ2UgPSAnXFxcXHUyMGQwLVxcXFx1MjBmZicsXG4gICAgcnNDb21ib1JhbmdlID0gcnNDb21ib01hcmtzUmFuZ2UgKyByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgKyByc0NvbWJvU3ltYm9sc1JhbmdlLFxuICAgIHJzVmFyUmFuZ2UgPSAnXFxcXHVmZTBlXFxcXHVmZTBmJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNhcHR1cmUgZ3JvdXBzLiAqL1xudmFyIHJzQXN0cmFsID0gJ1snICsgcnNBc3RyYWxSYW5nZSArICddJyxcbiAgICByc0NvbWJvID0gJ1snICsgcnNDb21ib1JhbmdlICsgJ10nLFxuICAgIHJzRml0eiA9ICdcXFxcdWQ4M2NbXFxcXHVkZmZiLVxcXFx1ZGZmZl0nLFxuICAgIHJzTW9kaWZpZXIgPSAnKD86JyArIHJzQ29tYm8gKyAnfCcgKyByc0ZpdHogKyAnKScsXG4gICAgcnNOb25Bc3RyYWwgPSAnW14nICsgcnNBc3RyYWxSYW5nZSArICddJyxcbiAgICByc1JlZ2lvbmFsID0gJyg/OlxcXFx1ZDgzY1tcXFxcdWRkZTYtXFxcXHVkZGZmXSl7Mn0nLFxuICAgIHJzU3VyclBhaXIgPSAnW1xcXFx1ZDgwMC1cXFxcdWRiZmZdW1xcXFx1ZGMwMC1cXFxcdWRmZmZdJyxcbiAgICByc1pXSiA9ICdcXFxcdTIwMGQnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgcmVnZXhlcy4gKi9cbnZhciByZU9wdE1vZCA9IHJzTW9kaWZpZXIgKyAnPycsXG4gICAgcnNPcHRWYXIgPSAnWycgKyByc1ZhclJhbmdlICsgJ10/JyxcbiAgICByc09wdEpvaW4gPSAnKD86JyArIHJzWldKICsgJyg/OicgKyBbcnNOb25Bc3RyYWwsIHJzUmVnaW9uYWwsIHJzU3VyclBhaXJdLmpvaW4oJ3wnKSArICcpJyArIHJzT3B0VmFyICsgcmVPcHRNb2QgKyAnKSonLFxuICAgIHJzU2VxID0gcnNPcHRWYXIgKyByZU9wdE1vZCArIHJzT3B0Sm9pbixcbiAgICByc1N5bWJvbCA9ICcoPzonICsgW3JzTm9uQXN0cmFsICsgcnNDb21ibyArICc/JywgcnNDb21ibywgcnNSZWdpb25hbCwgcnNTdXJyUGFpciwgcnNBc3RyYWxdLmpvaW4oJ3wnKSArICcpJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggW3N0cmluZyBzeW1ib2xzXShodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC11bmljb2RlKS4gKi9cbnZhciByZVVuaWNvZGUgPSBSZWdFeHAocnNGaXR6ICsgJyg/PScgKyByc0ZpdHogKyAnKXwnICsgcnNTeW1ib2wgKyByc1NlcSwgJ2cnKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFVuaWNvZGUgYHN0cmluZ2AgdG8gYW4gYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHVuaWNvZGVUb0FycmF5KHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlVW5pY29kZSkgfHwgW107XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdW5pY29kZVRvQXJyYXk7XG4iLCJ2YXIgYXNjaWlUb0FycmF5ID0gcmVxdWlyZSgnLi9fYXNjaWlUb0FycmF5JyksXG4gICAgaGFzVW5pY29kZSA9IHJlcXVpcmUoJy4vX2hhc1VuaWNvZGUnKSxcbiAgICB1bmljb2RlVG9BcnJheSA9IHJlcXVpcmUoJy4vX3VuaWNvZGVUb0FycmF5Jyk7XG5cbi8qKlxuICogQ29udmVydHMgYHN0cmluZ2AgdG8gYW4gYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1RvQXJyYXkoc3RyaW5nKSB7XG4gIHJldHVybiBoYXNVbmljb2RlKHN0cmluZylcbiAgICA/IHVuaWNvZGVUb0FycmF5KHN0cmluZylcbiAgICA6IGFzY2lpVG9BcnJheShzdHJpbmcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0cmluZ1RvQXJyYXk7XG4iLCJ2YXIgY2FzdFNsaWNlID0gcmVxdWlyZSgnLi9fY2FzdFNsaWNlJyksXG4gICAgaGFzVW5pY29kZSA9IHJlcXVpcmUoJy4vX2hhc1VuaWNvZGUnKSxcbiAgICBzdHJpbmdUb0FycmF5ID0gcmVxdWlyZSgnLi9fc3RyaW5nVG9BcnJheScpLFxuICAgIHRvU3RyaW5nID0gcmVxdWlyZSgnLi90b1N0cmluZycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmxvd2VyRmlyc3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZSBUaGUgbmFtZSBvZiB0aGUgYFN0cmluZ2AgY2FzZSBtZXRob2QgdG8gdXNlLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2FzZUZpcnN0KG1ldGhvZE5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG5cbiAgICB2YXIgc3RyU3ltYm9scyA9IGhhc1VuaWNvZGUoc3RyaW5nKVxuICAgICAgPyBzdHJpbmdUb0FycmF5KHN0cmluZylcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgdmFyIGNociA9IHN0clN5bWJvbHNcbiAgICAgID8gc3RyU3ltYm9sc1swXVxuICAgICAgOiBzdHJpbmcuY2hhckF0KDApO1xuXG4gICAgdmFyIHRyYWlsaW5nID0gc3RyU3ltYm9sc1xuICAgICAgPyBjYXN0U2xpY2Uoc3RyU3ltYm9scywgMSkuam9pbignJylcbiAgICAgIDogc3RyaW5nLnNsaWNlKDEpO1xuXG4gICAgcmV0dXJuIGNoclttZXRob2ROYW1lXSgpICsgdHJhaWxpbmc7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQ2FzZUZpcnN0O1xuIiwidmFyIGNyZWF0ZUNhc2VGaXJzdCA9IHJlcXVpcmUoJy4vX2NyZWF0ZUNhc2VGaXJzdCcpO1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYHN0cmluZ2AgdG8gdXBwZXIgY2FzZS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy51cHBlckZpcnN0KCdmcmVkJyk7XG4gKiAvLyA9PiAnRnJlZCdcbiAqXG4gKiBfLnVwcGVyRmlyc3QoJ0ZSRUQnKTtcbiAqIC8vID0+ICdGUkVEJ1xuICovXG52YXIgdXBwZXJGaXJzdCA9IGNyZWF0ZUNhc2VGaXJzdCgndG9VcHBlckNhc2UnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB1cHBlckZpcnN0O1xuIiwidmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi90b1N0cmluZycpLFxuICAgIHVwcGVyRmlyc3QgPSByZXF1aXJlKCcuL3VwcGVyRmlyc3QnKTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGBzdHJpbmdgIHRvIHVwcGVyIGNhc2UgYW5kIHRoZSByZW1haW5pbmdcbiAqIHRvIGxvd2VyIGNhc2UuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY2FwaXRhbGl6ZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNhcGl0YWxpemVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5jYXBpdGFsaXplKCdGUkVEJyk7XG4gKiAvLyA9PiAnRnJlZCdcbiAqL1xuZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHJpbmcpIHtcbiAgcmV0dXJuIHVwcGVyRmlyc3QodG9TdHJpbmcoc3RyaW5nKS50b0xvd2VyQ2FzZSgpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYXBpdGFsaXplO1xuIiwidmFyIGNhcGl0YWxpemUgPSByZXF1aXJlKCcuL2NhcGl0YWxpemUnKSxcbiAgICBjcmVhdGVDb21wb3VuZGVyID0gcmVxdWlyZSgnLi9fY3JlYXRlQ29tcG91bmRlcicpO1xuXG4vKipcbiAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIFtjYW1lbCBjYXNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DYW1lbENhc2UpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjYW1lbCBjYXNlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uY2FtZWxDYXNlKCdGb28gQmFyJyk7XG4gKiAvLyA9PiAnZm9vQmFyJ1xuICpcbiAqIF8uY2FtZWxDYXNlKCctLWZvby1iYXItLScpO1xuICogLy8gPT4gJ2Zvb0JhcidcbiAqXG4gKiBfLmNhbWVsQ2FzZSgnX19GT09fQkFSX18nKTtcbiAqIC8vID0+ICdmb29CYXInXG4gKi9cbnZhciBjYW1lbENhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgd29yZCA9IHdvcmQudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/IGNhcGl0YWxpemUod29yZCkgOiB3b3JkKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNhbWVsQ2FzZTtcbiIsInZhciBXZWFrTWFwID0gcmVxdWlyZSgnLi9fV2Vha01hcCcpO1xuXG4vKiogVXNlZCB0byBzdG9yZSBmdW5jdGlvbiBtZXRhZGF0YS4gKi9cbnZhciBtZXRhTWFwID0gV2Vha01hcCAmJiBuZXcgV2Vha01hcDtcblxubW9kdWxlLmV4cG9ydHMgPSBtZXRhTWFwO1xuIiwidmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpLFxuICAgIG1ldGFNYXAgPSByZXF1aXJlKCcuL19tZXRhTWFwJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldERhdGFgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaG90IGxvb3Agc2hvcnRpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFzc29jaWF0ZSBtZXRhZGF0YSB3aXRoLlxuICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXRhZGF0YS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gKi9cbnZhciBiYXNlU2V0RGF0YSA9ICFtZXRhTWFwID8gaWRlbnRpdHkgOiBmdW5jdGlvbihmdW5jLCBkYXRhKSB7XG4gIG1ldGFNYXAuc2V0KGZ1bmMsIGRhdGEpO1xuICByZXR1cm4gZnVuYztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVNldERhdGE7XG4iLCJ2YXIgYmFzZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX2Jhc2VDcmVhdGUnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwcm9kdWNlcyBhbiBpbnN0YW5jZSBvZiBgQ3RvcmAgcmVnYXJkbGVzcyBvZlxuICogd2hldGhlciBpdCB3YXMgaW52b2tlZCBhcyBwYXJ0IG9mIGEgYG5ld2AgZXhwcmVzc2lvbiBvciBieSBgY2FsbGAgb3IgYGFwcGx5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gQ3RvciBUaGUgY29uc3RydWN0b3IgdG8gd3JhcC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUN0b3IoQ3Rvcikge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgLy8gVXNlIGEgYHN3aXRjaGAgc3RhdGVtZW50IHRvIHdvcmsgd2l0aCBjbGFzcyBjb25zdHJ1Y3RvcnMuIFNlZVxuICAgIC8vIGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtZnVuY3Rpb24tb2JqZWN0cy1jYWxsLXRoaXNhcmd1bWVudC1hcmd1bWVudHNsaXN0XG4gICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6IHJldHVybiBuZXcgQ3RvcjtcbiAgICAgIGNhc2UgMTogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0pO1xuICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICBjYXNlIDM6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgIGNhc2UgNDogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICAgICAgY2FzZSA1OiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSwgYXJnc1s0XSk7XG4gICAgICBjYXNlIDY6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdLCBhcmdzWzVdKTtcbiAgICAgIGNhc2UgNzogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10sIGFyZ3NbNF0sIGFyZ3NbNV0sIGFyZ3NbNl0pO1xuICAgIH1cbiAgICB2YXIgdGhpc0JpbmRpbmcgPSBiYXNlQ3JlYXRlKEN0b3IucHJvdG90eXBlKSxcbiAgICAgICAgcmVzdWx0ID0gQ3Rvci5hcHBseSh0aGlzQmluZGluZywgYXJncyk7XG5cbiAgICAvLyBNaW1pYyB0aGUgY29uc3RydWN0b3IncyBgcmV0dXJuYCBiZWhhdmlvci5cbiAgICAvLyBTZWUgaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4MTMuMi4yIGZvciBtb3JlIGRldGFpbHMuXG4gICAgcmV0dXJuIGlzT2JqZWN0KHJlc3VsdCkgPyByZXN1bHQgOiB0aGlzQmluZGluZztcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVDdG9yO1xuIiwidmFyIGNyZWF0ZUN0b3IgPSByZXF1aXJlKCcuL19jcmVhdGVDdG9yJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgZnVuY3Rpb24gbWV0YWRhdGEuICovXG52YXIgV1JBUF9CSU5EX0ZMQUcgPSAxO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCB0byBpbnZva2UgaXQgd2l0aCB0aGUgb3B0aW9uYWwgYHRoaXNgXG4gKiBiaW5kaW5nIG9mIGB0aGlzQXJnYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmluZChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnKSB7XG4gIHZhciBpc0JpbmQgPSBiaXRtYXNrICYgV1JBUF9CSU5EX0ZMQUcsXG4gICAgICBDdG9yID0gY3JlYXRlQ3RvcihmdW5jKTtcblxuICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgIHZhciBmbiA9ICh0aGlzICYmIHRoaXMgIT09IHJvb3QgJiYgdGhpcyBpbnN0YW5jZW9mIHdyYXBwZXIpID8gQ3RvciA6IGZ1bmM7XG4gICAgcmV0dXJuIGZuLmFwcGx5KGlzQmluZCA/IHRoaXNBcmcgOiB0aGlzLCBhcmd1bWVudHMpO1xuICB9XG4gIHJldHVybiB3cmFwcGVyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUJpbmQ7XG4iLCIvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXg7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSB0aGF0IGlzIHRoZSBjb21wb3NpdGlvbiBvZiBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMsXG4gKiBwbGFjZWhvbGRlcnMsIGFuZCBwcm92aWRlZCBhcmd1bWVudHMgaW50byBhIHNpbmdsZSBhcnJheSBvZiBhcmd1bWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIHByb3ZpZGVkIGFyZ3VtZW50cy5cbiAqIEBwYXJhbSB7QXJyYXl9IHBhcnRpYWxzIFRoZSBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aG9zZSBwcm92aWRlZC5cbiAqIEBwYXJhbSB7QXJyYXl9IGhvbGRlcnMgVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAqIEBwYXJhbXMge2Jvb2xlYW59IFtpc0N1cnJpZWRdIFNwZWNpZnkgY29tcG9zaW5nIGZvciBhIGN1cnJpZWQgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21wb3NlZCBhcmd1bWVudHMuXG4gKi9cbmZ1bmN0aW9uIGNvbXBvc2VBcmdzKGFyZ3MsIHBhcnRpYWxzLCBob2xkZXJzLCBpc0N1cnJpZWQpIHtcbiAgdmFyIGFyZ3NJbmRleCA9IC0xLFxuICAgICAgYXJnc0xlbmd0aCA9IGFyZ3MubGVuZ3RoLFxuICAgICAgaG9sZGVyc0xlbmd0aCA9IGhvbGRlcnMubGVuZ3RoLFxuICAgICAgbGVmdEluZGV4ID0gLTEsXG4gICAgICBsZWZ0TGVuZ3RoID0gcGFydGlhbHMubGVuZ3RoLFxuICAgICAgcmFuZ2VMZW5ndGggPSBuYXRpdmVNYXgoYXJnc0xlbmd0aCAtIGhvbGRlcnNMZW5ndGgsIDApLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobGVmdExlbmd0aCArIHJhbmdlTGVuZ3RoKSxcbiAgICAgIGlzVW5jdXJyaWVkID0gIWlzQ3VycmllZDtcblxuICB3aGlsZSAoKytsZWZ0SW5kZXggPCBsZWZ0TGVuZ3RoKSB7XG4gICAgcmVzdWx0W2xlZnRJbmRleF0gPSBwYXJ0aWFsc1tsZWZ0SW5kZXhdO1xuICB9XG4gIHdoaWxlICgrK2FyZ3NJbmRleCA8IGhvbGRlcnNMZW5ndGgpIHtcbiAgICBpZiAoaXNVbmN1cnJpZWQgfHwgYXJnc0luZGV4IDwgYXJnc0xlbmd0aCkge1xuICAgICAgcmVzdWx0W2hvbGRlcnNbYXJnc0luZGV4XV0gPSBhcmdzW2FyZ3NJbmRleF07XG4gICAgfVxuICB9XG4gIHdoaWxlIChyYW5nZUxlbmd0aC0tKSB7XG4gICAgcmVzdWx0W2xlZnRJbmRleCsrXSA9IGFyZ3NbYXJnc0luZGV4KytdO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29tcG9zZUFyZ3M7XG4iLCIvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXg7XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBjb21wb3NlQXJnc2AgZXhjZXB0IHRoYXQgdGhlIGFyZ3VtZW50cyBjb21wb3NpdGlvblxuICogaXMgdGFpbG9yZWQgZm9yIGBfLnBhcnRpYWxSaWdodGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIHByb3ZpZGVkIGFyZ3VtZW50cy5cbiAqIEBwYXJhbSB7QXJyYXl9IHBhcnRpYWxzIFRoZSBhcmd1bWVudHMgdG8gYXBwZW5kIHRvIHRob3NlIHByb3ZpZGVkLlxuICogQHBhcmFtIHtBcnJheX0gaG9sZGVycyBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICogQHBhcmFtcyB7Ym9vbGVhbn0gW2lzQ3VycmllZF0gU3BlY2lmeSBjb21wb3NpbmcgZm9yIGEgY3VycmllZCBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNvbXBvc2VkIGFyZ3VtZW50cy5cbiAqL1xuZnVuY3Rpb24gY29tcG9zZUFyZ3NSaWdodChhcmdzLCBwYXJ0aWFscywgaG9sZGVycywgaXNDdXJyaWVkKSB7XG4gIHZhciBhcmdzSW5kZXggPSAtMSxcbiAgICAgIGFyZ3NMZW5ndGggPSBhcmdzLmxlbmd0aCxcbiAgICAgIGhvbGRlcnNJbmRleCA9IC0xLFxuICAgICAgaG9sZGVyc0xlbmd0aCA9IGhvbGRlcnMubGVuZ3RoLFxuICAgICAgcmlnaHRJbmRleCA9IC0xLFxuICAgICAgcmlnaHRMZW5ndGggPSBwYXJ0aWFscy5sZW5ndGgsXG4gICAgICByYW5nZUxlbmd0aCA9IG5hdGl2ZU1heChhcmdzTGVuZ3RoIC0gaG9sZGVyc0xlbmd0aCwgMCksXG4gICAgICByZXN1bHQgPSBBcnJheShyYW5nZUxlbmd0aCArIHJpZ2h0TGVuZ3RoKSxcbiAgICAgIGlzVW5jdXJyaWVkID0gIWlzQ3VycmllZDtcblxuICB3aGlsZSAoKythcmdzSW5kZXggPCByYW5nZUxlbmd0aCkge1xuICAgIHJlc3VsdFthcmdzSW5kZXhdID0gYXJnc1thcmdzSW5kZXhdO1xuICB9XG4gIHZhciBvZmZzZXQgPSBhcmdzSW5kZXg7XG4gIHdoaWxlICgrK3JpZ2h0SW5kZXggPCByaWdodExlbmd0aCkge1xuICAgIHJlc3VsdFtvZmZzZXQgKyByaWdodEluZGV4XSA9IHBhcnRpYWxzW3JpZ2h0SW5kZXhdO1xuICB9XG4gIHdoaWxlICgrK2hvbGRlcnNJbmRleCA8IGhvbGRlcnNMZW5ndGgpIHtcbiAgICBpZiAoaXNVbmN1cnJpZWQgfHwgYXJnc0luZGV4IDwgYXJnc0xlbmd0aCkge1xuICAgICAgcmVzdWx0W29mZnNldCArIGhvbGRlcnNbaG9sZGVyc0luZGV4XV0gPSBhcmdzW2FyZ3NJbmRleCsrXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb21wb3NlQXJnc1JpZ2h0O1xuIiwiLyoqXG4gKiBHZXRzIHRoZSBudW1iZXIgb2YgYHBsYWNlaG9sZGVyYCBvY2N1cnJlbmNlcyBpbiBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0gcGxhY2Vob2xkZXIgVGhlIHBsYWNlaG9sZGVyIHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBwbGFjZWhvbGRlciBjb3VudC5cbiAqL1xuZnVuY3Rpb24gY291bnRIb2xkZXJzKGFycmF5LCBwbGFjZWhvbGRlcikge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gMDtcblxuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoYXJyYXlbbGVuZ3RoXSA9PT0gcGxhY2Vob2xkZXIpIHtcbiAgICAgICsrcmVzdWx0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvdW50SG9sZGVycztcbiIsIi8qKlxuICogVGhlIGZ1bmN0aW9uIHdob3NlIHByb3RvdHlwZSBjaGFpbiBzZXF1ZW5jZSB3cmFwcGVycyBpbmhlcml0IGZyb20uXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYmFzZUxvZGFzaCgpIHtcbiAgLy8gTm8gb3BlcmF0aW9uIHBlcmZvcm1lZC5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlTG9kYXNoO1xuIiwidmFyIGJhc2VDcmVhdGUgPSByZXF1aXJlKCcuL19iYXNlQ3JlYXRlJyksXG4gICAgYmFzZUxvZGFzaCA9IHJlcXVpcmUoJy4vX2Jhc2VMb2Rhc2gnKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdGhlIG1heGltdW0gbGVuZ3RoIGFuZCBpbmRleCBvZiBhbiBhcnJheS4gKi9cbnZhciBNQVhfQVJSQVlfTEVOR1RIID0gNDI5NDk2NzI5NTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbGF6eSB3cmFwcGVyIG9iamVjdCB3aGljaCB3cmFwcyBgdmFsdWVgIHRvIGVuYWJsZSBsYXp5IGV2YWx1YXRpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAqL1xuZnVuY3Rpb24gTGF6eVdyYXBwZXIodmFsdWUpIHtcbiAgdGhpcy5fX3dyYXBwZWRfXyA9IHZhbHVlO1xuICB0aGlzLl9fYWN0aW9uc19fID0gW107XG4gIHRoaXMuX19kaXJfXyA9IDE7XG4gIHRoaXMuX19maWx0ZXJlZF9fID0gZmFsc2U7XG4gIHRoaXMuX19pdGVyYXRlZXNfXyA9IFtdO1xuICB0aGlzLl9fdGFrZUNvdW50X18gPSBNQVhfQVJSQVlfTEVOR1RIO1xuICB0aGlzLl9fdmlld3NfXyA9IFtdO1xufVxuXG4vLyBFbnN1cmUgYExhenlXcmFwcGVyYCBpcyBhbiBpbnN0YW5jZSBvZiBgYmFzZUxvZGFzaGAuXG5MYXp5V3JhcHBlci5wcm90b3R5cGUgPSBiYXNlQ3JlYXRlKGJhc2VMb2Rhc2gucHJvdG90eXBlKTtcbkxhenlXcmFwcGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExhenlXcmFwcGVyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExhenlXcmFwcGVyO1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGB1bmRlZmluZWRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi4zLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5ub29wKTtcbiAqIC8vID0+IFt1bmRlZmluZWQsIHVuZGVmaW5lZF1cbiAqL1xuZnVuY3Rpb24gbm9vcCgpIHtcbiAgLy8gTm8gb3BlcmF0aW9uIHBlcmZvcm1lZC5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBub29wO1xuIiwidmFyIG1ldGFNYXAgPSByZXF1aXJlKCcuL19tZXRhTWFwJyksXG4gICAgbm9vcCA9IHJlcXVpcmUoJy4vbm9vcCcpO1xuXG4vKipcbiAqIEdldHMgbWV0YWRhdGEgZm9yIGBmdW5jYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWV0YWRhdGEgZm9yIGBmdW5jYC5cbiAqL1xudmFyIGdldERhdGEgPSAhbWV0YU1hcCA/IG5vb3AgOiBmdW5jdGlvbihmdW5jKSB7XG4gIHJldHVybiBtZXRhTWFwLmdldChmdW5jKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0RGF0YTtcbiIsIi8qKiBVc2VkIHRvIGxvb2t1cCB1bm1pbmlmaWVkIGZ1bmN0aW9uIG5hbWVzLiAqL1xudmFyIHJlYWxOYW1lcyA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlYWxOYW1lcztcbiIsInZhciByZWFsTmFtZXMgPSByZXF1aXJlKCcuL19yZWFsTmFtZXMnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBHZXRzIHRoZSBuYW1lIG9mIGBmdW5jYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBuYW1lLlxuICovXG5mdW5jdGlvbiBnZXRGdW5jTmFtZShmdW5jKSB7XG4gIHZhciByZXN1bHQgPSAoZnVuYy5uYW1lICsgJycpLFxuICAgICAgYXJyYXkgPSByZWFsTmFtZXNbcmVzdWx0XSxcbiAgICAgIGxlbmd0aCA9IGhhc093blByb3BlcnR5LmNhbGwocmVhbE5hbWVzLCByZXN1bHQpID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICB2YXIgZGF0YSA9IGFycmF5W2xlbmd0aF0sXG4gICAgICAgIG90aGVyRnVuYyA9IGRhdGEuZnVuYztcbiAgICBpZiAob3RoZXJGdW5jID09IG51bGwgfHwgb3RoZXJGdW5jID09IGZ1bmMpIHtcbiAgICAgIHJldHVybiBkYXRhLm5hbWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0RnVuY05hbWU7XG4iLCJ2YXIgYmFzZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX2Jhc2VDcmVhdGUnKSxcbiAgICBiYXNlTG9kYXNoID0gcmVxdWlyZSgnLi9fYmFzZUxvZGFzaCcpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGNvbnN0cnVjdG9yIGZvciBjcmVhdGluZyBgbG9kYXNoYCB3cmFwcGVyIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtjaGFpbkFsbF0gRW5hYmxlIGV4cGxpY2l0IG1ldGhvZCBjaGFpbiBzZXF1ZW5jZXMuXG4gKi9cbmZ1bmN0aW9uIExvZGFzaFdyYXBwZXIodmFsdWUsIGNoYWluQWxsKSB7XG4gIHRoaXMuX193cmFwcGVkX18gPSB2YWx1ZTtcbiAgdGhpcy5fX2FjdGlvbnNfXyA9IFtdO1xuICB0aGlzLl9fY2hhaW5fXyA9ICEhY2hhaW5BbGw7XG4gIHRoaXMuX19pbmRleF9fID0gMDtcbiAgdGhpcy5fX3ZhbHVlc19fID0gdW5kZWZpbmVkO1xufVxuXG5Mb2Rhc2hXcmFwcGVyLnByb3RvdHlwZSA9IGJhc2VDcmVhdGUoYmFzZUxvZGFzaC5wcm90b3R5cGUpO1xuTG9kYXNoV3JhcHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMb2Rhc2hXcmFwcGVyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExvZGFzaFdyYXBwZXI7XG4iLCJ2YXIgTGF6eVdyYXBwZXIgPSByZXF1aXJlKCcuL19MYXp5V3JhcHBlcicpLFxuICAgIExvZGFzaFdyYXBwZXIgPSByZXF1aXJlKCcuL19Mb2Rhc2hXcmFwcGVyJyksXG4gICAgY29weUFycmF5ID0gcmVxdWlyZSgnLi9fY29weUFycmF5Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGB3cmFwcGVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHdyYXBwZXIgVGhlIHdyYXBwZXIgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgd3JhcHBlci5cbiAqL1xuZnVuY3Rpb24gd3JhcHBlckNsb25lKHdyYXBwZXIpIHtcbiAgaWYgKHdyYXBwZXIgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcikge1xuICAgIHJldHVybiB3cmFwcGVyLmNsb25lKCk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IG5ldyBMb2Rhc2hXcmFwcGVyKHdyYXBwZXIuX193cmFwcGVkX18sIHdyYXBwZXIuX19jaGFpbl9fKTtcbiAgcmVzdWx0Ll9fYWN0aW9uc19fID0gY29weUFycmF5KHdyYXBwZXIuX19hY3Rpb25zX18pO1xuICByZXN1bHQuX19pbmRleF9fICA9IHdyYXBwZXIuX19pbmRleF9fO1xuICByZXN1bHQuX192YWx1ZXNfXyA9IHdyYXBwZXIuX192YWx1ZXNfXztcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3cmFwcGVyQ2xvbmU7XG4iLCJ2YXIgTGF6eVdyYXBwZXIgPSByZXF1aXJlKCcuL19MYXp5V3JhcHBlcicpLFxuICAgIExvZGFzaFdyYXBwZXIgPSByZXF1aXJlKCcuL19Mb2Rhc2hXcmFwcGVyJyksXG4gICAgYmFzZUxvZGFzaCA9IHJlcXVpcmUoJy4vX2Jhc2VMb2Rhc2gnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKSxcbiAgICB3cmFwcGVyQ2xvbmUgPSByZXF1aXJlKCcuL193cmFwcGVyQ2xvbmUnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgYGxvZGFzaGAgb2JqZWN0IHdoaWNoIHdyYXBzIGB2YWx1ZWAgdG8gZW5hYmxlIGltcGxpY2l0IG1ldGhvZFxuICogY2hhaW4gc2VxdWVuY2VzLiBNZXRob2RzIHRoYXQgb3BlcmF0ZSBvbiBhbmQgcmV0dXJuIGFycmF5cywgY29sbGVjdGlvbnMsXG4gKiBhbmQgZnVuY3Rpb25zIGNhbiBiZSBjaGFpbmVkIHRvZ2V0aGVyLiBNZXRob2RzIHRoYXQgcmV0cmlldmUgYSBzaW5nbGUgdmFsdWVcbiAqIG9yIG1heSByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUgd2lsbCBhdXRvbWF0aWNhbGx5IGVuZCB0aGUgY2hhaW4gc2VxdWVuY2VcbiAqIGFuZCByZXR1cm4gdGhlIHVud3JhcHBlZCB2YWx1ZS4gT3RoZXJ3aXNlLCB0aGUgdmFsdWUgbXVzdCBiZSB1bndyYXBwZWRcbiAqIHdpdGggYF8jdmFsdWVgLlxuICpcbiAqIEV4cGxpY2l0IGNoYWluIHNlcXVlbmNlcywgd2hpY2ggbXVzdCBiZSB1bndyYXBwZWQgd2l0aCBgXyN2YWx1ZWAsIG1heSBiZVxuICogZW5hYmxlZCB1c2luZyBgXy5jaGFpbmAuXG4gKlxuICogVGhlIGV4ZWN1dGlvbiBvZiBjaGFpbmVkIG1ldGhvZHMgaXMgbGF6eSwgdGhhdCBpcywgaXQncyBkZWZlcnJlZCB1bnRpbFxuICogYF8jdmFsdWVgIGlzIGltcGxpY2l0bHkgb3IgZXhwbGljaXRseSBjYWxsZWQuXG4gKlxuICogTGF6eSBldmFsdWF0aW9uIGFsbG93cyBzZXZlcmFsIG1ldGhvZHMgdG8gc3VwcG9ydCBzaG9ydGN1dCBmdXNpb24uXG4gKiBTaG9ydGN1dCBmdXNpb24gaXMgYW4gb3B0aW1pemF0aW9uIHRvIG1lcmdlIGl0ZXJhdGVlIGNhbGxzOyB0aGlzIGF2b2lkc1xuICogdGhlIGNyZWF0aW9uIG9mIGludGVybWVkaWF0ZSBhcnJheXMgYW5kIGNhbiBncmVhdGx5IHJlZHVjZSB0aGUgbnVtYmVyIG9mXG4gKiBpdGVyYXRlZSBleGVjdXRpb25zLiBTZWN0aW9ucyBvZiBhIGNoYWluIHNlcXVlbmNlIHF1YWxpZnkgZm9yIHNob3J0Y3V0XG4gKiBmdXNpb24gaWYgdGhlIHNlY3Rpb24gaXMgYXBwbGllZCB0byBhbiBhcnJheSBhbmQgaXRlcmF0ZWVzIGFjY2VwdCBvbmx5XG4gKiBvbmUgYXJndW1lbnQuIFRoZSBoZXVyaXN0aWMgZm9yIHdoZXRoZXIgYSBzZWN0aW9uIHF1YWxpZmllcyBmb3Igc2hvcnRjdXRcbiAqIGZ1c2lvbiBpcyBzdWJqZWN0IHRvIGNoYW5nZS5cbiAqXG4gKiBDaGFpbmluZyBpcyBzdXBwb3J0ZWQgaW4gY3VzdG9tIGJ1aWxkcyBhcyBsb25nIGFzIHRoZSBgXyN2YWx1ZWAgbWV0aG9kIGlzXG4gKiBkaXJlY3RseSBvciBpbmRpcmVjdGx5IGluY2x1ZGVkIGluIHRoZSBidWlsZC5cbiAqXG4gKiBJbiBhZGRpdGlvbiB0byBsb2Rhc2ggbWV0aG9kcywgd3JhcHBlcnMgaGF2ZSBgQXJyYXlgIGFuZCBgU3RyaW5nYCBtZXRob2RzLlxuICpcbiAqIFRoZSB3cmFwcGVyIGBBcnJheWAgbWV0aG9kcyBhcmU6XG4gKiBgY29uY2F0YCwgYGpvaW5gLCBgcG9wYCwgYHB1c2hgLCBgc2hpZnRgLCBgc29ydGAsIGBzcGxpY2VgLCBhbmQgYHVuc2hpZnRgXG4gKlxuICogVGhlIHdyYXBwZXIgYFN0cmluZ2AgbWV0aG9kcyBhcmU6XG4gKiBgcmVwbGFjZWAgYW5kIGBzcGxpdGBcbiAqXG4gKiBUaGUgd3JhcHBlciBtZXRob2RzIHRoYXQgc3VwcG9ydCBzaG9ydGN1dCBmdXNpb24gYXJlOlxuICogYGF0YCwgYGNvbXBhY3RgLCBgZHJvcGAsIGBkcm9wUmlnaHRgLCBgZHJvcFdoaWxlYCwgYGZpbHRlcmAsIGBmaW5kYCxcbiAqIGBmaW5kTGFzdGAsIGBoZWFkYCwgYGluaXRpYWxgLCBgbGFzdGAsIGBtYXBgLCBgcmVqZWN0YCwgYHJldmVyc2VgLCBgc2xpY2VgLFxuICogYHRhaWxgLCBgdGFrZWAsIGB0YWtlUmlnaHRgLCBgdGFrZVJpZ2h0V2hpbGVgLCBgdGFrZVdoaWxlYCwgYW5kIGB0b0FycmF5YFxuICpcbiAqIFRoZSBjaGFpbmFibGUgd3JhcHBlciBtZXRob2RzIGFyZTpcbiAqIGBhZnRlcmAsIGBhcnlgLCBgYXNzaWduYCwgYGFzc2lnbkluYCwgYGFzc2lnbkluV2l0aGAsIGBhc3NpZ25XaXRoYCwgYGF0YCxcbiAqIGBiZWZvcmVgLCBgYmluZGAsIGBiaW5kQWxsYCwgYGJpbmRLZXlgLCBgY2FzdEFycmF5YCwgYGNoYWluYCwgYGNodW5rYCxcbiAqIGBjb21taXRgLCBgY29tcGFjdGAsIGBjb25jYXRgLCBgY29uZm9ybXNgLCBgY29uc3RhbnRgLCBgY291bnRCeWAsIGBjcmVhdGVgLFxuICogYGN1cnJ5YCwgYGRlYm91bmNlYCwgYGRlZmF1bHRzYCwgYGRlZmF1bHRzRGVlcGAsIGBkZWZlcmAsIGBkZWxheWAsXG4gKiBgZGlmZmVyZW5jZWAsIGBkaWZmZXJlbmNlQnlgLCBgZGlmZmVyZW5jZVdpdGhgLCBgZHJvcGAsIGBkcm9wUmlnaHRgLFxuICogYGRyb3BSaWdodFdoaWxlYCwgYGRyb3BXaGlsZWAsIGBleHRlbmRgLCBgZXh0ZW5kV2l0aGAsIGBmaWxsYCwgYGZpbHRlcmAsXG4gKiBgZmxhdE1hcGAsIGBmbGF0TWFwRGVlcGAsIGBmbGF0TWFwRGVwdGhgLCBgZmxhdHRlbmAsIGBmbGF0dGVuRGVlcGAsXG4gKiBgZmxhdHRlbkRlcHRoYCwgYGZsaXBgLCBgZmxvd2AsIGBmbG93UmlnaHRgLCBgZnJvbVBhaXJzYCwgYGZ1bmN0aW9uc2AsXG4gKiBgZnVuY3Rpb25zSW5gLCBgZ3JvdXBCeWAsIGBpbml0aWFsYCwgYGludGVyc2VjdGlvbmAsIGBpbnRlcnNlY3Rpb25CeWAsXG4gKiBgaW50ZXJzZWN0aW9uV2l0aGAsIGBpbnZlcnRgLCBgaW52ZXJ0QnlgLCBgaW52b2tlTWFwYCwgYGl0ZXJhdGVlYCwgYGtleUJ5YCxcbiAqIGBrZXlzYCwgYGtleXNJbmAsIGBtYXBgLCBgbWFwS2V5c2AsIGBtYXBWYWx1ZXNgLCBgbWF0Y2hlc2AsIGBtYXRjaGVzUHJvcGVydHlgLFxuICogYG1lbW9pemVgLCBgbWVyZ2VgLCBgbWVyZ2VXaXRoYCwgYG1ldGhvZGAsIGBtZXRob2RPZmAsIGBtaXhpbmAsIGBuZWdhdGVgLFxuICogYG50aEFyZ2AsIGBvbWl0YCwgYG9taXRCeWAsIGBvbmNlYCwgYG9yZGVyQnlgLCBgb3ZlcmAsIGBvdmVyQXJnc2AsXG4gKiBgb3ZlckV2ZXJ5YCwgYG92ZXJTb21lYCwgYHBhcnRpYWxgLCBgcGFydGlhbFJpZ2h0YCwgYHBhcnRpdGlvbmAsIGBwaWNrYCxcbiAqIGBwaWNrQnlgLCBgcGxhbnRgLCBgcHJvcGVydHlgLCBgcHJvcGVydHlPZmAsIGBwdWxsYCwgYHB1bGxBbGxgLCBgcHVsbEFsbEJ5YCxcbiAqIGBwdWxsQWxsV2l0aGAsIGBwdWxsQXRgLCBgcHVzaGAsIGByYW5nZWAsIGByYW5nZVJpZ2h0YCwgYHJlYXJnYCwgYHJlamVjdGAsXG4gKiBgcmVtb3ZlYCwgYHJlc3RgLCBgcmV2ZXJzZWAsIGBzYW1wbGVTaXplYCwgYHNldGAsIGBzZXRXaXRoYCwgYHNodWZmbGVgLFxuICogYHNsaWNlYCwgYHNvcnRgLCBgc29ydEJ5YCwgYHNwbGljZWAsIGBzcHJlYWRgLCBgdGFpbGAsIGB0YWtlYCwgYHRha2VSaWdodGAsXG4gKiBgdGFrZVJpZ2h0V2hpbGVgLCBgdGFrZVdoaWxlYCwgYHRhcGAsIGB0aHJvdHRsZWAsIGB0aHJ1YCwgYHRvQXJyYXlgLFxuICogYHRvUGFpcnNgLCBgdG9QYWlyc0luYCwgYHRvUGF0aGAsIGB0b1BsYWluT2JqZWN0YCwgYHRyYW5zZm9ybWAsIGB1bmFyeWAsXG4gKiBgdW5pb25gLCBgdW5pb25CeWAsIGB1bmlvbldpdGhgLCBgdW5pcWAsIGB1bmlxQnlgLCBgdW5pcVdpdGhgLCBgdW5zZXRgLFxuICogYHVuc2hpZnRgLCBgdW56aXBgLCBgdW56aXBXaXRoYCwgYHVwZGF0ZWAsIGB1cGRhdGVXaXRoYCwgYHZhbHVlc2AsXG4gKiBgdmFsdWVzSW5gLCBgd2l0aG91dGAsIGB3cmFwYCwgYHhvcmAsIGB4b3JCeWAsIGB4b3JXaXRoYCwgYHppcGAsXG4gKiBgemlwT2JqZWN0YCwgYHppcE9iamVjdERlZXBgLCBhbmQgYHppcFdpdGhgXG4gKlxuICogVGhlIHdyYXBwZXIgbWV0aG9kcyB0aGF0IGFyZSAqKm5vdCoqIGNoYWluYWJsZSBieSBkZWZhdWx0IGFyZTpcbiAqIGBhZGRgLCBgYXR0ZW1wdGAsIGBjYW1lbENhc2VgLCBgY2FwaXRhbGl6ZWAsIGBjZWlsYCwgYGNsYW1wYCwgYGNsb25lYCxcbiAqIGBjbG9uZURlZXBgLCBgY2xvbmVEZWVwV2l0aGAsIGBjbG9uZVdpdGhgLCBgY29uZm9ybXNUb2AsIGBkZWJ1cnJgLFxuICogYGRlZmF1bHRUb2AsIGBkaXZpZGVgLCBgZWFjaGAsIGBlYWNoUmlnaHRgLCBgZW5kc1dpdGhgLCBgZXFgLCBgZXNjYXBlYCxcbiAqIGBlc2NhcGVSZWdFeHBgLCBgZXZlcnlgLCBgZmluZGAsIGBmaW5kSW5kZXhgLCBgZmluZEtleWAsIGBmaW5kTGFzdGAsXG4gKiBgZmluZExhc3RJbmRleGAsIGBmaW5kTGFzdEtleWAsIGBmaXJzdGAsIGBmbG9vcmAsIGBmb3JFYWNoYCwgYGZvckVhY2hSaWdodGAsXG4gKiBgZm9ySW5gLCBgZm9ySW5SaWdodGAsIGBmb3JPd25gLCBgZm9yT3duUmlnaHRgLCBgZ2V0YCwgYGd0YCwgYGd0ZWAsIGBoYXNgLFxuICogYGhhc0luYCwgYGhlYWRgLCBgaWRlbnRpdHlgLCBgaW5jbHVkZXNgLCBgaW5kZXhPZmAsIGBpblJhbmdlYCwgYGludm9rZWAsXG4gKiBgaXNBcmd1bWVudHNgLCBgaXNBcnJheWAsIGBpc0FycmF5QnVmZmVyYCwgYGlzQXJyYXlMaWtlYCwgYGlzQXJyYXlMaWtlT2JqZWN0YCxcbiAqIGBpc0Jvb2xlYW5gLCBgaXNCdWZmZXJgLCBgaXNEYXRlYCwgYGlzRWxlbWVudGAsIGBpc0VtcHR5YCwgYGlzRXF1YWxgLFxuICogYGlzRXF1YWxXaXRoYCwgYGlzRXJyb3JgLCBgaXNGaW5pdGVgLCBgaXNGdW5jdGlvbmAsIGBpc0ludGVnZXJgLCBgaXNMZW5ndGhgLFxuICogYGlzTWFwYCwgYGlzTWF0Y2hgLCBgaXNNYXRjaFdpdGhgLCBgaXNOYU5gLCBgaXNOYXRpdmVgLCBgaXNOaWxgLCBgaXNOdWxsYCxcbiAqIGBpc051bWJlcmAsIGBpc09iamVjdGAsIGBpc09iamVjdExpa2VgLCBgaXNQbGFpbk9iamVjdGAsIGBpc1JlZ0V4cGAsXG4gKiBgaXNTYWZlSW50ZWdlcmAsIGBpc1NldGAsIGBpc1N0cmluZ2AsIGBpc1VuZGVmaW5lZGAsIGBpc1R5cGVkQXJyYXlgLFxuICogYGlzV2Vha01hcGAsIGBpc1dlYWtTZXRgLCBgam9pbmAsIGBrZWJhYkNhc2VgLCBgbGFzdGAsIGBsYXN0SW5kZXhPZmAsXG4gKiBgbG93ZXJDYXNlYCwgYGxvd2VyRmlyc3RgLCBgbHRgLCBgbHRlYCwgYG1heGAsIGBtYXhCeWAsIGBtZWFuYCwgYG1lYW5CeWAsXG4gKiBgbWluYCwgYG1pbkJ5YCwgYG11bHRpcGx5YCwgYG5vQ29uZmxpY3RgLCBgbm9vcGAsIGBub3dgLCBgbnRoYCwgYHBhZGAsXG4gKiBgcGFkRW5kYCwgYHBhZFN0YXJ0YCwgYHBhcnNlSW50YCwgYHBvcGAsIGByYW5kb21gLCBgcmVkdWNlYCwgYHJlZHVjZVJpZ2h0YCxcbiAqIGByZXBlYXRgLCBgcmVzdWx0YCwgYHJvdW5kYCwgYHJ1bkluQ29udGV4dGAsIGBzYW1wbGVgLCBgc2hpZnRgLCBgc2l6ZWAsXG4gKiBgc25ha2VDYXNlYCwgYHNvbWVgLCBgc29ydGVkSW5kZXhgLCBgc29ydGVkSW5kZXhCeWAsIGBzb3J0ZWRMYXN0SW5kZXhgLFxuICogYHNvcnRlZExhc3RJbmRleEJ5YCwgYHN0YXJ0Q2FzZWAsIGBzdGFydHNXaXRoYCwgYHN0dWJBcnJheWAsIGBzdHViRmFsc2VgLFxuICogYHN0dWJPYmplY3RgLCBgc3R1YlN0cmluZ2AsIGBzdHViVHJ1ZWAsIGBzdWJ0cmFjdGAsIGBzdW1gLCBgc3VtQnlgLFxuICogYHRlbXBsYXRlYCwgYHRpbWVzYCwgYHRvRmluaXRlYCwgYHRvSW50ZWdlcmAsIGB0b0pTT05gLCBgdG9MZW5ndGhgLFxuICogYHRvTG93ZXJgLCBgdG9OdW1iZXJgLCBgdG9TYWZlSW50ZWdlcmAsIGB0b1N0cmluZ2AsIGB0b1VwcGVyYCwgYHRyaW1gLFxuICogYHRyaW1FbmRgLCBgdHJpbVN0YXJ0YCwgYHRydW5jYXRlYCwgYHVuZXNjYXBlYCwgYHVuaXF1ZUlkYCwgYHVwcGVyQ2FzZWAsXG4gKiBgdXBwZXJGaXJzdGAsIGB2YWx1ZWAsIGFuZCBgd29yZHNgXG4gKlxuICogQG5hbWUgX1xuICogQGNvbnN0cnVjdG9yXG4gKiBAY2F0ZWdvcnkgU2VxXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwIGluIGEgYGxvZGFzaGAgaW5zdGFuY2UuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAqICAgcmV0dXJuIG4gKiBuO1xuICogfVxuICpcbiAqIHZhciB3cmFwcGVkID0gXyhbMSwgMiwgM10pO1xuICpcbiAqIC8vIFJldHVybnMgYW4gdW53cmFwcGVkIHZhbHVlLlxuICogd3JhcHBlZC5yZWR1Y2UoXy5hZGQpO1xuICogLy8gPT4gNlxuICpcbiAqIC8vIFJldHVybnMgYSB3cmFwcGVkIHZhbHVlLlxuICogdmFyIHNxdWFyZXMgPSB3cmFwcGVkLm1hcChzcXVhcmUpO1xuICpcbiAqIF8uaXNBcnJheShzcXVhcmVzKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KHNxdWFyZXMudmFsdWUoKSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGxvZGFzaCh2YWx1ZSkge1xuICBpZiAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiAhaXNBcnJheSh2YWx1ZSkgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExvZGFzaFdyYXBwZXIpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdfX3dyYXBwZWRfXycpKSB7XG4gICAgICByZXR1cm4gd3JhcHBlckNsb25lKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHZhbHVlKTtcbn1cblxuLy8gRW5zdXJlIHdyYXBwZXJzIGFyZSBpbnN0YW5jZXMgb2YgYGJhc2VMb2Rhc2hgLlxubG9kYXNoLnByb3RvdHlwZSA9IGJhc2VMb2Rhc2gucHJvdG90eXBlO1xubG9kYXNoLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGxvZGFzaDtcblxubW9kdWxlLmV4cG9ydHMgPSBsb2Rhc2g7XG4iLCJ2YXIgTGF6eVdyYXBwZXIgPSByZXF1aXJlKCcuL19MYXp5V3JhcHBlcicpLFxuICAgIGdldERhdGEgPSByZXF1aXJlKCcuL19nZXREYXRhJyksXG4gICAgZ2V0RnVuY05hbWUgPSByZXF1aXJlKCcuL19nZXRGdW5jTmFtZScpLFxuICAgIGxvZGFzaCA9IHJlcXVpcmUoJy4vd3JhcHBlckxvZGFzaCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGEgbGF6eSBjb3VudGVycGFydC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGhhcyBhIGxhenkgY291bnRlcnBhcnQsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0xhemlhYmxlKGZ1bmMpIHtcbiAgdmFyIGZ1bmNOYW1lID0gZ2V0RnVuY05hbWUoZnVuYyksXG4gICAgICBvdGhlciA9IGxvZGFzaFtmdW5jTmFtZV07XG5cbiAgaWYgKHR5cGVvZiBvdGhlciAhPSAnZnVuY3Rpb24nIHx8ICEoZnVuY05hbWUgaW4gTGF6eVdyYXBwZXIucHJvdG90eXBlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZnVuYyA9PT0gb3RoZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgZGF0YSA9IGdldERhdGEob3RoZXIpO1xuICByZXR1cm4gISFkYXRhICYmIGZ1bmMgPT09IGRhdGFbMF07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNMYXppYWJsZTtcbiIsInZhciBiYXNlU2V0RGF0YSA9IHJlcXVpcmUoJy4vX2Jhc2VTZXREYXRhJyksXG4gICAgc2hvcnRPdXQgPSByZXF1aXJlKCcuL19zaG9ydE91dCcpO1xuXG4vKipcbiAqIFNldHMgbWV0YWRhdGEgZm9yIGBmdW5jYC5cbiAqXG4gKiAqKk5vdGU6KiogSWYgdGhpcyBmdW5jdGlvbiBiZWNvbWVzIGhvdCwgaS5lLiBpcyBpbnZva2VkIGEgbG90IGluIGEgc2hvcnRcbiAqIHBlcmlvZCBvZiB0aW1lLCBpdCB3aWxsIHRyaXAgaXRzIGJyZWFrZXIgYW5kIHRyYW5zaXRpb24gdG8gYW4gaWRlbnRpdHlcbiAqIGZ1bmN0aW9uIHRvIGF2b2lkIGdhcmJhZ2UgY29sbGVjdGlvbiBwYXVzZXMgaW4gVjguIFNlZVxuICogW1Y4IGlzc3VlIDIwNzBdKGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIwNzApXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhc3NvY2lhdGUgbWV0YWRhdGEgd2l0aC5cbiAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWV0YWRhdGEuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovXG52YXIgc2V0RGF0YSA9IHNob3J0T3V0KGJhc2VTZXREYXRhKTtcblxubW9kdWxlLmV4cG9ydHMgPSBzZXREYXRhO1xuIiwiLyoqIFVzZWQgdG8gbWF0Y2ggd3JhcCBkZXRhaWwgY29tbWVudHMuICovXG52YXIgcmVXcmFwRGV0YWlscyA9IC9cXHtcXG5cXC9cXCogXFxbd3JhcHBlZCB3aXRoICguKylcXF0gXFwqLyxcbiAgICByZVNwbGl0RGV0YWlscyA9IC8sPyAmIC87XG5cbi8qKlxuICogRXh0cmFjdHMgd3JhcHBlciBkZXRhaWxzIGZyb20gdGhlIGBzb3VyY2VgIGJvZHkgY29tbWVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSBUaGUgc291cmNlIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdyYXBwZXIgZGV0YWlscy5cbiAqL1xuZnVuY3Rpb24gZ2V0V3JhcERldGFpbHMoc291cmNlKSB7XG4gIHZhciBtYXRjaCA9IHNvdXJjZS5tYXRjaChyZVdyYXBEZXRhaWxzKTtcbiAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0uc3BsaXQocmVTcGxpdERldGFpbHMpIDogW107XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0V3JhcERldGFpbHM7XG4iLCIvKiogVXNlZCB0byBtYXRjaCB3cmFwIGRldGFpbCBjb21tZW50cy4gKi9cbnZhciByZVdyYXBDb21tZW50ID0gL1xceyg/OlxcblxcL1xcKiBcXFt3cmFwcGVkIHdpdGggLitcXF0gXFwqXFwvKT9cXG4/LztcblxuLyoqXG4gKiBJbnNlcnRzIHdyYXBwZXIgYGRldGFpbHNgIGluIGEgY29tbWVudCBhdCB0aGUgdG9wIG9mIHRoZSBgc291cmNlYCBib2R5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc291cmNlIFRoZSBzb3VyY2UgdG8gbW9kaWZ5LlxuICogQHJldHVybnMge0FycmF5fSBkZXRhaWxzIFRoZSBkZXRhaWxzIHRvIGluc2VydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIG1vZGlmaWVkIHNvdXJjZS5cbiAqL1xuZnVuY3Rpb24gaW5zZXJ0V3JhcERldGFpbHMoc291cmNlLCBkZXRhaWxzKSB7XG4gIHZhciBsZW5ndGggPSBkZXRhaWxzLmxlbmd0aDtcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICByZXR1cm4gc291cmNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBsZW5ndGggLSAxO1xuICBkZXRhaWxzW2xhc3RJbmRleF0gPSAobGVuZ3RoID4gMSA/ICcmICcgOiAnJykgKyBkZXRhaWxzW2xhc3RJbmRleF07XG4gIGRldGFpbHMgPSBkZXRhaWxzLmpvaW4obGVuZ3RoID4gMiA/ICcsICcgOiAnICcpO1xuICByZXR1cm4gc291cmNlLnJlcGxhY2UocmVXcmFwQ29tbWVudCwgJ3tcXG4vKiBbd3JhcHBlZCB3aXRoICcgKyBkZXRhaWxzICsgJ10gKi9cXG4nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbnNlcnRXcmFwRGV0YWlscztcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmluZEluZGV4YCBhbmQgYF8uZmluZExhc3RJbmRleGAgd2l0aG91dFxuICogc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBiYXNlRmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCwgZnJvbVJpZ2h0KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBpbmRleCA9IGZyb21JbmRleCArIChmcm9tUmlnaHQgPyAxIDogLTEpO1xuXG4gIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGaW5kSW5kZXg7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmFOYCB3aXRob3V0IHN1cHBvcnQgZm9yIG51bWJlciBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGBOYU5gLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hTih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc05hTjtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmluZGV4T2ZgIHdoaWNoIHBlcmZvcm1zIHN0cmljdCBlcXVhbGl0eVxuICogY29tcGFyaXNvbnMgb2YgdmFsdWVzLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIHN0cmljdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgdmFyIGluZGV4ID0gZnJvbUluZGV4IC0gMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpY3RJbmRleE9mO1xuIiwidmFyIGJhc2VGaW5kSW5kZXggPSByZXF1aXJlKCcuL19iYXNlRmluZEluZGV4JyksXG4gICAgYmFzZUlzTmFOID0gcmVxdWlyZSgnLi9fYmFzZUlzTmFOJyksXG4gICAgc3RyaWN0SW5kZXhPZiA9IHJlcXVpcmUoJy4vX3N0cmljdEluZGV4T2YnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pbmRleE9mYCB3aXRob3V0IGBmcm9tSW5kZXhgIGJvdW5kcyBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZVxuICAgID8gc3RyaWN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleClcbiAgICA6IGJhc2VGaW5kSW5kZXgoYXJyYXksIGJhc2VJc05hTiwgZnJvbUluZGV4KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSW5kZXhPZjtcbiIsInZhciBiYXNlSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Jhc2VJbmRleE9mJyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmluY2x1ZGVzYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIHNwZWNpZnlpbmcgYW4gaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHRhcmdldCBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdGFyZ2V0YCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheUluY2x1ZGVzKGFycmF5LCB2YWx1ZSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gIHJldHVybiAhIWxlbmd0aCAmJiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIDApID4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlJbmNsdWRlcztcbiIsInZhciBhcnJheUVhY2ggPSByZXF1aXJlKCcuL19hcnJheUVhY2gnKSxcbiAgICBhcnJheUluY2x1ZGVzID0gcmVxdWlyZSgnLi9fYXJyYXlJbmNsdWRlcycpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBmdW5jdGlvbiBtZXRhZGF0YS4gKi9cbnZhciBXUkFQX0JJTkRfRkxBRyA9IDEsXG4gICAgV1JBUF9CSU5EX0tFWV9GTEFHID0gMixcbiAgICBXUkFQX0NVUlJZX0ZMQUcgPSA4LFxuICAgIFdSQVBfQ1VSUllfUklHSFRfRkxBRyA9IDE2LFxuICAgIFdSQVBfUEFSVElBTF9GTEFHID0gMzIsXG4gICAgV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcgPSA2NCxcbiAgICBXUkFQX0FSWV9GTEFHID0gMTI4LFxuICAgIFdSQVBfUkVBUkdfRkxBRyA9IDI1NixcbiAgICBXUkFQX0ZMSVBfRkxBRyA9IDUxMjtcblxuLyoqIFVzZWQgdG8gYXNzb2NpYXRlIHdyYXAgbWV0aG9kcyB3aXRoIHRoZWlyIGJpdCBmbGFncy4gKi9cbnZhciB3cmFwRmxhZ3MgPSBbXG4gIFsnYXJ5JywgV1JBUF9BUllfRkxBR10sXG4gIFsnYmluZCcsIFdSQVBfQklORF9GTEFHXSxcbiAgWydiaW5kS2V5JywgV1JBUF9CSU5EX0tFWV9GTEFHXSxcbiAgWydjdXJyeScsIFdSQVBfQ1VSUllfRkxBR10sXG4gIFsnY3VycnlSaWdodCcsIFdSQVBfQ1VSUllfUklHSFRfRkxBR10sXG4gIFsnZmxpcCcsIFdSQVBfRkxJUF9GTEFHXSxcbiAgWydwYXJ0aWFsJywgV1JBUF9QQVJUSUFMX0ZMQUddLFxuICBbJ3BhcnRpYWxSaWdodCcsIFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHXSxcbiAgWydyZWFyZycsIFdSQVBfUkVBUkdfRkxBR11cbl07XG5cbi8qKlxuICogVXBkYXRlcyB3cmFwcGVyIGBkZXRhaWxzYCBiYXNlZCBvbiBgYml0bWFza2AgZmxhZ3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEByZXR1cm5zIHtBcnJheX0gZGV0YWlscyBUaGUgZGV0YWlscyB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBkZXRhaWxzYC5cbiAqL1xuZnVuY3Rpb24gdXBkYXRlV3JhcERldGFpbHMoZGV0YWlscywgYml0bWFzaykge1xuICBhcnJheUVhY2god3JhcEZsYWdzLCBmdW5jdGlvbihwYWlyKSB7XG4gICAgdmFyIHZhbHVlID0gJ18uJyArIHBhaXJbMF07XG4gICAgaWYgKChiaXRtYXNrICYgcGFpclsxXSkgJiYgIWFycmF5SW5jbHVkZXMoZGV0YWlscywgdmFsdWUpKSB7XG4gICAgICBkZXRhaWxzLnB1c2godmFsdWUpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBkZXRhaWxzLnNvcnQoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB1cGRhdGVXcmFwRGV0YWlscztcbiIsInZhciBnZXRXcmFwRGV0YWlscyA9IHJlcXVpcmUoJy4vX2dldFdyYXBEZXRhaWxzJyksXG4gICAgaW5zZXJ0V3JhcERldGFpbHMgPSByZXF1aXJlKCcuL19pbnNlcnRXcmFwRGV0YWlscycpLFxuICAgIHNldFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fc2V0VG9TdHJpbmcnKSxcbiAgICB1cGRhdGVXcmFwRGV0YWlscyA9IHJlcXVpcmUoJy4vX3VwZGF0ZVdyYXBEZXRhaWxzJyk7XG5cbi8qKlxuICogU2V0cyB0aGUgYHRvU3RyaW5nYCBtZXRob2Qgb2YgYHdyYXBwZXJgIHRvIG1pbWljIHRoZSBzb3VyY2Ugb2YgYHJlZmVyZW5jZWBcbiAqIHdpdGggd3JhcHBlciBkZXRhaWxzIGluIGEgY29tbWVudCBhdCB0aGUgdG9wIG9mIHRoZSBzb3VyY2UgYm9keS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gd3JhcHBlciBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVmZXJlbmNlIFRoZSByZWZlcmVuY2UgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGB3cmFwcGVyYC5cbiAqL1xuZnVuY3Rpb24gc2V0V3JhcFRvU3RyaW5nKHdyYXBwZXIsIHJlZmVyZW5jZSwgYml0bWFzaykge1xuICB2YXIgc291cmNlID0gKHJlZmVyZW5jZSArICcnKTtcbiAgcmV0dXJuIHNldFRvU3RyaW5nKHdyYXBwZXIsIGluc2VydFdyYXBEZXRhaWxzKHNvdXJjZSwgdXBkYXRlV3JhcERldGFpbHMoZ2V0V3JhcERldGFpbHMoc291cmNlKSwgYml0bWFzaykpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRXcmFwVG9TdHJpbmc7XG4iLCJ2YXIgaXNMYXppYWJsZSA9IHJlcXVpcmUoJy4vX2lzTGF6aWFibGUnKSxcbiAgICBzZXREYXRhID0gcmVxdWlyZSgnLi9fc2V0RGF0YScpLFxuICAgIHNldFdyYXBUb1N0cmluZyA9IHJlcXVpcmUoJy4vX3NldFdyYXBUb1N0cmluZycpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBmdW5jdGlvbiBtZXRhZGF0YS4gKi9cbnZhciBXUkFQX0JJTkRfRkxBRyA9IDEsXG4gICAgV1JBUF9CSU5EX0tFWV9GTEFHID0gMixcbiAgICBXUkFQX0NVUlJZX0JPVU5EX0ZMQUcgPSA0LFxuICAgIFdSQVBfQ1VSUllfRkxBRyA9IDgsXG4gICAgV1JBUF9QQVJUSUFMX0ZMQUcgPSAzMixcbiAgICBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRyA9IDY0O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCB0byBjb250aW51ZSBjdXJyeWluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB3cmFwRnVuYyBUaGUgZnVuY3Rpb24gdG8gY3JlYXRlIHRoZSBgZnVuY2Agd3JhcHBlci5cbiAqIEBwYXJhbSB7Kn0gcGxhY2Vob2xkZXIgVGhlIHBsYWNlaG9sZGVyIHZhbHVlLlxuICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBwcmVwZW5kIHRvIHRob3NlIHByb3ZpZGVkIHRvXG4gKiAgdGhlIG5ldyBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7QXJyYXl9IFtob2xkZXJzXSBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICogQHBhcmFtIHtBcnJheX0gW2FyZ1Bvc10gVGhlIGFyZ3VtZW50IHBvc2l0aW9ucyBvZiB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFthcnldIFRoZSBhcml0eSBjYXAgb2YgYGZ1bmNgLlxuICogQHBhcmFtIHtudW1iZXJ9IFthcml0eV0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJlY3VycnkoZnVuYywgYml0bWFzaywgd3JhcEZ1bmMsIHBsYWNlaG9sZGVyLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycywgYXJnUG9zLCBhcnksIGFyaXR5KSB7XG4gIHZhciBpc0N1cnJ5ID0gYml0bWFzayAmIFdSQVBfQ1VSUllfRkxBRyxcbiAgICAgIG5ld0hvbGRlcnMgPSBpc0N1cnJ5ID8gaG9sZGVycyA6IHVuZGVmaW5lZCxcbiAgICAgIG5ld0hvbGRlcnNSaWdodCA9IGlzQ3VycnkgPyB1bmRlZmluZWQgOiBob2xkZXJzLFxuICAgICAgbmV3UGFydGlhbHMgPSBpc0N1cnJ5ID8gcGFydGlhbHMgOiB1bmRlZmluZWQsXG4gICAgICBuZXdQYXJ0aWFsc1JpZ2h0ID0gaXNDdXJyeSA/IHVuZGVmaW5lZCA6IHBhcnRpYWxzO1xuXG4gIGJpdG1hc2sgfD0gKGlzQ3VycnkgPyBXUkFQX1BBUlRJQUxfRkxBRyA6IFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHKTtcbiAgYml0bWFzayAmPSB+KGlzQ3VycnkgPyBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRyA6IFdSQVBfUEFSVElBTF9GTEFHKTtcblxuICBpZiAoIShiaXRtYXNrICYgV1JBUF9DVVJSWV9CT1VORF9GTEFHKSkge1xuICAgIGJpdG1hc2sgJj0gfihXUkFQX0JJTkRfRkxBRyB8IFdSQVBfQklORF9LRVlfRkxBRyk7XG4gIH1cbiAgdmFyIG5ld0RhdGEgPSBbXG4gICAgZnVuYywgYml0bWFzaywgdGhpc0FyZywgbmV3UGFydGlhbHMsIG5ld0hvbGRlcnMsIG5ld1BhcnRpYWxzUmlnaHQsXG4gICAgbmV3SG9sZGVyc1JpZ2h0LCBhcmdQb3MsIGFyeSwgYXJpdHlcbiAgXTtcblxuICB2YXIgcmVzdWx0ID0gd3JhcEZ1bmMuYXBwbHkodW5kZWZpbmVkLCBuZXdEYXRhKTtcbiAgaWYgKGlzTGF6aWFibGUoZnVuYykpIHtcbiAgICBzZXREYXRhKHJlc3VsdCwgbmV3RGF0YSk7XG4gIH1cbiAgcmVzdWx0LnBsYWNlaG9sZGVyID0gcGxhY2Vob2xkZXI7XG4gIHJldHVybiBzZXRXcmFwVG9TdHJpbmcocmVzdWx0LCBmdW5jLCBiaXRtYXNrKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVSZWN1cnJ5O1xuIiwiLyoqXG4gKiBHZXRzIHRoZSBhcmd1bWVudCBwbGFjZWhvbGRlciB2YWx1ZSBmb3IgYGZ1bmNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnNwZWN0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHBsYWNlaG9sZGVyIHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRIb2xkZXIoZnVuYykge1xuICB2YXIgb2JqZWN0ID0gZnVuYztcbiAgcmV0dXJuIG9iamVjdC5wbGFjZWhvbGRlcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRIb2xkZXI7XG4iLCJ2YXIgY29weUFycmF5ID0gcmVxdWlyZSgnLi9fY29weUFycmF5JyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1pbiA9IE1hdGgubWluO1xuXG4vKipcbiAqIFJlb3JkZXIgYGFycmF5YCBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZCBpbmRleGVzIHdoZXJlIHRoZSBlbGVtZW50IGF0XG4gKiB0aGUgZmlyc3QgaW5kZXggaXMgYXNzaWduZWQgYXMgdGhlIGZpcnN0IGVsZW1lbnQsIHRoZSBlbGVtZW50IGF0XG4gKiB0aGUgc2Vjb25kIGluZGV4IGlzIGFzc2lnbmVkIGFzIHRoZSBzZWNvbmQgZWxlbWVudCwgYW5kIHNvIG9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcmVvcmRlci5cbiAqIEBwYXJhbSB7QXJyYXl9IGluZGV4ZXMgVGhlIGFycmFuZ2VkIGFycmF5IGluZGV4ZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gcmVvcmRlcihhcnJheSwgaW5kZXhlcykge1xuICB2YXIgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgbGVuZ3RoID0gbmF0aXZlTWluKGluZGV4ZXMubGVuZ3RoLCBhcnJMZW5ndGgpLFxuICAgICAgb2xkQXJyYXkgPSBjb3B5QXJyYXkoYXJyYXkpO1xuXG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIHZhciBpbmRleCA9IGluZGV4ZXNbbGVuZ3RoXTtcbiAgICBhcnJheVtsZW5ndGhdID0gaXNJbmRleChpbmRleCwgYXJyTGVuZ3RoKSA/IG9sZEFycmF5W2luZGV4XSA6IHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVvcmRlcjtcbiIsIi8qKiBVc2VkIGFzIHRoZSBpbnRlcm5hbCBhcmd1bWVudCBwbGFjZWhvbGRlci4gKi9cbnZhciBQTEFDRUhPTERFUiA9ICdfX2xvZGFzaF9wbGFjZWhvbGRlcl9fJztcblxuLyoqXG4gKiBSZXBsYWNlcyBhbGwgYHBsYWNlaG9sZGVyYCBlbGVtZW50cyBpbiBgYXJyYXlgIHdpdGggYW4gaW50ZXJuYWwgcGxhY2Vob2xkZXJcbiAqIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIHRoZWlyIGluZGV4ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0geyp9IHBsYWNlaG9sZGVyIFRoZSBwbGFjZWhvbGRlciB0byByZXBsYWNlLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAqL1xuZnVuY3Rpb24gcmVwbGFjZUhvbGRlcnMoYXJyYXksIHBsYWNlaG9sZGVyKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgaWYgKHZhbHVlID09PSBwbGFjZWhvbGRlciB8fCB2YWx1ZSA9PT0gUExBQ0VIT0xERVIpIHtcbiAgICAgIGFycmF5W2luZGV4XSA9IFBMQUNFSE9MREVSO1xuICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gaW5kZXg7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVwbGFjZUhvbGRlcnM7XG4iLCJ2YXIgY29tcG9zZUFyZ3MgPSByZXF1aXJlKCcuL19jb21wb3NlQXJncycpLFxuICAgIGNvbXBvc2VBcmdzUmlnaHQgPSByZXF1aXJlKCcuL19jb21wb3NlQXJnc1JpZ2h0JyksXG4gICAgY291bnRIb2xkZXJzID0gcmVxdWlyZSgnLi9fY291bnRIb2xkZXJzJyksXG4gICAgY3JlYXRlQ3RvciA9IHJlcXVpcmUoJy4vX2NyZWF0ZUN0b3InKSxcbiAgICBjcmVhdGVSZWN1cnJ5ID0gcmVxdWlyZSgnLi9fY3JlYXRlUmVjdXJyeScpLFxuICAgIGdldEhvbGRlciA9IHJlcXVpcmUoJy4vX2dldEhvbGRlcicpLFxuICAgIHJlb3JkZXIgPSByZXF1aXJlKCcuL19yZW9yZGVyJyksXG4gICAgcmVwbGFjZUhvbGRlcnMgPSByZXF1aXJlKCcuL19yZXBsYWNlSG9sZGVycycpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGZ1bmN0aW9uIG1ldGFkYXRhLiAqL1xudmFyIFdSQVBfQklORF9GTEFHID0gMSxcbiAgICBXUkFQX0JJTkRfS0VZX0ZMQUcgPSAyLFxuICAgIFdSQVBfQ1VSUllfRkxBRyA9IDgsXG4gICAgV1JBUF9DVVJSWV9SSUdIVF9GTEFHID0gMTYsXG4gICAgV1JBUF9BUllfRkxBRyA9IDEyOCxcbiAgICBXUkFQX0ZMSVBfRkxBRyA9IDUxMjtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgdG8gaW52b2tlIGl0IHdpdGggb3B0aW9uYWwgYHRoaXNgXG4gKiBiaW5kaW5nIG9mIGB0aGlzQXJnYCwgcGFydGlhbCBhcHBsaWNhdGlvbiwgYW5kIGN1cnJ5aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufHN0cmluZ30gZnVuYyBUaGUgZnVuY3Rpb24gb3IgbWV0aG9kIG5hbWUgdG8gd3JhcC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIHByZXBlbmQgdG8gdGhvc2UgcHJvdmlkZWQgdG9cbiAqICB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQHBhcmFtIHtBcnJheX0gW2hvbGRlcnNdIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbHNSaWdodF0gVGhlIGFyZ3VtZW50cyB0byBhcHBlbmQgdG8gdGhvc2UgcHJvdmlkZWRcbiAqICB0byB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQHBhcmFtIHtBcnJheX0gW2hvbGRlcnNSaWdodF0gVGhlIGBwYXJ0aWFsc1JpZ2h0YCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICogQHBhcmFtIHtBcnJheX0gW2FyZ1Bvc10gVGhlIGFyZ3VtZW50IHBvc2l0aW9ucyBvZiB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFthcnldIFRoZSBhcml0eSBjYXAgb2YgYGZ1bmNgLlxuICogQHBhcmFtIHtudW1iZXJ9IFthcml0eV0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUh5YnJpZChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycywgcGFydGlhbHNSaWdodCwgaG9sZGVyc1JpZ2h0LCBhcmdQb3MsIGFyeSwgYXJpdHkpIHtcbiAgdmFyIGlzQXJ5ID0gYml0bWFzayAmIFdSQVBfQVJZX0ZMQUcsXG4gICAgICBpc0JpbmQgPSBiaXRtYXNrICYgV1JBUF9CSU5EX0ZMQUcsXG4gICAgICBpc0JpbmRLZXkgPSBiaXRtYXNrICYgV1JBUF9CSU5EX0tFWV9GTEFHLFxuICAgICAgaXNDdXJyaWVkID0gYml0bWFzayAmIChXUkFQX0NVUlJZX0ZMQUcgfCBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcpLFxuICAgICAgaXNGbGlwID0gYml0bWFzayAmIFdSQVBfRkxJUF9GTEFHLFxuICAgICAgQ3RvciA9IGlzQmluZEtleSA/IHVuZGVmaW5lZCA6IGNyZWF0ZUN0b3IoZnVuYyk7XG5cbiAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgYXJncyA9IEFycmF5KGxlbmd0aCksXG4gICAgICAgIGluZGV4ID0gbGVuZ3RoO1xuXG4gICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgIGFyZ3NbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICB9XG4gICAgaWYgKGlzQ3VycmllZCkge1xuICAgICAgdmFyIHBsYWNlaG9sZGVyID0gZ2V0SG9sZGVyKHdyYXBwZXIpLFxuICAgICAgICAgIGhvbGRlcnNDb3VudCA9IGNvdW50SG9sZGVycyhhcmdzLCBwbGFjZWhvbGRlcik7XG4gICAgfVxuICAgIGlmIChwYXJ0aWFscykge1xuICAgICAgYXJncyA9IGNvbXBvc2VBcmdzKGFyZ3MsIHBhcnRpYWxzLCBob2xkZXJzLCBpc0N1cnJpZWQpO1xuICAgIH1cbiAgICBpZiAocGFydGlhbHNSaWdodCkge1xuICAgICAgYXJncyA9IGNvbXBvc2VBcmdzUmlnaHQoYXJncywgcGFydGlhbHNSaWdodCwgaG9sZGVyc1JpZ2h0LCBpc0N1cnJpZWQpO1xuICAgIH1cbiAgICBsZW5ndGggLT0gaG9sZGVyc0NvdW50O1xuICAgIGlmIChpc0N1cnJpZWQgJiYgbGVuZ3RoIDwgYXJpdHkpIHtcbiAgICAgIHZhciBuZXdIb2xkZXJzID0gcmVwbGFjZUhvbGRlcnMoYXJncywgcGxhY2Vob2xkZXIpO1xuICAgICAgcmV0dXJuIGNyZWF0ZVJlY3VycnkoXG4gICAgICAgIGZ1bmMsIGJpdG1hc2ssIGNyZWF0ZUh5YnJpZCwgd3JhcHBlci5wbGFjZWhvbGRlciwgdGhpc0FyZyxcbiAgICAgICAgYXJncywgbmV3SG9sZGVycywgYXJnUG9zLCBhcnksIGFyaXR5IC0gbGVuZ3RoXG4gICAgICApO1xuICAgIH1cbiAgICB2YXIgdGhpc0JpbmRpbmcgPSBpc0JpbmQgPyB0aGlzQXJnIDogdGhpcyxcbiAgICAgICAgZm4gPSBpc0JpbmRLZXkgPyB0aGlzQmluZGluZ1tmdW5jXSA6IGZ1bmM7XG5cbiAgICBsZW5ndGggPSBhcmdzLmxlbmd0aDtcbiAgICBpZiAoYXJnUG9zKSB7XG4gICAgICBhcmdzID0gcmVvcmRlcihhcmdzLCBhcmdQb3MpO1xuICAgIH0gZWxzZSBpZiAoaXNGbGlwICYmIGxlbmd0aCA+IDEpIHtcbiAgICAgIGFyZ3MucmV2ZXJzZSgpO1xuICAgIH1cbiAgICBpZiAoaXNBcnkgJiYgYXJ5IDwgbGVuZ3RoKSB7XG4gICAgICBhcmdzLmxlbmd0aCA9IGFyeTtcbiAgICB9XG4gICAgaWYgKHRoaXMgJiYgdGhpcyAhPT0gcm9vdCAmJiB0aGlzIGluc3RhbmNlb2Ygd3JhcHBlcikge1xuICAgICAgZm4gPSBDdG9yIHx8IGNyZWF0ZUN0b3IoZm4pO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpc0JpbmRpbmcsIGFyZ3MpO1xuICB9XG4gIHJldHVybiB3cmFwcGVyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUh5YnJpZDtcbiIsInZhciBhcHBseSA9IHJlcXVpcmUoJy4vX2FwcGx5JyksXG4gICAgY3JlYXRlQ3RvciA9IHJlcXVpcmUoJy4vX2NyZWF0ZUN0b3InKSxcbiAgICBjcmVhdGVIeWJyaWQgPSByZXF1aXJlKCcuL19jcmVhdGVIeWJyaWQnKSxcbiAgICBjcmVhdGVSZWN1cnJ5ID0gcmVxdWlyZSgnLi9fY3JlYXRlUmVjdXJyeScpLFxuICAgIGdldEhvbGRlciA9IHJlcXVpcmUoJy4vX2dldEhvbGRlcicpLFxuICAgIHJlcGxhY2VIb2xkZXJzID0gcmVxdWlyZSgnLi9fcmVwbGFjZUhvbGRlcnMnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCB0byBlbmFibGUgY3VycnlpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtudW1iZXJ9IGFyaXR5IFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVDdXJyeShmdW5jLCBiaXRtYXNrLCBhcml0eSkge1xuICB2YXIgQ3RvciA9IGNyZWF0ZUN0b3IoZnVuYyk7XG5cbiAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgYXJncyA9IEFycmF5KGxlbmd0aCksXG4gICAgICAgIGluZGV4ID0gbGVuZ3RoLFxuICAgICAgICBwbGFjZWhvbGRlciA9IGdldEhvbGRlcih3cmFwcGVyKTtcblxuICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICBhcmdzW2luZGV4XSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgfVxuICAgIHZhciBob2xkZXJzID0gKGxlbmd0aCA8IDMgJiYgYXJnc1swXSAhPT0gcGxhY2Vob2xkZXIgJiYgYXJnc1tsZW5ndGggLSAxXSAhPT0gcGxhY2Vob2xkZXIpXG4gICAgICA/IFtdXG4gICAgICA6IHJlcGxhY2VIb2xkZXJzKGFyZ3MsIHBsYWNlaG9sZGVyKTtcblxuICAgIGxlbmd0aCAtPSBob2xkZXJzLmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoIDwgYXJpdHkpIHtcbiAgICAgIHJldHVybiBjcmVhdGVSZWN1cnJ5KFxuICAgICAgICBmdW5jLCBiaXRtYXNrLCBjcmVhdGVIeWJyaWQsIHdyYXBwZXIucGxhY2Vob2xkZXIsIHVuZGVmaW5lZCxcbiAgICAgICAgYXJncywgaG9sZGVycywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGFyaXR5IC0gbGVuZ3RoKTtcbiAgICB9XG4gICAgdmFyIGZuID0gKHRoaXMgJiYgdGhpcyAhPT0gcm9vdCAmJiB0aGlzIGluc3RhbmNlb2Ygd3JhcHBlcikgPyBDdG9yIDogZnVuYztcbiAgICByZXR1cm4gYXBwbHkoZm4sIHRoaXMsIGFyZ3MpO1xuICB9XG4gIHJldHVybiB3cmFwcGVyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUN1cnJ5O1xuIiwidmFyIGFwcGx5ID0gcmVxdWlyZSgnLi9fYXBwbHknKSxcbiAgICBjcmVhdGVDdG9yID0gcmVxdWlyZSgnLi9fY3JlYXRlQ3RvcicpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGZ1bmN0aW9uIG1ldGFkYXRhLiAqL1xudmFyIFdSQVBfQklORF9GTEFHID0gMTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgdG8gaW52b2tlIGl0IHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nXG4gKiBvZiBgdGhpc0FyZ2AgYW5kIGBwYXJ0aWFsc2AgcHJlcGVuZGVkIHRvIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge0FycmF5fSBwYXJ0aWFscyBUaGUgYXJndW1lbnRzIHRvIHByZXBlbmQgdG8gdGhvc2UgcHJvdmlkZWQgdG9cbiAqICB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUGFydGlhbChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscykge1xuICB2YXIgaXNCaW5kID0gYml0bWFzayAmIFdSQVBfQklORF9GTEFHLFxuICAgICAgQ3RvciA9IGNyZWF0ZUN0b3IoZnVuYyk7XG5cbiAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICB2YXIgYXJnc0luZGV4ID0gLTEsXG4gICAgICAgIGFyZ3NMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICBsZWZ0SW5kZXggPSAtMSxcbiAgICAgICAgbGVmdExlbmd0aCA9IHBhcnRpYWxzLmxlbmd0aCxcbiAgICAgICAgYXJncyA9IEFycmF5KGxlZnRMZW5ndGggKyBhcmdzTGVuZ3RoKSxcbiAgICAgICAgZm4gPSAodGhpcyAmJiB0aGlzICE9PSByb290ICYmIHRoaXMgaW5zdGFuY2VvZiB3cmFwcGVyKSA/IEN0b3IgOiBmdW5jO1xuXG4gICAgd2hpbGUgKCsrbGVmdEluZGV4IDwgbGVmdExlbmd0aCkge1xuICAgICAgYXJnc1tsZWZ0SW5kZXhdID0gcGFydGlhbHNbbGVmdEluZGV4XTtcbiAgICB9XG4gICAgd2hpbGUgKGFyZ3NMZW5ndGgtLSkge1xuICAgICAgYXJnc1tsZWZ0SW5kZXgrK10gPSBhcmd1bWVudHNbKythcmdzSW5kZXhdO1xuICAgIH1cbiAgICByZXR1cm4gYXBwbHkoZm4sIGlzQmluZCA/IHRoaXNBcmcgOiB0aGlzLCBhcmdzKTtcbiAgfVxuICByZXR1cm4gd3JhcHBlcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVQYXJ0aWFsO1xuIiwidmFyIGNvbXBvc2VBcmdzID0gcmVxdWlyZSgnLi9fY29tcG9zZUFyZ3MnKSxcbiAgICBjb21wb3NlQXJnc1JpZ2h0ID0gcmVxdWlyZSgnLi9fY29tcG9zZUFyZ3NSaWdodCcpLFxuICAgIHJlcGxhY2VIb2xkZXJzID0gcmVxdWlyZSgnLi9fcmVwbGFjZUhvbGRlcnMnKTtcblxuLyoqIFVzZWQgYXMgdGhlIGludGVybmFsIGFyZ3VtZW50IHBsYWNlaG9sZGVyLiAqL1xudmFyIFBMQUNFSE9MREVSID0gJ19fbG9kYXNoX3BsYWNlaG9sZGVyX18nO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBmdW5jdGlvbiBtZXRhZGF0YS4gKi9cbnZhciBXUkFQX0JJTkRfRkxBRyA9IDEsXG4gICAgV1JBUF9CSU5EX0tFWV9GTEFHID0gMixcbiAgICBXUkFQX0NVUlJZX0JPVU5EX0ZMQUcgPSA0LFxuICAgIFdSQVBfQ1VSUllfRkxBRyA9IDgsXG4gICAgV1JBUF9BUllfRkxBRyA9IDEyOCxcbiAgICBXUkFQX1JFQVJHX0ZMQUcgPSAyNTY7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNaW4gPSBNYXRoLm1pbjtcblxuLyoqXG4gKiBNZXJnZXMgdGhlIGZ1bmN0aW9uIG1ldGFkYXRhIG9mIGBzb3VyY2VgIGludG8gYGRhdGFgLlxuICpcbiAqIE1lcmdpbmcgbWV0YWRhdGEgcmVkdWNlcyB0aGUgbnVtYmVyIG9mIHdyYXBwZXJzIHVzZWQgdG8gaW52b2tlIGEgZnVuY3Rpb24uXG4gKiBUaGlzIGlzIHBvc3NpYmxlIGJlY2F1c2UgbWV0aG9kcyBsaWtlIGBfLmJpbmRgLCBgXy5jdXJyeWAsIGFuZCBgXy5wYXJ0aWFsYFxuICogbWF5IGJlIGFwcGxpZWQgcmVnYXJkbGVzcyBvZiBleGVjdXRpb24gb3JkZXIuIE1ldGhvZHMgbGlrZSBgXy5hcnlgIGFuZFxuICogYF8ucmVhcmdgIG1vZGlmeSBmdW5jdGlvbiBhcmd1bWVudHMsIG1ha2luZyB0aGUgb3JkZXIgaW4gd2hpY2ggdGhleSBhcmVcbiAqIGV4ZWN1dGVkIGltcG9ydGFudCwgcHJldmVudGluZyB0aGUgbWVyZ2luZyBvZiBtZXRhZGF0YS4gSG93ZXZlciwgd2UgbWFrZVxuICogYW4gZXhjZXB0aW9uIGZvciBhIHNhZmUgY29tYmluZWQgY2FzZSB3aGVyZSBjdXJyaWVkIGZ1bmN0aW9ucyBoYXZlIGBfLmFyeWBcbiAqIGFuZCBvciBgXy5yZWFyZ2AgYXBwbGllZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gZGF0YSBUaGUgZGVzdGluYXRpb24gbWV0YWRhdGEuXG4gKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIHNvdXJjZSBtZXRhZGF0YS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgZGF0YWAuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGF0YShkYXRhLCBzb3VyY2UpIHtcbiAgdmFyIGJpdG1hc2sgPSBkYXRhWzFdLFxuICAgICAgc3JjQml0bWFzayA9IHNvdXJjZVsxXSxcbiAgICAgIG5ld0JpdG1hc2sgPSBiaXRtYXNrIHwgc3JjQml0bWFzayxcbiAgICAgIGlzQ29tbW9uID0gbmV3Qml0bWFzayA8IChXUkFQX0JJTkRfRkxBRyB8IFdSQVBfQklORF9LRVlfRkxBRyB8IFdSQVBfQVJZX0ZMQUcpO1xuXG4gIHZhciBpc0NvbWJvID1cbiAgICAoKHNyY0JpdG1hc2sgPT0gV1JBUF9BUllfRkxBRykgJiYgKGJpdG1hc2sgPT0gV1JBUF9DVVJSWV9GTEFHKSkgfHxcbiAgICAoKHNyY0JpdG1hc2sgPT0gV1JBUF9BUllfRkxBRykgJiYgKGJpdG1hc2sgPT0gV1JBUF9SRUFSR19GTEFHKSAmJiAoZGF0YVs3XS5sZW5ndGggPD0gc291cmNlWzhdKSkgfHxcbiAgICAoKHNyY0JpdG1hc2sgPT0gKFdSQVBfQVJZX0ZMQUcgfCBXUkFQX1JFQVJHX0ZMQUcpKSAmJiAoc291cmNlWzddLmxlbmd0aCA8PSBzb3VyY2VbOF0pICYmIChiaXRtYXNrID09IFdSQVBfQ1VSUllfRkxBRykpO1xuXG4gIC8vIEV4aXQgZWFybHkgaWYgbWV0YWRhdGEgY2FuJ3QgYmUgbWVyZ2VkLlxuICBpZiAoIShpc0NvbW1vbiB8fCBpc0NvbWJvKSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIC8vIFVzZSBzb3VyY2UgYHRoaXNBcmdgIGlmIGF2YWlsYWJsZS5cbiAgaWYgKHNyY0JpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRykge1xuICAgIGRhdGFbMl0gPSBzb3VyY2VbMl07XG4gICAgLy8gU2V0IHdoZW4gY3VycnlpbmcgYSBib3VuZCBmdW5jdGlvbi5cbiAgICBuZXdCaXRtYXNrIHw9IGJpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRyA/IDAgOiBXUkFQX0NVUlJZX0JPVU5EX0ZMQUc7XG4gIH1cbiAgLy8gQ29tcG9zZSBwYXJ0aWFsIGFyZ3VtZW50cy5cbiAgdmFyIHZhbHVlID0gc291cmNlWzNdO1xuICBpZiAodmFsdWUpIHtcbiAgICB2YXIgcGFydGlhbHMgPSBkYXRhWzNdO1xuICAgIGRhdGFbM10gPSBwYXJ0aWFscyA/IGNvbXBvc2VBcmdzKHBhcnRpYWxzLCB2YWx1ZSwgc291cmNlWzRdKSA6IHZhbHVlO1xuICAgIGRhdGFbNF0gPSBwYXJ0aWFscyA/IHJlcGxhY2VIb2xkZXJzKGRhdGFbM10sIFBMQUNFSE9MREVSKSA6IHNvdXJjZVs0XTtcbiAgfVxuICAvLyBDb21wb3NlIHBhcnRpYWwgcmlnaHQgYXJndW1lbnRzLlxuICB2YWx1ZSA9IHNvdXJjZVs1XTtcbiAgaWYgKHZhbHVlKSB7XG4gICAgcGFydGlhbHMgPSBkYXRhWzVdO1xuICAgIGRhdGFbNV0gPSBwYXJ0aWFscyA/IGNvbXBvc2VBcmdzUmlnaHQocGFydGlhbHMsIHZhbHVlLCBzb3VyY2VbNl0pIDogdmFsdWU7XG4gICAgZGF0YVs2XSA9IHBhcnRpYWxzID8gcmVwbGFjZUhvbGRlcnMoZGF0YVs1XSwgUExBQ0VIT0xERVIpIDogc291cmNlWzZdO1xuICB9XG4gIC8vIFVzZSBzb3VyY2UgYGFyZ1Bvc2AgaWYgYXZhaWxhYmxlLlxuICB2YWx1ZSA9IHNvdXJjZVs3XTtcbiAgaWYgKHZhbHVlKSB7XG4gICAgZGF0YVs3XSA9IHZhbHVlO1xuICB9XG4gIC8vIFVzZSBzb3VyY2UgYGFyeWAgaWYgaXQncyBzbWFsbGVyLlxuICBpZiAoc3JjQml0bWFzayAmIFdSQVBfQVJZX0ZMQUcpIHtcbiAgICBkYXRhWzhdID0gZGF0YVs4XSA9PSBudWxsID8gc291cmNlWzhdIDogbmF0aXZlTWluKGRhdGFbOF0sIHNvdXJjZVs4XSk7XG4gIH1cbiAgLy8gVXNlIHNvdXJjZSBgYXJpdHlgIGlmIG9uZSBpcyBub3QgcHJvdmlkZWQuXG4gIGlmIChkYXRhWzldID09IG51bGwpIHtcbiAgICBkYXRhWzldID0gc291cmNlWzldO1xuICB9XG4gIC8vIFVzZSBzb3VyY2UgYGZ1bmNgIGFuZCBtZXJnZSBiaXRtYXNrcy5cbiAgZGF0YVswXSA9IHNvdXJjZVswXTtcbiAgZGF0YVsxXSA9IG5ld0JpdG1hc2s7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWVyZ2VEYXRhO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBOQU4gPSAwIC8gMDtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZS4gKi9cbnZhciByZVRyaW0gPSAvXlxccyt8XFxzKyQvZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJhZCBzaWduZWQgaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmFkSGV4ID0gL15bLStdMHhbMC05YS1mXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiaW5hcnkgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmluYXJ5ID0gL14wYlswMV0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb2N0YWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzT2N0YWwgPSAvXjBvWzAtN10rJC9pO1xuXG4vKiogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgd2l0aG91dCBhIGRlcGVuZGVuY3kgb24gYHJvb3RgLiAqL1xudmFyIGZyZWVQYXJzZUludCA9IHBhcnNlSW50O1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9OdW1iZXIoMy4yKTtcbiAqIC8vID0+IDMuMlxuICpcbiAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiA1ZS0zMjRcbiAqXG4gKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcbiAqIC8vID0+IEluZmluaXR5XG4gKlxuICogXy50b051bWJlcignMy4yJyk7XG4gKiAvLyA9PiAzLjJcbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIE5BTjtcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuICAgIHZhbHVlID0gaXNPYmplY3Qob3RoZXIpID8gKG90aGVyICsgJycpIDogb3RoZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICB9XG4gIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZVRyaW0sICcnKTtcbiAgdmFyIGlzQmluYXJ5ID0gcmVJc0JpbmFyeS50ZXN0KHZhbHVlKTtcbiAgcmV0dXJuIChpc0JpbmFyeSB8fCByZUlzT2N0YWwudGVzdCh2YWx1ZSkpXG4gICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXG4gICAgOiAocmVJc0JhZEhleC50ZXN0KHZhbHVlKSA/IE5BTiA6ICt2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9OdW1iZXI7XG4iLCJ2YXIgdG9OdW1iZXIgPSByZXF1aXJlKCcuL3RvTnVtYmVyJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDAsXG4gICAgTUFYX0lOVEVHRVIgPSAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwODtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgZmluaXRlIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTIuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgbnVtYmVyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvRmluaXRlKDMuMik7XG4gKiAvLyA9PiAzLjJcbiAqXG4gKiBfLnRvRmluaXRlKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gNWUtMzI0XG4gKlxuICogXy50b0Zpbml0ZShJbmZpbml0eSk7XG4gKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICpcbiAqIF8udG9GaW5pdGUoJzMuMicpO1xuICogLy8gPT4gMy4yXG4gKi9cbmZ1bmN0aW9uIHRvRmluaXRlKHZhbHVlKSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6IDA7XG4gIH1cbiAgdmFsdWUgPSB0b051bWJlcih2YWx1ZSk7XG4gIGlmICh2YWx1ZSA9PT0gSU5GSU5JVFkgfHwgdmFsdWUgPT09IC1JTkZJTklUWSkge1xuICAgIHZhciBzaWduID0gKHZhbHVlIDwgMCA/IC0xIDogMSk7XG4gICAgcmV0dXJuIHNpZ24gKiBNQVhfSU5URUdFUjtcbiAgfVxuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlID8gdmFsdWUgOiAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvRmluaXRlO1xuIiwidmFyIHRvRmluaXRlID0gcmVxdWlyZSgnLi90b0Zpbml0ZScpO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gaW50ZWdlci5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0ludGVnZXJgXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9pbnRlZ2VyKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBpbnRlZ2VyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvSW50ZWdlcigzLjIpO1xuICogLy8gPT4gM1xuICpcbiAqIF8udG9JbnRlZ2VyKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gMFxuICpcbiAqIF8udG9JbnRlZ2VyKEluZmluaXR5KTtcbiAqIC8vID0+IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4XG4gKlxuICogXy50b0ludGVnZXIoJzMuMicpO1xuICogLy8gPT4gM1xuICovXG5mdW5jdGlvbiB0b0ludGVnZXIodmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IHRvRmluaXRlKHZhbHVlKSxcbiAgICAgIHJlbWFpbmRlciA9IHJlc3VsdCAlIDE7XG5cbiAgcmV0dXJuIHJlc3VsdCA9PT0gcmVzdWx0ID8gKHJlbWFpbmRlciA/IHJlc3VsdCAtIHJlbWFpbmRlciA6IHJlc3VsdCkgOiAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvSW50ZWdlcjtcbiIsInZhciBiYXNlU2V0RGF0YSA9IHJlcXVpcmUoJy4vX2Jhc2VTZXREYXRhJyksXG4gICAgY3JlYXRlQmluZCA9IHJlcXVpcmUoJy4vX2NyZWF0ZUJpbmQnKSxcbiAgICBjcmVhdGVDdXJyeSA9IHJlcXVpcmUoJy4vX2NyZWF0ZUN1cnJ5JyksXG4gICAgY3JlYXRlSHlicmlkID0gcmVxdWlyZSgnLi9fY3JlYXRlSHlicmlkJyksXG4gICAgY3JlYXRlUGFydGlhbCA9IHJlcXVpcmUoJy4vX2NyZWF0ZVBhcnRpYWwnKSxcbiAgICBnZXREYXRhID0gcmVxdWlyZSgnLi9fZ2V0RGF0YScpLFxuICAgIG1lcmdlRGF0YSA9IHJlcXVpcmUoJy4vX21lcmdlRGF0YScpLFxuICAgIHNldERhdGEgPSByZXF1aXJlKCcuL19zZXREYXRhJyksXG4gICAgc2V0V3JhcFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fc2V0V3JhcFRvU3RyaW5nJyksXG4gICAgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi90b0ludGVnZXInKTtcblxuLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgZnVuY3Rpb24gbWV0YWRhdGEuICovXG52YXIgV1JBUF9CSU5EX0ZMQUcgPSAxLFxuICAgIFdSQVBfQklORF9LRVlfRkxBRyA9IDIsXG4gICAgV1JBUF9DVVJSWV9GTEFHID0gOCxcbiAgICBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcgPSAxNixcbiAgICBXUkFQX1BBUlRJQUxfRkxBRyA9IDMyLFxuICAgIFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHID0gNjQ7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBlaXRoZXIgY3VycmllcyBvciBpbnZva2VzIGBmdW5jYCB3aXRoIG9wdGlvbmFsXG4gKiBgdGhpc2AgYmluZGluZyBhbmQgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufHN0cmluZ30gZnVuYyBUaGUgZnVuY3Rpb24gb3IgbWV0aG9kIG5hbWUgdG8gd3JhcC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICogICAgMSAtIGBfLmJpbmRgXG4gKiAgICAyIC0gYF8uYmluZEtleWBcbiAqICAgIDQgLSBgXy5jdXJyeWAgb3IgYF8uY3VycnlSaWdodGAgb2YgYSBib3VuZCBmdW5jdGlvblxuICogICAgOCAtIGBfLmN1cnJ5YFxuICogICAxNiAtIGBfLmN1cnJ5UmlnaHRgXG4gKiAgIDMyIC0gYF8ucGFydGlhbGBcbiAqICAgNjQgLSBgXy5wYXJ0aWFsUmlnaHRgXG4gKiAgMTI4IC0gYF8ucmVhcmdgXG4gKiAgMjU2IC0gYF8uYXJ5YFxuICogIDUxMiAtIGBfLmZsaXBgXG4gKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICogQHBhcmFtIHtBcnJheX0gW2hvbGRlcnNdIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJnUG9zXSBUaGUgYXJndW1lbnQgcG9zaXRpb25zIG9mIHRoZSBuZXcgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2FyeV0gVGhlIGFyaXR5IGNhcCBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5XSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlV3JhcChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycywgYXJnUG9zLCBhcnksIGFyaXR5KSB7XG4gIHZhciBpc0JpbmRLZXkgPSBiaXRtYXNrICYgV1JBUF9CSU5EX0tFWV9GTEFHO1xuICBpZiAoIWlzQmluZEtleSAmJiB0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHZhciBsZW5ndGggPSBwYXJ0aWFscyA/IHBhcnRpYWxzLmxlbmd0aCA6IDA7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgYml0bWFzayAmPSB+KFdSQVBfUEFSVElBTF9GTEFHIHwgV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcpO1xuICAgIHBhcnRpYWxzID0gaG9sZGVycyA9IHVuZGVmaW5lZDtcbiAgfVxuICBhcnkgPSBhcnkgPT09IHVuZGVmaW5lZCA/IGFyeSA6IG5hdGl2ZU1heCh0b0ludGVnZXIoYXJ5KSwgMCk7XG4gIGFyaXR5ID0gYXJpdHkgPT09IHVuZGVmaW5lZCA/IGFyaXR5IDogdG9JbnRlZ2VyKGFyaXR5KTtcbiAgbGVuZ3RoIC09IGhvbGRlcnMgPyBob2xkZXJzLmxlbmd0aCA6IDA7XG5cbiAgaWYgKGJpdG1hc2sgJiBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRykge1xuICAgIHZhciBwYXJ0aWFsc1JpZ2h0ID0gcGFydGlhbHMsXG4gICAgICAgIGhvbGRlcnNSaWdodCA9IGhvbGRlcnM7XG5cbiAgICBwYXJ0aWFscyA9IGhvbGRlcnMgPSB1bmRlZmluZWQ7XG4gIH1cbiAgdmFyIGRhdGEgPSBpc0JpbmRLZXkgPyB1bmRlZmluZWQgOiBnZXREYXRhKGZ1bmMpO1xuXG4gIHZhciBuZXdEYXRhID0gW1xuICAgIGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzLCBwYXJ0aWFsc1JpZ2h0LCBob2xkZXJzUmlnaHQsXG4gICAgYXJnUG9zLCBhcnksIGFyaXR5XG4gIF07XG5cbiAgaWYgKGRhdGEpIHtcbiAgICBtZXJnZURhdGEobmV3RGF0YSwgZGF0YSk7XG4gIH1cbiAgZnVuYyA9IG5ld0RhdGFbMF07XG4gIGJpdG1hc2sgPSBuZXdEYXRhWzFdO1xuICB0aGlzQXJnID0gbmV3RGF0YVsyXTtcbiAgcGFydGlhbHMgPSBuZXdEYXRhWzNdO1xuICBob2xkZXJzID0gbmV3RGF0YVs0XTtcbiAgYXJpdHkgPSBuZXdEYXRhWzldID0gbmV3RGF0YVs5XSA9PT0gdW5kZWZpbmVkXG4gICAgPyAoaXNCaW5kS2V5ID8gMCA6IGZ1bmMubGVuZ3RoKVxuICAgIDogbmF0aXZlTWF4KG5ld0RhdGFbOV0gLSBsZW5ndGgsIDApO1xuXG4gIGlmICghYXJpdHkgJiYgYml0bWFzayAmIChXUkFQX0NVUlJZX0ZMQUcgfCBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcpKSB7XG4gICAgYml0bWFzayAmPSB+KFdSQVBfQ1VSUllfRkxBRyB8IFdSQVBfQ1VSUllfUklHSFRfRkxBRyk7XG4gIH1cbiAgaWYgKCFiaXRtYXNrIHx8IGJpdG1hc2sgPT0gV1JBUF9CSU5EX0ZMQUcpIHtcbiAgICB2YXIgcmVzdWx0ID0gY3JlYXRlQmluZChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnKTtcbiAgfSBlbHNlIGlmIChiaXRtYXNrID09IFdSQVBfQ1VSUllfRkxBRyB8fCBiaXRtYXNrID09IFdSQVBfQ1VSUllfUklHSFRfRkxBRykge1xuICAgIHJlc3VsdCA9IGNyZWF0ZUN1cnJ5KGZ1bmMsIGJpdG1hc2ssIGFyaXR5KTtcbiAgfSBlbHNlIGlmICgoYml0bWFzayA9PSBXUkFQX1BBUlRJQUxfRkxBRyB8fCBiaXRtYXNrID09IChXUkFQX0JJTkRfRkxBRyB8IFdSQVBfUEFSVElBTF9GTEFHKSkgJiYgIWhvbGRlcnMubGVuZ3RoKSB7XG4gICAgcmVzdWx0ID0gY3JlYXRlUGFydGlhbChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscyk7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0gY3JlYXRlSHlicmlkLmFwcGx5KHVuZGVmaW5lZCwgbmV3RGF0YSk7XG4gIH1cbiAgdmFyIHNldHRlciA9IGRhdGEgPyBiYXNlU2V0RGF0YSA6IHNldERhdGE7XG4gIHJldHVybiBzZXRXcmFwVG9TdHJpbmcoc2V0dGVyKHJlc3VsdCwgbmV3RGF0YSksIGZ1bmMsIGJpdG1hc2spO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVdyYXA7XG4iLCJ2YXIgYmFzZVJlc3QgPSByZXF1aXJlKCcuL19iYXNlUmVzdCcpLFxuICAgIGNyZWF0ZVdyYXAgPSByZXF1aXJlKCcuL19jcmVhdGVXcmFwJyksXG4gICAgZ2V0SG9sZGVyID0gcmVxdWlyZSgnLi9fZ2V0SG9sZGVyJyksXG4gICAgcmVwbGFjZUhvbGRlcnMgPSByZXF1aXJlKCcuL19yZXBsYWNlSG9sZGVycycpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBmdW5jdGlvbiBtZXRhZGF0YS4gKi9cbnZhciBXUkFQX0JJTkRfRkxBRyA9IDEsXG4gICAgV1JBUF9QQVJUSUFMX0ZMQUcgPSAzMjtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2BcbiAqIGFuZCBgcGFydGlhbHNgIHByZXBlbmRlZCB0byB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxuICpcbiAqIFRoZSBgXy5iaW5kLnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWMgYnVpbGRzLFxuICogbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICpcbiAqICoqTm90ZToqKiBVbmxpa2UgbmF0aXZlIGBGdW5jdGlvbiNiaW5kYCwgdGhpcyBtZXRob2QgZG9lc24ndCBzZXQgdGhlIFwibGVuZ3RoXCJcbiAqIHByb3BlcnR5IG9mIGJvdW5kIGZ1bmN0aW9ucy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGJpbmQuXG4gKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAqIEBwYXJhbSB7Li4uKn0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYm91bmQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIGdyZWV0KGdyZWV0aW5nLCBwdW5jdHVhdGlvbikge1xuICogICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyB0aGlzLnVzZXIgKyBwdW5jdHVhdGlvbjtcbiAqIH1cbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAndXNlcic6ICdmcmVkJyB9O1xuICpcbiAqIHZhciBib3VuZCA9IF8uYmluZChncmVldCwgb2JqZWN0LCAnaGknKTtcbiAqIGJvdW5kKCchJyk7XG4gKiAvLyA9PiAnaGkgZnJlZCEnXG4gKlxuICogLy8gQm91bmQgd2l0aCBwbGFjZWhvbGRlcnMuXG4gKiB2YXIgYm91bmQgPSBfLmJpbmQoZ3JlZXQsIG9iamVjdCwgXywgJyEnKTtcbiAqIGJvdW5kKCdoaScpO1xuICogLy8gPT4gJ2hpIGZyZWQhJ1xuICovXG52YXIgYmluZCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIHRoaXNBcmcsIHBhcnRpYWxzKSB7XG4gIHZhciBiaXRtYXNrID0gV1JBUF9CSU5EX0ZMQUc7XG4gIGlmIChwYXJ0aWFscy5sZW5ndGgpIHtcbiAgICB2YXIgaG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKHBhcnRpYWxzLCBnZXRIb2xkZXIoYmluZCkpO1xuICAgIGJpdG1hc2sgfD0gV1JBUF9QQVJUSUFMX0ZMQUc7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMpO1xufSk7XG5cbi8vIEFzc2lnbiBkZWZhdWx0IHBsYWNlaG9sZGVycy5cbmJpbmQucGxhY2Vob2xkZXIgPSB7fTtcblxubW9kdWxlLmV4cG9ydHMgPSBiaW5kO1xuIiwiZXhwb3J0IGRlZmF1bHQgdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6XG4gICAgICAgICAgICB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOlxuICAgICAgICAgICAgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbi8vIGJhc2VkIG9mZiBodHRwczovL2dpdGh1Yi5jb20vZGVmdW5jdHpvbWJpZS9ub2RlLXByb2Nlc3MvYmxvYi9tYXN0ZXIvYnJvd3Nlci5qc1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbnZhciBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuaWYgKHR5cGVvZiBnbG9iYWwuc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xufVxuaWYgKHR5cGVvZiBnbG9iYWwuY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xufVxuXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5leHBvcnQgZnVuY3Rpb24gbmV4dFRpY2soZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn1cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5leHBvcnQgdmFyIHRpdGxlID0gJ2Jyb3dzZXInO1xuZXhwb3J0IHZhciBwbGF0Zm9ybSA9ICdicm93c2VyJztcbmV4cG9ydCB2YXIgYnJvd3NlciA9IHRydWU7XG5leHBvcnQgdmFyIGVudiA9IHt9O1xuZXhwb3J0IHZhciBhcmd2ID0gW107XG5leHBvcnQgdmFyIHZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbmV4cG9ydCB2YXIgdmVyc2lvbnMgPSB7fTtcbmV4cG9ydCB2YXIgcmVsZWFzZSA9IHt9O1xuZXhwb3J0IHZhciBjb25maWcgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmV4cG9ydCB2YXIgb24gPSBub29wO1xuZXhwb3J0IHZhciBhZGRMaXN0ZW5lciA9IG5vb3A7XG5leHBvcnQgdmFyIG9uY2UgPSBub29wO1xuZXhwb3J0IHZhciBvZmYgPSBub29wO1xuZXhwb3J0IHZhciByZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5leHBvcnQgdmFyIHJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5leHBvcnQgdmFyIGVtaXQgPSBub29wO1xuXG5leHBvcnQgZnVuY3Rpb24gYmluZGluZyhuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3dkICgpIHsgcmV0dXJuICcvJyB9XG5leHBvcnQgZnVuY3Rpb24gY2hkaXIgKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuZXhwb3J0IGZ1bmN0aW9uIHVtYXNrKCkgeyByZXR1cm4gMDsgfVxuXG4vLyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9rdW1hdmlzL2Jyb3dzZXItcHJvY2Vzcy1ocnRpbWUvYmxvYi9tYXN0ZXIvaW5kZXguanNcbnZhciBwZXJmb3JtYW5jZSA9IGdsb2JhbC5wZXJmb3JtYW5jZSB8fCB7fVxudmFyIHBlcmZvcm1hbmNlTm93ID1cbiAgcGVyZm9ybWFuY2Uubm93ICAgICAgICB8fFxuICBwZXJmb3JtYW5jZS5tb3pOb3cgICAgIHx8XG4gIHBlcmZvcm1hbmNlLm1zTm93ICAgICAgfHxcbiAgcGVyZm9ybWFuY2Uub05vdyAgICAgICB8fFxuICBwZXJmb3JtYW5jZS53ZWJraXROb3cgIHx8XG4gIGZ1bmN0aW9uKCl7IHJldHVybiAobmV3IERhdGUoKSkuZ2V0VGltZSgpIH1cblxuLy8gZ2VuZXJhdGUgdGltZXN0YW1wIG9yIGRlbHRhXG4vLyBzZWUgaHR0cDovL25vZGVqcy5vcmcvYXBpL3Byb2Nlc3MuaHRtbCNwcm9jZXNzX3Byb2Nlc3NfaHJ0aW1lXG5leHBvcnQgZnVuY3Rpb24gaHJ0aW1lKHByZXZpb3VzVGltZXN0YW1wKXtcbiAgdmFyIGNsb2NrdGltZSA9IHBlcmZvcm1hbmNlTm93LmNhbGwocGVyZm9ybWFuY2UpKjFlLTNcbiAgdmFyIHNlY29uZHMgPSBNYXRoLmZsb29yKGNsb2NrdGltZSlcbiAgdmFyIG5hbm9zZWNvbmRzID0gTWF0aC5mbG9vcigoY2xvY2t0aW1lJTEpKjFlOSlcbiAgaWYgKHByZXZpb3VzVGltZXN0YW1wKSB7XG4gICAgc2Vjb25kcyA9IHNlY29uZHMgLSBwcmV2aW91c1RpbWVzdGFtcFswXVxuICAgIG5hbm9zZWNvbmRzID0gbmFub3NlY29uZHMgLSBwcmV2aW91c1RpbWVzdGFtcFsxXVxuICAgIGlmIChuYW5vc2Vjb25kczwwKSB7XG4gICAgICBzZWNvbmRzLS1cbiAgICAgIG5hbm9zZWNvbmRzICs9IDFlOVxuICAgIH1cbiAgfVxuICByZXR1cm4gW3NlY29uZHMsbmFub3NlY29uZHNdXG59XG5cbnZhciBzdGFydFRpbWUgPSBuZXcgRGF0ZSgpO1xuZXhwb3J0IGZ1bmN0aW9uIHVwdGltZSgpIHtcbiAgdmFyIGN1cnJlbnRUaW1lID0gbmV3IERhdGUoKTtcbiAgdmFyIGRpZiA9IGN1cnJlbnRUaW1lIC0gc3RhcnRUaW1lO1xuICByZXR1cm4gZGlmIC8gMTAwMDtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuZXh0VGljazogbmV4dFRpY2ssXG4gIHRpdGxlOiB0aXRsZSxcbiAgYnJvd3NlcjogYnJvd3NlcixcbiAgZW52OiBlbnYsXG4gIGFyZ3Y6IGFyZ3YsXG4gIHZlcnNpb246IHZlcnNpb24sXG4gIHZlcnNpb25zOiB2ZXJzaW9ucyxcbiAgb246IG9uLFxuICBhZGRMaXN0ZW5lcjogYWRkTGlzdGVuZXIsXG4gIG9uY2U6IG9uY2UsXG4gIG9mZjogb2ZmLFxuICByZW1vdmVMaXN0ZW5lcjogcmVtb3ZlTGlzdGVuZXIsXG4gIHJlbW92ZUFsbExpc3RlbmVyczogcmVtb3ZlQWxsTGlzdGVuZXJzLFxuICBlbWl0OiBlbWl0LFxuICBiaW5kaW5nOiBiaW5kaW5nLFxuICBjd2Q6IGN3ZCxcbiAgY2hkaXI6IGNoZGlyLFxuICB1bWFzazogdW1hc2ssXG4gIGhydGltZTogaHJ0aW1lLFxuICBwbGF0Zm9ybTogcGxhdGZvcm0sXG4gIHJlbGVhc2U6IHJlbGVhc2UsXG4gIGNvbmZpZzogY29uZmlnLFxuICB1cHRpbWU6IHVwdGltZVxufTtcbiIsIi8qIGF4aW9zIHYwLjE4LjAgfCAoYykgMjAxOCBieSBNYXR0IFphYnJpc2tpZSAqL1xuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiYXhpb3NcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiYXhpb3NcIl0gPSBmYWN0b3J5KCk7XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fSxcbi8qKioqKiovIFx0XHRcdGlkOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGxvYWRlZDogZmFsc2Vcbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbi8qKiovIH0pLFxuLyogMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdHZhciB1dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cdHZhciBiaW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblx0dmFyIEF4aW9zID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblx0dmFyIGRlZmF1bHRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblx0XG5cdC8qKlxuXHQgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgQXhpb3Ncblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IGRlZmF1bHRDb25maWcgVGhlIGRlZmF1bHQgY29uZmlnIGZvciB0aGUgaW5zdGFuY2Vcblx0ICogQHJldHVybiB7QXhpb3N9IEEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXG5cdCAqL1xuXHRmdW5jdGlvbiBjcmVhdGVJbnN0YW5jZShkZWZhdWx0Q29uZmlnKSB7XG5cdCAgdmFyIGNvbnRleHQgPSBuZXcgQXhpb3MoZGVmYXVsdENvbmZpZyk7XG5cdCAgdmFyIGluc3RhbmNlID0gYmluZChBeGlvcy5wcm90b3R5cGUucmVxdWVzdCwgY29udGV4dCk7XG5cdFxuXHQgIC8vIENvcHkgYXhpb3MucHJvdG90eXBlIHRvIGluc3RhbmNlXG5cdCAgdXRpbHMuZXh0ZW5kKGluc3RhbmNlLCBBeGlvcy5wcm90b3R5cGUsIGNvbnRleHQpO1xuXHRcblx0ICAvLyBDb3B5IGNvbnRleHQgdG8gaW5zdGFuY2Vcblx0ICB1dGlscy5leHRlbmQoaW5zdGFuY2UsIGNvbnRleHQpO1xuXHRcblx0ICByZXR1cm4gaW5zdGFuY2U7XG5cdH1cblx0XG5cdC8vIENyZWF0ZSB0aGUgZGVmYXVsdCBpbnN0YW5jZSB0byBiZSBleHBvcnRlZFxuXHR2YXIgYXhpb3MgPSBjcmVhdGVJbnN0YW5jZShkZWZhdWx0cyk7XG5cdFxuXHQvLyBFeHBvc2UgQXhpb3MgY2xhc3MgdG8gYWxsb3cgY2xhc3MgaW5oZXJpdGFuY2Vcblx0YXhpb3MuQXhpb3MgPSBBeGlvcztcblx0XG5cdC8vIEZhY3RvcnkgZm9yIGNyZWF0aW5nIG5ldyBpbnN0YW5jZXNcblx0YXhpb3MuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGluc3RhbmNlQ29uZmlnKSB7XG5cdCAgcmV0dXJuIGNyZWF0ZUluc3RhbmNlKHV0aWxzLm1lcmdlKGRlZmF1bHRzLCBpbnN0YW5jZUNvbmZpZykpO1xuXHR9O1xuXHRcblx0Ly8gRXhwb3NlIENhbmNlbCAmIENhbmNlbFRva2VuXG5cdGF4aW9zLkNhbmNlbCA9IF9fd2VicGFja19yZXF1aXJlX18oMjMpO1xuXHRheGlvcy5DYW5jZWxUb2tlbiA9IF9fd2VicGFja19yZXF1aXJlX18oMjQpO1xuXHRheGlvcy5pc0NhbmNlbCA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xuXHRcblx0Ly8gRXhwb3NlIGFsbC9zcHJlYWRcblx0YXhpb3MuYWxsID0gZnVuY3Rpb24gYWxsKHByb21pc2VzKSB7XG5cdCAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcblx0fTtcblx0YXhpb3Muc3ByZWFkID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNSk7XG5cdFxuXHRtb2R1bGUuZXhwb3J0cyA9IGF4aW9zO1xuXHRcblx0Ly8gQWxsb3cgdXNlIG9mIGRlZmF1bHQgaW1wb3J0IHN5bnRheCBpbiBUeXBlU2NyaXB0XG5cdG1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBheGlvcztcblxuXG4vKioqLyB9KSxcbi8qIDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHR2YXIgYmluZCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cdHZhciBpc0J1ZmZlciA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cdFxuXHQvKmdsb2JhbCB0b1N0cmluZzp0cnVlKi9cblx0XG5cdC8vIHV0aWxzIGlzIGEgbGlicmFyeSBvZiBnZW5lcmljIGhlbHBlciBmdW5jdGlvbnMgbm9uLXNwZWNpZmljIHRvIGF4aW9zXG5cdFxuXHR2YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXHRcblx0LyoqXG5cdCAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIEFycmF5XG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3Rcblx0ICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXksIG90aGVyd2lzZSBmYWxzZVxuXHQgKi9cblx0ZnVuY3Rpb24gaXNBcnJheSh2YWwpIHtcblx0ICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBBcnJheV0nO1xuXHR9XG5cdFxuXHQvKipcblx0ICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gQXJyYXlCdWZmZXJcblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG5cdCAqL1xuXHRmdW5jdGlvbiBpc0FycmF5QnVmZmVyKHZhbCkge1xuXHQgIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXSc7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZvcm1EYXRhXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3Rcblx0ICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gRm9ybURhdGEsIG90aGVyd2lzZSBmYWxzZVxuXHQgKi9cblx0ZnVuY3Rpb24gaXNGb3JtRGF0YSh2YWwpIHtcblx0ICByZXR1cm4gKHR5cGVvZiBGb3JtRGF0YSAhPT0gJ3VuZGVmaW5lZCcpICYmICh2YWwgaW5zdGFuY2VvZiBGb3JtRGF0YSk7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIHZpZXcgb24gYW4gQXJyYXlCdWZmZXJcblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIHZpZXcgb24gYW4gQXJyYXlCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuXHQgKi9cblx0ZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclZpZXcodmFsKSB7XG5cdCAgdmFyIHJlc3VsdDtcblx0ICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpICYmIChBcnJheUJ1ZmZlci5pc1ZpZXcpKSB7XG5cdCAgICByZXN1bHQgPSBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgcmVzdWx0ID0gKHZhbCkgJiYgKHZhbC5idWZmZXIpICYmICh2YWwuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpO1xuXHQgIH1cblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9XG5cdFxuXHQvKipcblx0ICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBTdHJpbmdcblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFN0cmluZywgb3RoZXJ3aXNlIGZhbHNlXG5cdCAqL1xuXHRmdW5jdGlvbiBpc1N0cmluZyh2YWwpIHtcblx0ICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZyc7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIE51bWJlclxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgTnVtYmVyLCBvdGhlcndpc2UgZmFsc2Vcblx0ICovXG5cdGZ1bmN0aW9uIGlzTnVtYmVyKHZhbCkge1xuXHQgIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJztcblx0fVxuXHRcblx0LyoqXG5cdCAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIHVuZGVmaW5lZFxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB2YWx1ZSBpcyB1bmRlZmluZWQsIG90aGVyd2lzZSBmYWxzZVxuXHQgKi9cblx0ZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsKSB7XG5cdCAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnO1xuXHR9XG5cdFxuXHQvKipcblx0ICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gT2JqZWN0XG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3Rcblx0ICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gT2JqZWN0LCBvdGhlcndpc2UgZmFsc2Vcblx0ICovXG5cdGZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xuXHQgIHJldHVybiB2YWwgIT09IG51bGwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCc7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIERhdGVcblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIERhdGUsIG90aGVyd2lzZSBmYWxzZVxuXHQgKi9cblx0ZnVuY3Rpb24gaXNEYXRlKHZhbCkge1xuXHQgIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IERhdGVdJztcblx0fVxuXHRcblx0LyoqXG5cdCAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRmlsZVxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRmlsZSwgb3RoZXJ3aXNlIGZhbHNlXG5cdCAqL1xuXHRmdW5jdGlvbiBpc0ZpbGUodmFsKSB7XG5cdCAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRmlsZV0nO1xuXHR9XG5cdFxuXHQvKipcblx0ICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBCbG9iXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3Rcblx0ICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBCbG9iLCBvdGhlcndpc2UgZmFsc2Vcblx0ICovXG5cdGZ1bmN0aW9uIGlzQmxvYih2YWwpIHtcblx0ICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBCbG9iXSc7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZ1bmN0aW9uXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3Rcblx0ICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGdW5jdGlvbiwgb3RoZXJ3aXNlIGZhbHNlXG5cdCAqL1xuXHRmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbCkge1xuXHQgIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFN0cmVhbVxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyZWFtLCBvdGhlcndpc2UgZmFsc2Vcblx0ICovXG5cdGZ1bmN0aW9uIGlzU3RyZWFtKHZhbCkge1xuXHQgIHJldHVybiBpc09iamVjdCh2YWwpICYmIGlzRnVuY3Rpb24odmFsLnBpcGUpO1xuXHR9XG5cdFxuXHQvKipcblx0ICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBVUkxTZWFyY2hQYXJhbXMgb2JqZWN0XG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3Rcblx0ICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBVUkxTZWFyY2hQYXJhbXMgb2JqZWN0LCBvdGhlcndpc2UgZmFsc2Vcblx0ICovXG5cdGZ1bmN0aW9uIGlzVVJMU2VhcmNoUGFyYW1zKHZhbCkge1xuXHQgIHJldHVybiB0eXBlb2YgVVJMU2VhcmNoUGFyYW1zICE9PSAndW5kZWZpbmVkJyAmJiB2YWwgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXM7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBUcmltIGV4Y2VzcyB3aGl0ZXNwYWNlIG9mZiB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2YgYSBzdHJpbmdcblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgU3RyaW5nIHRvIHRyaW1cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFN0cmluZyBmcmVlZCBvZiBleGNlc3Mgd2hpdGVzcGFjZVxuXHQgKi9cblx0ZnVuY3Rpb24gdHJpbShzdHIpIHtcblx0ICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMqLywgJycpLnJlcGxhY2UoL1xccyokLywgJycpO1xuXHR9XG5cdFxuXHQvKipcblx0ICogRGV0ZXJtaW5lIGlmIHdlJ3JlIHJ1bm5pbmcgaW4gYSBzdGFuZGFyZCBicm93c2VyIGVudmlyb25tZW50XG5cdCAqXG5cdCAqIFRoaXMgYWxsb3dzIGF4aW9zIHRvIHJ1biBpbiBhIHdlYiB3b3JrZXIsIGFuZCByZWFjdC1uYXRpdmUuXG5cdCAqIEJvdGggZW52aXJvbm1lbnRzIHN1cHBvcnQgWE1MSHR0cFJlcXVlc3QsIGJ1dCBub3QgZnVsbHkgc3RhbmRhcmQgZ2xvYmFscy5cblx0ICpcblx0ICogd2ViIHdvcmtlcnM6XG5cdCAqICB0eXBlb2Ygd2luZG93IC0+IHVuZGVmaW5lZFxuXHQgKiAgdHlwZW9mIGRvY3VtZW50IC0+IHVuZGVmaW5lZFxuXHQgKlxuXHQgKiByZWFjdC1uYXRpdmU6XG5cdCAqICBuYXZpZ2F0b3IucHJvZHVjdCAtPiAnUmVhY3ROYXRpdmUnXG5cdCAqL1xuXHRmdW5jdGlvbiBpc1N0YW5kYXJkQnJvd3NlckVudigpIHtcblx0ICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnByb2R1Y3QgPT09ICdSZWFjdE5hdGl2ZScpIHtcblx0ICAgIHJldHVybiBmYWxzZTtcblx0ICB9XG5cdCAgcmV0dXJuIChcblx0ICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG5cdCAgICB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnXG5cdCAgKTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIEl0ZXJhdGUgb3ZlciBhbiBBcnJheSBvciBhbiBPYmplY3QgaW52b2tpbmcgYSBmdW5jdGlvbiBmb3IgZWFjaCBpdGVtLlxuXHQgKlxuXHQgKiBJZiBgb2JqYCBpcyBhbiBBcnJheSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBwYXNzaW5nXG5cdCAqIHRoZSB2YWx1ZSwgaW5kZXgsIGFuZCBjb21wbGV0ZSBhcnJheSBmb3IgZWFjaCBpdGVtLlxuXHQgKlxuXHQgKiBJZiAnb2JqJyBpcyBhbiBPYmplY3QgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgcGFzc2luZ1xuXHQgKiB0aGUgdmFsdWUsIGtleSwgYW5kIGNvbXBsZXRlIG9iamVjdCBmb3IgZWFjaCBwcm9wZXJ0eS5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IG9iaiBUaGUgb2JqZWN0IHRvIGl0ZXJhdGVcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGNhbGxiYWNrIHRvIGludm9rZSBmb3IgZWFjaCBpdGVtXG5cdCAqL1xuXHRmdW5jdGlvbiBmb3JFYWNoKG9iaiwgZm4pIHtcblx0ICAvLyBEb24ndCBib3RoZXIgaWYgbm8gdmFsdWUgcHJvdmlkZWRcblx0ICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XG5cdCAgICByZXR1cm47XG5cdCAgfVxuXHRcblx0ICAvLyBGb3JjZSBhbiBhcnJheSBpZiBub3QgYWxyZWFkeSBzb21ldGhpbmcgaXRlcmFibGVcblx0ICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcblx0ICAgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuXHQgICAgb2JqID0gW29ial07XG5cdCAgfVxuXHRcblx0ICBpZiAoaXNBcnJheShvYmopKSB7XG5cdCAgICAvLyBJdGVyYXRlIG92ZXIgYXJyYXkgdmFsdWVzXG5cdCAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0ICAgICAgZm4uY2FsbChudWxsLCBvYmpbaV0sIGksIG9iaik7XG5cdCAgICB9XG5cdCAgfSBlbHNlIHtcblx0ICAgIC8vIEl0ZXJhdGUgb3ZlciBvYmplY3Qga2V5c1xuXHQgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuXHQgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuXHQgICAgICAgIGZuLmNhbGwobnVsbCwgb2JqW2tleV0sIGtleSwgb2JqKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblx0fVxuXHRcblx0LyoqXG5cdCAqIEFjY2VwdHMgdmFyYXJncyBleHBlY3RpbmcgZWFjaCBhcmd1bWVudCB0byBiZSBhbiBvYmplY3QsIHRoZW5cblx0ICogaW1tdXRhYmx5IG1lcmdlcyB0aGUgcHJvcGVydGllcyBvZiBlYWNoIG9iamVjdCBhbmQgcmV0dXJucyByZXN1bHQuXG5cdCAqXG5cdCAqIFdoZW4gbXVsdGlwbGUgb2JqZWN0cyBjb250YWluIHRoZSBzYW1lIGtleSB0aGUgbGF0ZXIgb2JqZWN0IGluXG5cdCAqIHRoZSBhcmd1bWVudHMgbGlzdCB3aWxsIHRha2UgcHJlY2VkZW5jZS5cblx0ICpcblx0ICogRXhhbXBsZTpcblx0ICpcblx0ICogYGBganNcblx0ICogdmFyIHJlc3VsdCA9IG1lcmdlKHtmb286IDEyM30sIHtmb286IDQ1Nn0pO1xuXHQgKiBjb25zb2xlLmxvZyhyZXN1bHQuZm9vKTsgLy8gb3V0cHV0cyA0NTZcblx0ICogYGBgXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmoxIE9iamVjdCB0byBtZXJnZVxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXN1bHQgb2YgYWxsIG1lcmdlIHByb3BlcnRpZXNcblx0ICovXG5cdGZ1bmN0aW9uIG1lcmdlKC8qIG9iajEsIG9iajIsIG9iajMsIC4uLiAqLykge1xuXHQgIHZhciByZXN1bHQgPSB7fTtcblx0ICBmdW5jdGlvbiBhc3NpZ25WYWx1ZSh2YWwsIGtleSkge1xuXHQgICAgaWYgKHR5cGVvZiByZXN1bHRba2V5XSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcpIHtcblx0ICAgICAgcmVzdWx0W2tleV0gPSBtZXJnZShyZXN1bHRba2V5XSwgdmFsKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHJlc3VsdFtrZXldID0gdmFsO1xuXHQgICAgfVxuXHQgIH1cblx0XG5cdCAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdCAgICBmb3JFYWNoKGFyZ3VtZW50c1tpXSwgYXNzaWduVmFsdWUpO1xuXHQgIH1cblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9XG5cdFxuXHQvKipcblx0ICogRXh0ZW5kcyBvYmplY3QgYSBieSBtdXRhYmx5IGFkZGluZyB0byBpdCB0aGUgcHJvcGVydGllcyBvZiBvYmplY3QgYi5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IGEgVGhlIG9iamVjdCB0byBiZSBleHRlbmRlZFxuXHQgKiBAcGFyYW0ge09iamVjdH0gYiBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0aGlzQXJnIFRoZSBvYmplY3QgdG8gYmluZCBmdW5jdGlvbiB0b1xuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSByZXN1bHRpbmcgdmFsdWUgb2Ygb2JqZWN0IGFcblx0ICovXG5cdGZ1bmN0aW9uIGV4dGVuZChhLCBiLCB0aGlzQXJnKSB7XG5cdCAgZm9yRWFjaChiLCBmdW5jdGlvbiBhc3NpZ25WYWx1ZSh2YWwsIGtleSkge1xuXHQgICAgaWYgKHRoaXNBcmcgJiYgdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICBhW2tleV0gPSBiaW5kKHZhbCwgdGhpc0FyZyk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBhW2tleV0gPSB2YWw7XG5cdCAgICB9XG5cdCAgfSk7XG5cdCAgcmV0dXJuIGE7XG5cdH1cblx0XG5cdG1vZHVsZS5leHBvcnRzID0ge1xuXHQgIGlzQXJyYXk6IGlzQXJyYXksXG5cdCAgaXNBcnJheUJ1ZmZlcjogaXNBcnJheUJ1ZmZlcixcblx0ICBpc0J1ZmZlcjogaXNCdWZmZXIsXG5cdCAgaXNGb3JtRGF0YTogaXNGb3JtRGF0YSxcblx0ICBpc0FycmF5QnVmZmVyVmlldzogaXNBcnJheUJ1ZmZlclZpZXcsXG5cdCAgaXNTdHJpbmc6IGlzU3RyaW5nLFxuXHQgIGlzTnVtYmVyOiBpc051bWJlcixcblx0ICBpc09iamVjdDogaXNPYmplY3QsXG5cdCAgaXNVbmRlZmluZWQ6IGlzVW5kZWZpbmVkLFxuXHQgIGlzRGF0ZTogaXNEYXRlLFxuXHQgIGlzRmlsZTogaXNGaWxlLFxuXHQgIGlzQmxvYjogaXNCbG9iLFxuXHQgIGlzRnVuY3Rpb246IGlzRnVuY3Rpb24sXG5cdCAgaXNTdHJlYW06IGlzU3RyZWFtLFxuXHQgIGlzVVJMU2VhcmNoUGFyYW1zOiBpc1VSTFNlYXJjaFBhcmFtcyxcblx0ICBpc1N0YW5kYXJkQnJvd3NlckVudjogaXNTdGFuZGFyZEJyb3dzZXJFbnYsXG5cdCAgZm9yRWFjaDogZm9yRWFjaCxcblx0ICBtZXJnZTogbWVyZ2UsXG5cdCAgZXh0ZW5kOiBleHRlbmQsXG5cdCAgdHJpbTogdHJpbVxuXHR9O1xuXG5cbi8qKiovIH0pLFxuLyogMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmluZChmbiwgdGhpc0FyZykge1xuXHQgIHJldHVybiBmdW5jdGlvbiB3cmFwKCkge1xuXHQgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBmbi5hcHBseSh0aGlzQXJnLCBhcmdzKTtcblx0ICB9O1xuXHR9O1xuXG5cbi8qKiovIH0pLFxuLyogNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdC8qIVxuXHQgKiBEZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGlzIGEgQnVmZmVyXG5cdCAqXG5cdCAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG5cdCAqIEBsaWNlbnNlICBNSVRcblx0ICovXG5cdFxuXHQvLyBUaGUgX2lzQnVmZmVyIGNoZWNrIGlzIGZvciBTYWZhcmkgNS03IHN1cHBvcnQsIGJlY2F1c2UgaXQncyBtaXNzaW5nXG5cdC8vIE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHlcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7XG5cdCAgcmV0dXJuIG9iaiAhPSBudWxsICYmIChpc0J1ZmZlcihvYmopIHx8IGlzU2xvd0J1ZmZlcihvYmopIHx8ICEhb2JqLl9pc0J1ZmZlcilcblx0fVxuXHRcblx0ZnVuY3Rpb24gaXNCdWZmZXIgKG9iaikge1xuXHQgIHJldHVybiAhIW9iai5jb25zdHJ1Y3RvciAmJiB0eXBlb2Ygb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopXG5cdH1cblx0XG5cdC8vIEZvciBOb2RlIHYwLjEwIHN1cHBvcnQuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHkuXG5cdGZ1bmN0aW9uIGlzU2xvd0J1ZmZlciAob2JqKSB7XG5cdCAgcmV0dXJuIHR5cGVvZiBvYmoucmVhZEZsb2F0TEUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iai5zbGljZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpc0J1ZmZlcihvYmouc2xpY2UoMCwgMCkpXG5cdH1cblxuXG4vKioqLyB9KSxcbi8qIDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHR2YXIgZGVmYXVsdHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXHR2YXIgdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXHR2YXIgSW50ZXJjZXB0b3JNYW5hZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XG5cdHZhciBkaXNwYXRjaFJlcXVlc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcblx0XG5cdC8qKlxuXHQgKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3Ncblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IGluc3RhbmNlQ29uZmlnIFRoZSBkZWZhdWx0IGNvbmZpZyBmb3IgdGhlIGluc3RhbmNlXG5cdCAqL1xuXHRmdW5jdGlvbiBBeGlvcyhpbnN0YW5jZUNvbmZpZykge1xuXHQgIHRoaXMuZGVmYXVsdHMgPSBpbnN0YW5jZUNvbmZpZztcblx0ICB0aGlzLmludGVyY2VwdG9ycyA9IHtcblx0ICAgIHJlcXVlc3Q6IG5ldyBJbnRlcmNlcHRvck1hbmFnZXIoKSxcblx0ICAgIHJlc3BvbnNlOiBuZXcgSW50ZXJjZXB0b3JNYW5hZ2VyKClcblx0ICB9O1xuXHR9XG5cdFxuXHQvKipcblx0ICogRGlzcGF0Y2ggYSByZXF1ZXN0XG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZyBzcGVjaWZpYyBmb3IgdGhpcyByZXF1ZXN0IChtZXJnZWQgd2l0aCB0aGlzLmRlZmF1bHRzKVxuXHQgKi9cblx0QXhpb3MucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiByZXF1ZXN0KGNvbmZpZykge1xuXHQgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuXHQgIC8vIEFsbG93IGZvciBheGlvcygnZXhhbXBsZS91cmwnWywgY29uZmlnXSkgYSBsYSBmZXRjaCBBUElcblx0ICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcblx0ICAgIGNvbmZpZyA9IHV0aWxzLm1lcmdlKHtcblx0ICAgICAgdXJsOiBhcmd1bWVudHNbMF1cblx0ICAgIH0sIGFyZ3VtZW50c1sxXSk7XG5cdCAgfVxuXHRcblx0ICBjb25maWcgPSB1dGlscy5tZXJnZShkZWZhdWx0cywge21ldGhvZDogJ2dldCd9LCB0aGlzLmRlZmF1bHRzLCBjb25maWcpO1xuXHQgIGNvbmZpZy5tZXRob2QgPSBjb25maWcubWV0aG9kLnRvTG93ZXJDYXNlKCk7XG5cdFxuXHQgIC8vIEhvb2sgdXAgaW50ZXJjZXB0b3JzIG1pZGRsZXdhcmVcblx0ICB2YXIgY2hhaW4gPSBbZGlzcGF0Y2hSZXF1ZXN0LCB1bmRlZmluZWRdO1xuXHQgIHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGNvbmZpZyk7XG5cdFxuXHQgIHRoaXMuaW50ZXJjZXB0b3JzLnJlcXVlc3QuZm9yRWFjaChmdW5jdGlvbiB1bnNoaWZ0UmVxdWVzdEludGVyY2VwdG9ycyhpbnRlcmNlcHRvcikge1xuXHQgICAgY2hhaW4udW5zaGlmdChpbnRlcmNlcHRvci5mdWxmaWxsZWQsIGludGVyY2VwdG9yLnJlamVjdGVkKTtcblx0ICB9KTtcblx0XG5cdCAgdGhpcy5pbnRlcmNlcHRvcnMucmVzcG9uc2UuZm9yRWFjaChmdW5jdGlvbiBwdXNoUmVzcG9uc2VJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcblx0ICAgIGNoYWluLnB1c2goaW50ZXJjZXB0b3IuZnVsZmlsbGVkLCBpbnRlcmNlcHRvci5yZWplY3RlZCk7XG5cdCAgfSk7XG5cdFxuXHQgIHdoaWxlIChjaGFpbi5sZW5ndGgpIHtcblx0ICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oY2hhaW4uc2hpZnQoKSwgY2hhaW4uc2hpZnQoKSk7XG5cdCAgfVxuXHRcblx0ICByZXR1cm4gcHJvbWlzZTtcblx0fTtcblx0XG5cdC8vIFByb3ZpZGUgYWxpYXNlcyBmb3Igc3VwcG9ydGVkIHJlcXVlc3QgbWV0aG9kc1xuXHR1dGlscy5mb3JFYWNoKFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJywgJ29wdGlvbnMnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZE5vRGF0YShtZXRob2QpIHtcblx0ICAvKmVzbGludCBmdW5jLW5hbWVzOjAqL1xuXHQgIEF4aW9zLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odXJsLCBjb25maWcpIHtcblx0ICAgIHJldHVybiB0aGlzLnJlcXVlc3QodXRpbHMubWVyZ2UoY29uZmlnIHx8IHt9LCB7XG5cdCAgICAgIG1ldGhvZDogbWV0aG9kLFxuXHQgICAgICB1cmw6IHVybFxuXHQgICAgfSkpO1xuXHQgIH07XG5cdH0pO1xuXHRcblx0dXRpbHMuZm9yRWFjaChbJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2RXaXRoRGF0YShtZXRob2QpIHtcblx0ICAvKmVzbGludCBmdW5jLW5hbWVzOjAqL1xuXHQgIEF4aW9zLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odXJsLCBkYXRhLCBjb25maWcpIHtcblx0ICAgIHJldHVybiB0aGlzLnJlcXVlc3QodXRpbHMubWVyZ2UoY29uZmlnIHx8IHt9LCB7XG5cdCAgICAgIG1ldGhvZDogbWV0aG9kLFxuXHQgICAgICB1cmw6IHVybCxcblx0ICAgICAgZGF0YTogZGF0YVxuXHQgICAgfSkpO1xuXHQgIH07XG5cdH0pO1xuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSBBeGlvcztcblxuXG4vKioqLyB9KSxcbi8qIDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHR2YXIgdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXHR2YXIgbm9ybWFsaXplSGVhZGVyTmFtZSA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cdFxuXHR2YXIgREVGQVVMVF9DT05URU5UX1RZUEUgPSB7XG5cdCAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnXG5cdH07XG5cdFxuXHRmdW5jdGlvbiBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgdmFsdWUpIHtcblx0ICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGhlYWRlcnMpICYmIHV0aWxzLmlzVW5kZWZpbmVkKGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKSkge1xuXHQgICAgaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSB2YWx1ZTtcblx0ICB9XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGdldERlZmF1bHRBZGFwdGVyKCkge1xuXHQgIHZhciBhZGFwdGVyO1xuXHQgIGlmICh0eXBlb2YgWE1MSHR0cFJlcXVlc3QgIT09ICd1bmRlZmluZWQnKSB7XG5cdCAgICAvLyBGb3IgYnJvd3NlcnMgdXNlIFhIUiBhZGFwdGVyXG5cdCAgICBhZGFwdGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblx0ICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJykge1xuXHQgICAgLy8gRm9yIG5vZGUgdXNlIEhUVFAgYWRhcHRlclxuXHQgICAgYWRhcHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5cdCAgfVxuXHQgIHJldHVybiBhZGFwdGVyO1xuXHR9XG5cdFxuXHR2YXIgZGVmYXVsdHMgPSB7XG5cdCAgYWRhcHRlcjogZ2V0RGVmYXVsdEFkYXB0ZXIoKSxcblx0XG5cdCAgdHJhbnNmb3JtUmVxdWVzdDogW2Z1bmN0aW9uIHRyYW5zZm9ybVJlcXVlc3QoZGF0YSwgaGVhZGVycykge1xuXHQgICAgbm9ybWFsaXplSGVhZGVyTmFtZShoZWFkZXJzLCAnQ29udGVudC1UeXBlJyk7XG5cdCAgICBpZiAodXRpbHMuaXNGb3JtRGF0YShkYXRhKSB8fFxuXHQgICAgICB1dGlscy5pc0FycmF5QnVmZmVyKGRhdGEpIHx8XG5cdCAgICAgIHV0aWxzLmlzQnVmZmVyKGRhdGEpIHx8XG5cdCAgICAgIHV0aWxzLmlzU3RyZWFtKGRhdGEpIHx8XG5cdCAgICAgIHV0aWxzLmlzRmlsZShkYXRhKSB8fFxuXHQgICAgICB1dGlscy5pc0Jsb2IoZGF0YSlcblx0ICAgICkge1xuXHQgICAgICByZXR1cm4gZGF0YTtcblx0ICAgIH1cblx0ICAgIGlmICh1dGlscy5pc0FycmF5QnVmZmVyVmlldyhkYXRhKSkge1xuXHQgICAgICByZXR1cm4gZGF0YS5idWZmZXI7XG5cdCAgICB9XG5cdCAgICBpZiAodXRpbHMuaXNVUkxTZWFyY2hQYXJhbXMoZGF0YSkpIHtcblx0ICAgICAgc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD11dGYtOCcpO1xuXHQgICAgICByZXR1cm4gZGF0YS50b1N0cmluZygpO1xuXHQgICAgfVxuXHQgICAgaWYgKHV0aWxzLmlzT2JqZWN0KGRhdGEpKSB7XG5cdCAgICAgIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCAnYXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04Jyk7XG5cdCAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShkYXRhKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBkYXRhO1xuXHQgIH1dLFxuXHRcblx0ICB0cmFuc2Zvcm1SZXNwb25zZTogW2Z1bmN0aW9uIHRyYW5zZm9ybVJlc3BvbnNlKGRhdGEpIHtcblx0ICAgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuXHQgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuXHQgICAgICB0cnkge1xuXHQgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuXHQgICAgICB9IGNhdGNoIChlKSB7IC8qIElnbm9yZSAqLyB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gZGF0YTtcblx0ICB9XSxcblx0XG5cdCAgLyoqXG5cdCAgICogQSB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyB0byBhYm9ydCBhIHJlcXVlc3QuIElmIHNldCB0byAwIChkZWZhdWx0KSBhXG5cdCAgICogdGltZW91dCBpcyBub3QgY3JlYXRlZC5cblx0ICAgKi9cblx0ICB0aW1lb3V0OiAwLFxuXHRcblx0ICB4c3JmQ29va2llTmFtZTogJ1hTUkYtVE9LRU4nLFxuXHQgIHhzcmZIZWFkZXJOYW1lOiAnWC1YU1JGLVRPS0VOJyxcblx0XG5cdCAgbWF4Q29udGVudExlbmd0aDogLTEsXG5cdFxuXHQgIHZhbGlkYXRlU3RhdHVzOiBmdW5jdGlvbiB2YWxpZGF0ZVN0YXR1cyhzdGF0dXMpIHtcblx0ICAgIHJldHVybiBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMDtcblx0ICB9XG5cdH07XG5cdFxuXHRkZWZhdWx0cy5oZWFkZXJzID0ge1xuXHQgIGNvbW1vbjoge1xuXHQgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L3BsYWluLCAqLyonXG5cdCAgfVxuXHR9O1xuXHRcblx0dXRpbHMuZm9yRWFjaChbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kTm9EYXRhKG1ldGhvZCkge1xuXHQgIGRlZmF1bHRzLmhlYWRlcnNbbWV0aG9kXSA9IHt9O1xuXHR9KTtcblx0XG5cdHV0aWxzLmZvckVhY2goWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kV2l0aERhdGEobWV0aG9kKSB7XG5cdCAgZGVmYXVsdHMuaGVhZGVyc1ttZXRob2RdID0gdXRpbHMubWVyZ2UoREVGQVVMVF9DT05URU5UX1RZUEUpO1xuXHR9KTtcblx0XG5cdG1vZHVsZS5leHBvcnRzID0gZGVmYXVsdHM7XG5cblxuLyoqKi8gfSksXG4vKiA3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0dmFyIHV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblx0XG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbm9ybWFsaXplSGVhZGVyTmFtZShoZWFkZXJzLCBub3JtYWxpemVkTmFtZSkge1xuXHQgIHV0aWxzLmZvckVhY2goaGVhZGVycywgZnVuY3Rpb24gcHJvY2Vzc0hlYWRlcih2YWx1ZSwgbmFtZSkge1xuXHQgICAgaWYgKG5hbWUgIT09IG5vcm1hbGl6ZWROYW1lICYmIG5hbWUudG9VcHBlckNhc2UoKSA9PT0gbm9ybWFsaXplZE5hbWUudG9VcHBlckNhc2UoKSkge1xuXHQgICAgICBoZWFkZXJzW25vcm1hbGl6ZWROYW1lXSA9IHZhbHVlO1xuXHQgICAgICBkZWxldGUgaGVhZGVyc1tuYW1lXTtcblx0ICAgIH1cblx0ICB9KTtcblx0fTtcblxuXG4vKioqLyB9KSxcbi8qIDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHR2YXIgdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXHR2YXIgc2V0dGxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblx0dmFyIGJ1aWxkVVJMID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG5cdHZhciBwYXJzZUhlYWRlcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcblx0dmFyIGlzVVJMU2FtZU9yaWdpbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuXHR2YXIgY3JlYXRlRXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcblx0dmFyIGJ0b2EgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmJ0b2EgJiYgd2luZG93LmJ0b2EuYmluZCh3aW5kb3cpKSB8fCBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcblx0XG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24geGhyQWRhcHRlcihjb25maWcpIHtcblx0ICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gZGlzcGF0Y2hYaHJSZXF1ZXN0KHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgdmFyIHJlcXVlc3REYXRhID0gY29uZmlnLmRhdGE7XG5cdCAgICB2YXIgcmVxdWVzdEhlYWRlcnMgPSBjb25maWcuaGVhZGVycztcblx0XG5cdCAgICBpZiAodXRpbHMuaXNGb3JtRGF0YShyZXF1ZXN0RGF0YSkpIHtcblx0ICAgICAgZGVsZXRlIHJlcXVlc3RIZWFkZXJzWydDb250ZW50LVR5cGUnXTsgLy8gTGV0IHRoZSBicm93c2VyIHNldCBpdFxuXHQgICAgfVxuXHRcblx0ICAgIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cdCAgICB2YXIgbG9hZEV2ZW50ID0gJ29ucmVhZHlzdGF0ZWNoYW5nZSc7XG5cdCAgICB2YXIgeERvbWFpbiA9IGZhbHNlO1xuXHRcblx0ICAgIC8vIEZvciBJRSA4LzkgQ09SUyBzdXBwb3J0XG5cdCAgICAvLyBPbmx5IHN1cHBvcnRzIFBPU1QgYW5kIEdFVCBjYWxscyBhbmQgZG9lc24ndCByZXR1cm5zIHRoZSByZXNwb25zZSBoZWFkZXJzLlxuXHQgICAgLy8gRE9OJ1QgZG8gdGhpcyBmb3IgdGVzdGluZyBiL2MgWE1MSHR0cFJlcXVlc3QgaXMgbW9ja2VkLCBub3QgWERvbWFpblJlcXVlc3QuXG5cdCAgICBpZiAoKFwicHJvZHVjdGlvblwiKSAhPT0gJ3Rlc3QnICYmXG5cdCAgICAgICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcblx0ICAgICAgICB3aW5kb3cuWERvbWFpblJlcXVlc3QgJiYgISgnd2l0aENyZWRlbnRpYWxzJyBpbiByZXF1ZXN0KSAmJlxuXHQgICAgICAgICFpc1VSTFNhbWVPcmlnaW4oY29uZmlnLnVybCkpIHtcblx0ICAgICAgcmVxdWVzdCA9IG5ldyB3aW5kb3cuWERvbWFpblJlcXVlc3QoKTtcblx0ICAgICAgbG9hZEV2ZW50ID0gJ29ubG9hZCc7XG5cdCAgICAgIHhEb21haW4gPSB0cnVlO1xuXHQgICAgICByZXF1ZXN0Lm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiBoYW5kbGVQcm9ncmVzcygpIHt9O1xuXHQgICAgICByZXF1ZXN0Lm9udGltZW91dCA9IGZ1bmN0aW9uIGhhbmRsZVRpbWVvdXQoKSB7fTtcblx0ICAgIH1cblx0XG5cdCAgICAvLyBIVFRQIGJhc2ljIGF1dGhlbnRpY2F0aW9uXG5cdCAgICBpZiAoY29uZmlnLmF1dGgpIHtcblx0ICAgICAgdmFyIHVzZXJuYW1lID0gY29uZmlnLmF1dGgudXNlcm5hbWUgfHwgJyc7XG5cdCAgICAgIHZhciBwYXNzd29yZCA9IGNvbmZpZy5hdXRoLnBhc3N3b3JkIHx8ICcnO1xuXHQgICAgICByZXF1ZXN0SGVhZGVycy5BdXRob3JpemF0aW9uID0gJ0Jhc2ljICcgKyBidG9hKHVzZXJuYW1lICsgJzonICsgcGFzc3dvcmQpO1xuXHQgICAgfVxuXHRcblx0ICAgIHJlcXVlc3Qub3Blbihjb25maWcubWV0aG9kLnRvVXBwZXJDYXNlKCksIGJ1aWxkVVJMKGNvbmZpZy51cmwsIGNvbmZpZy5wYXJhbXMsIGNvbmZpZy5wYXJhbXNTZXJpYWxpemVyKSwgdHJ1ZSk7XG5cdFxuXHQgICAgLy8gU2V0IHRoZSByZXF1ZXN0IHRpbWVvdXQgaW4gTVNcblx0ICAgIHJlcXVlc3QudGltZW91dCA9IGNvbmZpZy50aW1lb3V0O1xuXHRcblx0ICAgIC8vIExpc3RlbiBmb3IgcmVhZHkgc3RhdGVcblx0ICAgIHJlcXVlc3RbbG9hZEV2ZW50XSA9IGZ1bmN0aW9uIGhhbmRsZUxvYWQoKSB7XG5cdCAgICAgIGlmICghcmVxdWVzdCB8fCAocmVxdWVzdC5yZWFkeVN0YXRlICE9PSA0ICYmICF4RG9tYWluKSkge1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXHRcblx0ICAgICAgLy8gVGhlIHJlcXVlc3QgZXJyb3JlZCBvdXQgYW5kIHdlIGRpZG4ndCBnZXQgYSByZXNwb25zZSwgdGhpcyB3aWxsIGJlXG5cdCAgICAgIC8vIGhhbmRsZWQgYnkgb25lcnJvciBpbnN0ZWFkXG5cdCAgICAgIC8vIFdpdGggb25lIGV4Y2VwdGlvbjogcmVxdWVzdCB0aGF0IHVzaW5nIGZpbGU6IHByb3RvY29sLCBtb3N0IGJyb3dzZXJzXG5cdCAgICAgIC8vIHdpbGwgcmV0dXJuIHN0YXR1cyBhcyAwIGV2ZW4gdGhvdWdoIGl0J3MgYSBzdWNjZXNzZnVsIHJlcXVlc3Rcblx0ICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSAwICYmICEocmVxdWVzdC5yZXNwb25zZVVSTCAmJiByZXF1ZXN0LnJlc3BvbnNlVVJMLmluZGV4T2YoJ2ZpbGU6JykgPT09IDApKSB7XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgICB9XG5cdFxuXHQgICAgICAvLyBQcmVwYXJlIHRoZSByZXNwb25zZVxuXHQgICAgICB2YXIgcmVzcG9uc2VIZWFkZXJzID0gJ2dldEFsbFJlc3BvbnNlSGVhZGVycycgaW4gcmVxdWVzdCA/IHBhcnNlSGVhZGVycyhyZXF1ZXN0LmdldEFsbFJlc3BvbnNlSGVhZGVycygpKSA6IG51bGw7XG5cdCAgICAgIHZhciByZXNwb25zZURhdGEgPSAhY29uZmlnLnJlc3BvbnNlVHlwZSB8fCBjb25maWcucmVzcG9uc2VUeXBlID09PSAndGV4dCcgPyByZXF1ZXN0LnJlc3BvbnNlVGV4dCA6IHJlcXVlc3QucmVzcG9uc2U7XG5cdCAgICAgIHZhciByZXNwb25zZSA9IHtcblx0ICAgICAgICBkYXRhOiByZXNwb25zZURhdGEsXG5cdCAgICAgICAgLy8gSUUgc2VuZHMgMTIyMyBpbnN0ZWFkIG9mIDIwNCAoaHR0cHM6Ly9naXRodWIuY29tL2F4aW9zL2F4aW9zL2lzc3Vlcy8yMDEpXG5cdCAgICAgICAgc3RhdHVzOiByZXF1ZXN0LnN0YXR1cyA9PT0gMTIyMyA/IDIwNCA6IHJlcXVlc3Quc3RhdHVzLFxuXHQgICAgICAgIHN0YXR1c1RleHQ6IHJlcXVlc3Quc3RhdHVzID09PSAxMjIzID8gJ05vIENvbnRlbnQnIDogcmVxdWVzdC5zdGF0dXNUZXh0LFxuXHQgICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlSGVhZGVycyxcblx0ICAgICAgICBjb25maWc6IGNvbmZpZyxcblx0ICAgICAgICByZXF1ZXN0OiByZXF1ZXN0XG5cdCAgICAgIH07XG5cdFxuXHQgICAgICBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCByZXNwb25zZSk7XG5cdFxuXHQgICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG5cdCAgICAgIHJlcXVlc3QgPSBudWxsO1xuXHQgICAgfTtcblx0XG5cdCAgICAvLyBIYW5kbGUgbG93IGxldmVsIG5ldHdvcmsgZXJyb3JzXG5cdCAgICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiBoYW5kbGVFcnJvcigpIHtcblx0ICAgICAgLy8gUmVhbCBlcnJvcnMgYXJlIGhpZGRlbiBmcm9tIHVzIGJ5IHRoZSBicm93c2VyXG5cdCAgICAgIC8vIG9uZXJyb3Igc2hvdWxkIG9ubHkgZmlyZSBpZiBpdCdzIGEgbmV0d29yayBlcnJvclxuXHQgICAgICByZWplY3QoY3JlYXRlRXJyb3IoJ05ldHdvcmsgRXJyb3InLCBjb25maWcsIG51bGwsIHJlcXVlc3QpKTtcblx0XG5cdCAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3Rcblx0ICAgICAgcmVxdWVzdCA9IG51bGw7XG5cdCAgICB9O1xuXHRcblx0ICAgIC8vIEhhbmRsZSB0aW1lb3V0XG5cdCAgICByZXF1ZXN0Lm9udGltZW91dCA9IGZ1bmN0aW9uIGhhbmRsZVRpbWVvdXQoKSB7XG5cdCAgICAgIHJlamVjdChjcmVhdGVFcnJvcigndGltZW91dCBvZiAnICsgY29uZmlnLnRpbWVvdXQgKyAnbXMgZXhjZWVkZWQnLCBjb25maWcsICdFQ09OTkFCT1JURUQnLFxuXHQgICAgICAgIHJlcXVlc3QpKTtcblx0XG5cdCAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3Rcblx0ICAgICAgcmVxdWVzdCA9IG51bGw7XG5cdCAgICB9O1xuXHRcblx0ICAgIC8vIEFkZCB4c3JmIGhlYWRlclxuXHQgICAgLy8gVGhpcyBpcyBvbmx5IGRvbmUgaWYgcnVubmluZyBpbiBhIHN0YW5kYXJkIGJyb3dzZXIgZW52aXJvbm1lbnQuXG5cdCAgICAvLyBTcGVjaWZpY2FsbHkgbm90IGlmIHdlJ3JlIGluIGEgd2ViIHdvcmtlciwgb3IgcmVhY3QtbmF0aXZlLlxuXHQgICAgaWYgKHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkpIHtcblx0ICAgICAgdmFyIGNvb2tpZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcblx0XG5cdCAgICAgIC8vIEFkZCB4c3JmIGhlYWRlclxuXHQgICAgICB2YXIgeHNyZlZhbHVlID0gKGNvbmZpZy53aXRoQ3JlZGVudGlhbHMgfHwgaXNVUkxTYW1lT3JpZ2luKGNvbmZpZy51cmwpKSAmJiBjb25maWcueHNyZkNvb2tpZU5hbWUgP1xuXHQgICAgICAgICAgY29va2llcy5yZWFkKGNvbmZpZy54c3JmQ29va2llTmFtZSkgOlxuXHQgICAgICAgICAgdW5kZWZpbmVkO1xuXHRcblx0ICAgICAgaWYgKHhzcmZWYWx1ZSkge1xuXHQgICAgICAgIHJlcXVlc3RIZWFkZXJzW2NvbmZpZy54c3JmSGVhZGVyTmFtZV0gPSB4c3JmVmFsdWU7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0XG5cdCAgICAvLyBBZGQgaGVhZGVycyB0byB0aGUgcmVxdWVzdFxuXHQgICAgaWYgKCdzZXRSZXF1ZXN0SGVhZGVyJyBpbiByZXF1ZXN0KSB7XG5cdCAgICAgIHV0aWxzLmZvckVhY2gocmVxdWVzdEhlYWRlcnMsIGZ1bmN0aW9uIHNldFJlcXVlc3RIZWFkZXIodmFsLCBrZXkpIHtcblx0ICAgICAgICBpZiAodHlwZW9mIHJlcXVlc3REYXRhID09PSAndW5kZWZpbmVkJyAmJiBrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ2NvbnRlbnQtdHlwZScpIHtcblx0ICAgICAgICAgIC8vIFJlbW92ZSBDb250ZW50LVR5cGUgaWYgZGF0YSBpcyB1bmRlZmluZWRcblx0ICAgICAgICAgIGRlbGV0ZSByZXF1ZXN0SGVhZGVyc1trZXldO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAvLyBPdGhlcndpc2UgYWRkIGhlYWRlciB0byB0aGUgcmVxdWVzdFxuXHQgICAgICAgICAgcmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgdmFsKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXHRcblx0ICAgIC8vIEFkZCB3aXRoQ3JlZGVudGlhbHMgdG8gcmVxdWVzdCBpZiBuZWVkZWRcblx0ICAgIGlmIChjb25maWcud2l0aENyZWRlbnRpYWxzKSB7XG5cdCAgICAgIHJlcXVlc3Qud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcblx0ICAgIH1cblx0XG5cdCAgICAvLyBBZGQgcmVzcG9uc2VUeXBlIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG5cdCAgICBpZiAoY29uZmlnLnJlc3BvbnNlVHlwZSkge1xuXHQgICAgICB0cnkge1xuXHQgICAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gY29uZmlnLnJlc3BvbnNlVHlwZTtcblx0ICAgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICAgIC8vIEV4cGVjdGVkIERPTUV4Y2VwdGlvbiB0aHJvd24gYnkgYnJvd3NlcnMgbm90IGNvbXBhdGlibGUgWE1MSHR0cFJlcXVlc3QgTGV2ZWwgMi5cblx0ICAgICAgICAvLyBCdXQsIHRoaXMgY2FuIGJlIHN1cHByZXNzZWQgZm9yICdqc29uJyB0eXBlIGFzIGl0IGNhbiBiZSBwYXJzZWQgYnkgZGVmYXVsdCAndHJhbnNmb3JtUmVzcG9uc2UnIGZ1bmN0aW9uLlxuXHQgICAgICAgIGlmIChjb25maWcucmVzcG9uc2VUeXBlICE9PSAnanNvbicpIHtcblx0ICAgICAgICAgIHRocm93IGU7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdFxuXHQgICAgLy8gSGFuZGxlIHByb2dyZXNzIGlmIG5lZWRlZFxuXHQgICAgaWYgKHR5cGVvZiBjb25maWcub25Eb3dubG9hZFByb2dyZXNzID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBjb25maWcub25Eb3dubG9hZFByb2dyZXNzKTtcblx0ICAgIH1cblx0XG5cdCAgICAvLyBOb3QgYWxsIGJyb3dzZXJzIHN1cHBvcnQgdXBsb2FkIGV2ZW50c1xuXHQgICAgaWYgKHR5cGVvZiBjb25maWcub25VcGxvYWRQcm9ncmVzcyA9PT0gJ2Z1bmN0aW9uJyAmJiByZXF1ZXN0LnVwbG9hZCkge1xuXHQgICAgICByZXF1ZXN0LnVwbG9hZC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGNvbmZpZy5vblVwbG9hZFByb2dyZXNzKTtcblx0ICAgIH1cblx0XG5cdCAgICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG5cdCAgICAgIC8vIEhhbmRsZSBjYW5jZWxsYXRpb25cblx0ICAgICAgY29uZmlnLmNhbmNlbFRva2VuLnByb21pc2UudGhlbihmdW5jdGlvbiBvbkNhbmNlbGVkKGNhbmNlbCkge1xuXHQgICAgICAgIGlmICghcmVxdWVzdCkge1xuXHQgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgcmVxdWVzdC5hYm9ydCgpO1xuXHQgICAgICAgIHJlamVjdChjYW5jZWwpO1xuXHQgICAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3Rcblx0ICAgICAgICByZXF1ZXN0ID0gbnVsbDtcblx0ICAgICAgfSk7XG5cdCAgICB9XG5cdFxuXHQgICAgaWYgKHJlcXVlc3REYXRhID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgcmVxdWVzdERhdGEgPSBudWxsO1xuXHQgICAgfVxuXHRcblx0ICAgIC8vIFNlbmQgdGhlIHJlcXVlc3Rcblx0ICAgIHJlcXVlc3Quc2VuZChyZXF1ZXN0RGF0YSk7XG5cdCAgfSk7XG5cdH07XG5cblxuLyoqKi8gfSksXG4vKiA5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0dmFyIGNyZWF0ZUVycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG5cdFxuXHQvKipcblx0ICogUmVzb2x2ZSBvciByZWplY3QgYSBQcm9taXNlIGJhc2VkIG9uIHJlc3BvbnNlIHN0YXR1cy5cblx0ICpcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gcmVzb2x2ZSBBIGZ1bmN0aW9uIHRoYXQgcmVzb2x2ZXMgdGhlIHByb21pc2UuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdCBBIGZ1bmN0aW9uIHRoYXQgcmVqZWN0cyB0aGUgcHJvbWlzZS5cblx0ICogQHBhcmFtIHtvYmplY3R9IHJlc3BvbnNlIFRoZSByZXNwb25zZS5cblx0ICovXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgcmVzcG9uc2UpIHtcblx0ICB2YXIgdmFsaWRhdGVTdGF0dXMgPSByZXNwb25zZS5jb25maWcudmFsaWRhdGVTdGF0dXM7XG5cdCAgLy8gTm90ZTogc3RhdHVzIGlzIG5vdCBleHBvc2VkIGJ5IFhEb21haW5SZXF1ZXN0XG5cdCAgaWYgKCFyZXNwb25zZS5zdGF0dXMgfHwgIXZhbGlkYXRlU3RhdHVzIHx8IHZhbGlkYXRlU3RhdHVzKHJlc3BvbnNlLnN0YXR1cykpIHtcblx0ICAgIHJlc29sdmUocmVzcG9uc2UpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICByZWplY3QoY3JlYXRlRXJyb3IoXG5cdCAgICAgICdSZXF1ZXN0IGZhaWxlZCB3aXRoIHN0YXR1cyBjb2RlICcgKyByZXNwb25zZS5zdGF0dXMsXG5cdCAgICAgIHJlc3BvbnNlLmNvbmZpZyxcblx0ICAgICAgbnVsbCxcblx0ICAgICAgcmVzcG9uc2UucmVxdWVzdCxcblx0ICAgICAgcmVzcG9uc2Vcblx0ICAgICkpO1xuXHQgIH1cblx0fTtcblxuXG4vKioqLyB9KSxcbi8qIDEwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0dmFyIGVuaGFuY2VFcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXHRcblx0LyoqXG5cdCAqIENyZWF0ZSBhbiBFcnJvciB3aXRoIHRoZSBzcGVjaWZpZWQgbWVzc2FnZSwgY29uZmlnLCBlcnJvciBjb2RlLCByZXF1ZXN0IGFuZCByZXNwb25zZS5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgVGhlIGVycm9yIG1lc3NhZ2UuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZy5cblx0ICogQHBhcmFtIHtzdHJpbmd9IFtjb2RlXSBUaGUgZXJyb3IgY29kZSAoZm9yIGV4YW1wbGUsICdFQ09OTkFCT1JURUQnKS5cblx0ICogQHBhcmFtIHtPYmplY3R9IFtyZXF1ZXN0XSBUaGUgcmVxdWVzdC5cblx0ICogQHBhcmFtIHtPYmplY3R9IFtyZXNwb25zZV0gVGhlIHJlc3BvbnNlLlxuXHQgKiBAcmV0dXJucyB7RXJyb3J9IFRoZSBjcmVhdGVkIGVycm9yLlxuXHQgKi9cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVFcnJvcihtZXNzYWdlLCBjb25maWcsIGNvZGUsIHJlcXVlc3QsIHJlc3BvbnNlKSB7XG5cdCAgdmFyIGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuXHQgIHJldHVybiBlbmhhbmNlRXJyb3IoZXJyb3IsIGNvbmZpZywgY29kZSwgcmVxdWVzdCwgcmVzcG9uc2UpO1xuXHR9O1xuXG5cbi8qKiovIH0pLFxuLyogMTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHQvKipcblx0ICogVXBkYXRlIGFuIEVycm9yIHdpdGggdGhlIHNwZWNpZmllZCBjb25maWcsIGVycm9yIGNvZGUsIGFuZCByZXNwb25zZS5cblx0ICpcblx0ICogQHBhcmFtIHtFcnJvcn0gZXJyb3IgVGhlIGVycm9yIHRvIHVwZGF0ZS5cblx0ICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW2NvZGVdIFRoZSBlcnJvciBjb2RlIChmb3IgZXhhbXBsZSwgJ0VDT05OQUJPUlRFRCcpLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW3JlcXVlc3RdIFRoZSByZXF1ZXN0LlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW3Jlc3BvbnNlXSBUaGUgcmVzcG9uc2UuXG5cdCAqIEByZXR1cm5zIHtFcnJvcn0gVGhlIGVycm9yLlxuXHQgKi9cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBlbmhhbmNlRXJyb3IoZXJyb3IsIGNvbmZpZywgY29kZSwgcmVxdWVzdCwgcmVzcG9uc2UpIHtcblx0ICBlcnJvci5jb25maWcgPSBjb25maWc7XG5cdCAgaWYgKGNvZGUpIHtcblx0ICAgIGVycm9yLmNvZGUgPSBjb2RlO1xuXHQgIH1cblx0ICBlcnJvci5yZXF1ZXN0ID0gcmVxdWVzdDtcblx0ICBlcnJvci5yZXNwb25zZSA9IHJlc3BvbnNlO1xuXHQgIHJldHVybiBlcnJvcjtcblx0fTtcblxuXG4vKioqLyB9KSxcbi8qIDEyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0dmFyIHV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblx0XG5cdGZ1bmN0aW9uIGVuY29kZSh2YWwpIHtcblx0ICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHZhbCkuXG5cdCAgICByZXBsYWNlKC8lNDAvZ2ksICdAJykuXG5cdCAgICByZXBsYWNlKC8lM0EvZ2ksICc6JykuXG5cdCAgICByZXBsYWNlKC8lMjQvZywgJyQnKS5cblx0ICAgIHJlcGxhY2UoLyUyQy9naSwgJywnKS5cblx0ICAgIHJlcGxhY2UoLyUyMC9nLCAnKycpLlxuXHQgICAgcmVwbGFjZSgvJTVCL2dpLCAnWycpLlxuXHQgICAgcmVwbGFjZSgvJTVEL2dpLCAnXScpO1xuXHR9XG5cdFxuXHQvKipcblx0ICogQnVpbGQgYSBVUkwgYnkgYXBwZW5kaW5nIHBhcmFtcyB0byB0aGUgZW5kXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIGJhc2Ugb2YgdGhlIHVybCAoZS5nLiwgaHR0cDovL3d3dy5nb29nbGUuY29tKVxuXHQgKiBAcGFyYW0ge29iamVjdH0gW3BhcmFtc10gVGhlIHBhcmFtcyB0byBiZSBhcHBlbmRlZFxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZm9ybWF0dGVkIHVybFxuXHQgKi9cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBidWlsZFVSTCh1cmwsIHBhcmFtcywgcGFyYW1zU2VyaWFsaXplcikge1xuXHQgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuXHQgIGlmICghcGFyYW1zKSB7XG5cdCAgICByZXR1cm4gdXJsO1xuXHQgIH1cblx0XG5cdCAgdmFyIHNlcmlhbGl6ZWRQYXJhbXM7XG5cdCAgaWYgKHBhcmFtc1NlcmlhbGl6ZXIpIHtcblx0ICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJhbXNTZXJpYWxpemVyKHBhcmFtcyk7XG5cdCAgfSBlbHNlIGlmICh1dGlscy5pc1VSTFNlYXJjaFBhcmFtcyhwYXJhbXMpKSB7XG5cdCAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFyYW1zLnRvU3RyaW5nKCk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHZhciBwYXJ0cyA9IFtdO1xuXHRcblx0ICAgIHV0aWxzLmZvckVhY2gocGFyYW1zLCBmdW5jdGlvbiBzZXJpYWxpemUodmFsLCBrZXkpIHtcblx0ICAgICAgaWYgKHZhbCA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJykge1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXHRcblx0ICAgICAgaWYgKHV0aWxzLmlzQXJyYXkodmFsKSkge1xuXHQgICAgICAgIGtleSA9IGtleSArICdbXSc7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdmFsID0gW3ZhbF07XG5cdCAgICAgIH1cblx0XG5cdCAgICAgIHV0aWxzLmZvckVhY2godmFsLCBmdW5jdGlvbiBwYXJzZVZhbHVlKHYpIHtcblx0ICAgICAgICBpZiAodXRpbHMuaXNEYXRlKHYpKSB7XG5cdCAgICAgICAgICB2ID0gdi50b0lTT1N0cmluZygpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAodXRpbHMuaXNPYmplY3QodikpIHtcblx0ICAgICAgICAgIHYgPSBKU09OLnN0cmluZ2lmeSh2KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcGFydHMucHVzaChlbmNvZGUoa2V5KSArICc9JyArIGVuY29kZSh2KSk7XG5cdCAgICAgIH0pO1xuXHQgICAgfSk7XG5cdFxuXHQgICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcnRzLmpvaW4oJyYnKTtcblx0ICB9XG5cdFxuXHQgIGlmIChzZXJpYWxpemVkUGFyYW1zKSB7XG5cdCAgICB1cmwgKz0gKHVybC5pbmRleE9mKCc/JykgPT09IC0xID8gJz8nIDogJyYnKSArIHNlcmlhbGl6ZWRQYXJhbXM7XG5cdCAgfVxuXHRcblx0ICByZXR1cm4gdXJsO1xuXHR9O1xuXG5cbi8qKiovIH0pLFxuLyogMTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHR2YXIgdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXHRcblx0Ly8gSGVhZGVycyB3aG9zZSBkdXBsaWNhdGVzIGFyZSBpZ25vcmVkIGJ5IG5vZGVcblx0Ly8gYy5mLiBodHRwczovL25vZGVqcy5vcmcvYXBpL2h0dHAuaHRtbCNodHRwX21lc3NhZ2VfaGVhZGVyc1xuXHR2YXIgaWdub3JlRHVwbGljYXRlT2YgPSBbXG5cdCAgJ2FnZScsICdhdXRob3JpemF0aW9uJywgJ2NvbnRlbnQtbGVuZ3RoJywgJ2NvbnRlbnQtdHlwZScsICdldGFnJyxcblx0ICAnZXhwaXJlcycsICdmcm9tJywgJ2hvc3QnLCAnaWYtbW9kaWZpZWQtc2luY2UnLCAnaWYtdW5tb2RpZmllZC1zaW5jZScsXG5cdCAgJ2xhc3QtbW9kaWZpZWQnLCAnbG9jYXRpb24nLCAnbWF4LWZvcndhcmRzJywgJ3Byb3h5LWF1dGhvcml6YXRpb24nLFxuXHQgICdyZWZlcmVyJywgJ3JldHJ5LWFmdGVyJywgJ3VzZXItYWdlbnQnXG5cdF07XG5cdFxuXHQvKipcblx0ICogUGFyc2UgaGVhZGVycyBpbnRvIGFuIG9iamVjdFxuXHQgKlxuXHQgKiBgYGBcblx0ICogRGF0ZTogV2VkLCAyNyBBdWcgMjAxNCAwODo1ODo0OSBHTVRcblx0ICogQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9qc29uXG5cdCAqIENvbm5lY3Rpb246IGtlZXAtYWxpdmVcblx0ICogVHJhbnNmZXItRW5jb2Rpbmc6IGNodW5rZWRcblx0ICogYGBgXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBoZWFkZXJzIEhlYWRlcnMgbmVlZGluZyB0byBiZSBwYXJzZWRcblx0ICogQHJldHVybnMge09iamVjdH0gSGVhZGVycyBwYXJzZWQgaW50byBhbiBvYmplY3Rcblx0ICovXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VIZWFkZXJzKGhlYWRlcnMpIHtcblx0ICB2YXIgcGFyc2VkID0ge307XG5cdCAgdmFyIGtleTtcblx0ICB2YXIgdmFsO1xuXHQgIHZhciBpO1xuXHRcblx0ICBpZiAoIWhlYWRlcnMpIHsgcmV0dXJuIHBhcnNlZDsgfVxuXHRcblx0ICB1dGlscy5mb3JFYWNoKGhlYWRlcnMuc3BsaXQoJ1xcbicpLCBmdW5jdGlvbiBwYXJzZXIobGluZSkge1xuXHQgICAgaSA9IGxpbmUuaW5kZXhPZignOicpO1xuXHQgICAga2V5ID0gdXRpbHMudHJpbShsaW5lLnN1YnN0cigwLCBpKSkudG9Mb3dlckNhc2UoKTtcblx0ICAgIHZhbCA9IHV0aWxzLnRyaW0obGluZS5zdWJzdHIoaSArIDEpKTtcblx0XG5cdCAgICBpZiAoa2V5KSB7XG5cdCAgICAgIGlmIChwYXJzZWRba2V5XSAmJiBpZ25vcmVEdXBsaWNhdGVPZi5pbmRleE9mKGtleSkgPj0gMCkge1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXHQgICAgICBpZiAoa2V5ID09PSAnc2V0LWNvb2tpZScpIHtcblx0ICAgICAgICBwYXJzZWRba2V5XSA9IChwYXJzZWRba2V5XSA/IHBhcnNlZFtrZXldIDogW10pLmNvbmNhdChbdmFsXSk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgcGFyc2VkW2tleV0gPSBwYXJzZWRba2V5XSA/IHBhcnNlZFtrZXldICsgJywgJyArIHZhbCA6IHZhbDtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0pO1xuXHRcblx0ICByZXR1cm4gcGFyc2VkO1xuXHR9O1xuXG5cbi8qKiovIH0pLFxuLyogMTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHR2YXIgdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSAoXG5cdCAgdXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSA/XG5cdFxuXHQgIC8vIFN0YW5kYXJkIGJyb3dzZXIgZW52cyBoYXZlIGZ1bGwgc3VwcG9ydCBvZiB0aGUgQVBJcyBuZWVkZWQgdG8gdGVzdFxuXHQgIC8vIHdoZXRoZXIgdGhlIHJlcXVlc3QgVVJMIGlzIG9mIHRoZSBzYW1lIG9yaWdpbiBhcyBjdXJyZW50IGxvY2F0aW9uLlxuXHQgIChmdW5jdGlvbiBzdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG5cdCAgICB2YXIgbXNpZSA9IC8obXNpZXx0cmlkZW50KS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cdCAgICB2YXIgdXJsUGFyc2luZ05vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG5cdCAgICB2YXIgb3JpZ2luVVJMO1xuXHRcblx0ICAgIC8qKlxuXHQgICAgKiBQYXJzZSBhIFVSTCB0byBkaXNjb3ZlciBpdCdzIGNvbXBvbmVudHNcblx0ICAgICpcblx0ICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCBUaGUgVVJMIHRvIGJlIHBhcnNlZFxuXHQgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuXHQgICAgKi9cblx0ICAgIGZ1bmN0aW9uIHJlc29sdmVVUkwodXJsKSB7XG5cdCAgICAgIHZhciBocmVmID0gdXJsO1xuXHRcblx0ICAgICAgaWYgKG1zaWUpIHtcblx0ICAgICAgICAvLyBJRSBuZWVkcyBhdHRyaWJ1dGUgc2V0IHR3aWNlIHRvIG5vcm1hbGl6ZSBwcm9wZXJ0aWVzXG5cdCAgICAgICAgdXJsUGFyc2luZ05vZGUuc2V0QXR0cmlidXRlKCdocmVmJywgaHJlZik7XG5cdCAgICAgICAgaHJlZiA9IHVybFBhcnNpbmdOb2RlLmhyZWY7XG5cdCAgICAgIH1cblx0XG5cdCAgICAgIHVybFBhcnNpbmdOb2RlLnNldEF0dHJpYnV0ZSgnaHJlZicsIGhyZWYpO1xuXHRcblx0ICAgICAgLy8gdXJsUGFyc2luZ05vZGUgcHJvdmlkZXMgdGhlIFVybFV0aWxzIGludGVyZmFjZSAtIGh0dHA6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN1cmx1dGlsc1xuXHQgICAgICByZXR1cm4ge1xuXHQgICAgICAgIGhyZWY6IHVybFBhcnNpbmdOb2RlLmhyZWYsXG5cdCAgICAgICAgcHJvdG9jb2w6IHVybFBhcnNpbmdOb2RlLnByb3RvY29sID8gdXJsUGFyc2luZ05vZGUucHJvdG9jb2wucmVwbGFjZSgvOiQvLCAnJykgOiAnJyxcblx0ICAgICAgICBob3N0OiB1cmxQYXJzaW5nTm9kZS5ob3N0LFxuXHQgICAgICAgIHNlYXJjaDogdXJsUGFyc2luZ05vZGUuc2VhcmNoID8gdXJsUGFyc2luZ05vZGUuc2VhcmNoLnJlcGxhY2UoL15cXD8vLCAnJykgOiAnJyxcblx0ICAgICAgICBoYXNoOiB1cmxQYXJzaW5nTm9kZS5oYXNoID8gdXJsUGFyc2luZ05vZGUuaGFzaC5yZXBsYWNlKC9eIy8sICcnKSA6ICcnLFxuXHQgICAgICAgIGhvc3RuYW1lOiB1cmxQYXJzaW5nTm9kZS5ob3N0bmFtZSxcblx0ICAgICAgICBwb3J0OiB1cmxQYXJzaW5nTm9kZS5wb3J0LFxuXHQgICAgICAgIHBhdGhuYW1lOiAodXJsUGFyc2luZ05vZGUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpID9cblx0ICAgICAgICAgICAgICAgICAgdXJsUGFyc2luZ05vZGUucGF0aG5hbWUgOlxuXHQgICAgICAgICAgICAgICAgICAnLycgKyB1cmxQYXJzaW5nTm9kZS5wYXRobmFtZVxuXHQgICAgICB9O1xuXHQgICAgfVxuXHRcblx0ICAgIG9yaWdpblVSTCA9IHJlc29sdmVVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuXHRcblx0ICAgIC8qKlxuXHQgICAgKiBEZXRlcm1pbmUgaWYgYSBVUkwgc2hhcmVzIHRoZSBzYW1lIG9yaWdpbiBhcyB0aGUgY3VycmVudCBsb2NhdGlvblxuXHQgICAgKlxuXHQgICAgKiBAcGFyYW0ge1N0cmluZ30gcmVxdWVzdFVSTCBUaGUgVVJMIHRvIHRlc3Rcblx0ICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgVVJMIHNoYXJlcyB0aGUgc2FtZSBvcmlnaW4sIG90aGVyd2lzZSBmYWxzZVxuXHQgICAgKi9cblx0ICAgIHJldHVybiBmdW5jdGlvbiBpc1VSTFNhbWVPcmlnaW4ocmVxdWVzdFVSTCkge1xuXHQgICAgICB2YXIgcGFyc2VkID0gKHV0aWxzLmlzU3RyaW5nKHJlcXVlc3RVUkwpKSA/IHJlc29sdmVVUkwocmVxdWVzdFVSTCkgOiByZXF1ZXN0VVJMO1xuXHQgICAgICByZXR1cm4gKHBhcnNlZC5wcm90b2NvbCA9PT0gb3JpZ2luVVJMLnByb3RvY29sICYmXG5cdCAgICAgICAgICAgIHBhcnNlZC5ob3N0ID09PSBvcmlnaW5VUkwuaG9zdCk7XG5cdCAgICB9O1xuXHQgIH0pKCkgOlxuXHRcblx0ICAvLyBOb24gc3RhbmRhcmQgYnJvd3NlciBlbnZzICh3ZWIgd29ya2VycywgcmVhY3QtbmF0aXZlKSBsYWNrIG5lZWRlZCBzdXBwb3J0LlxuXHQgIChmdW5jdGlvbiBub25TdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG5cdCAgICByZXR1cm4gZnVuY3Rpb24gaXNVUkxTYW1lT3JpZ2luKCkge1xuXHQgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH07XG5cdCAgfSkoKVxuXHQpO1xuXG5cbi8qKiovIH0pLFxuLyogMTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHQvLyBidG9hIHBvbHlmaWxsIGZvciBJRTwxMCBjb3VydGVzeSBodHRwczovL2dpdGh1Yi5jb20vZGF2aWRjaGFtYmVycy9CYXNlNjQuanNcblx0XG5cdHZhciBjaGFycyA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSc7XG5cdFxuXHRmdW5jdGlvbiBFKCkge1xuXHQgIHRoaXMubWVzc2FnZSA9ICdTdHJpbmcgY29udGFpbnMgYW4gaW52YWxpZCBjaGFyYWN0ZXInO1xuXHR9XG5cdEUucHJvdG90eXBlID0gbmV3IEVycm9yO1xuXHRFLnByb3RvdHlwZS5jb2RlID0gNTtcblx0RS5wcm90b3R5cGUubmFtZSA9ICdJbnZhbGlkQ2hhcmFjdGVyRXJyb3InO1xuXHRcblx0ZnVuY3Rpb24gYnRvYShpbnB1dCkge1xuXHQgIHZhciBzdHIgPSBTdHJpbmcoaW5wdXQpO1xuXHQgIHZhciBvdXRwdXQgPSAnJztcblx0ICBmb3IgKFxuXHQgICAgLy8gaW5pdGlhbGl6ZSByZXN1bHQgYW5kIGNvdW50ZXJcblx0ICAgIHZhciBibG9jaywgY2hhckNvZGUsIGlkeCA9IDAsIG1hcCA9IGNoYXJzO1xuXHQgICAgLy8gaWYgdGhlIG5leHQgc3RyIGluZGV4IGRvZXMgbm90IGV4aXN0OlxuXHQgICAgLy8gICBjaGFuZ2UgdGhlIG1hcHBpbmcgdGFibGUgdG8gXCI9XCJcblx0ICAgIC8vICAgY2hlY2sgaWYgZCBoYXMgbm8gZnJhY3Rpb25hbCBkaWdpdHNcblx0ICAgIHN0ci5jaGFyQXQoaWR4IHwgMCkgfHwgKG1hcCA9ICc9JywgaWR4ICUgMSk7XG5cdCAgICAvLyBcIjggLSBpZHggJSAxICogOFwiIGdlbmVyYXRlcyB0aGUgc2VxdWVuY2UgMiwgNCwgNiwgOFxuXHQgICAgb3V0cHV0ICs9IG1hcC5jaGFyQXQoNjMgJiBibG9jayA+PiA4IC0gaWR4ICUgMSAqIDgpXG5cdCAgKSB7XG5cdCAgICBjaGFyQ29kZSA9IHN0ci5jaGFyQ29kZUF0KGlkeCArPSAzIC8gNCk7XG5cdCAgICBpZiAoY2hhckNvZGUgPiAweEZGKSB7XG5cdCAgICAgIHRocm93IG5ldyBFKCk7XG5cdCAgICB9XG5cdCAgICBibG9jayA9IGJsb2NrIDw8IDggfCBjaGFyQ29kZTtcblx0ICB9XG5cdCAgcmV0dXJuIG91dHB1dDtcblx0fVxuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSBidG9hO1xuXG5cbi8qKiovIH0pLFxuLyogMTYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHR2YXIgdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSAoXG5cdCAgdXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSA/XG5cdFxuXHQgIC8vIFN0YW5kYXJkIGJyb3dzZXIgZW52cyBzdXBwb3J0IGRvY3VtZW50LmNvb2tpZVxuXHQgIChmdW5jdGlvbiBzdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG5cdCAgICByZXR1cm4ge1xuXHQgICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUobmFtZSwgdmFsdWUsIGV4cGlyZXMsIHBhdGgsIGRvbWFpbiwgc2VjdXJlKSB7XG5cdCAgICAgICAgdmFyIGNvb2tpZSA9IFtdO1xuXHQgICAgICAgIGNvb2tpZS5wdXNoKG5hbWUgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpKTtcblx0XG5cdCAgICAgICAgaWYgKHV0aWxzLmlzTnVtYmVyKGV4cGlyZXMpKSB7XG5cdCAgICAgICAgICBjb29raWUucHVzaCgnZXhwaXJlcz0nICsgbmV3IERhdGUoZXhwaXJlcykudG9HTVRTdHJpbmcoKSk7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICBpZiAodXRpbHMuaXNTdHJpbmcocGF0aCkpIHtcblx0ICAgICAgICAgIGNvb2tpZS5wdXNoKCdwYXRoPScgKyBwYXRoKTtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIGlmICh1dGlscy5pc1N0cmluZyhkb21haW4pKSB7XG5cdCAgICAgICAgICBjb29raWUucHVzaCgnZG9tYWluPScgKyBkb21haW4pO1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgaWYgKHNlY3VyZSA9PT0gdHJ1ZSkge1xuXHQgICAgICAgICAgY29va2llLnB1c2goJ3NlY3VyZScpO1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgZG9jdW1lbnQuY29va2llID0gY29va2llLmpvaW4oJzsgJyk7XG5cdCAgICAgIH0sXG5cdFxuXHQgICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG5hbWUpIHtcblx0ICAgICAgICB2YXIgbWF0Y2ggPSBkb2N1bWVudC5jb29raWUubWF0Y2gobmV3IFJlZ0V4cCgnKF58O1xcXFxzKikoJyArIG5hbWUgKyAnKT0oW147XSopJykpO1xuXHQgICAgICAgIHJldHVybiAobWF0Y2ggPyBkZWNvZGVVUklDb21wb25lbnQobWF0Y2hbM10pIDogbnVsbCk7XG5cdCAgICAgIH0sXG5cdFxuXHQgICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShuYW1lKSB7XG5cdCAgICAgICAgdGhpcy53cml0ZShuYW1lLCAnJywgRGF0ZS5ub3coKSAtIDg2NDAwMDAwKTtcblx0ICAgICAgfVxuXHQgICAgfTtcblx0ICB9KSgpIDpcblx0XG5cdCAgLy8gTm9uIHN0YW5kYXJkIGJyb3dzZXIgZW52ICh3ZWIgd29ya2VycywgcmVhY3QtbmF0aXZlKSBsYWNrIG5lZWRlZCBzdXBwb3J0LlxuXHQgIChmdW5jdGlvbiBub25TdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG5cdCAgICByZXR1cm4ge1xuXHQgICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUoKSB7fSxcblx0ICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZCgpIHsgcmV0dXJuIG51bGw7IH0sXG5cdCAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge31cblx0ICAgIH07XG5cdCAgfSkoKVxuXHQpO1xuXG5cbi8qKiovIH0pLFxuLyogMTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHR2YXIgdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXHRcblx0ZnVuY3Rpb24gSW50ZXJjZXB0b3JNYW5hZ2VyKCkge1xuXHQgIHRoaXMuaGFuZGxlcnMgPSBbXTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIEFkZCBhIG5ldyBpbnRlcmNlcHRvciB0byB0aGUgc3RhY2tcblx0ICpcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZnVsZmlsbGVkIFRoZSBmdW5jdGlvbiB0byBoYW5kbGUgYHRoZW5gIGZvciBhIGBQcm9taXNlYFxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3RlZCBUaGUgZnVuY3Rpb24gdG8gaGFuZGxlIGByZWplY3RgIGZvciBhIGBQcm9taXNlYFxuXHQgKlxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IEFuIElEIHVzZWQgdG8gcmVtb3ZlIGludGVyY2VwdG9yIGxhdGVyXG5cdCAqL1xuXHRJbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLnVzZSA9IGZ1bmN0aW9uIHVzZShmdWxmaWxsZWQsIHJlamVjdGVkKSB7XG5cdCAgdGhpcy5oYW5kbGVycy5wdXNoKHtcblx0ICAgIGZ1bGZpbGxlZDogZnVsZmlsbGVkLFxuXHQgICAgcmVqZWN0ZWQ6IHJlamVjdGVkXG5cdCAgfSk7XG5cdCAgcmV0dXJuIHRoaXMuaGFuZGxlcnMubGVuZ3RoIC0gMTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBSZW1vdmUgYW4gaW50ZXJjZXB0b3IgZnJvbSB0aGUgc3RhY2tcblx0ICpcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGlkIFRoZSBJRCB0aGF0IHdhcyByZXR1cm5lZCBieSBgdXNlYFxuXHQgKi9cblx0SW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS5lamVjdCA9IGZ1bmN0aW9uIGVqZWN0KGlkKSB7XG5cdCAgaWYgKHRoaXMuaGFuZGxlcnNbaWRdKSB7XG5cdCAgICB0aGlzLmhhbmRsZXJzW2lkXSA9IG51bGw7XG5cdCAgfVxuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEl0ZXJhdGUgb3ZlciBhbGwgdGhlIHJlZ2lzdGVyZWQgaW50ZXJjZXB0b3JzXG5cdCAqXG5cdCAqIFRoaXMgbWV0aG9kIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgZm9yIHNraXBwaW5nIG92ZXIgYW55XG5cdCAqIGludGVyY2VwdG9ycyB0aGF0IG1heSBoYXZlIGJlY29tZSBgbnVsbGAgY2FsbGluZyBgZWplY3RgLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCBpbnRlcmNlcHRvclxuXHQgKi9cblx0SW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gZm9yRWFjaChmbikge1xuXHQgIHV0aWxzLmZvckVhY2godGhpcy5oYW5kbGVycywgZnVuY3Rpb24gZm9yRWFjaEhhbmRsZXIoaCkge1xuXHQgICAgaWYgKGggIT09IG51bGwpIHtcblx0ICAgICAgZm4oaCk7XG5cdCAgICB9XG5cdCAgfSk7XG5cdH07XG5cdFxuXHRtb2R1bGUuZXhwb3J0cyA9IEludGVyY2VwdG9yTWFuYWdlcjtcblxuXG4vKioqLyB9KSxcbi8qIDE4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0dmFyIHV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblx0dmFyIHRyYW5zZm9ybURhdGEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcblx0dmFyIGlzQ2FuY2VsID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG5cdHZhciBkZWZhdWx0cyA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cdHZhciBpc0Fic29sdXRlVVJMID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSk7XG5cdHZhciBjb21iaW5lVVJMcyA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpO1xuXHRcblx0LyoqXG5cdCAqIFRocm93cyBhIGBDYW5jZWxgIGlmIGNhbmNlbGxhdGlvbiBoYXMgYmVlbiByZXF1ZXN0ZWQuXG5cdCAqL1xuXHRmdW5jdGlvbiB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZykge1xuXHQgIGlmIChjb25maWcuY2FuY2VsVG9rZW4pIHtcblx0ICAgIGNvbmZpZy5jYW5jZWxUb2tlbi50aHJvd0lmUmVxdWVzdGVkKCk7XG5cdCAgfVxuXHR9XG5cdFxuXHQvKipcblx0ICogRGlzcGF0Y2ggYSByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXIgdXNpbmcgdGhlIGNvbmZpZ3VyZWQgYWRhcHRlci5cblx0ICpcblx0ICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHRoYXQgaXMgdG8gYmUgdXNlZCBmb3IgdGhlIHJlcXVlc3Rcblx0ICogQHJldHVybnMge1Byb21pc2V9IFRoZSBQcm9taXNlIHRvIGJlIGZ1bGZpbGxlZFxuXHQgKi9cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkaXNwYXRjaFJlcXVlc3QoY29uZmlnKSB7XG5cdCAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXHRcblx0ICAvLyBTdXBwb3J0IGJhc2VVUkwgY29uZmlnXG5cdCAgaWYgKGNvbmZpZy5iYXNlVVJMICYmICFpc0Fic29sdXRlVVJMKGNvbmZpZy51cmwpKSB7XG5cdCAgICBjb25maWcudXJsID0gY29tYmluZVVSTHMoY29uZmlnLmJhc2VVUkwsIGNvbmZpZy51cmwpO1xuXHQgIH1cblx0XG5cdCAgLy8gRW5zdXJlIGhlYWRlcnMgZXhpc3Rcblx0ICBjb25maWcuaGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzIHx8IHt9O1xuXHRcblx0ICAvLyBUcmFuc2Zvcm0gcmVxdWVzdCBkYXRhXG5cdCAgY29uZmlnLmRhdGEgPSB0cmFuc2Zvcm1EYXRhKFxuXHQgICAgY29uZmlnLmRhdGEsXG5cdCAgICBjb25maWcuaGVhZGVycyxcblx0ICAgIGNvbmZpZy50cmFuc2Zvcm1SZXF1ZXN0XG5cdCAgKTtcblx0XG5cdCAgLy8gRmxhdHRlbiBoZWFkZXJzXG5cdCAgY29uZmlnLmhlYWRlcnMgPSB1dGlscy5tZXJnZShcblx0ICAgIGNvbmZpZy5oZWFkZXJzLmNvbW1vbiB8fCB7fSxcblx0ICAgIGNvbmZpZy5oZWFkZXJzW2NvbmZpZy5tZXRob2RdIHx8IHt9LFxuXHQgICAgY29uZmlnLmhlYWRlcnMgfHwge31cblx0ICApO1xuXHRcblx0ICB1dGlscy5mb3JFYWNoKFxuXHQgICAgWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAncG9zdCcsICdwdXQnLCAncGF0Y2gnLCAnY29tbW9uJ10sXG5cdCAgICBmdW5jdGlvbiBjbGVhbkhlYWRlckNvbmZpZyhtZXRob2QpIHtcblx0ICAgICAgZGVsZXRlIGNvbmZpZy5oZWFkZXJzW21ldGhvZF07XG5cdCAgICB9XG5cdCAgKTtcblx0XG5cdCAgdmFyIGFkYXB0ZXIgPSBjb25maWcuYWRhcHRlciB8fCBkZWZhdWx0cy5hZGFwdGVyO1xuXHRcblx0ICByZXR1cm4gYWRhcHRlcihjb25maWcpLnRoZW4oZnVuY3Rpb24gb25BZGFwdGVyUmVzb2x1dGlvbihyZXNwb25zZSkge1xuXHQgICAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXHRcblx0ICAgIC8vIFRyYW5zZm9ybSByZXNwb25zZSBkYXRhXG5cdCAgICByZXNwb25zZS5kYXRhID0gdHJhbnNmb3JtRGF0YShcblx0ICAgICAgcmVzcG9uc2UuZGF0YSxcblx0ICAgICAgcmVzcG9uc2UuaGVhZGVycyxcblx0ICAgICAgY29uZmlnLnRyYW5zZm9ybVJlc3BvbnNlXG5cdCAgICApO1xuXHRcblx0ICAgIHJldHVybiByZXNwb25zZTtcblx0ICB9LCBmdW5jdGlvbiBvbkFkYXB0ZXJSZWplY3Rpb24ocmVhc29uKSB7XG5cdCAgICBpZiAoIWlzQ2FuY2VsKHJlYXNvbikpIHtcblx0ICAgICAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXHRcblx0ICAgICAgLy8gVHJhbnNmb3JtIHJlc3BvbnNlIGRhdGFcblx0ICAgICAgaWYgKHJlYXNvbiAmJiByZWFzb24ucmVzcG9uc2UpIHtcblx0ICAgICAgICByZWFzb24ucmVzcG9uc2UuZGF0YSA9IHRyYW5zZm9ybURhdGEoXG5cdCAgICAgICAgICByZWFzb24ucmVzcG9uc2UuZGF0YSxcblx0ICAgICAgICAgIHJlYXNvbi5yZXNwb25zZS5oZWFkZXJzLFxuXHQgICAgICAgICAgY29uZmlnLnRyYW5zZm9ybVJlc3BvbnNlXG5cdCAgICAgICAgKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHRcblx0ICAgIHJldHVybiBQcm9taXNlLnJlamVjdChyZWFzb24pO1xuXHQgIH0pO1xuXHR9O1xuXG5cbi8qKiovIH0pLFxuLyogMTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHR2YXIgdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXHRcblx0LyoqXG5cdCAqIFRyYW5zZm9ybSB0aGUgZGF0YSBmb3IgYSByZXF1ZXN0IG9yIGEgcmVzcG9uc2Vcblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBkYXRhIFRoZSBkYXRhIHRvIGJlIHRyYW5zZm9ybWVkXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGhlYWRlcnMgVGhlIGhlYWRlcnMgZm9yIHRoZSByZXF1ZXN0IG9yIHJlc3BvbnNlXG5cdCAqIEBwYXJhbSB7QXJyYXl8RnVuY3Rpb259IGZucyBBIHNpbmdsZSBmdW5jdGlvbiBvciBBcnJheSBvZiBmdW5jdGlvbnNcblx0ICogQHJldHVybnMgeyp9IFRoZSByZXN1bHRpbmcgdHJhbnNmb3JtZWQgZGF0YVxuXHQgKi9cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0cmFuc2Zvcm1EYXRhKGRhdGEsIGhlYWRlcnMsIGZucykge1xuXHQgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuXHQgIHV0aWxzLmZvckVhY2goZm5zLCBmdW5jdGlvbiB0cmFuc2Zvcm0oZm4pIHtcblx0ICAgIGRhdGEgPSBmbihkYXRhLCBoZWFkZXJzKTtcblx0ICB9KTtcblx0XG5cdCAgcmV0dXJuIGRhdGE7XG5cdH07XG5cblxuLyoqKi8gfSksXG4vKiAyMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNDYW5jZWwodmFsdWUpIHtcblx0ICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX19DQU5DRUxfXyk7XG5cdH07XG5cblxuLyoqKi8gfSksXG4vKiAyMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBVUkwgaXMgYWJzb2x1dGVcblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgVVJMIHRvIHRlc3Rcblx0ICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHNwZWNpZmllZCBVUkwgaXMgYWJzb2x1dGUsIG90aGVyd2lzZSBmYWxzZVxuXHQgKi9cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0Fic29sdXRlVVJMKHVybCkge1xuXHQgIC8vIEEgVVJMIGlzIGNvbnNpZGVyZWQgYWJzb2x1dGUgaWYgaXQgYmVnaW5zIHdpdGggXCI8c2NoZW1lPjovL1wiIG9yIFwiLy9cIiAocHJvdG9jb2wtcmVsYXRpdmUgVVJMKS5cblx0ICAvLyBSRkMgMzk4NiBkZWZpbmVzIHNjaGVtZSBuYW1lIGFzIGEgc2VxdWVuY2Ugb2YgY2hhcmFjdGVycyBiZWdpbm5pbmcgd2l0aCBhIGxldHRlciBhbmQgZm9sbG93ZWRcblx0ICAvLyBieSBhbnkgY29tYmluYXRpb24gb2YgbGV0dGVycywgZGlnaXRzLCBwbHVzLCBwZXJpb2QsIG9yIGh5cGhlbi5cblx0ICByZXR1cm4gL14oW2Etel1bYS16XFxkXFwrXFwtXFwuXSo6KT9cXC9cXC8vaS50ZXN0KHVybCk7XG5cdH07XG5cblxuLyoqKi8gfSksXG4vKiAyMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgbmV3IFVSTCBieSBjb21iaW5pbmcgdGhlIHNwZWNpZmllZCBVUkxzXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVVJMIFRoZSBiYXNlIFVSTFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gcmVsYXRpdmVVUkwgVGhlIHJlbGF0aXZlIFVSTFxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29tYmluZWQgVVJMXG5cdCAqL1xuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNvbWJpbmVVUkxzKGJhc2VVUkwsIHJlbGF0aXZlVVJMKSB7XG5cdCAgcmV0dXJuIHJlbGF0aXZlVVJMXG5cdCAgICA/IGJhc2VVUkwucmVwbGFjZSgvXFwvKyQvLCAnJykgKyAnLycgKyByZWxhdGl2ZVVSTC5yZXBsYWNlKC9eXFwvKy8sICcnKVxuXHQgICAgOiBiYXNlVVJMO1xuXHR9O1xuXG5cbi8qKiovIH0pLFxuLyogMjMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHQvKipcblx0ICogQSBgQ2FuY2VsYCBpcyBhbiBvYmplY3QgdGhhdCBpcyB0aHJvd24gd2hlbiBhbiBvcGVyYXRpb24gaXMgY2FuY2VsZWQuXG5cdCAqXG5cdCAqIEBjbGFzc1xuXHQgKiBAcGFyYW0ge3N0cmluZz19IG1lc3NhZ2UgVGhlIG1lc3NhZ2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBDYW5jZWwobWVzc2FnZSkge1xuXHQgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG5cdH1cblx0XG5cdENhbmNlbC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcblx0ICByZXR1cm4gJ0NhbmNlbCcgKyAodGhpcy5tZXNzYWdlID8gJzogJyArIHRoaXMubWVzc2FnZSA6ICcnKTtcblx0fTtcblx0XG5cdENhbmNlbC5wcm90b3R5cGUuX19DQU5DRUxfXyA9IHRydWU7XG5cdFxuXHRtb2R1bGUuZXhwb3J0cyA9IENhbmNlbDtcblxuXG4vKioqLyB9KSxcbi8qIDI0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0dmFyIENhbmNlbCA9IF9fd2VicGFja19yZXF1aXJlX18oMjMpO1xuXHRcblx0LyoqXG5cdCAqIEEgYENhbmNlbFRva2VuYCBpcyBhbiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byByZXF1ZXN0IGNhbmNlbGxhdGlvbiBvZiBhbiBvcGVyYXRpb24uXG5cdCAqXG5cdCAqIEBjbGFzc1xuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBleGVjdXRvciBUaGUgZXhlY3V0b3IgZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBDYW5jZWxUb2tlbihleGVjdXRvcikge1xuXHQgIGlmICh0eXBlb2YgZXhlY3V0b3IgIT09ICdmdW5jdGlvbicpIHtcblx0ICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4ZWN1dG9yIG11c3QgYmUgYSBmdW5jdGlvbi4nKTtcblx0ICB9XG5cdFxuXHQgIHZhciByZXNvbHZlUHJvbWlzZTtcblx0ICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiBwcm9taXNlRXhlY3V0b3IocmVzb2x2ZSkge1xuXHQgICAgcmVzb2x2ZVByb21pc2UgPSByZXNvbHZlO1xuXHQgIH0pO1xuXHRcblx0ICB2YXIgdG9rZW4gPSB0aGlzO1xuXHQgIGV4ZWN1dG9yKGZ1bmN0aW9uIGNhbmNlbChtZXNzYWdlKSB7XG5cdCAgICBpZiAodG9rZW4ucmVhc29uKSB7XG5cdCAgICAgIC8vIENhbmNlbGxhdGlvbiBoYXMgYWxyZWFkeSBiZWVuIHJlcXVlc3RlZFxuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cdFxuXHQgICAgdG9rZW4ucmVhc29uID0gbmV3IENhbmNlbChtZXNzYWdlKTtcblx0ICAgIHJlc29sdmVQcm9taXNlKHRva2VuLnJlYXNvbik7XG5cdCAgfSk7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBUaHJvd3MgYSBgQ2FuY2VsYCBpZiBjYW5jZWxsYXRpb24gaGFzIGJlZW4gcmVxdWVzdGVkLlxuXHQgKi9cblx0Q2FuY2VsVG9rZW4ucHJvdG90eXBlLnRocm93SWZSZXF1ZXN0ZWQgPSBmdW5jdGlvbiB0aHJvd0lmUmVxdWVzdGVkKCkge1xuXHQgIGlmICh0aGlzLnJlYXNvbikge1xuXHQgICAgdGhyb3cgdGhpcy5yZWFzb247XG5cdCAgfVxuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgYSBuZXcgYENhbmNlbFRva2VuYCBhbmQgYSBmdW5jdGlvbiB0aGF0LCB3aGVuIGNhbGxlZCxcblx0ICogY2FuY2VscyB0aGUgYENhbmNlbFRva2VuYC5cblx0ICovXG5cdENhbmNlbFRva2VuLnNvdXJjZSA9IGZ1bmN0aW9uIHNvdXJjZSgpIHtcblx0ICB2YXIgY2FuY2VsO1xuXHQgIHZhciB0b2tlbiA9IG5ldyBDYW5jZWxUb2tlbihmdW5jdGlvbiBleGVjdXRvcihjKSB7XG5cdCAgICBjYW5jZWwgPSBjO1xuXHQgIH0pO1xuXHQgIHJldHVybiB7XG5cdCAgICB0b2tlbjogdG9rZW4sXG5cdCAgICBjYW5jZWw6IGNhbmNlbFxuXHQgIH07XG5cdH07XG5cdFxuXHRtb2R1bGUuZXhwb3J0cyA9IENhbmNlbFRva2VuO1xuXG5cbi8qKiovIH0pLFxuLyogMjUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHQvKipcblx0ICogU3ludGFjdGljIHN1Z2FyIGZvciBpbnZva2luZyBhIGZ1bmN0aW9uIGFuZCBleHBhbmRpbmcgYW4gYXJyYXkgZm9yIGFyZ3VtZW50cy5cblx0ICpcblx0ICogQ29tbW9uIHVzZSBjYXNlIHdvdWxkIGJlIHRvIHVzZSBgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5YC5cblx0ICpcblx0ICogIGBgYGpzXG5cdCAqICBmdW5jdGlvbiBmKHgsIHksIHopIHt9XG5cdCAqICB2YXIgYXJncyA9IFsxLCAyLCAzXTtcblx0ICogIGYuYXBwbHkobnVsbCwgYXJncyk7XG5cdCAqICBgYGBcblx0ICpcblx0ICogV2l0aCBgc3ByZWFkYCB0aGlzIGV4YW1wbGUgY2FuIGJlIHJlLXdyaXR0ZW4uXG5cdCAqXG5cdCAqICBgYGBqc1xuXHQgKiAgc3ByZWFkKGZ1bmN0aW9uKHgsIHksIHopIHt9KShbMSwgMiwgM10pO1xuXHQgKiAgYGBgXG5cdCAqXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG5cdCAqIEByZXR1cm5zIHtGdW5jdGlvbn1cblx0ICovXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3ByZWFkKGNhbGxiYWNrKSB7XG5cdCAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoYXJyKSB7XG5cdCAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkobnVsbCwgYXJyKTtcblx0ICB9O1xuXHR9O1xuXG5cbi8qKiovIH0pXG4vKioqKioqLyBdKVxufSk7XG47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1heGlvcy5tYXAiLCJpbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MvZGlzdC9heGlvcyc7XG5pbXBvcnQgbW9tZW50IGZyb20gJ21vbWVudCc7XG5pbXBvcnQgeyBiaW5kIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IGVhY2ggfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgZXh0ZW5kIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IGlzT2JqZWN0IH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IGNhbWVsQ2FzZSB9IGZyb20gJ2xvZGFzaCc7XG5cbmNvbnN0IFBST1hZX0NPTkZJR19QUk9QRVJUSUVTID0gWydoZWFkZXJzJywgJ3BhcmFtcycsICdkYXRhJ107XG5cbmNvbnN0IFBST1hZX0NPTkZJR19NRVRIT0RTID0ge1xuICAgIGdldChwcm9wLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gY29udGV4dFtwcm9wXTtcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHNldChwcm9wLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIGNvbnRleHRbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGFkZChwcm9wLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgY29udGV4dFtwcm9wXVtrZXldID0gdmFsdWU7XG4gICAgICAgIH07XG4gICAgfSxcbiAgICByZW1vdmUocHJvcCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gKGtleSkgPT4ge1xuICAgICAgICAgICAgZGVsZXRlIGNvbnRleHRbcHJvcF1ba2V5XTtcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIG1lcmdlKHByb3AsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIChrZXksIHZhbHVlcykgPT4ge1xuICAgICAgICAgICAgZXh0ZW5kKGNvbnRleHRbcHJvcF0sIGtleSk7XG4gICAgICAgIH07XG4gICAgfVxufTtcblxuY29uc3QgbWV0aG9kID0gZnVuY3Rpb24oYWN0aW9uLCBwcm9wKSB7XG4gICAgcmV0dXJuIGNhbWVsQ2FzZShbYWN0aW9uLCBwcm9wXS5qb2luKCcgJykpO1xufTtcblxuY29uc3QgY2hhaW5hYmxlID0gZnVuY3Rpb24ocHJvcCkge1xuICAgIHJldHVybiAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICBpZihrZXkgaW5zdGFuY2VvZiBGb3JtRGF0YSkge1xuICAgICAgICAgICAgdGhpc1ttZXRob2QoJ3NldCcsIHByb3ApXShrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYoaXNPYmplY3Qoa2V5KSkge1xuICAgICAgICAgICAgdGhpc1ttZXRob2QoJ21lcmdlJywgcHJvcCldKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzW21ldGhvZCgnYWRkJywgcHJvcCldKGtleSwgdmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlcXVlc3Qge1xuXG4gICAgY29uc3RydWN0b3IodXJsLCBjb25maWcgPSB7fSkge1xuICAgICAgICB0aGlzLiRjb25maWcgPSBleHRlbmQoe1xuICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICBoZWFkZXJzOiB7fSxcbiAgICAgICAgICAgIHBhcmFtczoge30sXG4gICAgICAgICAgICBkYXRhOiB7fVxuICAgICAgICB9LCBjb25maWcpO1xuXG4gICAgICAgIGVhY2goUFJPWFlfQ09ORklHX01FVEhPRFMsIChjYWxsYmFjaywga2V5KSA9PiB7XG4gICAgICAgICAgICB0aGlzW21ldGhvZChrZXksICdjb25maWcnKV0gPSBiaW5kKGNhbGxiYWNrKSgnJGNvbmZpZycsIHRoaXMpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzWydjb25maWcnXSA9IGJpbmQoY2hhaW5hYmxlLCB0aGlzKSgnY29uZmlnJyk7XG5cbiAgICAgICAgZWFjaChQUk9YWV9DT05GSUdfUFJPUEVSVElFUywgKHByb3ApID0+IHtcbiAgICAgICAgICAgIGVhY2goUFJPWFlfQ09ORklHX01FVEhPRFMsIChjYWxsYmFjaywga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpc1ttZXRob2Qoa2V5LCBwcm9wKV0gPSBiaW5kKGNhbGxiYWNrKShwcm9wLCB0aGlzLiRjb25maWcpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXNbcHJvcF0gPSBiaW5kKGNoYWluYWJsZSwgdGhpcykocHJvcCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9XG5cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy4kZXJyb3IgPSBudWxsO1xuICAgICAgICB0aGlzLiRzdGF0dXMgPSBudWxsO1xuICAgICAgICB0aGlzLiRzdGF0dXNUZXh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy4kcmVzcG9uc2UgPSBudWxsO1xuICAgICAgICB0aGlzLiRyZXF1ZXN0U2VudEF0ID0gbnVsbDtcbiAgICAgICAgdGhpcy4kcmVzcG9uc2VSZWNlaXZlZEF0ID0gbnVsbDtcbiAgICB9XG5cbiAgICBoYXNTZW50KCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLiRyZXF1ZXN0U2VudEF0O1xuICAgIH1cblxuICAgIGhhc1Jlc3BvbnNlKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLiRyZXNwb25zZVJlY2VpdmVkQXQ7XG4gICAgfVxuXG4gICAgcGFzc2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNSZXNwb25zZSgpICYmICF0aGlzLiRlcnJvcjtcbiAgICB9XG5cbiAgICBmYWlsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc1Jlc3BvbnNlKCkgJiYgISF0aGlzLiRlcnJvcjtcbiAgICB9XG5cbiAgICBnZXRVcmwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiR1cmw7XG4gICAgfVxuXG4gICAgc2V0VXJsKHVybCkge1xuICAgICAgICB0aGlzLiR1cmwgPSB1cmw7XG4gICAgfVxuXG4gICAgZ2V0KHBhcmFtcyA9IHt9LCBoZWFkZXJzID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyYW1zKHBhcmFtcykuaGVhZGVycyhoZWFkZXJzKS5yZXF1ZXN0KCdnZXQnKTtcbiAgICB9XG5cbiAgICBwb3N0KGRhdGEgPSB7fSwgaGVhZGVycyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEoZGF0YSkuaGVhZGVycyhoZWFkZXJzKS5yZXF1ZXN0KCdwb3N0Jyk7XG4gICAgfVxuXG4gICAgcHV0KGRhdGEgPSB7fSwgaGVhZGVycyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEoZGF0YSkuaGVhZGVycyhoZWFkZXJzKS5yZXF1ZXN0KCdwdXQnKTtcbiAgICB9XG5cbiAgICBkZWxldGUoaGVhZGVycyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhlYWRlcnMoaGVhZGVycykucmVxdWVzdCgnZGVsZXRlJyk7XG4gICAgfVxuXG4gICAgcmVxdWVzdChtZXRob2QpIHtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICB0aGlzLiRyZXF1ZXN0U2VudEF0ID0gbW9tZW50KCk7XG4gICAgICAgIHRoaXMuYWRkQ29uZmlnKCdtZXRob2QnLCBtZXRob2QpO1xuXG4gICAgICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBheGlvcy5yZXF1ZXN0KHRoaXMuJGNvbmZpZykudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy4kcmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB0aGlzLiRyZXNwb25zZVJlY2VpdmVkQXQgPSBtb21lbnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRzdGF0dXMgPSByZXNwb25zZS5zdGF0dXM7XG4gICAgICAgICAgICAgICAgdGhpcy4kc3RhdHVzVGV4dCA9IHJlc3BvbnNlLnN0YXR1c1RleHQ7XG5cbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3BvbnNlLmRhdGEpO1xuICAgICAgICAgICAgfSwgZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuJGVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgdGhpcy4kcmVzcG9uc2UgPSBlcnJvci5yZXNwb25zZTtcbiAgICAgICAgICAgICAgICB0aGlzLiRyZXNwb25zZVJlY2VpdmVkQXQgPSBtb21lbnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRzdGF0dXMgPSBlcnJvci5yZXNwb25zZS5zdGF0dXM7XG4gICAgICAgICAgICAgICAgdGhpcy4kc3RhdHVzVGV4dCA9IGVycm9yLnJlc3BvbnNlLnN0YXR1c1RleHQ7XG5cbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IucmVzcG9uc2UuZGF0YS5lcnJvcnMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cblxufVxuIiwiaW1wb3J0IHsgbWFwIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IGVhY2ggfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsga2V5cyB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBzaXplIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IGV4dGVuZCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBmaWx0ZXIgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgaXNOdWxsIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IHBpY2tCeSB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyByZWR1Y2UgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgaXNBcnJheSB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBpc09iamVjdCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBpc1VuZGVmaW5lZCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgUmVxdWVzdCBmcm9tICcuLi9SZXF1ZXN0JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTW9kZWwge1xuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0aGUgbW9kZWwgaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRhIG9iamVjdFxuICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGRhdGEgPSB7fSwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgdGhpcy4kY2hhbmdlZCA9IHt9O1xuICAgICAgICB0aGlzLiRleGlzdHMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4kYXR0cmlidXRlcyA9IHt9O1xuICAgICAgICB0aGlzLiRrZXkgPSB0aGlzLmtleSgpO1xuICAgICAgICB0aGlzLiRmaWxlcyA9IHRoaXMuZmlsZXMoKTtcbiAgICAgICAgdGhpcy4kdGFibGUgPSB0aGlzLnRhYmxlKCk7XG4gICAgICAgIHRoaXMuJHByb3BlcnRpZXMgPSB0aGlzLnByb3BlcnRpZXMoKTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplKGRhdGEpO1xuXG4gICAgICAgIGVhY2gocGFyYW1zLCAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgdGhpc1trZXldID0gdmFsdWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmKCF0aGlzLiR0YWJsZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIHRhYmxlIG11c3QgYmUgZGVmaW5lZCBmb3IgZXZlcnkgbW9kZWwuJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLiRpbml0aWFsaXplZCA9IHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0aGUgbW9kZWwgd2l0aCB0aGUgZ2l2ZW4gZGF0YSB3aXRob3V0IGNvbnNpZGVyaW5nIHRoZSBkYXRhXG4gICAgICogYXMgXCJjaGFuZ2VkXCIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGF0YSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICBpbml0aWFsaXplKGRhdGEpIHtcbiAgICAgICAgdGhpcy4kaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5maWxsKGRhdGEpO1xuICAgICAgICB0aGlzLiRpbml0aWFsaXplZCA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVmaW5lIHRoZSBjb3JyZXNwb25kaW5nIGRhdGFiYXNlIHRhYmxlIChha2EgQVBJIGVuZHBvaW50IHNsdWcpLlxuICAgICAqXG4gICAgICogQHJldHVybiBzdHJpbmdcbiAgICAgKi9cbiAgICB0YWJsZSgpIHtcbiAgICAgICAgLy9cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWZpbmUgYSBwcmltYXJ5IGtleS4gVGhpcyBpcyB1c2VkIHRvIGRldGVybWluZSBpZiB0aGUgbW9kZWwgZXhpc3RzIGFuZFxuICAgICAqIHdoaWNoIGVuZHBvaW50IHRvIHVzZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gc3RyaW5nXG4gICAgICovXG4gICAga2V5KCkge1xuICAgICAgICByZXR1cm4gJ2lkJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgcHJvcGVydGllcyB0aGF0IGFyZSBzZW50IHRvIHRoZSBBUEkuIElmIG5vIHByb3BlcnRpZXNcbiAgICAgKiBhcmUgZGVmaW5lZCwgdGhlbiBhbGwgdGhlIGF0dHJpYnV0ZXMgd2lsbCBiZSBpbmNsdWRlZCBpbiB0aGUgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gYXJyYXlcbiAgICAgKi9cbiAgICBwcm9wZXJ0aWVzKCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGFuIGFycmF5IG9mIGZpbGUgcHJvcGVydGllcyB0aGF0IGFyZSBzZW50IHRvIHRoZSBBUEkuIElmIG5vIGZpZXNcbiAgICAgKiBhcmUgZGVmaW5lZCwgdGhlbiByZXF1ZXN0IHdpbGwgYWx3YXlzIGJlIHNlbnQgd2l0aCBKU09OIHZzLiBtdWx0aXBhcnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIGFycmF5XG4gICAgICovXG4gICAgZmlsZXMoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGF0dHJpYnV0ZXMgaW4gdGhlIG1vZGVsIHdpdGggdGhlIGRhdGEgZ2l2ZW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGF0YSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICBmaWxsKGRhdGEpIHtcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGVzKGRhdGEpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBvbmUgb3IgbW9yZSBhdHRyaWJ1dGVzIGZyb20gdGhlIG1vZGVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGEgc3RyaW5nfGFycmF5XG4gICAgICogQHJldHVybiBhcnJheXxtaXhlZFxuICAgICAqL1xuICAgIGdldChrZXkpIHtcbiAgICAgICAgaWYoaXNBcnJheShrZXkpIHx8IGlzT2JqZWN0KGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZXMoKS5maWx0ZXIoKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEuaW5kZXhPZih2YWx1ZSkgIT09IC0xO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoa2V5KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFsaWFzIGZvciBzZXRBdHRyaWJ1dGVzKCkgZXhjZXB0IHRoaXMgbWV0aG9kIHJldHVybnMgYHRoaXNgLiBUaGlzIG1ldGhvZFxuICAgICAqIGFsc28gYWNjZXB0cyBhbiBhcnJheSBvZiB2YWx1ZXMgb3Iga2V5L3ZhbHVlIHBhaXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICBzZXQoa2V5LCB2YWx1ZSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZihpc0FycmF5KGtleSkgfHwgaXNPYmplY3Qoa2V5KSkge1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGVzKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgdGhlIGRlZmluZWQgYXR0cmlidXRlcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gYXJyYXlcbiAgICAgKi9cbiAgICBnZXRBdHRyaWJ1dGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kYXR0cmlidXRlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNoYW5nZWQgYXR0cmlidXRlc1xuICAgICAqXG4gICAgICogQHJldHVybiBhcnJheVxuICAgICAqL1xuICAgIGdldENoYW5nZWRBdHRyaWJ1dGVzKCkge1xuICAgICAgICByZXR1cm4ga2V5cyh0aGlzLiRjaGFuZ2VkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNoYW5nZWQgYXR0cmlidXRlc1xuICAgICAqXG4gICAgICogQHJldHVybiBhcnJheVxuICAgICAqL1xuICAgIGdldE9yaWdpbmFsVmFsdWUoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRjaGFuZ2VkW2tleV0gfHwgdGhpcy4kYXR0cmlidXRlc1trZXldO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdW5jaGFuZ2VkIGF0dHJpYnV0ZXNcbiAgICAgKlxuICAgICAqIEByZXR1cm4gYXJyYXlcbiAgICAgKi9cbiAgICBnZXRVbmNoYW5nZWRBdHRyaWJ1dGVzKCkge1xuICAgICAgICByZXR1cm4gZmlsdGVyKGtleXModGhpcy4kYXR0cmlidXRlcyksIGtleSA9PiAhKGtleSBpbiB0aGlzLiRjaGFuZ2VkKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGFuIGF0dHJpYnV0ZSB3aXRoIGEgZ2l2ZW4ga2V5LiBJZiBubyBrZXkgaXMgZGVmaW5lZFxuICAgICAqXG4gICAgICogQHBhcmFtIGtleSBzdHJpbmdcbiAgICAgKiBAcGFyYW0gZGVmYXVsdCB1bmRlZmluZWR8bWl4ZWRcbiAgICAgKiBAcmV0dXJuIGFycmF5XG4gICAgICovXG4gICAgZ2V0QXR0cmlidXRlKGtleSwgdmFsdWUgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGF0dHJpYnV0ZXNba2V5XSB8fCB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgYW4gYXJyYXkgb3Igb2JqZWN0IG9mIGRhdGEgYXMgYXR0cmlidXRlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhdHRyaWJ1dGVzIGFycmF5fG9iamVjdFxuICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAqL1xuICAgIHNldEF0dHJpYnV0ZXMoZGF0YSkge1xuICAgICAgICBpZighaXNBcnJheShkYXRhKSAmJiAhaXNPYmplY3QoZGF0YSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXR0cmlidXRlcyBtdXN0IGJlIHNldCB3aXRoIGFuIGFycmF5IG9yIG9iamVjdC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVhY2goZGF0YSwgKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgYW4gYXR0cmlidXRlIHdpdGggYSBnaXZlbiBrZXkvdmFsdWUgcGFpci4gVGhpcyB3aWxsIHRyYWNrIHRoZSBjaGFuZ2VzXG4gICAgICogaW4gdGhlIG1vZGVsIHdpdGhpbiB0aGUgYHRoaXMuJGNoYW5nZWRgIHByb3BlcnR5LiBJZiB0aGUgcHJpbWFyeSBrZXlcbiAgICAgKiBpcyBzZXQsIGl0IHdpbGwgYWxzbyBjaGFuZ2UgdGhlIGB0aGlzLiRleGlzdHNgIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGtleSBzdHJpbmdcbiAgICAgKiBAcGFyYW0gdmFsdWUgbWl4ZWRcbiAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgKi9cbiAgICBzZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZih0aGlzLmdldEF0dHJpYnV0ZShrZXkpICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVBdHRyaWJ1dGVDaGFuZ2Uoa2V5LCB2YWx1ZSk7XG5cbiAgICAgICAgICAgIGlmKGlzVW5kZWZpbmVkKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLiRhdHRyaWJ1dGVzW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRhdHRyaWJ1dGVzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldmVydCB0aGUgbW9kZWwgdG8gaXRzIG9yaWdpbmFsIHN0YXRlLlxuICAgICAqXG4gICAgICogQHJldHVybiBib29sXG4gICAgICovXG4gICAgcmV2ZXJ0KCkge1xuICAgICAgICBlYWNoKHRoaXMuJGNoYW5nZWQsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICBpZighaXNVbmRlZmluZWQodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kYXR0cmlidXRlc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy4kYXR0cmlidXRlc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLiRjaGFuZ2VkID0ge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpZiB0aGUgbW9kZWwgaGFzIGEgcHJpbWFyeSBrZXkgc2V0LlxuICAgICAqXG4gICAgICogQHJldHVybiBib29sXG4gICAgICovXG4gICAgZXhpc3RzKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLiRleGlzdHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbW9kZWwgYmVlbiBjaGFuZ2VkIG9yIG5vdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gYm9vbFxuICAgICAqL1xuICAgIGhhc0NoYW5nZWQoa2V5KSB7XG4gICAgICAgIHJldHVybiAha2V5ID8gc2l6ZSh0aGlzLiRjaGFuZ2VkKSA+IDAgOiAhaXNVbmRlZmluZWQodGhpcy4kY2hhbmdlZFtrZXldKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEb2VzIHRoZSBtb2RlbCBoYXZlIGFueSBGaWxlIG9iamVjdHMuIElmIHNvLCBuZWVkIHRvIHNlbmQgYXMgbXVsdGlwYXJ0LlxuICAgICAqXG4gICAgICogQHJldHVybiBib29sXG4gICAgICovXG4gICAgaGFzRmlsZXMoKSB7XG4gICAgICAgIGZ1bmN0aW9uIGNvdW50KGZpbGVzLCB0b3RhbCA9IDApIHtcbiAgICAgICAgICAgIHJldHVybiByZWR1Y2UoZmlsZXMsIChjYXJyeSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICBpZihpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FycnkgKyBjb3VudCh2YWx1ZSwgdG90YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmKHZhbHVlIGluc3RhbmNlb2YgRmlsZSB8fCB2YWx1ZSBpbnN0YW5jZW9mIEZpbGVMaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYXJyeSArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2Fycnk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdG90YWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvdW50KHRoaXMudG9KU09OKCkpICE9PSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBzZXR0aW5ncyB0aGUgJGNoYW5nZWQgYXR0cmlidXRlcyB3aGVuIGFuIGF0dHJpYnV0ZSB2YWx1ZSBpcyBzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ga2V5IHN0cmluZ1xuICAgICAqIEBwYXJhbSB2YWx1ZSBtaXhlZFxuICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAqL1xuICAgIGhhbmRsZUF0dHJpYnV0ZUNoYW5nZShrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmKHRoaXMuJGluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICBpZih0aGlzLiRjaGFuZ2VkW2tleV0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuJGNoYW5nZWRba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYoIShrZXkgaW4gdGhpcy4kY2hhbmdlZCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRjaGFuZ2VkW2tleV0gPSB0aGlzLmdldEF0dHJpYnV0ZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5oYW5kbGVQcmltYXJ5S2V5Q2hhbmdlKGtleSwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCBhbiBhcnJheSBvciBvYmplY3Qgb2YgZGF0YSBhcyBhdHRyaWJ1dGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGtleSBzdHJpbmdcbiAgICAgKiBAcGFyYW0gdmFsdWUgbWl4ZWRcbiAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgKi9cbiAgICBoYW5kbGVQcmltYXJ5S2V5Q2hhbmdlKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYodGhpcy4ka2V5ID09PSBrZXkpIHtcbiAgICAgICAgICAgIHRoaXMuJGV4aXN0cyA9ICFpc1VuZGVmaW5lZCh2YWx1ZSkgJiYgIWlzTnVsbCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTYXZlIHRoZSBtb2RlbCB0byB0aGUgZGF0YWJhc2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRhIG9iamVjdFxuICAgICAqIEByZXR1cm4gYm9vbFxuICAgICAqL1xuICAgIHNhdmUoZGF0YSA9IHt9LCBjb25maWcgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5leGlzdHMoKSA/IHRoaXMuY3JlYXRlKGRhdGEsIGNvbmZpZykgOiB0aGlzLnVwZGF0ZShkYXRhLCBjb25maWcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBtb2RlbFxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGEgb2JqZWN0XG4gICAgICogQHJldHVybiBib29sXG4gICAgICovXG4gICAgY3JlYXRlKGRhdGEgPSB7fSwgY29uZmlnID0ge30pIHtcbiAgICAgICAgaWYodGhpcy5leGlzdHMoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKGRhdGEsIGNvbmZpZyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmZpbGwoZGF0YSk7XG5cbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMucmVxdWVzdChgL2FwaS8ke3RoaXMudGFibGUoKX1gLCBleHRlbmQoe1xuICAgICAgICAgICAgZGF0YTogIXRoaXMuaGFzRmlsZXMoKSA/IHRoaXMudG9Kc29uKCkgOiB0aGlzLnRvRm9ybURhdGEoKVxuICAgICAgICB9LCBjb25maWcpKVxuXG4gICAgICAgIHJldHVybiByZXF1ZXN0LnBvc3QoKS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbGwocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgYW4gZXhpc3RpbmcgbW9kZWxcbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRhIG9iamVjdFxuICAgICAqIEByZXR1cm4gYm9vbFxuICAgICAqL1xuICAgIHVwZGF0ZShkYXRhID0ge30sIGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIGlmKCF0aGlzLmV4aXN0cygpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGUoZGF0YSwgY29uZmlnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZmlsbChkYXRhKTtcblxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5yZXF1ZXN0KGAvYXBpLyR7dGhpcy50YWJsZSgpfS8ke3RoaXMuZ2V0KHRoaXMua2V5KCkpfWAsIGV4dGVuZCh7XG4gICAgICAgICAgICBkYXRhOiAhdGhpcy5oYXNGaWxlcygpID8gdGhpcy50b0pzb24oKSA6IHRoaXMudG9Gb3JtRGF0YSgpXG4gICAgICAgIH0sIGNvbmZpZykpO1xuXG4gICAgICAgIHJldHVybiByZXF1ZXN0W3RoaXMuaGFzRmlsZXMoKSA/ICdwb3N0JyA6ICdwdXQnXSgpLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsbChyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhbiBleGlzdGluZyBtb2RlbFxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGEgb2JqZWN0XG4gICAgICogQHJldHVybiBib29sXG4gICAgICovXG4gICAgZGVsZXRlKGRhdGEgPSB7fSwgY29uZmlnID0ge30pIHtcbiAgICAgICAgaWYoIXRoaXMuZXhpc3RzKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIG1vZGVsIG11c3QgaGF2ZSBhIHByaW1hcnkga2V5IGJlZm9yZSBpdCBjYW4gYmUgZGVsZXRlLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5maWxsKGRhdGEpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYC9hcGkvJHt0aGlzLnRhYmxlKCl9LyR7dGhpcy5nZXQodGhpcy5rZXkoKSl9YCwgY29uZmlnKS5kZWxldGUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kIGFuIGV4aXN0aW5nIG1vZGVsIGJ5IGlkXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGF0YSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIGJvb2xcbiAgICAgKi9cbiAgICBzZWFyY2gocGFyYW1zID0ge30sIGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3QoYC9hcGkvJHt0aGlzLnRhYmxlKCl9YCwgZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICBwYXJhbXM6IHBhcmFtc1xuICAgICAgICAgICAgfSwgY29uZmlnKSkuZ2V0KCkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShtYXAocmVzcG9uc2UuZGF0YSwgZGF0YSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgKHRoaXMuY29uc3RydWN0b3IpKGRhdGEpO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0sIGVycm9ycyA9PiB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9ycyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZCBhbiBleGlzdGluZyBtb2RlbCBieSBpZFxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGEgb2JqZWN0XG4gICAgICogQHJldHVybiBib29sXG4gICAgICovXG4gICAgZmluZChpZCwgY29uZmlnID0ge30pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdChgL2FwaS8ke3RoaXMudGFibGUoKX0vJHtpZH1gLCBjb25maWcpLmdldCgpLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICAgICAgICAgIHJlc29sdmUodGhpcy5pbml0aWFsaXplKHJlc3BvbnNlKSk7XG4gICAgICAgICAgICB9LCBlcnJvcnMgPT4ge1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcnMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHJlcXVlc3QgZnJvbSB0aGUgbW9kZWwgZGF0YVxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGEgb2JqZWN0XG4gICAgICogQHJldHVybiBib29sXG4gICAgICovXG4gICAgcmVxdWVzdCh1cmwsIGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVxdWVzdCh1cmwsIGNvbmZpZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydCB0aGUgTW9kZWwgaW5zdGFuY2UgdG8gYSBGb3JtRGF0YSBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQHJldHVybiBvYmplY3RcbiAgICAgKi9cbiAgICB0b0Zvcm1EYXRhKCkge1xuICAgICAgICBjb25zdCBmb3JtID0gbmV3IEZvcm1EYXRhKCk7XG5cbiAgICAgICAgZWFjaCh0aGlzLnRvSlNPTigpLCAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgaWYoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBlYWNoKHZhbHVlLCBpdGVtID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYoIShpdGVtIGluc3RhbmNlb2YgRmlsZSkgJiYgKGlzT2JqZWN0KGl0ZW0pIHx8IGlzQXJyYXkoaXRlbSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtID0gSlNPTi5zdHJpbmdpZnkoaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmb3JtLmFwcGVuZChrZXkucmVwbGFjZSgvKC4rKShcXFsuK1xcXT8pJC8sICckMScpKydbXScsIGl0ZW0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZighKHZhbHVlIGluc3RhbmNlb2YgRmlsZSkgJiYgaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZm9ybS5hcHBlbmQoa2V5LCBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZighaXNOdWxsKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGZvcm0uYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZm9ybTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRoZSBpbnN0YW5jZSB0byBKU09OIHBheWxvYWRcbiAgICAgKlxuICAgICAqIEByZXR1cm4gb2JqZWN0XG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gcGlja0J5KHRoaXMuJGF0dHJpYnV0ZXMsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gIXRoaXMuJHByb3BlcnRpZXMubGVuZ3RoIHx8IChcbiAgICAgICAgICAgICAgICBrZXkgPT09IHRoaXMua2V5KCkgfHwgdGhpcy4kcHJvcGVydGllcy5pbmRleE9mKGtleSkgIT09IC0xXG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbGlhcyBmb3IgdG9KU09OXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIG9iamVjdFxuICAgICAqL1xuICAgIHRvSnNvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9KU09OKCk7XG4gICAgfVxuXG59XG4iLCI8dGVtcGxhdGU+XG4gICAgPGZvcm0gQHN1Ym1pdC5wcmV2ZW50PVwib25TdWJtaXRcIiA6Y2xhc3M9XCJ7J2Zvcm0taW5saW5lJzogaW5saW5lfVwiIDpub3ZhbGlkYXRlPVwibm92YWxpZGF0ZVwiPlxuICAgICAgICA8c2xvdD48L3Nsb3Q+XG4gICAgPC9mb3JtPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cblxuaW1wb3J0IHsgaXNGdW5jdGlvbiB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgTW9kZWwgZnJvbSAnQC9IdHRwL01vZGVsL01vZGVsJztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgcHJvcHM6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIE1vZGVsIG1ldGhvZCB1c2VkIHRvIHNlbmQgdGhlIHJlcXVlc3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBCb29sZWFuXG4gICAgICAgICAqL1xuICAgICAgICBtZXRob2Q6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdzYXZlJyxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwgJiYgaXNGdW5jdGlvbih0aGlzLm1vZGVsW3ZhbHVlXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIG9iamVjdCBvZiBmb3JtIGRhdGFcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IE9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICAgICAgZGVmYXVsdDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzcGxheSB0aGUgZm9ybSBmaWVsZHMgaW5saW5lXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBPYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIG1vZGVsOiB7XG4gICAgICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIE1vZGVsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwbGF5IHRoZSBmb3JtIGZpZWxkcyBpbmxpbmVcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IEJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIGlubGluZTogQm9vbGVhbixcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBjYWxsYmFjayBmdW5jdGlvbiBmb3IgdGhlIGBzdWJtaXRgIGV2ZW50XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBCb29sZWFuXG4gICAgICAgICAqL1xuICAgICAgICBub3ZhbGlkYXRlOiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIFVSSSBvciBVUkwgdXNlZCB0byByZWRpcmVjdCB1c2VyIGFmdGVyIGZvcm0gc3VibWl0cyBzdWNjZXNzZnVsbHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBGdW5jdGlvbnxTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHJlZGlyZWN0OiBbT2JqZWN0LCBTdHJpbmcsIEZ1bmN0aW9uXSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBjYWxsYmFjayBmdW5jdGlvbiBmb3IgdGhlIGBzdWJtaXRgIGV2ZW50XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBGdW5jdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgb25TdWJtaXQ6IHtcbiAgICAgICAgICAgIHR5cGU6IEZ1bmN0aW9uLFxuICAgICAgICAgICAgZGVmYXVsdChldmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMubW9kZWwgJiYgdGhpcy5zdWJtaXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBjYWxsYmFjayBmdW5jdGlvbiBmb3IgdGhlIGBzdWJtaXQ6c3VjY2Vzc2AgZXZlbnRcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IEZ1bmN0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBvblN1Ym1pdFN1Y2Nlc3M6IHtcbiAgICAgICAgICAgIHR5cGU6IEZ1bmN0aW9uLFxuICAgICAgICAgICAgZGVmYXVsdChldmVudCwgZGF0YSkge1xuICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ3N1Ym1pdDpzdWNjZXNzJywgZXZlbnQsIGRhdGEpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ3N1Ym1pdDpjb21wbGV0ZScsIGV2ZW50LCB0cnVlLCBkYXRhKTtcblxuICAgICAgICAgICAgICAgIGlmKHRoaXMucmVkaXJlY3QgJiYgaXNGdW5jdGlvbih0aGlzLnJlZGlyZWN0KSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZGlyZWN0KHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmKHRoaXMucmVkaXJlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kcm91dGVyLnB1c2godGhpcy5yZWRpcmVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGNhbGxiYWNrIGZ1bmN0aW9uIGZvciB0aGUgYHN1Ym1pdDpzdWNjZXNzYCBldmVudFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgRnVuY3Rpb25cbiAgICAgICAgICovXG4gICAgICAgIG9uU3VibWl0RmFpbGVkOiB7XG4gICAgICAgICAgICB0eXBlOiBGdW5jdGlvbixcbiAgICAgICAgICAgIGRlZmF1bHQoZXZlbnQsIGVycm9ycykge1xuICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ3N1Ym1pdDpmYWlsZWQnLCBldmVudCwgZXJyb3JzKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdzdWJtaXQ6Y29tcGxldGUnLCBldmVudCwgZmFsc2UsIGVycm9ycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBtZXRob2RzOiB7XG5cbiAgICAgICAgc3VibWl0KGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCdzdWJtaXQnLCBldmVudCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1vZGVsW3RoaXMubWV0aG9kXSh0aGlzLmRhdGEsIHtcbiAgICAgICAgICAgICAgICBvblVwbG9hZFByb2dyZXNzOiBldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ3N1Ym1pdDpwcm9ncmVzcycsIGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KS50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5vblN1Ym1pdFN1Y2Nlc3MoZXZlbnQsIGRhdGEpO1xuICAgICAgICAgICAgfSwgKGVycm9ycykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMub25TdWJtaXRGYWlsZWQoZXZlbnQsIGVycm9ycyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlcnJvcnM6IHt9XG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgQmFzZUZvcm0gZnJvbSAnLi9CYXNlRm9ybSc7XG5pbXBvcnQgVnVlSW5zdGFsbGVyIGZyb20gJ0AvSGVscGVycy9WdWVJbnN0YWxsZXIvVnVlSW5zdGFsbGVyJztcblxuY29uc3QgcGx1Z2luID0gVnVlSW5zdGFsbGVyLnVzZSh7XG5cbiAgICBpbnN0YWxsKFZ1ZSwgb3B0aW9ucykge1xuICAgICAgICBWdWVJbnN0YWxsZXIuY29tcG9uZW50cyh7XG4gICAgICAgICAgICBCYXNlRm9ybVxuICAgICAgICB9KTtcbiAgICB9XG5cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBCYXNlRm9ybTtcbiIsIjx0ZW1wbGF0ZT5cbiAgICA8bmF2IGFyaWEtbGFiZWw9XCJicmVhZGNydW1iXCI+XG4gICAgICAgIDxvbCBjbGFzcz1cImJyZWFkY3J1bWJcIj5cbiAgICAgICAgICAgIDxicmVhZGNydW1iLWl0ZW1cbiAgICAgICAgICAgICAgICB2LWlmPVwiaXRlbXMubGVuZ3RoXCJcbiAgICAgICAgICAgICAgICB2LWZvcj1cIihpdGVtLCBpKSBpbiBpdGVtc1wiXG4gICAgICAgICAgICAgICAgdi1iaW5kPVwiaXRlbVwiXG4gICAgICAgICAgICAgICAgOmtleT1cImlcIlxuICAgICAgICAgICAgICAgIDpjdXJyZW50PVwiaSA9PT0gaXRlbS5sZW5ndGggLSAxXCJcbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8c2xvdC8+XG4gICAgICAgIDwvb2w+XG4gICAgPC9uYXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ2JyZWFkY3J1bWInLFxuXG4gICAgcHJvcHM6IHtcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBhcnJheSBvZiBicmVhZGNydW1ic1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcCB7QXJyYXl9XG4gICAgICAgICAqL1xuICAgICAgICBpdGVtczogQXJyYXlcblxuICAgIH1cblxufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gICAgPGxpIGNsYXNzPVwiYnJlYWRjcnVtYi1pdGVtXCIgOmNsYXNzPVwieydhY3RpdmUnOiBhY3RpdmV9XCIgOmFyaWEtY3VycmVudD1cImFjdGl2ZSA/ICdwYWdlJyA6IGZhbHNlXCI+XG4gICAgICAgIDxhIHYtaWY9XCIhYWN0aXZlICYmIGhyZWZcIiA6aHJlZj1cImhyZWZcIj5cbiAgICAgICAgICAgIDxzbG90Pnt7bGFiZWx9fTwvc2xvdD5cbiAgICAgICAgPC9hPlxuICAgICAgICA8dGVtcGxhdGUgdi1lbHNlPlxuICAgICAgICAgICAgPHNsb3Q+e3tsYWJlbH19PC9zbG90PlxuICAgICAgICA8L3RlbXBsYXRlPlxuICAgIDwvbGk+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ2JyZWFkY3J1bWItaXRlbScsXG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJcyB0aGUgaXRlbSBhY3RpdmU/XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wIHtCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgYWN0aXZlOiBCb29sZWFuLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBocmVmIGF0dHJpYnV0ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcCB7U3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgaHJlZjogU3RyaW5nLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBicmVhZGNydW1iIGxhYmVsXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wIHtTdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBsYWJlbDogU3RyaW5nXG5cbiAgICB9XG5cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IEJyZWFkY3J1bWIgZnJvbSAnLi9CcmVhZGNydW1iJztcbmltcG9ydCBCcmVhZGNydW1iSXRlbSBmcm9tICcuL0JyZWFkY3J1bWJJdGVtJztcbmltcG9ydCBWdWVJbnN0YWxsZXIgZnJvbSAnQC9IZWxwZXJzL1Z1ZUluc3RhbGxlci9WdWVJbnN0YWxsZXInO1xuXG5jb25zdCBwbHVnaW4gPSBWdWVJbnN0YWxsZXIudXNlKHtcblxuICAgIGluc3RhbGwoVnVlLCBvcHRpb25zKSB7XG4gICAgICAgIFZ1ZUluc3RhbGxlci5jb21wb25lbnRzKHtcbiAgICAgICAgICAgIEJyZWFkY3J1bWIsXG4gICAgICAgICAgICBCcmVhZGNydW1iSXRlbVxuICAgICAgICB9KTtcbiAgICB9XG5cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBCcmVhZGNydW1iO1xuIiwiaW1wb3J0IHByZWZpeCBmcm9tICdAL0hlbHBlcnMvUHJlZml4L1ByZWZpeCc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzaXplIG9mIHRoZSBmb3JtIGNvbnRyb2xcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgc2l6ZToge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJ21kJyxcbiAgICAgICAgICAgIHZhbGlkYXRlOiB2YWx1ZSA9PiBbJ3NtJywgJ21kJywgJ2xnJ10uaW5kZXhPZih2YWx1ZSkgIT09IC0xXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBjb21wdXRlZDoge1xuXG4gICAgICAgIHNpemVhYmxlQ2xhc3MoKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJlZml4KHRoaXMuc2l6ZSwgdGhpcy4kb3B0aW9ucy5uYW1lKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG59XG4iLCI8dGVtcGxhdGU+XG4gICAgPGxhYmVsIHYtaWY9XCJsYWJlbFwiIGNsYXNzPVwiYnRuXCIgOmRpc2FibGVkPVwiZGlzYWJsZWRcIiA6Y2xhc3M9XCJjbGFzc2VzXCIgQGNsaWNrPVwib25DbGlja1wiPlxuICAgICAgICA8c2xvdC8+XG4gICAgPC9sYWJlbD5cbiAgICA8YSB2LWVsc2UtaWY9XCJocmVmXCIgY2xhc3M9XCJidG5cIiA6aHJlZj1cImhyZWZcIiA6ZGlzYWJsZWQ9XCJkaXNhYmxlZFwiIDpjbGFzcz1cImNsYXNzZXNcIiBAY2xpY2s9XCJvbkNsaWNrXCI+XG4gICAgICAgIDxzbG90Lz5cbiAgICA8L2E+XG4gICAgPGJ1dHRvbiB2LWVsc2UgY2xhc3M9XCJidG5cIiA6dHlwZT1cInR5cGVcIiA6ZGlzYWJsZWQ9XCJkaXNhYmxlZFwiIDpjbGFzcz1cImNsYXNzZXNcIiBAY2xpY2s9XCJvbkNsaWNrXCI+XG4gICAgICAgIDxzbG90Lz5cbiAgICA8L2J1dHRvbj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgVmFyaWFudCBmcm9tICdAL01peGlucy9WYXJpYW50L1ZhcmlhbnQnO1xuaW1wb3J0IFNpemVhYmxlIGZyb20gJ0AvTWl4aW5zL1NpemVhYmxlL1NpemVhYmxlJztcbmltcG9ydCB0cmFuc2l0aW9uIGZyb20gJ0AvSGVscGVycy9UcmFuc2l0aW9uL1RyYW5zaXRpb24nO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAnYnRuJyxcblxuICAgIG1peGluczogW1xuICAgICAgICBWYXJpYW50LFxuICAgICAgICBTaXplYWJsZVxuICAgIF0sXG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG91bGQgdXNlIDxsYWJlbD4gYXMgdGhlIGVsZW1lbnQgZm9yIHRoZSBidXR0b24uIFVzZWQgZm9yIGlucHV0c1xuICAgICAgICAgKiB3cmFwcGVycyAodG9nZ2xlcykuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBCb29sZWFuXG4gICAgICAgICAqL1xuICAgICAgICBsYWJlbDogQm9vbGVhbixcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgYW4gaHJlZiBpcyBwYXNzZWQsIGJ1dHRvbiBpcyBhbiBhbmNob3IgZWxlbWVudFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgQm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgaHJlZjogU3RyaW5nLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdHlwZSBhdHRyaWJ1dGUgZm9yIHRoZSBidXR0b24uIE5vdCBhcHBsaWVkIGlmIGFuIGFuY2hvclxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAnc3VibWl0J1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwbGF5IGJ1dHRvbiB3aXRoIGFjdGl2ZSBzdGF0ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBhY3RpdmU6IEJvb2xlYW4sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc3BsYXkgYnV0dG9uIHdpdGggYmxvY2tlZCBzdGF0ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBibG9jazogQm9vbGVhbixcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzcGxheSBidXR0b24gd2l0aCBkaXNhYmxlZCBzdGF0ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBkaXNhYmxlZDogQm9vbGVhbixcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzcGxheSBhcyBhbiBvdXRsaW5lIGJ1dHRvblxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBvdXRsaW5lOiBCb29sZWFuXG5cbiAgICB9LFxuXG4gICAgbWV0aG9kczoge1xuXG4gICAgICAgIG9uQ2xpY2soZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2NsaWNrJywgZXZlbnQsIHRoaXMpO1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgY29tcHV0ZWQ6IHtcblxuICAgICAgICB2YXJpYW50Q2xhc3NQcmVmaXgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kb3B0aW9ucy5uYW1lICsgKHRoaXMub3V0bGluZSA/ICctb3V0bGluZScgOiAnJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xhc3NlcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRtZXJnZUNsYXNzZXMoXG4gICAgICAgICAgICAgICAgdGhpcy52YXJpYW50Q2xhc3MsXG4gICAgICAgICAgICAgICAgdGhpcy5zaXplYWJsZUNsYXNzLFxuICAgICAgICAgICAgICAgIHRoaXMuYmxvY2sgPyAnYnRuLWJsb2NrJyA6ICcnLFxuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlID8gJ2FjdGl2ZScgOiAnJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG59XG48L3NjcmlwdD5cbiIsImltcG9ydCBCdG4gZnJvbSAnLi9CdG4nO1xuaW1wb3J0IFZ1ZUluc3RhbGxlciBmcm9tICdAL0hlbHBlcnMvVnVlSW5zdGFsbGVyL1Z1ZUluc3RhbGxlcic7XG5cbmNvbnN0IHBsdWdpbiA9IFZ1ZUluc3RhbGxlci51c2Uoe1xuXG4gICAgaW5zdGFsbChWdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgVnVlSW5zdGFsbGVyLmNvbXBvbmVudHMoe1xuICAgICAgICAgICAgQnRuXG4gICAgICAgIH0pO1xuICAgIH1cblxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IEJ0bjtcbiIsIi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbmVnYXRlcyB0aGUgcmVzdWx0IG9mIHRoZSBwcmVkaWNhdGUgYGZ1bmNgLiBUaGVcbiAqIGBmdW5jYCBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBhbmQgYXJndW1lbnRzIG9mIHRoZVxuICogY3JlYXRlZCBmdW5jdGlvbi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgcHJlZGljYXRlIHRvIG5lZ2F0ZS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG5lZ2F0ZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIGlzRXZlbihuKSB7XG4gKiAgIHJldHVybiBuICUgMiA9PSAwO1xuICogfVxuICpcbiAqIF8uZmlsdGVyKFsxLCAyLCAzLCA0LCA1LCA2XSwgXy5uZWdhdGUoaXNFdmVuKSk7XG4gKiAvLyA9PiBbMSwgMywgNV1cbiAqL1xuZnVuY3Rpb24gbmVnYXRlKHByZWRpY2F0ZSkge1xuICBpZiAodHlwZW9mIHByZWRpY2F0ZSAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6IHJldHVybiAhcHJlZGljYXRlLmNhbGwodGhpcyk7XG4gICAgICBjYXNlIDE6IHJldHVybiAhcHJlZGljYXRlLmNhbGwodGhpcywgYXJnc1swXSk7XG4gICAgICBjYXNlIDI6IHJldHVybiAhcHJlZGljYXRlLmNhbGwodGhpcywgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICBjYXNlIDM6IHJldHVybiAhcHJlZGljYXRlLmNhbGwodGhpcywgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgfVxuICAgIHJldHVybiAhcHJlZGljYXRlLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5lZ2F0ZTtcbiIsInZhciBiYXNlSXRlcmF0ZWUgPSByZXF1aXJlKCcuL19iYXNlSXRlcmF0ZWUnKSxcbiAgICBuZWdhdGUgPSByZXF1aXJlKCcuL25lZ2F0ZScpLFxuICAgIHBpY2tCeSA9IHJlcXVpcmUoJy4vcGlja0J5Jyk7XG5cbi8qKlxuICogVGhlIG9wcG9zaXRlIG9mIGBfLnBpY2tCeWA7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mXG4gKiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBgb2JqZWN0YCB0aGF0XG4gKiBgcHJlZGljYXRlYCBkb2Vzbid0IHJldHVybiB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0d29cbiAqIGFyZ3VtZW50czogKHZhbHVlLCBrZXkpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBwcm9wZXJ0eS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAnMicsICdjJzogMyB9O1xuICpcbiAqIF8ub21pdEJ5KG9iamVjdCwgXy5pc051bWJlcik7XG4gKiAvLyA9PiB7ICdiJzogJzInIH1cbiAqL1xuZnVuY3Rpb24gb21pdEJ5KG9iamVjdCwgcHJlZGljYXRlKSB7XG4gIHJldHVybiBwaWNrQnkob2JqZWN0LCBuZWdhdGUoYmFzZUl0ZXJhdGVlKHByZWRpY2F0ZSkpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvbWl0Qnk7XG4iLCJpbXBvcnQgeyBtYXAgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgZWFjaCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBmaWx0ZXIgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgaXNOdWxsIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IG9taXRCeSB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBjYW1lbENhc2UgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHByZWZpeCBmcm9tICdAL0hlbHBlcnMvUHJlZml4L1ByZWZpeCc7XG5cbmNvbnN0IENPTE9SUyA9IFtcbiAgICAncHJpbWFyeScsXG4gICAgJ3NlY29uZGFyeScsXG4gICAgJ3N1Y2Nlc3MnLFxuICAgICdkYW5nZXInLFxuICAgICd3YXJuaW5nJyxcbiAgICAnaW5mbycsXG4gICAgJ2xpZ2h0JyxcbiAgICAnZGFyaycsXG4gICAgJ3doaXRlJyxcbiAgICAnbXV0ZWQnXG5dO1xuXG5jb25zdCBwcm9wcyA9IHt9O1xuXG5lYWNoKFsnYm9yZGVyJywgJ3RleHQnLCAnYmcnLCAnYmctZ3JhZGllbnQnXSwgbmFtZXNwYWNlID0+IHtcbiAgICBlYWNoKENPTE9SUywgY29sb3IgPT4ge1xuICAgICAgICBwcm9wc1tjYW1lbENhc2UocHJlZml4KGNvbG9yLCBuYW1lc3BhY2UpKV0gPSBCb29sZWFuO1xuICAgIH0pO1xufSk7XG5cbmZ1bmN0aW9uIGNsYXNzZXMoaW5zdGFuY2UsIG5hbWVzcGFjZSkge1xuICAgIHJldHVybiBmaWx0ZXIobWFwKENPTE9SUywgY29sb3IgPT4ge1xuICAgICAgICByZXR1cm4gaW5zdGFuY2VbY2FtZWxDYXNlKGNvbG9yID0gcHJlZml4KGNvbG9yLCBuYW1lc3BhY2UpKV0gPyBjb2xvciA6IG51bGw7XG4gICAgfSkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBwcm9wczogcHJvcHMsXG5cbiAgICBtZXRob2RzOiB7XG5cbiAgICAgICAgdGV4dENvbG9yKCkge1xuICAgICAgICAgICAgcmV0dXJuIGNsYXNzZXModGhpcywgJ3RleHQnKTtcbiAgICAgICAgfSxcblxuICAgICAgICBiZ0NvbG9yKCkge1xuICAgICAgICAgICAgcmV0dXJuIGNsYXNzZXModGhpcywgJ2JnJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYm9yZGVyQ29sb3IoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2xhc3Nlcyh0aGlzLCAnYm9yZGVyJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYmdHcmFkaWVudENvbG9yKCkge1xuICAgICAgICAgICAgcmV0dXJuIGNsYXNzZXModGhpcywgJ2JnLWdyYWRpZW50Jyk7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBjb21wdXRlZDoge1xuXG4gICAgICAgIHRleHRDb2xvckNsYXNzZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50ZXh0Q29sb3IoKS5qb2luKCcgJykudHJpbSgpIHx8IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYm9yZGVyQ29sb3JDbGFzc2VzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYm9yZGVyQ29sb3IoKS5qb2luKCcgJykudHJpbSgpIHx8IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYmdDb2xvckNsYXNzZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iZ0NvbG9yKCkuam9pbignICcpLnRyaW0oKSB8fCBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIGJnR3JhZGllbnRDb2xvckNsYXNzZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iZ0dyYWRpZW50Q29sb3IoKS5qb2luKCcgJykudHJpbSgpIHx8IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29sb3JhYmxlQ2xhc3NlcygpIHtcbiAgICAgICAgICAgIGNvbnN0IGNsYXNzZXMgPSB7fTtcblxuICAgICAgICAgICAgY2xhc3Nlc1t0aGlzLnRleHRDb2xvckNsYXNzZXNdID0gISF0aGlzLnRleHRDb2xvckNsYXNzZXM7XG4gICAgICAgICAgICBjbGFzc2VzW3RoaXMuYm9yZGVyQ29sb3JDbGFzc2VzXSA9ICEhdGhpcy5ib3JkZXJDb2xvckNsYXNzZXM7XG4gICAgICAgICAgICBjbGFzc2VzW3RoaXMuYmdDb2xvckNsYXNzZXNdID0gISF0aGlzLmJnQ29sb3JDbGFzc2VzO1xuICAgICAgICAgICAgY2xhc3Nlc1t0aGlzLmJnR3JhZGllbnRDb2xvckNsYXNzZXNdID0gISF0aGlzLmJnR3JhZGllbnRDb2xvckNsYXNzZXM7XG5cbiAgICAgICAgICAgIHJldHVybiBvbWl0QnkoY2xhc3NlcywgKGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIWtleSB8fCAhdmFsdWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG59XG4iLCI8dGVtcGxhdGU+XG4gICAgPGRpdiA6Y2xhc3M9XCJjbGFzc2VzXCIgcm9sZT1cImdyb3VwXCI+XG4gICAgICAgIDxidG4gdi1pZj1cImJ1dHRvbnNcIiB2LWZvcj1cIihidXR0b24sIGkpIGluIGJ1dHRvbnNcIiA6a2V5PVwiaVwiIHYtYmluZD1cImJ1dHRvblwiIC8+XG4gICAgICAgIDxzbG90Lz5cbiAgICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgU2l6ZWFibGUgZnJvbSAnQC9NaXhpbnMvU2l6ZWFibGUvU2l6ZWFibGUnO1xuaW1wb3J0IENvbG9yYWJsZSBmcm9tICdAL01peGlucy9Db2xvcmFibGUvQ29sb3JhYmxlJztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ2J0bi1ncm91cCcsXG5cbiAgICBtaXhpbnM6IFtcbiAgICAgICAgQ29sb3JhYmxlLFxuICAgICAgICBTaXplYWJsZVxuICAgIF0sXG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBhcnJheSBvZiBidXR0b25zXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wIHtBcnJheX1cbiAgICAgICAgICovXG4gICAgICAgIGJ1dHRvbnM6IEFycmF5LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwbGF5IHRoZSBidXR0b25zIHZlcnRpY2FsbHlcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3Age0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB2ZXJ0aWNhbDogQm9vbGVhblxuXG4gICAgfSxcblxuICAgIGNvbXB1dGVkOiB7XG5cbiAgICAgICAgY2xhc3NlcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRtZXJnZUNsYXNzZXMoXG4gICAgICAgICAgICAgICAgdGhpcy5zaXplYWJsZUNsYXNzLFxuICAgICAgICAgICAgICAgIHRoaXMuY29sb3JhYmxlQ2xhc3Nlcywge1xuICAgICAgICAgICAgICAgICAgICAnYnRuLWdyb3VwJzogIXRoaXMudmVydGljYWwsXG4gICAgICAgICAgICAgICAgICAgICdidG4tZ3JvdXAtdmVydGljYWwnOiB0aGlzLnZlcnRpY2FsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgICA8ZGl2IGNsYXNzPVwiYnRuLXRvb2xiYXJcIiByb2xlPVwidG9vbGJhclwiPlxuICAgICAgICA8c2xvdC8+XG4gICAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ2J0bi10b29sYmFyJ1xuXG59XG48L3NjcmlwdD5cbiIsImltcG9ydCBCdG5Hcm91cCBmcm9tICcuL0J0bkdyb3VwJztcbmltcG9ydCBCdG5Ub29sYmFyIGZyb20gJy4vQnRuVG9vbGJhcic7XG5pbXBvcnQgVnVlSW5zdGFsbGVyIGZyb20gJ0AvSGVscGVycy9WdWVJbnN0YWxsZXIvVnVlSW5zdGFsbGVyJztcblxuY29uc3QgcGx1Z2luID0gVnVlSW5zdGFsbGVyLnVzZSh7XG5cbiAgICBpbnN0YWxsKFZ1ZSwgb3B0aW9ucykge1xuICAgICAgICBWdWVJbnN0YWxsZXIuY29tcG9uZW50cyh7XG4gICAgICAgICAgICBCdG5Hcm91cCxcbiAgICAgICAgICAgIEJ0blRvb2xiYXJcbiAgICAgICAgfSk7XG4gICAgfVxuXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgQnRuR3JvdXA7XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1dWlkKCkge1xuICAgIHJldHVybiAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIGMgPT4ge1xuICAgICAgICB2YXIgciA9IE1hdGgucmFuZG9tKCkgKiAxNiB8IDAsIHYgPSBjID09ICd4JyA/IHIgOiAociAmIDB4MyB8IDB4OCk7XG4gICAgICAgIHJldHVybiB2LnRvU3RyaW5nKDE2KTtcbiAgICB9KTtcbn1cbiIsImltcG9ydCB7IGlzRnVuY3Rpb24gfSBmcm9tICdsb2Rhc2gnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBtZXRob2RzOiB7XG4gICAgICAgIHByb3h5KGNhbGxiYWNrLCBldmVudCkge1xuICAgICAgICAgICAgaWYoaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykuc3BsaWNlKDEpKTtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG59XG4iLCI8dGVtcGxhdGU+XG4gICAgPGFcbiAgICAgICAgOmhyZWY9XCJocmVmIHx8ICcjJ1wiXG4gICAgICAgIGNsYXNzPVwiZHJvcGRvd24taXRlbVwiXG4gICAgICAgIDpjbGFzcz1cInsnYWN0aXZlJzogYWN0aXZlfVwiXG4gICAgICAgIEBjbGljaz1cInByb3h5KG9uQ2xpY2ssICRldmVudCk7b25DbGlja2VkKCRldmVudCk7XCI+XG4gICAgICAgIDxpIHYtaWY9XCJpY29uXCIgOmNsYXNzPVwiaWNvblwiLz5cbiAgICAgICAgPHNsb3Q+e3tsYWJlbH19PC9zbG90PlxuICAgIDwvYT5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5cbmltcG9ydCBQcm94eSBmcm9tICdAL01peGlucy9Qcm94eS9Qcm94eSc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG1peGluczogW1Byb3h5XSxcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElzIHRoZSBtZW51IGl0ZW0gYWN0aXZlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgT2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBhY3RpdmU6IEJvb2xlYW4sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBgaHJlZmAgYXR0cmlidXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgT2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBocmVmOiBTdHJpbmcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsYWJlbCBvZiB0aGUgZHJvcGRvd24gbWVudSBpdGVtLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgT2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBsYWJlbDogU3RyaW5nLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaWNvbiBvZiB0aGUgZHJvcGRvd24gbWVudSBpdGVtLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgT2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBpY29uOiBTdHJpbmcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIHRoZSBgY2xpY2tgIGV2ZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgT2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBvbkNsaWNrOiBGdW5jdGlvblxuXG4gICAgfSxcblxuICAgIG1ldGhvZHM6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBjYWxsYmFjayBmdW5jdGlvbiBmb3IgdGhlIGBjbGlja2AgZXZlbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBPYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIG9uQ2xpY2tlZChldmVudCkge1xuICAgICAgICAgICAgaWYoIXRoaXMuaHJlZikge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2NsaWNrJywgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG59XG5cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICAgIDxoNSBjbGFzcz1cImRyb3Bkb3duLWhlYWRlclwiPlxuICAgICAgICB7e2hlYWRlcn19XG5cbiAgICAgICAgPHNsb3Q+PC9zbG90PlxuICAgIDwvaDU+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAnZHJvcGRvd24tbWVudS1oZWFkZXInLFxuXG4gICAgcHJvcHM6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHZhbHVlIG9mIHRoZSBoZWFkZXJcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IE9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgaGVhZGVyOiBTdHJpbmdcblxuICAgIH1cblxufVxuXG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgICA8ZGl2IGNsYXNzPVwiZHJvcGRvd24tZGl2aWRlclwiPjwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ2Ryb3Bkb3duLW1lbnUtZGl2aWRlcidcblxufVxuXG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgICA8ZGl2IGNsYXNzPVwiZHJvcGRvd24tbWVudVwiIDpjbGFzcz1cInsnZHJvcGRvd24tbWVudS1yaWdodCc6IGFsaWduID09PSAncmlnaHQnLCAnc2hvdyc6IHNob3d9XCIgOmFyaWEtbGFiZWxsZWRieT1cImlkXCI+XG4gICAgICAgIDxzbG90PlxuICAgICAgICAgICAgPHRlbXBsYXRlIHYtZm9yPVwiaXRlbSBpbiBpdGVtc1wiPlxuICAgICAgICAgICAgICAgIDxjb21wb25lbnQgOmlzPVwicHJlZml4KGl0ZW0udHlwZSB8fCAnaXRlbScsICdkcm9wZG93bi1tZW51JylcIiB2LWJpbmQ9XCJpdGVtXCIgQGNsaWNrPVwib25DbGljaygkZXZlbnQsIGl0ZW0pXCIgLz5cbiAgICAgICAgICAgIDwvdGVtcGxhdGU+XG4gICAgICAgIDwvc2xvdD5cbiAgICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5cbmltcG9ydCB1dWlkIGZyb20gJ0AvSGVscGVycy9VdWlkL1V1aWQnO1xuaW1wb3J0IHByZWZpeCBmcm9tICdAL0hlbHBlcnMvUHJlZml4L1ByZWZpeCc7XG5pbXBvcnQgRHJvcGRvd25NZW51SXRlbSBmcm9tICcuL0Ryb3Bkb3duTWVudUl0ZW0nO1xuaW1wb3J0IERyb3Bkb3duTWVudUhlYWRlciBmcm9tICcuL0Ryb3Bkb3duTWVudUhlYWRlcic7XG5pbXBvcnQgRHJvcGRvd25NZW51RGl2aWRlciBmcm9tICcuL0Ryb3Bkb3duTWVudURpdmlkZXInO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBjb21wb25lbnRzOiB7XG4gICAgICAgIERyb3Bkb3duTWVudUl0ZW0sXG4gICAgICAgIERyb3Bkb3duTWVudUhlYWRlcixcbiAgICAgICAgRHJvcGRvd25NZW51RGl2aWRlclxuICAgIH0sXG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYGlkYCBhdHRyaWJ1dGUgb24gdGhlIHRvZ2dsZSBidXR0b24gYW5kIGFyaWEgbGFiZWwuIElmIG5vIGBpZGAgaXNcbiAgICAgICAgICogZGVmaW5lZCwgdGhlbiBhIFVVSUQgd2lsbCBiZSBnZW5lcmF0ZWQgaW5zdGVhZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IE9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgaWQ6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6IHV1aWRcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzcGxheSB0aGUgZHJvcGRvd24gbWVudSBhbGlnbmVkIGxlZnQgb3IgcmlnaHRcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgYWxpZ246IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdsZWZ0JyxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsnbGVmdCcsICdyaWdodCddLmluZGV4T2YodmFsdWUudG9Mb3dlckNhc2UoKSkgIT09IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGVmYXVsdCB2aXNpYmlsaXR5IG9mIHRoZSBkcm9wZG93biBtZW51LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgT2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBzaG93OiBCb29sZWFuLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBhcnJheSBvZiBkcm9wZG93biBpdGVtcy4gSWYgYW4ga2V5L3ZhbHVlIHBhaXIgaXNuJ3QgZGVmaW5lZCwgdGhlXG4gICAgICAgICAqIGRlZmF1bHQgdmFsdWUgd2lsbCBiZSB1c2VkLiBJZiBubyBpdGVtcyBhcmUgZGVmaW5lZCwgdGhlbiB0aGUgc2xvdFxuICAgICAgICAgKiBuYW1lZCBcIml0ZW1zXCIgY2FuIGJlIHVzZWQgdG8gZGVmaW5lIHRoZSBvcHRpb25zIHdpdGggSFRNTC5cbiAgICAgICAgICpcbiAgICAgICAgICogW3tcbiAgICAgICAgICogICAgICB0eXBlOiAnaXRlbScsIC8vIFN0cmluZyBbaXRlbXxoZWFkZXJ8ZGl2aWRlcl1cbiAgICAgICAgICogICAgICBocmVmOiAnIycsIC8vIFN0cmluZ1xuICAgICAgICAgKiAgICAgIGxhYmVsOiAnU29tZSBsYWJlbCcsIC8vIFN0cmluZ1xuICAgICAgICAgKiAgICAgIG9uQ2xpY2s6IChldmVudCkgPT4ge30gLy8gRnVuY3Rpb25cbiAgICAgICAgICogfV1cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IEFycmF5XG4gICAgICAgICAqL1xuICAgICAgICBpdGVtczogQXJyYXlcblxuICAgIH0sXG5cbiAgICBtZXRob2RzOiB7XG5cbiAgICAgICAgcHJlZml4OiBwcmVmaXgsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIHRoZSBgY2xpY2tgIGV2ZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gT2JqZWN0IGV2ZW50XG4gICAgICAgICAqIEBwYXJhbSBPYmplY3QgaXRlbVxuICAgICAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgICAgICovXG4gICAgICAgIG9uQ2xpY2soZXZlbnQsIGl0ZW0pIHtcbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2l0ZW06Y2xpY2snLCBldmVudCwgaXRlbSk7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCd1cGRhdGU6c2hvdycsIGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG59XG5cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IERyb3Bkb3duTWVudSBmcm9tICcuL0Ryb3Bkb3duTWVudSc7XG5pbXBvcnQgRHJvcGRvd25NZW51RGl2aWRlciBmcm9tICcuL0Ryb3Bkb3duTWVudURpdmlkZXInO1xuaW1wb3J0IERyb3Bkb3duTWVudUhlYWRlciBmcm9tICcuL0Ryb3Bkb3duTWVudUhlYWRlcic7XG5pbXBvcnQgRHJvcGRvd25NZW51SXRlbSBmcm9tICcuL0Ryb3Bkb3duTWVudUl0ZW0nO1xuaW1wb3J0IFZ1ZUluc3RhbGxlciBmcm9tICdAL0hlbHBlcnMvVnVlSW5zdGFsbGVyL1Z1ZUluc3RhbGxlcic7XG5cbmNvbnN0IHBsdWdpbiA9IFZ1ZUluc3RhbGxlci51c2Uoe1xuXG4gICAgaW5zdGFsbChWdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgVnVlSW5zdGFsbGVyLmNvbXBvbmVudHMoe1xuICAgICAgICAgICAgRHJvcGRvd25NZW51LFxuICAgICAgICAgICAgRHJvcGRvd25NZW51RGl2aWRlcixcbiAgICAgICAgICAgIERyb3Bkb3duTWVudUhlYWRlcixcbiAgICAgICAgICAgIERyb3Bkb3duTWVudUl0ZW1cbiAgICAgICAgfSk7XG4gICAgfVxuXG59KTtcblxuZXhwb3J0ICogZnJvbSAnLi9Ecm9wZG93bk1lbnVEaXZpZGVyJztcbmV4cG9ydCAqIGZyb20gJy4vRHJvcGRvd25NZW51SGVhZGVyJztcbmV4cG9ydCAqIGZyb20gJy4vRHJvcGRvd25NZW51SXRlbSc7XG5leHBvcnQgZGVmYXVsdCBEcm9wZG93bk1lbnU7XG4iLCI8dGVtcGxhdGU+XG5cbiAgICA8ZGl2IGNsYXNzPVwiYnRuLWdyb3VwXCIgOmNsYXNzPVwieydkcm9wdXAnOiBkcm9wdXAsICdkcm9wcmlnaHQnOiBkcm9wcmlnaHQsICdkcm9wbGVmdCc6IGRyb3BsZWZ0fVwiPlxuICAgICAgICA8c2xvdCBuYW1lPVwidG9nZ2xlLWJ1dHRvblwiPlxuICAgICAgICAgICAgPHRlbXBsYXRlIHYtaWY9XCJzcGxpdFwiPlxuICAgICAgICAgICAgICAgIDxhIHYtaWY9XCJocmVmXCIgOmhyZWY9XCJocmVmXCIgOmNsYXNzPVwiYWN0aW9uQ2xhc3Nlc1wiIEBjbGljaz1cIm9uQ2xpY2tcIj5cbiAgICAgICAgICAgICAgICAgICAgPHNsb3QgbmFtZT1cImxhYmVsLXdyYXBwZXJcIj48aSB2LWlmPVwiaWNvblwiIDpjbGFzcz1cImljb25cIj48L2k+IDxzbG90IG5hbWU9XCJsYWJlbFwiPnt7bGFiZWx9fTwvc2xvdD48L3Nsb3Q+XG4gICAgICAgICAgICAgICAgPC9hPlxuICAgICAgICAgICAgICAgIDxidXR0b24gdi1lbHNlIDp0eXBlPVwidHlwZVwiIDpjbGFzcz1cImFjdGlvbkNsYXNzZXNcIiBAY2xpY2s9XCJvbkNsaWNrXCI+XG4gICAgICAgICAgICAgICAgICAgIDxzbG90IG5hbWU9XCJsYWJlbC13cmFwcGVyXCI+PGkgdi1pZj1cImljb25cIiA6Y2xhc3M9XCJpY29uXCI+PC9pPiA8c2xvdCBuYW1lPVwibGFiZWxcIj57e2xhYmVsfX08L3Nsb3Q+PC9zbG90PlxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGFyaWEtaGFzcG9wdXA9XCJ0cnVlXCIgOmFyaWEtZXhwYW5kZWQ9XCJpc0Ryb3Bkb3duU2hvd2luZ1wiIDppZD1cImlkXCIgOmNsYXNzPVwidG9nZ2xlQ2xhc3Nlc1wiIEBjbGljay5wcmV2ZW50PVwiIWlzRHJvcGRvd25TaG93aW5nID8gc2hvdygpIDogaGlkZSgpXCIgQGJsdXI9XCJvbkJsdXJcIj48L2J1dHRvbj5cbiAgICAgICAgICAgIDwvdGVtcGxhdGU+XG4gICAgICAgICAgICA8dGVtcGxhdGUgdi1lbHNlPlxuICAgICAgICAgICAgICAgIDxidXR0b24gYXJpYS1oYXNwb3B1cD1cInRydWVcIiA6YXJpYS1leHBhbmRlZD1cImlzRHJvcGRvd25TaG93aW5nXCIgOnR5cGU9XCJ0eXBlXCIgOmlkPVwiaWRcIiA6Y2xhc3M9XCJ0b2dnbGVDbGFzc2VzXCIgQGNsaWNrLnByZXZlbnQ9XCIhaXNEcm9wZG93blNob3dpbmcgPyBzaG93KCkgOiBoaWRlKClcIiBAYmx1cj1cIm9uQmx1clwiPlxuICAgICAgICAgICAgICAgICAgICA8c2xvdCBuYW1lPVwibGFiZWwtd3JhcHBlclwiPjxpIHYtaWY9XCJpY29uXCIgOmNsYXNzPVwiaWNvblwiPjwvaT4gPHNsb3QgbmFtZT1cImxhYmVsXCI+e3tsYWJlbH19PC9zbG90Pjwvc2xvdD5cbiAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgIDwvdGVtcGxhdGU+XG4gICAgICAgIDwvc2xvdD5cblxuICAgICAgICA8c2xvdCBuYW1lPVwiZHJvcGRvd24tbWVudVwiPlxuICAgICAgICAgICAgPGRyb3Bkb3duLW1lbnVcbiAgICAgICAgICAgICAgICA6aWQ9XCJpZFwiXG4gICAgICAgICAgICAgICAgOml0ZW1zPVwiaXRlbXNcIlxuICAgICAgICAgICAgICAgIDphbGlnbj1cImFsaWduXCJcbiAgICAgICAgICAgICAgICA6c2hvdy5zeW5jPVwiaXNEcm9wZG93blNob3dpbmdcIlxuICAgICAgICAgICAgICAgIEBpdGVtOmNsaWNrPVwib25JdGVtQ2xpY2tcIj5cbiAgICAgICAgICAgICAgICA8c2xvdC8+XG4gICAgICAgICAgICA8L2Ryb3Bkb3duLW1lbnU+XG4gICAgICAgIDwvc2xvdD5cbiAgICA8L2Rpdj5cblxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cblxuaW1wb3J0IHV1aWQgZnJvbSAnQC9IZWxwZXJzL1V1aWQvVXVpZCc7XG5pbXBvcnQgcHJlZml4IGZyb20gJ0AvSGVscGVycy9QcmVmaXgvUHJlZml4JztcbmltcG9ydCBEcm9wZG93bk1lbnUgZnJvbSAnLi4vRHJvcGRvd25NZW51JztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ2J1dHRvbi1kcm9wZG93bicsXG5cbiAgICBjb21wb25lbnRzOiB7XG4gICAgICAgIERyb3Bkb3duTWVudVxuICAgIH0sXG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBhcnJheSBvZiBkcm9wZG93biBpdGVtcy4gSWYgYW4ga2V5L3ZhbHVlIHBhaXIgaXNuJ3QgZGVmaW5lZCwgdGhlXG4gICAgICAgICAqIGRlZmF1bHQgdmFsdWUgd2lsbCBiZSB1c2VkLiBJZiBubyBpdGVtcyBhcmUgZGVmaW5lZCwgdGhlbiB0aGUgc2xvdFxuICAgICAgICAgKiBuYW1lZCBcIml0ZW1zXCIgY2FuIGJlIHVzZWQgdG8gZGVmaW5lIHRoZSBvcHRpb25zIHdpdGggSFRNTC5cbiAgICAgICAgICpcbiAgICAgICAgICogW3tcbiAgICAgICAgICogICAgICB0eXBlOiAnaXRlbScsIC8vIFN0cmluZyBbaXRlbXxoZWFkZXJ8ZGl2aWRlcl1cbiAgICAgICAgICogICAgICBocmVmOiAnIycsIC8vIFN0cmluZ1xuICAgICAgICAgKiAgICAgIGxhYmVsOiAnU29tZSBsYWJlbCcsIC8vIFN0cmluZ1xuICAgICAgICAgKiAgICAgIG9uQ2xpY2s6IChldmVudCkgPT4ge30gLy8gRnVuY3Rpb25cbiAgICAgICAgICogfV1cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IEFycmF5XG4gICAgICAgICAqL1xuICAgICAgICBpdGVtczogQXJyYXksXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBgaHJlZmAgYXR0cmlidXRlIG9uIHRoZSBhY3Rpb24gYnV0dG9uIChpZiBhIHNwbGl0IGJ1dHRvbikuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGhyZWY6IFN0cmluZyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGJ1dHRvbiBpY29uIHRoYXQgYXBwZWFycyBiZWZvcmUgdGhlIGxhYmVsLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBpY29uOiBTdHJpbmcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0b2dnbGUgYnV0dG9uJ3MgbGFiZWwuIElmIG5vdCBkZWZpbmVkIGFzIGFuIGF0dHJpYnV0ZSxcbiAgICAgICAgICogeW91IGNhbiBvdmVycmlkZSB3aXRoIHRoZSBjb21wb25lbnQncyBzbG90IChpbm5lciBodG1sKS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgbGFiZWw6IFN0cmluZyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGBpZGAgYXR0cmlidXRlIG9uIHRoZSB0b2dnbGUgYnV0dG9uIGFuZCBhcmlhIGxhYmVsLiBJZiBubyBgaWRgIGlzXG4gICAgICAgICAqIGRlZmluZWQsIHRoZW4gYSBVVUlEIHdpbGwgYmUgZ2VuZXJhdGVkIGluc3RlYWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGlkOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiB1dWlkXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBgdHlwZWAgYXR0cmlidXRlIG9uIHRoZSB0b2dnbGUgYnV0dG9uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdidXR0b24nXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzaXplIGNsYXNzIG9mIHRoZSB0b2dnbGUgYnV0dG9uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHNpemU6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdtZCdcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRvZ2dsZSBidXR0b24ncyB2YXJpYW50IGNsYXNzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICB2YXJpYW50OiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAncHJpbWFyeSdcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzcGxheSB0aGUgZHJvcGRvd24gbWVudSBhbGlnbmVkIGxlZnQgb3IgcmlnaHRcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgYWxpZ246IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdsZWZ0JyxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsnbGVmdCcsICdyaWdodCddLmluZGV4T2YodmFsdWUudG9Mb3dlckNhc2UoKSkgIT09IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwbGF5IHRoZSBkcm9wZG93biBidXR0b24gd2l0aCBhIHNwbGl0IHRvZ2dsZSBidXR0b24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBCb29sZWFuXG4gICAgICAgICAqL1xuICAgICAgICBzcGxpdDoge1xuICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc3BsYXkgYXMgYSBkcm9wdXAgaW5zdGVhZCBvZiBhIGRyb3Bkb3duLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgQm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgZHJvcHVwOiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzcGxheSBhcyBhIGRyb3ByaWdodCBpbnN0ZWFkIG9mIGEgZHJvcGRvd24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBCb29sZWFuXG4gICAgICAgICAqL1xuICAgICAgICBkcm9wcmlnaHQ6IHtcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwbGF5IGFzIGEgZHJvcGxlZnQgaW5zdGVhZCBvZiBhIGRyb3Bkb3duLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgQm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgZHJvcGxlZnQ6IHtcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgbWV0aG9kczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUb2dnbGUgdGhlIGRyb3Bkb3duIG1lbnVcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB2b2lkXG4gICAgICAgICAqL1xuICAgICAgICB0b2dnbGUoKSB7XG4gICAgICAgICAgICAhdGhpcy5pc0Ryb3Bkb3duU2hvd2luZyA/IHRoaXMuc2hvdygpIDogdGhpcy5oaWRlKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3cgdGhlIGRyb3Bkb3duIG1lbnVcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB2b2lkXG4gICAgICAgICAqL1xuICAgICAgICBzaG93KCkge1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgndG9nZ2xlJywgdGhpcy5pc0Ryb3Bkb3duU2hvd2luZyA9IHRydWUpO1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgnc2hvdycpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIaWRlIHRoZSBkcm9wZG93biBtZW51XG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAgICAgKi9cbiAgICAgICAgaGlkZSgpIHtcbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ3RvZ2dsZScsIHRoaXMuaXNEcm9wZG93blNob3dpbmcgPSBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCdoaWRlJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIHRoZSBgY2xpY2tgIGV2ZW50IGZvciB0aGUgYWN0aW9uIGJ1dHRvblxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgICAgICovXG4gICAgICAgIG9uQ2xpY2soZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgnY2xpY2snLCBldmVudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIHRoZSBgYmx1cmAgZXZlbnQgZm9yIHRoZSBhY3Rpb24gYnV0dG9uXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAgICAgKi9cbiAgICAgICAgb25CbHVyKGV2ZW50KSB7XG4gICAgICAgICAgICBpZighdGhpcy4kZWwuY29udGFpbnMoZXZlbnQucmVsYXRlZFRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBjYWxsYmFjayBmdW5jdGlvbiBmb3IgdGhlIGBpdGVtOmNsaWNrYCBldmVudCBmb3IgdGhlIGFjdGlvbiBidXR0b25cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB2b2lkXG4gICAgICAgICAqL1xuICAgICAgICBvbkl0ZW1DbGljayhldmVudCwgY2hpbGQpIHtcbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2l0ZW06Y2xpY2snLCBldmVudCwgY2hpbGQpO1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgY29tcHV0ZWQ6IHtcblxuICAgICAgICBhY3Rpb25DbGFzc2VzKCkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAnYnRuJyxcbiAgICAgICAgICAgICAgICBwcmVmaXgodGhpcy5zaXplLCAnYnRuJyksXG4gICAgICAgICAgICAgICAgcHJlZml4KHRoaXMudmFyaWFudCwgJ2J0bicpXG4gICAgICAgICAgICBdLmpvaW4oJyAnKTtcbiAgICAgICAgfSxcblxuICAgICAgICB0b2dnbGVDbGFzc2VzKCkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAnYnRuJyxcbiAgICAgICAgICAgICAgICAnZHJvcGRvd24tdG9nZ2xlJyxcbiAgICAgICAgICAgICAgICBwcmVmaXgodGhpcy5zaXplLCAnYnRuJyksXG4gICAgICAgICAgICAgICAgcHJlZml4KHRoaXMudmFyaWFudCwgJ2J0bicpLFxuICAgICAgICAgICAgICAgICh0aGlzLnNwbGl0ID8gJ2Ryb3Bkb3duLXRvZ2dsZS1zcGxpdCcgOiAnJyksXG4gICAgICAgICAgICBdLmpvaW4oJyAnKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNEcm9wZG93blNob3dpbmc6IGZhbHNlXG4gICAgICAgIH07XG4gICAgfVxuXG59XG5cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IEJ1dHRvbkRyb3Bkb3duIGZyb20gJy4vQnV0dG9uRHJvcGRvd24nO1xuaW1wb3J0IFZ1ZUluc3RhbGxlciBmcm9tICdAL0hlbHBlcnMvVnVlSW5zdGFsbGVyL1Z1ZUluc3RhbGxlcic7XG5cbmNvbnN0IHBsdWdpbiA9IFZ1ZUluc3RhbGxlci51c2Uoe1xuXG4gICAgaW5zdGFsbChWdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgVnVlSW5zdGFsbGVyLmNvbXBvbmVudHMoe1xuICAgICAgICAgICAgQnV0dG9uRHJvcGRvd25cbiAgICAgICAgfSk7XG4gICAgfVxuXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uRHJvcGRvd247XG4iLCJleHBvcnQgZGVmYXVsdCB7XG5cbiAgICBtZXRob2RzOiB7XG5cbiAgICAgICAgZ2V0U2xvdChzbG90KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kc2xvdHNbc2xvdF07XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFzU2xvdChzbG90KSB7XG4gICAgICAgICAgICByZXR1cm4gISF0aGlzLiRzbG90c1tzbG90XTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYXNTbG90cyhzbG90cykge1xuICAgICAgICAgICAgZm9yKGxldCBpIGluIHNsb3RzKSB7XG4gICAgICAgICAgICAgICAgaWYoIXRoaXMuaGFzU2xvdChzbG90c1tpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGNvbXB1dGVkOiB7XG5cbiAgICAgICAgaGFzRGVmYXVsdFNsb3QoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYXNTbG90KCdkZWZhdWx0Jyk7XG4gICAgICAgIH1cblxuICAgIH1cblxufVxuIiwiPHRlbXBsYXRlPlxuXG4gICAgPGRpdiA6Y2xhc3M9XCIkbWVyZ2VDbGFzc2VzKGNsYXNzTmFtZSwgY29sb3JhYmxlQ2xhc3NlcylcIj5cbiAgICAgICAgPHNsb3QvPlxuICAgIDwvZGl2PlxuXG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IEhhc1Nsb3RzIGZyb20gJ0AvTWl4aW5zL0hhc1Nsb3RzL0hhc1Nsb3RzJztcbmltcG9ydCBDb2xvcmFibGUgZnJvbSAnQC9NaXhpbnMvQ29sb3JhYmxlL0NvbG9yYWJsZSc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdjYXJkJyxcblxuICAgIG1peGluczogW1xuICAgICAgICBIYXNTbG90cyxcbiAgICAgICAgQ29sb3JhYmxlXG4gICAgXSxcblxuICAgIGNvbXB1dGVkOiB7XG5cbiAgICAgICAgY2xhc3NOYW1lKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJG9wdGlvbnMubmFtZVxuICAgICAgICB9XG5cbiAgICB9XG5cbn1cblxuPC9zY3JpcHQ+XG4iLCI8c2NyaXB0PlxuaW1wb3J0IENhcmQgZnJvbSAnLi9DYXJkJztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ2NhcmQtYm9keScsXG5cbiAgICBleHRlbmRzOiBDYXJkXG5cbn1cblxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG5cbiAgICA8Y29tcG9uZW50IDppcz1cImVsZW1lbnRcIiA6Y2xhc3M9XCIkbWVyZ2VDbGFzc2VzKGNsYXNzTmFtZSwgY29sb3JhYmxlQ2xhc3NlcylcIj5cbiAgICAgICAgPHNsb3QvPlxuICAgIDwvY29tcG9uZW50PlxuXG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IENhcmQgZnJvbSAnLi9DYXJkJztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ2NhcmQtaGVhZGVyJyxcblxuICAgIGV4dGVuZHM6IENhcmQsXG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYWx0IGF0dHJpYnV0ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBlbGVtZW50OiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAnZGl2J1xuICAgICAgICB9XG5cbiAgICB9XG5cbn1cblxuPC9zY3JpcHQ+XG4iLCI8c2NyaXB0PlxuaW1wb3J0IENhcmRIZWFkZXIgZnJvbSAnLi9DYXJkSGVhZGVyJztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ2NhcmQtZm9vdGVyJyxcblxuICAgIGV4dGVuZHM6IENhcmRIZWFkZXJcblxufVxuXG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cblxuICAgIDxpbWcgdi1pZj1cIiFoYXNEZWZhdWx0U2xvdFwiIDpjbGFzcz1cImNsYXNzTmFtZVwiIDpzcmM9XCJzcmNcIiA6YWx0PVwiYWx0XCIvPlxuXG4gICAgPGRpdiB2LWVsc2UgOmNsYXNzPVwiY2xhc3NOYW1lXCI+XG4gICAgICAgIDxzbG90Lz5cbiAgICA8L2Rpdj5cblxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBDYXJkIGZyb20gJy4vQ2FyZCc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdjYXJkLWltZycsXG5cbiAgICBleHRlbmRzOiBDYXJkLFxuXG4gICAgcHJvcHM6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGFsdCBhdHRyaWJ1dGVcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgYWx0OiBTdHJpbmcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzcmMgYXR0cmlidXRlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHNyYzogU3RyaW5nXG5cbiAgICB9XG5cbn1cblxuPC9zY3JpcHQ+XG4iLCI8c2NyaXB0PlxuaW1wb3J0IENhcmRJbWcgZnJvbSAnLi9DYXJkSW1nJztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ2NhcmQtaW1nLXRvcCcsXG5cbiAgICBleHRlbmRzOiBDYXJkSW1nXG59XG5cbjwvc2NyaXB0PlxuIiwiPHNjcmlwdD5cbmltcG9ydCBDYXJkSW1nIGZyb20gJy4vQ2FyZEltZyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdjYXJkLWltZy1ib3R0b20nLFxuXG4gICAgZXh0ZW5kczogQ2FyZEltZ1xuXG59XG48L3NjcmlwdD5cbiIsIjxzY3JpcHQ+XG5pbXBvcnQgQ2FyZCBmcm9tICcuL0NhcmQnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAnY2FyZC1pbWctb3ZlcmxheScsXG5cbiAgICBleHRlbmRzOiBDYXJkXG5cbn1cblxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG5cbiAgICA8YSA6aHJlZj1cImhyZWZcIiA6Y2xhc3M9XCIkbWVyZ2VDbGFzc2VzKGNsYXNzTmFtZSwgY29sb3JhYmxlQ2xhc3NlcylcIiBAY2xpY2s9XCJvbkNsaWNrXCI+XG4gICAgICAgIDxzbG90Lz5cbiAgICA8L2g2PlxuXG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IENhcmQgZnJvbSAnLi9DYXJkJztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ2NhcmQtdGl0bGUnLFxuXG4gICAgZXh0ZW5kczogQ2FyZCxcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhbHQgYXR0cmlidXRlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGFsdDogU3RyaW5nLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc3JjIGF0dHJpYnV0ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBocmVmOiBTdHJpbmdcblxuICAgIH0sXG5cbiAgICBtZXRob2RzOiB7XG5cbiAgICAgICAgb25DbGljayhldmVudCkge1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgnY2xpY2snLCBldmVudCwgdGhpcyk7XG4gICAgICAgIH1cblxuICAgIH1cblxufVxuXG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cblxuICAgIDxoNiA6Y2xhc3M9XCIkbWVyZ2VDbGFzc2VzKGNsYXNzTmFtZSwgY29sb3JhYmxlQ2xhc3NlcylcIj5cbiAgICAgICAgPHNsb3QvPlxuICAgIDwvaDY+XG5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgQ2FyZCBmcm9tICcuL0NhcmQnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAnY2FyZC1zdWJ0aXRsZScsXG5cbiAgICBleHRlbmRzOiBDYXJkXG5cbn1cblxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG5cbiAgICA8aDUgOmNsYXNzPVwiJG1lcmdlQ2xhc3NlcyhjbGFzc05hbWUsIGNvbG9yYWJsZUNsYXNzZXMpXCI+XG4gICAgICAgIDxzbG90Lz5cbiAgICA8L2g1PlxuXG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IENhcmQgZnJvbSAnLi9DYXJkJztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ2NhcmQtdGl0bGUnLFxuXG4gICAgbWl4aW5zOiBbXG4gICAgICAgIENhcmRcbiAgICBdXG5cbn1cblxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgQ2FyZCBmcm9tICcuL0NhcmQnO1xuaW1wb3J0IENhcmRCb2R5IGZyb20gJy4vQ2FyZEJvZHknO1xuaW1wb3J0IENhcmRGb290ZXIgZnJvbSAnLi9DYXJkRm9vdGVyJztcbmltcG9ydCBDYXJkSGVhZGVyIGZyb20gJy4vQ2FyZEhlYWRlcic7XG5pbXBvcnQgQ2FyZEltZyBmcm9tICcuL0NhcmRJbWcnO1xuaW1wb3J0IENhcmRJbWdUb3AgZnJvbSAnLi9DYXJkSW1nVG9wJztcbmltcG9ydCBDYXJkSW1nQm90dG9tIGZyb20gJy4vQ2FyZEltZ0JvdHRvbSc7XG5pbXBvcnQgQ2FyZEltZ092ZXJsYXkgZnJvbSAnLi9DYXJkSW1nT3ZlcmxheSc7XG5pbXBvcnQgQ2FyZExpbmsgZnJvbSAnLi9DYXJkTGluayc7XG5pbXBvcnQgQ2FyZFN1YnRpdGxlIGZyb20gJy4vQ2FyZFN1YnRpdGxlJztcbmltcG9ydCBDYXJkVGl0bGUgZnJvbSAnLi9DYXJkVGl0bGUnO1xuaW1wb3J0IFZ1ZUluc3RhbGxlciBmcm9tICdAL0hlbHBlcnMvVnVlSW5zdGFsbGVyL1Z1ZUluc3RhbGxlcic7XG5cbmNvbnN0IHBsdWdpbiA9IFZ1ZUluc3RhbGxlci51c2Uoe1xuXG4gICAgaW5zdGFsbChWdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgVnVlSW5zdGFsbGVyLmNvbXBvbmVudHMoe1xuICAgICAgICAgICAgQ2FyZCxcbiAgICAgICAgICAgIENhcmRCb2R5LFxuICAgICAgICAgICAgQ2FyZEZvb3RlcixcbiAgICAgICAgICAgIENhcmRIZWFkZXIsXG4gICAgICAgICAgICBDYXJkSW1nLFxuICAgICAgICAgICAgQ2FyZEltZ1RvcCxcbiAgICAgICAgICAgIENhcmRJbWdCb3R0b20sXG4gICAgICAgICAgICBDYXJkSW1nT3ZlcmxheSxcbiAgICAgICAgICAgIENhcmRMaW5rLFxuICAgICAgICAgICAgQ2FyZFN1YnRpdGxlLFxuICAgICAgICAgICAgQ2FyZFRpdGxlXG4gICAgICAgIH0pO1xuICAgIH1cblxufSk7XG5cbmV4cG9ydCAqIGZyb20gJy4vQ2FyZEJvZHknO1xuZXhwb3J0ICogZnJvbSAnLi9DYXJkRm9vdGVyJztcbmV4cG9ydCAqIGZyb20gJy4vQ2FyZEhlYWRlcic7XG5leHBvcnQgKiBmcm9tICcuL0NhcmRJbWcnO1xuZXhwb3J0ICogZnJvbSAnLi9DYXJkSW1nVG9wJztcbmV4cG9ydCAqIGZyb20gJy4vQ2FyZEltZ0JvdHRvbSc7XG5leHBvcnQgKiBmcm9tICcuL0NhcmRJbWdPdmVybGF5JztcbmV4cG9ydCAqIGZyb20gJy4vQ2FyZExpbmsnO1xuZXhwb3J0ICogZnJvbSAnLi9DYXJkU3VidGl0bGUnO1xuZXhwb3J0ICogZnJvbSAnLi9DYXJkVGl0bGUnO1xuZXhwb3J0IGRlZmF1bHQgQ2FyZDtcbiIsImltcG9ydCB7IGVhY2ggfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgbWVyZ2UgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgZXh0ZW5kIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IGlzQXJyYXkgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgaXNPYmplY3QgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgY2FtZWxDYXNlIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IGlzVW5kZWZpbmVkIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBwcmVmaXggZnJvbSAnQC9IZWxwZXJzL1ByZWZpeC9QcmVmaXgnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZmllbGQgaWQgYXR0cmlidXRlIHZhbHVlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBpZDogW051bWJlciwgU3RyaW5nXSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHZhbHVlIG9mIGxhYmVsIGVsZW1lbnQuIElmIG5vIHZhbHVlLCBubyBsYWJlbCB3aWxsIGFwcGVhci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgbGFiZWw6IFtOdW1iZXIsIFN0cmluZ10sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBmaWVsZCBuYW1lIGF0dHJpYnV0ZSB2YWx1ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgbmFtZTogU3RyaW5nLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZmllbGQgaWQgYXR0cmlidXRlIHZhbHVlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgZGVmYXVsdDogbnVsbFxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcGxhY2Vob2xkZXIgYXR0cmlidXRlIHZhbHVlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBwbGFjZWhvbGRlcjogU3RyaW5nLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJcyB0aGUgZmllbGQgcmVxdWlyZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHJlcXVpcmVkOiBCb29sZWFuLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgZm9ybS1ncm91cCB3cmFwcGVyIHRvIGlucHV0XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGdyb3VwOiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHJlZ2V4IHBhdHRlcm4gZm9yIHZhbGlkYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHBhdHRlcm46IFN0cmluZyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gaW5saW5lIGZpZWxkIHZhbGlkYXRpb24gZXJyb3IuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmd8Qm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgZXJyb3I6IFN0cmluZyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gaW5saW5lIGZpZWxkIHZhbGlkYXRpb24gZXJyb3JzIHBhc3NlZCBhcyBvYmplY3Qgd2l0aCBrZXkvdmFsdWVcbiAgICAgICAgICogcGFpcnMuIElmIGVycm9ycyBwYXNzZWQgYXMgYW4gb2JqZWN0LCB0aGUgZm9ybSBuYW1lIHdpbGwgYmUgdXNlZCBmb3JcbiAgICAgICAgICogdGhlIGtleS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IE9iamVjdHxCb29sZWFuXG4gICAgICAgICAqL1xuICAgICAgICBlcnJvcnM6IFtPYmplY3QsIEFycmF5XSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU29tZSBmZWVkYmFjayB0byBhZGQgdG8gdGhlIGZpZWxkIG9uY2UgdGhlIGZpZWxkIGlzIHN1Y2Nlc3NmdWxseVxuICAgICAgICAgKiB2YWxpZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgZmVlZGJhY2s6IFtTdHJpbmcsIEFycmF5XSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gYXJyYXkgb2YgZXZlbnQgbmFtZXMgdGhhdCBjb3JyZWxhdGUgd2l0aCBjYWxsYmFjayBmdW5jdGlvbnNcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IEZ1bmN0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBiaW5kRXZlbnRzOiB7XG4gICAgICAgICAgICB0eXBlOiBBcnJheSxcbiAgICAgICAgICAgIGRlZmF1bHQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsnZm9jdXMnLCAnYmx1cicsICdjaGFuZ2UnLCAnY2xpY2snLCAna2V5dXAnLCAna2V5ZG93bicsICdwcm9ncmVzcyddO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGVmYXVsdCBjbGFzcyBuYW1lIGFzc2lnbmVkIHRvIHRoZSBjb250cm9sIGVsZW1lbnRcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgZGVmYXVsdENvbnRyb2xDbGFzczoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJ2Zvcm0tY29udHJvbCdcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSGlkZSB0aGUgbGFiZWwgZm9yIGJyb3dzZXJzLCBidXQgbGVhdmUgaXQgZm9yIHNjcmVlbiByZWFkZXJzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBoaWRlTGFiZWw6IEJvb2xlYW4sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZGl0aW9uYWwgbWFyZ2luL3BhZGRpbmcgY2xhc3NlcyBmb3IgZmluZSBjb250cm9sIG9mIHNwYWNpbmdcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgc3BhY2luZzogU3RyaW5nLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc2l6ZSBvZiB0aGUgZm9ybSBjb250cm9sXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHNpemU6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdtZCcsXG4gICAgICAgICAgICB2YWxpZGF0ZTogdmFsdWUgPT4gWydzbScsICdtZCcsICdsZyddLmluZGV4T2YodmFsdWUpICE9PSAtMVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwbGF5IHRoZSBmb3JtIGZpZWxkIGlubGluZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBpbmxpbmU6IEJvb2xlYW4sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoZSBmb3JtIGNvbnRyb2wgaXMgcmVhZG9ubHksIGRpc3BsYXkgb25seSBhcyB0ZXh0P1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBwbGFpbnRleHQ6IEJvb2xlYW4sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElzIHRoZSBmb3JtIGNvbnRyb2wgcmVhZG9ubHk/XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHJlYWRvbmx5OiBCb29sZWFuLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJcyB0aGUgZm9ybSBjb250cm9sIGRpc2FibGVkP1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBkaXNhYmxlZDogQm9vbGVhbixcblxuICAgICAgICAvKipcbiAgICAgICAgICogU29tZSBpbnN0cnVjdGlvbnMgdG8gYXBwZWFyIHVuZGVyIHRoZSBmaWVsZCBsYWJlbFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBoZWxwVGV4dDogU3RyaW5nLFxuXG4gICAgfSxcblxuICAgIGRpcmVjdGl2ZXM6IHtcbiAgICAgICAgYmluZEV2ZW50czoge1xuICAgICAgICAgICAgYmluZChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBldmVudHMgPSBiaW5kaW5nLnZhbHVlIHx8IHZub2RlLmNvbnRleHQuYmluZEV2ZW50cztcblxuICAgICAgICAgICAgICAgIGVhY2goZXZlbnRzLCBuYW1lID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2bm9kZS5jb250ZXh0LiRlbWl0KG5hbWUsIGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWV0aG9kczoge1xuXG4gICAgICAgIGdldElucHV0RmllbGQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kZWwucXVlcnlTZWxlY3RvcignLmZvcm0tY29udHJvbCwgaW5wdXQsIHNlbGVjdCwgdGV4dGFyZWEnKTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRGaWVsZEVycm9ycygpIHtcbiAgICAgICAgICAgIGxldCBlcnJvcnMgPSB0aGlzLmVycm9yIHx8IHRoaXMuZXJyb3JzO1xuXG4gICAgICAgICAgICBpZihpc09iamVjdCh0aGlzLmVycm9ycykpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMgPSB0aGlzLmVycm9yc1t0aGlzLm5hbWUgfHwgdGhpcy5pZF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAhZXJyb3JzIHx8IGlzQXJyYXkoZXJyb3JzKSB8fCBpc09iamVjdChlcnJvcnMpID8gZXJyb3JzIDogW2Vycm9yc107XG4gICAgICAgIH0sXG5cbiAgICAgICAgdXBkYXRlZCh2YWx1ZSwgZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuJGVtaXQoZXZlbnQgfHwgJ2lucHV0JywgdmFsdWUpO1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgY29tcHV0ZWQ6IHtcblxuICAgICAgICBjYWxsYmFja3MoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iaW5kRXZlbnRzLm1hcChldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiB0aGlzW2NhbWVsQ2FzZShbJ29uJywgZXZlbnRdLmpvaW4oJyAnKSldXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkuZmlsdGVyKGV2ZW50ID0+ICFpc1VuZGVmaW5lZChldmVudC5jYWxsYmFjaykpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGludmFsaWRGZWVkYmFjaygpIHtcbiAgICAgICAgICAgIGlmKHRoaXMuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgZXJyb3JzID0gdGhpcy5nZXRGaWVsZEVycm9ycygpO1xuXG4gICAgICAgICAgICByZXR1cm4gaXNBcnJheShlcnJvcnMpID8gZXJyb3JzLmpvaW4oJzxicj4nKSA6IGVycm9ycztcbiAgICAgICAgfSxcblxuICAgICAgICB2YWxpZEZlZWRiYWNrKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5mZWVkYmFjaykgPyB0aGlzLmZlZWRiYWNrLmpvaW4oJzxicj4nKSA6IHRoaXMuZmVlZGJhY2s7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29udHJvbENsYXNzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdENvbnRyb2xDbGFzcyArICh0aGlzLnBsYWludGV4dCA/ICctcGxhaW50ZXh0JyA6ICcnKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjb250cm9sU2l6ZUNsYXNzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHByZWZpeCh0aGlzLnNpemUsIHRoaXMuY29udHJvbENsYXNzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjb250cm9sQ2xhc3NlcygpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgdGhpcy5jb250cm9sQ2xhc3MsXG4gICAgICAgICAgICAgICAgdGhpcy5jb250cm9sU2l6ZUNsYXNzLFxuICAgICAgICAgICAgICAgICh0aGlzLnNwYWNpbmcgfHwgJycpLFxuICAgICAgICAgICAgICAgICh0aGlzLmludmFsaWRGZWVkYmFjayA/ICdpcy1pbnZhbGlkJyA6ICcnKVxuICAgICAgICAgICAgXS5qb2luKCcgJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFzRGVmYXVsdFNsb3QgKCkge1xuICAgICAgICAgICAgcmV0dXJuICEhdGhpcy4kc2xvdHMuZGVmYXVsdFxuICAgICAgICB9XG5cbiAgICB9XG5cbn1cbiIsIjx0ZW1wbGF0ZT5cblxuICAgIDxkaXYgOmNsYXNzPVwiJG1lcmdlQ2xhc3Nlcyhjb250cm9sQ2xhc3MsIGN1c3RvbUNvbnRyb2xDbGFzcywgc2l6ZWFibGVDbGFzcywgaW5saW5lID8gaW5saW5lQ2xhc3MgOiAnJylcIj5cblxuICAgICAgICA8dGVtcGxhdGUgdi1pZj1cImN1c3RvbSAmJiBpZFwiPlxuICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgdi1iaW5kLWV2ZW50c1xuICAgICAgICAgICAgICAgIHR5cGU9XCJyYWRpb1wiXG4gICAgICAgICAgICAgICAgOm5hbWU9XCJuYW1lXCJcbiAgICAgICAgICAgICAgICA6aWQ9XCJpZFwiXG4gICAgICAgICAgICAgICAgOnZhbHVlPVwidmFsdWVcIlxuICAgICAgICAgICAgICAgIDpyZXF1aXJlZD1cInJlcXVpcmVkXCJcbiAgICAgICAgICAgICAgICA6ZGlzYWJsZWQ9XCJkaXNhYmxlZCB8fCByZWFkb25seVwiXG4gICAgICAgICAgICAgICAgOnJlYWRvbmx5PVwicmVhZG9ubHlcIlxuICAgICAgICAgICAgICAgIDpwYXR0ZXJuPVwicGF0dGVyblwiXG4gICAgICAgICAgICAgICAgOmNoZWNrZWQ9XCJjaGVja2VkVmFsdWUgPT09IHZhbHVlIHx8IGNoZWNrZWRcIlxuICAgICAgICAgICAgICAgIDpjbGFzcz1cIiRtZXJnZUNsYXNzZXMoaW5wdXRDbGFzcywgKGludmFsaWRGZWVkYmFjayA/ICdpcy1pbnZhbGlkJyA6ICcnKSlcIlxuICAgICAgICAgICAgICAgIEBjaGFuZ2U9XCJ1cGRhdGVkKCRldmVudC50YXJnZXQudmFsdWUsICdjaGFuZ2UnKVwiPlxuXG4gICAgICAgICAgICA8bGFiZWwgOmZvcj1cImlkXCIgOmNsYXNzPVwiJG1lcmdlQ2xhc3NlcyhsYWJlbENsYXNzLCBjb2xvcmFibGVDbGFzc2VzKVwiPlxuICAgICAgICAgICAgICAgIDxzbG90Pnt7bGFiZWx9fTwvc2xvdD5cbiAgICAgICAgICAgICAgICA8c2xvdCBuYW1lPVwiZmVlZGJhY2tcIj5cbiAgICAgICAgICAgICAgICAgICAgPGZvcm0tZmVlZGJhY2sgdi1pZj1cInZhbGlkRmVlZGJhY2tcIiB2LWh0bWw9XCJ2YWxpZEZlZWRiYWNrXCIgdmFsaWQgLz5cbiAgICAgICAgICAgICAgICAgICAgPGZvcm0tZmVlZGJhY2sgdi1pZj1cImludmFsaWRGZWVkYmFja1wiIHYtaHRtbD1cImludmFsaWRGZWVkYmFja1wiIGludmFsaWQgLz5cbiAgICAgICAgICAgICAgICA8L3Nsb3Q+XG4gICAgICAgICAgICA8L2xhYmVsPlxuXG4gICAgICAgIDwvdGVtcGxhdGU+XG4gICAgICAgIDx0ZW1wbGF0ZSB2LWVsc2U+XG4gICAgICAgICAgICA8bGFiZWwgOmZvcj1cImlkXCIgOmNsYXNzPVwiJG1lcmdlQ2xhc3NlcyhsYWJlbENsYXNzLCBjb2xvcmFibGVDbGFzc2VzKVwiPlxuICAgICAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgICAgICB2LWJpbmQtZXZlbnRzXG4gICAgICAgICAgICAgICAgICAgIHR5cGU9XCJyYWRpb1wiXG4gICAgICAgICAgICAgICAgICAgIDpuYW1lPVwibmFtZVwiXG4gICAgICAgICAgICAgICAgICAgIDppZD1cImlkXCJcbiAgICAgICAgICAgICAgICAgICAgOnZhbHVlPVwidmFsdWVcIlxuICAgICAgICAgICAgICAgICAgICA6cmVxdWlyZWQ9XCJyZXF1aXJlZFwiXG4gICAgICAgICAgICAgICAgICAgIDpkaXNhYmxlZD1cImRpc2FibGVkIHx8IHJlYWRvbmx5XCJcbiAgICAgICAgICAgICAgICAgICAgOnJlYWRvbmx5PVwicmVhZG9ubHlcIlxuICAgICAgICAgICAgICAgICAgICA6cGF0dGVybj1cInBhdHRlcm5cIlxuICAgICAgICAgICAgICAgICAgICA6Y2hlY2tlZD1cImNoZWNrZWRWYWx1ZSA9PT0gdmFsdWUgfHwgY2hlY2tlZFwiXG4gICAgICAgICAgICAgICAgICAgIDpjbGFzcz1cIiRtZXJnZUNsYXNzZXMoaW5wdXRDbGFzcywgKGludmFsaWRGZWVkYmFjayA/ICdpcy1pbnZhbGlkJyA6ICcnKSlcIlxuICAgICAgICAgICAgICAgICAgICBAY2hhbmdlPVwidXBkYXRlZCgkZXZlbnQudGFyZ2V0LnZhbHVlLCAnY2hhbmdlJylcIj5cblxuICAgICAgICAgICAgICAgIDxzbG90Pnt7bGFiZWx9fTwvc2xvdD5cblxuICAgICAgICAgICAgICAgIDxzbG90IG5hbWU9XCJmZWVkYmFja1wiPlxuICAgICAgICAgICAgICAgICAgICA8Zm9ybS1mZWVkYmFjayB2LWlmPVwidmFsaWRGZWVkYmFja1wiIHYtaHRtbD1cInZhbGlkRmVlZGJhY2tcIiB2YWxpZCAvPlxuICAgICAgICAgICAgICAgICAgICA8Zm9ybS1mZWVkYmFjayB2LWlmPVwiaW52YWxpZEZlZWRiYWNrXCIgdi1odG1sPVwiaW52YWxpZEZlZWRiYWNrXCIgaW52YWxpZCAvPlxuICAgICAgICAgICAgICAgIDwvc2xvdD5cbiAgICAgICAgICAgIDwvbGFiZWw+XG4gICAgICAgIDwvdGVtcGxhdGU+XG5cbiAgICAgICAgPHNsb3QgbmFtZT1cImhlbHBcIj5cbiAgICAgICAgICAgIDxoZWxwLXRleHQgdi1pZj1cImhlbHBUZXh0XCIgdi1odG1sPVwiaGVscFRleHRcIiAvPlxuICAgICAgICA8L3Nsb3Q+XG4gICAgPC9kaXY+XG5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5cbmltcG9ydCBwcmVmaXggZnJvbSAnQC9IZWxwZXJzL1ByZWZpeC9QcmVmaXgnO1xuaW1wb3J0IENvbG9yYWJsZSBmcm9tICdAL01peGlucy9Db2xvcmFibGUvQ29sb3JhYmxlJztcbmltcG9ydCBGb3JtQ29udHJvbCBmcm9tICdAL01peGlucy9Gb3JtQ29udHJvbC9Gb3JtQ29udHJvbCc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdyYWRpby1maWVsZCcsXG5cbiAgICBtaXhpbnM6IFtcbiAgICAgICAgQ29sb3JhYmxlLFxuICAgICAgICBGb3JtQ29udHJvbFxuICAgIF0sXG5cbiAgICBtb2RlbDoge1xuICAgICAgICBldmVudDogJ2NoYW5nZScsXG4gICAgICAgIHByb3A6ICdjaGVja2VkVmFsdWUnXG4gICAgfSxcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGFycmF5IG9mIGV2ZW50IG5hbWVzIHRoYXQgY29ycmVsYXRlIHdpdGggY2FsbGJhY2sgZnVuY3Rpb25zXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBGdW5jdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgYmluZEV2ZW50czoge1xuICAgICAgICAgICAgdHlwZTogQXJyYXksXG4gICAgICAgICAgICBkZWZhdWx0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbJ2ZvY3VzJywgJ2JsdXInLCAnaW5wdXQnLCAnY2xpY2snLCAna2V5dXAnLCAna2V5ZG93bicsICdwcm9ncmVzcyddO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJcyB0aGlzIGEgY3VzdG9tIGVsZW1lbnRcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgY3VzdG9tOiBCb29sZWFuLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwbGF5IHRoZSBmb3JtIGZpZWxkIGFuZCBsYWJlbCBpbmxpbmVcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IEZ1bmN0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBpbmxpbmU6IEJvb2xlYW4sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjaGVja2VkIHZhbHVlc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBjaGVja2VkOiBCb29sZWFuLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY2hlY2tlZCB2YWx1ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBjaGVja2VkVmFsdWU6IFtCb29sZWFuLCBOdW1iZXIsIFN0cmluZywgT2JqZWN0XSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNsYXNzIG5hbWUgYXNzaWduZWQgdG8gdGhlIGNvbnRyb2wgZWxlbWVudFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBkZWZhdWx0Q29udHJvbENsYXNzOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAnZm9ybS1jaGVjaydcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGNvbXB1dGVkOiB7XG5cbiAgICAgICAgbGFiZWxDbGFzcygpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmVmaXgoJ2xhYmVsJywgdGhpcy5jb250cm9sQ2xhc3MpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGlucHV0Q2xhc3MoKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJlZml4KCdpbnB1dCcsIHRoaXMuY29udHJvbENsYXNzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpbmxpbmVDbGFzcygpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmVmaXgoJ2lubGluZScsIHRoaXMuY29udHJvbENsYXNzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjb250cm9sQ2xhc3MoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jdXN0b20gPyAnY3VzdG9tLWNvbnRyb2wnIDogdGhpcy5kZWZhdWx0Q29udHJvbENsYXNzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGN1c3RvbUNvbnRyb2xDbGFzcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmN1c3RvbSA/IHByZWZpeCh0aGlzLiRvcHRpb25zLm5hbWUucmVwbGFjZSgnLWZpZWxkJywgJycpLCAnY3VzdG9tJykgOiAnJztcbiAgICAgICAgfSxcblxuICAgICAgICBzaXplYWJsZUNsYXNzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHByZWZpeCh0aGlzLnNpemUsICdmb3JtLWNvbnRyb2wnKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG59XG5cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuXG4gICAgPGRpdiA6Y2xhc3M9XCIkbWVyZ2VDbGFzc2VzKGNvbnRyb2xDbGFzcywgY3VzdG9tQ29udHJvbENsYXNzLCBzaXplYWJsZUNsYXNzLCBpbmxpbmUgPyBpbmxpbmVDbGFzcyA6ICcnKVwiPlxuXG4gICAgICAgIDx0ZW1wbGF0ZSB2LWlmPVwiY3VzdG9tICYmIGlkXCI+XG4gICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICB2LWJpbmQtZXZlbnRzXG4gICAgICAgICAgICAgICAgdHlwZT1cImNoZWNrYm94XCJcbiAgICAgICAgICAgICAgICA6bmFtZT1cIm5hbWVcIlxuICAgICAgICAgICAgICAgIDppZD1cImlkXCJcbiAgICAgICAgICAgICAgICA6dmFsdWU9XCJ2YWx1ZVwiXG4gICAgICAgICAgICAgICAgOnJlcXVpcmVkPVwicmVxdWlyZWRcIlxuICAgICAgICAgICAgICAgIDpkaXNhYmxlZD1cImRpc2FibGVkIHx8IHJlYWRvbmx5XCJcbiAgICAgICAgICAgICAgICA6cmVhZG9ubHk9XCJyZWFkb25seVwiXG4gICAgICAgICAgICAgICAgOnBhdHRlcm49XCJwYXR0ZXJuXCJcbiAgICAgICAgICAgICAgICA6Y2hlY2tlZD1cImNoZWNrZWRWYWx1ZSA9PT0gdmFsdWUgfHwgY2hlY2tlZFwiXG4gICAgICAgICAgICAgICAgOmNsYXNzPVwiJG1lcmdlQ2xhc3NlcyhpbnB1dENsYXNzLCAoaW52YWxpZEZlZWRiYWNrID8gJ2lzLWludmFsaWQnIDogJycpKVwiXG4gICAgICAgICAgICAgICAgQGNoYW5nZT1cInVwZGF0ZWQoJGV2ZW50LnRhcmdldC52YWx1ZSwgJ2NoYW5nZScpXCI+XG5cbiAgICAgICAgICAgIDxsYWJlbCA6Zm9yPVwiaWRcIiA6Y2xhc3M9XCIkbWVyZ2VDbGFzc2VzKGxhYmVsQ2xhc3MsIGNvbG9yYWJsZUNsYXNzZXMpXCI+XG4gICAgICAgICAgICAgICAgPHNsb3Q+e3tsYWJlbH19PC9zbG90PlxuICAgICAgICAgICAgICAgIDxzbG90IG5hbWU9XCJmZWVkYmFja1wiPlxuICAgICAgICAgICAgICAgICAgICA8Zm9ybS1mZWVkYmFjayB2LWlmPVwidmFsaWRGZWVkYmFja1wiIHYtaHRtbD1cInZhbGlkRmVlZGJhY2tcIiB2YWxpZCAvPlxuICAgICAgICAgICAgICAgICAgICA8Zm9ybS1mZWVkYmFjayB2LWlmPVwiaW52YWxpZEZlZWRiYWNrXCIgdi1odG1sPVwiaW52YWxpZEZlZWRiYWNrXCIgaW52YWxpZCAvPlxuICAgICAgICAgICAgICAgIDwvc2xvdD5cbiAgICAgICAgICAgIDwvbGFiZWw+XG5cbiAgICAgICAgPC90ZW1wbGF0ZT5cblxuICAgICAgICA8dGVtcGxhdGUgdi1lbHNlPlxuICAgICAgICAgICAgPGxhYmVsIDpmb3I9XCJpZFwiIDpjbGFzcz1cIiRtZXJnZUNsYXNzZXMobGFiZWxDbGFzcywgY29sb3JhYmxlQ2xhc3NlcylcIj5cbiAgICAgICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICAgICAgdi1iaW5kLWV2ZW50c1xuICAgICAgICAgICAgICAgICAgICB0eXBlPVwiY2hlY2tib3hcIlxuICAgICAgICAgICAgICAgICAgICA6bmFtZT1cIm5hbWVcIlxuICAgICAgICAgICAgICAgICAgICA6aWQ9XCJpZFwiXG4gICAgICAgICAgICAgICAgICAgIDp2YWx1ZT1cInZhbHVlXCJcbiAgICAgICAgICAgICAgICAgICAgOnJlcXVpcmVkPVwicmVxdWlyZWRcIlxuICAgICAgICAgICAgICAgICAgICA6ZGlzYWJsZWQ9XCJkaXNhYmxlZCB8fCByZWFkb25seVwiXG4gICAgICAgICAgICAgICAgICAgIDpyZWFkb25seT1cInJlYWRvbmx5XCJcbiAgICAgICAgICAgICAgICAgICAgOnBhdHRlcm49XCJwYXR0ZXJuXCJcbiAgICAgICAgICAgICAgICAgICAgOmNoZWNrZWQ9XCJjaGVja2VkVmFsdWUgPT09IHZhbHVlIHx8IGNoZWNrZWRcIlxuICAgICAgICAgICAgICAgICAgICA6Y2xhc3M9XCIkbWVyZ2VDbGFzc2VzKGlucHV0Q2xhc3MsIChpbnZhbGlkRmVlZGJhY2sgPyAnaXMtaW52YWxpZCcgOiAnJykpXCJcbiAgICAgICAgICAgICAgICAgICAgQGNoYW5nZT1cInVwZGF0ZWQoJGV2ZW50LnRhcmdldC52YWx1ZSwgJ2NoYW5nZScpXCI+XG5cbiAgICAgICAgICAgICAgICA8c2xvdD57e2xhYmVsfX08L3Nsb3Q+XG5cbiAgICAgICAgICAgICAgICA8c2xvdCBuYW1lPVwiZmVlZGJhY2tcIj5cbiAgICAgICAgICAgICAgICAgICAgPGZvcm0tZmVlZGJhY2sgdi1pZj1cInZhbGlkRmVlZGJhY2tcIiB2LWh0bWw9XCJ2YWxpZEZlZWRiYWNrXCIgdmFsaWQgLz5cbiAgICAgICAgICAgICAgICAgICAgPGZvcm0tZmVlZGJhY2sgdi1pZj1cImludmFsaWRGZWVkYmFja1wiIHYtaHRtbD1cImludmFsaWRGZWVkYmFja1wiIGludmFsaWQgLz5cbiAgICAgICAgICAgICAgICA8L3Nsb3Q+XG4gICAgICAgICAgICA8L2xhYmVsPlxuICAgICAgICA8L3RlbXBsYXRlPlxuXG4gICAgICAgIDxzbG90IG5hbWU9XCJoZWxwXCI+XG4gICAgICAgICAgICA8aGVscC10ZXh0IHYtaWY9XCJoZWxwVGV4dFwiIHYtaHRtbD1cImhlbHBUZXh0XCIgLz5cbiAgICAgICAgPC9zbG90PlxuICAgIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cblxuaW1wb3J0IFJhZGlvRmllbGQgZnJvbSAnQC9Db21wb25lbnRzL1JhZGlvRmllbGQvUmFkaW9GaWVsZCc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdjaGVja2JveC1maWVsZCcsXG5cbiAgICBleHRlbmRzOiBSYWRpb0ZpZWxkLFxuXG4gICAgcHJvcHM6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNoZWNrZWQgdmFsdWVzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGNoZWNrZWRWYWx1ZToge1xuICAgICAgICAgICAgdHlwZTogQXJyYXksXG4gICAgICAgICAgICBkZWZhdWx0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIG1ldGhvZHM6IHtcblxuICAgICAgICB1cGRhdGVkKHZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCBjaGVja2VkID0gdGhpcy5jaGVja2VkVmFsdWUuc2xpY2UoMCk7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuY2hlY2tlZFZhbHVlLmluZGV4T2YodmFsdWUpO1xuXG4gICAgICAgICAgICBpZihpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBjaGVja2VkLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hlY2tlZC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnLCBjaGVja2VkKTtcbiAgICAgICAgfVxuXG4gICAgfVxufVxuXG48L3NjcmlwdD5cbiIsImltcG9ydCBDaGVja2JveEZpZWxkIGZyb20gJy4vQ2hlY2tib3hGaWVsZCc7XG5pbXBvcnQgVnVlSW5zdGFsbGVyIGZyb20gJ0AvSGVscGVycy9WdWVJbnN0YWxsZXIvVnVlSW5zdGFsbGVyJztcblxuY29uc3QgcGx1Z2luID0gVnVlSW5zdGFsbGVyLnVzZSh7XG5cbiAgICBpbnN0YWxsKFZ1ZSwgb3B0aW9ucykge1xuICAgICAgICBWdWVJbnN0YWxsZXIuY29tcG9uZW50cyh7XG4gICAgICAgICAgICBDaGVja2JveEZpZWxkXG4gICAgICAgIH0pO1xuICAgIH1cblxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IENoZWNrYm94RmllbGQ7XG4iLCI8dGVtcGxhdGU+XG5cbiAgICA8ZGl2IGNsYXNzPVwiY29udGFpbmVyXCI+PHNsb3QvPjwvZGl2PlxuXG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuXG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdjb250YWluZXInXG5cbn1cblxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgQ29udGFpbmVyIGZyb20gJy4vQ29udGFpbmVyJztcbmltcG9ydCBWdWVJbnN0YWxsZXIgZnJvbSAnQC9IZWxwZXJzL1Z1ZUluc3RhbGxlci9WdWVJbnN0YWxsZXInO1xuXG5jb25zdCBwbHVnaW4gPSBWdWVJbnN0YWxsZXIudXNlKHtcblxuICAgIGluc3RhbGwoVnVlLCBvcHRpb25zKSB7XG4gICAgICAgIFZ1ZUluc3RhbGxlci5jb21wb25lbnRzKHtcbiAgICAgICAgICAgIENvbnRhaW5lclxuICAgICAgICB9KTtcbiAgICB9XG5cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBDb250YWluZXI7XG4iLCI8dGVtcGxhdGU+XG5cbiAgICA8Zm9ybS1ncm91cD5cblxuICAgICAgICA8c2xvdCBuYW1lPVwibGFiZWxcIj5cbiAgICAgICAgICAgIDxmb3JtLWxhYmVsIHYtaWY9XCJsYWJlbCB8fCBoYXNEZWZhdWx0U2xvdFwiIDpmb3I9XCJpZFwiPlxuICAgICAgICAgICAgICAgIDxzbG90Pnt7bGFiZWx9fTwvc2xvdD5cbiAgICAgICAgICAgIDwvZm9ybS1sYWJlbD5cbiAgICAgICAgPC9zbG90PlxuXG4gICAgICAgIDxzbG90IG5hbWU9XCJjb250cm9sXCI+XG4gICAgICAgICAgICA8Zm9ybS1jb250cm9sXG4gICAgICAgICAgICAgICAgOmlkPVwiaWRcIlxuICAgICAgICAgICAgICAgIDp0eXBlPVwidHlwZVwiXG4gICAgICAgICAgICAgICAgOnZhbHVlPVwidmFsdWVcIlxuICAgICAgICAgICAgICAgIDplcnJvcnM9XCJlcnJvcnNcIlxuICAgICAgICAgICAgICAgIDpwbGFjZWhvbGRlcj1cInBsYWNlaG9sZGVyXCJcbiAgICAgICAgICAgICAgICA6cmVxdWlyZWQ9XCJyZXF1aXJlZFwiXG4gICAgICAgICAgICAgICAgOmRpc2FibGVkPVwiZGlzYWJsZWQgfHwgcmVhZG9ubHlcIlxuICAgICAgICAgICAgICAgIDpyZWFkb25seT1cInJlYWRvbmx5XCJcbiAgICAgICAgICAgICAgICA6cGF0dGVybj1cInBhdHRlcm5cIlxuICAgICAgICAgICAgICAgIDpjbGFzcz1cIiRtZXJnZUNsYXNzZXMoY29udHJvbENsYXNzZXMsIGNvbG9yYWJsZUNsYXNzZXMpXCJcbiAgICAgICAgICAgICAgICA6YXJpYS1sYWJlbD1cImxhYmVsXCJcbiAgICAgICAgICAgICAgICA6YXJpYS1kZXNjcmliZWRieT1cImlkXCJcbiAgICAgICAgICAgICAgICB2LWJpbmQtZXZlbnRzPVwiYmluZEV2ZW50c1wiXG4gICAgICAgICAgICAgICAgdi1vbjppbnB1dD1cInVwZGF0ZWQoJGV2ZW50LnRhcmdldC52YWx1ZSlcIlxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9zbG90PlxuXG4gICAgICAgIDxzbG90IG5hbWU9XCJoZWxwXCI+XG4gICAgICAgICAgICA8aGVscC10ZXh0IHYtaWY9XCJoZWxwVGV4dFwiIHYtaHRtbD1cImhlbHBUZXh0XCIgLz5cbiAgICAgICAgPC9zbG90PlxuXG4gICAgICAgIDxzbG90IG5hbWU9XCJmZWVkYmFja1wiPlxuICAgICAgICAgICAgPGZvcm0tZmVlZGJhY2sgdi1pZj1cInZhbGlkRmVlZGJhY2tcIiB2LWh0bWw9XCJ2YWxpZEZlZWRiYWNrXCIgdmFsaWQgLz5cbiAgICAgICAgICAgIDxmb3JtLWZlZWRiYWNrIHYtaWY9XCJpbnZhbGlkRmVlZGJhY2tcIiB2LWh0bWw9XCJpbnZhbGlkRmVlZGJhY2tcIiBpbnZhbGlkIC8+XG4gICAgICAgIDwvc2xvdD5cblxuICAgIDwvZm9ybS1ncm91cD5cblxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cblxuaW1wb3J0IENvbG9yYWJsZSBmcm9tICdAL01peGlucy9Db2xvcmFibGUvQ29sb3JhYmxlJztcbmltcG9ydCBGb3JtQ29udHJvbCBmcm9tICdAL01peGlucy9Gb3JtQ29udHJvbC9Gb3JtQ29udHJvbCc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdpbnB1dC1maWVsZCcsXG5cbiAgICBtaXhpbnM6IFtcbiAgICAgICAgQ29sb3JhYmxlLFxuICAgICAgICBGb3JtQ29udHJvbFxuICAgIF0sXG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdHlwZSBhdHRyaWJ1dGVcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJ3RleHQnXG4gICAgICAgIH1cblxuICAgIH1cblxufVxuXG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cblxuICAgIDxmb3JtLWdyb3VwPlxuXG4gICAgICAgIDxzbG90IG5hbWU9XCJsYWJlbFwiPlxuICAgICAgICAgICAgPGZvcm0tbGFiZWwgdi1pZj1cImxhYmVsIHx8IGhhc0RlZmF1bHRTbG90XCIgOmZvcj1cImlkXCI+XG4gICAgICAgICAgICAgICAgPHNsb3Q+e3tsYWJlbH19PC9zbG90PlxuICAgICAgICAgICAgPC9mb3JtLWxhYmVsPlxuICAgICAgICA8L3Nsb3Q+XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cImN1c3RvbS1maWxlXCI+XG5cbiAgICAgICAgICAgIDxzbG90IG5hbWU9XCJwbGFjZWhvbGRlclwiPlxuICAgICAgICAgICAgICAgIDxmb3JtLWxhYmVsIDpjbGFzcz1cIiRtZXJnZUNsYXNzZXMoY29sb3JhYmxlQ2xhc3NlcywgJ2N1c3RvbS1maWxlLWxhYmVsJylcIiA6Zm9yPVwiaWRcIiB2LWh0bWw9XCJwbGFjZWhvbGRlciB8fCAnQ2hvb3NlIGZpbGUnXCIgLz5cbiAgICAgICAgICAgIDwvc2xvdD5cblxuICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgdi1iaW5kLWV2ZW50c1xuICAgICAgICAgICAgICAgIHR5cGU9XCJmaWxlXCJcbiAgICAgICAgICAgICAgICA6Y2xhc3M9XCJjb250cm9sQ2xhc3Nlc1wiXG4gICAgICAgICAgICAgICAgOmlkPVwiaWRcIlxuICAgICAgICAgICAgICAgIDp3aWR0aD1cIndpZHRoXCJcbiAgICAgICAgICAgICAgICA6aGVpZ2h0PVwiaGVpZ2h0XCJcbiAgICAgICAgICAgICAgICA6cmVxdWlyZWQ9XCJyZXF1aXJlZFwiXG4gICAgICAgICAgICAgICAgOm11bHRpcGxlPVwibXVsdGlwbGVcIlxuICAgICAgICAgICAgICAgIDpyZWFkb25seT1cInJlYWRvbmx5XCJcbiAgICAgICAgICAgICAgICBAY2hhbmdlPVwidXBkYXRlZCgkZXZlbnQudGFyZ2V0LmZpbGVzLCAnY2hhbmdlJylcIj5cblxuICAgICAgICAgICAgPHNsb3QgbmFtZT1cImhlbHBcIj5cbiAgICAgICAgICAgICAgICA8aGVscC10ZXh0IHYtaWY9XCJoZWxwVGV4dFwiIHYtaHRtbD1cImhlbHBUZXh0XCIgLz5cbiAgICAgICAgICAgIDwvc2xvdD5cblxuICAgICAgICAgICAgPHNsb3QgbmFtZT1cImZlZWRiYWNrXCI+XG4gICAgICAgICAgICAgICAgPGZvcm0tZmVlZGJhY2sgdi1pZj1cInZhbGlkRmVlZGJhY2tcIiB2LWh0bWw9XCJ2YWxpZEZlZWRiYWNrXCIgdmFsaWQgLz5cbiAgICAgICAgICAgICAgICA8Zm9ybS1mZWVkYmFjayB2LWlmPVwiaW52YWxpZEZlZWRiYWNrXCIgdi1odG1sPVwiaW52YWxpZEZlZWRiYWNrXCIgaW52YWxpZCAvPlxuICAgICAgICAgICAgPC9zbG90PlxuXG4gICAgICAgIDwvZGl2PlxuXG4gICAgPC9mb3JtLWdyb3VwPlxuXG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuXG5pbXBvcnQgSW5wdXRGaWVsZCBmcm9tICdAL0NvbXBvbmVudHMvSW5wdXRGaWVsZC9JbnB1dEZpZWxkJztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ2ZpbGUtZmllbGQnLFxuXG4gICAgZXh0ZW5kczogSW5wdXRGaWVsZCxcblxuICAgIG1vZGVsOiB7XG4gICAgICAgIGV2ZW50OiAnY2hhbmdlJ1xuICAgIH0sXG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBhcnJheSBvZiBldmVudCBuYW1lcyB0aGF0IGNvcnJlbGF0ZSB3aXRoIGNhbGxiYWNrIGZ1bmN0aW9uc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgRnVuY3Rpb25cbiAgICAgICAgICovXG4gICAgICAgIGJpbmRFdmVudHM6IHtcbiAgICAgICAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgICAgICAgZGVmYXVsdCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWydmb2N1cycsICdibHVyJywgJ2lucHV0JywgJ2NsaWNrJywgJ2tleXVwJywgJ2tleWRvd24nLCAncHJvZ3Jlc3MnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNsYXNzIG5hbWUgYXNzaWduZWQgdG8gdGhlIGNvbnRyb2wgZWxlbWVudFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBkZWZhdWx0Q29udHJvbENsYXNzOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAnY3VzdG9tLWZpbGUtaW5wdXQnXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGFycmF5IG9mIHZhbGlkIGV4dGVuc2lvbnNcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgZXh0ZW5zaW9uczogQXJyYXksXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0eXBlIGF0dHJpYnV0ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBtdWx0aXBsZTogQm9vbGVhbixcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGhlaWdodCBhdHRyaWJ1dGUgZm9yIHRoZSBjb250cm9sIGVsZW1lbnRcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgaGVpZ2h0OiBbTnVtYmVyLCBTdHJpbmddLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgd2lkdGggYXR0cmlidXRlIGZvciB0aGUgY29udHJvbCBlbGVtZW50XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHdpZHRoOiBbTnVtYmVyLCBTdHJpbmddXG5cbiAgICB9XG5cbn1cblxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG5cbiAgICA8YnRuIGNsYXNzPVwiYnRuLWZpbGVcIiA6dHlwZT1cInR5cGVcIiA6dmFyaWFudD1cInZhcmlhbnRcIiA6YmxvY2s9XCJibG9ja1wiIDpzaXplPVwic2l6ZVwiIDpkaXNhYmxlZD1cImRpc2FibGVkXCIgOmFjdGl2ZT1cImFjdGl2ZVwiPlxuICAgICAgICA8c2xvdC8+XG5cbiAgICAgICAgPGlucHV0XG4gICAgICAgICAgICB2LWJpbmQtZXZlbnRzXG4gICAgICAgICAgICB0eXBlPVwiZmlsZVwiXG4gICAgICAgICAgICA6Y2xhc3M9XCJjb250cm9sQ2xhc3Nlc1wiXG4gICAgICAgICAgICA6aWQ9XCJpZFwiXG4gICAgICAgICAgICA6d2lkdGg9XCJ3aWR0aFwiXG4gICAgICAgICAgICA6aGVpZ2h0PVwiaGVpZ2h0XCJcbiAgICAgICAgICAgIDpyZXF1aXJlZD1cInJlcXVpcmVkXCJcbiAgICAgICAgICAgIDptdWx0aXBsZT1cIm11bHRpcGxlXCJcbiAgICAgICAgICAgIDpyZWFkb25seT1cInJlYWRvbmx5XCJcbiAgICAgICAgICAgIHYtb246Y2hhbmdlPVwidXBkYXRlZCgkZXZlbnQudGFyZ2V0LmZpbGVzLCAnY2hhbmdlJylcIj5cbiAgICA8L2J0bj5cblxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cblxuaW1wb3J0IEJ0biBmcm9tICdAL0NvbXBvbmVudHMvQnRuL0J0bic7XG5pbXBvcnQgRmlsZUZpZWxkIGZyb20gJ0AvQ29tcG9uZW50cy9GaWxlRmllbGQvRmlsZUZpZWxkJztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ2ZpbGUtZmllbGQnLFxuXG4gICAgbWl4aW5zOiBbXG4gICAgICAgIEJ0bixcbiAgICAgICAgRmlsZUZpZWxkXG4gICAgXSxcblxuICAgIG1vZGVsOiB7XG4gICAgICAgIGV2ZW50OiAnY2hhbmdlJ1xuICAgIH0sXG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdHlwZSBhdHRyaWJ1dGUgZm9yIHRoZSBidXR0b24uIE5vdCBhcHBsaWVkIGlmIGFuIGFuY2hvclxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAnYnV0dG9uJ1xuICAgICAgICB9XG5cbiAgICB9XG5cbn1cblxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwic2Nzc1wiPlxuLmJ0bi1maWxlIHtcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuXG4gICAgaW5wdXQge1xuICAgICAgICB6LWluZGV4OiAxO1xuICAgICAgICBvcGFjaXR5OiAwO1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogMDtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIGhlaWdodDogMTAwJTtcbiAgICB9XG59XG48L3N0eWxlPlxuIiwiaW1wb3J0IEZpbGVCdXR0b24gZnJvbSAnLi9GaWxlQnV0dG9uJztcbmltcG9ydCBWdWVJbnN0YWxsZXIgZnJvbSAnQC9IZWxwZXJzL1Z1ZUluc3RhbGxlci9WdWVJbnN0YWxsZXInO1xuXG5jb25zdCBwbHVnaW4gPSBWdWVJbnN0YWxsZXIudXNlKHtcblxuICAgIGluc3RhbGwoVnVlLCBvcHRpb25zKSB7XG4gICAgICAgIFZ1ZUluc3RhbGxlci5jb21wb25lbnRzKHtcbiAgICAgICAgICAgIEZpbGVCdXR0b25cbiAgICAgICAgfSk7XG4gICAgfVxuXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgRmlsZUJ1dHRvbjtcbiIsImltcG9ydCBGaWxlRmllbGQgZnJvbSAnLi9GaWxlRmllbGQnO1xuaW1wb3J0IFZ1ZUluc3RhbGxlciBmcm9tICdAL0hlbHBlcnMvVnVlSW5zdGFsbGVyL1Z1ZUluc3RhbGxlcic7XG5cbmNvbnN0IHBsdWdpbiA9IFZ1ZUluc3RhbGxlci51c2Uoe1xuXG4gICAgaW5zdGFsbChWdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgVnVlSW5zdGFsbGVyLmNvbXBvbmVudHMoe1xuICAgICAgICAgICAgRmlsZUZpZWxkXG4gICAgICAgIH0pO1xuICAgIH1cblxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IEZpbGVGaWVsZDtcbiIsImltcG9ydCB7IGlzRnVuY3Rpb24gfSBmcm9tICdsb2Rhc2gnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZWFkRmlsZShmaWxlLCBwcm9ncmVzcykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyO1xuICAgICAgICByZWFkZXIub25sb2FkID0gZSA9PiByZXNvbHZlKGUpO1xuICAgICAgICByZWFkZXIub25lcnJvciA9IGUgPT4gcmVqZWN0KGUpO1xuICAgICAgICByZWFkZXIub25hYm9ydCA9IGUgPT4gcmVqZWN0KGUpO1xuICAgICAgICByZWFkZXIub25wcm9ncmVzcyA9IGUgPT4gcHJvZ3Jlc3MoZSwgcmVhZGVyKTtcbiAgICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoZmlsZSk7XG4gICAgfSk7XG59XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBOdW1iZXJgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogKipOb3RlOioqIFRvIGV4Y2x1ZGUgYEluZmluaXR5YCwgYC1JbmZpbml0eWAsIGFuZCBgTmFOYCwgd2hpY2ggYXJlXG4gKiBjbGFzc2lmaWVkIGFzIG51bWJlcnMsIHVzZSB0aGUgYF8uaXNGaW5pdGVgIG1ldGhvZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG51bWJlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTnVtYmVyKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNOdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc051bWJlcihJbmZpbml0eSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc051bWJlcignMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IG51bWJlclRhZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNOdW1iZXI7XG4iLCI8dGVtcGxhdGU+XG4gICAgPGRpdiBjbGFzcz1cInByb2dyZXNzXCIgOnN0eWxlPVwieydoZWlnaHQnOiBmb3JtYXR0ZWRIZWlnaHR9XCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJwcm9ncmVzcy1iYXJcIiByb2xlPVwicHJvZ3Jlc3NiYXJcIiA6c3R5bGU9XCJ7J3dpZHRoJzogb2Zmc2V0VmFsdWUgKyAnJSd9XCIgOmNsYXNzPVwiJG1lcmdlQ2xhc3Nlcyhwcm9ncmVzc0NsYXNzZXMsIHZhcmlhbnRDbGFzcylcIiA6YXJpYS12YWx1ZW5vdz1cIm9mZnNldFZhbHVlXCIgOmFyaWEtdmFsdWVtaW49XCJtaW5cIiA6YXJpYS12YWx1ZW1heD1cIm1heFwiPlxuICAgICAgICAgICAgPHNwYW4gdi1pZj1cImxhYmVsXCI+e3tvZmZzZXRWYWx1ZX19JTwvc3Bhbj5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuXG5pbXBvcnQgeyBpc051bWJlciB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgVmFyaWFudCBmcm9tICdAL01peGlucy9WYXJpYW50L1ZhcmlhbnQnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAncHJvZ3Jlc3MtYmFyJyxcblxuICAgIG1peGluczogW1xuICAgICAgICBWYXJpYW50XG4gICAgXSxcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwcm9ncmVzcyBiYXIgcGVyY2VudGFnZSB2YWx1ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGhlaWdodCBvZiB0aGUgcHJvZ3Jlc3MgYmFyXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGhlaWdodDogW051bWJlciwgU3RyaW5nXSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvdyB0aGUgcHJvZ3Jlc3MgYmFyIHZhbHVlIGFzIGEgbGFiZWwgaW5zaWRlIHRoZSBiYXJcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgbGFiZWw6IEJvb2xlYW4sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3VsZCB0aGUgcHJvZ3Jlc3MgYmFyIGFwcGVhciB3aXRoIHN0cmlwZXNcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgc3RyaXBlZDogQm9vbGVhbixcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvdWxkIHRoZSBwcm9ncmVzcyBiYXIgYXBwZWFyIHdpdGggYW5pbWF0ZWQgc3RyaXBlc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBhbmltYXRlZDogQm9vbGVhbixcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1pbmltdW0gdmFsdWVcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgbWluOiB7XG4gICAgICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgICAgICBkZWZhdWx0OiAwXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtYXggdmFsdWVcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgbWF4OiB7XG4gICAgICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgICAgICBkZWZhdWx0OiAxMDBcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGNvbXB1dGVkOiB7XG5cbiAgICAgICAgdmFyaWFudENsYXNzUHJlZml4KCkge1xuICAgICAgICAgICAgcmV0dXJuICdiZyc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb2Zmc2V0VmFsdWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSAvIHRoaXMubWF4ICogMTAwO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZvcm1hdHRlZEhlaWdodCgpIHtcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5oZWlnaHQgPyBudWxsIDogKFxuICAgICAgICAgICAgICAgIGlzTnVtYmVyKHRoaXMuaGVpZ2h0KSA/IHRoaXMuaGVpZ2h0ICsgJ3B4JyA6IHRoaXMuaGVpZ2h0XG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuXG4gICAgICAgIHByb2dyZXNzQ2xhc3NlcygpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgJ3Byb2dyZXNzLWJhci1zdHJpcGVkJzogdGhpcy5zdHJpcGVkLFxuICAgICAgICAgICAgICAgICdwcm9ncmVzcy1iYXItYW5pbWF0ZWQnOiB0aGlzLmFuaW1hdGVkXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICB9XG5cbn1cblxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG5cbiAgICA8ZGl2IGNsYXNzPVwiZmlsZS1wcmV2aWV3XCIgOmNsYXNzPVwieydpcy1pbWFnZSc6IGlzSW1hZ2V9XCI+XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cImZpbGUtcHJldmlldy1pbm5lclwiPlxuXG4gICAgICAgICAgICA8YSB2LWlmPVwiIWhpZGVDbG9zZSAmJiAoIWlzSW1hZ2UgfHwgaW1hZ2UpXCIgaHJlZj1cIiNcIiBjbGFzcz1cImZpbGUtcHJldmlldy1jbG9zZVwiIEBjbGljay5wcmV2ZW50PVwiJGVtaXQoJ2Nsb3NlJywgZmlsZSlcIj5cbiAgICAgICAgICAgICAgICA8aSBjbGFzcz1cImZhIGZhLXRpbWVzLWNpcmNsZVwiPjwvaT5cbiAgICAgICAgICAgIDwvYT5cblxuICAgICAgICAgICAgPGRpdiB2LWlmPVwiaXNJbWFnZVwiIGNsYXNzPVwiZmlsZS1wcmV2aWV3LWltYWdlXCI+XG4gICAgICAgICAgICAgICAgPGltZyB2LWlmPVwiaW1hZ2VcIiA6c3JjPVwiaW1hZ2VcIiBjbGFzcz1cImZpbGUtcHJldmlldy10aHVtYm5haWxcIj5cbiAgICAgICAgICAgICAgICA8cHJvZ3Jlc3MtYmFyIHYtZWxzZSB2LXJlYWR5PVwicmVhZEZpbGVcIiA6dmFsdWU9XCJsb2FkZWRcIiA6aGVpZ2h0PVwiMTBcIiAvPlxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgIDxkaXYgdi1lbHNlIGNsYXNzPVwiZmlsZS1wcmV2aWV3LWljb25cIj5cbiAgICAgICAgICAgICAgICA8aSBjbGFzcz1cImZhIGZhLWZpbGUtb1wiPjwvaT5cbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZmlsZS1wcmV2aWV3LWZpbGVuYW1lXCIgdi1odG1sPVwibmFtZVwiPjwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZpbGUtcHJldmlldy1maWxlc2l6ZVwiPih7e3NpemV9fSk8L2Rpdj5cblxuICAgICAgICA8ZGl2PlxuXG4gICAgPC9kaXY+XG5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgbW9tZW50IGZyb20gJ21vbWVudCc7XG5pbXBvcnQgeyBpc0Z1bmN0aW9uIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCByZWFkRmlsZSBmcm9tICdAL0hlbHBlcnMvUmVhZEZpbGUvUmVhZEZpbGUnO1xuaW1wb3J0IFByb2dyZXNzQmFyIGZyb20gJ0AvQ29tcG9uZW50cy9Qcm9ncmVzc0Jhci9Qcm9ncmVzc0Jhcic7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdmaWxlLXByZXZpZXcnLFxuXG4gICAgY29tcG9uZW50czoge1xuICAgICAgICBQcm9ncmVzc0JhclxuICAgIH0sXG5cbiAgICBkaXJlY3RpdmVzOiB7XG4gICAgICAgIHJlYWR5OiB7XG4gICAgICAgICAgICBpbnNlcnRlZChlbCwgYmluZGluZykge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZihpc0Z1bmN0aW9uKGJpbmRpbmcudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiaW5kaW5nLnZhbHVlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCA1MCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcHJvcHM6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSGlkZSB0aGUgY2xvc2UgYnV0dG9uIGZvciB0aGUgcHJldmlld1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgT2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBoaWRlQ2xvc2U6IEJvb2xlYW4sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB1cGxvYWRlZCBGaWxlIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgT2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBmaWxlOiB7XG4gICAgICAgICAgICB0eXBlOiBbT2JqZWN0LCBGaWxlXSxcbiAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGFycmF5IG9mIG1pbWUgdHlwZXMgdGhhdCBzaG91bGQgYmUgdXNlZCB0byBkZXRlcm1pbmUgaWYgdGhlXG4gICAgICAgICAqIGZpbGUgaXMgYW4gaW1hZ2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBBcnJheVxuICAgICAgICAgKi9cbiAgICAgICAgaW1hZ2VNaW1lczoge1xuICAgICAgICAgICAgdHlwZTogQXJyYXksXG4gICAgICAgICAgICBkZWZhdWx0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbJ2ltYWdlL2dpZicsICdpbWFnZS9wbmcnLCAnaW1hZ2UvanBlZycsICdpbWFnZS9ibXAnLCAnaW1hZ2Uvd2VicCddO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgY29tcHV0ZWQ6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBmaWxlIG5hbWVcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgbmFtZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbGUgaW5zdGFuY2VvZiBGaWxlID8gdGhpcy5maWxlLm5hbWUgOiB0aGlzLmZpbGUub3JpZ19maWxlbmFtZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBmaWxlIGV4dGVuc2lvblxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBleHRlbnNpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maWxlIGluc3RhbmNlb2YgRmlsZSA/IHRoaXMuZmlsZS5uYW1lLnNwbGl0KCcuJykucG9wKCkudG9Mb3dlckNhc2UoKSA6IHRoaXMuZmlsZS5leHRlbnNpb247XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgZmlsZSBmb3JtYXR0ZWQgc2l6ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBzaXplKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnl0ZXNUb1NpemUodGhpcy5maWxlIGluc3RhbmNlb2YgRmlsZSA/IHRoaXMuZmlsZS5zaXplIDogdGhpcy5maWxlLmJ5dGVzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBmaWxlIHR5cGVcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgdHlwZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbGUgaW5zdGFuY2VvZiBGaWxlID8gdGhpcy5maWxlLnR5cGUgOiB0aGlzLmZpbGUubWltZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhlIGZpbGUgYW4gaW1hZ2U/XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGlzSW1hZ2UoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbWFnZU1pbWVzLmluZGV4T2YodGhpcy50eXBlKSAhPT0gLTE7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgbGFzdCB0aW1lIHRoZSBmaWxlIHdhcyBtb2RpZmllZCAoYXMgdGltZXN0YW1wKVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBsYXN0TW9kaWZpZWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maWxlIGluc3RhbmNlb2YgRmlsZSA/IHRoaXMuZmlsZS5sYXN0TW9kaWZpZWQgOiBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGxhc3QgdGltZSB0aGUgZmlsZSB3YXMgbW9kaWZpZWQgKGFzIERhdGUpXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGxhc3RNb2RpZmllZERhdGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maWxlIGluc3RhbmNlb2YgRmlsZSA/IHRoaXMuZmlsZS5sYXN0TW9kaWZpZWREYXRlIDogbnVsbDtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgcmVhZEZpbGUoKSB7XG4gICAgICAgICAgICBpZih0aGlzLmZpbGUgaW5zdGFuY2VvZiBGaWxlKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBtb21lbnQoKTtcblxuICAgICAgICAgICAgICAgIHJlYWRGaWxlKHRoaXMuZmlsZSwgZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmKGUubGVuZ3RoQ29tcHV0YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2FkZWQgPSBwYXJzZUludCgoZS5sb2FkZWQgLyBlLnRvdGFsKSAqIDEwMCwgMTApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkudGhlbihldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbWFnZSA9IGV2ZW50LnRhcmdldC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdsb2FkZWQnLCBldmVudCwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH0sIDYwMCAtIG1vbWVudCgpLmRpZmYoc3RhcnQpKTtcbiAgICAgICAgICAgICAgICB9LCBlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgXHRieXRlc1RvU2l6ZTogZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICBcdFx0dmFyIHNpemVzID0gWydCeXRlcycsICdLQicsICdNQicsICdHQicsICdUQiddO1xuICAgIFx0XHRpZiAoYnl0ZXMgPT0gMCkgcmV0dXJuICcwIEJ5dGUnO1xuICAgIFx0XHR2YXIgaSA9IHBhcnNlSW50KE1hdGguZmxvb3IoTWF0aC5sb2coYnl0ZXMpIC8gTWF0aC5sb2coMTAyNCkpKTtcbiAgICBcdFx0cmV0dXJuIE1hdGgucm91bmQoYnl0ZXMgLyBNYXRoLnBvdygxMDI0LCBpKSwgMikgKyAnICcgKyBzaXplc1tpXTtcbiAgICBcdH1cblxuICAgIH0sXG5cbiAgICBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbG9hZGVkOiAwLFxuICAgICAgICAgICAgaW1hZ2U6IHRoaXMuZmlsZS51cmxcbiAgICAgICAgfTtcbiAgICB9XG5cbn1cblxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwic2Nzc1wiPlxuJGZpbGUtcHJldmlldy1jbG9zZS13aWR0aDogMXJlbSAqIDI7XG4kZmlsZS1wcmV2aWV3LWNsb3NlLWhlaWdodDogMXJlbSAqIDI7XG5cbi5maWxlLXByZXZpZXcge1xuICAgIHdpZHRoOiAxMDAlO1xuXG4gICAgLmZpbGUtcHJldmlldy1pbm5lciB7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICB9XG5cbiAgICAuZmlsZS1wcmV2aWV3LWNsb3NlIHtcbiAgICAgICAgdG9wOiAwO1xuICAgICAgICByaWdodDogMDtcbiAgICAgICAgcGFkZGluZzogMDtcbiAgICAgICAgd2lkdGg6IDI0cHg7XG4gICAgICAgIGhlaWdodDogMjRweDtcbiAgICAgICAgYmFja2dyb3VuZDogd2hpdGU7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogMTAwJTtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoMzMlLCAtMzMlKTtcblxuICAgICAgICBpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgICAgIHRvcDogMDtcbiAgICAgICAgICAgIGxlZnQ6IDA7XG4gICAgICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMjRweDtcbiAgICAgICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC5maWxlLXByZXZpZXctaWNvbiB7XG4gICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgZm9udC1zaXplOiA2MHB4O1xuICAgICAgICBwYWRkaW5nOiAxcmVtO1xuICAgIH1cblxuICAgIC5maWxlLXByZXZpZXctdGh1bWJuYWlsIHtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIG1heC13aWR0aDogMTAwJTtcbiAgICB9XG5cbiAgICAuZmlsZS1wcmV2aWV3LWZpbGVuYW1lIHtcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgICAgICB3aGl0ZS1zcGFjZTogbm93cmFwO1xuICAgICAgICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcbiAgICB9XG5cbiAgICAuZmlsZS1wcmV2aWV3LWZpbGVuYW1lLFxuICAgIC5maWxlLXByZXZpZXctZmlsZXNpemUge1xuICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgfVxuXG59XG5cbjwvc3R5bGU+XG4iLCJpbXBvcnQgRmlsZVByZXZpZXcgZnJvbSAnLi9GaWxlUHJldmlldyc7XG5pbXBvcnQgVnVlSW5zdGFsbGVyIGZyb20gJ0AvSGVscGVycy9WdWVJbnN0YWxsZXIvVnVlSW5zdGFsbGVyJztcblxuY29uc3QgcGx1Z2luID0gVnVlSW5zdGFsbGVyLnVzZSh7XG5cbiAgICBpbnN0YWxsKFZ1ZSwgb3B0aW9ucykge1xuICAgICAgICBWdWVJbnN0YWxsZXIuY29tcG9uZW50cyh7XG4gICAgICAgICAgICBGaWxlUHJldmlld1xuICAgICAgICB9KTtcbiAgICB9XG5cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBGaWxlUHJldmlldztcbiIsIjx0ZW1wbGF0ZT5cblxuICAgIDxjb21wb25lbnRcbiAgICAgICAgOmlkPVwiaWRcIlxuICAgICAgICA6aXM9XCIhc2VsZWN0ID8gJ2lucHV0JyA6ICdzZWxlY3QnXCJcbiAgICAgICAgOnR5cGU9XCIhc2VsZWN0ID8gdHlwZSA6IGZhbHNlXCJcbiAgICAgICAgOnZhbHVlPVwidmFsdWVcIlxuICAgICAgICA6cGF0dGVybj1cInBhdHRlcm5cIlxuICAgICAgICA6cmVxdWlyZWQ9XCJyZXF1aXJlZFwiXG4gICAgICAgIDpyZWFkb25seT1cInJlYWRvbmx5XCJcbiAgICAgICAgOnBsYWNlaG9sZGVyPVwicGxhY2Vob2xkZXJcIlxuICAgICAgICA6ZGlzYWJsZWQ9XCJkaXNhYmxlZCB8fCByZWFkb25seVwiXG4gICAgICAgIDpjbGFzcz1cIiRtZXJnZUNsYXNzZXMoY29udHJvbENsYXNzZXMsIGNvbG9yYWJsZUNsYXNzZXMpXCJcbiAgICAgICAgOmFyaWEtbGFiZWw9XCJsYWJlbFwiXG4gICAgICAgIDphcmlhLWRlc2NyaWJlZGJ5PVwiaWRcIlxuICAgICAgICB2LWJpbmQtZXZlbnRzPVwiYmluZEV2ZW50c1wiXG4gICAgICAgIHYtb246aW5wdXQ9XCJ1cGRhdGVkXCI+XG4gICAgICAgIDxzbG90IHYtaWY9XCJzZWxlY3RcIi8+XG4gICAgPC9jb21wb25lbnQ+XG5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5cbmltcG9ydCBDb2xvcmFibGUgZnJvbSAnQC9NaXhpbnMvQ29sb3JhYmxlL0NvbG9yYWJsZSc7XG5pbXBvcnQgRm9ybUNvbnRyb2wgZnJvbSAnQC9NaXhpbnMvRm9ybUNvbnRyb2wvRm9ybUNvbnRyb2wnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAnZm9ybS1jb250cm9sJyxcblxuICAgIG1peGluczogW1xuICAgICAgICBDb2xvcmFibGUsXG4gICAgICAgIEZvcm1Db250cm9sXG4gICAgXSxcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElzIHRoZSBlbGVtZW50IGEgc2VsZWN0P1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBzZWxlY3Q6IEJvb2xlYW4sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0eXBlIGF0dHJpYnV0ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAndGV4dCdcbiAgICAgICAgfVxuXG4gICAgfVxuXG59XG5cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IEZvcm1Db250cm9sIGZyb20gJy4vRm9ybUNvbnRyb2wnO1xuaW1wb3J0IFZ1ZUluc3RhbGxlciBmcm9tICdAL0hlbHBlcnMvVnVlSW5zdGFsbGVyL1Z1ZUluc3RhbGxlcic7XG5cbmNvbnN0IHBsdWdpbiA9IFZ1ZUluc3RhbGxlci51c2Uoe1xuXG4gICAgaW5zdGFsbChWdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgVnVlSW5zdGFsbGVyLmNvbXBvbmVudHMoe1xuICAgICAgICAgICAgRm9ybUNvbnRyb2xcbiAgICAgICAgfSk7XG4gICAgfVxuXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgRm9ybUNvbnRyb2w7XG4iLCI8dGVtcGxhdGU+XG5cbiAgICA8ZGl2IDpjbGFzcz1cInsnaW52YWxpZC1mZWVkYmFjayc6IGludmFsaWQsICd2YWxpZC1mZWVkYmFjayc6IHZhbGlkICYmICFpbnZhbGlkfVwiPlxuICAgICAgICA8c2xvdD57e2xhYmVsfX08L3Nsb3Q+XG4gICAgPC9kaXY+XG5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5cbmltcG9ydCBDb2xvcmFibGUgZnJvbSAnQC9NaXhpbnMvQ29sb3JhYmxlL0NvbG9yYWJsZSc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdmb3JtLWZlZWRiYWNrJyxcblxuICAgIG1peGluczogW1xuICAgICAgICBDb2xvcmFibGVcbiAgICBdLFxuXG4gICAgcHJvcHM6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHZhbHVlIG9mIGxhYmVsIGVsZW1lbnQuIElmIG5vIHZhbHVlLCBubyBsYWJlbCB3aWxsIGFwcGVhci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgbGFiZWw6IFN0cmluZyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvdWxkIHRoZSBmZWVkYmFjayBtYXJrZWQgYXMgaW52YWxpZFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBpbnZhbGlkOiBCb29sZWFuLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG91bGQgdGhlIGZlZWRiYWNrIG1hcmtlZCBhcyBpbnZhbGlkXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHZhbGlkOiBCb29sZWFuXG5cbiAgICB9XG5cbn1cblxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgRm9ybUZlZWRiYWNrIGZyb20gJy4vRm9ybUZlZWRiYWNrJztcbmltcG9ydCBWdWVJbnN0YWxsZXIgZnJvbSAnQC9IZWxwZXJzL1Z1ZUluc3RhbGxlci9WdWVJbnN0YWxsZXInO1xuXG5jb25zdCBwbHVnaW4gPSBWdWVJbnN0YWxsZXIudXNlKHtcblxuICAgIGluc3RhbGwoVnVlLCBvcHRpb25zKSB7XG4gICAgICAgIFZ1ZUluc3RhbGxlci5jb21wb25lbnRzKHtcbiAgICAgICAgICAgIEZvcm1GZWVkYmFja1xuICAgICAgICB9KTtcbiAgICB9XG5cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBGb3JtRmVlZGJhY2s7XG4iLCI8dGVtcGxhdGU+XG5cbiAgICA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cFwiPjxzbG90Lz48L2Rpdj5cblxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cblxuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAnZm9ybS1ncm91cCdcbiAgICBcbn1cblxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgRm9ybUdyb3VwIGZyb20gJy4vRm9ybUdyb3VwJztcbmltcG9ydCBWdWVJbnN0YWxsZXIgZnJvbSAnQC9IZWxwZXJzL1Z1ZUluc3RhbGxlci9WdWVJbnN0YWxsZXInO1xuXG5jb25zdCBwbHVnaW4gPSBWdWVJbnN0YWxsZXIudXNlKHtcblxuICAgIGluc3RhbGwoVnVlLCBvcHRpb25zKSB7XG4gICAgICAgIFZ1ZUluc3RhbGxlci5jb21wb25lbnRzKHtcbiAgICAgICAgICAgIEZvcm1Hcm91cFxuICAgICAgICB9KTtcbiAgICB9XG5cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBGb3JtR3JvdXA7XG4iLCJleHBvcnQgZGVmYXVsdCB7XG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG91bGQgc2hvdyBvbmx5IGZvciBzY3JlZW5yZWFkZXJzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBCb29sZWFuXG4gICAgICAgICAqL1xuICAgICAgICBzck9ubHk6IEJvb2xlYW4sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3VsZCBiZSBmb2N1c2FibGUgZm9yIHNjcmVlbnJlYWRlcnNcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IEJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIHNyT25seUZvY3VzYWJsZTogQm9vbGVhblxuXG4gICAgfSxcblxuICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIHNjcmVlbnJlYWRlckNsYXNzZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICdzci1vbmx5JzogdGhpcy5zck9ubHksXG4gICAgICAgICAgICAgICAgJ3NyLW9ubHktZm9jdXNhYmxlJzogdGhpcy5zck9ubHlGb2N1c2FibGUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG59XG4iLCI8dGVtcGxhdGU+XG5cbiAgICA8bGFiZWwgOmNsYXNzPVwiY2xhc3Nlc1wiPjxzbG90Lz48L2xhYmVsPlxuXG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuXG5pbXBvcnQgeyBleHRlbmQgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IENvbG9yYWJsZSBmcm9tICdAL01peGlucy9Db2xvcmFibGUvQ29sb3JhYmxlJztcbmltcG9ydCBTY3JlZW5yZWFkZXJzIGZyb20gJ0AvTWl4aW5zL1NjcmVlbnJlYWRlcnMvU2NyZWVucmVhZGVycyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdmb3JtLWxhYmVsJyxcblxuICAgIG1peGluczogW1xuICAgICAgICBDb2xvcmFibGUsXG4gICAgICAgIFNjcmVlbnJlYWRlcnNcbiAgICBdLFxuXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgY2xhc3NlcygpIHtcbiAgICAgICAgICAgIHJldHVybiBleHRlbmQoe30sIHRoaXMuc2NyZWVucmVhZGVyQ2xhc3NlcywgdGhpcy5jb2xvcmFibGVDbGFzc2VzKTtcbiAgICAgICAgfVxuICAgIH1cblxufVxuXG48L3NjcmlwdD5cbiIsImltcG9ydCBGb3JtTGFiZWwgZnJvbSAnLi9Gb3JtTGFiZWwnO1xuaW1wb3J0IFZ1ZUluc3RhbGxlciBmcm9tICdAL0hlbHBlcnMvVnVlSW5zdGFsbGVyL1Z1ZUluc3RhbGxlcic7XG5cbmNvbnN0IHBsdWdpbiA9IFZ1ZUluc3RhbGxlci51c2Uoe1xuXG4gICAgaW5zdGFsbChWdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgVnVlSW5zdGFsbGVyLmNvbXBvbmVudHMoe1xuICAgICAgICAgICAgRm9ybUxhYmVsXG4gICAgICAgIH0pO1xuICAgIH1cblxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IEZvcm1MYWJlbDtcbiIsIjx0ZW1wbGF0ZT5cblxuICAgIDxzbWFsbCBjbGFzcz1cImZvcm0tdGV4dFwiIDpjbGFzcz1cImNsYXNzZXNcIj48c2xvdCAvPjwvc21hbGw+XG5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5cbmltcG9ydCB7IGV4dGVuZCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgQ29sb3JhYmxlIGZyb20gJ0AvTWl4aW5zL0NvbG9yYWJsZS9Db2xvcmFibGUnO1xuaW1wb3J0IFNjcmVlbnJlYWRlcnMgZnJvbSAnQC9NaXhpbnMvU2NyZWVucmVhZGVycy9TY3JlZW5yZWFkZXJzJztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ2hlbHAtdGV4dCcsXG5cbiAgICBtaXhpbnM6IFtcbiAgICAgICAgQ29sb3JhYmxlLFxuICAgICAgICBTY3JlZW5yZWFkZXJzXG4gICAgXSxcblxuICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIGNsYXNzZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gZXh0ZW5kKHt9LCB0aGlzLnNjcmVlbnJlYWRlckNsYXNzZXMsIHRoaXMuY29sb3JhYmxlQ2xhc3Nlcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgSGVscFRleHQgZnJvbSAnLi9IZWxwVGV4dCc7XG5pbXBvcnQgVnVlSW5zdGFsbGVyIGZyb20gJ0AvSGVscGVycy9WdWVJbnN0YWxsZXIvVnVlSW5zdGFsbGVyJztcblxuY29uc3QgcGx1Z2luID0gVnVlSW5zdGFsbGVyLnVzZSh7XG5cbiAgICBpbnN0YWxsKFZ1ZSwgb3B0aW9ucykge1xuICAgICAgICBWdWVJbnN0YWxsZXIuY29tcG9uZW50cyh7XG4gICAgICAgICAgICBIZWxwVGV4dFxuICAgICAgICB9KTtcbiAgICB9XG5cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBIZWxwVGV4dDtcbiIsImltcG9ydCBJbnB1dEZpZWxkIGZyb20gJy4vSW5wdXRGaWVsZCc7XG5pbXBvcnQgVnVlSW5zdGFsbGVyIGZyb20gJ0AvSGVscGVycy9WdWVJbnN0YWxsZXIvVnVlSW5zdGFsbGVyJztcblxuY29uc3QgcGx1Z2luID0gVnVlSW5zdGFsbGVyLnVzZSh7XG5cbiAgICBpbnN0YWxsKFZ1ZSwgb3B0aW9ucykge1xuICAgICAgICBWdWVJbnN0YWxsZXIuY29tcG9uZW50cyh7XG4gICAgICAgICAgICBJbnB1dEZpZWxkXG4gICAgICAgIH0pO1xuICAgIH1cblxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IElucHV0RmllbGQ7XG4iLCI8dGVtcGxhdGU+XG5cbiAgICA8ZGl2IGNsYXNzPVwiaW5wdXQtZ3JvdXBcIiA6Y2xhc3M9XCIkbWVyZ2VDbGFzc2VzKGNvbG9yYWJsZUNsYXNzZXMsIHNpemVhYmxlQ2xhc3MpXCI+XG5cbiAgICAgICAgPHNsb3QgbmFtZT1cInByZXBlbmRcIj5cbiAgICAgICAgICAgIDx0ZW1wbGF0ZSB2LWlmPVwicHJlcGVuZCBpbnN0YW5jZW9mIEFycmF5XCI+XG4gICAgICAgICAgICAgICAgPGlucHV0LWdyb3VwLXByZXBlbmQ+XG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dC1ncm91cC10ZXh0IHYtZm9yPVwidmFsdWUgaW4gcHJlcGVuZFwiIDp0ZXh0PVwidmFsdWVcIi8+XG4gICAgICAgICAgICAgICAgPC9pbnB1dC1ncm91cC1wcmVwZW5kPlxuICAgICAgICAgICAgPC90ZW1wbGF0ZT5cbiAgICAgICAgICAgIDx0ZW1wbGF0ZSB2LWVsc2UtaWY9XCJwcmVwZW5kXCI+XG4gICAgICAgICAgICAgICAgPGlucHV0LWdyb3VwLXByZXBlbmQgdGV4dD57e3ByZXBlbmR9fTwvaW5wdXQtZ3JvdXAtcHJlcGVuZD5cbiAgICAgICAgICAgIDwvdGVtcGxhdGU+XG4gICAgICAgIDwvc2xvdD5cblxuICAgICAgICA8c2xvdC8+XG5cbiAgICAgICAgPHNsb3QgbmFtZT1cImFwcGVuZFwiPlxuICAgICAgICAgICAgPHRlbXBsYXRlIHYtaWY9XCJhcHBlbmQgaW5zdGFuY2VvZiBBcnJheVwiPlxuICAgICAgICAgICAgICAgIDxpbnB1dC1ncm91cC1hcHBlbmQ+XG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dC1ncm91cC10ZXh0IHYtZm9yPVwidmFsdWUgaW4gYXBwZW5kXCIgOnRleHQ9XCJ2YWx1ZVwiLz5cbiAgICAgICAgICAgICAgICA8L2lucHV0LWdyb3VwLWFwcGVuZD5cbiAgICAgICAgICAgIDwvdGVtcGxhdGU+XG4gICAgICAgICAgICA8dGVtcGxhdGUgdi1lbHNlLWlmPVwiYXBwZW5kXCI+XG4gICAgICAgICAgICAgICAgPGlucHV0LWdyb3VwLWFwcGVuZCB0ZXh0Pnt7YXBwZW5kfX08L2lucHV0LWdyb3VwLWFwcGVuZD5cbiAgICAgICAgICAgIDwvdGVtcGxhdGU+XG4gICAgICAgIDwvc2xvdD5cbiAgICA8L2Rpdj5cblxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cblxuaW1wb3J0IEhhc1Nsb3RzIGZyb20gJ0AvTWl4aW5zL0hhc1Nsb3RzL0hhc1Nsb3RzJztcbmltcG9ydCBTaXplYWJsZSBmcm9tICdAL01peGlucy9TaXplYWJsZS9TaXplYWJsZSc7XG5pbXBvcnQgQ29sb3JhYmxlIGZyb20gJ0AvTWl4aW5zL0NvbG9yYWJsZS9Db2xvcmFibGUnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAnaW5wdXQtZ3JvdXAnLFxuXG4gICAgbWl4aW5zOiBbXG4gICAgICAgIEhhc1Nsb3RzLFxuICAgICAgICBTaXplYWJsZSxcbiAgICAgICAgQ29sb3JhYmxlXG4gICAgXSxcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgYXBwZW5kOiBbQXJyYXksIE51bWJlciwgU3RyaW5nXSxcblxuICAgICAgICBwcmVwZW5kOiBbQXJyYXksIE51bWJlciwgU3RyaW5nXVxuXG4gICAgfVxuXG59XG5cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuXG4gICAgPGRpdiBjbGFzcz1cImlucHV0LWdyb3VwLWFwcGVuZFwiPlxuICAgICAgICA8aW5wdXQtZ3JvdXAtdGV4dCB2LWlmPVwidGV4dFwiPlxuICAgICAgICAgICAgPHNsb3QvPlxuICAgICAgICA8L2lucHV0LWdyb3VwLXRleHQ+XG4gICAgICAgIDxzbG90IHYtZWxzZS8+XG4gICAgPC9kaXY+XG5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdpbnB1dC1ncm91cC1hcHBlbmQnLFxuXG4gICAgcHJvcHM6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHR5cGUgYXR0cmlidXRlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHRleHQ6IEJvb2xlYW5cblxuICAgIH1cblxufVxuXG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cblxuICAgIDxkaXYgY2xhc3M9XCJpbnB1dC1ncm91cC1wcmVwZW5kXCI+XG4gICAgICAgIDxpbnB1dC1ncm91cC10ZXh0IHYtaWY9XCJ0ZXh0XCI+XG4gICAgICAgICAgICA8c2xvdC8+XG4gICAgICAgIDwvaW5wdXQtZ3JvdXAtdGV4dD5cbiAgICAgICAgPHNsb3Qgdi1lbHNlLz5cbiAgICA8L2Rpdj5cblxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ2lucHV0LWdyb3VwLXByZXBlbmQnLFxuXG4gICAgcHJvcHM6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHR5cGUgYXR0cmlidXRlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHRleHQ6IEJvb2xlYW5cblxuICAgIH1cblxufVxuXG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cblxuICAgIDxzcGFuIGNsYXNzPVwiaW5wdXQtZ3JvdXAtdGV4dFwiIDppZD1cImlkXCI+XG4gICAgICAgIDxzbG90Pnt7IHRleHQgfX08L3Nsb3Q+XG4gICAgPC9zcGFuPlxuXG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAnaW5wdXQtZ3JvdXAtdGV4dCcsXG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaWQgYXR0cmlidXRlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGlkOiBTdHJpbmcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0eXBlIGF0dHJpYnV0ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICB0ZXh0OiBbQXJyYXksIE51bWJlciwgU3RyaW5nXVxuXG4gICAgfVxuXG59XG5cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IElucHV0R3JvdXAgZnJvbSAnLi9JbnB1dEdyb3VwJztcbmltcG9ydCBJbnB1dEdyb3VwQXBwZW5kIGZyb20gJy4vSW5wdXRHcm91cEFwcGVuZCc7XG5pbXBvcnQgSW5wdXRHcm91cFByZXBlbmQgZnJvbSAnLi9JbnB1dEdyb3VwUHJlcGVuZCc7XG5pbXBvcnQgSW5wdXRHcm91cFRleHQgZnJvbSAnLi9JbnB1dEdyb3VwVGV4dCc7XG5pbXBvcnQgVnVlSW5zdGFsbGVyIGZyb20gJ0AvSGVscGVycy9WdWVJbnN0YWxsZXIvVnVlSW5zdGFsbGVyJztcblxuY29uc3QgcGx1Z2luID0gVnVlSW5zdGFsbGVyLnVzZSh7XG5cbiAgICBpbnN0YWxsKFZ1ZSwgb3B0aW9ucykge1xuICAgICAgICBWdWVJbnN0YWxsZXIuY29tcG9uZW50cyh7XG4gICAgICAgICAgICBJbnB1dEdyb3VwLFxuICAgICAgICAgICAgSW5wdXRHcm91cEFwcGVuZCxcbiAgICAgICAgICAgIElucHV0R3JvdXBQcmVwZW5kLFxuICAgICAgICAgICAgSW5wdXRHcm91cFRleHRcbiAgICAgICAgfSk7XG4gICAgfVxuXG59KTtcblxuZXhwb3J0ICogZnJvbSAnLi9JbnB1dEdyb3VwQXBwZW5kJztcbmV4cG9ydCAqIGZyb20gJy4vSW5wdXRHcm91cFByZXBlbmQnO1xuZXhwb3J0ICogZnJvbSAnLi9JbnB1dEdyb3VwVGV4dCc7XG5leHBvcnQgZGVmYXVsdCBJbnB1dEdyb3VwO1xuIiwiPHRlbXBsYXRlPlxuXG4gICAgPGZvcm0tZ3JvdXA+XG5cbiAgICAgICAgPHNsb3QgbmFtZT1cImxhYmVsXCI+XG4gICAgICAgICAgICA8Zm9ybS1sYWJlbCB2LWlmPVwibGFiZWxcIiA6Zm9yPVwiaWRcIiB2LWh0bWw9XCJsYWJlbFwiIC8+XG4gICAgICAgIDwvc2xvdD5cblxuICAgICAgICA8ZGl2IDpjbGFzcz1cImNvbnRyb2xDbGFzc2VzXCIgdGFiaW5kZXg9XCIwXCIgQGNsaWNrPVwidG9nZ2xlKClcIiBAa2V5dXAuMzI9XCJ0b2dnbGUoKVwiIEBrZXl1cC4zNz1cInRvZ2dsZShvZmZWYWx1ZSlcIiBAa2V5dXAuMzk9XCJ0b2dnbGUob25WYWx1ZSlcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJsaWdodC1zd2l0Y2gtaGFuZGxlXCI+PC9kaXY+XG4gICAgICAgIFx0PGRpdiBjbGFzcz1cImxpZ2h0LXN3aXRjaC1jb250YWluZXJcIj5cbiAgICAgICAgXHRcdDxkaXYgY2xhc3M9XCJsaWdodC1zd2l0Y2gtbGFiZWwgb24tdmFsdWVcIj48L2Rpdj5cbiAgICAgICAgXHRcdDxkaXYgY2xhc3M9XCJsaWdodC1zd2l0Y2gtbGFiZWwgb2ZmLXZhbHVlXCI+PC9kaXY+XG4gICAgICAgIFx0PC9kaXY+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIDxmb3JtLWNvbnRyb2wgOm5hbWU9XCJuYW1lXCIgOnZhbHVlPVwidmFsdWVcIiA6aWQ9XCJpZFwiIGNsYXNzPVwiZC1ub25lXCIvPlxuXG4gICAgICAgIDxzbG90IG5hbWU9XCJmZWVkYmFja1wiPlxuICAgICAgICAgICAgPGZvcm0tZmVlZGJhY2sgdi1pZj1cInZhbGlkRmVlZGJhY2tcIiB2LWh0bWw9XCJ2YWxpZEZlZWRiYWNrXCIgdmFsaWQgLz5cbiAgICAgICAgICAgIDxmb3JtLWZlZWRiYWNrIHYtaWY9XCJpbnZhbGlkRmVlZGJhY2tcIiB2LWh0bWw9XCJpbnZhbGlkRmVlZGJhY2tcIiBpbnZhbGlkIC8+XG4gICAgICAgIDwvc2xvdD5cblxuICAgICAgICA8c2xvdCBuYW1lPVwiaGVscFwiPlxuICAgICAgICAgICAgPGhlbHAtdGV4dCB2LWlmPVwiaGVscFRleHRcIiB2LWh0bWw9XCJoZWxwVGV4dFwiIC8+XG4gICAgICAgIDwvc2xvdD5cblxuICAgIDwvZm9ybS1ncm91cD5cblxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cblxuaW1wb3J0IHsgZXh0ZW5kIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IGlzVW5kZWZpbmVkIH0gZnJvbSAnbG9kYXNoJztcbi8vaW1wb3J0IEJhc2VGaWVsZCBmcm9tICcuL0Jhc2VGaWVsZCc7XG5pbXBvcnQgRm9ybUNvbnRyb2wgZnJvbSAnQC9NaXhpbnMvRm9ybUNvbnRyb2wvRm9ybUNvbnRyb2wnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAnbGlnaHQtc3dpdGNoLWZpZWxkJyxcblxuICAgIG1peGluczogW0Zvcm1Db250cm9sXSxcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjbGFzcyBuYW1lIGFzc2lnbmVkIHRvIHRoZSBjb250cm9sIGVsZW1lbnRcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgZGVmYXVsdENvbnRyb2xDbGFzczoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJ2Zvcm0tY29udHJvbCBsaWdodC1zd2l0Y2gnXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjbGFzcyBuYW1lIGFzc2lnbmVkIHRvIHRoZSBjb250cm9sIGVsZW1lbnRcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgYWN0aXZlQ2xhc3M6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdvbidcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNsYXNzIG5hbWUgYXNzaWduZWQgdG8gdGhlIGNvbnRyb2wgZWxlbWVudFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBvblZhbHVlOiB7XG4gICAgICAgICAgICBkZWZhdWx0OiAxXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjbGFzcyBuYW1lIGFzc2lnbmVkIHRvIHRoZSBjb250cm9sIGVsZW1lbnRcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgb2ZmVmFsdWU6IHtcbiAgICAgICAgICAgIGRlZmF1bHQ6IDBcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGNvbXB1dGVkOiB7XG5cbiAgICAgICAgaXNBY3RpdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUgPT09IHRoaXMub25WYWx1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICBjb250cm9sQ2xhc3NlcygpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgdGhpcy5jb250cm9sQ2xhc3MsXG4gICAgICAgICAgICAgICAgdGhpcy5jb250cm9sU2l6ZUNsYXNzLFxuICAgICAgICAgICAgICAgICh0aGlzLnNwYWNpbmcgfHwgJycpLFxuICAgICAgICAgICAgICAgICh0aGlzLmludmFsaWRGZWVkYmFjayA/ICdpcy1pbnZhbGlkJyA6ICcnKSxcbiAgICAgICAgICAgICAgICAodGhpcy5kcmFnZ2luZyA/ICdpcy1kcmFnZ2luZycgOiAnJyksXG4gICAgICAgICAgICAgICAgKHRoaXMuaXNBY3RpdmUgPyAnaXMtYWN0aXZlJyA6ICcnKVxuICAgICAgICAgICAgXS5qb2luKCcgJyk7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBtZXRob2RzOiB7XG5cbiAgICAgICAgZ2V0VHJhbnNpdGlvbkluTWlsbGlzZWNvbmRzKCkge1xuICAgICAgICAgICAgY29uc3QgZHVyYXRpb24gPSBnZXRDb21wdXRlZFN0eWxlKHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3IoJy5saWdodC1zd2l0Y2gtaGFuZGxlJykpLnRyYW5zaXRpb25EdXJhdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IG51bWVyaWMgPSBwYXJzZUZsb2F0KGR1cmF0aW9uLCAxMCk7XG4gICAgICAgICAgICBjb25zdCB1bml0ID0gZHVyYXRpb24ubWF0Y2goL20/cy8pO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKHVuaXRbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bWVyaWMgKiAxMDAwO1xuICAgICAgICAgICAgICAgIGNhc2UgJ21zJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bWVyaWM7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7dW5pdFswXX1cIiBpcyBub3QgYSB2YWxpZCB1bml0IG9mIG1lYXN1cmUuIFVuaXQgbXVzdCBiZSBcInNcIiAoc2Vjb25kcykgb3IgXCJtc1wiIChtaWxsaXNlY29uZHMpLmApO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRvZ2dsZSh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgnaW5wdXQnLCAhaXNVbmRlZmluZWQodmFsdWUpID8gdmFsdWUgOiAodGhpcy5pc0FjdGl2ZSA/IHRoaXMub2ZmVmFsdWUgOiB0aGlzLm9uVmFsdWUpKTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIHdhdGNoOiB7XG4gICAgICAgIHZhbHVlKCkge1xuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZyA9IHRydWU7XG5cbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH0sIHRoaXMuZ2V0VHJhbnNpdGlvbkluTWlsbGlzZWNvbmRzKCkpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkcmFnZ2luZzogZmFsc2VcbiAgICAgICAgfTtcbiAgICB9XG5cbn1cblxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwic2Nzc1wiPlxuQGltcG9ydCAnLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwL3Njc3MvYm9vdHN0cmFwLXJlYm9vdC5zY3NzJztcblxuJGxpZ2h0LXN3aXRjaC1hbmltYXRpb24tZWFzaW5nOiBlYXNlO1xuJGxpZ2h0LXN3aXRjaC1hbmltYXRpb24tbGVuZ3RoOiAxcyAvIDM7XG4kbGlnaHQtc3dpdGNoLWhhbmRsZS13aWR0aDogJGZvbnQtc2l6ZS1iYXNlICogMjtcbiRsaWdodC1zd2l0Y2gtaGFuZGxlLWhlaWdodDogJGxpZ2h0LXN3aXRjaC1oYW5kbGUtd2lkdGg7XG4kbGlnaHQtc3dpdGNoLXNpemUtd2lkdGg6ICRsaWdodC1zd2l0Y2gtaGFuZGxlLXdpZHRoICogMS41O1xuJGxpZ2h0LXN3aXRjaC1zaXplLWhlaWdodDogJGxpZ2h0LXN3aXRjaC1oYW5kbGUtaGVpZ2h0O1xuJGxpZ2h0LXN3aXRjaC1sYWJlbC13aWR0aDogJGxpZ2h0LXN3aXRjaC1oYW5kbGUtd2lkdGg7XG4kbGlnaHQtc3dpdGNoLWxhYmVsLWhlaWdodDogJGxpZ2h0LXN3aXRjaC1oYW5kbGUtaGVpZ2h0O1xuXG5AbWl4aW4gbGlnaHQtc3dpdGNoLXNpemUoJHNpemUsICRtb2RpZmllcikge1xuICAgICRoYW5kbGUtd2lkdGg6ICRsaWdodC1zd2l0Y2gtaGFuZGxlLXdpZHRoICogJG1vZGlmaWVyO1xuICAgICRoYW5kbGUtaGVpZ2h0OiAkaGFuZGxlLXdpZHRoO1xuICAgICRzaXplLXdpZHRoOiAkaGFuZGxlLXdpZHRoICogMS41O1xuICAgICRzaXplLWhlaWdodDogJGhhbmRsZS1oZWlnaHQ7XG4gICAgJGxhYmVsLXdpZHRoOiAkaGFuZGxlLXdpZHRoO1xuICAgICRsYWJlbC1oZWlnaHQ6ICRoYW5kbGUtaGVpZ2h0O1xuXG4gICAgJi5saWdodC1zd2l0Y2gtI3skc2l6ZX0ge1xuICAgICAgICBwYWRkaW5nOiAwO1xuICAgIFx0d2lkdGg6ICRzaXplLXdpZHRoO1xuICAgIFx0aGVpZ2h0OiAkaGFuZGxlLWhlaWdodDtcbiAgICBcdGJvcmRlci1yYWRpdXM6ICRoYW5kbGUtd2lkdGg7XG5cbiAgICAgICAgLmxpZ2h0LXN3aXRjaC1oYW5kbGUge1xuICAgICAgICAgICAgd2lkdGg6ICRoYW5kbGUtd2lkdGg7XG4gICAgICAgICAgICBoZWlnaHQ6ICRoYW5kbGUtaGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgLmxpZ2h0LXN3aXRjaC1jb250YWluZXIge1xuICAgICAgICAgICAgbGVmdDogLSRoYW5kbGUtd2lkdGggLyAyO1xuICAgICAgICAgICAgd2lkdGg6ICRsYWJlbC13aWR0aCAqIDI7XG4gICAgICAgICAgICBoZWlnaHQ6ICRsYWJlbC1oZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICAmLmlzLWFjdGl2ZSB7XG4gICAgICAgICAgICAubGlnaHQtc3dpdGNoLWhhbmRsZSB7XG4gICAgICAgICAgICAgICAgbGVmdDogJGhhbmRsZS13aWR0aCAvIDI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAubGlnaHQtc3dpdGNoLWxhYmVsIHtcbiAgICAgICAgICAgIHdpZHRoOiAkbGFiZWwtd2lkdGg7XG4gICAgICAgICAgICBoZWlnaHQ6ICRsYWJlbC1oZWlnaHQ7XG5cbiAgICAgICAgICAgICYub24tdmFsdWUge1xuICAgICAgICAgICAgICAgIC8vYm9yZGVyLXJhZGl1czogJGhhbmRsZS13aWR0aCAwIDAgJGhhbmRsZS13aWR0aDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgJi5vZmYtdmFsdWUge1xuICAgICAgICAgICAgICAgIC8vYm9yZGVyLXJhZGl1czogMCAkaGFuZGxlLXdpZHRoICRoYW5kbGUtd2lkdGggMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuLmxpZ2h0LXN3aXRjaCB7XG4gICAgcGFkZGluZzogMDtcblx0cG9zaXRpb246IHJlbGF0aXZlO1xuXHRib3JkZXI6IG5vbmU7XG5cdHdpZHRoOiAkbGlnaHQtc3dpdGNoLXNpemUtd2lkdGg7XG5cdGhlaWdodDogJGxpZ2h0LXN3aXRjaC1oYW5kbGUtaGVpZ2h0O1xuXHRib3JkZXItcmFkaXVzOiAkbGlnaHQtc3dpdGNoLWhhbmRsZS13aWR0aDtcblx0b3ZlcmZsb3c6IGhpZGRlbjtcblx0Y3Vyc29yOiBwb2ludGVyO1xuXHQtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xuXHQtbW96LXVzZXItc2VsZWN0OiBub25lO1xuXHQtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XG5cdG92ZXJmbG93OiBoaWRkZW47XG5cbiAgICBAaW5jbHVkZSBsaWdodC1zd2l0Y2gtc2l6ZSgneHMnLCAuNSk7XG4gICAgQGluY2x1ZGUgbGlnaHQtc3dpdGNoLXNpemUoJ3NtJywgLjc1KTtcbiAgICBAaW5jbHVkZSBsaWdodC1zd2l0Y2gtc2l6ZSgnbWQnLCAxKTtcbiAgICBAaW5jbHVkZSBsaWdodC1zd2l0Y2gtc2l6ZSgnbGcnLCAxLjUpO1xuICAgIEBpbmNsdWRlIGxpZ2h0LXN3aXRjaC1zaXplKCd4bCcsIDIpO1xuXG4gICAgQGluY2x1ZGUgZm9ybS12YWxpZGF0aW9uLXN0YXRlKFwidmFsaWRcIiwgJGZvcm0tZmVlZGJhY2stdmFsaWQtY29sb3IpO1xuICAgIEBpbmNsdWRlIGZvcm0tdmFsaWRhdGlvbi1zdGF0ZShcImludmFsaWRcIiwgJGZvcm0tZmVlZGJhY2staW52YWxpZC1jb2xvcik7XG5cbiAgICAmLmlzLWludmFsaWQge1xuICAgICAgICBib3JkZXI6IDFweCBzb2xpZCAkZm9ybS1mZWVkYmFjay1pbnZhbGlkLWNvbG9yO1xuXG4gICAgICAgICYgLmxpZ2h0LXN3aXRjaC1oYW5kbGUge1xuXG5cbiAgICAgICAgfVxuXG4gICAgICAgICY6bm90KC5pcy1hY3RpdmUpIC5saWdodC1zd2l0Y2gtaGFuZGxlIHtcbiAgICAgICAgICAgIGJhY2tncm91bmQ6ICRmb3JtLWZlZWRiYWNrLWludmFsaWQtY29sb3I7XG4gICAgICAgIH1cblxuICAgICAgICAubGlnaHQtc3dpdGNoLWxhYmVsIHtcbiAgICAgICAgICAgICYub24tdmFsdWUge1xuICAgICAgICAgICAgICAgIGxlZnQ6IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAmLm9mZi12YWx1ZSB7XG4gICAgICAgICAgICAgICAgcmlnaHQ6IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAubGlnaHQtc3dpdGNoLWhhbmRsZSB7XG4gICAgICAgIHRvcDogMDtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgICAgei1pbmRleDogMTtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICBib3JkZXItcmFkaXVzOiAxMDAlO1xuICAgICAgICB0cmFuc2l0aW9uOiBsZWZ0ICRsaWdodC1zd2l0Y2gtYW5pbWF0aW9uLWxlbmd0aCAkbGlnaHQtc3dpdGNoLWFuaW1hdGlvbi1lYXNpbmc7XG4gICAgICAgIHdpZHRoOiAkbGlnaHQtc3dpdGNoLWhhbmRsZS13aWR0aDtcbiAgICAgICAgaGVpZ2h0OiAkbGlnaHQtc3dpdGNoLWhhbmRsZS1oZWlnaHQ7XG4gICAgICAgIGJhY2tncm91bmQ6IHdoaXRlO1xuICAgICAgICBiYWNrZ3JvdW5kLWltYWdlOiByYWRpYWwtZ3JhZGllbnQod2hpdGUsIHJnYigyNTAsIDI1MCwgMjUwKSA1MCUsIHdoaXRlIDc1JSk7XG4gICAgICAgIGJveC1zaGFkb3c6IGluc2V0IDAgMCAwIDFweCByZ2JhKDAsIDAsIDAsIDAuMSksIDAgMCAwIDFweCByZ2JhKDAsIDAsIDAsIDAuMSk7XG4gICAgfVxuXG4gICAgLmxpZ2h0LXN3aXRjaC1jb250YWluZXIge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIGxlZnQ6IC0kbGlnaHQtc3dpdGNoLWhhbmRsZS13aWR0aCAvIDI7XG4gICAgICAgIHRvcDogKCRsaWdodC1zd2l0Y2gtaGFuZGxlLWhlaWdodCAtICAkbGlnaHQtc3dpdGNoLWxhYmVsLWhlaWdodCkgLyAyO1xuICAgICAgICB3aWR0aDogJGxpZ2h0LXN3aXRjaC1sYWJlbC13aWR0aCAqIDI7XG4gICAgICAgIGhlaWdodDogJGxpZ2h0LXN3aXRjaC1sYWJlbC1oZWlnaHQ7XG4gICAgICAgIHRyYW5zaXRpb246IGxlZnQgJGxpZ2h0LXN3aXRjaC1hbmltYXRpb24tbGVuZ3RoICRsaWdodC1zd2l0Y2gtYW5pbWF0aW9uLWVhc2luZztcbiAgICB9XG5cbiAgICAmOm5vdCguaXMtYWN0aXZlKSB7XG4gICAgICAgICY6bm90KC5pcy1kcmFnZ2luZykgLm9uLXZhbHVlIHtcbiAgICAgICAgICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgICYuaXMtYWN0aXZlIHtcbiAgICAgICAgJjpub3QoLmlzLWRyYWdnaW5nKSAub2ZmLXZhbHVlIHtcbiAgICAgICAgICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcbiAgICAgICAgfVxuXG4gICAgICAgIC5saWdodC1zd2l0Y2gtaGFuZGxlIHtcbiAgICAgICAgICAgIGxlZnQ6ICRsaWdodC1zd2l0Y2gtaGFuZGxlLXdpZHRoIC8gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIC5saWdodC1zd2l0Y2gtY29udGFpbmVyIHtcbiAgICAgICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAubGlnaHQtc3dpdGNoLWxhYmVsIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB3aWR0aDogJGxpZ2h0LXN3aXRjaC1sYWJlbC13aWR0aDtcbiAgICAgICAgaGVpZ2h0OiAkbGlnaHQtc3dpdGNoLWxhYmVsLWhlaWdodDtcbiAgICAgICAgLy9ib3gtc2hhZG93OiBpbnNldCAwIDAgMCAxcHggcmdiYSgwLCAwLCAwLCAwLjEpO1xuXG4gICAgICAgICYub24tdmFsdWUge1xuICAgICAgICAgICAgbGVmdDogMDtcbiAgICAgICAgICAgIGJhY2tncm91bmQ6ICMwMGIwMDc7XG4gICAgICAgICAgICAvL2JvcmRlci1yYWRpdXM6ICRsaWdodC1zd2l0Y2gtaGFuZGxlLXdpZHRoIDAgMCAkbGlnaHQtc3dpdGNoLWhhbmRsZS13aWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgICYub2ZmLXZhbHVlIHtcbiAgICAgICAgICAgIHJpZ2h0OiAwO1xuICAgICAgICAgICAgYmFja2dyb3VuZDogI2ViZWRlZjtcbiAgICAgICAgICAgIC8vYm9yZGVyLXJhZGl1czogMCAkbGlnaHQtc3dpdGNoLWhhbmRsZS13aWR0aCAkbGlnaHQtc3dpdGNoLWhhbmRsZS13aWR0aCAwO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cblxuPC9zdHlsZT5cbiIsImltcG9ydCBMaWdodFN3aXRjaEZpZWxkIGZyb20gJy4vTGlnaHRTd2l0Y2hGaWVsZCc7XG5pbXBvcnQgVnVlSW5zdGFsbGVyIGZyb20gJ0AvSGVscGVycy9WdWVJbnN0YWxsZXIvVnVlSW5zdGFsbGVyJztcblxuY29uc3QgcGx1Z2luID0gVnVlSW5zdGFsbGVyLnVzZSh7XG5cbiAgICBpbnN0YWxsKFZ1ZSwgb3B0aW9ucykge1xuICAgICAgICBWdWVJbnN0YWxsZXIuY29tcG9uZW50cyh7XG4gICAgICAgICAgICBMaWdodFN3aXRjaEZpZWxkXG4gICAgICAgIH0pO1xuICAgIH1cblxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IExpZ2h0U3dpdGNoRmllbGQ7XG4iLCI8dGVtcGxhdGU+XG4gICAgPGEgdi1pZj1cImhyZWZcIiA6aHJlZj1cImhyZWZcIiBjbGFzcz1cImxpc3QtZ3JvdXAtaXRlbVwiIDpjbGFzcz1cImNsYXNzZXNcIiBAY2xpY2s9XCJvbkNsaWNrXCI+XG4gICAgICAgIDxzbG90Pnt7bGFiZWx9fTwvc2xvdD4gPGJhZGdlIHYtaWY9XCJiYWRnZVwiIHYtYmluZD1cImJhZGdlT3B0aW9uc1wiPjwvYmFkZ2U+XG4gICAgPC9hPlxuICAgIDxhIHYtZWxzZS1pZj1cImFjdGlvblwiIGhyZWY9XCIjXCIgY2xhc3M9XCJsaXN0LWdyb3VwLWl0ZW1cIiA6Y2xhc3M9XCJjbGFzc2VzXCIgQGNsaWNrLnByZXZlbnQ9XCJvbkNsaWNrXCI+XG4gICAgICAgIDxzbG90Pnt7bGFiZWx9fTwvc2xvdD4gPGJhZGdlIHYtaWY9XCJiYWRnZVwiIHYtYmluZD1cImJhZGdlT3B0aW9uc1wiPjwvYmFkZ2U+XG4gICAgPC9hPlxuICAgIDxkaXYgdi1lbHNlIGNsYXNzPVwibGlzdC1ncm91cC1pdGVtXCIgOmNsYXNzPVwiY2xhc3Nlc1wiIEBjbGljaz1cIm9uQ2xpY2tcIj5cbiAgICAgICAgPHNsb3Q+e3tsYWJlbH19PC9zbG90PiA8YmFkZ2Ugdi1pZj1cImJhZGdlXCIgdi1iaW5kPVwiYmFkZ2VPcHRpb25zXCI+PC9iYWRnZT5cbiAgICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5cbmltcG9ydCB7IGlzT2JqZWN0IH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBCYWRnZSBmcm9tICcuLi9CYWRnZSc7XG5pbXBvcnQgcHJlZml4IGZyb20gJ0AvSGVscGVycy9QcmVmaXgvUHJlZml4JztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgY29tcG9uZW50czoge1xuICAgICAgICBCYWRnZVxuICAgIH0sXG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbGlzdCBpdGVtIGxhYmVsLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgT2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBsYWJlbDoge1xuICAgICAgICAgICAgdHlwZTogW051bWJlciwgU3RyaW5nXSxcbiAgICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsaXN0IGdyb3VwIGl0ZW0gYW4gYWN0aW9uLCBvciBjbGlja2FibGUgaXRlbS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IEJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIGFjdGlvbjoge1xuICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsaXN0IGdyb3VwIGl0ZW0gYWN0aXZlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgQm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgYWN0aXZlOiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGxpc3QgZ3JvdXAgaXRlbSBkaXNhYmxlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IEJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIGRpc2FibGVkOiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGxpc3QgZ3JvdXAgaXRlbSB2YXJpYW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICB2YXJpYW50OiBTdHJpbmcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsaXN0IGdyb3VwIGl0ZW0gaHJlZiBhdHRyaWJ1dGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGhyZWY6IFN0cmluZyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGJhZGdlIGxhYmVsIChpZiBudW1iZXIgb3Igc3RyaW5nKSBvciBvYmplY3Qgb2Ygb3B0aW9ucyB0byBwYXNzIHRvXG4gICAgICAgICAqIHRoZSBjb21wb25lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmd8T2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBiYWRnZTogW051bWJlciwgU3RyaW5nLCBPYmplY3RdXG5cbiAgICB9LFxuXG4gICAgY29tcHV0ZWQ6IHtcblxuICAgICAgICBjbGFzc2VzKCkge1xuICAgICAgICAgICAgY29uc3QgY2xhc3NlcyA9IHByZWZpeCh7XG4gICAgICAgICAgICAgICAgJ2FjdGlvbic6IHRoaXMuYWN0aW9uLFxuICAgICAgICAgICAgfSwgJ2xpc3QtZ3JvdXAtaXRlbScpO1xuXG4gICAgICAgICAgICBjbGFzc2VzWydhY3RpdmUnXSA9IHRoaXMuaXNBY3RpdmU7XG4gICAgICAgICAgICBjbGFzc2VzWydkaXNhYmxlZCddID0gdGhpcy5pc0Rpc2FibGVkO1xuXG4gICAgICAgICAgICBpZih0aGlzLnZhcmlhbnQpIHtcbiAgICAgICAgICAgICAgICBjbGFzc2VzW3ByZWZpeCh0aGlzLnZhcmlhbnQsICdsaXN0LWdyb3VwLWl0ZW0nKV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY2xhc3NlcztcbiAgICAgICAgfSxcblxuICAgICAgICBiYWRnZU9wdGlvbnMoKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNPYmplY3QodGhpcy5iYWRnZSkgPyB0aGlzLmJhZGdlIDoge1xuICAgICAgICAgICAgICAgIGxhYmVsOiB0aGlzLmJhZGdlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgbWV0aG9kczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUb2dnbGUgdGhlIGxpc3QgaXRlbSdzIGFjdGl2ZSBjbGFzcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB2b2lkXG4gICAgICAgICAqL1xuICAgICAgICB0b2dnbGUoKSB7XG4gICAgICAgICAgICB0aGlzLmlzQWN0aXZlID0gIXRoaXMuaXNBY3RpdmU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFjdGl2YXRlIHRoZSBsaXN0IGl0ZW0uXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAgICAgKi9cbiAgICAgICAgYWN0aXZhdGUoKSB7XG4gICAgICAgICAgICB0aGlzLmlzQWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVhY3RpdmF0ZSB0aGUgbGlzdCBpdGVtLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgICAgICovXG4gICAgICAgIGRlYWN0aXZhdGUoKSB7XG4gICAgICAgICAgICB0aGlzLmlzQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFjdGl2YXRlIHRoZSBsaXN0IGl0ZW0uXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAgICAgKi9cbiAgICAgICAgZGlzYWJsZSgpIHtcbiAgICAgICAgICAgIHRoaXMuaXNEaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWFjdGl2YXRlIHRoZSBsaXN0IGl0ZW0uXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAgICAgKi9cbiAgICAgICAgZW5hYmxlKCkge1xuICAgICAgICAgICAgdGhpcy5pc0Rpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjYWxsYmFjayBmdW5jdGlvbiBmb3IgdGhlIGBjbGlja2AgZXZlbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAgICAgKi9cbiAgICAgICAgb25DbGljayhldmVudCkge1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgnY2xpY2snLCBldmVudCwgdGhpcyk7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICB3YXRjaDoge1xuXG4gICAgICAgIGlzQWN0aXZlKHZhbHVlLCBwcmV2VmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ3VwZGF0ZTphY3RpdmUnLCB0aGlzLmlzQWN0aXZlKTtcbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ3RvZ2dsZScsIHRoaXMuaXNBY3RpdmUsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy4kZW1pdCh2YWx1ZSA/ICdhY3RpdmF0ZScgOiAnZGVhY3RpdmF0ZScsIHRoaXMpO1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlzQWN0aXZlOiB0aGlzLmFjdGl2ZSxcbiAgICAgICAgICAgIGlzRGlzYWJsZWQ6IHRoaXMuZGlzYWJsZWRcbiAgICAgICAgfTtcbiAgICB9XG5cbn1cblxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gICAgPGRpdiBjbGFzcz1cImxpc3QtZ3JvdXBcIiA6Y2xhc3M9XCJjbGFzc2VzXCI+XG4gICAgICAgIDxzbG90PlxuICAgICAgICAgICAgPGxpc3QtZ3JvdXAtaXRlbSB2LWZvcj1cIihpdGVtLCBrZXkpIGluIGl0ZW1zXCIgOmtleT1cImtleVwiIHYtYmluZD1cIml0ZW1cIi8+XG4gICAgICAgIDwvc2xvdD5cbiAgICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5cbmltcG9ydCB7IGVhY2ggfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IExpc3RHcm91cEl0ZW0gZnJvbSAnLi9MaXN0R3JvdXBJdGVtJztcbmltcG9ydCBwcmVmaXggZnJvbSAnQC9IZWxwZXJzL1ByZWZpeC9QcmVmaXgnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBjb21wb25lbnRzOiB7XG4gICAgICAgIExpc3RHcm91cEl0ZW1cbiAgICB9LFxuXG4gICAgcHJvcHM6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gYXJyYXkgb2YgbGlzdCBpdGVtIG9iamVjdHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFt7bGFiZWw6ICdTb21lIExhYmVsJywgYmFkZ2U6IDF9XVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgT2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBpdGVtczogQXJyYXksXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbiB0aGUgbGlzdCBpdGVtcyBiZSBhY3RpdmF0ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBCb29sZWFuXG4gICAgICAgICAqL1xuICAgICAgICBhY3RpdmF0ZWFibGU6IHtcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbGlzdCBncm91cCBhcHBlYXIgZmx1c2ggKHdpdGhvdXQgc29tZSBib3JkZXJzKS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IEJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIGZsdXNoOiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FuIGFjdGl2YXRlIG11bHRpcGxlIGxpc3QgaXRlbXNcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IEJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIG11bHRpcGxlOiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIGNsYXNzZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJlZml4KHtcbiAgICAgICAgICAgICAgICAnZmx1c2gnOiB0aGlzLmZsdXNoXG4gICAgICAgICAgICB9LCAnbGlzdC1ncm91cCcpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1ldGhvZHM6IHtcblxuICAgICAgICBiaW5kRXZlbnRzVG9DaGlsZHJlbigpIHtcbiAgICAgICAgICAgIGVhY2godGhpcy4kY2hpbGRyZW4sIGNoaWxkID0+IHtcbiAgICAgICAgICAgICAgICBjaGlsZC4kb2ZmKCdjbGljaycsIHRoaXMub25DbGlja0NoaWxkKTtcbiAgICAgICAgICAgICAgICBjaGlsZC4kb24oJ2NsaWNrJywgdGhpcy5vbkNsaWNrQ2hpbGQpO1xuICAgICAgICAgICAgICAgIGNoaWxkLiRvZmYoJ2FjdGl2YXRlJywgdGhpcy5vbkFjdGl2YXRlKTtcbiAgICAgICAgICAgICAgICBjaGlsZC4kb24oJ2FjdGl2YXRlJywgdGhpcy5vbkFjdGl2YXRlKTtcbiAgICAgICAgICAgICAgICBjaGlsZC4kb2ZmKCdkZWFjdGl2YXRlJywgdGhpcy5vbkRlYWN0aXZhdGUpO1xuICAgICAgICAgICAgICAgIGNoaWxkLiRvbignZGVhY3RpdmF0ZScsIHRoaXMub25EZWFjdGl2YXRlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uQ2xpY2tDaGlsZChldmVudCwgY2hpbGQpIHtcbiAgICAgICAgICAgIGlmKHRoaXMuYWN0aXZhdGVhYmxlKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQudG9nZ2xlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2NsaWNrOmNoaWxkJywgZXZlbnQsIGNoaWxkKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbkFjdGl2YXRlKGl0ZW0pIHtcbiAgICAgICAgICAgIGlmKCF0aGlzLm11bHRpcGxlICYmIHRoaXMuYWN0aXZlSXRlbSAhPT0gaXRlbSkge1xuICAgICAgICAgICAgICAgIGlmKHRoaXMuYWN0aXZlSXRlbSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZUl0ZW0uZGVhY3RpdmF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlSXRlbSA9IGl0ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25EZWFjdGl2YXRlKGl0ZW0pIHtcbiAgICAgICAgICAgIGlmKCF0aGlzLm11bHRpcGxlICYmIHRoaXMuYWN0aXZlSXRlbSA9PT0gaXRlbSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlSXRlbSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFjdGl2ZUl0ZW06IG51bGxcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtb3VudGVkKCkge1xuICAgICAgICB0aGlzLmJpbmRFdmVudHNUb0NoaWxkcmVuKCk7XG4gICAgfSxcblxuICAgIHVwZGF0ZWQoKSB7XG4gICAgICAgIHRoaXMuYmluZEV2ZW50c1RvQ2hpbGRyZW4oKTtcbiAgICB9XG5cbn1cblxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgTGlzdEdyb3VwIGZyb20gJy4vTGlzdEdyb3VwJztcbmltcG9ydCBWdWVJbnN0YWxsZXIgZnJvbSAnQC9IZWxwZXJzL1Z1ZUluc3RhbGxlci9WdWVJbnN0YWxsZXInO1xuXG5jb25zdCBwbHVnaW4gPSBWdWVJbnN0YWxsZXIudXNlKHtcblxuICAgIGluc3RhbGwoVnVlLCBvcHRpb25zKSB7XG4gICAgICAgIFZ1ZUluc3RhbGxlci5jb21wb25lbnRzKHtcbiAgICAgICAgICAgIExpc3RHcm91cFxuICAgICAgICB9KTtcbiAgICB9XG5cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBMaXN0R3JvdXA7XG4iLCI8dGVtcGxhdGU+XG4gICAgPG5hdiBjbGFzcz1cIm5hdlwiIDpjbGFzcz1cImNsYXNzZXNcIiA6cm9sZT1cInJvbGVcIj5cbiAgICAgICAgPG5hdmlnYXRpb24taXRlbSB2LWlmPVwiaXRlbXNcIiB2LWZvcj1cIihpdGVtLCBpKSBpbiBpdGVtc1wiIHYtYmluZD1cIml0ZW1cIiA6a2V5PVwiaVwiLz5cbiAgICAgICAgPHNsb3QvPlxuICAgIDwvbmF2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBwcmVmaXggZnJvbSAnQC9IZWxwZXJzL1ByZWZpeC9QcmVmaXgnO1xuaW1wb3J0IENvbG9yYWJsZSBmcm9tICdAL01peGlucy9Db2xvcmFibGUvQ29sb3JhYmxlJztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ25hdmlnYXRpb24nLFxuXG4gICAgbWl4aW5zOiBbXG4gICAgICAgIENvbG9yYWJsZVxuICAgIF0sXG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIZWxwZXIgdG8gYWRkIHRoZSBqdXN0aWZ5LWNvbnRlbnQtWCBjbGFzcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3Age0FycmF5fVxuICAgICAgICAgKi9cbiAgICAgICAgYWxpZ246IFN0cmluZyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gYXJyYXkgb2YgYnV0dG9uc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcCB7QXJyYXl9XG4gICAgICAgICAqL1xuICAgICAgICBidXR0b25zOiBBcnJheSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG5hdmlnYXRpb24gaW5zaWRlIGEgY2FyZFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcCB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGNhcmQ6IEJvb2xlYW4sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEp1c3RpZnkgbmF2IGl0ZW1zIHRvIGZpbGwgdGhlIHdpZHRoIGVxdWFsbHkgKHVzaW5nIGZsZXgpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcCB7QXJyYXl9XG4gICAgICAgICAqL1xuICAgICAgICBmaWxsOiBCb29sZWFuLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgYG5hdi1qdXN0aWZpZWRgIGNsYXNzIHRvIHRoZSBjb21wb25lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wIHtBcnJheX1cbiAgICAgICAgICovXG4gICAgICAgIGp1c3RpZmllZDogQm9vbGVhbixcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzcGxheSBpdGVtcyBhcyBwaWxsIHNoYXBlc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcCB7QXJyYXl9XG4gICAgICAgICAqL1xuICAgICAgICBwaWxsczogQm9vbGVhbixcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzcGxheSBpdGVtcyBhcyB0YWIgc2hhcGVzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wIHtBcnJheX1cbiAgICAgICAgICovXG4gICAgICAgIHRhYnM6IEJvb2xlYW4sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc3BsYXkgdGhlIGJ1dHRvbnMgdmVydGljYWxseVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcCB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHZlcnRpY2FsOiBCb29sZWFuLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcm9sZSBhdHRyaWJ1dGVcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3Age1N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHJvbGU6IFN0cmluZ1xuXG4gICAgfSxcblxuICAgIGNvbXB1dGVkOiB7XG5cbiAgICAgICAgY2xhc3NlcygpIHtcbiAgICAgICAgICAgIHRoaXMuJG5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZighdGhpcy5pc0NhcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0NhcmQgPSB0aGlzLiRwYXJlbnQuJGVsLmNsYXNzTGlzdC5jb250YWlucygnY2FyZC1oZWFkZXInKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJG1lcmdlQ2xhc3NlcyhcbiAgICAgICAgICAgICAgICBwcmVmaXgodGhpcy5hbGlnbiwgJ2p1c3RpZnktY29udGVudCcpLFxuICAgICAgICAgICAgICAgIHRoaXMuY29sb3JhYmxlQ2xhc3Nlcywge1xuICAgICAgICAgICAgICAgICAgICAnY2FyZC1oZWFkZXItdGFicyc6IHRoaXMuaXNDYXJkICYmIHRoaXMudGFicyxcbiAgICAgICAgICAgICAgICAgICAgJ2NhcmQtaGVhZGVyLXBpbGxzJzogdGhpcy5pc0NhcmQgJiYgdGhpcy5waWxscyxcbiAgICAgICAgICAgICAgICAgICAgJ25hdi1qdXN0aWZpZWQnOiB0aGlzLmp1c3RpZmllZCxcbiAgICAgICAgICAgICAgICAgICAgJ25hdi1maWxsJzogdGhpcy5maWxsLFxuICAgICAgICAgICAgICAgICAgICAnbmF2LXBpbGxzJzogdGhpcy5waWxscyxcbiAgICAgICAgICAgICAgICAgICAgJ25hdi10YWJzJzogdGhpcy50YWJzLFxuICAgICAgICAgICAgICAgICAgICAnZmxleC1jb2x1bW4nOiB0aGlzLnZlcnRpY2FsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpc0NhcmQ6IHRoaXMuY2FyZFxuICAgICAgICB9O1xuICAgIH1cblxufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gICAgPGEgOmhyZWY9XCJocmVmXCIgOmNsYXNzPVwiY2xhc3Nlc1wiPlxuICAgICAgICA8c2xvdCAvPlxuICAgIDwvYT5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAnbmF2aWdhdGlvbi1saW5rJyxcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElzIHRoZSBuYXZpZ2F0aW9uIGl0ZW0gYWN0aXZlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wIHtCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgYWN0aXZlOiBCb29sZWFuLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJcyB0aGUgbmF2aWdhdGlvbiBpdGVtIGRpc2FibGVkXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wIHtCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgZGlzYWJsZWQ6IEJvb2xlYW4sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBocmVmIGF0dHJpYnV0ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcCB7U3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgaHJlZjogU3RyaW5nLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgdGhlIG5hdi1pdGVtIGNsYXNzIHRvIHRoZSBsaW5rXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wIHtCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgaXRlbToge1xuICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBjb21wdXRlZDoge1xuXG4gICAgICAgIGNsYXNzZXMoKSB7XG4gICAgICAgICAgICB0aGlzLiRuZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYoIXRoaXMuaXNJdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNJdGVtID0gIXRoaXMuJHBhcmVudC4kZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCduYXYtaXRlbScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICduYXYtbGluayc6IHRoaXMuaHJlZixcbiAgICAgICAgICAgICAgICAnbmF2LWl0ZW0nOiB0aGlzLmlzSXRlbSxcbiAgICAgICAgICAgICAgICAnYWN0aXZlJzogdGhpcy5hY3RpdmUsXG4gICAgICAgICAgICAgICAgJ2Rpc2FibGVkJzogdGhpcy5kaXNhYmxlZFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlzSXRlbTogdGhpcy5pdGVtXG4gICAgICAgIH1cbiAgICB9XG5cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICAgIDxjb21wb25lbnQgOmlzPVwiY29tcG9uZW50XCIgOmNsYXNzPVwiY2xhc3Nlc1wiPlxuICAgICAgICA8c2xvdCAvPlxuICAgIDwvY29tcG9uZW50PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBOYXZpZ2F0aW9uTGluayBmcm9tICcuL05hdmlnYXRpb25MaW5rJztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ25hdmlnYXRpb24taXRlbScsXG5cbiAgICBleHRlbmRzOiBOYXZpZ2F0aW9uTGluayxcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBIVE1MIGVsZW1lbnRcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3Age1N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIGVsZW1lbnQ6IFN0cmluZyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSXMgdGhlIGNvbXBvbmVudCBhIGxpc3QgZWxlbWVudFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcCB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGxpc3Q6IEJvb2xlYW4sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCB0aGUgbmF2LWl0ZW0gY2xhc3MgdG8gdGhlIGxpbmtcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3Age0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBpdGVtOiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgICB9XG5cbiAgICB9LFxuXG5cbiAgICBjb21wdXRlZDoge1xuXG4gICAgICAgIGNvbXBvbmVudCgpIHtcbiAgICAgICAgICAgIGlmKHRoaXMuZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKHRoaXMuaHJlZikge1xuICAgICAgICAgICAgICAgIHJldHVybiAnYSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKHRoaXMubGlzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnbGknO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gJ2Rpdic7XG4gICAgICAgIH1cblxuICAgIH1cblxufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG5cbiAgICA8bmF2aWdhdGlvbi1pdGVtIGNsYXNzPVwiZHJvcGRvd25cIj5cblxuICAgICAgICA8c2xvdCBuYW1lPVwidG9nZ2xlLWJ1dHRvblwiPlxuICAgICAgICAgICAgPG5hdmlnYXRpb24tbGlua1xuICAgICAgICAgICAgICAgIGhyZWY9XCIjXCJcbiAgICAgICAgICAgICAgICBjbGFzcz1cImRyb3Bkb3duLXRvZ2dsZVwiXG4gICAgICAgICAgICAgICAgZGF0YS10b2dnbGU9XCJkcm9wZG93blwiXG4gICAgICAgICAgICAgICAgcm9sZT1cImJ1dHRvblwiXG4gICAgICAgICAgICAgICAgYXJpYS1oYXNwb3B1cD1cInRydWVcIlxuICAgICAgICAgICAgICAgIDphcmlhLWV4cGFuZGVkPVwiaXNEcm9wZG93blNob3dpbmdcIlxuICAgICAgICAgICAgICAgIEBjbGljay5uYXRpdmUucHJldmVudD1cInRvZ2dsZSgpXCJcbiAgICAgICAgICAgICAgICBAYmx1cj1cIm9uQmx1clwiPlxuICAgICAgICAgICAgICAgIHt7bGFiZWx9fVxuICAgICAgICAgICAgPC9uYXZpZ2F0aW9uLWxpbms+XG4gICAgICAgIDwvc2xvdD5cblxuICAgICAgICA8c2xvdCBuYW1lPVwiZHJvcGRvd24tbWVudVwiPlxuICAgICAgICAgICAgPGRyb3Bkb3duLW1lbnVcbiAgICAgICAgICAgICAgICA6aWQ9XCJpZFwiXG4gICAgICAgICAgICAgICAgOml0ZW1zPVwiaXRlbXNcIlxuICAgICAgICAgICAgICAgIDphbGlnbj1cImFsaWduXCJcbiAgICAgICAgICAgICAgICA6c2hvdy5zeW5jPVwiaXNEcm9wZG93blNob3dpbmdcIlxuICAgICAgICAgICAgICAgIEBpdGVtOmNsaWNrPVwib25JdGVtQ2xpY2tcIj5cbiAgICAgICAgICAgICAgICA8c2xvdC8+XG4gICAgICAgICAgICA8L2Ryb3Bkb3duLW1lbnU+XG4gICAgICAgIDwvc2xvdD5cblxuICAgIDwvbmF2aWdhdGlvbi1pdGVtPlxuXG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IEJ1dHRvbkRyb3Bkb3duIGZyb20gJ0AvQ29tcG9uZW50cy9CdXR0b25Ecm9wZG93bi9CdXR0b25Ecm9wZG93bic7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICduYXZpZ2F0aW9uLWRyb3Bkb3duJyxcblxuICAgIGV4dGVuZHM6IEJ1dHRvbkRyb3Bkb3duXG5cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IE5hdmlnYXRpb24gZnJvbSAnLi9OYXZpZ2F0aW9uJztcbmltcG9ydCBOYXZpZ2F0aW9uSXRlbSBmcm9tICcuL05hdmlnYXRpb25JdGVtJztcbmltcG9ydCBOYXZpZ2F0aW9uTGluayBmcm9tICcuL05hdmlnYXRpb25MaW5rJztcbmltcG9ydCBOYXZpZ2F0aW9uRHJvcGRvd24gZnJvbSAnLi9OYXZpZ2F0aW9uRHJvcGRvd24nO1xuaW1wb3J0IFZ1ZUluc3RhbGxlciBmcm9tICdAL0hlbHBlcnMvVnVlSW5zdGFsbGVyL1Z1ZUluc3RhbGxlcic7XG5cbmNvbnN0IHBsdWdpbiA9IFZ1ZUluc3RhbGxlci51c2Uoe1xuXG4gICAgaW5zdGFsbChWdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgVnVlSW5zdGFsbGVyLmNvbXBvbmVudHMoe1xuICAgICAgICAgICAgTmF2aWdhdGlvbixcbiAgICAgICAgICAgIE5hdmlnYXRpb25JdGVtLFxuICAgICAgICAgICAgTmF2aWdhdGlvbkxpbmssXG4gICAgICAgICAgICBOYXZpZ2F0aW9uRHJvcGRvd25cbiAgICAgICAgfSk7XG4gICAgfVxuXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgTmF2aWdhdGlvbjtcbiIsImltcG9ydCBPdmVybGF5IGZyb20gJy4vT3ZlcmxheSc7XG5pbXBvcnQgVnVlSW5zdGFsbGVyIGZyb20gJ0AvSGVscGVycy9WdWVJbnN0YWxsZXIvVnVlSW5zdGFsbGVyJztcblxuY29uc3QgcGx1Z2luID0gVnVlSW5zdGFsbGVyLnVzZSh7XG5cbiAgICBpbnN0YWxsKFZ1ZSwgb3B0aW9ucykge1xuICAgICAgICBWdWVJbnN0YWxsZXIuY29tcG9uZW50cyh7XG4gICAgICAgICAgICBPdmVybGF5XG4gICAgICAgIH0pO1xuICAgIH1cblxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IE92ZXJsYXk7XG4iLCI8dGVtcGxhdGU+XG4gICAgPG5hdiBhcmlhLWxhYmVsPVwiUGFnZSBuYXZpZ2F0aW9uIGV4YW1wbGVcIj5cbiAgICAgICAgPHVsIGNsYXNzPVwicGFnaW5hdGlvblwiIDpjbGFzcz1cImNsYXNzZXNcIj5cbiAgICAgICAgXHQ8bGkgY2xhc3M9XCJwYWdlLWl0ZW1cIiA6Y2xhc3M9XCJ7J2Rpc2FibGVkJzogY3VycmVudFBhZ2UgPT09IDF9XCI+XG4gICAgICAgIFx0XHQ8YSBocmVmPVwiI1wiIGNsYXNzPVwicGFnZS1saW5rXCIgYXJpYS1sYWJlbD1cIlByZXZpb3VzXCIgQGNsaWNrLnByZXZlbnQ9XCJwcmV2KCRldmVudClcIj5cbiAgICAgICAgXHRcdFx0PHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCI+JmxhcXVvOzwvc3Bhbj5cbiAgICAgICAgXHRcdDwvYT5cbiAgICAgICAgXHQ8L2xpPlxuICAgICAgICAgICAgPGxpIHYtZm9yPVwiaXRlbSBpbiBwYWdlc1wiIDpkYXRhLXBhZ2U9XCJpdGVtLnBhZ2VcIiBjbGFzcz1cInBhZ2UtaXRlbVwiIDpjbGFzcz1cInsnYWN0aXZlJzogaXRlbS5wYWdlID09PSBjdXJyZW50UGFnZSwgJ2Rpc2FibGVkJzogISFpdGVtLmRpdmlkZXJ9XCI+XG4gICAgICAgICAgICAgICAgPHNsb3QgOml0ZW09XCJpdGVtXCI+XG4gICAgICAgICAgICAgICAgICAgIDxhIHYtaWY9XCJpdGVtLmRpdmlkZXJcIiBjbGFzcz1cInBhZ2UtbGlua1wiPiZoZWxsaXA7PC9hPlxuICAgICAgICAgICAgICAgIFx0PGEgdi1lbHNlIGhyZWY9XCIjXCIgY2xhc3M9XCJwYWdlLWxpbmtcIiA6Y2xhc3M9XCJpdGVtLmNsYXNzXCIgOmRhdGEtbGFiZWw9XCJpdGVtLmxhYmVsXCIgQGNsaWNrLnByZXZlbnQ9XCJwYWdpbmF0ZShpdGVtLnBhZ2UsICRldmVudClcIj5cbiAgICAgICAgICAgICAgICBcdFx0PHNwYW4gdi1pZj1cIml0ZW0ubGFiZWxcIiBhcmlhLWhpZGRlbj1cInRydWVcIiB2LWh0bWw9XCJpdGVtLmxhYmVsXCI+PC9zcGFuPlxuICAgICAgICAgICAgICAgIFx0XHQ8c3BhbiB2LWlmPVwiaXRlbS5wYWdlXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCIgdi1odG1sPVwiaXRlbS5wYWdlXCI+PC9zcGFuPlxuICAgICAgICAgICAgICAgIFx0PC9hPlxuICAgICAgICAgICAgICAgIDwvc2xvdD5cbiAgICAgICAgICAgIDwvbGk+XG4gICAgICAgIFx0PGxpIGNsYXNzPVwicGFnZS1pdGVtXCIgOmNsYXNzPVwieydkaXNhYmxlZCc6IGN1cnJlbnRQYWdlID49IHRvdGFsUGFnZXN9XCI+XG4gICAgICAgIFx0XHQ8YSBocmVmPVwiI1wiIGNsYXNzPVwicGFnZS1saW5rXCIgYXJpYS1sYWJlbD1cIk5leHRcIiBAY2xpY2sucHJldmVudD1cIm5leHQoJGV2ZW50KVwiPlxuICAgICAgICBcdFx0XHQ8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj4mcmFxdW87PC9zcGFuPlxuICAgICAgICBcdFx0PC9hPlxuICAgICAgICAgICAgPC9saT5cbiAgICAgICAgPC91bD5cbiAgICA8L25hdj5cblxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdwYWdpbmF0aW9uJyxcblxuICAgIHByb3BzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYWxpZ25tZW50IG9mIHRoZSBwYWdpbmF0aW9uIGNvbXBvbmVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3AgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBhbGlnbjoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgdmFsaWRhdGU6IHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWydzdGFydCcsICdlbmQnLCAnY2VudGVyJ10uaW5kZXhPZih2YWx1ZSkgIT09IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcGFnZSBvbiB3aGljaCB0aGUgcGFnaW5hdG9yIHNob3VsZCBzdGFydC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3AgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBwYWdlOiB7XG4gICAgICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgICAgICBkZWZhdWx0OiAxXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0b3RhbCBudW1iZXIgb2YgcGFnZXMgaW4gdGhlIHBhZ2luYXRvci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3AgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICB0b3RhbFBhZ2VzOiB7XG4gICAgICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgICAgICBkZWZhdWx0OiAxXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBudW1iZXIgb2YgcGFnZXMgdG8gc2hvdyB3aGVuIHRoZSB0b3RhbCBudW1iZXIgb2YgcGFnZXMgaXNcbiAgICAgICAgICogZ3JlYXRlciB0aGFuIHRoZSBudW1iZXIgb2YgcGFnZXMgdGhhdCBzaG91bGQgYmUgc2hvd24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wIFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgc2hvd1BhZ2VzOiB7XG4gICAgICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgICAgICBkZWZhdWx0OiA2XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25QYWdpbmF0ZTogRnVuY3Rpb25cbiAgICB9LFxuXG4gICAgbWV0aG9kczoge1xuXG4gICAgICAgIG5leHQoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMucGFnaW5hdGUodGhpcy5jdXJyZW50UGFnZSA+PSB0aGlzLnRvdGFsUGFnZXMgPyB0aGlzLmN1cnJlbnRQYWdlIDogdGhpcy5jdXJyZW50UGFnZSArIDEsIGV2ZW50KTtcbiAgICAgICAgfSxcblxuICAgICAgICBwcmV2KGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLnBhZ2luYXRlKHRoaXMuY3VycmVudFBhZ2UgPD0gMSA/IHRoaXMuY3VycmVudFBhZ2UgOiB0aGlzLmN1cnJlbnRQYWdlIC0gMSwgZXZlbnQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBhZ2luYXRlKHBhZ2UsIGV2ZW50KSB7XG4gICAgICAgICAgICBpZihldmVudC5jdXJyZW50VGFyZ2V0LnBhcmVudE5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKCdkaXNhYmxlZCcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG5cdFx0XHR0aGlzLnNldEFjdGl2ZVBhZ2UocGFnZSk7XG5cbiAgICAgICAgICAgIGlmKHRoaXMub25QYWdpbmF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMub25QYWdpbmF0ZShwYWdlLCBldmVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ3BhZ2luYXRlJywgcGFnZSwgZXZlbnQpO1xuICAgICAgICB9LFxuXG5cdFx0c2V0QWN0aXZlUGFnZShwYWdlKSB7XG5cdFx0XHRpZih0aGlzLmN1cnJlbnRQYWdlICE9PSBwYWdlKSB7XG5cdFx0XHRcdHRoaXMuY3VycmVudFBhZ2UgPSBwYWdlO1xuXHRcdFx0fVxuXHRcdH0sXG5cbiAgICAgICAgZ2VuZXJhdGUoKSB7XG4gICAgICAgICAgICBjb25zdCBwYWdlcyA9IFtdO1xuICAgICAgICAgICAgY29uc3Qgc2hvd1BhZ2VzID0gdGhpcy5zaG93UGFnZXMgJSAyID8gdGhpcy5zaG93UGFnZXMgKyAxOiB0aGlzLnNob3dQYWdlcztcblxuICAgICAgICAgICAgbGV0IHN0YXJ0UGFnZSA9ICh0aGlzLmN1cnJlbnRQYWdlID49IHNob3dQYWdlcykgPyB0aGlzLmN1cnJlbnRQYWdlIC0gKHNob3dQYWdlcyAvIDIpIDogMTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gc2hvd1BhZ2VzICsgc3RhcnRQYWdlO1xuICAgICAgICAgICAgY29uc3QgZW5kUGFnZSA9ICh0aGlzLnRvdGFsUGFnZXMgPCBzdGFydE9mZnNldCkgPyB0aGlzLnRvdGFsUGFnZXMgOiBzdGFydE9mZnNldDtcbiAgICAgICAgICAgIGNvbnN0IGRpZmYgPSBzdGFydFBhZ2UgLSBlbmRQYWdlICsgc2hvd1BhZ2VzO1xuXG4gICAgICAgICAgICBzdGFydFBhZ2UgLT0gKHN0YXJ0UGFnZSAtIGRpZmYgPiAwKSA/IGRpZmYgOiAwO1xuXG4gICAgICAgICAgICBpZiAoc3RhcnRQYWdlID4gMSkge1xuICAgICAgICAgICAgICAgIHBhZ2VzLnB1c2goe3BhZ2U6IDF9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoc3RhcnRQYWdlID4gMikge1xuICAgICAgICAgICAgICAgIHBhZ2VzLnB1c2goe2RpdmlkZXI6IHRydWV9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yKGxldCBpID0gc3RhcnRQYWdlOyBpIDwgZW5kUGFnZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcGFnZXMucHVzaCh7cGFnZTogaX0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZW5kUGFnZSA8PSB0aGlzLnRvdGFsUGFnZXMpIHtcbiAgICAgICAgICAgICAgICBpZih0aGlzLnRvdGFsUGFnZXMgLSAxID4gZW5kUGFnZSkge1xuICAgICAgICAgICAgICAgICAgICBwYWdlcy5wdXNoKHtkaXZpZGVyOiB0cnVlfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcGFnZXMucHVzaCh7cGFnZTogdGhpcy50b3RhbFBhZ2VzfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBwYWdlcztcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGNvbXB1dGVkOiB7XG5cbiAgICAgICAgcGFnZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsYXNzZXMoKSB7XG4gICAgICAgICAgICBjb25zdCBjbGFzc2VzID0ge307XG5cbiAgICAgICAgICAgIGNsYXNzZXNbJ2p1c3RpZnktY29udGVudC0nICsgdGhpcy5hbGlnbl0gPSB0cnVlO1xuXG4gICAgICAgICAgICByZXR1cm4gY2xhc3NlcztcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiAge1xuICAgICAgICAgICAgY3VycmVudFBhZ2U6IHRoaXMucGFnZVxuICAgICAgICB9O1xuICAgIH1cblxufTtcbjwvc2NyaXB0PlxuIiwiaW1wb3J0IFBhZ2luYXRpb24gZnJvbSAnLi9QYWdpbmF0aW9uJztcbmltcG9ydCBWdWVJbnN0YWxsZXIgZnJvbSAnQC9IZWxwZXJzL1Z1ZUluc3RhbGxlci9WdWVJbnN0YWxsZXInO1xuXG5jb25zdCBwbHVnaW4gPSBWdWVJbnN0YWxsZXIudXNlKHtcblxuICAgIGluc3RhbGwoVnVlLCBvcHRpb25zKSB7XG4gICAgICAgIFZ1ZUluc3RhbGxlci5jb21wb25lbnRzKHtcbiAgICAgICAgICAgIFBhZ2luYXRpb25cbiAgICAgICAgfSk7XG4gICAgfVxuXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgUGFnaW5hdGlvbjtcbiIsImltcG9ydCBQcm9ncmVzc0JhciBmcm9tICcuL1Byb2dyZXNzQmFyJztcbmltcG9ydCBWdWVJbnN0YWxsZXIgZnJvbSAnQC9IZWxwZXJzL1Z1ZUluc3RhbGxlci9WdWVJbnN0YWxsZXInO1xuXG5jb25zdCBwbHVnaW4gPSBWdWVJbnN0YWxsZXIudXNlKHtcblxuICAgIGluc3RhbGwoVnVlLCBvcHRpb25zKSB7XG4gICAgICAgIFZ1ZUluc3RhbGxlci5jb21wb25lbnRzKHtcbiAgICAgICAgICAgIFByb2dyZXNzQmFyXG4gICAgICAgIH0pO1xuICAgIH1cblxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IFByb2dyZXNzQmFyO1xuIiwiaW1wb3J0IFJhZGlvRmllbGQgZnJvbSAnLi9SYWRpb0ZpZWxkJztcbmltcG9ydCBWdWVJbnN0YWxsZXIgZnJvbSAnQC9IZWxwZXJzL1Z1ZUluc3RhbGxlci9WdWVJbnN0YWxsZXInO1xuXG5jb25zdCBwbHVnaW4gPSBWdWVJbnN0YWxsZXIudXNlKHtcblxuICAgIGluc3RhbGwoVnVlLCBvcHRpb25zKSB7XG4gICAgICAgIFZ1ZUluc3RhbGxlci5jb21wb25lbnRzKHtcbiAgICAgICAgICAgIFJhZGlvRmllbGRcbiAgICAgICAgfSk7XG4gICAgfVxuXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgUmFkaW9GaWVsZDtcbiIsIjx0ZW1wbGF0ZT5cblxuICAgIDxmb3JtLWdyb3VwPlxuXG4gICAgICAgIDxzbG90IG5hbWU9XCJsYWJlbFwiPlxuICAgICAgICAgICAgPGZvcm0tbGFiZWwgdi1pZj1cImxhYmVsXCIgOmZvcj1cImlkXCIgdi1odG1sPVwibGFiZWxcIi8+XG4gICAgICAgIDwvc2xvdD5cblxuICAgICAgICA8c2xvdCBuYW1lPVwiY29udHJvbFwiPlxuICAgICAgICAgICAgPHNlbGVjdFxuICAgICAgICAgICAgICAgIDppZD1cImlkXCJcbiAgICAgICAgICAgICAgICA6dmFsdWU9XCJ2YWx1ZVwiXG4gICAgICAgICAgICAgICAgOnJlcXVpcmVkPVwicmVxdWlyZWRcIlxuICAgICAgICAgICAgICAgIDpkaXNhYmxlZD1cImRpc2FibGVkIHx8IHJlYWRvbmx5XCJcbiAgICAgICAgICAgICAgICA6cmVhZG9ubHk9XCJyZWFkb25seVwiXG4gICAgICAgICAgICAgICAgOnBhdHRlcm49XCJwYXR0ZXJuXCJcbiAgICAgICAgICAgICAgICA6Y2xhc3M9XCIkbWVyZ2VDbGFzc2VzKGNvbnRyb2xDbGFzc2VzLCBjb2xvcmFibGVDbGFzc2VzKVwiXG4gICAgICAgICAgICAgICAgdi1vbjppbnB1dD1cInVwZGF0ZWQoJGV2ZW50LnRhcmdldC52YWx1ZSlcIj5cbiAgICAgICAgICAgICAgICA8c2xvdCAvPlxuICAgICAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgIDwvc2xvdD5cblxuICAgICAgICA8c2xvdCBuYW1lPVwiaGVscFwiPlxuICAgICAgICAgICAgPGhlbHAtdGV4dCB2LWlmPVwiaGVscFRleHRcIiB2LWh0bWw9XCJoZWxwVGV4dFwiIC8+XG4gICAgICAgIDwvc2xvdD5cblxuICAgICAgICA8c2xvdCBuYW1lPVwiZmVlZGJhY2tcIj5cbiAgICAgICAgICAgIDxmb3JtLWZlZWRiYWNrIHYtaWY9XCJ2YWxpZEZlZWRiYWNrXCIgdi1odG1sPVwidmFsaWRGZWVkYmFja1wiIHZhbGlkIC8+XG4gICAgICAgICAgICA8Zm9ybS1mZWVkYmFjayB2LWlmPVwiaW52YWxpZEZlZWRiYWNrXCIgdi1odG1sPVwiaW52YWxpZEZlZWRiYWNrXCIgaW52YWxpZCAvPlxuICAgICAgICA8L3Nsb3Q+XG5cbiAgICA8L2Zvcm0tZ3JvdXA+XG5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5cbi8vaW1wb3J0IEJhc2VGaWVsZCBmcm9tICcuL0Jhc2VGaWVsZCc7XG5pbXBvcnQgQ29sb3JhYmxlIGZyb20gJ0AvTWl4aW5zL0NvbG9yYWJsZS9Db2xvcmFibGUnO1xuaW1wb3J0IEZvcm1Db250cm9sIGZyb20gJ0AvTWl4aW5zL0Zvcm1Db250cm9sL0Zvcm1Db250cm9sJztcblxuY29uc3QgQ1VTVE9NX1NFTEVDVF9QUkVGSVggPSAnY3VzdG9tLXNlbGVjdC0nXG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdzZWxlY3QtZmllbGQnLFxuXG4gICAgZXh0ZW5kczogRm9ybUNvbnRyb2wsXG5cbiAgICBtaXhpbnM6IFtcbiAgICAgICAgRm9ybUNvbnRyb2wsXG4gICAgICAgIENvbG9yYWJsZVxuICAgIF0sXG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgYGN1c3RvbS1zZWxlY3RgIHRvIHRoZSBmb3JtIGNvbnRyb2wgaWYgdHJ1ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgY3VzdG9tOiBCb29sZWFuXG5cbiAgICB9LFxuXG4gICAgY29tcHV0ZWQ6IHtcblxuICAgICAgICBjb250cm9sQ2xhc3MoKSB7XG4gICAgICAgICAgICBjb25zdCBjb250cm9sQ2xhc3MgPSB0aGlzLmN1c3RvbSA/ICdjdXN0b20tc2VsZWN0JyA6IHRoaXMuZGVmYXVsdENvbnRyb2xDbGFzcztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBsYWludGV4dCA/IGAke2NvbnRyb2xDbGFzc30tcGxhaW50ZXh0YCA6IGNvbnRyb2xDbGFzcztcbiAgICAgICAgfSxcblxuICAgICAgICBjdXN0b21TZWxlY3RDbGFzc2VzKCkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBDVVNUT01fU0VMRUNUX1BSRUZJWC5yZXBsYWNlKC9cXC0kLywgJycpICsgKHRoaXMucGxhaW50ZXh0ID8gJy1wbGFpbnRleHQnIDogJycpLFxuICAgICAgICAgICAgICAgIHRoaXMuY3VzdG9tU2VsZWN0U2l6ZUNsYXNzLFxuICAgICAgICAgICAgICAgICh0aGlzLnNwYWNpbmcgfHwgJycpXG4gICAgICAgICAgICBdLmpvaW4oJyAnKTtcbiAgICAgICAgfVxuICAgIH1cblxufVxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgU2VsZWN0RmllbGQgZnJvbSAnLi9TZWxlY3RGaWVsZCc7XG5pbXBvcnQgVnVlSW5zdGFsbGVyIGZyb20gJ0AvSGVscGVycy9WdWVJbnN0YWxsZXIvVnVlSW5zdGFsbGVyJztcblxuY29uc3QgcGx1Z2luID0gVnVlSW5zdGFsbGVyLnVzZSh7XG5cbiAgICBpbnN0YWxsKFZ1ZSwgb3B0aW9ucykge1xuICAgICAgICBWdWVJbnN0YWxsZXIuY29tcG9uZW50cyh7XG4gICAgICAgICAgICBTZWxlY3RGaWVsZFxuICAgICAgICB9KTtcbiAgICB9XG5cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBTZWxlY3RGaWVsZDtcbiIsImltcG9ydCB7IGVhY2ggfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgaXNBcnJheSB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBpc09iamVjdCB9IGZyb20gJ2xvZGFzaCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRyYW5zZm9ybWVyIHtcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgdGhlIHRyYW5zZm9ybWVyIGluc3RhbmNlIHVzaW5nIGFuIEhUVFAgcmVzcG9uc2Ugb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGEgb2JqZWN0XG4gICAgICogQHJldHVybiB2b2lkXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocmVzcG9uc2UpIHtcbiAgICAgICAgaWYoIWlzT2JqZWN0KHRoaXMuJG9yaWdpbmFsUmVzcG9uc2UgPSByZXNwb25zZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHRyYW5zZm9ybWVyIG11c3QgYmUgaW5zdGFudGlhdGVkIHdpdGggYSByZXNwb25zZSBvYmplY3QuJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmKCFpc0FycmF5KHRoaXMuJHJlcXVpcmVkID0gdGhpcy5yZXF1aXJlZCgpKSB8fCAhdGhpcy4kcmVxdWlyZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgdHJhbnNmb3JtZXIgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSByZXF1aXJlZCBwcm9wZXJ0eS4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuJHRyYW5zZm9ybWVkUmVzcG9uc2UgPSB0aGlzLnRyYW5zZm9ybShyZXNwb25zZSk7XG4gICAgICAgIHRoaXMudmFsaWRhdGUoKTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBtZXRob2QgdG8gb3ZlcnJpZGUgdG8gcGVyZm9ybSBsb2dpYyB0byBmaW5pc2hlZCBpbml0aWFsaXppbmcuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgKi9cbiAgICBpbml0aWFsaXplKCkge1xuICAgICAgICAvL1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlZmluZSBhbiBhcnJheSBvZiByZXF1aXJlZCBwcm9wZXJ0aWUgd2l0aCBhdCBsZWFzdCBvbmUgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgKi9cbiAgICByZXF1aXJlZCgpIHtcbiAgICAgICAgLy9cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmFuZm9ybSB0aGUgcmVzcG9uc2Ugb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICovXG4gICAgdHJhbnNmb3JtKHJlc3BvbnNlKSB7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHRyYW5mb3JtZWQgcmVzcG9uc2VcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgKi9cbiAgICByZXNwb25zZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHRyYW5zZm9ybWVkUmVzcG9uc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVmFsaWRhdGUgdGhlIHRyYW5mb3JtZWQgcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgKi9cbiAgICB2YWxpZGF0ZSgpIHtcbiAgICAgICAgaWYoIWlzT2JqZWN0KHRoaXMuJHRyYW5zZm9ybWVkUmVzcG9uc2UpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSB0cmFuc2Zvcm1lZCByZXNwb25zZSBtdXN0IGJlIGFuIG9iamVjdC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVhY2godGhpcy4kcmVxdWlyZWQsIGtleSA9PiB7XG4gICAgICAgICAgICBpZighKGtleSBpbiB0aGlzLiR0cmFuc2Zvcm1lZFJlc3BvbnNlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke2tleX1cIiBpcyBhIHJlcXVpcmVkIHByb3BlcnR5IGFuZCBkb2VzIG5vdCBleGlzdCBpbiB0aGUgdHJhbmZvcm1lZCByZXNwb25zZS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG59XG4iLCJpbXBvcnQgeyBlYWNoIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IGlzQXJyYXkgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgaXNPYmplY3QgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IFRyYW5zZm9ybWVyIGZyb20gJy4uL1RyYW5zZm9ybWVyJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGFibGVWaWV3VHJhbnNmb3JtZXIgZXh0ZW5kcyBUcmFuc2Zvcm1lciB7XG5cbiAgICByZXF1aXJlZCgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIC8vIFRoZSBlbmQgb2YgdGhlIGNvdW50IG9mIHRoZSBwYWdpbmF0ZWQgbGlzdC5cbiAgICAgICAgICAgICd0bycsXG5cbiAgICAgICAgICAgIC8vIFRoZSBzdGFydCBvZiB0aGUgY291bnQgb2YgdGhlIHBhZ2luYXRlZCBsaXN0LlxuICAgICAgICAgICAgJ2Zyb20nLFxuXG4gICAgICAgICAgICAvLyBUaGUgdG90YWwgbnVtYmVyIG9mIGl0ZW1zIChub3QganVzdCBpbmNsdWRlZCBpbiB0aGUgcGFnaW5hdGlvbilcbiAgICAgICAgICAgICd0b3RhbCcsXG5cbiAgICAgICAgICAgIC8vIFRoZSBudW1iZXIgb2YgaXRlbXMgcGVyIHBhZ2VcbiAgICAgICAgICAgICdwZXJfcGFnZScsXG5cbiAgICAgICAgICAgIC8vIFRoZSBsYXN0IHBhZ2UgbnVtYmVyIChvciB0b3RhbCBwYWdlcylcbiAgICAgICAgICAgICdsYXN0X3BhZ2UnLFxuXG4gICAgICAgICAgICAvLyBUaGUgY3VycmVudCBwYWdlIG51bWJlclxuICAgICAgICAgICAgJ2N1cnJlbnRfcGFnZScsXG5cbiAgICAgICAgICAgIC8vIFRoZSBhY3R1YWwgcmVzcG9uc2UgZGF0YSB0byBhcHBlYXIgaW4gdGhlIHRhYmxlXG4gICAgICAgICAgICAnZGF0YSdcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICBkYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kdHJhbnNmb3JtZWRSZXNwb25zZS5kYXRhO1xuICAgIH1cblxuICAgIGluaXRpYWxpemUoKSB7XG4gICAgICAgIGlmKCFpc0FycmF5KHRoaXMuZGF0YSgpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZGF0YSBwcm9wZXJ0eSBtdXN0IGJlIGFuIGFycmF5LicpO1xuICAgICAgICB9XG4gICAgfVxuXG59XG4iLCI8dGVtcGxhdGU+XG5cbiAgICA8ZGl2IGNsYXNzPVwidGFibGUtdmlld1wiPlxuXG4gICAgICAgIDxkaXYgY2xhc3M9XCJkLWZsZXgganVzdGlmeS1jb250ZW50LWJldHdlZW4gYWxpZ24taXRlbXMtY2VudGVyXCI+XG4gICAgICAgICAgICA8c2xvdCBuYW1lPVwiaGVhZGVyXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRhYmxlLXZpZXctaGVhZGVyXCI+XG4gICAgICAgICAgICAgICAgICAgIDxzbG90IG5hbWU9XCJoZWFkaW5nXCI+PGgzIHYtaWY9XCJoZWFkaW5nXCIgdi1odG1sPVwiaGVhZGluZ1wiPjwvaDM+PC9zbG90PlxuICAgICAgICAgICAgICAgICAgICA8c2xvdCBuYW1lPVwiZGVzY3JpcHRpb25cIj48cCB2LWlmPVwiZGVzY3JpcHRpb25cIiB2LWh0bWw9XCJkZXNjcmlwdGlvblwiPjwvcD48L3Nsb3Q+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L3Nsb3Q+XG5cbiAgICAgICAgICAgIDxzbG90IG5hbWU9XCJidXR0b25zXCI+XG4gICAgICAgICAgICAgICAgPGRpdiB2LWlmPVwiYnV0dG9ucy5sZW5ndGhcIiBjbGFzcz1cImJ1dHRvbnMtd3JhcHBlciBteS0zXCI+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuPlxuICAgICAgICAgICAgICAgIFx0XHQ8YSB2LWZvcj1cIihidXR0b24sIGtleSkgaW4gYnV0dG9uc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOmhyZWY9XCJidXR0b24uaHJlZiB8fCAnIydcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDpjbGFzcz1cImJ1dHRvbi5jbGFzc05hbWUgfHwgJ2J0biBidG4tcHJpbWFyeSdcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEBjbGljaz1cInByb3h5KGJ1dHRvbi5vbkNsaWNrLCAkZXZlbnQpXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGkgdi1pZj1cImJ1dHRvbi5pY29uXCIgOmNsYXNzPVwiYnV0dG9uLmljb25cIj48L2k+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gdi1odG1sPVwiYnV0dG9uLmxhYmVsXCI+PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9hPlxuICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L3Nsb3Q+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIDx0YWJsZSBjbGFzcz1cInRhYmxlXCIgOmNsYXNzPVwieyd0YWJsZS1ob3Zlcic6IGhvdmVyICYmICFsb2FkaW5nICYmIGRhdGEubGVuZ3RofVwiPlxuXG4gICAgICAgICAgICA8c2xvdCBuYW1lPVwidGhlYWRcIj5cbiAgICAgICAgICAgIFx0PHRoZWFkPlxuICAgICAgICAgICAgXHRcdDx0cj5cbiAgICAgICAgICAgIFx0XHRcdDx0aCBzY29wZT1cImNvbFwiIDp3aWR0aD1cImNvbHVtbi53aWR0aFwiIHYtZm9yPVwiY29sdW1uIGluIHRhYmxlQ29sdW1uc1wiPlxuICAgICAgICAgICAgXHRcdFx0ICAgIDxkaXYgdi1pZj1cImNvbHVtbi5pZFwiPlxuICAgICAgICAgICAgXHRcdFx0XHRcdDxhIGhyZWY9XCIjXCIgY2xhc3M9XCJzb3J0XCIgOmRhdGEtaWQ9XCJjb2x1bW4uaWRcIiBAY2xpY2sucHJldmVudD1cIm9yZGVyQnkoY29sdW1uLmlkKVwiIHYtaHRtbD1cImNvbHVtbi5uYW1lIHx8IGNvbHVtbi5pZFwiPjwvYT5cbiAgICAgICAgICAgIFx0XHRcdFx0XHQ8aSB2LWlmPVwicmVxdWVzdC5wYXJhbXMub3JkZXIgPT09IGNvbHVtbi5pZCAmJiByZXF1ZXN0LnBhcmFtcy5zb3J0ID09PSAnYXNjJ1wiIGNsYXNzPVwic29ydC1pY29uIGZhIGZhLXNvcnQtYXNjXCI+PC9pPlxuICAgICAgICAgICAgXHRcdFx0XHRcdDxpIHYtaWY9XCJyZXF1ZXN0LnBhcmFtcy5vcmRlciA9PT0gY29sdW1uLmlkICYmIHJlcXVlc3QucGFyYW1zLnNvcnQgPT09ICdkZXNjJ1wiIGNsYXNzPVwic29ydC1pY29uIGZhIGZhLXNvcnQtZGVzY1wiPjwvaT5cbiAgICAgICAgICAgIFx0XHRcdFx0PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiB2LWVsc2Ugdi1odG1sPVwiY29sdW1uLm5hbWVcIj48L2Rpdj5cbiAgICAgICAgICAgIFx0XHRcdDwvdGg+XG4gICAgICAgICAgICBcdFx0PC90cj5cbiAgICAgICAgICAgIFx0PC90aGVhZD5cbiAgICAgICAgICAgIDwvc2xvdD5cblxuICAgICAgICAgICAgPHNsb3QgbmFtZT1cInRib2R5XCI+XG4gICAgICAgICAgICAgICAgPHRib2R5PlxuICAgICAgICAgICAgICAgICAgICA8dHIgdi1pZj1cImxvYWRpbmdcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCA6Y29sc3Bhbj1cInRhYmxlQ29sdW1ucy5sZW5ndGhcIiBjbGFzcz1cInBvc2l0aW9uLXJlbGF0aXZlXCIgOnN0eWxlPVwieydoZWlnaHQnOiBoZWlnaHQobWluSGVpZ2h0KX1cIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YWN0aXZpdHktaW5kaWNhdG9yIDpjZW50ZXI9XCJ0cnVlXCI+PC9hY3Rpdml0eS1pbmRpY2F0b3I+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgICAgICAgICA8L3RyPlxuXG4gICAgICAgICAgICAgICAgICAgIDx0ciB2LWVsc2UtaWY9XCIhZGF0YS5sZW5ndGhcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCA6Y29sc3Bhbj1cInRhYmxlQ29sdW1ucy5sZW5ndGhcIiBjbGFzcz1cInBvc2l0aW9uLXJlbGF0aXZlXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGFsZXJ0IHZhcmlhbnQ9XCJ3YXJuaW5nXCIgY2xhc3M9XCJteS0zXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVwiZmEgZmEtd2FybmluZ1wiLz4gVGhlcmUgYXJlIG5vIHJlc3VsdHMgZm91bmQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9hbGVydD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICAgICAgICAgIDwvdHI+XG5cbiAgICAgICAgICAgICAgICAgICAgPHNsb3Qgdi1lbHNlIDpkYXRhPVwiZGF0YVwiIDpjb2x1bW5zPVwidGFibGVDb2x1bW5zXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dHIgdi1mb3I9XCIocm93LCBpKSBpbiBkYXRhXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIHYtZm9yPVwiY29sdW1uIGluIHRhYmxlQ29sdW1uc1wiIHYtaHRtbD1cInJvd1tjb2x1bW4uaWRdIHx8IHJvd1tjb2x1bW4ubmFtZV1cIj48L3RkPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cbiAgICAgICAgICAgICAgICAgICAgPC9zbG90PlxuICAgICAgICAgICAgICAgIDwvdGJvZHk+XG4gICAgICAgICAgICA8L3Nsb3Q+XG5cbiAgICAgICAgICAgIDxzbG90IG5hbWU9XCJ0Zm9vdFwiPlxuICAgICAgICAgICAgXHQ8dGZvb3Q+XG4gICAgICAgICAgICBcdFx0PHRkIDpjb2xzcGFuPVwidGFibGVDb2x1bW5zLmxlbmd0aFwiIGNsYXNzPVwidGFibGUtdmlldy1mb290ZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzbG90IG5hbWU9XCJwYWdpbmF0aW9uXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHBhZ2luYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdi1pZj1cInBhZ2luYXRlICYmIHJlc3BvbnNlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ249XCJjZW50ZXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6cGFnZT1cInJlc3BvbnNlLmN1cnJlbnRfcGFnZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDp0b3RhbC1wYWdlcz1cInJlc3BvbnNlLmxhc3RfcGFnZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDpvbi1wYWdpbmF0ZT1cIm9uUGFnaW5hdGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L3Nsb3Q+XG4gICAgICAgICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICBcdDwvdGZvb3Q+XG4gICAgICAgICAgICA8L3Nsb3Q+XG5cbiAgICAgICAgPC90YWJsZT5cblxuICAgIDwvZGl2PlxuXG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IHsga2V5cyB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBlYWNoIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IGV4dGVuZCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBpc09iamVjdCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgUGFnaW5hdGlvbiBmcm9tICcuLi9QYWdpbmF0aW9uJztcbmltcG9ydCBBY3Rpdml0eUluZGljYXRvciBmcm9tICcuLi9BY3Rpdml0eUluZGljYXRvcic7XG5pbXBvcnQgUHJveHkgZnJvbSAnQC9NaXhpbnMvUHJveHkvUHJveHknO1xuaW1wb3J0IFJlcXVlc3QgZnJvbSAnQC9IdHRwL1JlcXVlc3QvUmVxdWVzdCc7XG5pbXBvcnQgVGFibGVWaWV3VHJhbnNmb3JtZXIgZnJvbSAnQC9IdHRwL1RhYmxlVmlld1RyYW5zZm9ybWVyL1RhYmxlVmlld1RyYW5zZm9ybWVyJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIG5hbWU6ICd0YWJsZS12aWV3JyxcblxuICAgIG1peGluczogW1Byb3h5XSxcblxuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgICAgUGFnaW5hdGlvbixcbiAgICAgICAgQWN0aXZpdHlJbmRpY2F0b3JcbiAgICB9LFxuXG4gICAgcHJvcHM6IHtcbiAgICAgICAgLy8gKHN0cmluZykgQSByZWxhdGl2ZSBvciBhYnNvbHV0ZSBlbmRwb2ludCBVUkwgdXNlZCB0byBmZXRjaCBkYXRhXG4gICAgICAgIHVybDoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICAvLyAoaW50ZWdlcikgVGhlIHN0YXJ0aW5nIHBhZ2Ugb2YgdGhlIHRhYmxlXG4gICAgICAgIHBhZ2U6IHtcbiAgICAgICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgICAgIGRlZmF1bHQ6IDFcbiAgICAgICAgfSxcblxuICAgICAgICAvLyAoaW50ZWdlcikgVGhlIHRvdGFsIG51bWJlciBvZiByZXN1bHRzIHBlciBwYWdlXG4gICAgICAgIGxpbWl0OiB7XG4gICAgICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgICAgICBkZWZhdWx0OiAyMFxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIChzdHJpbmcpIFRoZSBjb2x1bW4gdXNlZCB0byBvcmRlciB0aGUgZGF0YVxuICAgICAgICBvcmRlcjogU3RyaW5nLFxuXG4gICAgICAgIC8vIChzdHJpbmcpIFRoZSBzb3J0IGRpcmVjdGlvbiAoYXNjfGRlc2MpXG4gICAgICAgIHNvcnQ6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIHZhbGlkYXRlOiAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWydhc2MnLCAnZGVzYyddLmluZGV4T2YodmFsdWUpICE9PSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyAoaW50ZWdlcikgVGhlIG1pbmltdW0gaGVpZ2h0IG9mIHRoZSByb3cgd2hlbiBsb2FkaW5nIGRhdGFcbiAgICAgICAgbWluSGVpZ2h0OiB7XG4gICAgICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgICAgICBkZWZhdWx0OiA0MDBcbiAgICAgICAgfSxcblxuICAgICAgICAvLyAoYXJyYXkpIEFuIGFycmF5IG9mIGJ1dHRvbiBvYmplY3RzXG4gICAgICAgIC8vIFt7aHJlZjogJ3Rlc3QtMTIzJywgbGFiZWw6ICdUZXN0IDEyMyd9XVxuICAgICAgICBidXR0b25zOiB7XG4gICAgICAgICAgICB0eXBlOiBBcnJheSxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICgpID0+IHsgcmV0dXJuIFtdOyB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gKGFycmF5KSBBbiBhcnJheSBvZiB0YWJsZSBjb2x1bW5cbiAgICAgICAgLy8gW3tpZDogJ2RhdGFiYXNlX2lkJywgbmFtZTogJ0RhdGFiYXNlIGlkJywgd2lkdGg6ICcyMCUnfV1cbiAgICAgICAgY29sdW1uczoge1xuICAgICAgICAgICAgdHlwZTogQXJyYXksXG4gICAgICAgICAgICBkZWZhdWx0OiAoKSA9PiB7IHJldHVybiBbXTsgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIChzdHJpbmcpIFRoZSB0YWJsZSBoZWFkaW5nXG4gICAgICAgIGhlYWRpbmc6IFN0cmluZyxcblxuICAgICAgICAvLyAoc3RyaW5nKSBBZGQgdGFibGUtaG92ZXIgdG8gdGhlIHRhYmxlIGVsZW1lbnRcbiAgICAgICAgaG92ZXI6IHtcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgICBkZWZhdWx0OiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gKHN0cmluZykgVGhlIHRhYmxlIGRlc2NyaXB0aW9uXG4gICAgICAgIGRlc2NyaXB0aW9uOiBTdHJpbmcsXG5cbiAgICAgICAgLy8gKGJvb2wpIFNob3VsZCBzaG93IHRoZSBwYWdpbmF0aW9uIGZvciB0aGlzIHRhYmxlXG4gICAgICAgIHBhZ2luYXRlOiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIChvYmplY3QpIFRoZSBIVFRQIHJlc3BvbnNlIHRyYW5zZm9ybWVyIGluc3RhbmNlXG4gICAgICAgIHRyYW5zZm9ybWVyOiB7XG4gICAgICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgICAgICB2YWxpZGF0ZTogKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgVGFibGVWaWV3VHJhbnNmb3JtZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgdGFibGVDb2x1bW5zKCkge1xuICAgICAgICAgICAgbGV0IGNvbHVtbnMgPSB0aGlzLmNvbHVtbnM7XG5cbiAgICAgICAgICAgIGlmKCFjb2x1bW5zIHx8ICFjb2x1bW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbHVtbnMgPSBrZXlzKHRoaXMuZGF0YVswXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjb2x1bW5zLm1hcChjb2x1bW4gPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc09iamVjdChjb2x1bW4pID8gY29sdW1uIDoge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBjb2x1bW5cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWV0aG9kczoge1xuXG4gICAgICAgIG9yZGVyQnkob3JkZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRTb3J0ID0gJ2Rlc2MnO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFNvcnQgPSB0aGlzLmdldFJlcXVlc3RQYXJhbSgnc29ydCcpO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudE9yZGVyID0gdGhpcy5nZXRSZXF1ZXN0UGFyYW0oJ29yZGVyJyk7XG5cbiAgICAgICAgICAgIHRoaXMuYWRkUmVxdWVzdFBhcmFtKCdvcmRlcicsIG9yZGVyKTtcbiAgICAgICAgICAgIHRoaXMuYWRkUmVxdWVzdFBhcmFtKCdzb3J0JyxcbiAgICAgICAgICAgICAgICBjdXJyZW50T3JkZXIgIT09IG9yZGVyIHx8ICFjdXJyZW50U29ydCA/IGRlZmF1bHRTb3J0IDogKFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U29ydCA9PT0gZGVmYXVsdFNvcnQgPyAnYXNjJyA6IG51bGxcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB0aGlzLmZldGNoKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0UmVxdWVzdEhlYWRlcihrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0LmhlYWRlcnNba2V5XSB8fCB2YWx1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIGFkZFJlcXVlc3RIZWFkZXIoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYoIXRoaXMucmVxdWVzdC5oZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0LmhlYWRlcnMgPSB7fTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0LmhlYWRlcnNba2V5XSA9IHZhbHVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldFJlcXVlc3RQYXJhbShrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0LnBhcmFtc1trZXldIHx8IHZhbHVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkUmVxdWVzdFBhcmFtKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmKCF0aGlzLnJlcXVlc3QucGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0LnBhcmFtcyA9IHt9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnJlcXVlc3QucGFyYW1zW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICBmZXRjaCgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgUmVxdWVzdCh0aGlzLnVybCwgdGhpcy5yZXF1ZXN0KTtcblxuICAgICAgICAgICAgdGhpcy5sb2FkaW5nID0gdHJ1ZTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3QuZ2V0KCkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtZXIgPSB0aGlzLnRyYW5zZm9ybWVyIHx8IG5ldyBUYWJsZVZpZXdUcmFuc2Zvcm1lcihyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNwb25zZSA9IHRyYW5zZm9ybWVyLnJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhID0gdHJhbnNmb3JtZXIuZGF0YSgpO1xuICAgICAgICAgICAgICAgIHRoaXMubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfSwgZXJyb3JzID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhlaWdodChtaW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRzID0gW1xuICAgICAgICAgICAgICAgIC8vIHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3IoJ3RoZWFkJyksXG4gICAgICAgICAgICAgICAgdGhpcy4kZWwucXVlcnlTZWxlY3RvcigndGJvZHknKVxuICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgbGV0IGhlaWdodCA9IDA7XG5cbiAgICAgICAgICAgIGVhY2goZWxlbWVudHMsIGVsID0+IHtcbiAgICAgICAgICAgICAgICBoZWlnaHQgKz0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1heChtaW4sIGhlaWdodCkgKyAncHgnO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uUGFnaW5hdGUocGFnZSwgZXZlbnQpIHtcbiAgICAgICAgICAgIGlmKCF0aGlzLnJlcXVlc3QucGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0LnBhcmFtcyA9IHt9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnJlcXVlc3QucGFyYW1zLnBhZ2UgPSBwYWdlO1xuICAgICAgICAgICAgdGhpcy5mZXRjaCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAvLyAoYXJyYXkpIFRoZSBkYXRhc2V0IGZvciB0aGUgdGFibGVcbiAgICAgICAgICAgIGRhdGE6IHRoaXMuJGF0dHJzLmRhdGEgfHwgW10sXG5cbiAgICAgICAgICAgIC8vIChib29sKSBJcyB0aGUgdGFibGUgY3VycmVudGx5IGxvYWRpbmcgZGF0YVxuICAgICAgICAgICAgbG9hZGluZzogZmFsc2UsXG5cbiAgICAgICAgICAgIC8vIChudWxsfG9iamVjdCkgVGhlIHJlc3BvbnNlIG9iamVjdFxuICAgICAgICAgICAgcmVzcG9uc2U6IG51bGwsXG5cbiAgICAgICAgICAgIC8vIChvYmplY3QpIFRoZSBIVFRQIHJlcXVlc3Qgb2JqZWN0XG4gICAgICAgICAgICByZXF1ZXN0OiBleHRlbmQoe1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgICAgICBwYWdlOiB0aGlzLnBhZ2UsXG4gICAgICAgICAgICAgICAgICAgIGxpbWl0OiB0aGlzLmxpbWl0LFxuICAgICAgICAgICAgICAgICAgICBvcmRlcjogdGhpcy5vcmRlcixcbiAgICAgICAgICAgICAgICAgICAgc29ydDogdGhpcy5zb3J0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcy4kYXR0cnMucmVxdWVzdClcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgbW91bnRlZCgpIHtcbiAgICAgICAgdGhpcy5mZXRjaCgpO1xuICAgIH0sXG5cbiAgICAvKlxuICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiBleHRlbmQoe1xuICAgICAgICAgICAgYnV0dG9uczogW10sXG5cbiAgICAgICAgICAgIGNvbHVtbnM6IFtdLFxuXG4gICAgICAgICAgICBoZWFkZXI6IGZhbHNlLFxuXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogZmFsc2UsXG5cbiAgICAgICAgICAgIC8vIChib29sKSBTaG91bGQgc2hvdyB0aGUgcGFnaW5hdGlvbiBmb3IgdGhpcyB0YWJsZVxuICAgICAgICAgICAgcGFnaW5hdGU6IHRydWUsXG5cbiAgICAgICAgICAgIC8vIChib29sKSBJcyB0aGUgdGFibGUgY3VycmVudGx5IGxvYWRpbmcgZGF0YVxuICAgICAgICAgICAgbG9hZGluZzogZmFsc2UsXG5cbiAgICAgICAgICAgIC8vIChvYmplY3QpIEFuIG9iamVjdCB3aXRoIGtleS92YWx1ZSBwYWlycyBmb3IgY29tcG9uZW50cyB1c2VkIGluIHRoZSB0ZW1wbGF0ZVxuICAgICAgICAgICAgY29tcG9uZW50czoge1xuICAgICAgICAgICAgICAgIC8vIChzdHJpbmcpIFRoZSBuYW1lIG9mIHRoZSBjb21wb25lbnQgdXNlZCBmb3IgdGhlIHRhYmxlIGhlYWRlclxuICAgICAgICAgICAgICAgIGhlYWRlcjogJ3RhYmxlLXZpZXctaGVhZGVyJyxcblxuICAgICAgICAgICAgICAgIC8vIChzdHJpbmcpIFRoZSBuYW1lIG9mIHRoZSBjb21wb25lbnQgdXNlZCBmb3IgdGhlIHRhYmxlIHJvd1xuICAgICAgICAgICAgICAgIHJvdzogJ3RhYmxlLXZpZXctcm93JyxcblxuICAgICAgICAgICAgICAgIC8vIChzdHJpbmcpIFRoZSBuYW1lIG9mIHRoZSBjb21wb25lbnQgdXNlZCBmb3IgdGhlIHRhYmxlIHJvd1xuICAgICAgICAgICAgICAgIGZvb3RlcjogJ3RhYmxlLXZpZXctZm9vdGVyJ1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gKGludCkgVGhlIHN0YXJ0aW5nIHBhZ2VcbiAgICAgICAgICAgIC8vIHBhZ2U6IDEsXG5cbiAgICAgICAgICAgIC8vIChzdHJpbmcpIFRoZSBvcmRlciBvZiB0aGUgZGF0ZSBiZWluZyByZXR1cm5lZFxuICAgICAgICAgICAgLy8gb3JkZXI6IG51bGwsXG5cbiAgICAgICAgICAgIC8vIChzdHJpbmcpIEVpdGhlciBhc2Mgb3IgZGVzYyBzb3J0aW5nIG9yZGVyXG4gICAgICAgICAgICAvLyBzb3J0OiBudWxsLFxuXG4gICAgICAgICAgICAvLyAoaW50KSBUaGUgbnVtYmVycyBvZiByb3dzIHBlciBwYWdlXG4gICAgICAgICAgICAvLyBsaW1pdDogMjAsXG5cbiAgICAgICAgICAgIC8vIChib29sKSBGZXRjaCB0aGUgZGF0YSB3aGVuIHRhYmxlIGlzIHNob3duXG4gICAgICAgICAgICAvLyBmZXRjaE9uUmVuZGVyOiB0cnVlLFxuXG4gICAgICAgICAgICAvLyAoYXJyYXkpIEFuIGFycmF5IG9mIGhlYWRlcnMgYXBwZW5kZWQgdG8gdGhlIHJlcXVlc3RcbiAgICAgICAgICAgIC8vIHJlcXVlc3RIZWFkZXJzOiBbXSxcblxuICAgICAgICAgICAgLy8gKGFycmF5KSBUaGUgZGVmYXVsdCBvcHRpb25zIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIHF1ZXJ5IHN0cmluZ1xuICAgICAgICAgICAgLy8gZGVmYXVsdFJlcXVlc3REYXRhT3B0aW9uczogW1xuICAgICAgICAgICAgLy8gICAgJ3BhZ2UnLFxuICAgICAgICAgICAgLy8gICAgJ2xpbWl0JyxcbiAgICAgICAgICAgIC8vICAgICdvcmRlcicsXG4gICAgICAgICAgICAvLyAgICAnc29ydCdcbiAgICAgICAgICAgIC8vIF0sXG5cbiAgICAgICAgICAgIC8vIChvYmplY3QpIEFuIG9wdGlvbiB0byBwYXNzIGFuIG9iamVjdCB3aXRoIHJlcXVlc3QgZGF0YVxuICAgICAgICAgICAgLy8gcmVxdWVzdERhdGE6IHt9LFxuXG4gICAgICAgICAgICAvLyAoYXJyYXkpIEFkZGl0aW9uYWwgb3B0aW9ucyB1c2VkIHRvIGdlbmVyYXRlIHRoZSBxdWVyeSBzdHJpbmdcbiAgICAgICAgICAgIC8vIHJlcXVlc3REYXRhT3B0aW9uczogW10sXG5cbiAgICAgICAgICAgIC8vIChvYmplY3QpIFRoZSBib2R5IHZpZXcgb3B0aW9ucyBvYmplY3RcbiAgICAgICAgICAgIC8vIGJvZHlWaWV3T3B0aW9uczogZmFsc2UsXG5cbiAgICAgICAgICAgIC8vIChvYmplY3QpIFRoZSBwYWdpbmF0aW9uIHZpZXcgY2xhc3NcbiAgICAgICAgICAgIC8vIGZvb3RlclZpZXc6ICdwYWdpbmF0aW9uJyxcblxuICAgICAgICAgICAgLy8gKG9iamVjdCkgVGhlIHBhZ2luYXRpb24gdmlldyBvcHRpb25zIG9iamVjdFxuICAgICAgICAgICAgLy8gZm9vdGVyVmlld09wdGlvbnM6IGZhbHNlLFxuXG4gICAgICAgICAgICAvLyAoc3RyaW5nKSBUaGUgdGFibGUgZm9vdGVyIGNsYXNzIG5hbWVcbiAgICAgICAgICAgIC8vIGZvb3RlckNsYXNzTmFtZTogJ3RhYmxlLWhlYWRlcicsXG5cbiAgICAgICAgICAgIC8vIChzdHJpbmcpIFRoZSB0YWJsZSBoZWFkZXJcbiAgICAgICAgICAgIC8vIGhlYWRlcjogZmFsc2UsXG5cbiAgICAgICAgICAgIC8vIChzdHJpbmcpIFRoZSB0YWJsZSBoZWFkZXIgdGFnIG5hbWVcbiAgICAgICAgICAgIC8vIGhlYWRlclRhZ05hbWU6ICdoMycsXG5cbiAgICAgICAgICAgIC8vIChzdHJpbmcpIFRoZSB0YWJsZSBoZWFkZXIgY2xhc3MgbmFtZVxuICAgICAgICAgICAgLy8gaGVhZGVyQ2xhc3NOYW1lOiAndGFibGUtaGVhZGVyJyxcblxuICAgICAgICAgICAgLy8gKG9iamVjdCkgVGhlIGhlYWRlciB2aWV3IGNsYXNzXG4gICAgICAgICAgICAvLyBoZWFkZXJWaWV3OiBmYWxzZSxcblxuICAgICAgICAgICAgLy8gKG9iamVjdCkgVGhlIGhlYWRlciB2aWV3IG9wdGlvbnMgb2JqZWN0XG4gICAgICAgICAgICAvLyBoZWFkZXJWaWV3T3B0aW9uczogZmFsc2UsXG5cbiAgICAgICAgICAgIC8vIChzdHJpbmcpIFRoZSB0YWJsZSBkZXNjcmlwdGlvblxuICAgICAgICAgICAgLy8gZGVzY3JpcHRpb246IGZhbHNlLFxuXG4gICAgICAgICAgICAvLyAoc3RyaW5nKSBUaGUgdGFibGUgZGVzY3JpcHRpb24gdGFnXG4gICAgICAgICAgICAvLyBkZXNjcmlwdGlvblRhZzogJ3AnLFxuXG4gICAgICAgICAgICAvLyAoc3RyaW5nKSBUaGUgdGFibGUgZGVzY3JpcHRpb24gdGFnXG4gICAgICAgICAgICAvLyBkZXNjcmlwdGlvbkNsYXNzTmFtZTogJ2Rlc2NyaXB0aW9uIHJvdyBjb2wtc20tNicsXG5cbiAgICAgICAgICAgIC8vIChzdHJpbmcpIFRoZSB0YWJsZSBjbGFzcyBuYW1lXG4gICAgICAgICAgICAvLyB0YWJsZUNsYXNzTmFtZTogJ3RhYmxlJyxcblxuICAgICAgICAgICAgLy8gKHN0cmluZykgVGhlIGxvYWRpbmcgY2xhc3MgbmFtZVxuICAgICAgICAgICAgLy8gbG9hZGluZ0NsYXNzTmFtZTogJ2xvYWRpbmcnLFxuXG4gICAgICAgICAgICAvLyAoc3RyaW5nKSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgaW4gdGhlIG1vZGVsIHN0b3JpbmcgdGhlIGNvbHVtbnNcbiAgICAgICAgICAgIC8vIGNoaWxkVmlld0NvbHVtbnNQcm9wZXJ0eTogJ2NvbHVtbnMnLFxuXG4gICAgICAgICAgICAvLyAob2JqZWN0KSBUaGUgYWN0aXZpdHkgaW5kaWNhdG9yIG9wdGlvbnNcbiAgICAgICAgICAgIC8vIGluZGljYXRvck9wdGlvbnM6IHtcbiAgICAgICAgICAgIC8vICAgICBpbmRpY2F0b3I6ICdzbWFsbCdcbiAgICAgICAgICAgIC8vIH0sXG5cbiAgICAgICAgICAgIC8vIChzdHJpbmcpIFRoZSBtZXNzYWdlIHRvIGRpc3BsYXkgaWYgdGhlcmUgYXJlIG5vIHRhYmxlIHJvd3NcbiAgICAgICAgICAgIC8vIGVtcHR5TWVzc2FnZTogJ05vIHJvd3MgZm91bmQnLFxuXG4gICAgICAgICAgICAvLyAoc3RyaW5nKSBUaGUgbmFtZSBvZiB0aGUgY2xhc3MgYXBwZW5kZWQgdG8gdGhlIGJ1dHRvbnNcbiAgICAgICAgICAgIC8vIGJ1dHRvbkNsYXNzTmFtZTogJ2J0biBidG4tZGVmYXVsdCcsXG4gICAgICAgIH0sIHRoaXMuJGF0dHJzKTtcbiAgICB9LFxuICAgICovXG5cbiAgICBiZWZvcmVEZXN0cm95KCkge1xuICAgICAgICB0aGlzLiRvZmYoKTtcbiAgICB9XG59XG5cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IFRhYmxlVmlldyBmcm9tICcuL1RhYmxlVmlldyc7XG5pbXBvcnQgVnVlSW5zdGFsbGVyIGZyb20gJ0AvSGVscGVycy9WdWVJbnN0YWxsZXIvVnVlSW5zdGFsbGVyJztcblxuY29uc3QgcGx1Z2luID0gVnVlSW5zdGFsbGVyLnVzZSh7XG5cbiAgICBpbnN0YWxsKFZ1ZSwgb3B0aW9ucykge1xuICAgICAgICBWdWVJbnN0YWxsZXIuY29tcG9uZW50cyh7XG4gICAgICAgICAgICBUYWJsZVZpZXdcbiAgICAgICAgfSk7XG4gICAgfVxuXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgVGFibGVWaWV3O1xuIiwiPHRlbXBsYXRlPlxuXG4gICAgPGZvcm0tZ3JvdXA+XG5cbiAgICAgICAgPHNsb3QgbmFtZT1cImxhYmVsXCI+XG4gICAgICAgICAgICA8Zm9ybS1sYWJlbCB2LWlmPVwibGFiZWwgfHwgaGFzRGVmYXVsdFNsb3RcIiA6Zm9yPVwiaWRcIj5cbiAgICAgICAgICAgICAgICA8c2xvdD57e2xhYmVsfX08L3Nsb3Q+XG4gICAgICAgICAgICA8L2Zvcm0tbGFiZWw+XG4gICAgICAgIDwvc2xvdD5cblxuICAgICAgICA8c2xvdCBuYW1lPVwiY29udHJvbFwiPlxuICAgICAgICAgICAgPHRleHRhcmVhXG4gICAgICAgICAgICAgICAgOmlkPVwiaWRcIlxuICAgICAgICAgICAgICAgIDp2YWx1ZT1cInZhbHVlXCJcbiAgICAgICAgICAgICAgICA6ZXJyb3JzPVwiZXJyb3JzXCJcbiAgICAgICAgICAgICAgICA6cGxhY2Vob2xkZXI9XCJwbGFjZWhvbGRlclwiXG4gICAgICAgICAgICAgICAgOnJlcXVpcmVkPVwicmVxdWlyZWRcIlxuICAgICAgICAgICAgICAgIDpkaXNhYmxlZD1cImRpc2FibGVkIHx8IHJlYWRvbmx5XCJcbiAgICAgICAgICAgICAgICA6cmVhZG9ubHk9XCJyZWFkb25seVwiXG4gICAgICAgICAgICAgICAgOnBhdHRlcm49XCJwYXR0ZXJuXCJcbiAgICAgICAgICAgICAgICA6Y2xhc3M9XCIkbWVyZ2VDbGFzc2VzKGNvbnRyb2xDbGFzc2VzLCBjb2xvcmFibGVDbGFzc2VzKVwiXG4gICAgICAgICAgICAgICAgdi1iaW5kLWV2ZW50cz1cImJpbmRFdmVudHNcIlxuICAgICAgICAgICAgICAgIHYtb246aW5wdXQ9XCJ1cGRhdGVkKCRldmVudC50YXJnZXQudmFsdWUpXCI+XG4gICAgICAgICAgICA8L3RleHRhcmVhPlxuICAgICAgICA8L3Nsb3Q+XG5cbiAgICAgICAgPHNsb3QgbmFtZT1cImhlbHBcIj5cbiAgICAgICAgICAgIDxoZWxwLXRleHQgdi1pZj1cImhlbHBUZXh0XCIgdi1odG1sPVwiaGVscFRleHRcIiAvPlxuICAgICAgICA8L3Nsb3Q+XG5cbiAgICAgICAgPHNsb3QgbmFtZT1cImZlZWRiYWNrXCI+XG4gICAgICAgICAgICA8Zm9ybS1mZWVkYmFjayB2LWlmPVwidmFsaWRGZWVkYmFja1wiIHYtaHRtbD1cInZhbGlkRmVlZGJhY2tcIiB2YWxpZCAvPlxuICAgICAgICAgICAgPGZvcm0tZmVlZGJhY2sgdi1pZj1cImludmFsaWRGZWVkYmFja1wiIHYtaHRtbD1cImludmFsaWRGZWVkYmFja1wiIGludmFsaWQgLz5cbiAgICAgICAgPC9zbG90PlxuXG4gICAgPC9mb3JtLWdyb3VwPlxuXG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuXG5pbXBvcnQgQ29sb3JhYmxlIGZyb20gJ0AvTWl4aW5zL0NvbG9yYWJsZS9Db2xvcmFibGUnO1xuaW1wb3J0IEZvcm1Db250cm9sIGZyb20gJ0AvTWl4aW5zL0Zvcm1Db250cm9sL0Zvcm1Db250cm9sJztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ3RleHRhcmVhLWZpZWxkJyxcblxuICAgIG1peGluczogW1xuICAgICAgICBDb2xvcmFibGUsXG4gICAgICAgIEZvcm1Db250cm9sXG4gICAgXSxcblxuICAgIHByb3BzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdHlwZSBhdHRyaWJ1dGVcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJ3RleHQnXG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgVGV4dGFyZWFGaWVsZCBmcm9tICcuL1RleHRhcmVhRmllbGQnO1xuaW1wb3J0IFZ1ZUluc3RhbGxlciBmcm9tICdAL0hlbHBlcnMvVnVlSW5zdGFsbGVyL1Z1ZUluc3RhbGxlcic7XG5cbmNvbnN0IHBsdWdpbiA9IFZ1ZUluc3RhbGxlci51c2Uoe1xuXG4gICAgaW5zdGFsbChWdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgVnVlSW5zdGFsbGVyLmNvbXBvbmVudHMoe1xuICAgICAgICAgICAgVGV4dGFyZWFGaWVsZFxuICAgICAgICB9KTtcbiAgICB9XG5cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBUZXh0YXJlYUZpZWxkO1xuIiwidmFyIGJhc2VGaW5kSW5kZXggPSByZXF1aXJlKCcuL19iYXNlRmluZEluZGV4JyksXG4gICAgYmFzZUl0ZXJhdGVlID0gcmVxdWlyZSgnLi9fYmFzZUl0ZXJhdGVlJyksXG4gICAgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi90b0ludGVnZXInKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0XG4gKiBlbGVtZW50IGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciBpbnN0ZWFkIG9mIHRoZSBlbGVtZW50IGl0c2VsZi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDEuMS4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZvdW5kIGVsZW1lbnQsIGVsc2UgYC0xYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIHVzZXJzID0gW1xuICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogZmFsc2UgfSxcbiAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiB0cnVlIH1cbiAqIF07XG4gKlxuICogXy5maW5kSW5kZXgodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8udXNlciA9PSAnYmFybmV5JzsgfSk7XG4gKiAvLyA9PiAwXG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmluZEluZGV4KHVzZXJzLCB7ICd1c2VyJzogJ2ZyZWQnLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gKiAvLyA9PiAxXG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kSW5kZXgodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAqIC8vID0+IDBcbiAqXG4gKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmluZEluZGV4KHVzZXJzLCAnYWN0aXZlJyk7XG4gKiAvLyA9PiAyXG4gKi9cbmZ1bmN0aW9uIGZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICBpZiAoIWxlbmd0aCkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICB2YXIgaW5kZXggPSBmcm9tSW5kZXggPT0gbnVsbCA/IDAgOiB0b0ludGVnZXIoZnJvbUluZGV4KTtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIGluZGV4ID0gbmF0aXZlTWF4KGxlbmd0aCArIGluZGV4LCAwKTtcbiAgfVxuICByZXR1cm4gYmFzZUZpbmRJbmRleChhcnJheSwgYmFzZUl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIGluZGV4KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmaW5kSW5kZXg7XG4iLCIvKipcbiAqIEdldHMgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmxhc3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IDNcbiAqL1xuZnVuY3Rpb24gbGFzdChhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gIHJldHVybiBsZW5ndGggPyBhcnJheVtsZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsYXN0O1xuIiwidmFyIGJhc2VHZXQgPSByZXF1aXJlKCcuL19iYXNlR2V0JyksXG4gICAgYmFzZVNsaWNlID0gcmVxdWlyZSgnLi9fYmFzZVNsaWNlJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgcGFyZW50IHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheX0gcGF0aCBUaGUgcGF0aCB0byBnZXQgdGhlIHBhcmVudCB2YWx1ZSBvZi5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwYXJlbnQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHBhcmVudChvYmplY3QsIHBhdGgpIHtcbiAgcmV0dXJuIHBhdGgubGVuZ3RoIDwgMiA/IG9iamVjdCA6IGJhc2VHZXQob2JqZWN0LCBiYXNlU2xpY2UocGF0aCwgMCwgLTEpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwYXJlbnQ7XG4iLCJ2YXIgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpLFxuICAgIGxhc3QgPSByZXF1aXJlKCcuL2xhc3QnKSxcbiAgICBwYXJlbnQgPSByZXF1aXJlKCcuL19wYXJlbnQnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5zZXRgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHByb3BlcnR5IHBhdGggdG8gdW5zZXQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHByb3BlcnR5IGlzIGRlbGV0ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuc2V0KG9iamVjdCwgcGF0aCkge1xuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcbiAgb2JqZWN0ID0gcGFyZW50KG9iamVjdCwgcGF0aCk7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCB8fCBkZWxldGUgb2JqZWN0W3RvS2V5KGxhc3QocGF0aCkpXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVW5zZXQ7XG4iLCJ2YXIgYmFzZVVuc2V0ID0gcmVxdWlyZSgnLi9fYmFzZVVuc2V0JyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnB1bGxBdGAgd2l0aG91dCBzdXBwb3J0IGZvciBpbmRpdmlkdWFsXG4gKiBpbmRleGVzIG9yIGNhcHR1cmluZyB0aGUgcmVtb3ZlZCBlbGVtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7bnVtYmVyW119IGluZGV4ZXMgVGhlIGluZGV4ZXMgb2YgZWxlbWVudHMgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VQdWxsQXQoYXJyYXksIGluZGV4ZXMpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID8gaW5kZXhlcy5sZW5ndGggOiAwLFxuICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTtcblxuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICB2YXIgaW5kZXggPSBpbmRleGVzW2xlbmd0aF07XG4gICAgaWYgKGxlbmd0aCA9PSBsYXN0SW5kZXggfHwgaW5kZXggIT09IHByZXZpb3VzKSB7XG4gICAgICB2YXIgcHJldmlvdXMgPSBpbmRleDtcbiAgICAgIGlmIChpc0luZGV4KGluZGV4KSkge1xuICAgICAgICBzcGxpY2UuY2FsbChhcnJheSwgaW5kZXgsIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmFzZVVuc2V0KGFycmF5LCBpbmRleCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUHVsbEF0O1xuIiwidmFyIGJhc2VJdGVyYXRlZSA9IHJlcXVpcmUoJy4vX2Jhc2VJdGVyYXRlZScpLFxuICAgIGJhc2VQdWxsQXQgPSByZXF1aXJlKCcuL19iYXNlUHVsbEF0Jyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwgZWxlbWVudHMgZnJvbSBgYXJyYXlgIHRoYXQgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yXG4gKiBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiB0aGUgcmVtb3ZlZCBlbGVtZW50cy4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkXG4gKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICpcbiAqICoqTm90ZToqKiBVbmxpa2UgYF8uZmlsdGVyYCwgdGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLiBVc2UgYF8ucHVsbGBcbiAqIHRvIHB1bGwgZWxlbWVudHMgZnJvbSBhbiBhcnJheSBieSB2YWx1ZS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuMC4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiByZW1vdmVkIGVsZW1lbnRzLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgYXJyYXkgPSBbMSwgMiwgMywgNF07XG4gKiB2YXIgZXZlbnMgPSBfLnJlbW92ZShhcnJheSwgZnVuY3Rpb24obikge1xuICogICByZXR1cm4gbiAlIDIgPT0gMDtcbiAqIH0pO1xuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAqIC8vID0+IFsxLCAzXVxuICpcbiAqIGNvbnNvbGUubG9nKGV2ZW5zKTtcbiAqIC8vID0+IFsyLCA0XVxuICovXG5mdW5jdGlvbiByZW1vdmUoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgaW5kZXhlcyA9IFtdLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIHByZWRpY2F0ZSA9IGJhc2VJdGVyYXRlZShwcmVkaWNhdGUsIDMpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICBpbmRleGVzLnB1c2goaW5kZXgpO1xuICAgIH1cbiAgfVxuICBiYXNlUHVsbEF0KGFycmF5LCBpbmRleGVzKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZW1vdmU7XG4iLCI8dGVtcGxhdGU+XG5cbiAgICA8Zm9ybS1ncm91cCBjbGFzcz1cInVwbG9hZC1maWVsZFwiIDpjbGFzcz1cInsnZW5hYmxlLWRyb3B6b25lJzogZHJvcHpvbmUsICdlbmFibGUtbXVsdGlwbGUnOiBtdWx0aXBsZX1cIiBAZHJhZ2VudGVyLnByZXZlbnQ9XCJvbkRyYWdFbnRlclwiIEBkcmFnb3Zlci5wcmV2ZW50PVwib25EcmFnT3ZlclwiIEBkcmFnbGVhdmUucHJldmVudD1cIm9uRHJhZ0xlYXZlXCI+XG5cbiAgICAgICAgPGZpbGUtZmllbGRcbiAgICAgICAgICAgIHYtaWY9XCJtdWx0aXBsZSAmJiAoIW1heFVwbG9hZHMgfHwgbWF4VXBsb2FkcyA+IHZhbHVlLmxlbmd0aCkgfHwgIW11bHRpcGxlICYmICF2YWx1ZVwiXG4gICAgICAgICAgICA6bmFtZT1cIm5hbWVcIlxuICAgICAgICAgICAgOmxhYmVsPVwibGFiZWxcIlxuICAgICAgICAgICAgOnBsYWNlaG9sZGVyPVwicGxhY2Vob2xkZXJcIlxuICAgICAgICAgICAgOmhlbHAtdGV4dD1cImhlbHBUZXh0XCJcbiAgICAgICAgICAgIDptdWx0aXBsZT1cIm11bHRpcGxlXCJcbiAgICAgICAgICAgIDp3aWR0aD1cIndpZHRoXCJcbiAgICAgICAgICAgIDpoZWlnaHQ9XCJoZWlnaHRcIlxuICAgICAgICAgICAgOmVycm9ycz1cImVycm9yc1wiXG4gICAgICAgICAgICBAY2hhbmdlPVwib25DaGFuZ2VcIlxuICAgICAgICAvPlxuXG4gICAgICAgIDxkaXYgdi1pZj1cIm11bHRpcGxlICYmIHZhbHVlICYmIHZhbHVlLmxlbmd0aFwiIGNsYXNzPVwidXBsb2FkLWZpZWxkLXByZXZpZXcgbXQtNFwiPlxuICAgICAgICAgICAgPGZpbGUtcHJldmlldyB2LWZvcj1cIihmaWxlLCBrZXkpIGluIHZhbHVlXCIgOmtleT1cImZpbGUuaWQgfHwga2V5XCIgOmZpbGU9XCJmaWxlXCIgQGNsb3NlPVwicmVtb3ZlRmlsZShmaWxlKVwiLz5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPGRpdiB2LWVsc2UtaWY9XCIhbXVsdGlwbGUgJiYgdmFsdWVcIiBjbGFzcz1cInVwbG9hZC1maWVsZC1wcmV2aWV3IG10LTRcIj5cbiAgICAgICAgICAgIDxmaWxlLXByZXZpZXcgOmZpbGU9XCJ2YWx1ZVwiIEBjbG9zZT1cInJlbW92ZUZpbGUodmFsdWUpXCIvPlxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8ZGl2IHYtaWY9XCJzaG93RHJvcEVsZW1lbnRcIiBjbGFzcz1cInVwbG9hZC1maWVsZC1kcm9wem9uZVwiIDpzdHlsZT1cInsnbWluLWhlaWdodCc6IGRyb3B6b25lTWluSGVpZ2h0fVwiIEBkcm9wLnByZXZlbnQ9XCJvbkRyb3BcIj5cbiAgICAgICAgICAgIDxpIGNsYXNzPVwiZmEgZmEtY2xvdWQtdXBsb2FkXCI+PC9pPlxuICAgICAgICAgICAgPGRpdj5EcmFnIGFuZCBkcm9wIGZpbGVzIHRvIHVwbG9hZDwvZGl2PlxuICAgICAgICA8L2Rpdj5cblxuICAgIDwvZm9ybS1ncm91cD5cblxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCB7IHB1bGwgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgZWFjaCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBtZXJnZSB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyByZW1vdmUgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgZXh0ZW5kIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IGlzQXJyYXkgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgZmluZEluZGV4IH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IGlzVW5kZWZpbmVkIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBGb3JtQ29udHJvbCBmcm9tICdAL01peGlucy9Gb3JtQ29udHJvbC9Gb3JtQ29udHJvbCc7XG5pbXBvcnQgRmlsZUZpZWxkIGZyb20gJ0AvQ29tcG9uZW50cy9GaWxlRmllbGQvRmlsZUZpZWxkJztcbmltcG9ydCBGaWxlUHJldmlldyBmcm9tICdAL0NvbXBvbmVudHMvRmlsZVByZXZpZXcvRmlsZVByZXZpZXcnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAndXBsb2FkLWZpZWxkJyxcblxuICAgIG1peGluczogW0Zvcm1Db250cm9sXSxcblxuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgICAgRmlsZUZpZWxkLFxuICAgICAgICBGaWxlUHJldmlld1xuICAgIH0sXG5cbiAgICBtb2RlbDoge1xuICAgICAgICBwcm9wOiAndmFsdWUnLFxuICAgICAgICBldmVudDogJ2NoYW5nZSdcbiAgICB9LFxuXG4gICAgcHJvcHM6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FuIHVzZXIgdXBsb2FkIG11bHRpcGxlIGZpbGVzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIG11bHRpcGxlOiBCb29sZWFuLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgZmlsZXMgdGhhdCBhIHVzZXIgY2FuIHVwbG9hZFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBtYXhVcGxvYWRzOiBOdW1iZXIsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBoZWlnaHQgYXR0cmlidXRlIGZvciB0aGUgY29udHJvbCBlbGVtZW50XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGhlaWdodDogW051bWJlciwgU3RyaW5nXSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHdpZHRoIGF0dHJpYnV0ZSBmb3IgdGhlIGNvbnRyb2wgZWxlbWVudFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICB3aWR0aDogW051bWJlciwgU3RyaW5nXSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FuIHVzZXIgZHJhZy9kcm9wIGZpbGVzIGludG8gYnJvd3NlciB0byB1cGxvYWQgdGhlbS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgZHJvcHpvbmVNaW5IZWlnaHQ6IFtOdW1iZXIsIFN0cmluZ10sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElzIHRoZSB1c2VyIGRyYWdnaW5nIGEgZmlsZSBvdmVyIHRoZSBkcm9wem9uZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBkcmFnZ2luZzoge1xuICAgICAgICAgICAgdHlwZTogW1N0cmluZywgQm9vbGVhbl0sXG4gICAgICAgICAgICBkZWZhdWx0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbiB1c2VyIGRyYWcvZHJvcCBmaWxlcyBpbnRvIGJyb3dzZXIgdG8gdXBsb2FkIHRoZW0uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGRyb3B6b25lOiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGF0YSBhdHRyaWJ1dGVcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IEZpbGV8RmlsZUxpc3R8QXJyYXlcbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICB0eXBlOiBbT2JqZWN0LCBGaWxlLCBGaWxlTGlzdCwgQXJyYXldLFxuICAgICAgICAgICAgZGVmYXVsdCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIXRoaXMubXVsdGlwbGUgPyBudWxsIDogW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBtZXRob2RzOiB7XG5cbiAgICAgICAgcmVtb3ZlRmlsZShkYXRhKSB7XG4gICAgICAgICAgICBpZih0aGlzLm11bHRpcGxlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsZXMgPSBpc0FycmF5KHRoaXMudmFsdWUpID8gdGhpcy52YWx1ZS5zbGljZSgwKSA6IFtdO1xuXG4gICAgICAgICAgICAgICAgaWYoZGF0YSBpbnN0YW5jZW9mIEZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlKGZpbGVzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBkYXRhLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplOiBkYXRhLnNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0TW9kaWZpZWQ6IGRhdGEubGFzdE1vZGlmaWVkXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlKGZpbGVzLCBkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnLCBmaWxlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBhZGRGaWxlKGZpbGUsIHN1YmplY3QpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogZmlsZS5uYW1lLFxuICAgICAgICAgICAgICAgIGxhc3RNb2RpZmllZDogZmlsZS5sYXN0TW9kaWZpZWQsXG4gICAgICAgICAgICAgICAgbGFzdE1vZGlmaWVkRGF0ZTogZmlsZS5sYXN0TW9kaWZpZWREYXRlLFxuICAgICAgICAgICAgICAgIHNpemU6IGZpbGUuc2l6ZSxcbiAgICAgICAgICAgICAgICB0eXBlOiBmaWxlLnR5cGVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYodGhpcy5tdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVzID0gc3ViamVjdCB8fCAoaXNBcnJheSh0aGlzLnZhbHVlKSA/IHRoaXMudmFsdWUuc2xpY2UoMCkgOiBbXSk7XG5cbiAgICAgICAgICAgICAgICBpZighdGhpcy5tYXhVcGxvYWRzIHx8IHRoaXMubWF4VXBsb2FkcyA+IGZpbGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpZihmaW5kSW5kZXgoZmlsZXMsIGRhdGEpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZXMucHVzaChmaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScsIGZpbGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnLCBmaWxlKVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGFkZEZpbGVzKGZpbGVzKSB7XG4gICAgICAgICAgICBjb25zdCBzdWJqZWN0ID0gaXNBcnJheSh0aGlzLnZhbHVlKSA/IHRoaXMudmFsdWUuc2xpY2UoMCkgOiBbXTtcblxuICAgICAgICAgICAgZWFjaChmaWxlcywgZmlsZSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRGaWxlKGZpbGUsIHN1YmplY3QpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGV2ZW50LnRhcmdldC52YWx1ZSA9IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25DaGFuZ2UoZmlsZXMpIHtcbiAgICAgICAgICAgIGlmKGZpbGVzIGluc3RhbmNlb2YgRmlsZUxpc3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEZpbGVzKGZpbGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkRmlsZShmaWxlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBgZHJhZ292ZXJgIGV2ZW50IGNhbGxiYWNrLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBvbkRyYWdPdmVyKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmlzRHJhZ2dpbmdJbnNpZGUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgndXBkYXRlOmRyYWdnaW5nJywgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCdkcmFnOm92ZXInLCBldmVudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBgZHJhZ292ZXJgIGV2ZW50IGNhbGxiYWNrLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBvbkRyYWdFbnRlcihldmVudCkge1xuICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nSW5zaWRlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ3VwZGF0ZTpkcmFnZ2luZycsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgnZHJhZzplbnRlcicsIGV2ZW50KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGBkcmFnbGVhdmVgIGV2ZW50IGNhbGxiYWNrLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBvbkRyYWdMZWF2ZShldmVudCkge1xuICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nSW5zaWRlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCd1cGRhdGU6ZHJhZ2dpbmcnLCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCdkcmFnOmxlYXZlJywgZXZlbnQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYGRyb3BgIGV2ZW50IGNhbGxiYWNrLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBvbkRyb3AoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZ0luc2lkZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5hZGRGaWxlcyhldmVudC5kYXRhVHJhbnNmZXIuZmlsZXMpO1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgndXBkYXRlOmRyYWdnaW5nJywgZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgnZHJvcCcsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBjb21wdXRlZDoge1xuICAgICAgICBzaG93RHJvcEVsZW1lbnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gIWlzVW5kZWZpbmVkKHRoaXMuZHJhZ2dpbmcpID8gdGhpcy5kcmFnZ2luZyA6IHRoaXMuaXNEcmFnZ2luZ0luc2lkZVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpc0RyYWdnaW5nSW5zaWRlOiBmYWxzZVxuICAgICAgICB9O1xuICAgIH1cblxufVxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwic2Nzc1wiPlxuQGltcG9ydCAnLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwL3Njc3MvYm9vdHN0cmFwLXJlYm9vdC5zY3NzJztcblxuQG1peGluIGZpbGUtcHJldmlldygkdG90YWwpIHtcbiAgICAmIC5maWxlLXByZXZpZXctaW5uZXIge1xuICAgICAgICBtYXJnaW4tcmlnaHQ6IDA7XG4gICAgfVxuXG4gICAgJjpudGgtbGFzdC1jaGlsZCgjeyR0b3RhbH0pIC5maWxlLXByZXZpZXctaW5uZXIge1xuICAgICAgICBtYXJnaW4tcmlnaHQ6IDFyZW07XG4gICAgfVxuXG4gICAgJjpudGgtbGFzdC1jaGlsZCgjeyR0b3RhbH0pLFxuICAgICY6bnRoLWxhc3QtY2hpbGQoI3skdG90YWx9KSB+IC5maWxlLXByZXZpZXcge1xuICAgICAgICB3aWR0aDogMTAwJSAvICR0b3RhbDtcbiAgICB9XG59XG5cbi51cGxvYWQtZmllbGQge1xuXG4gICAgJi5lbmFibGUtZHJvcHpvbmUge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgfVxuXG4gICAgLmZpbGUtcHJldmlldyB7XG4gICAgICAgIG1heC13aWR0aDogMzAwcHg7XG4gICAgfVxuXG4gICAgJi5lbmFibGUtbXVsdGlwbGUgLmZpbGUtcHJldmlldyB7XG5cbiAgICAgICAgJjpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCgxKSB7XG4gICAgICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgfVxuXG4gICAgICAgIEBpbmNsdWRlIGZpbGUtcHJldmlldygyKTtcbiAgICAgICAgQGluY2x1ZGUgZmlsZS1wcmV2aWV3KDMpO1xuICAgICAgICBAaW5jbHVkZSBmaWxlLXByZXZpZXcoNCk7XG4gICAgICAgIEBpbmNsdWRlIGZpbGUtcHJldmlldyg1KTtcbiAgICB9XG5cbiAgICAmOm5vdCguZW5hYmxlLWRyb3B6b25lKSAudXBsb2FkLWZpZWxkLWRyb3B6b25lIHtcbiAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgIH1cblxuICAgIC51cGxvYWQtZmllbGQtZHJvcHpvbmUge1xuICAgICAgICBjb2xvcjogJGluZm87XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogMDtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgICAgei1pbmRleDogMTAwO1xuICAgICAgICBiYWNrZ3JvdW5kOiBsaWdodGVuKCRpbmZvLCA0NSUpO1xuICAgICAgICBib3JkZXI6IDJweCBkYXNoZWQgbGlnaHRlbigkaW5mbywgMjUlKTtcbiAgICAgICAgdGV4dC1zaGFkb3c6IDAgMXB4IDAgd2hpdGU7XG5cbiAgICAgICAgJiA+IGkge1xuICAgICAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgICAgICBmb250LXNpemU6IDMycHg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAudXBsb2FkLWZpZWxkLXByZXZpZXcge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBmbGV4LXdyYXA6IHdyYXA7XG4gICAgfVxuXG5cbiAgICAvKlxuICAgIC51cGxvYWQtZmllbGQtcHJldmlldyAuZmlsZS1wcmV2aWV3LmlzLWltYWdlIHtcbiAgICAgICAgd2lkdGg6IDIyLjc1JTtcbiAgICAgICAgbWFyZ2luLXJpZ2h0OiAzJTtcblxuICAgICAgICAmOm50aC1jaGlsZCg0bikge1xuICAgICAgICAgICAgbWFyZ2luLXJpZ2h0OiAwO1xuICAgICAgICB9XG4gICAgfVxuICAgICovXG5cbiAgICAudXBsb2FkLWZpZWxkLXByZXZpZXcgLmZpbGUtcHJldmlldyB7XG4gICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICB9XG5cbiAgICAudXBsb2FkLWZpZWxkLXByZXZpZXcgLmZpbGUtcHJldmlldy1uYW1lLWxhYmVsIHtcbiAgICAgICAgbWF4LXdpZHRoOiAyMDBweDtcbiAgICB9XG59XG48L3N0eWxlPlxuIiwiaW1wb3J0IFVwbG9hZEZpZWxkIGZyb20gJy4vVXBsb2FkRmllbGQnO1xuaW1wb3J0IFZ1ZUluc3RhbGxlciBmcm9tICdAL0hlbHBlcnMvVnVlSW5zdGFsbGVyL1Z1ZUluc3RhbGxlcic7XG5cbmNvbnN0IHBsdWdpbiA9IFZ1ZUluc3RhbGxlci51c2Uoe1xuXG4gICAgaW5zdGFsbChWdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgVnVlSW5zdGFsbGVyLmNvbXBvbmVudHMoe1xuICAgICAgICAgICAgVXBsb2FkRmllbGRcbiAgICAgICAgfSk7XG4gICAgfVxuXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgVXBsb2FkRmllbGQ7XG4iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBSZXNwb25zZVRyYW5zZm9ybWVyIHtcblxuICAgIGNvbnN0cnVjdG9yKHJlc3BvbnNlKSB7XG4gICAgICAgIHRoaXMuJHJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgfVxuXG59XG4iLCJpbXBvcnQgeyBpc0Z1bmN0aW9uIH0gZnJvbSAnbG9kYXNoJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYmxvYih1cmwsIHByb2dyZXNzKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIHVybCwgdHJ1ZSk7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYmxvYic7XG5cbiAgICAgICAgaWYoaXNGdW5jdGlvbihwcm9ncmVzcykpIHtcbiAgICAgICAgICAgIHhoci5vbnByb2dyZXNzID0gZSA9PiBwcm9ncmVzcyhlLCB4aHIpO1xuICAgICAgICB9XG5cbiAgICAgICAgeGhyLm9uZXJyb3IgPSBlID0+IHJlamVjdChlKTtcbiAgICAgICAgeGhyLm9uYWJvcnQgPSBlID0+IHJlamVjdChlKTtcbiAgICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLnJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB4aHIuc2VuZCgpO1xuICAgIH0pO1xufVxuIiwiaW1wb3J0IHsgZWFjaCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgKiBhcyBmaWx0ZXJzIGZyb20gJy4vRmlsdGVycyc7XG5pbXBvcnQgKiBhcyBwbHVnaW5zIGZyb20gJy4vUGx1Z2lucyc7XG5pbXBvcnQgKiBhcyBjb21wb25lbnRzIGZyb20gJy4vQ29tcG9uZW50cyc7XG5pbXBvcnQgVnVlSW5zdGFsbGVyIGZyb20gJy4vSGVscGVycy9WdWVJbnN0YWxsZXInO1xuXG5leHBvcnQgKiBmcm9tICcuL0h0dHAnO1xuZXhwb3J0ICogZnJvbSAnLi9NaXhpbnMnO1xuZXhwb3J0ICogZnJvbSAnLi9QbHVnaW5zJztcbmV4cG9ydCAqIGZyb20gJy4vQ29tcG9uZW50cyc7XG5leHBvcnQgKiBmcm9tICcuL0ZpbHRlcnMnO1xuZXhwb3J0ICogZnJvbSAnLi9IZWxwZXJzJztcblxuZXhwb3J0IGRlZmF1bHQgVnVlSW5zdGFsbGVyLnVzZSh7XG5cbiAgICBpbnN0YWxsKFZ1ZSkge1xuXG4gICAgICAgIGlmKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgICAgICBjb25zdCBkb21haW4gPSAobG9jYXRpb24uaG9zdCB8fCAnbG9jYWxob3N0Jykuc3BsaXQoJzonKVswXTtcbiAgICAgICAgICAgIGNvbnN0IHBvcnQgPSBwcm9jZXNzLmVudi5MSVZFUkVMT0FEX09QVElPTlMgJiYgcHJvY2Vzcy5lbnYuTElWRVJFTE9BRF9PUFRJT05TLnBvcnQ7XG4gICAgICAgICAgICBWdWVJbnN0YWxsZXIuc2NyaXB0KGBodHRwOi8vJHtkb21haW59OiR7cG9ydH0vbGl2ZXJlbG9hZC5qcz9zbmlwdmVyPTFgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIFZ1ZUluc3RhbGxlci5wbHVnaW5zKFZ1ZSwgcGx1Z2lucyk7XG4gICAgICAgIFZ1ZUluc3RhbGxlci5jb21wb25lbnRzKFZ1ZSwgY29tcG9uZW50cyk7XG4gICAgICAgIFZ1ZUluc3RhbGxlci5maWx0ZXJzKFZ1ZSwgZmlsdGVycyk7XG4gICAgfVxuXG59KTtcbiJdLCJuYW1lcyI6WyJ2YWx1ZSIsImZvcm1hdCIsIm1vbWVudCIsIlN0cmluZyIsIlZ1ZSIsIm9wdGlvbnMiLCJmaWx0ZXIiLCJEYXRlRmlsdGVyIiwiTW9tZW50RmlsdGVyIiwiZ2xvYmFsIiwiZnJlZUdsb2JhbCIsIlN5bWJvbCIsInJvb3QiLCJvYmplY3RQcm90byIsIm5hdGl2ZU9iamVjdFRvU3RyaW5nIiwic3ltVG9TdHJpbmdUYWciLCJnZXRSYXdUYWciLCJvYmplY3RUb1N0cmluZyIsImlzT2JqZWN0IiwiYmFzZUdldFRhZyIsImNvcmVKc0RhdGEiLCJmdW5jUHJvdG8iLCJmdW5jVG9TdHJpbmciLCJoYXNPd25Qcm9wZXJ0eSIsImlzTWFza2VkIiwiaXNGdW5jdGlvbiIsInRvU291cmNlIiwiZ2V0VmFsdWUiLCJiYXNlSXNOYXRpdmUiLCJnZXROYXRpdmUiLCJkZWZpbmVQcm9wZXJ0eSIsImVxIiwiYmFzZUFzc2lnblZhbHVlIiwiYXNzaWduVmFsdWUiLCJhcHBseSIsImlkZW50aXR5IiwiY29uc3RhbnQiLCJzaG9ydE91dCIsImJhc2VTZXRUb1N0cmluZyIsInNldFRvU3RyaW5nIiwib3ZlclJlc3QiLCJpc0xlbmd0aCIsIk1BWF9TQUZFX0lOVEVHRVIiLCJpc0FycmF5TGlrZSIsImlzSW5kZXgiLCJiYXNlUmVzdCIsImlzSXRlcmF0ZWVDYWxsIiwiaXNPYmplY3RMaWtlIiwiYmFzZUlzQXJndW1lbnRzIiwic3R1YkZhbHNlIiwiYXJnc1RhZyIsImZ1bmNUYWciLCJub2RlVXRpbCIsImJhc2VVbmFyeSIsImJhc2VJc1R5cGVkQXJyYXkiLCJpc0FycmF5IiwiaXNBcmd1bWVudHMiLCJpc0J1ZmZlciIsImlzVHlwZWRBcnJheSIsImJhc2VUaW1lcyIsIm5hdGl2ZUtleXNJbiIsImlzUHJvdG90eXBlIiwiYXJyYXlMaWtlS2V5cyIsImJhc2VLZXlzSW4iLCJjcmVhdGVBc3NpZ25lciIsImNvcHlPYmplY3QiLCJrZXlzSW4iLCJyZXF1aXJlJCQwIiwiYXNzb2NJbmRleE9mIiwibGlzdENhY2hlQ2xlYXIiLCJsaXN0Q2FjaGVEZWxldGUiLCJsaXN0Q2FjaGVHZXQiLCJsaXN0Q2FjaGVIYXMiLCJsaXN0Q2FjaGVTZXQiLCJMaXN0Q2FjaGUiLCJNYXAiLCJuYXRpdmVDcmVhdGUiLCJIQVNIX1VOREVGSU5FRCIsImhhc2hDbGVhciIsImhhc2hEZWxldGUiLCJoYXNoR2V0IiwiaGFzaEhhcyIsImhhc2hTZXQiLCJIYXNoIiwiaXNLZXlhYmxlIiwiZ2V0TWFwRGF0YSIsIm1hcENhY2hlQ2xlYXIiLCJtYXBDYWNoZURlbGV0ZSIsIm1hcENhY2hlR2V0IiwibWFwQ2FjaGVIYXMiLCJtYXBDYWNoZVNldCIsIk1hcENhY2hlIiwic3RhY2tDbGVhciIsInN0YWNrRGVsZXRlIiwic3RhY2tHZXQiLCJzdGFja0hhcyIsInN0YWNrU2V0IiwiY3JlYXRlQmFzZUZvciIsIlVpbnQ4QXJyYXkiLCJjbG9uZUFycmF5QnVmZmVyIiwib3ZlckFyZyIsImJhc2VDcmVhdGUiLCJnZXRQcm90b3R5cGUiLCJvYmplY3RUYWciLCJzYWZlR2V0IiwiYXNzaWduTWVyZ2VWYWx1ZSIsImlzQXJyYXlMaWtlT2JqZWN0IiwiY29weUFycmF5IiwiY2xvbmVCdWZmZXIiLCJjbG9uZVR5cGVkQXJyYXkiLCJpc1BsYWluT2JqZWN0IiwidG9QbGFpbk9iamVjdCIsImluaXRDbG9uZU9iamVjdCIsImJhc2VGb3IiLCJTdGFjayIsImJhc2VNZXJnZURlZXAiLCJiYXNlTWVyZ2UiLCJuYXRpdmVLZXlzIiwiYmFzZUtleXMiLCJrZXlzIiwiY3JlYXRlQmFzZUVhY2giLCJiYXNlRm9yT3duIiwiYXJyYXlFYWNoIiwiYmFzZUVhY2giLCJjYXN0RnVuY3Rpb24iLCJwcm90b3R5cGUiLCIkbWVyZ2VDbGFzc2VzIiwiY2xhc3NlcyIsInNsaWNlIiwiY2FsbCIsImFyZ3VtZW50cyIsIl9pc09iamVjdCIsImFyZyIsIl9pc0FycmF5IiwicmVuZGVyIiwibmFtZSIsInByb3BzIiwiYmFja2dyb3VuZCIsInR5cGUiLCJkZWZhdWx0IiwidmlzaWJsZSIsIkJvb2xlYW4iLCJmaXhlZENvbnRlbnQiLCJjbG9zZUJ1dHRvbiIsIm1pbkhlaWdodCIsIk51bWJlciIsIndhdGNoIiwiaXNWaXNpYmxlIiwiZm9jdXMiLCJtZXRob2RzIiwiZWwiLCIkZWwiLCJxdWVyeVNlbGVjdG9yIiwic2hvdyIsImNvbnRlbnRzIiwiJG1vdW50IiwiZG9jdW1lbnQiLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJjcmVhdGVFbGVtZW50IiwiJHBhcmVudCIsIiRlbWl0IiwiaGlkZSIsIm9uQ2xpY2tDbG9zZSIsIm1vdW50ZWQiLCJkYXRhIiwiJG92ZXJsYXkiLCJDb250ZW50Q29tcG9uZW50Iiwib3ZlcmxheU9wdGlvbnMiLCJPdmVybGF5Q29tcG9uZW50IiwiY29tcG9uZW50IiwidnVlIiwiZXh0ZW5kIiwicm91dGUiLCIkcm91dGUiLCJyb3V0ZXIiLCIkcm91dGVyIiwiX2lzRnVuY3Rpb24iLCJvdmVybGF5IiwiT3ZlcmxheSIsIiRjb250ZW50IiwiYmFzZVByb3BlcnR5T2YiLCJhcnJheU1hcCIsImlzU3ltYm9sIiwiYmFzZVRvU3RyaW5nIiwidG9TdHJpbmciLCJkZWJ1cnJMZXR0ZXIiLCJyc0NvbWJvTWFya3NSYW5nZSIsInJlQ29tYm9IYWxmTWFya3NSYW5nZSIsInJzQ29tYm9TeW1ib2xzUmFuZ2UiLCJyc0NvbWJvUmFuZ2UiLCJyc0NvbWJvIiwiaGFzVW5pY29kZVdvcmQiLCJ1bmljb2RlV29yZHMiLCJhc2NpaVdvcmRzIiwicnNBcG9zIiwiYXJyYXlSZWR1Y2UiLCJ3b3JkcyIsImRlYnVyciIsImNyZWF0ZUNvbXBvdW5kZXIiLCJub2RlcyIsInNpemUiLCJwcmVmaXgiLCJjb21wdXRlZCIsIiRvcHRpb25zIiwicmVwbGFjZSIsImV4dGVuZHMiLCJCYXNlVHlwZSIsIl9leHRlbmQiLCJjZW50ZXIiLCJjb21wb25lbnRzIiwiQWN0aXZpdHlJbmRpY2F0b3JEb3RzIiwiQWN0aXZpdHlJbmRpY2F0b3JTcGlubmVyIiwiX2tlYmFiQ2FzZSIsImxvYWRlZCIsImVsZW1lbnQiLCJ1cmwiLCJzY3JpcHQiLCJzZXRBdHRyaWJ1dGUiLCJhcHBlbmQiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImFkZEV2ZW50TGlzdGVuZXIiLCJlIiwiVnVlSW5zdGFsbGVyIiwidXNlIiwicGx1Z2luIiwicGx1Z2lucyIsImZpbHRlcnMiLCJkaXJlY3RpdmUiLCJkaXJlY3RpdmVzIiwiJHBsdWdpbnMiLCIkZmlsdGVycyIsIiRkaXJlY3RpdmVzIiwiJGNvbXBvbmVudHMiLCJ3aW5kb3ciLCJkZWYiLCJpbnN0YWxsIiwiQWN0aXZpdHlJbmRpY2F0b3IiLCJjb252ZXJ0QW5pbWF0aW9uRGVsYXlUb0ludCIsImRlbGF5IiwibnVtIiwicGFyc2VGbG9hdCIsIm1hdGNoZXMiLCJtYXRjaCIsInVuaXQiLCJtaWxsaXNlY29uZHMiLCJhbmltYXRlZCIsImNhbGxiYWNrIiwiZGVmYXVsdFZpZXciLCJvd25lckRvY3VtZW50Iiwic2V0VGltZW91dCIsImdldENvbXB1dGVkU3R5bGUiLCJhbmltYXRpb25EdXJhdGlvbiIsImFjdGl2aXR5IiwiZGlzYWJsZWQiLCJibG9jayIsImxhYmVsIiwiaWNvbiIsInZhcmlhbnQiLCJpbmRpY2F0b3IiLCJvcmllbnRhdGlvbiIsImRpc2FibGUiLCJlbmFibGUiLCJzaG93QWN0aXZpdHkiLCJjbGFzc0xpc3QiLCJhZGQiLCJoaWRlQWN0aXZpdHkiLCJyZW1vdmUiLCJvbkNsaWNrIiwiZXZlbnQiLCJBY3Rpdml0eUJ1dHRvbiIsInNldENhY2hlQWRkIiwic2V0Q2FjaGVIYXMiLCJTZXRDYWNoZSIsImFycmF5U29tZSIsImNhY2hlSGFzIiwiQ09NUEFSRV9QQVJUSUFMX0ZMQUciLCJDT01QQVJFX1VOT1JERVJFRF9GTEFHIiwiYm9vbFRhZyIsImRhdGVUYWciLCJlcnJvclRhZyIsIm1hcFRhZyIsIm51bWJlclRhZyIsInJlZ2V4cFRhZyIsInNldFRhZyIsInN0cmluZ1RhZyIsInN5bWJvbFRhZyIsImFycmF5QnVmZmVyVGFnIiwiZGF0YVZpZXdUYWciLCJzeW1ib2xQcm90byIsIm1hcFRvQXJyYXkiLCJzZXRUb0FycmF5IiwiZXF1YWxBcnJheXMiLCJhcnJheVB1c2giLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsInN0dWJBcnJheSIsImFycmF5RmlsdGVyIiwiYmFzZUdldEFsbEtleXMiLCJnZXRTeW1ib2xzIiwiZ2V0QWxsS2V5cyIsIndlYWtNYXBUYWciLCJEYXRhVmlldyIsIlNldCIsIldlYWtNYXAiLCJhcnJheVRhZyIsImdldFRhZyIsImVxdWFsQnlUYWciLCJlcXVhbE9iamVjdHMiLCJiYXNlSXNFcXVhbERlZXAiLCJiYXNlSXNFcXVhbCIsImlzU3RyaWN0Q29tcGFyYWJsZSIsImdldE1hdGNoRGF0YSIsIm1hdGNoZXNTdHJpY3RDb21wYXJhYmxlIiwiYmFzZUlzTWF0Y2giLCJtZW1vaXplIiwibWVtb2l6ZUNhcHBlZCIsImlzS2V5Iiwic3RyaW5nVG9QYXRoIiwiSU5GSU5JVFkiLCJjYXN0UGF0aCIsInRvS2V5IiwiYmFzZUdldCIsImhhc1BhdGgiLCJiYXNlSGFzSW4iLCJnZXQiLCJoYXNJbiIsImJhc2VQcm9wZXJ0eSIsImJhc2VQcm9wZXJ0eURlZXAiLCJiYXNlTWF0Y2hlc1Byb3BlcnR5IiwiYmFzZU1hdGNoZXMiLCJwcm9wZXJ0eSIsImJhc2VJdGVyYXRlZSIsInN1YmplY3QiLCJkZWxpbWV0ZXIiLCJwcmVmaXhlciIsImtleSIsInN0cmluZyIsIlJlZ0V4cCIsImpvaW4iLCJfaXNOdWxsIiwiX2lzVW5kZWZpbmVkIiwiX21hcEtleXMiLCJ2YXJpYW50Q2xhc3NQcmVmaXgiLCJ2YXJpYW50Q2xhc3MiLCJkdXJhdGlvbiIsInRyYW5zaXRpb25EdXJhdGlvbiIsIm51bWVyaWMiLCJ0cmFuc2l0aW9uIiwibWl4aW5zIiwiVmFyaWFudCIsImRpc21pc3NpYmxlIiwiZmFkZSIsImRpc21pc3MiLCJ0aGVuIiwiZGlzbWlzc0NvdW50IiwiaW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJBbGVydCIsIkFsZXJ0TGluayIsIkFsZXJ0Q2xvc2UiLCJBbGVydEhlYWRpbmciLCJhY2Nlc3NpYmlsaXR5IiwiaHJlZiIsInBpbGwiLCJzZWNvbmRhcnkiLCJCYWRnZSIsImJhc2VSZWR1Y2UiLCJiYXNlU2V0IiwibmF0aXZlR2V0U3ltYm9scyIsImdldFN5bWJvbHNJbiIsImdldEFsbEtleXNJbiIsImJhc2VQaWNrQnkiLCJiYXNlRmlsdGVyIiwicnNBc3RyYWxSYW5nZSIsInJzVmFyUmFuZ2UiLCJyc1pXSiIsInJzRml0eiIsInJzTW9kaWZpZXIiLCJyc05vbkFzdHJhbCIsInJzUmVnaW9uYWwiLCJyc1N1cnJQYWlyIiwicmVPcHRNb2QiLCJyc09wdFZhciIsInJzT3B0Sm9pbiIsInJzU2VxIiwiaGFzVW5pY29kZSIsInVuaWNvZGVTaXplIiwiYXNjaWlTaXplIiwiaXNTdHJpbmciLCJzdHJpbmdTaXplIiwiYmFzZU1hcCIsImJhc2VTbGljZSIsInJzQXN0cmFsIiwicnNTeW1ib2wiLCJyZVVuaWNvZGUiLCJ1bmljb2RlVG9BcnJheSIsImFzY2lpVG9BcnJheSIsInN0cmluZ1RvQXJyYXkiLCJjYXN0U2xpY2UiLCJjcmVhdGVDYXNlRmlyc3QiLCJ1cHBlckZpcnN0IiwiY2FwaXRhbGl6ZSIsIm1ldGFNYXAiLCJjcmVhdGVDdG9yIiwibmF0aXZlTWF4IiwiYmFzZUxvZGFzaCIsIm5vb3AiLCJyZWFsTmFtZXMiLCJMYXp5V3JhcHBlciIsIkxvZGFzaFdyYXBwZXIiLCJ3cmFwcGVyQ2xvbmUiLCJnZXRGdW5jTmFtZSIsImxvZGFzaCIsImdldERhdGEiLCJiYXNlU2V0RGF0YSIsInN0cmljdEluZGV4T2YiLCJiYXNlRmluZEluZGV4IiwiYmFzZUlzTmFOIiwiYmFzZUluZGV4T2YiLCJXUkFQX0JJTkRfRkxBRyIsImFycmF5SW5jbHVkZXMiLCJpbnNlcnRXcmFwRGV0YWlscyIsInVwZGF0ZVdyYXBEZXRhaWxzIiwiZ2V0V3JhcERldGFpbHMiLCJXUkFQX0JJTkRfS0VZX0ZMQUciLCJXUkFQX0NVUlJZX0ZMQUciLCJXUkFQX1BBUlRJQUxfRkxBRyIsIldSQVBfUEFSVElBTF9SSUdIVF9GTEFHIiwiaXNMYXppYWJsZSIsInNldERhdGEiLCJzZXRXcmFwVG9TdHJpbmciLCJXUkFQX0NVUlJZX1JJR0hUX0ZMQUciLCJXUkFQX0FSWV9GTEFHIiwiV1JBUF9GTElQX0ZMQUciLCJnZXRIb2xkZXIiLCJjb3VudEhvbGRlcnMiLCJjb21wb3NlQXJncyIsImNvbXBvc2VBcmdzUmlnaHQiLCJyZXBsYWNlSG9sZGVycyIsImNyZWF0ZVJlY3VycnkiLCJyZW9yZGVyIiwiY3JlYXRlSHlicmlkIiwiUExBQ0VIT0xERVIiLCJXUkFQX0NVUlJZX0JPVU5EX0ZMQUciLCJXUkFQX1JFQVJHX0ZMQUciLCJuYXRpdmVNaW4iLCJ0b051bWJlciIsInRvRmluaXRlIiwiRlVOQ19FUlJPUl9URVhUIiwidG9JbnRlZ2VyIiwibWVyZ2VEYXRhIiwiY3JlYXRlQmluZCIsImNyZWF0ZUN1cnJ5IiwiY3JlYXRlUGFydGlhbCIsImNyZWF0ZVdyYXAiLCJ0aGlzIiwiY29uZmlnIiwiUFJPWFlfQ09ORklHX1BST1BFUlRJRVMiLCJQUk9YWV9DT05GSUdfTUVUSE9EUyIsInByb3AiLCJjb250ZXh0Iiwic2V0IiwibWVyZ2UiLCJ2YWx1ZXMiLCJtZXRob2QiLCJhY3Rpb24iLCJfY2FtZWxDYXNlIiwiY2hhaW5hYmxlIiwiRm9ybURhdGEiLCJSZXF1ZXN0IiwiJGNvbmZpZyIsImhlYWRlcnMiLCJwYXJhbXMiLCJfYmluZCIsInJlc2V0IiwiJGVycm9yIiwiJHN0YXR1cyIsIiRzdGF0dXNUZXh0IiwiJHJlc3BvbnNlIiwiJHJlcXVlc3RTZW50QXQiLCIkcmVzcG9uc2VSZWNlaXZlZEF0IiwiaGFzUmVzcG9uc2UiLCIkdXJsIiwicmVxdWVzdCIsImFkZENvbmZpZyIsInByb21pc2UiLCJheGlvcyIsInJlc3BvbnNlIiwic3RhdHVzIiwic3RhdHVzVGV4dCIsImVycm9yIiwiZXJyb3JzIiwiTW9kZWwiLCIkY2hhbmdlZCIsIiRleGlzdHMiLCIkYXR0cmlidXRlcyIsIiRrZXkiLCIkZmlsZXMiLCJmaWxlcyIsIiR0YWJsZSIsInRhYmxlIiwiJHByb3BlcnRpZXMiLCJwcm9wZXJ0aWVzIiwiaW5pdGlhbGl6ZSIsIkVycm9yIiwiJGluaXRpYWxpemVkIiwiZmlsbCIsInNldEF0dHJpYnV0ZXMiLCJnZXRBdHRyaWJ1dGVzIiwiaW5kZXhPZiIsImdldEF0dHJpYnV0ZSIsInVuZGVmaW5lZCIsIl9rZXlzIiwiX2ZpbHRlciIsImhhbmRsZUF0dHJpYnV0ZUNoYW5nZSIsIl9zaXplIiwiY291bnQiLCJ0b3RhbCIsIl9yZWR1Y2UiLCJjYXJyeSIsIkZpbGUiLCJGaWxlTGlzdCIsInRvSlNPTiIsImhhbmRsZVByaW1hcnlLZXlDaGFuZ2UiLCJleGlzdHMiLCJjcmVhdGUiLCJ1cGRhdGUiLCJoYXNGaWxlcyIsInRvSnNvbiIsInRvRm9ybURhdGEiLCJwb3N0IiwiZGVsZXRlIiwiX21hcCIsImNvbnN0cnVjdG9yIiwiaWQiLCJmb3JtIiwiaXRlbSIsIkpTT04iLCJzdHJpbmdpZnkiLCJfcGlja0J5IiwibGVuZ3RoIiwidmFsaWRhdGUiLCJtb2RlbCIsIk9iamVjdCIsImlubGluZSIsIm5vdmFsaWRhdGUiLCJyZWRpcmVjdCIsIkZ1bmN0aW9uIiwib25TdWJtaXQiLCJzdWJtaXQiLCJvblN1Ym1pdFN1Y2Nlc3MiLCJwdXNoIiwib25TdWJtaXRGYWlsZWQiLCJvblVwbG9hZFByb2dyZXNzIiwiQmFzZUZvcm0iLCJpdGVtcyIsIkFycmF5IiwiYWN0aXZlIiwiQnJlYWRjcnVtYiIsIkJyZWFkY3J1bWJJdGVtIiwic2l6ZWFibGVDbGFzcyIsIlNpemVhYmxlIiwib3V0bGluZSIsIkJ0biIsInBpY2tCeSIsIm5lZ2F0ZSIsIkNPTE9SUyIsIl9lYWNoIiwiY29sb3IiLCJuYW1lc3BhY2UiLCJpbnN0YW5jZSIsInRleHRDb2xvciIsImJnQ29sb3IiLCJib3JkZXJDb2xvciIsImJnR3JhZGllbnRDb2xvciIsInRleHRDb2xvckNsYXNzZXMiLCJ0cmltIiwiYm9yZGVyQ29sb3JDbGFzc2VzIiwiYmdDb2xvckNsYXNzZXMiLCJiZ0dyYWRpZW50Q29sb3JDbGFzc2VzIiwiY29sb3JhYmxlQ2xhc3NlcyIsIl9vbWl0QnkiLCJDb2xvcmFibGUiLCJidXR0b25zIiwidmVydGljYWwiLCJCdG5Hcm91cCIsIkJ0blRvb2xiYXIiLCJ1dWlkIiwiciIsIk1hdGgiLCJyYW5kb20iLCJ2IiwiYyIsInByb3h5Iiwic3BsaWNlIiwicHJldmVudERlZmF1bHQiLCJQcm94eSIsIm9uQ2xpY2tlZCIsImhlYWRlciIsIkRyb3Bkb3duTWVudUl0ZW0iLCJEcm9wZG93bk1lbnVIZWFkZXIiLCJEcm9wZG93bk1lbnVEaXZpZGVyIiwiYWxpZ24iLCJ0b0xvd2VyQ2FzZSIsIkRyb3Bkb3duTWVudSIsInNwbGl0IiwiZHJvcHVwIiwiZHJvcHJpZ2h0IiwiZHJvcGxlZnQiLCJ0b2dnbGUiLCJpc0Ryb3Bkb3duU2hvd2luZyIsIm9uQmx1ciIsImNvbnRhaW5zIiwicmVsYXRlZFRhcmdldCIsIm9uSXRlbUNsaWNrIiwiY2hpbGQiLCJhY3Rpb25DbGFzc2VzIiwidG9nZ2xlQ2xhc3NlcyIsIkJ1dHRvbkRyb3Bkb3duIiwiZ2V0U2xvdCIsInNsb3QiLCIkc2xvdHMiLCJoYXNTbG90IiwiaGFzU2xvdHMiLCJzbG90cyIsImkiLCJoYXNEZWZhdWx0U2xvdCIsIkhhc1Nsb3RzIiwiY2xhc3NOYW1lIiwiQ2FyZCIsIkNhcmRIZWFkZXIiLCJhbHQiLCJzcmMiLCJDYXJkSW1nIiwiQ2FyZEJvZHkiLCJDYXJkRm9vdGVyIiwiQ2FyZEltZ1RvcCIsIkNhcmRJbWdCb3R0b20iLCJDYXJkSW1nT3ZlcmxheSIsIkNhcmRMaW5rIiwiQ2FyZFN1YnRpdGxlIiwiQ2FyZFRpdGxlIiwicGxhY2Vob2xkZXIiLCJyZXF1aXJlZCIsImdyb3VwIiwicGF0dGVybiIsImZlZWRiYWNrIiwiYmluZEV2ZW50cyIsImRlZmF1bHRDb250cm9sQ2xhc3MiLCJoaWRlTGFiZWwiLCJzcGFjaW5nIiwicGxhaW50ZXh0IiwicmVhZG9ubHkiLCJoZWxwVGV4dCIsImJpbmQiLCJiaW5kaW5nIiwidm5vZGUiLCJldmVudHMiLCJnZXRJbnB1dEZpZWxkIiwiZ2V0RmllbGRFcnJvcnMiLCJ1cGRhdGVkIiwiY2FsbGJhY2tzIiwibWFwIiwiaW52YWxpZEZlZWRiYWNrIiwidmFsaWRGZWVkYmFjayIsImNvbnRyb2xDbGFzcyIsImNvbnRyb2xTaXplQ2xhc3MiLCJjb250cm9sQ2xhc3NlcyIsIkZvcm1Db250cm9sIiwiY3VzdG9tIiwiY2hlY2tlZCIsImNoZWNrZWRWYWx1ZSIsImxhYmVsQ2xhc3MiLCJpbnB1dENsYXNzIiwiaW5saW5lQ2xhc3MiLCJjdXN0b21Db250cm9sQ2xhc3MiLCJSYWRpb0ZpZWxkIiwiaW5kZXgiLCJDaGVja2JveEZpZWxkIiwiQ29udGFpbmVyIiwiSW5wdXRGaWVsZCIsImV4dGVuc2lvbnMiLCJtdWx0aXBsZSIsImhlaWdodCIsIndpZHRoIiwiRmlsZUZpZWxkIiwiRmlsZUJ1dHRvbiIsInJlYWRGaWxlIiwiZmlsZSIsInByb2dyZXNzIiwicmVhZGVyIiwiRmlsZVJlYWRlciIsIm9ubG9hZCIsIm9uZXJyb3IiLCJvbmFib3J0Iiwib25wcm9ncmVzcyIsInJlYWRBc0RhdGFVUkwiLCJzdHJpcGVkIiwibWluIiwibWF4Iiwib2Zmc2V0VmFsdWUiLCJmb3JtYXR0ZWRIZWlnaHQiLCJfaXNOdW1iZXIiLCJwcm9ncmVzc0NsYXNzZXMiLCJQcm9ncmVzc0JhciIsInJlYWR5IiwiaW5zZXJ0ZWQiLCJoaWRlQ2xvc2UiLCJpbWFnZU1pbWVzIiwib3JpZ19maWxlbmFtZSIsImV4dGVuc2lvbiIsInBvcCIsImJ5dGVzVG9TaXplIiwiYnl0ZXMiLCJtaW1lIiwiaXNJbWFnZSIsImxhc3RNb2RpZmllZCIsImxhc3RNb2RpZmllZERhdGUiLCJzdGFydCIsImxlbmd0aENvbXB1dGFibGUiLCJwYXJzZUludCIsImltYWdlIiwidGFyZ2V0IiwicmVzdWx0IiwiZGlmZiIsInNpemVzIiwiZmxvb3IiLCJsb2ciLCJyb3VuZCIsInBvdyIsIkZpbGVQcmV2aWV3Iiwic2VsZWN0IiwiaW52YWxpZCIsInZhbGlkIiwiRm9ybUZlZWRiYWNrIiwiRm9ybUdyb3VwIiwic3JPbmx5Iiwic3JPbmx5Rm9jdXNhYmxlIiwic2NyZWVucmVhZGVyQ2xhc3NlcyIsIlNjcmVlbnJlYWRlcnMiLCJGb3JtTGFiZWwiLCJIZWxwVGV4dCIsInByZXBlbmQiLCJ0ZXh0IiwiSW5wdXRHcm91cCIsIklucHV0R3JvdXBBcHBlbmQiLCJJbnB1dEdyb3VwUHJlcGVuZCIsIklucHV0R3JvdXBUZXh0IiwiYWN0aXZlQ2xhc3MiLCJvblZhbHVlIiwib2ZmVmFsdWUiLCJpc0FjdGl2ZSIsImRyYWdnaW5nIiwiZ2V0VHJhbnNpdGlvbkluTWlsbGlzZWNvbmRzIiwiTGlnaHRTd2l0Y2hGaWVsZCIsImJhZGdlIiwiaXNEaXNhYmxlZCIsImJhZGdlT3B0aW9ucyIsImFjdGl2YXRlIiwiZGVhY3RpdmF0ZSIsInByZXZWYWx1ZSIsIkxpc3RHcm91cEl0ZW0iLCJhY3RpdmF0ZWFibGUiLCJmbHVzaCIsImJpbmRFdmVudHNUb0NoaWxkcmVuIiwiJGNoaWxkcmVuIiwiJG9mZiIsIm9uQ2xpY2tDaGlsZCIsIiRvbiIsIm9uQWN0aXZhdGUiLCJvbkRlYWN0aXZhdGUiLCJhY3RpdmVJdGVtIiwiTGlzdEdyb3VwIiwiY2FyZCIsImp1c3RpZmllZCIsInBpbGxzIiwidGFicyIsInJvbGUiLCIkbmV4dFRpY2siLCJpc0NhcmQiLCJpc0l0ZW0iLCJOYXZpZ2F0aW9uTGluayIsImxpc3QiLCJOYXZpZ2F0aW9uIiwiTmF2aWdhdGlvbkl0ZW0iLCJOYXZpZ2F0aW9uRHJvcGRvd24iLCJwYWdlIiwidG90YWxQYWdlcyIsInNob3dQYWdlcyIsIm9uUGFnaW5hdGUiLCJuZXh0IiwicGFnaW5hdGUiLCJjdXJyZW50UGFnZSIsInByZXYiLCJjdXJyZW50VGFyZ2V0IiwicGFyZW50Tm9kZSIsInNldEFjdGl2ZVBhZ2UiLCJnZW5lcmF0ZSIsInBhZ2VzIiwic3RhcnRQYWdlIiwic3RhcnRPZmZzZXQiLCJlbmRQYWdlIiwiZGl2aWRlciIsIlBhZ2luYXRpb24iLCJDVVNUT01fU0VMRUNUX1BSRUZJWCIsImN1c3RvbVNlbGVjdENsYXNzZXMiLCJjdXN0b21TZWxlY3RTaXplQ2xhc3MiLCJTZWxlY3RGaWVsZCIsIlRyYW5zZm9ybWVyIiwiJG9yaWdpbmFsUmVzcG9uc2UiLCIkcmVxdWlyZWQiLCIkdHJhbnNmb3JtZWRSZXNwb25zZSIsInRyYW5zZm9ybSIsIlRhYmxlVmlld1RyYW5zZm9ybWVyIiwibGltaXQiLCJvcmRlciIsInNvcnQiLCJjb2x1bW5zIiwiaGVhZGluZyIsImhvdmVyIiwiZGVzY3JpcHRpb24iLCJ0cmFuc2Zvcm1lciIsInRhYmxlQ29sdW1ucyIsImNvbHVtbiIsIm9yZGVyQnkiLCJkZWZhdWx0U29ydCIsImN1cnJlbnRTb3J0IiwiZ2V0UmVxdWVzdFBhcmFtIiwiY3VycmVudE9yZGVyIiwiYWRkUmVxdWVzdFBhcmFtIiwiZmV0Y2giLCJnZXRSZXF1ZXN0SGVhZGVyIiwiYWRkUmVxdWVzdEhlYWRlciIsImxvYWRpbmciLCJlbGVtZW50cyIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsIiRhdHRycyIsImJlZm9yZURlc3Ryb3kiLCJUYWJsZVZpZXciLCJUZXh0YXJlYUZpZWxkIiwicGFyZW50IiwibGFzdCIsImFycmF5UHJvdG8iLCJiYXNlVW5zZXQiLCJiYXNlUHVsbEF0IiwibWF4VXBsb2FkcyIsImRyb3B6b25lTWluSGVpZ2h0IiwiZHJvcHpvbmUiLCJyZW1vdmVGaWxlIiwiYWRkRmlsZSIsIl9maW5kSW5kZXgiLCJhZGRGaWxlcyIsIm9uQ2hhbmdlIiwib25EcmFnT3ZlciIsImlzRHJhZ2dpbmdJbnNpZGUiLCJvbkRyYWdFbnRlciIsIm9uRHJhZ0xlYXZlIiwib25Ecm9wIiwiZGF0YVRyYW5zZmVyIiwic2hvd0Ryb3BFbGVtZW50IiwiVXBsb2FkRmllbGQiLCJSZXNwb25zZVRyYW5zZm9ybWVyIiwiYmxvYiIsInhociIsIlhNTEh0dHBSZXF1ZXN0Iiwib3BlbiIsInJlc3BvbnNlVHlwZSIsInNlbmQiLCJkb21haW4iLCJsb2NhdGlvbiIsImhvc3QiLCJwb3J0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7OztJQUVlLHFCQUFTQSxLQUFULEVBQWdCQyxNQUFoQixFQUF3QjtJQUNuQyxNQUFHRCxLQUFILEVBQVU7SUFDTixXQUFPRSxPQUFPQyxPQUFPSCxLQUFQLENBQVAsRUFBc0JDLE1BQXRCLENBQTZCQSxNQUE3QixDQUFQO0lBQ0g7O0lBRUQsU0FBTyxFQUFQO0lBQ0g7O0lDTmMsdUJBQVNELEtBQVQsRUFBZ0JDLE1BQWhCLEVBQXdCO0lBQ25DLE1BQUdELEtBQUgsRUFBVTtJQUNOLFdBQU9FLE9BQU9DLE9BQU9ILEtBQVAsQ0FBUCxFQUFzQkMsTUFBdEIsQ0FBNkJBLE1BQTdCLENBQVA7SUFDSDs7SUFFRCxTQUFPLEVBQVA7SUFDSDs7SUNBYyxnQkFBU0csR0FBVCxFQUFjQyxPQUFkLEVBQXVCO0lBQ2xDRCxNQUFJRSxNQUFKLENBQVcsTUFBWCxFQUFtQkMsVUFBbkI7SUFDQUgsTUFBSUUsTUFBSixDQUFXLFFBQVgsRUFBcUJFLFlBQXJCO0lBQ0g7Ozs7Ozs7OztJQ1hEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBeUJBLFNBQVMsUUFBUSxDQUFDLEtBQUssRUFBRTtNQUN2QixJQUFJLElBQUksR0FBRyxPQUFPLEtBQUssQ0FBQztNQUN4QixPQUFPLEtBQUssSUFBSSxJQUFJLEtBQUssSUFBSSxJQUFJLFFBQVEsSUFBSSxJQUFJLElBQUksVUFBVSxDQUFDLENBQUM7S0FDbEU7O0lBRUQsY0FBYyxHQUFHLFFBQVEsQ0FBQzs7SUM5QjFCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQXVCQSxJ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TUFBTSxFQUFFLEdBQUc7TUFDbkQsTUFBTSxFQUFFLEdBQUcsR0FBRyxNQUFNLEVBQUUsR0FBRztNQUN6QixNQUFNLEVBQUUsR0FBRyxHQUFHLE1BQU0sRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLEdBQUc7TUFDN0UsTUFBTSxFQUFFLEdBQUcsR0FBRyxNQUFNLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxHQUFHO01BQzdFLE1BQU0sRUFBRSxHQUFHLEdBQUcsTUFBTSxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxHQUFHO01BQ25ELE1BQU0sRUFBRSxHQUFHLEdBQUcsTUFBTSxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxHQUFHO01BQ25ELE1BQU0sRUFBRSxHQUFHLEdBQUcsTUFBTSxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsR0FBRztNQUN0QyxNQUFNLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxJQUFJO01BQzFCLE1BQU0sRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLElBQUk7TUFDMUIsTUFBTSxFQUFFLElBQUk7O01BRVosUUFBUSxFQUFFLEdBQUcsR0FBRyxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHO01BQzVDLFFBQVEsRUFBRSxHQUFHLEdBQUcsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRztNQUM1QyxRQUFRLEVBQUUsR0FBRyxHQUFHLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRztNQUMzRCxRQUFRLEVBQUUsR0FBRyxHQUFHLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRztNQUMzRCxRQUFRLEVBQUUsR0FBRyxHQUFHLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRztNQUMzRCxRQUFRLEVBQUUsR0FBRyxHQUFHLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHO01BQzFFLFFBQVEsRUFBRSxHQUFHLEdBQUcsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUc7TUFDMUUsUUFBUSxFQUFFLEdBQUcsR0FBRyxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUc7TUFDM0QsUUFBUSxFQUFFLEdBQUcsR0FBRyxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUc7TUFDM0QsUUFBUSxFQUFFLEdBQUcsR0FBRyxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUc7TUFDM0QsUUFBUSxFQUFFLEdBQUcsR0FBRyxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRztNQUMxRSxRQUFRLEVBQUUsR0FBRyxHQUFHLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHO01BQzFFLFFBQVEsRUFBRSxHQUFHLEdBQUcsUUFBUSxFQUFFLEdBQUc7TUFDN0IsUUFBUSxFQUFFLEdBQUcsR0FBRyxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHO01BQzVDLFFBQVEsRUFBRSxHQUFHLEdBQUcsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUc7TUFDMUUsUUFBUSxFQUFFLEdBQUcsR0FBRyxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRztNQUMxRSxRQUFRLEVBQUUsR0FBRyxHQUFHLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRztNQUMzRCxRQUFRLEVBQUUsR0FBRyxHQUFHLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRztNQUMzRCxRQUFRLEVBQUUsR0FBRyxHQUFHLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUc7TUFDNUMsUUFBUSxFQUFFLEdBQUcsR0FBRyxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHO01BQzVDLFFBQVEsRUFBRSxHQUFHLEdBQUcsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRztNQUM1QyxRQUFRLEVBQUUsR0FBRyxHQUFHLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUc7TUFDNUMsUUFBUSxFQUFFLEdBQUcsR0FBRyxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUc7TUFDM0QsUUFBUSxFQUFFLEdBQUcsR0FBRyxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUc7TUFDM0QsUUFBUSxFQUFFLEdBQUcsR0FBRyxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHO01BQzVDLFFBQVEsRUFBRSxHQUFHLEdBQUcsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRztNQUM1QyxRQUFRLEVBQUUsR0FBRyxHQUFHLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUc7TUFDekYsUUFBUSxFQUFFLEdBQUcsR0FBRyxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHO01BQ3pGLFFBQVEsRUFBRSxHQUFHLEdBQUcsUUFBUSxFQUFFLEdBQUc7TUFDN0IsUUFBUSxFQUFFLEdBQUcsR0FBRyxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHO01BQzVDLFFBQVEsRUFBRSxHQUFHLEdBQUcsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRztNQUM1QyxRQUFRLEVBQUUsR0FBRyxHQUFHLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUc7TUFDNUMsUUFBUSxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsSUFBSTtNQUM5QixRQUFRLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSxJQUFJO01BQzlCLFFBQVEsRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFLEdBQUc7S0FDOUIsQ0FBQzs7Ozs7Ozs7OztJQVVGLElBQUksWUFBWSxHQUFHRyxlQUFjLENBQUMsZUFBZSxDQUFDLENBQUM7O0lBRW5ELGlCQUFjLEdBQUcsWUFBWSxDQUFDOztJQ3RFOUI7Ozs7Ozs7OztJQVNBLFNBQVMsUUFBUSxDQUFDLEtBQUssRUFBRSxRQUFRLEVBQUU7TUFDakMsSUFBSSxLQUFLLEdBQUcsQ0FBQyxDQUFDO1VBQ1YsTUFBTSxHQUFHLEtBQUssSUFBSSxJQUFJLEdBQUcsQ0FBQyxHQUFHLEtBQUssQ0FBQyxNQUFNO1VBQ3pDLE1BQU0sR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUM7O01BRTNCLE9BQU8sRUFBRSxLQUFLLEdBQUcsTUFBTSxFQUFFO1FBQ3ZCLE1BQU0sQ0FBQyxLQUFLLENBQUMsR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxFQUFFLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQztPQUN0RDtNQUNELE9BQU8sTUFBTSxDQUFDO0tBQ2Y7O0lBRUQsYUFBYyxHQUFHLFFBQVEsQ0FBQzs7SUNqQjFCO0lBQ0EsSUFBSSxTQUFTLEdBQUcsaUJBQWlCLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFtQmxDLFNBQVMsUUFBUSxDQUFDLEtBQUssRUFBRTtNQUN2QixPQUFPLE9BQU8sS0FBSyxJQUFJLFFBQVE7U0FDNUJ0SSxjQUFZLENBQUMsS0FBSyxDQUFDLElBQUk1QixXQUFVLENBQUMsS0FBSyxDQUFDLElBQUksU0FBUyxDQUFDLENBQUM7S0FDM0Q7O0lBRUQsY0FBYyxHQUFHLFFBQVEsQ0FBQzs7SUN2QjFCO0lBQ0EsSUFBSSxRQUFRLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQzs7O0lBR3JCLElBQUksV0FBVyxHQUFHUixPQUFNLEdBQUdBLE9BQU0sQ0FBQyxTQUFTLEdBQUcsU0FBUztRQUNuRCxjQUFjLEdBQUcsV0FBVyxHQUFHLFdBQVcsQ0FBQyxRQUFRLEdBQUcsU0FBUyxDQUFDOzs7Ozs7Ozs7O0lBVXBFLFNBQVMsWUFBWSxDQUFDLEtBQUssRUFBRTs7TUFFM0IsSUFBSSxPQUFPLEtBQUssSUFBSSxRQUFRLEVBQUU7UUFDNUIsT0FBTyxLQUFLLENBQUM7T0FDZDtNQUNELElBQUk0QyxTQUFPLENBQUMsS0FBSyxDQUFDLEVBQUU7O1FBRWxCLE9BQU8rSCxTQUFRLENBQUMsS0FBSyxFQUFFLFlBQVksQ0FBQyxHQUFHLEVBQUUsQ0FBQztPQUMzQztNQUNELElBQUlDLFVBQVEsQ0FBQyxLQUFLLENBQUMsRUFBRTtRQUNuQixPQUFPLGNBQWMsR0FBRyxjQUFjLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsQ0FBQztPQUN6RDtNQUNELElBQUksTUFBTSxJQUFJLEtBQUssR0FBRyxFQUFFLENBQUMsQ0FBQztNQUMxQixPQUFPLENBQUMsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxLQUFLLEtBQUssQ0FBQyxRQUFRLElBQUksSUFBSSxHQUFHLE1BQU0sQ0FBQztLQUNwRTs7SUFFRCxpQkFBYyxHQUFHLFlBQVksQ0FBQzs7SUNsQzlCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFxQkEsU0FBUyxRQUFRLENBQUMsS0FBSyxFQUFFO01BQ3ZCLE9BQU8sS0FBSyxJQUFJLElBQUksR0FBRyxFQUFFLEdBQUdDLGFBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQztLQUNqRDs7SUFFRCxjQUFjLEdBQUcsUUFBUSxDQUFDOztJQ3hCMUI7SUFDQSxJQUFJLE9BQU8sR0FBRyw2Q0FBNkMsQ0FBQzs7O0lBRzVELElBQUksaUJBQWlCLEdBQUcsaUJBQWlCO1FBQ3JDLHFCQUFxQixHQUFHLGlCQUFpQjtRQUN6QyxtQkFBbUIsR0FBRyxpQkFBaUI7UUFDdkMsWUFBWSxHQUFHLGlCQUFpQixHQUFHLHFCQUFxQixHQUFHLG1CQUFtQixDQUFDOzs7SUFHbkYsSUFBSSxPQUFPLEdBQUcsR0FBRyxHQUFHLFlBQVksR0FBRyxHQUFHLENBQUM7Ozs7OztJQU12QyxJQUFJLFdBQVcsR0FBRyxNQUFNLENBQUMsT0FBTyxFQUFFLEdBQUcsQ0FBQyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQW9CdkMsU0FBUyxNQUFNLENBQUMsTUFBTSxFQUFFO01BQ3RCLE1BQU0sR0FBR0MsVUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDO01BQzFCLE9BQU8sTUFBTSxJQUFJLE1BQU0sQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFQyxhQUFZLENBQUMsQ0FBQyxPQUFPLENBQUMsV0FBVyxFQUFFLEVBQUUsQ0FBQyxDQUFDO0tBQ2pGOztJQUVELFlBQWMsR0FBRyxNQUFNLENBQUM7O0lDNUN4QjtJQUNBLElBQUksV0FBVyxHQUFHLDJDQUEyQyxDQUFDOzs7Ozs7Ozs7SUFTOUQsU0FBUyxVQUFVLENBQUMsTUFBTSxFQUFFO01BQzFCLE9BQU8sTUFBTSxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsSUFBSSxFQUFFLENBQUM7S0FDeEM7O0lBRUQsZUFBYyxHQUFHLFVBQVUsQ0FBQzs7SUNkNUI7SUFDQSxJQUFJLGdCQUFnQixHQUFHLHFFQUFxRSxDQUFDOzs7Ozs7Ozs7SUFTN0YsU0FBUyxjQUFjLENBQUMsTUFBTSxFQUFFO01BQzlCLE9BQU8sZ0JBQWdCLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0tBQ3RDOztJQUVELG1CQUFjLEdBQUcsY0FBYyxDQUFDOztJQ2RoQztJQUNBLElBQUksYUFBYSxHQUFHLGlCQUFpQjtRQUNqQ0MsbUJBQWlCLEdBQUcsaUJBQWlCO1FBQ3JDQyx1QkFBcUIsR0FBRyxpQkFBaUI7UUFDekNDLHFCQUFtQixHQUFHLGlCQUFpQjtRQUN2Q0MsY0FBWSxHQUFHSCxtQkFBaUIsR0FBR0MsdUJBQXFCLEdBQUdDLHFCQUFtQjtRQUM5RSxjQUFjLEdBQUcsaUJBQWlCO1FBQ2xDLFlBQVksR0FBRywyQkFBMkI7UUFDMUMsYUFBYSxHQUFHLHNCQUFzQjtRQUN0QyxjQUFjLEdBQUcsOENBQThDO1FBQy9ELGtCQUFrQixHQUFHLGlCQUFpQjtRQUN0QyxZQUFZLEdBQUcsOEpBQThKO1FBQzdLLFlBQVksR0FBRywyQkFBMkI7UUFDMUMsVUFBVSxHQUFHLGdCQUFnQjtRQUM3QixZQUFZLEdBQUcsYUFBYSxHQUFHLGNBQWMsR0FBRyxrQkFBa0IsR0FBRyxZQUFZLENBQUM7OztJQUd0RixJQUFJLE1BQU0sR0FBRyxXQUFXO1FBQ3BCLE9BQU8sR0FBRyxHQUFHLEdBQUcsWUFBWSxHQUFHLEdBQUc7UUFDbENFLFNBQU8sR0FBRyxHQUFHLEdBQUdELGNBQVksR0FBRyxHQUFHO1FBQ2xDLFFBQVEsR0FBRyxNQUFNO1FBQ2pCLFNBQVMsR0FBRyxHQUFHLEdBQUcsY0FBYyxHQUFHLEdBQUc7UUFDdEMsT0FBTyxHQUFHLEdBQUcsR0FBRyxZQUFZLEdBQUcsR0FBRztRQUNsQyxNQUFNLEdBQUcsSUFBSSxHQUFHLGFBQWEsR0FBRyxZQUFZLEdBQUcsUUFBUSxHQUFHLGNBQWMsR0FBRyxZQUFZLEdBQUcsWUFBWSxHQUFHLEdBQUc7UUFDNUcsTUFBTSxHQUFHLDBCQUEwQjtRQUNuQyxVQUFVLEdBQUcsS0FBSyxHQUFHQyxTQUFPLEdBQUcsR0FBRyxHQUFHLE1BQU0sR0FBRyxHQUFHO1FBQ2pELFdBQVcsR0FBRyxJQUFJLEdBQUcsYUFBYSxHQUFHLEdBQUc7UUFDeEMsVUFBVSxHQUFHLGlDQUFpQztRQUM5QyxVQUFVLEdBQUcsb0NBQW9DO1FBQ2pELE9BQU8sR0FBRyxHQUFHLEdBQUcsWUFBWSxHQUFHLEdBQUc7UUFDbEMsS0FBSyxHQUFHLFNBQVMsQ0FBQzs7O0lBR3RCLElBQUksV0FBVyxHQUFHLEtBQUssR0FBRyxPQUFPLEdBQUcsR0FBRyxHQUFHLE1BQU0sR0FBRyxHQUFHO1FBQ2xELFdBQVcsR0FBRyxLQUFLLEdBQUcsT0FBTyxHQUFHLEdBQUcsR0FBRyxNQUFNLEdBQUcsR0FBRztRQUNsRCxlQUFlLEdBQUcsS0FBSyxHQUFHLE1BQU0sR0FBRyx3QkFBd0I7UUFDM0QsZUFBZSxHQUFHLEtBQUssR0FBRyxNQUFNLEdBQUcsd0JBQXdCO1FBQzNELFFBQVEsR0FBRyxVQUFVLEdBQUcsR0FBRztRQUMzQixRQUFRLEdBQUcsR0FBRyxHQUFHLFVBQVUsR0FBRyxJQUFJO1FBQ2xDLFNBQVMsR0FBRyxLQUFLLEdBQUcsS0FBSyxHQUFHLEtBQUssR0FBRyxDQUFDLFdBQVcsRUFBRSxVQUFVLEVBQUUsVUFBVSxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEdBQUcsR0FBRyxRQUFRLEdBQUcsUUFBUSxHQUFHLElBQUk7UUFDdEgsVUFBVSxHQUFHLGtEQUFrRDtRQUMvRCxVQUFVLEdBQUcsa0RBQWtEO1FBQy9ELEtBQUssR0FBRyxRQUFRLEdBQUcsUUFBUSxHQUFHLFNBQVM7UUFDdkMsT0FBTyxHQUFHLEtBQUssR0FBRyxDQUFDLFNBQVMsRUFBRSxVQUFVLEVBQUUsVUFBVSxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEdBQUcsR0FBRyxLQUFLLENBQUM7OztJQUdsRixJQUFJLGFBQWEsR0FBRyxNQUFNLENBQUM7TUFDekIsT0FBTyxHQUFHLEdBQUcsR0FBRyxPQUFPLEdBQUcsR0FBRyxHQUFHLGVBQWUsR0FBRyxLQUFLLEdBQUcsQ0FBQyxPQUFPLEVBQUUsT0FBTyxFQUFFLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxHQUFHO01BQ2pHLFdBQVcsR0FBRyxHQUFHLEdBQUcsZUFBZSxHQUFHLEtBQUssR0FBRyxDQUFDLE9BQU8sRUFBRSxPQUFPLEdBQUcsV0FBVyxFQUFFLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxHQUFHO01BQ25HLE9BQU8sR0FBRyxHQUFHLEdBQUcsV0FBVyxHQUFHLEdBQUcsR0FBRyxlQUFlO01BQ25ELE9BQU8sR0FBRyxHQUFHLEdBQUcsZUFBZTtNQUMvQixVQUFVO01BQ1YsVUFBVTtNQUNWLFFBQVE7TUFDUixPQUFPO0tBQ1IsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUM7Ozs7Ozs7OztJQVNsQixTQUFTLFlBQVksQ0FBQyxNQUFNLEVBQUU7TUFDNUIsT0FBTyxNQUFNLENBQUMsS0FBSyxDQUFDLGFBQWEsQ0FBQyxJQUFJLEVBQUUsQ0FBQztLQUMxQzs7SUFFRCxpQkFBYyxHQUFHLFlBQVksQ0FBQzs7SUMvRDlCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBbUJBLFNBQVMsS0FBSyxDQUFDLE1BQU0sRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFO01BQ3JDLE1BQU0sR0FBR04sVUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDO01BQzFCLE9BQU8sR0FBRyxLQUFLLEdBQUcsU0FBUyxHQUFHLE9BQU8sQ0FBQzs7TUFFdEMsSUFBSSxPQUFPLEtBQUssU0FBUyxFQUFFO1FBQ3pCLE9BQU9PLGVBQWMsQ0FBQyxNQUFNLENBQUMsR0FBR0MsYUFBWSxDQUFDLE1BQU0sQ0FBQyxHQUFHQyxXQUFVLENBQUMsTUFBTSxDQUFDLENBQUM7T0FDM0U7TUFDRCxPQUFPLE1BQU0sQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxDQUFDO0tBQ3BDOztJQUVELFdBQWMsR0FBRyxLQUFLLENBQUM7O0lDOUJ2QjtJQUNBLElBQUlDLFFBQU0sR0FBRyxXQUFXLENBQUM7OztJQUd6QixJQUFJLE1BQU0sR0FBRyxNQUFNLENBQUNBLFFBQU0sRUFBRSxHQUFHLENBQUMsQ0FBQzs7Ozs7Ozs7O0lBU2pDLFNBQVMsZ0JBQWdCLENBQUMsUUFBUSxFQUFFO01BQ2xDLE9BQU8sU0FBUyxNQUFNLEVBQUU7UUFDdEIsT0FBT0MsWUFBVyxDQUFDQyxPQUFLLENBQUNDLFFBQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxDQUFDLEVBQUUsUUFBUSxFQUFFLEVBQUUsQ0FBQyxDQUFDO09BQzdFLENBQUM7S0FDSDs7SUFFRCxxQkFBYyxHQUFHLGdCQUFnQixDQUFDOztJQ3JCbEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQXFCQSxJQUFJLFNBQVMsR0FBR0MsaUJBQWdCLENBQUMsU0FBUyxNQUFNLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRTtNQUM3RCxPQUFPLE1BQU0sSUFBSSxLQUFLLEdBQUcsR0FBRyxHQUFHLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztLQUN6RCxDQUFDLENBQUM7O0lBRUgsZUFBYyxHQUFHLFNBQVMsQ0FBQzs7QUNwQjNCLG1CQUFlO0lBQUNqRTs7Ozs7Ozs7Ozs7OztPQUFEO3lCQUFBO0lBRVhFLFNBQU87SUFDSGdFLFdBQU87SUFDSDlELFlBQU1PLE1BREg7SUFFSE4sZUFBUztJQUZOLEtBREo7SUFLSDhELFVBQU07SUFDRi9ELFlBQU12SSxNQURKO0lBRUZ3SSxlQUFTO0lBRlAsS0FMSDtJQVNIK0QsWUFBUTtJQUNKaEUsWUFBTXZJLE1BREY7SUFFSndJLGVBQVM7SUFGTDtJQVRMLEdBRkk7SUFpQlhnRSxZQUFVO0lBQ041RSxhQUFTLG1CQUFXO0lBQ2hCLFVBQU1BLFVBQVUsRUFBaEI7SUFFQUEsY0FBUSxLQUFLNkUsUUFBTCxDQUFjckUsSUFBdEIsSUFBOEIsQ0FBQyxDQUFDLEtBQUtxRSxRQUFMLENBQWNyRSxJQUE5QztJQUNBUixjQUFRLEtBQUsyRSxNQUFMLEdBQWMsS0FBS0QsSUFBTCxDQUFVSSxPQUFWLENBQWtCLEtBQUtILE1BQXZCLEVBQStCLEVBQS9CLENBQXRCLElBQTRELENBQUMsQ0FBQyxLQUFLRCxJQUFuRTtJQUVBLGFBQU8xRSxPQUFQO0lBQ0g7SUFSSztJQWpCQyxDQUFmOztBQ0pBLGdDQUFlO0lBRVhRLFFBQU0seUJBRks7SUFJWHVFLFdBQVNDO0lBSkUsQ0FBZjs7QUNDQSxtQ0FBZTtJQUVYeEUsUUFBTSw0QkFGSztJQUlYdUUsV0FBU0MsUUFKRTtJQU1YdkUsU0FBT3dFLE9BQU8sRUFBUCxFQUFXRCxTQUFTdkUsS0FBcEIsRUFBMkI7SUFDOUJnRSxXQUFPO0lBQ0g5RCxZQUFNTyxNQURIO0lBRUhOLGVBQVM7SUFGTjtJQUR1QixHQUEzQjtJQU5JLENBQWY7O0FDWUEsNEJBQWU7SUFBQ0w7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQUFEO3lCQUFBO0lBRVhDLFFBQU0sb0JBRks7SUFJWHVFLFdBQVNDLFFBSkU7SUFNWHZFLFNBQU87SUFFSHlFLFlBQVE7SUFDSnZFLFlBQU1HLE9BREY7SUFFSkYsZUFBUztJQUZMLEtBRkw7SUFPSEQsVUFBTTtJQUNGQSxZQUFNdkksTUFESjtJQUVGd0ksZUFBUztJQUZQO0lBUEgsR0FOSTtJQW9CWHVFLGNBQVk7SUFDUkMsZ0RBRFE7SUFFUkM7SUFGUSxHQXBCRDtJQXlCWFQsWUFBVTtJQUNOakMsZUFBVyxxQkFBVztJQUNsQixhQUFPMkMsWUFBVSxLQUFLWCxNQUFMLEdBQWMsS0FBS2hFLElBQUwsQ0FBVW1FLE9BQVYsQ0FBa0IsS0FBS0gsTUFBdkIsRUFBK0IsRUFBL0IsQ0FBeEIsQ0FBUDtJQUNIO0lBSEs7SUF6QkMsQ0FBZjs7SUNkQSxJQUFNWSxTQUFTLEVBQWY7O0lBRUEsU0FBU0MsT0FBVCxDQUFpQkMsR0FBakIsRUFBc0I7SUFDbEIsTUFBTUMsU0FBUzdELFNBQVNHLGFBQVQsQ0FBdUIsUUFBdkIsQ0FBZjtJQUNBMEQsU0FBT0MsWUFBUCxDQUFvQixLQUFwQixFQUEyQkYsR0FBM0I7SUFDQUMsU0FBT0MsWUFBUCxDQUFvQixNQUFwQixFQUE0QixpQkFBNUI7SUFDQUQsU0FBT0MsWUFBUCxDQUFvQixTQUFwQixFQUErQixPQUEvQjtJQUNBLFNBQU9ELE1BQVA7SUFDSDs7SUFFRCxTQUFTRSxNQUFULENBQWdCRixNQUFoQixFQUF3QjtJQUNwQixNQUFHN0QsU0FBU0osYUFBVCxDQUF1QixNQUF2QixDQUFILEVBQW1DO0lBQy9CSSxhQUFTSixhQUFULENBQXVCLE1BQXZCLEVBQStCTSxXQUEvQixDQUEyQzJELE1BQTNDO0lBQ0gsR0FGRCxNQUdLO0lBQ0Q3RCxhQUFTSixhQUFULENBQXVCLE1BQXZCLEVBQStCTSxXQUEvQixDQUEyQzJELE1BQTNDO0lBQ0g7O0lBRUQsU0FBT0EsTUFBUDtJQUNIOztBQUVELElBQWUsU0FBU0EsTUFBVCxDQUFnQkQsR0FBaEIsRUFBcUI7SUFDaEMsU0FBTyxJQUFJSSxPQUFKLENBQVksVUFBQ0MsT0FBRCxFQUFVQyxNQUFWLEVBQXFCO0lBQ3BDLFFBQUk7SUFDQSxVQUFHLENBQUNSLE9BQU9FLEdBQVAsQ0FBSixFQUFpQjtJQUNiRyxlQUFPSixRQUFRQyxHQUFSLENBQVAsRUFBcUJPLGdCQUFyQixDQUFzQyxNQUF0QyxFQUE4QyxhQUFLO0lBQy9DRixrQkFBUVAsT0FBT0UsR0FBUCxJQUFjUSxDQUF0QjtJQUNILFNBRkQ7SUFHSCxPQUpELE1BS0s7SUFDREgsZ0JBQVFQLE9BQU9FLEdBQVAsQ0FBUjtJQUNIO0lBQ0osS0FURCxDQVVBLE9BQU1RLENBQU4sRUFBUztJQUNMRixhQUFPRSxDQUFQO0lBQ0g7SUFDSixHQWRNLENBQVA7SUFlSDs7SUNwQ0QsSUFBTUMsZUFBZTtJQUNqQkMsVUFEaUI7SUFFakJULGdCQUZpQjtJQUdqQlUsZ0JBSGlCO0lBSWpCQyxvQkFKaUI7SUFLakI5TixnQkFMaUI7SUFNakIrTixvQkFOaUI7SUFPakIzRCxzQkFQaUI7SUFRakJ3Qyx3QkFSaUI7SUFTakJvQixzQkFUaUI7SUFVakJDLHdCQVZpQjtJQVdqQkMsWUFBVSxFQVhPO0lBWWpCQyxZQUFVLEVBWk87SUFhakJDLGVBQWEsRUFiSTtJQWNqQkMsZUFBYTtJQWRJLENBQXJCO0FBaUJBLElBQU8sU0FBU1QsR0FBVCxDQUFhQyxNQUFiLEVBQXFCO0lBQ3hCLE1BQUksT0FBT1MsTUFBUCxLQUFrQixXQUFsQixJQUFpQ0EsT0FBT3hPLEdBQTVDLEVBQWlEO0lBQzdDd08sV0FBT3hPLEdBQVAsQ0FBVzhOLEdBQVgsQ0FBZUMsTUFBZjtJQUNIOztJQUVELFNBQU9BLE1BQVA7SUFDSDtBQUVELElBQU8sU0FBU0EsTUFBVCxDQUFnQi9OLEdBQWhCLEVBQXFCbUksSUFBckIsRUFBMkJzRyxHQUEzQixFQUFnQztJQUNuQyxNQUFHLENBQUNaLGFBQWFPLFFBQWIsQ0FBc0JqRyxJQUF0QixDQUFKLEVBQWlDO0lBQzdCbkksUUFBSThOLEdBQUosQ0FBUUQsYUFBYU8sUUFBYixDQUFzQmpHLElBQXRCLElBQThCc0csR0FBdEM7SUFDSDtJQUNKO0FBRUQsSUFBTyxTQUFTVCxTQUFULENBQWlCaE8sR0FBakIsRUFBc0JnTyxPQUF0QixFQUErQjtJQUNsQyxPQUFLQSxPQUFMLEVBQWMsVUFBQ1MsR0FBRCxFQUFNdEcsSUFBTixFQUFlO0lBQ3pCNEYsV0FBTy9OLEdBQVAsRUFBWW1JLElBQVosRUFBa0JzRyxHQUFsQjtJQUNILEdBRkQ7SUFHSDtBQUVELElBQU8sU0FBU3ZPLE1BQVQsQ0FBZ0JGLEdBQWhCLEVBQXFCbUksSUFBckIsRUFBMkJzRyxHQUEzQixFQUFnQztJQUNuQyxNQUFHLENBQUNaLGFBQWFRLFFBQWIsQ0FBc0JsRyxJQUF0QixDQUFKLEVBQWlDO0lBQzdCbkksUUFBSThOLEdBQUosQ0FBUUQsYUFBYVEsUUFBYixDQUFzQmxHLElBQXRCLElBQThCc0csR0FBdEM7SUFDSDtJQUNKO0FBRUQsSUFBTyxTQUFTUixTQUFULENBQWlCak8sR0FBakIsRUFBc0JpTyxPQUF0QixFQUErQjtJQUNsQyxPQUFLQSxPQUFMLEVBQWMsVUFBQ1EsR0FBRCxFQUFNdEcsSUFBTixFQUFlO0lBQ3pCakksV0FBT0YsR0FBUCxFQUFZbUksSUFBWixFQUFrQnNHLEdBQWxCO0lBQ0gsR0FGRDtJQUdIO0FBRUQsSUFBTyxTQUFTbkUsU0FBVCxDQUFtQnRLLEdBQW5CLEVBQXdCbUksSUFBeEIsRUFBOEJzRyxHQUE5QixFQUFtQztJQUN0QyxNQUFHLENBQUNaLGFBQWFVLFdBQWIsQ0FBeUJwRyxJQUF6QixDQUFKLEVBQW9DO0lBQ2hDbkksUUFBSXNLLFNBQUosQ0FBY25DLElBQWQsRUFBb0IwRixhQUFhVSxXQUFiLENBQXlCcEcsSUFBekIsSUFBaUNzRyxHQUFyRDtJQUNIO0lBQ0o7QUFFRCxJQUFPLFNBQVMzQixVQUFULENBQW9COU0sR0FBcEIsRUFBeUI4TSxVQUF6QixFQUFxQztJQUN4QyxPQUFLQSxVQUFMLEVBQWlCLFVBQUMyQixHQUFELEVBQU10RyxJQUFOLEVBQWU7SUFDNUJtQyxjQUFVdEssR0FBVixFQUFlbUksSUFBZixFQUFxQnNHLEdBQXJCO0lBQ0gsR0FGRDtJQUdIO0FBRUQsSUFBTyxTQUFTUCxTQUFULENBQW1CbE8sR0FBbkIsRUFBd0JtSSxJQUF4QixFQUE4QnNHLEdBQTlCLEVBQW1DO0lBQ3RDLE1BQUcsQ0FBQ1osYUFBYVMsV0FBYixDQUF5Qm5HLElBQXpCLENBQUosRUFBb0M7SUFDaENuSSxRQUFJa08sU0FBSixDQUFjL0YsSUFBZCxFQUFvQjBGLGFBQWFTLFdBQWIsQ0FBeUJuRyxJQUF6QixJQUFpQ3NHLEdBQXJEO0lBQ0g7SUFDSjtBQUVELElBQU8sU0FBU04sVUFBVCxDQUFvQm5PLEdBQXBCLEVBQXlCbU8sVUFBekIsRUFBcUM7SUFDeEMsT0FBS0EsVUFBTCxFQUFpQixVQUFDTSxHQUFELEVBQU10RyxJQUFOLEVBQWU7SUFDNUIrRixjQUFVbE8sR0FBVixFQUFlbUksSUFBZixFQUFxQnNHLEdBQXJCO0lBQ0gsR0FGRDtJQUdIOztJQ3ZFRCxJQUFNVixXQUFTRixhQUFhQyxHQUFiLENBQWlCO0lBRTVCWSxTQUY0QixtQkFFcEIxTyxHQUZvQixFQUVmQyxPQUZlLEVBRU47SUFDbEI0TixpQkFBYWYsVUFBYixDQUF3QjtJQUNwQjZCO0lBRG9CLEtBQXhCO0lBR0g7SUFOMkIsQ0FBakIsQ0FBZjs7SUNRQSxJQUFNQyw2QkFBNkIsU0FBN0JBLDBCQUE2QixDQUFTQyxLQUFULEVBQWdCO0lBQy9DLE1BQU1DLE1BQU1DLFdBQVdGLEtBQVgsRUFBa0IsRUFBbEIsQ0FBWjtJQUNBLE1BQU1HLFVBQVVILE1BQU1JLEtBQU4sQ0FBWSxLQUFaLENBQWhCO0lBQ0EsTUFBTUMsT0FBT0YsVUFBVUEsUUFBUSxDQUFSLENBQVYsR0FBdUIsS0FBcEM7SUFFQSxNQUFJRyxZQUFKOztJQUVBLFVBQVFELElBQVI7SUFDSSxTQUFLLEdBQUw7SUFBVTtJQUNOQyxxQkFBZUwsTUFBTSxJQUFyQjtJQUNBOztJQUNKLFNBQUssSUFBTDtJQUNBO0lBQ0lLLHFCQUFlTCxHQUFmO0lBQ0E7SUFQUjs7SUFVQSxTQUFPSyxnQkFBZ0IsQ0FBdkI7SUFDSCxDQWxCRDs7SUFvQkEsSUFBTUMsV0FBVyxTQUFYQSxRQUFXLENBQVNsRyxFQUFULEVBQWFtRyxRQUFiLEVBQXVCO0lBQ3BDLE1BQU1DLGNBQWMsQ0FBQ3BHLEdBQUdxRyxhQUFILElBQW9CL0YsUUFBckIsRUFBK0I4RixXQUFuRDtJQUVBRSxhQUFXLFlBQU07SUFDYkgsYUFBU3ZOLEtBQVQ7SUFDSCxHQUZELEVBRUc4TSwyQkFBMkJVLFlBQVlHLGdCQUFaLENBQTZCdkcsRUFBN0IsRUFBaUN3RyxpQkFBNUQsQ0FGSDtJQUdILENBTkQ7O0FBUUEseUJBQWU7SUFBQ3hIOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQUFEO3lCQUFBO0lBRVhDLFFBQU0saUJBRks7SUFJWDJFLGNBQVk7SUFDUjZCO0lBRFEsR0FKRDtJQVFYdkcsU0FBTztJQUVIOzs7OztJQUtBdUgsY0FBVWxILE9BUFA7O0lBU0g7Ozs7O0lBS0FtSCxjQUFVbkgsT0FkUDs7SUFnQkg7Ozs7O0lBS0FvSCxXQUFPcEgsT0FyQko7O0lBdUJIOzs7Ozs7SUFNQXFILFdBQU8vUCxNQTdCSjs7SUErQkg7Ozs7O0lBS0FnUSxVQUFNaFEsTUFwQ0g7O0lBc0NIOzs7OztJQUtBc00sVUFBTTtJQUNGL0QsWUFBTXZJLE1BREo7SUFFRndJLGVBQVM7SUFGUCxLQTNDSDs7SUFnREg7Ozs7O0lBS0F5SCxhQUFTO0lBQ0wxSCxZQUFNdkksTUFERDtJQUVMd0ksZUFBUztJQUZKLEtBckROOztJQTBESDs7Ozs7SUFLQUQsVUFBTTtJQUNGQSxZQUFNdkksTUFESjtJQUVGd0ksZUFBUztJQUZQLEtBL0RIOztJQW9FSDs7Ozs7SUFLQTBILGVBQVc7SUFDUDNILFlBQU12SSxNQURDO0lBRVB3SSxlQUFTO0lBRkYsS0F6RVI7O0lBOEVIOzs7OztJQUtBMkgsaUJBQWE7SUFDVDVILFlBQU12SSxNQURHO0lBRVR3SSxlQUFTO0lBRkE7SUFuRlYsR0FSSTtJQWlHWFUsV0FBUztJQUVMOzs7OztJQUtBa0gsV0FQSyxxQkFPSztJQUNOLFdBQUtoSCxHQUFMLENBQVN5RyxRQUFULEdBQW9CLElBQXBCO0lBQ0gsS0FUSTs7SUFXTDs7Ozs7SUFLQVEsVUFoQkssb0JBZ0JJO0lBQ0wsV0FBS2pILEdBQUwsQ0FBU3lHLFFBQVQsR0FBb0IsS0FBcEI7SUFDSCxLQWxCSTs7SUFvQkw7Ozs7O0lBS0FTLGdCQXpCSywwQkF5QlU7SUFBQTs7SUFDWCxXQUFLRixPQUFMO0lBRUFmLGVBQVMsS0FBS2pHLEdBQWQsRUFBbUIsWUFBTTtJQUNyQixjQUFLQSxHQUFMLENBQVNtSCxTQUFULENBQW1CQyxHQUFuQixDQUF1QixjQUF2Qjs7SUFDQSxjQUFLMUcsS0FBTCxDQUFXLGVBQVg7SUFDSCxPQUhEO0lBSUgsS0FoQ0k7O0lBa0NMOzs7OztJQUtBMkcsZ0JBdkNLLDBCQXVDVTtJQUFBOztJQUNYLFdBQUtySCxHQUFMLENBQVNtSCxTQUFULENBQW1CQyxHQUFuQixDQUF1QixtQkFBdkI7SUFFQW5CLGVBQVMsS0FBS2pHLEdBQWQsRUFBbUIsWUFBTTtJQUNyQixlQUFLaUgsTUFBTDs7SUFDQSxlQUFLakgsR0FBTCxDQUFTbUgsU0FBVCxDQUFtQkcsTUFBbkIsQ0FBMEIsY0FBMUIsRUFBMEMsbUJBQTFDOztJQUNBLGVBQUs1RyxLQUFMLENBQVcsZUFBWDtJQUNILE9BSkQ7SUFLSCxLQS9DSTs7SUFpREw7Ozs7O0lBS0E2RyxXQXRESyxtQkFzREdDLEtBdERILEVBc0RVO0lBQ1gsV0FBSzlHLEtBQUwsQ0FBVyxPQUFYLEVBQW9COEcsS0FBcEIsRUFBMkIsSUFBM0I7SUFDSDtJQXhESSxHQWpHRTtJQTRKWHBFLFlBQVU7SUFFTjs7Ozs7SUFLQTVFLFdBUE0scUJBT0k7SUFDTixVQUFNQSxVQUFVO0lBQ1oscUJBQWEsS0FBS2tJLEtBRE47SUFFWix3QkFBZ0IsS0FBS0Y7SUFGVCxPQUFoQjtJQUtBaEksY0FBUSxTQUFTLEtBQUswRSxJQUFMLENBQVVJLE9BQVYsQ0FBa0IsTUFBbEIsRUFBMEIsRUFBMUIsQ0FBakIsSUFBa0QsQ0FBQyxDQUFDLEtBQUtKLElBQXpEO0lBQ0ExRSxjQUFRLFNBQVMsS0FBS3FJLE9BQUwsQ0FBYXZELE9BQWIsQ0FBcUIsTUFBckIsRUFBNkIsRUFBN0IsQ0FBakIsSUFBcUQsQ0FBQyxDQUFDLEtBQUt1RCxPQUE1RDtJQUNBckksY0FBUSxrQkFBa0IsS0FBS3VJLFdBQUwsQ0FBaUJ6RCxPQUFqQixDQUF5QixlQUF6QixFQUEwQyxFQUExQyxDQUExQixJQUEyRSxDQUFDLENBQUMsS0FBS3lELFdBQWxGO0lBQ0F2SSxjQUFRLDRCQUE0QixLQUFLc0ksU0FBTCxDQUFleEQsT0FBZixDQUF1Qix5QkFBdkIsRUFBa0QsRUFBbEQsQ0FBcEMsSUFBNkYsQ0FBQyxDQUFDLEtBQUt3RCxTQUFwRztJQUVBLGFBQU90SSxPQUFQO0lBQ0g7SUFuQkssR0E1SkM7SUFrTFhtQixTQUFPO0lBRUg2RyxZQUZHLG9CQUVNL1AsS0FGTixFQUVhO0lBQ1osVUFBR0EsS0FBSCxFQUFVO0lBQ04sYUFBS3lRLFlBQUw7SUFDSCxPQUZELE1BR0s7SUFDRCxhQUFLRyxZQUFMO0lBQ0g7SUFDSjtJQVRFO0lBbExJLENBQWY7O0lDcENBLElBQU16QyxXQUFTRixhQUFhQyxHQUFiLENBQWlCO0lBRTVCWSxTQUY0QixtQkFFcEIxTyxHQUZvQixFQUVmQyxPQUZlLEVBRU47SUFDbEI0TixpQkFBYWYsVUFBYixDQUF3QjtJQUNwQjhEO0lBRG9CLEtBQXhCO0lBR0g7SUFOMkIsQ0FBakIsQ0FBZjs7SUNIQTs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFpQkEsU0FBUyxXQUFXLENBQUMsS0FBSyxFQUFFO01BQzFCLE9BQU8sS0FBSyxLQUFLLFNBQVMsQ0FBQztLQUM1Qjs7SUFFRCxpQkFBYyxHQUFHLFdBQVcsQ0FBQzs7SUNyQjdCO0lBQ0EsSUFBSW5NLGdCQUFjLEdBQUcsMkJBQTJCLENBQUM7Ozs7Ozs7Ozs7OztJQVlqRCxTQUFTLFdBQVcsQ0FBQyxLQUFLLEVBQUU7TUFDMUIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsS0FBSyxFQUFFQSxnQkFBYyxDQUFDLENBQUM7TUFDekMsT0FBTyxJQUFJLENBQUM7S0FDYjs7SUFFRCxnQkFBYyxHQUFHLFdBQVcsQ0FBQzs7SUNsQjdCOzs7Ozs7Ozs7SUFTQSxTQUFTLFdBQVcsQ0FBQyxLQUFLLEVBQUU7TUFDMUIsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztLQUNqQzs7SUFFRCxnQkFBYyxHQUFHLFdBQVcsQ0FBQzs7SUNUN0I7Ozs7Ozs7O0lBUUEsU0FBUyxRQUFRLENBQUMsTUFBTSxFQUFFO01BQ3hCLElBQUksS0FBSyxHQUFHLENBQUMsQ0FBQztVQUNWLE1BQU0sR0FBRyxNQUFNLElBQUksSUFBSSxHQUFHLENBQUMsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDOztNQUVoRCxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUljLFNBQVEsQ0FBQztNQUM3QixPQUFPLEVBQUUsS0FBSyxHQUFHLE1BQU0sRUFBRTtRQUN2QixJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO09BQ3pCO0tBQ0Y7OztJQUdELFFBQVEsQ0FBQyxTQUFTLENBQUMsR0FBRyxHQUFHLFFBQVEsQ0FBQyxTQUFTLENBQUMsSUFBSSxHQUFHc0wsWUFBVyxDQUFDO0lBQy9ELFFBQVEsQ0FBQyxTQUFTLENBQUMsR0FBRyxHQUFHQyxZQUFXLENBQUM7O0lBRXJDLGFBQWMsR0FBRyxRQUFRLENBQUM7O0lDMUIxQjs7Ozs7Ozs7OztJQVVBLFNBQVMsU0FBUyxDQUFDLEtBQUssRUFBRSxTQUFTLEVBQUU7TUFDbkMsSUFBSSxLQUFLLEdBQUcsQ0FBQyxDQUFDO1VBQ1YsTUFBTSxHQUFHLEtBQUssSUFBSSxJQUFJLEdBQUcsQ0FBQyxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUM7O01BRTlDLE9BQU8sRUFBRSxLQUFLLEdBQUcsTUFBTSxFQUFFO1FBQ3ZCLElBQUksU0FBUyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsRUFBRSxLQUFLLEVBQUUsS0FBSyxDQUFDLEVBQUU7VUFDekMsT0FBTyxJQUFJLENBQUM7U0FDYjtPQUNGO01BQ0QsT0FBTyxLQUFLLENBQUM7S0FDZDs7SUFFRCxjQUFjLEdBQUcsU0FBUyxDQUFDOztJQ3RCM0I7Ozs7Ozs7O0lBUUEsU0FBUyxRQUFRLENBQUMsS0FBSyxFQUFFLEdBQUcsRUFBRTtNQUM1QixPQUFPLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7S0FDdkI7O0lBRUQsYUFBYyxHQUFHLFFBQVEsQ0FBQzs7SUNSMUI7SUFDQSxJQUFJLG9CQUFvQixHQUFHLENBQUM7UUFDeEIsc0JBQXNCLEdBQUcsQ0FBQyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7SUFlL0IsU0FBUyxXQUFXLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUUsVUFBVSxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUU7TUFDeEUsSUFBSSxTQUFTLEdBQUcsT0FBTyxHQUFHLG9CQUFvQjtVQUMxQyxTQUFTLEdBQUcsS0FBSyxDQUFDLE1BQU07VUFDeEIsU0FBUyxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUM7O01BRTdCLElBQUksU0FBUyxJQUFJLFNBQVMsSUFBSSxFQUFFLFNBQVMsSUFBSSxTQUFTLEdBQUcsU0FBUyxDQUFDLEVBQUU7UUFDbkUsT0FBTyxLQUFLLENBQUM7T0FDZDs7TUFFRCxJQUFJLE9BQU8sR0FBRyxLQUFLLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO01BQy9CLElBQUksT0FBTyxJQUFJLEtBQUssQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEVBQUU7UUFDL0IsT0FBTyxPQUFPLElBQUksS0FBSyxDQUFDO09BQ3pCO01BQ0QsSUFBSSxLQUFLLEdBQUcsQ0FBQyxDQUFDO1VBQ1YsTUFBTSxHQUFHLElBQUk7VUFDYixJQUFJLEdBQUcsQ0FBQyxPQUFPLEdBQUcsc0JBQXNCLElBQUksSUFBSUMsU0FBUSxHQUFHLFNBQVMsQ0FBQzs7TUFFekUsS0FBSyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUM7TUFDeEIsS0FBSyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUM7OztNQUd4QixPQUFPLEVBQUUsS0FBSyxHQUFHLFNBQVMsRUFBRTtRQUMxQixJQUFJLFFBQVEsR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDO1lBQ3ZCLFFBQVEsR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7O1FBRTVCLElBQUksVUFBVSxFQUFFO1VBQ2QsSUFBSSxRQUFRLEdBQUcsU0FBUztjQUNwQixVQUFVLENBQUMsUUFBUSxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLENBQUM7Y0FDMUQsVUFBVSxDQUFDLFFBQVEsRUFBRSxRQUFRLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUM7U0FDaEU7UUFDRCxJQUFJLFFBQVEsS0FBSyxTQUFTLEVBQUU7VUFDMUIsSUFBSSxRQUFRLEVBQUU7WUFDWixTQUFTO1dBQ1Y7VUFDRCxNQUFNLEdBQUcsS0FBSyxDQUFDO1VBQ2YsTUFBTTtTQUNQOztRQUVELElBQUksSUFBSSxFQUFFO1VBQ1IsSUFBSSxDQUFDQyxVQUFTLENBQUMsS0FBSyxFQUFFLFNBQVMsUUFBUSxFQUFFLFFBQVEsRUFBRTtnQkFDN0MsSUFBSSxDQUFDQyxTQUFRLENBQUMsSUFBSSxFQUFFLFFBQVEsQ0FBQztxQkFDeEIsUUFBUSxLQUFLLFFBQVEsSUFBSSxTQUFTLENBQUMsUUFBUSxFQUFFLFFBQVEsRUFBRSxPQUFPLEVBQUUsVUFBVSxFQUFFLEtBQUssQ0FBQyxDQUFDLEVBQUU7a0JBQ3hGLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztpQkFDNUI7ZUFDRixDQUFDLEVBQUU7WUFDTixNQUFNLEdBQUcsS0FBSyxDQUFDO1lBQ2YsTUFBTTtXQUNQO1NBQ0YsTUFBTSxJQUFJO2NBQ0wsUUFBUSxLQUFLLFFBQVE7Z0JBQ25CLFNBQVMsQ0FBQyxRQUFRLEVBQUUsUUFBUSxFQUFFLE9BQU8sRUFBRSxVQUFVLEVBQUUsS0FBSyxDQUFDO2FBQzVELEVBQUU7VUFDTCxNQUFNLEdBQUcsS0FBSyxDQUFDO1VBQ2YsTUFBTTtTQUNQO09BQ0Y7TUFDRCxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUM7TUFDdkIsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDO01BQ3ZCLE9BQU8sTUFBTSxDQUFDO0tBQ2Y7O0lBRUQsZ0JBQWMsR0FBRyxXQUFXLENBQUM7O0lDbEY3Qjs7Ozs7OztJQU9BLFNBQVMsVUFBVSxDQUFDLEdBQUcsRUFBRTtNQUN2QixJQUFJLEtBQUssR0FBRyxDQUFDLENBQUM7VUFDVixNQUFNLEdBQUcsS0FBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQzs7TUFFN0IsR0FBRyxDQUFDLE9BQU8sQ0FBQyxTQUFTLEtBQUssRUFBRSxHQUFHLEVBQUU7UUFDL0IsTUFBTSxDQUFDLEVBQUUsS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDLENBQUM7T0FDaEMsQ0FBQyxDQUFDO01BQ0gsT0FBTyxNQUFNLENBQUM7S0FDZjs7SUFFRCxlQUFjLEdBQUcsVUFBVSxDQUFDOztJQ2pCNUI7Ozs7Ozs7SUFPQSxTQUFTLFVBQVUsQ0FBQyxHQUFHLEVBQUU7TUFDdkIsSUFBSSxLQUFLLEdBQUcsQ0FBQyxDQUFDO1VBQ1YsTUFBTSxHQUFHLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7O01BRTdCLEdBQUcsQ0FBQyxPQUFPLENBQUMsU0FBUyxLQUFLLEVBQUU7UUFDMUIsTUFBTSxDQUFDLEVBQUUsS0FBSyxDQUFDLEdBQUcsS0FBSyxDQUFDO09BQ3pCLENBQUMsQ0FBQztNQUNILE9BQU8sTUFBTSxDQUFDO0tBQ2Y7O0lBRUQsZUFBYyxHQUFHLFVBQVUsQ0FBQzs7SUNWNUI7SUFDQSxJQUFJQyxzQkFBb0IsR0FBRyxDQUFDO1FBQ3hCQyx3QkFBc0IsR0FBRyxDQUFDLENBQUM7OztJQUcvQixJQUFJQyxTQUFPLEdBQUcsa0JBQWtCO1FBQzVCQyxTQUFPLEdBQUcsZUFBZTtRQUN6QkMsVUFBUSxHQUFHLGdCQUFnQjtRQUMzQkMsUUFBTSxHQUFHLGNBQWM7UUFDdkJDLFdBQVMsR0FBRyxpQkFBaUI7UUFDN0JDLFdBQVMsR0FBRyxpQkFBaUI7UUFDN0JDLFFBQU0sR0FBRyxjQUFjO1FBQ3ZCQyxXQUFTLEdBQUcsaUJBQWlCO1FBQzdCQyxXQUFTLEdBQUcsaUJBQWlCLENBQUM7O0lBRWxDLElBQUlDLGdCQUFjLEdBQUcsc0JBQXNCO1FBQ3ZDQyxhQUFXLEdBQUcsbUJBQW1CLENBQUM7OztJQUd0QyxJQUFJQyxhQUFXLEdBQUd4UixPQUFNLEdBQUdBLE9BQU0sQ0FBQyxTQUFTLEdBQUcsU0FBUztRQUNuRCxhQUFhLEdBQUd3UixhQUFXLEdBQUdBLGFBQVcsQ0FBQyxPQUFPLEdBQUcsU0FBUyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBbUJsRSxTQUFTLFVBQVUsQ0FBQyxNQUFNLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRSxPQUFPLEVBQUUsVUFBVSxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUU7TUFDN0UsUUFBUSxHQUFHO1FBQ1QsS0FBS0QsYUFBVztVQUNkLElBQUksQ0FBQyxNQUFNLENBQUMsVUFBVSxJQUFJLEtBQUssQ0FBQyxVQUFVO2VBQ3JDLE1BQU0sQ0FBQyxVQUFVLElBQUksS0FBSyxDQUFDLFVBQVUsQ0FBQyxFQUFFO1lBQzNDLE9BQU8sS0FBSyxDQUFDO1dBQ2Q7VUFDRCxNQUFNLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQztVQUN2QixLQUFLLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQzs7UUFFdkIsS0FBS0QsZ0JBQWM7VUFDakIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxVQUFVLElBQUksS0FBSyxDQUFDLFVBQVU7Y0FDdEMsQ0FBQyxTQUFTLENBQUMsSUFBSS9MLFdBQVUsQ0FBQyxNQUFNLENBQUMsRUFBRSxJQUFJQSxXQUFVLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRTtZQUM3RCxPQUFPLEtBQUssQ0FBQztXQUNkO1VBQ0QsT0FBTyxJQUFJLENBQUM7O1FBRWQsS0FBS3NMLFNBQU8sQ0FBQztRQUNiLEtBQUtDLFNBQU8sQ0FBQztRQUNiLEtBQUtHLFdBQVM7OztVQUdaLE9BQU83UCxJQUFFLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQzs7UUFFN0IsS0FBSzJQLFVBQVE7VUFDWCxPQUFPLE1BQU0sQ0FBQyxJQUFJLElBQUksS0FBSyxDQUFDLElBQUksSUFBSSxNQUFNLENBQUMsT0FBTyxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUM7O1FBRXRFLEtBQUtHLFdBQVMsQ0FBQztRQUNmLEtBQUtFLFdBQVM7Ozs7VUFJWixPQUFPLE1BQU0sS0FBSyxLQUFLLEdBQUcsRUFBRSxDQUFDLENBQUM7O1FBRWhDLEtBQUtKLFFBQU07VUFDVCxJQUFJLE9BQU8sR0FBR1MsV0FBVSxDQUFDOztRQUUzQixLQUFLTixRQUFNO1VBQ1QsSUFBSSxTQUFTLEdBQUcsT0FBTyxHQUFHUixzQkFBb0IsQ0FBQztVQUMvQyxPQUFPLEtBQUssT0FBTyxHQUFHZSxXQUFVLENBQUMsQ0FBQzs7VUFFbEMsSUFBSSxNQUFNLENBQUMsSUFBSSxJQUFJLEtBQUssQ0FBQyxJQUFJLElBQUksQ0FBQyxTQUFTLEVBQUU7WUFDM0MsT0FBTyxLQUFLLENBQUM7V0FDZDs7VUFFRCxJQUFJLE9BQU8sR0FBRyxLQUFLLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1VBQ2hDLElBQUksT0FBTyxFQUFFO1lBQ1gsT0FBTyxPQUFPLElBQUksS0FBSyxDQUFDO1dBQ3pCO1VBQ0QsT0FBTyxJQUFJZCx3QkFBc0IsQ0FBQzs7O1VBR2xDLEtBQUssQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxDQUFDO1VBQ3pCLElBQUksTUFBTSxHQUFHZSxZQUFXLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxFQUFFLE9BQU8sQ0FBQyxLQUFLLENBQUMsRUFBRSxPQUFPLEVBQUUsVUFBVSxFQUFFLFNBQVMsRUFBRSxLQUFLLENBQUMsQ0FBQztVQUNqRyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUM7VUFDeEIsT0FBTyxNQUFNLENBQUM7O1FBRWhCLEtBQUtOLFdBQVM7VUFDWixJQUFJLGFBQWEsRUFBRTtZQUNqQixPQUFPLGFBQWEsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksYUFBYSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztXQUNoRTtPQUNKO01BQ0QsT0FBTyxLQUFLLENBQUM7S0FDZDs7SUFFRCxlQUFjLEdBQUcsVUFBVSxDQUFDOztJQy9HNUI7Ozs7Ozs7O0lBUUEsU0FBUyxTQUFTLENBQUMsS0FBSyxFQUFFLE1BQU0sRUFBRTtNQUNoQyxJQUFJLEtBQUssR0FBRyxDQUFDLENBQUM7VUFDVixNQUFNLEdBQUcsTUFBTSxDQUFDLE1BQU07VUFDdEIsTUFBTSxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUM7O01BRTFCLE9BQU8sRUFBRSxLQUFLLEdBQUcsTUFBTSxFQUFFO1FBQ3ZCLEtBQUssQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO09BQ3ZDO01BQ0QsT0FBTyxLQUFLLENBQUM7S0FDZDs7SUFFRCxjQUFjLEdBQUcsU0FBUyxDQUFDOztJQ2hCM0I7Ozs7Ozs7Ozs7O0lBV0EsU0FBUyxjQUFjLENBQUMsTUFBTSxFQUFFLFFBQVEsRUFBRSxXQUFXLEVBQUU7TUFDckQsSUFBSSxNQUFNLEdBQUcsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDO01BQzlCLE9BQU96TyxTQUFPLENBQUMsTUFBTSxDQUFDLEdBQUcsTUFBTSxHQUFHZ1AsVUFBUyxDQUFDLE1BQU0sRUFBRSxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztLQUMxRTs7SUFFRCxtQkFBYyxHQUFHLGNBQWMsQ0FBQzs7SUNuQmhDOzs7Ozs7Ozs7SUFTQSxTQUFTLFdBQVcsQ0FBQyxLQUFLLEVBQUUsU0FBUyxFQUFFO01BQ3JDLElBQUksS0FBSyxHQUFHLENBQUMsQ0FBQztVQUNWLE1BQU0sR0FBRyxLQUFLLElBQUksSUFBSSxHQUFHLENBQUMsR0FBRyxLQUFLLENBQUMsTUFBTTtVQUN6QyxRQUFRLEdBQUcsQ0FBQztVQUNaLE1BQU0sR0FBRyxFQUFFLENBQUM7O01BRWhCLE9BQU8sRUFBRSxLQUFLLEdBQUcsTUFBTSxFQUFFO1FBQ3ZCLElBQUksS0FBSyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUN6QixJQUFJLFNBQVMsQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssQ0FBQyxFQUFFO1VBQ2xDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsQ0FBQyxHQUFHLEtBQUssQ0FBQztTQUM1QjtPQUNGO01BQ0QsT0FBTyxNQUFNLENBQUM7S0FDZjs7SUFFRCxnQkFBYyxHQUFHLFdBQVcsQ0FBQzs7SUN4QjdCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFrQkEsU0FBUyxTQUFTLEdBQUc7TUFDbkIsT0FBTyxFQUFFLENBQUM7S0FDWDs7SUFFRCxlQUFjLEdBQUcsU0FBUyxDQUFDOztJQ25CM0I7SUFDQSxJQUFJMVIsY0FBVyxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUM7OztJQUduQyxJQUFJMlIsc0JBQW9CLEdBQUczUixjQUFXLENBQUMsb0JBQW9CLENBQUM7OztJQUc1RCxJQUFJLGdCQUFnQixHQUFHLE1BQU0sQ0FBQyxxQkFBcUIsQ0FBQzs7Ozs7Ozs7O0lBU3BELElBQUksVUFBVSxHQUFHLENBQUMsZ0JBQWdCLEdBQUc0UixXQUFTLEdBQUcsU0FBUyxNQUFNLEVBQUU7TUFDaEUsSUFBSSxNQUFNLElBQUksSUFBSSxFQUFFO1FBQ2xCLE9BQU8sRUFBRSxDQUFDO09BQ1g7TUFDRCxNQUFNLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO01BQ3hCLE9BQU9DLFlBQVcsQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsRUFBRSxTQUFTLE1BQU0sRUFBRTtRQUM1RCxPQUFPRixzQkFBb0IsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQyxDQUFDO09BQ2xELENBQUMsQ0FBQztLQUNKLENBQUM7O0lBRUYsZUFBYyxHQUFHLFVBQVUsQ0FBQzs7SUN6QjVCOzs7Ozs7O0lBT0EsU0FBUyxVQUFVLENBQUMsTUFBTSxFQUFFO01BQzFCLE9BQU9HLGVBQWMsQ0FBQyxNQUFNLEVBQUVwTCxNQUFJLEVBQUVxTCxXQUFVLENBQUMsQ0FBQztLQUNqRDs7SUFFRCxlQUFjLEdBQUcsVUFBVSxDQUFDOztJQ2I1QjtJQUNBLElBQUl0QixzQkFBb0IsR0FBRyxDQUFDLENBQUM7OztJQUc3QixJQUFJelEsY0FBVyxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUM7OztJQUduQyxJQUFJVSxpQkFBYyxHQUFHVixjQUFXLENBQUMsY0FBYyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7SUFlaEQsU0FBUyxZQUFZLENBQUMsTUFBTSxFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUUsVUFBVSxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUU7TUFDMUUsSUFBSSxTQUFTLEdBQUcsT0FBTyxHQUFHeVEsc0JBQW9CO1VBQzFDLFFBQVEsR0FBR3VCLFdBQVUsQ0FBQyxNQUFNLENBQUM7VUFDN0IsU0FBUyxHQUFHLFFBQVEsQ0FBQyxNQUFNO1VBQzNCLFFBQVEsR0FBR0EsV0FBVSxDQUFDLEtBQUssQ0FBQztVQUM1QixTQUFTLEdBQUcsUUFBUSxDQUFDLE1BQU0sQ0FBQzs7TUFFaEMsSUFBSSxTQUFTLElBQUksU0FBUyxJQUFJLENBQUMsU0FBUyxFQUFFO1FBQ3hDLE9BQU8sS0FBSyxDQUFDO09BQ2Q7TUFDRCxJQUFJLEtBQUssR0FBRyxTQUFTLENBQUM7TUFDdEIsT0FBTyxLQUFLLEVBQUUsRUFBRTtRQUNkLElBQUksR0FBRyxHQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUMxQixJQUFJLEVBQUUsU0FBUyxHQUFHLEdBQUcsSUFBSSxLQUFLLEdBQUd0UixpQkFBYyxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDLENBQUMsRUFBRTtVQUNqRSxPQUFPLEtBQUssQ0FBQztTQUNkO09BQ0Y7O01BRUQsSUFBSSxPQUFPLEdBQUcsS0FBSyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQztNQUNoQyxJQUFJLE9BQU8sSUFBSSxLQUFLLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxFQUFFO1FBQy9CLE9BQU8sT0FBTyxJQUFJLEtBQUssQ0FBQztPQUN6QjtNQUNELElBQUksTUFBTSxHQUFHLElBQUksQ0FBQztNQUNsQixLQUFLLENBQUMsR0FBRyxDQUFDLE1BQU0sRUFBRSxLQUFLLENBQUMsQ0FBQztNQUN6QixLQUFLLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxNQUFNLENBQUMsQ0FBQzs7TUFFekIsSUFBSSxRQUFRLEdBQUcsU0FBUyxDQUFDO01BQ3pCLE9BQU8sRUFBRSxLQUFLLEdBQUcsU0FBUyxFQUFFO1FBQzFCLEdBQUcsR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDdEIsSUFBSSxRQUFRLEdBQUcsTUFBTSxDQUFDLEdBQUcsQ0FBQztZQUN0QixRQUFRLEdBQUcsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDOztRQUUxQixJQUFJLFVBQVUsRUFBRTtVQUNkLElBQUksUUFBUSxHQUFHLFNBQVM7Y0FDcEIsVUFBVSxDQUFDLFFBQVEsRUFBRSxRQUFRLEVBQUUsR0FBRyxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsS0FBSyxDQUFDO2NBQ3pELFVBQVUsQ0FBQyxRQUFRLEVBQUUsUUFBUSxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDO1NBQy9EOztRQUVELElBQUksRUFBRSxRQUFRLEtBQUssU0FBUztpQkFDbkIsUUFBUSxLQUFLLFFBQVEsSUFBSSxTQUFTLENBQUMsUUFBUSxFQUFFLFFBQVEsRUFBRSxPQUFPLEVBQUUsVUFBVSxFQUFFLEtBQUssQ0FBQztnQkFDbkYsUUFBUTthQUNYLEVBQUU7VUFDTCxNQUFNLEdBQUcsS0FBSyxDQUFDO1VBQ2YsTUFBTTtTQUNQO1FBQ0QsUUFBUSxLQUFLLFFBQVEsR0FBRyxHQUFHLElBQUksYUFBYSxDQUFDLENBQUM7T0FDL0M7TUFDRCxJQUFJLE1BQU0sSUFBSSxDQUFDLFFBQVEsRUFBRTtRQUN2QixJQUFJLE9BQU8sR0FBRyxNQUFNLENBQUMsV0FBVztZQUM1QixPQUFPLEdBQUcsS0FBSyxDQUFDLFdBQVcsQ0FBQzs7O1FBR2hDLElBQUksT0FBTyxJQUFJLE9BQU87YUFDakIsYUFBYSxJQUFJLE1BQU0sSUFBSSxhQUFhLElBQUksS0FBSyxDQUFDO1lBQ25ELEVBQUUsT0FBTyxPQUFPLElBQUksVUFBVSxJQUFJLE9BQU8sWUFBWSxPQUFPO2NBQzFELE9BQU8sT0FBTyxJQUFJLFVBQVUsSUFBSSxPQUFPLFlBQVksT0FBTyxDQUFDLEVBQUU7VUFDakUsTUFBTSxHQUFHLEtBQUssQ0FBQztTQUNoQjtPQUNGO01BQ0QsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDO01BQ3hCLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQztNQUN2QixPQUFPLE1BQU0sQ0FBQztLQUNmOztJQUVELGlCQUFjLEdBQUcsWUFBWSxDQUFDOztJQ3JGOUI7SUFDQSxJQUFJLFFBQVEsR0FBR00sVUFBUyxDQUFDakIsS0FBSSxFQUFFLFVBQVUsQ0FBQyxDQUFDOztJQUUzQyxhQUFjLEdBQUcsUUFBUSxDQUFDOztJQ0gxQjtJQUNBLElBQUlnTixTQUFPLEdBQUcvTCxVQUFTLENBQUNqQixLQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7O0lBRXpDLFlBQWMsR0FBR2dOLFNBQU8sQ0FBQzs7SUNIekI7SUFDQSxJQUFJLEdBQUcsR0FBRy9MLFVBQVMsQ0FBQ2pCLEtBQUksRUFBRSxLQUFLLENBQUMsQ0FBQzs7SUFFakMsUUFBYyxHQUFHLEdBQUcsQ0FBQzs7SUNIckI7SUFDQSxJQUFJLE9BQU8sR0FBR2lCLFVBQVMsQ0FBQ2pCLEtBQUksRUFBRSxTQUFTLENBQUMsQ0FBQzs7SUFFekMsWUFBYyxHQUFHLE9BQU8sQ0FBQzs7SUNFekI7SUFDQSxJQUFJK1EsUUFBTSxHQUFHLGNBQWM7UUFDdkJwTCxXQUFTLEdBQUcsaUJBQWlCO1FBQzdCLFVBQVUsR0FBRyxrQkFBa0I7UUFDL0J1TCxRQUFNLEdBQUcsY0FBYztRQUN2QmdCLFlBQVUsR0FBRyxrQkFBa0IsQ0FBQzs7SUFFcEMsSUFBSVosYUFBVyxHQUFHLG1CQUFtQixDQUFDOzs7SUFHdEMsSUFBSSxrQkFBa0IsR0FBR3hRLFNBQVEsQ0FBQ3FSLFNBQVEsQ0FBQztRQUN2QyxhQUFhLEdBQUdyUixTQUFRLENBQUNpRCxJQUFHLENBQUM7UUFDN0IsaUJBQWlCLEdBQUdqRCxTQUFRLENBQUNrTSxRQUFPLENBQUM7UUFDckMsYUFBYSxHQUFHbE0sU0FBUSxDQUFDc1IsSUFBRyxDQUFDO1FBQzdCLGlCQUFpQixHQUFHdFIsU0FBUSxDQUFDdVIsUUFBTyxDQUFDLENBQUM7Ozs7Ozs7OztJQVMxQyxJQUFJLE1BQU0sR0FBRzlSLFdBQVUsQ0FBQzs7O0lBR3hCLElBQUksQ0FBQzRSLFNBQVEsSUFBSSxNQUFNLENBQUMsSUFBSUEsU0FBUSxDQUFDLElBQUksV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSWIsYUFBVztTQUNuRXZOLElBQUcsSUFBSSxNQUFNLENBQUMsSUFBSUEsSUFBRyxDQUFDLElBQUlnTixRQUFNLENBQUM7U0FDakMvRCxRQUFPLElBQUksTUFBTSxDQUFDQSxRQUFPLENBQUMsT0FBTyxFQUFFLENBQUMsSUFBSSxVQUFVLENBQUM7U0FDbkRvRixJQUFHLElBQUksTUFBTSxDQUFDLElBQUlBLElBQUcsQ0FBQyxJQUFJbEIsUUFBTSxDQUFDO1NBQ2pDbUIsUUFBTyxJQUFJLE1BQU0sQ0FBQyxJQUFJQSxRQUFPLENBQUMsSUFBSUgsWUFBVSxDQUFDLEVBQUU7TUFDbEQsTUFBTSxHQUFHLFNBQVMsS0FBSyxFQUFFO1FBQ3ZCLElBQUksTUFBTSxHQUFHM1IsV0FBVSxDQUFDLEtBQUssQ0FBQztZQUMxQixJQUFJLEdBQUcsTUFBTSxJQUFJb0YsV0FBUyxHQUFHLEtBQUssQ0FBQyxXQUFXLEdBQUcsU0FBUztZQUMxRCxVQUFVLEdBQUcsSUFBSSxHQUFHN0UsU0FBUSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQzs7UUFFNUMsSUFBSSxVQUFVLEVBQUU7VUFDZCxRQUFRLFVBQVU7WUFDaEIsS0FBSyxrQkFBa0IsRUFBRSxPQUFPd1EsYUFBVyxDQUFDO1lBQzVDLEtBQUssYUFBYSxFQUFFLE9BQU9QLFFBQU0sQ0FBQztZQUNsQyxLQUFLLGlCQUFpQixFQUFFLE9BQU8sVUFBVSxDQUFDO1lBQzFDLEtBQUssYUFBYSxFQUFFLE9BQU9HLFFBQU0sQ0FBQztZQUNsQyxLQUFLLGlCQUFpQixFQUFFLE9BQU9nQixZQUFVLENBQUM7V0FDM0M7U0FDRjtRQUNELE9BQU8sTUFBTSxDQUFDO09BQ2YsQ0FBQztLQUNIOztJQUVELFdBQWMsR0FBRyxNQUFNLENBQUM7O0lDaER4QjtJQUNBLElBQUl4QixzQkFBb0IsR0FBRyxDQUFDLENBQUM7OztJQUc3QixJQUFJcE8sU0FBTyxHQUFHLG9CQUFvQjtRQUM5QmdRLFVBQVEsR0FBRyxnQkFBZ0I7UUFDM0IzTSxXQUFTLEdBQUcsaUJBQWlCLENBQUM7OztJQUdsQyxJQUFJMUYsY0FBVyxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUM7OztJQUduQyxJQUFJVSxpQkFBYyxHQUFHVixjQUFXLENBQUMsY0FBYyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0lBZ0JoRCxTQUFTLGVBQWUsQ0FBQyxNQUFNLEVBQUUsS0FBSyxFQUFFLE9BQU8sRUFBRSxVQUFVLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRTtNQUM3RSxJQUFJLFFBQVEsR0FBRzBDLFNBQU8sQ0FBQyxNQUFNLENBQUM7VUFDMUIsUUFBUSxHQUFHQSxTQUFPLENBQUMsS0FBSyxDQUFDO1VBQ3pCLE1BQU0sR0FBRyxRQUFRLEdBQUcyUCxVQUFRLEdBQUdDLE9BQU0sQ0FBQyxNQUFNLENBQUM7VUFDN0MsTUFBTSxHQUFHLFFBQVEsR0FBR0QsVUFBUSxHQUFHQyxPQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7O01BRWpELE1BQU0sR0FBRyxNQUFNLElBQUlqUSxTQUFPLEdBQUdxRCxXQUFTLEdBQUcsTUFBTSxDQUFDO01BQ2hELE1BQU0sR0FBRyxNQUFNLElBQUlyRCxTQUFPLEdBQUdxRCxXQUFTLEdBQUcsTUFBTSxDQUFDOztNQUVoRCxJQUFJLFFBQVEsR0FBRyxNQUFNLElBQUlBLFdBQVM7VUFDOUIsUUFBUSxHQUFHLE1BQU0sSUFBSUEsV0FBUztVQUM5QixTQUFTLEdBQUcsTUFBTSxJQUFJLE1BQU0sQ0FBQzs7TUFFakMsSUFBSSxTQUFTLElBQUk5QyxVQUFRLENBQUMsTUFBTSxDQUFDLEVBQUU7UUFDakMsSUFBSSxDQUFDQSxVQUFRLENBQUMsS0FBSyxDQUFDLEVBQUU7VUFDcEIsT0FBTyxLQUFLLENBQUM7U0FDZDtRQUNELFFBQVEsR0FBRyxJQUFJLENBQUM7UUFDaEIsUUFBUSxHQUFHLEtBQUssQ0FBQztPQUNsQjtNQUNELElBQUksU0FBUyxJQUFJLENBQUMsUUFBUSxFQUFFO1FBQzFCLEtBQUssS0FBSyxLQUFLLEdBQUcsSUFBSXlELE1BQUssQ0FBQyxDQUFDO1FBQzdCLE9BQU8sQ0FBQyxRQUFRLElBQUl4RCxjQUFZLENBQUMsTUFBTSxDQUFDO1lBQ3BDNE8sWUFBVyxDQUFDLE1BQU0sRUFBRSxLQUFLLEVBQUUsT0FBTyxFQUFFLFVBQVUsRUFBRSxTQUFTLEVBQUUsS0FBSyxDQUFDO1lBQ2pFYyxXQUFVLENBQUMsTUFBTSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsT0FBTyxFQUFFLFVBQVUsRUFBRSxTQUFTLEVBQUUsS0FBSyxDQUFDLENBQUM7T0FDOUU7TUFDRCxJQUFJLEVBQUUsT0FBTyxHQUFHOUIsc0JBQW9CLENBQUMsRUFBRTtRQUNyQyxJQUFJLFlBQVksR0FBRyxRQUFRLElBQUkvUCxpQkFBYyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsYUFBYSxDQUFDO1lBQ3JFLFlBQVksR0FBRyxRQUFRLElBQUlBLGlCQUFjLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxhQUFhLENBQUMsQ0FBQzs7UUFFekUsSUFBSSxZQUFZLElBQUksWUFBWSxFQUFFO1VBQ2hDLElBQUksWUFBWSxHQUFHLFlBQVksR0FBRyxNQUFNLENBQUMsS0FBSyxFQUFFLEdBQUcsTUFBTTtjQUNyRCxZQUFZLEdBQUcsWUFBWSxHQUFHLEtBQUssQ0FBQyxLQUFLLEVBQUUsR0FBRyxLQUFLLENBQUM7O1VBRXhELEtBQUssS0FBSyxLQUFLLEdBQUcsSUFBSTJGLE1BQUssQ0FBQyxDQUFDO1VBQzdCLE9BQU8sU0FBUyxDQUFDLFlBQVksRUFBRSxZQUFZLEVBQUUsT0FBTyxFQUFFLFVBQVUsRUFBRSxLQUFLLENBQUMsQ0FBQztTQUMxRTtPQUNGO01BQ0QsSUFBSSxDQUFDLFNBQVMsRUFBRTtRQUNkLE9BQU8sS0FBSyxDQUFDO09BQ2Q7TUFDRCxLQUFLLEtBQUssS0FBSyxHQUFHLElBQUlBLE1BQUssQ0FBQyxDQUFDO01BQzdCLE9BQU9tTSxhQUFZLENBQUMsTUFBTSxFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUUsVUFBVSxFQUFFLFNBQVMsRUFBRSxLQUFLLENBQUMsQ0FBQztLQUMzRTs7SUFFRCxvQkFBYyxHQUFHLGVBQWUsQ0FBQzs7SUMvRWpDOzs7Ozs7Ozs7Ozs7OztJQWNBLFNBQVMsV0FBVyxDQUFDLEtBQUssRUFBRSxLQUFLLEVBQUUsT0FBTyxFQUFFLFVBQVUsRUFBRSxLQUFLLEVBQUU7TUFDN0QsSUFBSSxLQUFLLEtBQUssS0FBSyxFQUFFO1FBQ25CLE9BQU8sSUFBSSxDQUFDO09BQ2I7TUFDRCxJQUFJLEtBQUssSUFBSSxJQUFJLElBQUksS0FBSyxJQUFJLElBQUksS0FBSyxDQUFDdFEsY0FBWSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUNBLGNBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFO1FBQ3BGLE9BQU8sS0FBSyxLQUFLLEtBQUssSUFBSSxLQUFLLEtBQUssS0FBSyxDQUFDO09BQzNDO01BQ0QsT0FBT3VRLGdCQUFlLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUUsVUFBVSxFQUFFLFdBQVcsRUFBRSxLQUFLLENBQUMsQ0FBQztLQUMvRTs7SUFFRCxnQkFBYyxHQUFHLFdBQVcsQ0FBQzs7SUN4QjdCO0lBQ0EsSUFBSWhDLHNCQUFvQixHQUFHLENBQUM7UUFDeEJDLHdCQUFzQixHQUFHLENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7O0lBWS9CLFNBQVMsV0FBVyxDQUFDLE1BQU0sRUFBRSxNQUFNLEVBQUUsU0FBUyxFQUFFLFVBQVUsRUFBRTtNQUMxRCxJQUFJLEtBQUssR0FBRyxTQUFTLENBQUMsTUFBTTtVQUN4QixNQUFNLEdBQUcsS0FBSztVQUNkLFlBQVksR0FBRyxDQUFDLFVBQVUsQ0FBQzs7TUFFL0IsSUFBSSxNQUFNLElBQUksSUFBSSxFQUFFO1FBQ2xCLE9BQU8sQ0FBQyxNQUFNLENBQUM7T0FDaEI7TUFDRCxNQUFNLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO01BQ3hCLE9BQU8sS0FBSyxFQUFFLEVBQUU7UUFDZCxJQUFJLElBQUksR0FBRyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDNUIsSUFBSSxDQUFDLFlBQVksSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDO2dCQUNwQixJQUFJLENBQUMsQ0FBQyxDQUFDLEtBQUssTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDM0IsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksTUFBTSxDQUFDO2NBQ3RCO1VBQ0osT0FBTyxLQUFLLENBQUM7U0FDZDtPQUNGO01BQ0QsT0FBTyxFQUFFLEtBQUssR0FBRyxNQUFNLEVBQUU7UUFDdkIsSUFBSSxHQUFHLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUN4QixJQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDO1lBQ2IsUUFBUSxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUM7WUFDdEIsUUFBUSxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQzs7UUFFdkIsSUFBSSxZQUFZLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFO1VBQzNCLElBQUksUUFBUSxLQUFLLFNBQVMsSUFBSSxFQUFFLEdBQUcsSUFBSSxNQUFNLENBQUMsRUFBRTtZQUM5QyxPQUFPLEtBQUssQ0FBQztXQUNkO1NBQ0YsTUFBTTtVQUNMLElBQUksS0FBSyxHQUFHLElBQUlySyxNQUFLLENBQUM7VUFDdEIsSUFBSSxVQUFVLEVBQUU7WUFDZCxJQUFJLE1BQU0sR0FBRyxVQUFVLENBQUMsUUFBUSxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxLQUFLLENBQUMsQ0FBQztXQUN6RTtVQUNELElBQUksRUFBRSxNQUFNLEtBQUssU0FBUztrQkFDbEJxTSxZQUFXLENBQUMsUUFBUSxFQUFFLFFBQVEsRUFBRWpDLHNCQUFvQixHQUFHQyx3QkFBc0IsRUFBRSxVQUFVLEVBQUUsS0FBSyxDQUFDO2tCQUNqRyxNQUFNO2VBQ1QsRUFBRTtZQUNMLE9BQU8sS0FBSyxDQUFDO1dBQ2Q7U0FDRjtPQUNGO01BQ0QsT0FBTyxJQUFJLENBQUM7S0FDYjs7SUFFRCxnQkFBYyxHQUFHLFdBQVcsQ0FBQzs7SUMzRDdCOzs7Ozs7OztJQVFBLFNBQVMsa0JBQWtCLENBQUMsS0FBSyxFQUFFO01BQ2pDLE9BQU8sS0FBSyxLQUFLLEtBQUssSUFBSSxDQUFDclEsVUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO0tBQzVDOztJQUVELHVCQUFjLEdBQUcsa0JBQWtCLENBQUM7O0lDWHBDOzs7Ozs7O0lBT0EsU0FBUyxZQUFZLENBQUMsTUFBTSxFQUFFO01BQzVCLElBQUksTUFBTSxHQUFHcUcsTUFBSSxDQUFDLE1BQU0sQ0FBQztVQUNyQixNQUFNLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQzs7TUFFM0IsT0FBTyxNQUFNLEVBQUUsRUFBRTtRQUNmLElBQUksR0FBRyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUM7WUFDcEIsS0FBSyxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQzs7UUFFeEIsTUFBTSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLEtBQUssRUFBRWlNLG1CQUFrQixDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7T0FDMUQ7TUFDRCxPQUFPLE1BQU0sQ0FBQztLQUNmOztJQUVELGlCQUFjLEdBQUcsWUFBWSxDQUFDOztJQ3ZCOUI7Ozs7Ozs7OztJQVNBLFNBQVMsdUJBQXVCLENBQUMsR0FBRyxFQUFFLFFBQVEsRUFBRTtNQUM5QyxPQUFPLFNBQVMsTUFBTSxFQUFFO1FBQ3RCLElBQUksTUFBTSxJQUFJLElBQUksRUFBRTtVQUNsQixPQUFPLEtBQUssQ0FBQztTQUNkO1FBQ0QsT0FBTyxNQUFNLENBQUMsR0FBRyxDQUFDLEtBQUssUUFBUTtXQUM1QixRQUFRLEtBQUssU0FBUyxLQUFLLEdBQUcsSUFBSSxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO09BQ3ZELENBQUM7S0FDSDs7SUFFRCw0QkFBYyxHQUFHLHVCQUF1QixDQUFDOztJQ2Z6Qzs7Ozs7OztJQU9BLFNBQVMsV0FBVyxDQUFDLE1BQU0sRUFBRTtNQUMzQixJQUFJLFNBQVMsR0FBR0MsYUFBWSxDQUFDLE1BQU0sQ0FBQyxDQUFDO01BQ3JDLElBQUksU0FBUyxDQUFDLE1BQU0sSUFBSSxDQUFDLElBQUksU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFO1FBQzVDLE9BQU9DLHdCQUF1QixDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztPQUNsRTtNQUNELE9BQU8sU0FBUyxNQUFNLEVBQUU7UUFDdEIsT0FBTyxNQUFNLEtBQUssTUFBTSxJQUFJQyxZQUFXLENBQUMsTUFBTSxFQUFFLE1BQU0sRUFBRSxTQUFTLENBQUMsQ0FBQztPQUNwRSxDQUFDO0tBQ0g7O0lBRUQsZ0JBQWMsR0FBRyxXQUFXLENBQUM7O0lDbEI3QjtJQUNBLElBQUksWUFBWSxHQUFHLGtEQUFrRDtRQUNqRSxhQUFhLEdBQUcsT0FBTyxDQUFDOzs7Ozs7Ozs7O0lBVTVCLFNBQVMsS0FBSyxDQUFDLEtBQUssRUFBRSxNQUFNLEVBQUU7TUFDNUIsSUFBSXBRLFNBQU8sQ0FBQyxLQUFLLENBQUMsRUFBRTtRQUNsQixPQUFPLEtBQUssQ0FBQztPQUNkO01BQ0QsSUFBSSxJQUFJLEdBQUcsT0FBTyxLQUFLLENBQUM7TUFDeEIsSUFBSSxJQUFJLElBQUksUUFBUSxJQUFJLElBQUksSUFBSSxRQUFRLElBQUksSUFBSSxJQUFJLFNBQVM7VUFDekQsS0FBSyxJQUFJLElBQUksSUFBSWdJLFVBQVEsQ0FBQyxLQUFLLENBQUMsRUFBRTtRQUNwQyxPQUFPLElBQUksQ0FBQztPQUNiO01BQ0QsT0FBTyxhQUFhLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUM7U0FDMUQsTUFBTSxJQUFJLElBQUksSUFBSSxLQUFLLElBQUksTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7S0FDL0M7O0lBRUQsVUFBYyxHQUFHLEtBQUssQ0FBQzs7SUMxQnZCO0lBQ0EsSUFBSSxlQUFlLEdBQUcscUJBQXFCLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUE4QzVDLFNBQVMsT0FBTyxDQUFDLElBQUksRUFBRSxRQUFRLEVBQUU7TUFDL0IsSUFBSSxPQUFPLElBQUksSUFBSSxVQUFVLEtBQUssUUFBUSxJQUFJLElBQUksSUFBSSxPQUFPLFFBQVEsSUFBSSxVQUFVLENBQUMsRUFBRTtRQUNwRixNQUFNLElBQUksU0FBUyxDQUFDLGVBQWUsQ0FBQyxDQUFDO09BQ3RDO01BQ0QsSUFBSSxRQUFRLEdBQUcsV0FBVztRQUN4QixJQUFJLElBQUksR0FBRyxTQUFTO1lBQ2hCLEdBQUcsR0FBRyxRQUFRLEdBQUcsUUFBUSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQztZQUNyRCxLQUFLLEdBQUcsUUFBUSxDQUFDLEtBQUssQ0FBQzs7UUFFM0IsSUFBSSxLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFO1VBQ2xCLE9BQU8sS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUN2QjtRQUNELElBQUksTUFBTSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQ3BDLFFBQVEsQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsTUFBTSxDQUFDLElBQUksS0FBSyxDQUFDO1FBQ2pELE9BQU8sTUFBTSxDQUFDO09BQ2YsQ0FBQztNQUNGLFFBQVEsQ0FBQyxLQUFLLEdBQUcsS0FBSyxPQUFPLENBQUMsS0FBSyxJQUFJNUYsU0FBUSxDQUFDLENBQUM7TUFDakQsT0FBTyxRQUFRLENBQUM7S0FDakI7OztJQUdELE9BQU8sQ0FBQyxLQUFLLEdBQUdBLFNBQVEsQ0FBQzs7SUFFekIsYUFBYyxHQUFHLE9BQU8sQ0FBQzs7SUN0RXpCO0lBQ0EsSUFBSSxnQkFBZ0IsR0FBRyxHQUFHLENBQUM7Ozs7Ozs7Ozs7SUFVM0IsU0FBUyxhQUFhLENBQUMsSUFBSSxFQUFFO01BQzNCLElBQUksTUFBTSxHQUFHaU8sU0FBTyxDQUFDLElBQUksRUFBRSxTQUFTLEdBQUcsRUFBRTtRQUN2QyxJQUFJLEtBQUssQ0FBQyxJQUFJLEtBQUssZ0JBQWdCLEVBQUU7VUFDbkMsS0FBSyxDQUFDLEtBQUssRUFBRSxDQUFDO1NBQ2Y7UUFDRCxPQUFPLEdBQUcsQ0FBQztPQUNaLENBQUMsQ0FBQzs7TUFFSCxJQUFJLEtBQUssR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDO01BQ3pCLE9BQU8sTUFBTSxDQUFDO0tBQ2Y7O0lBRUQsa0JBQWMsR0FBRyxhQUFhLENBQUM7O0lDdkIvQjtJQUNBLElBQUksVUFBVSxHQUFHLGtHQUFrRyxDQUFDOzs7SUFHcEgsSUFBSSxZQUFZLEdBQUcsVUFBVSxDQUFDOzs7Ozs7Ozs7SUFTOUIsSUFBSSxZQUFZLEdBQUdDLGNBQWEsQ0FBQyxTQUFTLE1BQU0sRUFBRTtNQUNoRCxJQUFJLE1BQU0sR0FBRyxFQUFFLENBQUM7TUFDaEIsSUFBSSxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUsVUFBVTtRQUN2QyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO09BQ2pCO01BQ0QsTUFBTSxDQUFDLE9BQU8sQ0FBQyxVQUFVLEVBQUUsU0FBUyxLQUFLLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUU7UUFDbkUsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLEdBQUcsU0FBUyxDQUFDLE9BQU8sQ0FBQyxZQUFZLEVBQUUsSUFBSSxDQUFDLElBQUksTUFBTSxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUM7T0FDaEYsQ0FBQyxDQUFDO01BQ0gsT0FBTyxNQUFNLENBQUM7S0FDZixDQUFDLENBQUM7O0lBRUgsaUJBQWMsR0FBRyxZQUFZLENBQUM7O0lDckI5Qjs7Ozs7Ozs7SUFRQSxTQUFTLFFBQVEsQ0FBQyxLQUFLLEVBQUUsTUFBTSxFQUFFO01BQy9CLElBQUl0USxTQUFPLENBQUMsS0FBSyxDQUFDLEVBQUU7UUFDbEIsT0FBTyxLQUFLLENBQUM7T0FDZDtNQUNELE9BQU91USxNQUFLLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEdBQUdDLGFBQVksQ0FBQ3RJLFVBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0tBQ3ZFOztJQUVELGFBQWMsR0FBRyxRQUFRLENBQUM7O0lDbEIxQjtJQUNBLElBQUl1SSxVQUFRLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQzs7Ozs7Ozs7O0lBU3JCLFNBQVMsS0FBSyxDQUFDLEtBQUssRUFBRTtNQUNwQixJQUFJLE9BQU8sS0FBSyxJQUFJLFFBQVEsSUFBSXpJLFVBQVEsQ0FBQyxLQUFLLENBQUMsRUFBRTtRQUMvQyxPQUFPLEtBQUssQ0FBQztPQUNkO01BQ0QsSUFBSSxNQUFNLElBQUksS0FBSyxHQUFHLEVBQUUsQ0FBQyxDQUFDO01BQzFCLE9BQU8sQ0FBQyxNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssS0FBSyxDQUFDeUksVUFBUSxJQUFJLElBQUksR0FBRyxNQUFNLENBQUM7S0FDcEU7O0lBRUQsVUFBYyxHQUFHLEtBQUssQ0FBQzs7SUNqQnZCOzs7Ozs7OztJQVFBLFNBQVMsT0FBTyxDQUFDLE1BQU0sRUFBRSxJQUFJLEVBQUU7TUFDN0IsSUFBSSxHQUFHQyxTQUFRLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxDQUFDOztNQUU5QixJQUFJLEtBQUssR0FBRyxDQUFDO1VBQ1QsTUFBTSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUM7O01BRXpCLE9BQU8sTUFBTSxJQUFJLElBQUksSUFBSSxLQUFLLEdBQUcsTUFBTSxFQUFFO1FBQ3ZDLE1BQU0sR0FBRyxNQUFNLENBQUNDLE1BQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7T0FDdkM7TUFDRCxPQUFPLENBQUMsS0FBSyxJQUFJLEtBQUssSUFBSSxNQUFNLElBQUksTUFBTSxHQUFHLFNBQVMsQ0FBQztLQUN4RDs7SUFFRCxZQUFjLEdBQUcsT0FBTyxDQUFDOztJQ3JCekI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUF5QkEsU0FBUyxHQUFHLENBQUMsTUFBTSxFQUFFLElBQUksRUFBRSxZQUFZLEVBQUU7TUFDdkMsSUFBSSxNQUFNLEdBQUcsTUFBTSxJQUFJLElBQUksR0FBRyxTQUFTLEdBQUdDLFFBQU8sQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLENBQUM7TUFDaEUsT0FBTyxNQUFNLEtBQUssU0FBUyxHQUFHLFlBQVksR0FBRyxNQUFNLENBQUM7S0FDckQ7O0lBRUQsU0FBYyxHQUFHLEdBQUcsQ0FBQzs7SUNoQ3JCOzs7Ozs7OztJQVFBLFNBQVMsU0FBUyxDQUFDLE1BQU0sRUFBRSxHQUFHLEVBQUU7TUFDOUIsT0FBTyxNQUFNLElBQUksSUFBSSxJQUFJLEdBQUcsSUFBSSxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7S0FDaEQ7O0lBRUQsY0FBYyxHQUFHLFNBQVMsQ0FBQzs7SUNMM0I7Ozs7Ozs7OztJQVNBLFNBQVMsT0FBTyxDQUFDLE1BQU0sRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFO01BQ3RDLElBQUksR0FBR0YsU0FBUSxDQUFDLElBQUksRUFBRSxNQUFNLENBQUMsQ0FBQzs7TUFFOUIsSUFBSSxLQUFLLEdBQUcsQ0FBQyxDQUFDO1VBQ1YsTUFBTSxHQUFHLElBQUksQ0FBQyxNQUFNO1VBQ3BCLE1BQU0sR0FBRyxLQUFLLENBQUM7O01BRW5CLE9BQU8sRUFBRSxLQUFLLEdBQUcsTUFBTSxFQUFFO1FBQ3ZCLElBQUksR0FBRyxHQUFHQyxNQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7UUFDN0IsSUFBSSxFQUFFLE1BQU0sR0FBRyxNQUFNLElBQUksSUFBSSxJQUFJLE9BQU8sQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUMsRUFBRTtVQUN0RCxNQUFNO1NBQ1A7UUFDRCxNQUFNLEdBQUcsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO09BQ3RCO01BQ0QsSUFBSSxNQUFNLElBQUksRUFBRSxLQUFLLElBQUksTUFBTSxFQUFFO1FBQy9CLE9BQU8sTUFBTSxDQUFDO09BQ2Y7TUFDRCxNQUFNLEdBQUcsTUFBTSxJQUFJLElBQUksR0FBRyxDQUFDLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQztNQUM1QyxPQUFPLENBQUMsQ0FBQyxNQUFNLElBQUl6UixVQUFRLENBQUMsTUFBTSxDQUFDLElBQUlHLFFBQU8sQ0FBQyxHQUFHLEVBQUUsTUFBTSxDQUFDO1NBQ3hEVyxTQUFPLENBQUMsTUFBTSxDQUFDLElBQUlDLGFBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0tBQzVDOztJQUVELFlBQWMsR0FBRyxPQUFPLENBQUM7O0lDbkN6Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUEwQkEsU0FBUyxLQUFLLENBQUMsTUFBTSxFQUFFLElBQUksRUFBRTtNQUMzQixPQUFPLE1BQU0sSUFBSSxJQUFJLElBQUk0USxRQUFPLENBQUMsTUFBTSxFQUFFLElBQUksRUFBRUMsVUFBUyxDQUFDLENBQUM7S0FDM0Q7O0lBRUQsV0FBYyxHQUFHLEtBQUssQ0FBQzs7SUN6QnZCO0lBQ0EsSUFBSS9DLHNCQUFvQixHQUFHLENBQUM7UUFDeEJDLHdCQUFzQixHQUFHLENBQUMsQ0FBQzs7Ozs7Ozs7OztJQVUvQixTQUFTLG1CQUFtQixDQUFDLElBQUksRUFBRSxRQUFRLEVBQUU7TUFDM0MsSUFBSXVDLE1BQUssQ0FBQyxJQUFJLENBQUMsSUFBSU4sbUJBQWtCLENBQUMsUUFBUSxDQUFDLEVBQUU7UUFDL0MsT0FBT0Usd0JBQXVCLENBQUNRLE1BQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxRQUFRLENBQUMsQ0FBQztPQUN2RDtNQUNELE9BQU8sU0FBUyxNQUFNLEVBQUU7UUFDdEIsSUFBSSxRQUFRLEdBQUdJLEtBQUcsQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDakMsT0FBTyxDQUFDLFFBQVEsS0FBSyxTQUFTLElBQUksUUFBUSxLQUFLLFFBQVE7WUFDbkRDLE9BQUssQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDO1lBQ25CaEIsWUFBVyxDQUFDLFFBQVEsRUFBRSxRQUFRLEVBQUVqQyxzQkFBb0IsR0FBR0Msd0JBQXNCLENBQUMsQ0FBQztPQUNwRixDQUFDO0tBQ0g7O0lBRUQsd0JBQWMsR0FBRyxtQkFBbUIsQ0FBQzs7SUNoQ3JDOzs7Ozs7O0lBT0EsU0FBUyxZQUFZLENBQUMsR0FBRyxFQUFFO01BQ3pCLE9BQU8sU0FBUyxNQUFNLEVBQUU7UUFDdEIsT0FBTyxNQUFNLElBQUksSUFBSSxHQUFHLFNBQVMsR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7T0FDakQsQ0FBQztLQUNIOztJQUVELGlCQUFjLEdBQUcsWUFBWSxDQUFDOztJQ1g5Qjs7Ozs7OztJQU9BLFNBQVMsZ0JBQWdCLENBQUMsSUFBSSxFQUFFO01BQzlCLE9BQU8sU0FBUyxNQUFNLEVBQUU7UUFDdEIsT0FBTzRDLFFBQU8sQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLENBQUM7T0FDOUIsQ0FBQztLQUNIOztJQUVELHFCQUFjLEdBQUcsZ0JBQWdCLENBQUM7O0lDVmxDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBc0JBLFNBQVMsUUFBUSxDQUFDLElBQUksRUFBRTtNQUN0QixPQUFPTCxNQUFLLENBQUMsSUFBSSxDQUFDLEdBQUdVLGFBQVksQ0FBQ04sTUFBSyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUdPLGlCQUFnQixDQUFDLElBQUksQ0FBQyxDQUFDO0tBQ3pFOztJQUVELGNBQWMsR0FBRyxRQUFRLENBQUM7O0lDekIxQjs7Ozs7OztJQU9BLFNBQVMsWUFBWSxDQUFDLEtBQUssRUFBRTs7O01BRzNCLElBQUksT0FBTyxLQUFLLElBQUksVUFBVSxFQUFFO1FBQzlCLE9BQU8sS0FBSyxDQUFDO09BQ2Q7TUFDRCxJQUFJLEtBQUssSUFBSSxJQUFJLEVBQUU7UUFDakIsT0FBT3RTLFVBQVEsQ0FBQztPQUNqQjtNQUNELElBQUksT0FBTyxLQUFLLElBQUksUUFBUSxFQUFFO1FBQzVCLE9BQU9vQixTQUFPLENBQUMsS0FBSyxDQUFDO1lBQ2pCbVIsb0JBQW1CLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUN2Q0MsWUFBVyxDQUFDLEtBQUssQ0FBQyxDQUFDO09BQ3hCO01BQ0QsT0FBT0MsVUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO0tBQ3hCOztJQUVELGlCQUFjLEdBQUcsWUFBWSxDQUFDOztJQzFCOUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQXFCQSxTQUFTLE9BQU8sQ0FBQyxNQUFNLEVBQUUsUUFBUSxFQUFFO01BQ2pDLElBQUksTUFBTSxHQUFHLEVBQUUsQ0FBQztNQUNoQixRQUFRLEdBQUdDLGFBQVksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDLENBQUM7O01BRXJDcE4sV0FBVSxDQUFDLE1BQU0sRUFBRSxTQUFTLEtBQUssRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFO1FBQzlDekYsZ0JBQWUsQ0FBQyxNQUFNLEVBQUUsUUFBUSxDQUFDLEtBQUssRUFBRSxHQUFHLEVBQUUsTUFBTSxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUM7T0FDOUQsQ0FBQyxDQUFDO01BQ0gsT0FBTyxNQUFNLENBQUM7S0FDZjs7SUFFRCxhQUFjLEdBQUcsT0FBTyxDQUFDOztJQ25DekI7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBaUJBLFNBQVMsTUFBTSxDQUFDLEtBQUssRUFBRTtNQUNyQixPQUFPLEtBQUssS0FBSyxJQUFJLENBQUM7S0FDdkI7O0lBRUQsWUFBYyxHQUFHLE1BQU0sQ0FBQzs7SUNoQlQsU0FBUzBLLE1BQVQsQ0FBZ0JvSSxPQUFoQixFQUF5QnBJLE1BQXpCLEVBQWtEO0lBQUEsTUFBakJxSSxTQUFpQix1RUFBTCxHQUFLOztJQUM3RCxNQUFNQyxXQUFXLFNBQVhBLFFBQVcsQ0FBQ2hWLEtBQUQsRUFBUWlWLEdBQVIsRUFBZ0I7SUFDN0IsUUFBTUMsU0FBU0QsT0FBT2pWLEtBQXRCO0lBRUEsV0FBTyxDQUNIME0sTUFERyxFQUVId0ksT0FBT3JJLE9BQVAsQ0FBZSxJQUFJc0ksTUFBSixZQUFlekksTUFBZixTQUF3QnFJLFNBQXhCLE9BQWYsRUFBc0QsRUFBdEQsQ0FGRyxFQUdMSyxJQUhLLENBR0FMLFNBSEEsQ0FBUDtJQUlILEdBUEQ7O0lBU0EsTUFBR00sU0FBT1AsT0FBUCxLQUFtQlEsY0FBWVIsT0FBWixDQUF0QixFQUEyQztJQUN2QyxXQUFPQSxPQUFQO0lBQ0g7O0lBRUQsTUFBRzNNLFdBQVMyTSxPQUFULENBQUgsRUFBc0I7SUFDbEIsV0FBT1MsVUFBUVQsT0FBUixFQUFpQkUsUUFBakIsQ0FBUDtJQUNIOztJQUVELFNBQU9BLFNBQVNGLE9BQVQsQ0FBUDtJQUNIOztBQ3RCRCxrQkFBZTtJQUVYdE0sU0FBTztJQUVIOzs7OztJQUtBNEgsYUFBUztJQUNMMUgsWUFBTXZJLE1BREQ7SUFFTHdJLGVBQVM7SUFGSjtJQVBOLEdBRkk7SUFnQlhnRSxZQUFVO0lBRU42SSxzQkFGTSxnQ0FFZTtJQUNqQixhQUFPLEtBQUs1SSxRQUFMLENBQWNyRSxJQUFyQjtJQUNILEtBSks7SUFNTmtOLGdCQU5NLDBCQU1TO0lBQ1gsYUFBTy9JLE9BQU8sS0FBSzBELE9BQVosRUFBcUIsS0FBS29GLGtCQUExQixDQUFQO0lBQ0g7SUFSSztJQWhCQyxDQUFmOztJQ0ZBLFNBQVNFLFFBQVQsQ0FBa0JwTSxFQUFsQixFQUFzQjtJQUNsQixNQUFNb00sV0FBVzdGLGlCQUFpQnZHLEVBQWpCLEVBQXFCcU0sa0JBQXRDO0lBQ0EsTUFBTUMsVUFBVXpHLFdBQVd1RyxRQUFYLEVBQXFCLEVBQXJCLEtBQTRCLENBQTVDO0lBQ0EsTUFBTXBHLE9BQU9vRyxTQUFTckcsS0FBVCxDQUFlLEtBQWYsQ0FBYjs7SUFFQSxVQUFRQyxLQUFLLENBQUwsQ0FBUjtJQUNJLFNBQUssR0FBTDtJQUNJLGFBQU9zRyxVQUFVLElBQWpCOztJQUNKLFNBQUssSUFBTDtJQUNJLGFBQU9BLE9BQVA7SUFKUjtJQU1IOztBQUVELElBQWUsU0FBU0MsVUFBVCxDQUFvQnZNLEVBQXBCLEVBQXdCO0lBQ25DLFNBQU8sSUFBSXNFLE9BQUosQ0FBWSxVQUFDQyxPQUFELEVBQVVDLE1BQVYsRUFBcUI7SUFDcEMsUUFBSTtJQUNBLFVBQU1tQixRQUFReUcsU0FBU3BNLEVBQVQsQ0FBZDtJQUNBc0csaUJBQVc7SUFBQSxlQUFNL0IsUUFBUW9CLEtBQVIsQ0FBTjtJQUFBLE9BQVgsRUFBaUNBLEtBQWpDO0lBQ0gsS0FIRCxDQUlBLE9BQU1qQixDQUFOLEVBQVM7SUFDTEYsYUFBT0UsQ0FBUDtJQUNIO0lBQ0osR0FSTSxDQUFQO0lBU0g7O0FDWEQsZ0JBQWU7SUFBQzFGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BQUQ7eUJBQUE7SUFFWEMsUUFBTSxPQUZLO0lBSVh1TixVQUFRLENBQ0pDLE9BREksQ0FKRztJQVFYdk4sU0FBTztJQUVIOzs7OztJQUtBd04saUJBQWFuTixPQVBWOztJQVNIOzs7OztJQUtBb04sVUFBTTtJQUNGdk4sWUFBTUcsT0FESjtJQUVGRixlQUFTO0lBRlAsS0FkSDs7SUFtQkg7Ozs7OztJQU1BYyxVQUFNO0lBQ0ZmLFlBQU0sQ0FBQ08sTUFBRCxFQUFTSixPQUFULENBREo7SUFFRkYsZUFBUztJQUZQO0lBekJILEdBUkk7SUF3Q1hVLFdBQVM7SUFFTDZNLFdBRksscUJBRUs7SUFBQTs7SUFDTkwsaUJBQVcsS0FBS3RNLEdBQWhCLEVBQXFCNE0sSUFBckIsQ0FBMEIsaUJBQVM7SUFDL0IsY0FBS2xNLEtBQUwsQ0FBVyxXQUFYO0lBQ0gsT0FGRDtJQUlBLFdBQUtBLEtBQUwsQ0FBVyxnQkFBWCxFQUE2QixLQUFLZCxTQUFMLEdBQWlCLEtBQTlDO0lBQ0g7SUFSSSxHQXhDRTtJQW9EWGlCLFNBcERXLHFCQW9ERDtJQUFBOztJQUNOLFFBQUcsT0FBTyxLQUFLWCxJQUFaLEtBQXFCLFFBQXhCLEVBQWtDO0lBQzlCLFVBQU1ILEtBQUssS0FBS0MsR0FBTCxDQUFTQyxhQUFULENBQXVCLGVBQXZCLENBQVg7SUFFQSxXQUFLUyxLQUFMLENBQVcsbUJBQVgsRUFBZ0MsS0FBS21NLFlBQUwsR0FBb0IsS0FBSzNNLElBQXpEO0lBRUEsVUFBTTRNLFdBQVdDLFlBQVksWUFBTTtJQUMvQixlQUFLck0sS0FBTCxDQUFXLG1CQUFYLEVBQWdDLE9BQUttTSxZQUFMLElBQXFCLENBQXJEOztJQUVBLFlBQUcsQ0FBQyxPQUFLQSxZQUFULEVBQXVCO0lBQ25CRyx3QkFBY0YsUUFBZDtJQUNBUixxQkFBV3ZNLEVBQVgsRUFBZTZNLElBQWYsQ0FBb0I7SUFBQSxtQkFBUyxPQUFLRCxPQUFMLEVBQVQ7SUFBQSxXQUFwQjtJQUNIO0lBQ0osT0FQZ0IsRUFPZCxJQVBjLENBQWpCO0lBUUg7SUFDSixHQW5FVTtJQXFFWDdMLE1BckVXLGtCQXFFSjtJQUNILFdBQU87SUFDSCtMLG9CQUFjLEtBQUszTSxJQURoQjtJQUVITixpQkFBVyxLQUFLTTtJQUZiLEtBQVA7SUFJSDtJQTFFVSxDQUFmOztBQ1BBLG9CQUFlO0lBQUNuQjs7Ozs7Ozs7OztPQUFEO3lCQUFBO0lBRVhDLFFBQU07SUFGSyxDQUFmOztBQ0VBLHFCQUFlO0lBQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BQUQ7eUJBQUE7SUFFWEMsUUFBTSxhQUZLO0lBSVhjLFdBQVM7SUFFTHlILFdBRkssbUJBRUdDLEtBRkgsRUFFVTtJQUNYLFdBQUs5RyxLQUFMLENBQVcsT0FBWCxFQUFvQjhHLEtBQXBCO0lBQ0g7SUFKSTtJQUpFLENBQWY7O0FDRkEsdUJBQWU7SUFBQ3pJOzs7Ozs7Ozs7O09BQUQ7eUJBQUE7SUFFWEMsUUFBTTtJQUZLLENBQWY7O0lDQ0EsSUFBTTRGLFdBQVNGLGFBQWFDLEdBQWIsQ0FBaUI7SUFFNUJZLFNBRjRCLG1CQUVwQjFPLEdBRm9CLEVBRWZDLE9BRmUsRUFFTjtJQUNsQjROLGlCQUFhZixVQUFiLENBQXdCO0lBQ3BCc0osa0JBRG9CO0lBRXBCQywwQkFGb0I7SUFHcEJDLDRCQUhvQjtJQUlwQkM7SUFKb0IsS0FBeEI7SUFNSDtJQVQyQixDQUFqQixDQUFmOztBQ1VBLGdCQUFlO0lBQUNyTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BQUQ7eUJBQUE7SUFFWEMsUUFBTSxPQUZLO0lBSVh1TixVQUFRLENBQ0pDLE9BREksQ0FKRztJQVFYdk4sU0FBTztJQUVIOzs7OztJQUtBb08sbUJBQWV6VyxNQVBaOztJQVNIOzs7OztJQUtBMFcsVUFBTTFXLE1BZEg7O0lBZ0JIOzs7OztJQUtBMlcsVUFBTWpPLE9BckJIOztJQXVCSDs7Ozs7SUFLQXFILFdBQU8sQ0FBQ2pILE1BQUQsRUFBUzlJLE1BQVQsQ0E1Qko7O0lBOEJIOzs7OztJQUtBNFcsZUFBV2xPO0lBbkNSLEdBUkk7SUErQ1g4RCxZQUFVO0lBRU41RSxXQUZNLHFCQUVJO0lBQ04sYUFBTzJFLE9BQU87SUFDVixnQkFBUSxLQUFLb0ssSUFESDtJQUVWLHFCQUFhLEtBQUtDO0lBRlIsT0FBUCxFQUdKLEtBQUtuSyxRQUFMLENBQWNyRSxJQUhWLENBQVA7SUFJSDtJQVBLO0lBL0NDLENBQWY7O0lDYkEsSUFBTTRGLFdBQVNGLGFBQWFDLEdBQWIsQ0FBaUI7SUFFNUJZLFNBRjRCLG1CQUVwQjFPLEdBRm9CLEVBRWZDLE9BRmUsRUFFTjtJQUNsQjROLGlCQUFhZixVQUFiLENBQXdCO0lBQ3BCOEo7SUFEb0IsS0FBeEI7SUFHSDtJQU4yQixDQUFqQixDQUFmOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQ0hBOzs7Ozs7Ozs7Ozs7O0lBYUEsU0FBUyxVQUFVLENBQUMsVUFBVSxFQUFFLFFBQVEsRUFBRSxXQUFXLEVBQUUsU0FBUyxFQUFFLFFBQVEsRUFBRTtNQUMxRSxRQUFRLENBQUMsVUFBVSxFQUFFLFNBQVMsS0FBSyxFQUFFLEtBQUssRUFBRSxVQUFVLEVBQUU7UUFDdEQsV0FBVyxHQUFHLFNBQVM7YUFDbEIsU0FBUyxHQUFHLEtBQUssRUFBRSxLQUFLO1lBQ3pCLFFBQVEsQ0FBQyxXQUFXLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxVQUFVLENBQUMsQ0FBQztPQUNyRCxDQUFDLENBQUM7TUFDSCxPQUFPLFdBQVcsQ0FBQztLQUNwQjs7SUFFRCxlQUFjLEdBQUcsVUFBVSxDQUFDOztJQ2hCNUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFxQ0EsU0FBUyxNQUFNLENBQUMsVUFBVSxFQUFFLFFBQVEsRUFBRSxXQUFXLEVBQUU7TUFDakQsSUFBSSxJQUFJLEdBQUd6VCxTQUFPLENBQUMsVUFBVSxDQUFDLEdBQUc2SSxZQUFXLEdBQUc2SyxXQUFVO1VBQ3JELFNBQVMsR0FBRyxTQUFTLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQzs7TUFFckMsT0FBTyxJQUFJLENBQUMsVUFBVSxFQUFFcEMsYUFBWSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUMsRUFBRSxXQUFXLEVBQUUsU0FBUyxFQUFFbE4sU0FBUSxDQUFDLENBQUM7S0FDdEY7O0lBRUQsWUFBYyxHQUFHLE1BQU0sQ0FBQzs7SUM1Q3hCOzs7Ozs7Ozs7O0lBVUEsU0FBUyxPQUFPLENBQUMsTUFBTSxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsVUFBVSxFQUFFO01BQ2hELElBQUksQ0FBQ3pHLFVBQVEsQ0FBQyxNQUFNLENBQUMsRUFBRTtRQUNyQixPQUFPLE1BQU0sQ0FBQztPQUNmO01BQ0QsSUFBSSxHQUFHK1MsU0FBUSxDQUFDLElBQUksRUFBRSxNQUFNLENBQUMsQ0FBQzs7TUFFOUIsSUFBSSxLQUFLLEdBQUcsQ0FBQyxDQUFDO1VBQ1YsTUFBTSxHQUFHLElBQUksQ0FBQyxNQUFNO1VBQ3BCLFNBQVMsR0FBRyxNQUFNLEdBQUcsQ0FBQztVQUN0QixNQUFNLEdBQUcsTUFBTSxDQUFDOztNQUVwQixPQUFPLE1BQU0sSUFBSSxJQUFJLElBQUksRUFBRSxLQUFLLEdBQUcsTUFBTSxFQUFFO1FBQ3pDLElBQUksR0FBRyxHQUFHQyxNQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ3hCLFFBQVEsR0FBRyxLQUFLLENBQUM7O1FBRXJCLElBQUksS0FBSyxJQUFJLFNBQVMsRUFBRTtVQUN0QixJQUFJLFFBQVEsR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7VUFDM0IsUUFBUSxHQUFHLFVBQVUsR0FBRyxVQUFVLENBQUMsUUFBUSxFQUFFLEdBQUcsRUFBRSxNQUFNLENBQUMsR0FBRyxTQUFTLENBQUM7VUFDdEUsSUFBSSxRQUFRLEtBQUssU0FBUyxFQUFFO1lBQzFCLFFBQVEsR0FBR2hULFVBQVEsQ0FBQyxRQUFRLENBQUM7Z0JBQ3pCLFFBQVE7aUJBQ1AwQixRQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQztXQUMxQztTQUNGO1FBQ0RYLFlBQVcsQ0FBQyxNQUFNLEVBQUUsR0FBRyxFQUFFLFFBQVEsQ0FBQyxDQUFDO1FBQ25DLE1BQU0sR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7T0FDdEI7TUFDRCxPQUFPLE1BQU0sQ0FBQztLQUNmOztJQUVELFlBQWMsR0FBRyxPQUFPLENBQUM7O0lDMUN6Qjs7Ozs7Ozs7O0lBU0EsU0FBUyxVQUFVLENBQUMsTUFBTSxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUU7TUFDNUMsSUFBSSxLQUFLLEdBQUcsQ0FBQyxDQUFDO1VBQ1YsTUFBTSxHQUFHLEtBQUssQ0FBQyxNQUFNO1VBQ3JCLE1BQU0sR0FBRyxFQUFFLENBQUM7O01BRWhCLE9BQU8sRUFBRSxLQUFLLEdBQUcsTUFBTSxFQUFFO1FBQ3ZCLElBQUksSUFBSSxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUM7WUFDbkIsS0FBSyxHQUFHa1MsUUFBTyxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsQ0FBQzs7UUFFbEMsSUFBSSxTQUFTLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxFQUFFO1VBQzFCK0MsUUFBTyxDQUFDLE1BQU0sRUFBRWpELFNBQVEsQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUM7U0FDaEQ7T0FDRjtNQUNELE9BQU8sTUFBTSxDQUFDO0tBQ2Y7O0lBRUQsZUFBYyxHQUFHLFVBQVUsQ0FBQzs7SUN4QjVCO0lBQ0EsSUFBSWtELGtCQUFnQixHQUFHLE1BQU0sQ0FBQyxxQkFBcUIsQ0FBQzs7Ozs7Ozs7O0lBU3BELElBQUksWUFBWSxHQUFHLENBQUNBLGtCQUFnQixHQUFHMUUsV0FBUyxHQUFHLFNBQVMsTUFBTSxFQUFFO01BQ2xFLElBQUksTUFBTSxHQUFHLEVBQUUsQ0FBQztNQUNoQixPQUFPLE1BQU0sRUFBRTtRQUNiRixVQUFTLENBQUMsTUFBTSxFQUFFSyxXQUFVLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztRQUN0QyxNQUFNLEdBQUd0TSxhQUFZLENBQUMsTUFBTSxDQUFDLENBQUM7T0FDL0I7TUFDRCxPQUFPLE1BQU0sQ0FBQztLQUNmLENBQUM7O0lBRUYsaUJBQWMsR0FBRyxZQUFZLENBQUM7O0lDcEI5Qjs7Ozs7Ozs7SUFRQSxTQUFTLFlBQVksQ0FBQyxNQUFNLEVBQUU7TUFDNUIsT0FBT3FNLGVBQWMsQ0FBQyxNQUFNLEVBQUV6TyxRQUFNLEVBQUVrVCxhQUFZLENBQUMsQ0FBQztLQUNyRDs7SUFFRCxpQkFBYyxHQUFHLFlBQVksQ0FBQzs7SUNYOUI7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQWtCQSxTQUFTLE1BQU0sQ0FBQyxNQUFNLEVBQUUsU0FBUyxFQUFFO01BQ2pDLElBQUksTUFBTSxJQUFJLElBQUksRUFBRTtRQUNsQixPQUFPLEVBQUUsQ0FBQztPQUNYO01BQ0QsSUFBSSxLQUFLLEdBQUc5TCxTQUFRLENBQUMrTCxhQUFZLENBQUMsTUFBTSxDQUFDLEVBQUUsU0FBUyxJQUFJLEVBQUU7UUFDeEQsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO09BQ2YsQ0FBQyxDQUFDO01BQ0gsU0FBUyxHQUFHeEMsYUFBWSxDQUFDLFNBQVMsQ0FBQyxDQUFDO01BQ3BDLE9BQU95QyxXQUFVLENBQUMsTUFBTSxFQUFFLEtBQUssRUFBRSxTQUFTLEtBQUssRUFBRSxJQUFJLEVBQUU7UUFDckQsT0FBTyxTQUFTLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO09BQ2xDLENBQUMsQ0FBQztLQUNKOztJQUVELFlBQWMsR0FBRyxNQUFNLENBQUM7O0lDbEN4Qjs7Ozs7Ozs7SUFRQSxTQUFTLFVBQVUsQ0FBQyxVQUFVLEVBQUUsU0FBUyxFQUFFO01BQ3pDLElBQUksTUFBTSxHQUFHLEVBQUUsQ0FBQztNQUNoQjNQLFNBQVEsQ0FBQyxVQUFVLEVBQUUsU0FBUyxLQUFLLEVBQUUsS0FBSyxFQUFFLFVBQVUsRUFBRTtRQUN0RCxJQUFJLFNBQVMsQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLFVBQVUsQ0FBQyxFQUFFO1VBQ3ZDLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDcEI7T0FDRixDQUFDLENBQUM7TUFDSCxPQUFPLE1BQU0sQ0FBQztLQUNmOztJQUVELGVBQWMsR0FBRyxVQUFVLENBQUM7O0lDZjVCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBcUNBLFNBQVNySCxRQUFNLENBQUMsVUFBVSxFQUFFLFNBQVMsRUFBRTtNQUNyQyxJQUFJLElBQUksR0FBR2lELFNBQU8sQ0FBQyxVQUFVLENBQUMsR0FBR21QLFlBQVcsR0FBRzZFLFdBQVUsQ0FBQztNQUMxRCxPQUFPLElBQUksQ0FBQyxVQUFVLEVBQUUxQyxhQUFZLENBQUMsU0FBUyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDckQ7O0lBRUQsWUFBYyxHQUFHdlUsUUFBTSxDQUFDOztJQzNDeEI7SUFDQSxJQUFJeVIsV0FBUyxHQUFHLGlCQUFpQixDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBbUJsQyxTQUFTLFFBQVEsQ0FBQyxLQUFLLEVBQUU7TUFDdkIsT0FBTyxPQUFPLEtBQUssSUFBSSxRQUFRO1NBQzVCLENBQUN4TyxTQUFPLENBQUMsS0FBSyxDQUFDLElBQUlSLGNBQVksQ0FBQyxLQUFLLENBQUMsSUFBSTVCLFdBQVUsQ0FBQyxLQUFLLENBQUMsSUFBSTRRLFdBQVMsQ0FBQyxDQUFDO0tBQzlFOztJQUVELGNBQWMsR0FBRyxRQUFRLENBQUM7O0lDM0IxQjs7Ozs7OztJQU9BLElBQUksU0FBUyxHQUFHeUMsYUFBWSxDQUFDLFFBQVEsQ0FBQyxDQUFDOztJQUV2QyxjQUFjLEdBQUcsU0FBUyxDQUFDOztJQ1gzQjtJQUNBLElBQUlnRCxlQUFhLEdBQUcsaUJBQWlCO1FBQ2pDN0wsbUJBQWlCLEdBQUcsaUJBQWlCO1FBQ3JDQyx1QkFBcUIsR0FBRyxpQkFBaUI7UUFDekNDLHFCQUFtQixHQUFHLGlCQUFpQjtRQUN2Q0MsY0FBWSxHQUFHSCxtQkFBaUIsR0FBR0MsdUJBQXFCLEdBQUdDLHFCQUFtQjtRQUM5RTRMLFlBQVUsR0FBRyxnQkFBZ0IsQ0FBQzs7O0lBR2xDLElBQUlDLE9BQUssR0FBRyxTQUFTLENBQUM7OztJQUd0QixJQUFJLFlBQVksR0FBRyxNQUFNLENBQUMsR0FBRyxHQUFHQSxPQUFLLEdBQUdGLGVBQWEsSUFBSTFMLGNBQVksR0FBRzJMLFlBQVUsR0FBRyxHQUFHLENBQUMsQ0FBQzs7Ozs7Ozs7O0lBUzFGLFNBQVMsVUFBVSxDQUFDLE1BQU0sRUFBRTtNQUMxQixPQUFPLFlBQVksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7S0FDbEM7O0lBRUQsZUFBYyxHQUFHLFVBQVUsQ0FBQzs7SUN6QjVCO0lBQ0EsSUFBSUQsZUFBYSxHQUFHLGlCQUFpQjtRQUNqQzdMLG1CQUFpQixHQUFHLGlCQUFpQjtRQUNyQ0MsdUJBQXFCLEdBQUcsaUJBQWlCO1FBQ3pDQyxxQkFBbUIsR0FBRyxpQkFBaUI7UUFDdkNDLGNBQVksR0FBR0gsbUJBQWlCLEdBQUdDLHVCQUFxQixHQUFHQyxxQkFBbUI7UUFDOUU0TCxZQUFVLEdBQUcsZ0JBQWdCLENBQUM7OztJQUdsQyxJQUFJLFFBQVEsR0FBRyxHQUFHLEdBQUdELGVBQWEsR0FBRyxHQUFHO1FBQ3BDekwsU0FBTyxHQUFHLEdBQUcsR0FBR0QsY0FBWSxHQUFHLEdBQUc7UUFDbEM2TCxRQUFNLEdBQUcsMEJBQTBCO1FBQ25DQyxZQUFVLEdBQUcsS0FBSyxHQUFHN0wsU0FBTyxHQUFHLEdBQUcsR0FBRzRMLFFBQU0sR0FBRyxHQUFHO1FBQ2pERSxhQUFXLEdBQUcsSUFBSSxHQUFHTCxlQUFhLEdBQUcsR0FBRztRQUN4Q00sWUFBVSxHQUFHLGlDQUFpQztRQUM5Q0MsWUFBVSxHQUFHLG9DQUFvQztRQUNqREwsT0FBSyxHQUFHLFNBQVMsQ0FBQzs7O0lBR3RCLElBQUlNLFVBQVEsR0FBR0osWUFBVSxHQUFHLEdBQUc7UUFDM0JLLFVBQVEsR0FBRyxHQUFHLEdBQUdSLFlBQVUsR0FBRyxJQUFJO1FBQ2xDUyxXQUFTLEdBQUcsS0FBSyxHQUFHUixPQUFLLEdBQUcsS0FBSyxHQUFHLENBQUNHLGFBQVcsRUFBRUMsWUFBVSxFQUFFQyxZQUFVLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsR0FBRyxHQUFHRSxVQUFRLEdBQUdELFVBQVEsR0FBRyxJQUFJO1FBQ3RIRyxPQUFLLEdBQUdGLFVBQVEsR0FBR0QsVUFBUSxHQUFHRSxXQUFTO1FBQ3ZDLFFBQVEsR0FBRyxLQUFLLEdBQUcsQ0FBQ0wsYUFBVyxHQUFHOUwsU0FBTyxHQUFHLEdBQUcsRUFBRUEsU0FBTyxFQUFFK0wsWUFBVSxFQUFFQyxZQUFVLEVBQUUsUUFBUSxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEdBQUcsQ0FBQzs7O0lBR2hILElBQUksU0FBUyxHQUFHLE1BQU0sQ0FBQ0osUUFBTSxHQUFHLEtBQUssR0FBR0EsUUFBTSxHQUFHLElBQUksR0FBRyxRQUFRLEdBQUdRLE9BQUssRUFBRSxHQUFHLENBQUMsQ0FBQzs7Ozs7Ozs7O0lBUy9FLFNBQVMsV0FBVyxDQUFDLE1BQU0sRUFBRTtNQUMzQixJQUFJLE1BQU0sR0FBRyxTQUFTLENBQUMsU0FBUyxHQUFHLENBQUMsQ0FBQztNQUNyQyxPQUFPLFNBQVMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUU7UUFDN0IsRUFBRSxNQUFNLENBQUM7T0FDVjtNQUNELE9BQU8sTUFBTSxDQUFDO0tBQ2Y7O0lBRUQsZ0JBQWMsR0FBRyxXQUFXLENBQUM7O0lDdkM3Qjs7Ozs7OztJQU9BLFNBQVMsVUFBVSxDQUFDLE1BQU0sRUFBRTtNQUMxQixPQUFPQyxXQUFVLENBQUMsTUFBTSxDQUFDO1VBQ3JCQyxZQUFXLENBQUMsTUFBTSxDQUFDO1VBQ25CQyxVQUFTLENBQUMsTUFBTSxDQUFDLENBQUM7S0FDdkI7O0lBRUQsZUFBYyxHQUFHLFVBQVUsQ0FBQzs7SUNYNUI7SUFDQSxJQUFJM0csUUFBTSxHQUFHLGNBQWM7UUFDdkJHLFFBQU0sR0FBRyxjQUFjLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBdUI1QixTQUFTLElBQUksQ0FBQyxVQUFVLEVBQUU7TUFDeEIsSUFBSSxVQUFVLElBQUksSUFBSSxFQUFFO1FBQ3RCLE9BQU8sQ0FBQyxDQUFDO09BQ1Y7TUFDRCxJQUFJblAsYUFBVyxDQUFDLFVBQVUsQ0FBQyxFQUFFO1FBQzNCLE9BQU80VixVQUFRLENBQUMsVUFBVSxDQUFDLEdBQUdDLFdBQVUsQ0FBQyxVQUFVLENBQUMsR0FBRyxVQUFVLENBQUMsTUFBTSxDQUFDO09BQzFFO01BQ0QsSUFBSSxHQUFHLEdBQUdyRixPQUFNLENBQUMsVUFBVSxDQUFDLENBQUM7TUFDN0IsSUFBSSxHQUFHLElBQUl4QixRQUFNLElBQUksR0FBRyxJQUFJRyxRQUFNLEVBQUU7UUFDbEMsT0FBTyxVQUFVLENBQUMsSUFBSSxDQUFDO09BQ3hCO01BQ0QsT0FBT3hLLFNBQVEsQ0FBQyxVQUFVLENBQUMsQ0FBQyxNQUFNLENBQUM7S0FDcEM7O0lBRUQsVUFBYyxHQUFHLElBQUksQ0FBQzs7SUMxQ3RCOzs7Ozs7OztJQVFBLFNBQVMsT0FBTyxDQUFDLFVBQVUsRUFBRSxRQUFRLEVBQUU7TUFDckMsSUFBSSxLQUFLLEdBQUcsQ0FBQyxDQUFDO1VBQ1YsTUFBTSxHQUFHM0UsYUFBVyxDQUFDLFVBQVUsQ0FBQyxHQUFHLEtBQUssQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLEdBQUcsRUFBRSxDQUFDOztNQUVyRWdGLFNBQVEsQ0FBQyxVQUFVLEVBQUUsU0FBUyxLQUFLLEVBQUUsR0FBRyxFQUFFLFVBQVUsRUFBRTtRQUNwRCxNQUFNLENBQUMsRUFBRSxLQUFLLENBQUMsR0FBRyxRQUFRLENBQUMsS0FBSyxFQUFFLEdBQUcsRUFBRSxVQUFVLENBQUMsQ0FBQztPQUNwRCxDQUFDLENBQUM7TUFDSCxPQUFPLE1BQU0sQ0FBQztLQUNmOztJQUVELFlBQWMsR0FBRyxPQUFPLENBQUM7O0lDaEJ6Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBMENBLFNBQVMsR0FBRyxDQUFDLFVBQVUsRUFBRSxRQUFRLEVBQUU7TUFDakMsSUFBSSxJQUFJLEdBQUdwRSxTQUFPLENBQUMsVUFBVSxDQUFDLEdBQUcrSCxTQUFRLEdBQUdtTixRQUFPLENBQUM7TUFDcEQsT0FBTyxJQUFJLENBQUMsVUFBVSxFQUFFNUQsYUFBWSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ3BEOztJQUVELFNBQWMsR0FBRyxHQUFHLENBQUM7O0lDcERyQjs7Ozs7Ozs7O0lBU0EsU0FBUyxTQUFTLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxHQUFHLEVBQUU7TUFDcEMsSUFBSSxLQUFLLEdBQUcsQ0FBQyxDQUFDO1VBQ1YsTUFBTSxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUM7O01BRTFCLElBQUksS0FBSyxHQUFHLENBQUMsRUFBRTtRQUNiLEtBQUssR0FBRyxDQUFDLEtBQUssR0FBRyxNQUFNLEdBQUcsQ0FBQyxJQUFJLE1BQU0sR0FBRyxLQUFLLENBQUMsQ0FBQztPQUNoRDtNQUNELEdBQUcsR0FBRyxHQUFHLEdBQUcsTUFBTSxHQUFHLE1BQU0sR0FBRyxHQUFHLENBQUM7TUFDbEMsSUFBSSxHQUFHLEdBQUcsQ0FBQyxFQUFFO1FBQ1gsR0FBRyxJQUFJLE1BQU0sQ0FBQztPQUNmO01BQ0QsTUFBTSxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxHQUFHLEtBQUssTUFBTSxDQUFDLENBQUMsQ0FBQztNQUNqRCxLQUFLLE1BQU0sQ0FBQyxDQUFDOztNQUViLElBQUksTUFBTSxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQztNQUMzQixPQUFPLEVBQUUsS0FBSyxHQUFHLE1BQU0sRUFBRTtRQUN2QixNQUFNLENBQUMsS0FBSyxDQUFDLEdBQUcsS0FBSyxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUMsQ0FBQztPQUN0QztNQUNELE9BQU8sTUFBTSxDQUFDO0tBQ2Y7O0lBRUQsY0FBYyxHQUFHLFNBQVMsQ0FBQzs7SUM1QjNCOzs7Ozs7Ozs7SUFTQSxTQUFTLFNBQVMsQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRTtNQUNwQyxJQUFJLE1BQU0sR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDO01BQzFCLEdBQUcsR0FBRyxHQUFHLEtBQUssU0FBUyxHQUFHLE1BQU0sR0FBRyxHQUFHLENBQUM7TUFDdkMsT0FBTyxDQUFDLENBQUMsS0FBSyxJQUFJLEdBQUcsSUFBSSxNQUFNLElBQUksS0FBSyxHQUFHNkQsVUFBUyxDQUFDLEtBQUssRUFBRSxLQUFLLEVBQUUsR0FBRyxDQUFDLENBQUM7S0FDekU7O0lBRUQsY0FBYyxHQUFHLFNBQVMsQ0FBQzs7SUNqQjNCOzs7Ozs7O0lBT0EsU0FBUyxZQUFZLENBQUMsTUFBTSxFQUFFO01BQzVCLE9BQU8sTUFBTSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQztLQUN6Qjs7SUFFRCxpQkFBYyxHQUFHLFlBQVksQ0FBQzs7SUNYOUI7SUFDQSxJQUFJbEIsZUFBYSxHQUFHLGlCQUFpQjtRQUNqQzdMLG1CQUFpQixHQUFHLGlCQUFpQjtRQUNyQ0MsdUJBQXFCLEdBQUcsaUJBQWlCO1FBQ3pDQyxxQkFBbUIsR0FBRyxpQkFBaUI7UUFDdkNDLGNBQVksR0FBR0gsbUJBQWlCLEdBQUdDLHVCQUFxQixHQUFHQyxxQkFBbUI7UUFDOUU0TCxZQUFVLEdBQUcsZ0JBQWdCLENBQUM7OztJQUdsQyxJQUFJa0IsVUFBUSxHQUFHLEdBQUcsR0FBR25CLGVBQWEsR0FBRyxHQUFHO1FBQ3BDekwsU0FBTyxHQUFHLEdBQUcsR0FBR0QsY0FBWSxHQUFHLEdBQUc7UUFDbEM2TCxRQUFNLEdBQUcsMEJBQTBCO1FBQ25DQyxZQUFVLEdBQUcsS0FBSyxHQUFHN0wsU0FBTyxHQUFHLEdBQUcsR0FBRzRMLFFBQU0sR0FBRyxHQUFHO1FBQ2pERSxhQUFXLEdBQUcsSUFBSSxHQUFHTCxlQUFhLEdBQUcsR0FBRztRQUN4Q00sWUFBVSxHQUFHLGlDQUFpQztRQUM5Q0MsWUFBVSxHQUFHLG9DQUFvQztRQUNqREwsT0FBSyxHQUFHLFNBQVMsQ0FBQzs7O0lBR3RCLElBQUlNLFVBQVEsR0FBR0osWUFBVSxHQUFHLEdBQUc7UUFDM0JLLFVBQVEsR0FBRyxHQUFHLEdBQUdSLFlBQVUsR0FBRyxJQUFJO1FBQ2xDUyxXQUFTLEdBQUcsS0FBSyxHQUFHUixPQUFLLEdBQUcsS0FBSyxHQUFHLENBQUNHLGFBQVcsRUFBRUMsWUFBVSxFQUFFQyxZQUFVLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsR0FBRyxHQUFHRSxVQUFRLEdBQUdELFVBQVEsR0FBRyxJQUFJO1FBQ3RIRyxPQUFLLEdBQUdGLFVBQVEsR0FBR0QsVUFBUSxHQUFHRSxXQUFTO1FBQ3ZDVSxVQUFRLEdBQUcsS0FBSyxHQUFHLENBQUNmLGFBQVcsR0FBRzlMLFNBQU8sR0FBRyxHQUFHLEVBQUVBLFNBQU8sRUFBRStMLFlBQVUsRUFBRUMsWUFBVSxFQUFFWSxVQUFRLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsR0FBRyxDQUFDOzs7SUFHaEgsSUFBSUUsV0FBUyxHQUFHLE1BQU0sQ0FBQ2xCLFFBQU0sR0FBRyxLQUFLLEdBQUdBLFFBQU0sR0FBRyxJQUFJLEdBQUdpQixVQUFRLEdBQUdULE9BQUssRUFBRSxHQUFHLENBQUMsQ0FBQzs7Ozs7Ozs7O0lBUy9FLFNBQVMsY0FBYyxDQUFDLE1BQU0sRUFBRTtNQUM5QixPQUFPLE1BQU0sQ0FBQyxLQUFLLENBQUNVLFdBQVMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztLQUN0Qzs7SUFFRCxtQkFBYyxHQUFHLGNBQWMsQ0FBQzs7SUNuQ2hDOzs7Ozs7O0lBT0EsU0FBUyxhQUFhLENBQUMsTUFBTSxFQUFFO01BQzdCLE9BQU9ULFdBQVUsQ0FBQyxNQUFNLENBQUM7VUFDckJVLGVBQWMsQ0FBQyxNQUFNLENBQUM7VUFDdEJDLGFBQVksQ0FBQyxNQUFNLENBQUMsQ0FBQztLQUMxQjs7SUFFRCxrQkFBYyxHQUFHLGFBQWEsQ0FBQzs7SUNaL0I7Ozs7Ozs7SUFPQSxTQUFTLGVBQWUsQ0FBQyxVQUFVLEVBQUU7TUFDbkMsT0FBTyxTQUFTLE1BQU0sRUFBRTtRQUN0QixNQUFNLEdBQUd0TixVQUFRLENBQUMsTUFBTSxDQUFDLENBQUM7O1FBRTFCLElBQUksVUFBVSxHQUFHMk0sV0FBVSxDQUFDLE1BQU0sQ0FBQztZQUMvQlksY0FBYSxDQUFDLE1BQU0sQ0FBQztZQUNyQixTQUFTLENBQUM7O1FBRWQsSUFBSSxHQUFHLEdBQUcsVUFBVTtZQUNoQixVQUFVLENBQUMsQ0FBQyxDQUFDO1lBQ2IsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQzs7UUFFckIsSUFBSSxRQUFRLEdBQUcsVUFBVTtZQUNyQkMsVUFBUyxDQUFDLFVBQVUsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDO1lBQ2pDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7O1FBRXBCLE9BQU8sR0FBRyxDQUFDLFVBQVUsQ0FBQyxFQUFFLEdBQUcsUUFBUSxDQUFDO09BQ3JDLENBQUM7S0FDSDs7SUFFRCxvQkFBYyxHQUFHLGVBQWUsQ0FBQzs7SUM5QmpDOzs7Ozs7Ozs7Ozs7Ozs7OztJQWlCQSxJQUFJLFVBQVUsR0FBR0MsZ0JBQWUsQ0FBQyxhQUFhLENBQUMsQ0FBQzs7SUFFaEQsZ0JBQWMsR0FBRyxVQUFVLENBQUM7O0lDbEI1Qjs7Ozs7Ozs7Ozs7Ozs7O0lBZUEsU0FBUyxVQUFVLENBQUMsTUFBTSxFQUFFO01BQzFCLE9BQU9DLFlBQVUsQ0FBQzFOLFVBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDO0tBQ25EOztJQUVELGdCQUFjLEdBQUcsVUFBVSxDQUFDOztJQ25CNUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBb0JBLElBQUksU0FBUyxHQUFHYyxpQkFBZ0IsQ0FBQyxTQUFTLE1BQU0sRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFO01BQzdELElBQUksR0FBRyxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7TUFDMUIsT0FBTyxNQUFNLElBQUksS0FBSyxHQUFHNk0sWUFBVSxDQUFDLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDO0tBQ25ELENBQUMsQ0FBQzs7SUFFSCxlQUFjLEdBQUcsU0FBUyxDQUFDOztJQzFCM0I7SUFDQSxJQUFJLE9BQU8sR0FBR25HLFFBQU8sSUFBSSxJQUFJQSxRQUFPLENBQUM7O0lBRXJDLFlBQWMsR0FBRyxPQUFPLENBQUM7O0lDRnpCOzs7Ozs7OztJQVFBLElBQUksV0FBVyxHQUFHLENBQUNvRyxRQUFPLEdBQUdsWCxVQUFRLEdBQUcsU0FBUyxJQUFJLEVBQUUsSUFBSSxFQUFFO01BQzNEa1gsUUFBTyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7TUFDeEIsT0FBTyxJQUFJLENBQUM7S0FDYixDQUFDOztJQUVGLGdCQUFjLEdBQUcsV0FBVyxDQUFDOztJQ2I3Qjs7Ozs7Ozs7SUFRQSxTQUFTLFVBQVUsQ0FBQyxJQUFJLEVBQUU7TUFDeEIsT0FBTyxXQUFXOzs7O1FBSWhCLElBQUksSUFBSSxHQUFHLFNBQVMsQ0FBQztRQUNyQixRQUFRLElBQUksQ0FBQyxNQUFNO1VBQ2pCLEtBQUssQ0FBQyxFQUFFLE9BQU8sSUFBSSxJQUFJLENBQUM7VUFDeEIsS0FBSyxDQUFDLEVBQUUsT0FBTyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztVQUNqQyxLQUFLLENBQUMsRUFBRSxPQUFPLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztVQUMxQyxLQUFLLENBQUMsRUFBRSxPQUFPLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7VUFDbkQsS0FBSyxDQUFDLEVBQUUsT0FBTyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztVQUM1RCxLQUFLLENBQUMsRUFBRSxPQUFPLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztVQUNyRSxLQUFLLENBQUMsRUFBRSxPQUFPLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7VUFDOUUsS0FBSyxDQUFDLEVBQUUsT0FBTyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUN4RjtRQUNELElBQUksV0FBVyxHQUFHaFQsV0FBVSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUM7WUFDeEMsTUFBTSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsV0FBVyxFQUFFLElBQUksQ0FB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
