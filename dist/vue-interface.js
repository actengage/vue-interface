(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('moment'), require('axios')) :
    typeof define === 'function' && define.amd ? define(['exports', 'moment', 'axios'], factory) :
    (factory((global.VueInterface = {}),global.moment,global.axios));
}(this, (function (exports,moment,axios) { 'use strict';

    moment = moment && moment.hasOwnProperty('default') ? moment['default'] : moment;
    axios = axios && axios.hasOwnProperty('default') ? axios['default'] : axios;

    function DateFilter (value, format) {
      if (value) {
        return moment(String(value)).format(format);
      }

      return '';
    }

    function MomentFilter (value, format) {
      return value ? moment(String(value)) : null;
    }

    function index (Vue, options) {
      Vue.filter('date', DateFilter);
      Vue.filter('moment', MomentFilter);
    }



    var filters = /*#__PURE__*/Object.freeze({
        DateFilter: index,
        MomentFilter: index
    });

    /**
     * A faster alternative to `Function#apply`, this function invokes `func`
     * with the `this` binding of `thisArg` and the arguments of `args`.
     *
     * @private
     * @param {Function} func The function to invoke.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} args The arguments to invoke `func` with.
     * @returns {*} Returns the result of `func`.
     */
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0: return func.call(thisArg);
        case 1: return func.call(thisArg, args[0]);
        case 2: return func.call(thisArg, args[0], args[1]);
        case 3: return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }

    /**
     * This method returns the first argument it receives.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'a': 1 };
     *
     * console.log(_.identity(object) === object);
     * // => true
     */
    function identity(value) {
      return value;
    }

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeMax = Math.max;

    /**
     * A specialized version of `baseRest` which transforms the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @param {Function} transform The rest array transform.
     * @returns {Function} Returns the new function.
     */
    function overRest(func, start, transform) {
      start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
      return function() {
        var args = arguments,
            index = -1,
            length = nativeMax(args.length - start, 0),
            array = Array(length);

        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new constant function.
     * @example
     *
     * var objects = _.times(2, _.constant({ 'a': 1 }));
     *
     * console.log(objects);
     * // => [{ 'a': 1 }, { 'a': 1 }]
     *
     * console.log(objects[0] === objects[1]);
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    var global$1 = typeof global !== "undefined" ? global :
                typeof self !== "undefined" ? self :
                typeof window !== "undefined" ? window : {}

    /** Detect free variable `global` from Node.js. */
    var freeGlobal = typeof global$1 == 'object' && global$1 && global$1.Object === Object && global$1;

    /** Detect free variable `self`. */
    var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

    /** Used as a reference to the global object. */
    var root = freeGlobal || freeSelf || Function('return this')();

    /** Built-in value references. */
    var Symbol$1 = root.Symbol;

    /** Used for built-in method references. */
    var objectProto = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString = objectProto.toString;

    /** Built-in value references. */
    var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;

    /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag),
          tag = value[symToStringTag];

      try {
        value[symToStringTag] = undefined;
        var unmasked = true;
      } catch (e) {}

      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }

    /** Used for built-in method references. */
    var objectProto$1 = Object.prototype;

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString$1 = objectProto$1.toString;

    /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */
    function objectToString(value) {
      return nativeObjectToString$1.call(value);
    }

    /** `Object#toString` result references. */
    var nullTag = '[object Null]',
        undefinedTag = '[object Undefined]';

    /** Built-in value references. */
    var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;

    /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    function baseGetTag(value) {
      if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
      }
      return (symToStringTag$1 && symToStringTag$1 in Object(value))
        ? getRawTag(value)
        : objectToString(value);
    }

    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == 'object' || type == 'function');
    }

    /** `Object#toString` result references. */
    var asyncTag = '[object AsyncFunction]',
        funcTag = '[object Function]',
        genTag = '[object GeneratorFunction]',
        proxyTag = '[object Proxy]';

    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction$1(value) {
      if (!isObject(value)) {
        return false;
      }
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 9 which returns 'object' for typed arrays and other constructors.
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }

    /** Used to detect overreaching core-js shims. */
    var coreJsData = root['__core-js_shared__'];

    /** Used to detect methods masquerading as native. */
    var maskSrcKey = (function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
      return uid ? ('Symbol(src)_1.' + uid) : '';
    }());

    /**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */
    function isMasked(func) {
      return !!maskSrcKey && (maskSrcKey in func);
    }

    /** Used for built-in method references. */
    var funcProto = Function.prototype;

    /** Used to resolve the decompiled source of functions. */
    var funcToString = funcProto.toString;

    /**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to convert.
     * @returns {string} Returns the source code.
     */
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {}
        try {
          return (func + '');
        } catch (e) {}
      }
      return '';
    }

    /**
     * Used to match `RegExp`
     * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
     */
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

    /** Used to detect host constructors (Safari). */
    var reIsHostCtor = /^\[object .+?Constructor\]$/;

    /** Used for built-in method references. */
    var funcProto$1 = Function.prototype,
        objectProto$2 = Object.prototype;

    /** Used to resolve the decompiled source of functions. */
    var funcToString$1 = funcProto$1.toString;

    /** Used to check objects for own properties. */
    var hasOwnProperty$1 = objectProto$2.hasOwnProperty;

    /** Used to detect if a method is native. */
    var reIsNative = RegExp('^' +
      funcToString$1.call(hasOwnProperty$1).replace(reRegExpChar, '\\$&')
      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
    );

    /**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction$1(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }

    /**
     * Gets the value at `key` of `object`.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */
    function getValue(object, key) {
      return object == null ? undefined : object[key];
    }

    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : undefined;
    }

    var defineProperty = (function() {
      try {
        var func = getNative(Object, 'defineProperty');
        func({}, '', {});
        return func;
      } catch (e) {}
    }());

    /**
     * The base implementation of `setToString` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
    var baseSetToString = !defineProperty ? identity : function(func, string) {
      return defineProperty(func, 'toString', {
        'configurable': true,
        'enumerable': false,
        'value': constant(string),
        'writable': true
      });
    };

    /** Used to detect hot functions by number of calls within a span of milliseconds. */
    var HOT_COUNT = 800,
        HOT_SPAN = 16;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeNow = Date.now;

    /**
     * Creates a function that'll short out and invoke `identity` instead
     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
     * milliseconds.
     *
     * @private
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new shortable function.
     */
    function shortOut(func) {
      var count = 0,
          lastCalled = 0;

      return function() {
        var stamp = nativeNow(),
            remaining = HOT_SPAN - (stamp - lastCalled);

        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(undefined, arguments);
      };
    }

    /**
     * Sets the `toString` method of `func` to return `string`.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
    var setToString = shortOut(baseSetToString);

    /**
     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     */
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + '');
    }

    /**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }

    /**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */
    function eq(value, other) {
      return value === other || (value !== value && other !== other);
    }

    /**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }

    /** Used for built-in method references. */
    var arrayProto = Array.prototype;

    /** Built-in value references. */
    var splice = arrayProto.splice;

    /**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function listCacheDelete(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }

    /**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function listCacheGet(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      return index < 0 ? undefined : data[index][1];
    }

    /**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }

    /**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */
    function listCacheSet(key, value) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }

    /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function ListCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    // Add methods to `ListCache`.
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype['delete'] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;

    /**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */
    function stackClear() {
      this.__data__ = new ListCache;
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function stackDelete(key) {
      var data = this.__data__,
          result = data['delete'](key);

      this.size = data.size;
      return result;
    }

    /**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function stackGet(key) {
      return this.__data__.get(key);
    }

    /**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function stackHas(key) {
      return this.__data__.has(key);
    }

    /* Built-in method references that are verified to be native. */
    var Map$1 = getNative(root, 'Map');

    /* Built-in method references that are verified to be native. */
    var nativeCreate = getNative(Object, 'create');

    /**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }

    /** Used to stand-in for `undefined` hash values. */
    var HASH_UNDEFINED = '__lodash_hash_undefined__';

    /** Used for built-in method references. */
    var objectProto$3 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$2 = objectProto$3.hasOwnProperty;

    /**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
      }
      return hasOwnProperty$2.call(data, key) ? data[key] : undefined;
    }

    /** Used for built-in method references. */
    var objectProto$4 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$3 = objectProto$4.hasOwnProperty;

    /**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? (data[key] !== undefined) : hasOwnProperty$3.call(data, key);
    }

    /** Used to stand-in for `undefined` hash values. */
    var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

    /**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED$1 : value;
      return this;
    }

    /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Hash(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    // Add methods to `Hash`.
    Hash.prototype.clear = hashClear;
    Hash.prototype['delete'] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;

    /**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        'hash': new Hash,
        'map': new (Map$1 || ListCache),
        'string': new Hash
      };
    }

    /**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */
    function isKeyable(value) {
      var type = typeof value;
      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
        ? (value !== '__proto__')
        : (value === null);
    }

    /**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key)
        ? data[typeof key == 'string' ? 'string' : 'hash']
        : data.map;
    }

    /**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function mapCacheDelete(key) {
      var result = getMapData(this, key)['delete'](key);
      this.size -= result ? 1 : 0;
      return result;
    }

    /**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }

    /**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }

    /**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */
    function mapCacheSet(key, value) {
      var data = getMapData(this, key),
          size = data.size;

      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }

    /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function MapCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    // Add methods to `MapCache`.
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype['delete'] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;

    /** Used as the size to enable large array optimizations. */
    var LARGE_ARRAY_SIZE = 200;

    /**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map$1 || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }

    /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }

    // Add methods to `Stack`.
    Stack.prototype.clear = stackClear;
    Stack.prototype['delete'] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;

    /**
     * The base implementation of `assignValue` and `assignMergeValue` without
     * value checks.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function baseAssignValue(object, key, value) {
      if (key == '__proto__' && defineProperty) {
        defineProperty(object, key, {
          'configurable': true,
          'enumerable': true,
          'value': value,
          'writable': true
        });
      } else {
        object[key] = value;
      }
    }

    /**
     * This function is like `assignValue` except that it doesn't assign
     * `undefined` values.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignMergeValue(object, key, value) {
      if ((value !== undefined && !eq(object[key], value)) ||
          (value === undefined && !(key in object))) {
        baseAssignValue(object, key, value);
      }
    }

    /**
     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1,
            iterable = Object(object),
            props = keysFunc(object),
            length = props.length;

        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }

    /**
     * The base implementation of `baseForOwn` which iterates over `object`
     * properties returned by `keysFunc` and invokes `iteratee` for each property.
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseFor = createBaseFor();

    /** Detect free variable `exports`. */
    var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

    /** Detect free variable `module`. */
    var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

    /** Detect the popular CommonJS extension `module.exports`. */
    var moduleExports = freeModule && freeModule.exports === freeExports;

    /** Built-in value references. */
    var Buffer = moduleExports ? root.Buffer : undefined,
        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

    /**
     * Creates a clone of  `buffer`.
     *
     * @private
     * @param {Buffer} buffer The buffer to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Buffer} Returns the cloned buffer.
     */
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length,
          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

      buffer.copy(result);
      return result;
    }

    /** Built-in value references. */
    var Uint8Array = root.Uint8Array;

    /**
     * Creates a clone of `arrayBuffer`.
     *
     * @private
     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array(result).set(new Uint8Array(arrayBuffer));
      return result;
    }

    /**
     * Creates a clone of `typedArray`.
     *
     * @private
     * @param {Object} typedArray The typed array to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned typed array.
     */
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }

    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function copyArray(source, array) {
      var index = -1,
          length = source.length;

      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }

    /** Built-in value references. */
    var objectCreate = Object.create;

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} proto The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    var baseCreate = (function() {
      function object() {}
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object;
        object.prototype = undefined;
        return result;
      };
    }());

    /**
     * Creates a unary function that invokes `func` with its argument transformed.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {Function} transform The argument transform.
     * @returns {Function} Returns the new function.
     */
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }

    /** Built-in value references. */
    var getPrototype = overArg(Object.getPrototypeOf, Object);

    /** Used for built-in method references. */
    var objectProto$5 = Object.prototype;

    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */
    function isPrototype(value) {
      var Ctor = value && value.constructor,
          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$5;

      return value === proto;
    }

    /**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneObject(object) {
      return (typeof object.constructor == 'function' && !isPrototype(object))
        ? baseCreate(getPrototype(object))
        : {};
    }

    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return value != null && typeof value == 'object';
    }

    /** `Object#toString` result references. */
    var argsTag = '[object Arguments]';

    /**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }

    /** Used for built-in method references. */
    var objectProto$6 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$4 = objectProto$6.hasOwnProperty;

    /** Built-in value references. */
    var propertyIsEnumerable = objectProto$6.propertyIsEnumerable;

    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty$4.call(value, 'callee') &&
        !propertyIsEnumerable.call(value, 'callee');
    };

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
    var isArray = Array.isArray;

    /** Used as references for various `Number` constants. */
    var MAX_SAFE_INTEGER = 9007199254740991;

    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */
    function isLength(value) {
      return typeof value == 'number' &&
        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction$1(value);
    }

    /**
     * This method is like `_.isArrayLike` except that it also checks if `value`
     * is an object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array-like object,
     *  else `false`.
     * @example
     *
     * _.isArrayLikeObject([1, 2, 3]);
     * // => true
     *
     * _.isArrayLikeObject(document.body.children);
     * // => true
     *
     * _.isArrayLikeObject('abc');
     * // => false
     *
     * _.isArrayLikeObject(_.noop);
     * // => false
     */
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }

    /**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */
    function stubFalse() {
      return false;
    }

    /** Detect free variable `exports`. */
    var freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;

    /** Detect free variable `module`. */
    var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;

    /** Detect the popular CommonJS extension `module.exports`. */
    var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;

    /** Built-in value references. */
    var Buffer$1 = moduleExports$1 ? root.Buffer : undefined;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : undefined;

    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */
    var isBuffer = nativeIsBuffer || stubFalse;

    /** `Object#toString` result references. */
    var objectTag = '[object Object]';

    /** Used for built-in method references. */
    var funcProto$2 = Function.prototype,
        objectProto$7 = Object.prototype;

    /** Used to resolve the decompiled source of functions. */
    var funcToString$2 = funcProto$2.toString;

    /** Used to check objects for own properties. */
    var hasOwnProperty$5 = objectProto$7.hasOwnProperty;

    /** Used to infer the `Object` constructor. */
    var objectCtorString = funcToString$2.call(Object);

    /**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * @static
     * @memberOf _
     * @since 0.8.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty$5.call(proto, 'constructor') && proto.constructor;
      return typeof Ctor == 'function' && Ctor instanceof Ctor &&
        funcToString$2.call(Ctor) == objectCtorString;
    }

    /** `Object#toString` result references. */
    var argsTag$1 = '[object Arguments]',
        arrayTag = '[object Array]',
        boolTag = '[object Boolean]',
        dateTag = '[object Date]',
        errorTag = '[object Error]',
        funcTag$1 = '[object Function]',
        mapTag = '[object Map]',
        numberTag = '[object Number]',
        objectTag$1 = '[object Object]',
        regexpTag = '[object RegExp]',
        setTag = '[object Set]',
        stringTag = '[object String]',
        weakMapTag = '[object WeakMap]';

    var arrayBufferTag = '[object ArrayBuffer]',
        dataViewTag = '[object DataView]',
        float32Tag = '[object Float32Array]',
        float64Tag = '[object Float64Array]',
        int8Tag = '[object Int8Array]',
        int16Tag = '[object Int16Array]',
        int32Tag = '[object Int32Array]',
        uint8Tag = '[object Uint8Array]',
        uint8ClampedTag = '[object Uint8ClampedArray]',
        uint16Tag = '[object Uint16Array]',
        uint32Tag = '[object Uint32Array]';

    /** Used to identify `toStringTag` values of typed arrays. */
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
    typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
    typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
    typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
    typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag$1] = typedArrayTags[arrayTag] =
    typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
    typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
    typedArrayTags[errorTag] = typedArrayTags[funcTag$1] =
    typedArrayTags[mapTag] = typedArrayTags[numberTag] =
    typedArrayTags[objectTag$1] = typedArrayTags[regexpTag] =
    typedArrayTags[setTag] = typedArrayTags[stringTag] =
    typedArrayTags[weakMapTag] = false;

    /**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */
    function baseIsTypedArray(value) {
      return isObjectLike(value) &&
        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }

    /**
     * The base implementation of `_.unary` without support for storing metadata.
     *
     * @private
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     */
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }

    /** Detect free variable `exports`. */
    var freeExports$2 = typeof exports == 'object' && exports && !exports.nodeType && exports;

    /** Detect free variable `module`. */
    var freeModule$2 = freeExports$2 && typeof module == 'object' && module && !module.nodeType && module;

    /** Detect the popular CommonJS extension `module.exports`. */
    var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;

    /** Detect free variable `process` from Node.js. */
    var freeProcess = moduleExports$2 && freeGlobal.process;

    /** Used to access faster Node.js helpers. */
    var nodeUtil = (function() {
      try {
        return freeProcess && freeProcess.binding && freeProcess.binding('util');
      } catch (e) {}
    }());

    /* Node.js helper references. */
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

    /**
     * Gets the value at `key`, unless `key` is "__proto__".
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */
    function safeGet(object, key) {
      return key == '__proto__'
        ? undefined
        : object[key];
    }

    /** Used for built-in method references. */
    var objectProto$8 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$6 = objectProto$8.hasOwnProperty;

    /**
     * Assigns `value` to `key` of `object` if the existing value is not equivalent
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty$6.call(object, key) && eq(objValue, value)) ||
          (value === undefined && !(key in object))) {
        baseAssignValue(object, key, value);
      }
    }

    /**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property identifiers to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Function} [customizer] The function to customize copied values.
     * @returns {Object} Returns `object`.
     */
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});

      var index = -1,
          length = props.length;

      while (++index < length) {
        var key = props[index];

        var newValue = customizer
          ? customizer(object[key], source[key], key, object, source)
          : undefined;

        if (newValue === undefined) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }

    /**
     * The base implementation of `_.times` without support for iteratee shorthands
     * or max array length checks.
     *
     * @private
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     */
    function baseTimes(n, iteratee) {
      var index = -1,
          result = Array(n);

      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }

    /** Used as references for various `Number` constants. */
    var MAX_SAFE_INTEGER$1 = 9007199254740991;

    /** Used to detect unsigned integer values. */
    var reIsUint = /^(?:0|[1-9]\d*)$/;

    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER$1 : length;

      return !!length &&
        (type == 'number' ||
          (type != 'symbol' && reIsUint.test(value))) &&
            (value > -1 && value % 1 == 0 && value < length);
    }

    /** Used for built-in method references. */
    var objectProto$9 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$7 = objectProto$9.hasOwnProperty;

    /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value),
          isArg = !isArr && isArguments(value),
          isBuff = !isArr && !isArg && isBuffer(value),
          isType = !isArr && !isArg && !isBuff && isTypedArray(value),
          skipIndexes = isArr || isArg || isBuff || isType,
          result = skipIndexes ? baseTimes(value.length, String) : [],
          length = result.length;

      for (var key in value) {
        if ((inherited || hasOwnProperty$7.call(value, key)) &&
            !(skipIndexes && (
               // Safari 9 has enumerable `arguments.length` in strict mode.
               key == 'length' ||
               // Node.js 0.10 has enumerable non-index properties on buffers.
               (isBuff && (key == 'offset' || key == 'parent')) ||
               // PhantomJS 2 has enumerable non-index properties on typed arrays.
               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
               // Skip index properties.
               isIndex(key, length)
            ))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * This function is like
     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * except that it includes inherited enumerable properties.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }

    /** Used for built-in method references. */
    var objectProto$10 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$8 = objectProto$10.hasOwnProperty;

    /**
     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object),
          result = [];

      for (var key in object) {
        if (!(key == 'constructor' && (isProto || !hasOwnProperty$8.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */
    function keysIn$1(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }

    /**
     * Converts `value` to a plain object flattening inherited enumerable string
     * keyed properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */
    function toPlainObject(value) {
      return copyObject(value, keysIn$1(value));
    }

    /**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key),
          srcValue = safeGet(source, key),
          stacked = stack.get(srcValue);

      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer
        ? customizer(objValue, srcValue, (key + ''), object, source, stack)
        : undefined;

      var isCommon = newValue === undefined;

      if (isCommon) {
        var isArr = isArray(srcValue),
            isBuff = !isArr && isBuffer(srcValue),
            isTyped = !isArr && !isBuff && isTypedArray(srcValue);

        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          }
          else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          }
          else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          }
          else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          }
          else {
            newValue = [];
          }
        }
        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          }
          else if (!isObject(objValue) || (srcIndex && isFunction$1(objValue))) {
            newValue = initCloneObject(srcValue);
          }
        }
        else {
          isCommon = false;
        }
      }
      if (isCommon) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack['delete'](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }

    /**
     * The base implementation of `_.merge` without support for multiple sources.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        if (isObject(srcValue)) {
          stack || (stack = new Stack);
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        }
        else {
          var newValue = customizer
            ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
            : undefined;

          if (newValue === undefined) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn$1);
    }

    /**
     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
     * objects into destination objects that are passed thru.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to merge.
     * @param {Object} object The parent object of `objValue`.
     * @param {Object} source The parent object of `srcValue`.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     * @returns {*} Returns the value to assign.
     */
    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
      if (isObject(objValue) && isObject(srcValue)) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        stack.set(srcValue, objValue);
        baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);
        stack['delete'](srcValue);
      }
      return objValue;
    }

    /**
     * Checks if the given arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
     *  else `false`.
     */
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == 'number'
            ? (isArrayLike(object) && isIndex(index, object.length))
            : (type == 'string' && index in object)
          ) {
        return eq(object[index], value);
      }
      return false;
    }

    /**
     * Creates a function like `_.assign`.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1,
            length = sources.length,
            customizer = length > 1 ? sources[length - 1] : undefined,
            guard = length > 2 ? sources[2] : undefined;

        customizer = (assigner.length > 3 && typeof customizer == 'function')
          ? (length--, customizer)
          : undefined;

        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? undefined : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }

    /**
     * This method is like `_.merge` except that it accepts `customizer` which
     * is invoked to produce the merged values of the destination and source
     * properties. If `customizer` returns `undefined`, merging is handled by the
     * method instead. The `customizer` is invoked with six arguments:
     * (objValue, srcValue, key, object, source, stack).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   if (_.isArray(objValue)) {
     *     return objValue.concat(srcValue);
     *   }
     * }
     *
     * var object = { 'a': [1], 'b': [2] };
     * var other = { 'a': [3], 'b': [4] };
     *
     * _.mergeWith(object, other, customizer);
     * // => { 'a': [1, 3], 'b': [2, 4] }
     */
    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
      baseMerge(object, source, srcIndex, customizer);
    });

    /**
     * This method is like `_.defaults` except that it recursively assigns
     * default properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaults
     * @example
     *
     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
     * // => { 'a': { 'b': 2, 'c': 3 } }
     */
    var defaultsDeep = baseRest(function(args) {
      args.push(undefined, customDefaultsMerge);
      return apply(mergeWith, undefined, args);
    });

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */
    function isUndefined(value) {
      return value === undefined;
    }

    /** `Object#toString` result references. */
    var boolTag$1 = '[object Boolean]';

    /**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false ||
        (isObjectLike(value) && baseGetTag(value) == boolTag$1);
    }

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeKeys = overArg(Object.keys, Object);

    /** Used for built-in method references. */
    var objectProto$11 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$9 = objectProto$11.hasOwnProperty;

    /**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty$9.call(object, key) && key != 'constructor') {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }

    /**
     * The base implementation of `_.forOwn` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }

    /** Used to stand-in for `undefined` hash values. */
    var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

    /**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED$2);
      return this;
    }

    /**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */
    function setCacheHas(value) {
      return this.__data__.has(value);
    }

    /**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */
    function SetCache(values) {
      var index = -1,
          length = values == null ? 0 : values.length;

      this.__data__ = new MapCache;
      while (++index < length) {
        this.add(values[index]);
      }
    }

    // Add methods to `SetCache`.
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;

    /**
     * A specialized version of `_.some` for arrays without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function arraySome(array, predicate) {
      var index = -1,
          length = array == null ? 0 : array.length;

      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }

    /**
     * Checks if a `cache` value for `key` exists.
     *
     * @private
     * @param {Object} cache The cache to query.
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function cacheHas(cache, key) {
      return cache.has(key);
    }

    /** Used to compose bitmasks for value comparisons. */
    var COMPARE_PARTIAL_FLAG = 1,
        COMPARE_UNORDERED_FLAG = 2;

    /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
          arrLength = array.length,
          othLength = other.length;

      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(array);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var index = -1,
          result = true,
          seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

      stack.set(array, other);
      stack.set(other, array);

      // Ignore non-index properties.
      while (++index < arrLength) {
        var arrValue = array[index],
            othValue = other[index];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, arrValue, index, other, array, stack)
            : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== undefined) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        // Recursively compare arrays (susceptible to call stack limits).
        if (seen) {
          if (!arraySome(other, function(othValue, othIndex) {
                if (!cacheHas(seen, othIndex) &&
                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
            result = false;
            break;
          }
        } else if (!(
              arrValue === othValue ||
                equalFunc(arrValue, othValue, bitmask, customizer, stack)
            )) {
          result = false;
          break;
        }
      }
      stack['delete'](array);
      stack['delete'](other);
      return result;
    }

    /**
     * Converts `map` to its key-value pairs.
     *
     * @private
     * @param {Object} map The map to convert.
     * @returns {Array} Returns the key-value pairs.
     */
    function mapToArray(map) {
      var index = -1,
          result = Array(map.size);

      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }

    /**
     * Converts `set` to an array of its values.
     *
     * @private
     * @param {Object} set The set to convert.
     * @returns {Array} Returns the values.
     */
    function setToArray(set) {
      var index = -1,
          result = Array(set.size);

      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }

    /** Used to compose bitmasks for value comparisons. */
    var COMPARE_PARTIAL_FLAG$1 = 1,
        COMPARE_UNORDERED_FLAG$1 = 2;

    /** `Object#toString` result references. */
    var boolTag$2 = '[object Boolean]',
        dateTag$1 = '[object Date]',
        errorTag$1 = '[object Error]',
        mapTag$1 = '[object Map]',
        numberTag$1 = '[object Number]',
        regexpTag$1 = '[object RegExp]',
        setTag$1 = '[object Set]',
        stringTag$1 = '[object String]',
        symbolTag = '[object Symbol]';

    var arrayBufferTag$1 = '[object ArrayBuffer]',
        dataViewTag$1 = '[object DataView]';

    /** Used to convert symbols to primitives and strings. */
    var symbolProto = Symbol$1 ? Symbol$1.prototype : undefined,
        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

    /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag$1:
          if ((object.byteLength != other.byteLength) ||
              (object.byteOffset != other.byteOffset)) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;

        case arrayBufferTag$1:
          if ((object.byteLength != other.byteLength) ||
              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
            return false;
          }
          return true;

        case boolTag$2:
        case dateTag$1:
        case numberTag$1:
          // Coerce booleans to `1` or `0` and dates to milliseconds.
          // Invalid dates are coerced to `NaN`.
          return eq(+object, +other);

        case errorTag$1:
          return object.name == other.name && object.message == other.message;

        case regexpTag$1:
        case stringTag$1:
          // Coerce regexes to strings and treat strings, primitives and objects,
          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
          // for more details.
          return object == (other + '');

        case mapTag$1:
          var convert = mapToArray;

        case setTag$1:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1;
          convert || (convert = setToArray);

          if (object.size != other.size && !isPartial) {
            return false;
          }
          // Assume cyclic values are equal.
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG$1;

          // Recursively compare objects (susceptible to call stack limits).
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack['delete'](object);
          return result;

        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }

    /**
     * Appends the elements of `values` to `array`.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to append.
     * @returns {Array} Returns `array`.
     */
    function arrayPush(array, values) {
      var index = -1,
          length = values.length,
          offset = array.length;

      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }

    /**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }

    /**
     * A specialized version of `_.filter` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function arrayFilter(array, predicate) {
      var index = -1,
          length = array == null ? 0 : array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }

    /**
     * This method returns a new empty array.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Array} Returns the new empty array.
     * @example
     *
     * var arrays = _.times(2, _.stubArray);
     *
     * console.log(arrays);
     * // => [[], []]
     *
     * console.log(arrays[0] === arrays[1]);
     * // => false
     */
    function stubArray() {
      return [];
    }

    /** Used for built-in method references. */
    var objectProto$12 = Object.prototype;

    /** Built-in value references. */
    var propertyIsEnumerable$1 = objectProto$12.propertyIsEnumerable;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeGetSymbols = Object.getOwnPropertySymbols;

    /**
     * Creates an array of the own enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable$1.call(object, symbol);
      });
    };

    /**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }

    /** Used to compose bitmasks for value comparisons. */
    var COMPARE_PARTIAL_FLAG$2 = 1;

    /** Used for built-in method references. */
    var objectProto$13 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$10 = objectProto$13.hasOwnProperty;

    /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2,
          objProps = getAllKeys(object),
          objLength = objProps.length,
          othProps = getAllKeys(other),
          othLength = othProps.length;

      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty$10.call(other, key))) {
          return false;
        }
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);

      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key],
            othValue = other[key];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, objValue, key, other, object, stack)
            : customizer(objValue, othValue, key, object, other, stack);
        }
        // Recursively compare objects (susceptible to call stack limits).
        if (!(compared === undefined
              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
              : compared
            )) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == 'constructor');
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor,
            othCtor = other.constructor;

        // Non `Object` object instances with different constructors are not equal.
        if (objCtor != othCtor &&
            ('constructor' in object && 'constructor' in other) &&
            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack['delete'](object);
      stack['delete'](other);
      return result;
    }

    /* Built-in method references that are verified to be native. */
    var DataView = getNative(root, 'DataView');

    /* Built-in method references that are verified to be native. */
    var Promise$1 = getNative(root, 'Promise');

    /* Built-in method references that are verified to be native. */
    var Set = getNative(root, 'Set');

    /* Built-in method references that are verified to be native. */
    var WeakMap = getNative(root, 'WeakMap');

    /** `Object#toString` result references. */
    var mapTag$2 = '[object Map]',
        objectTag$2 = '[object Object]',
        promiseTag = '[object Promise]',
        setTag$2 = '[object Set]',
        weakMapTag$1 = '[object WeakMap]';

    var dataViewTag$2 = '[object DataView]';

    /** Used to detect maps, sets, and weakmaps. */
    var dataViewCtorString = toSource(DataView),
        mapCtorString = toSource(Map$1),
        promiseCtorString = toSource(Promise$1),
        setCtorString = toSource(Set),
        weakMapCtorString = toSource(WeakMap);

    /**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    var getTag = baseGetTag;

    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag$2) ||
        (Map$1 && getTag(new Map$1) != mapTag$2) ||
        (Promise$1 && getTag(Promise$1.resolve()) != promiseTag) ||
        (Set && getTag(new Set) != setTag$2) ||
        (WeakMap && getTag(new WeakMap) != weakMapTag$1)) {
      getTag = function(value) {
        var result = baseGetTag(value),
            Ctor = result == objectTag$2 ? value.constructor : undefined,
            ctorString = Ctor ? toSource(Ctor) : '';

        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString: return dataViewTag$2;
            case mapCtorString: return mapTag$2;
            case promiseCtorString: return promiseTag;
            case setCtorString: return setTag$2;
            case weakMapCtorString: return weakMapTag$1;
          }
        }
        return result;
      };
    }

    var getTag$1 = getTag;

    /** Used to compose bitmasks for value comparisons. */
    var COMPARE_PARTIAL_FLAG$3 = 1;

    /** `Object#toString` result references. */
    var argsTag$2 = '[object Arguments]',
        arrayTag$1 = '[object Array]',
        objectTag$3 = '[object Object]';

    /** Used for built-in method references. */
    var objectProto$14 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$11 = objectProto$14.hasOwnProperty;

    /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object),
          othIsArr = isArray(other),
          objTag = objIsArr ? arrayTag$1 : getTag$1(object),
          othTag = othIsArr ? arrayTag$1 : getTag$1(other);

      objTag = objTag == argsTag$2 ? objectTag$3 : objTag;
      othTag = othTag == argsTag$2 ? objectTag$3 : othTag;

      var objIsObj = objTag == objectTag$3,
          othIsObj = othTag == objectTag$3,
          isSameTag = objTag == othTag;

      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack);
        return (objIsArr || isTypedArray(object))
          ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
          : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG$3)) {
        var objIsWrapped = objIsObj && hasOwnProperty$11.call(object, '__wrapped__'),
            othIsWrapped = othIsObj && hasOwnProperty$11.call(other, '__wrapped__');

        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object,
              othUnwrapped = othIsWrapped ? other.value() : other;

          stack || (stack = new Stack);
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack);
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }

    /**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Unordered comparison
     *  2 - Partial comparison
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }

    /** Used to compose bitmasks for value comparisons. */
    var COMPARE_PARTIAL_FLAG$4 = 1,
        COMPARE_UNORDERED_FLAG$2 = 2;

    /**
     * The base implementation of `_.isMatch` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Array} matchData The property names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length,
          length = index,
          noCustomizer = !customizer;

      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if ((noCustomizer && data[2])
              ? data[1] !== object[data[0]]
              : !(data[0] in object)
            ) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0],
            objValue = object[key],
            srcValue = data[1];

        if (noCustomizer && data[2]) {
          if (objValue === undefined && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack;
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === undefined
                ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$4 | COMPARE_UNORDERED_FLAG$2, customizer, stack)
                : result
              )) {
            return false;
          }
        }
      }
      return true;
    }

    /**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }

    /**
     * Gets the property names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */
    function getMatchData(object) {
      var result = keys(object),
          length = result.length;

      while (length--) {
        var key = result[length],
            value = object[key];

        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }

    /**
     * A specialized version of `matchesProperty` for source values suitable
     * for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue &&
          (srcValue !== undefined || (key in Object(object)));
      };
    }

    /**
     * The base implementation of `_.matches` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }

    /** `Object#toString` result references. */
    var symbolTag$1 = '[object Symbol]';

    /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */
    function isSymbol(value) {
      return typeof value == 'symbol' ||
        (isObjectLike(value) && baseGetTag(value) == symbolTag$1);
    }

    /** Used to match property names within property paths. */
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
        reIsPlainProp = /^\w*$/;

    /**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == 'number' || type == 'symbol' || type == 'boolean' ||
          value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
        (object != null && value in Object(object));
    }

    /** Error message constants. */
    var FUNC_ERROR_TEXT = 'Expected a function';

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided, it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the
     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoized function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // Modify the result cache.
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // Replace `_.memoize.Cache`.
     * _.memoize.Cache = WeakMap;
     */
    function memoize(func, resolver) {
      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments,
            key = resolver ? resolver.apply(this, args) : args[0],
            cache = memoized.cache;

        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache);
      return memoized;
    }

    // Expose `MapCache`.
    memoize.Cache = MapCache;

    /** Used as the maximum memoize cache size. */
    var MAX_MEMOIZE_SIZE = 500;

    /**
     * A specialized version of `_.memoize` which clears the memoized function's
     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
     *
     * @private
     * @param {Function} func The function to have its output memoized.
     * @returns {Function} Returns the new memoized function.
     */
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });

      var cache = result.cache;
      return result;
    }

    /** Used to match property names within property paths. */
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

    /** Used to match backslashes in property paths. */
    var reEscapeChar = /\\(\\)?/g;

    /**
     * Converts `string` to a property path array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the property path array.
     */
    var stringToPath = memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46 /* . */) {
        result.push('');
      }
      string.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
      });
      return result;
    });

    /**
     * A specialized version of `_.map` for arrays without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function arrayMap(array, iteratee) {
      var index = -1,
          length = array == null ? 0 : array.length,
          result = Array(length);

      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }

    /** Used as references for various `Number` constants. */
    var INFINITY = 1 / 0;

    /** Used to convert symbols to primitives and strings. */
    var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : undefined,
        symbolToString = symbolProto$1 ? symbolProto$1.toString : undefined;

    /**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */
    function baseToString(value) {
      // Exit early for strings to avoid a performance hit in some environments.
      if (typeof value == 'string') {
        return value;
      }
      if (isArray(value)) {
        // Recursively convert values (susceptible to call stack limits).
        return arrayMap(value, baseToString) + '';
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : '';
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }

    /**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */
    function toString(value) {
      return value == null ? '' : baseToString(value);
    }

    /**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {Object} [object] The object to query keys on.
     * @returns {Array} Returns the cast property path array.
     */
    function castPath(value, object) {
      if (isArray(value)) {
        return value;
      }
      return isKey(value, object) ? [value] : stringToPath(toString(value));
    }

    /** Used as references for various `Number` constants. */
    var INFINITY$1 = 1 / 0;

    /**
     * Converts `value` to a string key if it's not a string or symbol.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {string|symbol} Returns the key.
     */
    function toKey(value) {
      if (typeof value == 'string' || isSymbol(value)) {
        return value;
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY$1) ? '-0' : result;
    }

    /**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */
    function baseGet(object, path) {
      path = castPath(path, object);

      var index = 0,
          length = path.length;

      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return (index && index == length) ? object : undefined;
    }

    /**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined`, the `defaultValue` is returned in its place.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */
    function get(object, path, defaultValue) {
      var result = object == null ? undefined : baseGet(object, path);
      return result === undefined ? defaultValue : result;
    }

    /**
     * The base implementation of `_.hasIn` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }

    /**
     * Checks if `path` exists on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @param {Function} hasFunc The function to check properties.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     */
    function hasPath(object, path, hasFunc) {
      path = castPath(path, object);

      var index = -1,
          length = path.length,
          result = false;

      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result || ++index != length) {
        return result;
      }
      length = object == null ? 0 : object.length;
      return !!length && isLength(length) && isIndex(key, length) &&
        (isArray(object) || isArguments(object));
    }

    /**
     * Checks if `path` is a direct or inherited property of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.hasIn(object, 'a');
     * // => true
     *
     * _.hasIn(object, 'a.b');
     * // => true
     *
     * _.hasIn(object, ['a', 'b']);
     * // => true
     *
     * _.hasIn(object, 'b');
     * // => false
     */
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }

    /** Used to compose bitmasks for value comparisons. */
    var COMPARE_PARTIAL_FLAG$5 = 1,
        COMPARE_UNORDERED_FLAG$3 = 2;

    /**
     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get(object, path);
        return (objValue === undefined && objValue === srcValue)
          ? hasIn(object, path)
          : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$5 | COMPARE_UNORDERED_FLAG$3);
      };
    }

    /**
     * The base implementation of `_.property` without support for deep paths.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @returns {Function} Returns the new accessor function.
     */
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined : object[key];
      };
    }

    /**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     */
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }

    /**
     * Creates a function that returns the value at `path` of a given object.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': 2 } },
     *   { 'a': { 'b': 1 } }
     * ];
     *
     * _.map(objects, _.property('a.b'));
     * // => [2, 1]
     *
     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
     * // => [1, 2]
     */
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }

    /**
     * The base implementation of `_.iteratee`.
     *
     * @private
     * @param {*} [value=_.identity] The value to convert to an iteratee.
     * @returns {Function} Returns the iteratee.
     */
    function baseIteratee(value) {
      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
      if (typeof value == 'function') {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == 'object') {
        return isArray(value)
          ? baseMatchesProperty(value[0], value[1])
          : baseMatches(value);
      }
      return property(value);
    }

    /**
     * The opposite of `_.mapValues`; this method creates an object with the
     * same values as `object` and keys generated by running each own enumerable
     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
     * with three arguments: (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapValues
     * @example
     *
     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
     *   return key + value;
     * });
     * // => { 'a1': 1, 'b2': 2 }
     */
    function mapKeys(object, iteratee) {
      var result = {};
      iteratee = baseIteratee(iteratee, 3);

      baseForOwn(object, function(value, key, object) {
        baseAssignValue(result, iteratee(value, key, object), value);
      });
      return result;
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length,
            index = fromRight ? length : -1,
            iterable = Object(collection);

        while ((fromRight ? index-- : ++index < length)) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }

    /**
     * The base implementation of `_.forEach` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
    var baseEach = createBaseEach(baseForOwn);

    /**
     * The base implementation of `_.filter` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function baseFilter(collection, predicate) {
      var result = [];
      baseEach(collection, function(value, index, collection) {
        if (predicate(value, index, collection)) {
          result.push(value);
        }
      });
      return result;
    }

    /**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * **Note:** Unlike `_.remove`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.reject
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, { 'age': 36, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.filter(users, 'active');
     * // => objects for ['barney']
     */
    function filter(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, baseIteratee(predicate, 3));
    }

    function prefix(subject, prefix) {
      var delimeter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '-';

      var prefixer = function prefixer(value, key) {
        var string = key || value;
        return filter([prefix, string.replace(new RegExp("^".concat(prefix).concat(delimeter, "?")), '')]).join(delimeter);
      };

      if (isBoolean(subject) || isNull(subject) || isUndefined(subject)) {
        return subject;
      }

      if (isObject(subject)) {
        return mapKeys(subject, prefixer);
      }

      return prefixer(subject);
    }

    var Variant = {
      props: {
        /**
         * The variant attribute
         *
         * @property String
         */
        variant: {
          type: String,
          default: 'primary'
        }
      },
      computed: {
        variantClassPrefix: function variantClassPrefix() {
          return this.$options.name;
        },
        variantClass: function variantClass() {
          return prefix(this.variant, this.variantClassPrefix);
        }
      }
    };

    var Sizeable = {
      props: {
        /**
         * The size of the form control
         *
         * @property String
         */
        size: {
          type: String,
          default: 'md',
          validate: function validate(value) {
            return ['sm', 'md', 'lg'].indexOf(value) !== -1;
          }
        }
      },
      computed: {
        sizeableClassPrefix: function sizeableClassPrefix() {
          return this.$options.name;
        },
        sizeableClass: function sizeableClass() {
          return prefix(this.size, this.sizeableClassPrefix);
        }
      }
    };

    /**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseSlice(array, start, end) {
      var index = -1,
          length = array.length;

      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : ((end - start) >>> 0);
      start >>>= 0;

      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }

    /**
     * Casts `array` to a slice if it's needed.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {number} start The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the cast slice.
     */
    function castSlice(array, start, end) {
      var length = array.length;
      end = end === undefined ? length : end;
      return (!start && end >= length) ? array : baseSlice(array, start, end);
    }

    /** Used to compose unicode character classes. */
    var rsAstralRange = '\\ud800-\\udfff',
        rsComboMarksRange = '\\u0300-\\u036f',
        reComboHalfMarksRange = '\\ufe20-\\ufe2f',
        rsComboSymbolsRange = '\\u20d0-\\u20ff',
        rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
        rsVarRange = '\\ufe0e\\ufe0f';

    /** Used to compose unicode capture groups. */
    var rsZWJ = '\\u200d';

    /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
    var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

    /**
     * Checks if `string` contains Unicode symbols.
     *
     * @private
     * @param {string} string The string to inspect.
     * @returns {boolean} Returns `true` if a symbol is found, else `false`.
     */
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }

    /**
     * Converts an ASCII `string` to an array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the converted array.
     */
    function asciiToArray(string) {
      return string.split('');
    }

    /** Used to compose unicode character classes. */
    var rsAstralRange$1 = '\\ud800-\\udfff',
        rsComboMarksRange$1 = '\\u0300-\\u036f',
        reComboHalfMarksRange$1 = '\\ufe20-\\ufe2f',
        rsComboSymbolsRange$1 = '\\u20d0-\\u20ff',
        rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1,
        rsVarRange$1 = '\\ufe0e\\ufe0f';

    /** Used to compose unicode capture groups. */
    var rsAstral = '[' + rsAstralRange$1 + ']',
        rsCombo = '[' + rsComboRange$1 + ']',
        rsFitz = '\\ud83c[\\udffb-\\udfff]',
        rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
        rsNonAstral = '[^' + rsAstralRange$1 + ']',
        rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
        rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
        rsZWJ$1 = '\\u200d';

    /** Used to compose unicode regexes. */
    var reOptMod = rsModifier + '?',
        rsOptVar = '[' + rsVarRange$1 + ']?',
        rsOptJoin = '(?:' + rsZWJ$1 + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
        rsSeq = rsOptVar + reOptMod + rsOptJoin,
        rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

    /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
    var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

    /**
     * Converts a Unicode `string` to an array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the converted array.
     */
    function unicodeToArray(string) {
      return string.match(reUnicode) || [];
    }

    /**
     * Converts `string` to an array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the converted array.
     */
    function stringToArray(string) {
      return hasUnicode(string)
        ? unicodeToArray(string)
        : asciiToArray(string);
    }

    /**
     * Creates a function like `_.lowerFirst`.
     *
     * @private
     * @param {string} methodName The name of the `String` case method to use.
     * @returns {Function} Returns the new case function.
     */
    function createCaseFirst(methodName) {
      return function(string) {
        string = toString(string);

        var strSymbols = hasUnicode(string)
          ? stringToArray(string)
          : undefined;

        var chr = strSymbols
          ? strSymbols[0]
          : string.charAt(0);

        var trailing = strSymbols
          ? castSlice(strSymbols, 1).join('')
          : string.slice(1);

        return chr[methodName]() + trailing;
      };
    }

    /**
     * Converts the first character of `string` to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.upperFirst('fred');
     * // => 'Fred'
     *
     * _.upperFirst('FRED');
     * // => 'FRED'
     */
    var upperFirst = createCaseFirst('toUpperCase');

    /**
     * Converts the first character of `string` to upper case and the remaining
     * to lower case.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('FRED');
     * // => 'Fred'
     */
    function capitalize(string) {
      return upperFirst(toString(string).toLowerCase());
    }

    /**
     * A specialized version of `_.reduce` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {boolean} [initAccum] Specify using the first element of `array` as
     *  the initial value.
     * @returns {*} Returns the accumulated value.
     */
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1,
          length = array == null ? 0 : array.length;

      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }

    /**
     * The base implementation of `_.propertyOf` without support for deep paths.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new accessor function.
     */
    function basePropertyOf(object) {
      return function(key) {
        return object == null ? undefined : object[key];
      };
    }

    /** Used to map Latin Unicode letters to basic Latin letters. */
    var deburredLetters = {
      // Latin-1 Supplement block.
      '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
      '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
      '\xc7': 'C',  '\xe7': 'c',
      '\xd0': 'D',  '\xf0': 'd',
      '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
      '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
      '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
      '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
      '\xd1': 'N',  '\xf1': 'n',
      '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
      '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
      '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
      '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
      '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
      '\xc6': 'Ae', '\xe6': 'ae',
      '\xde': 'Th', '\xfe': 'th',
      '\xdf': 'ss',
      // Latin Extended-A block.
      '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
      '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
      '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
      '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
      '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
      '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
      '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
      '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
      '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
      '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
      '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
      '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
      '\u0134': 'J',  '\u0135': 'j',
      '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
      '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
      '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
      '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
      '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
      '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
      '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
      '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
      '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
      '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
      '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
      '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
      '\u0163': 't',  '\u0165': 't', '\u0167': 't',
      '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
      '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
      '\u0174': 'W',  '\u0175': 'w',
      '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
      '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
      '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
      '\u0132': 'IJ', '\u0133': 'ij',
      '\u0152': 'Oe', '\u0153': 'oe',
      '\u0149': "'n", '\u017f': 's'
    };

    /**
     * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
     * letters to basic Latin letters.
     *
     * @private
     * @param {string} letter The matched letter to deburr.
     * @returns {string} Returns the deburred letter.
     */
    var deburrLetter = basePropertyOf(deburredLetters);

    /** Used to match Latin Unicode letters (excluding mathematical operators). */
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

    /** Used to compose unicode character classes. */
    var rsComboMarksRange$2 = '\\u0300-\\u036f',
        reComboHalfMarksRange$2 = '\\ufe20-\\ufe2f',
        rsComboSymbolsRange$2 = '\\u20d0-\\u20ff',
        rsComboRange$2 = rsComboMarksRange$2 + reComboHalfMarksRange$2 + rsComboSymbolsRange$2;

    /** Used to compose unicode capture groups. */
    var rsCombo$1 = '[' + rsComboRange$2 + ']';

    /**
     * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
     * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
     */
    var reComboMark = RegExp(rsCombo$1, 'g');

    /**
     * Deburrs `string` by converting
     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
     * letters to basic Latin letters and removing
     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('dj vu');
     * // => 'deja vu'
     */
    function deburr(string) {
      string = toString(string);
      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
    }

    /** Used to match words composed of alphanumeric characters. */
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

    /**
     * Splits an ASCII `string` into an array of its words.
     *
     * @private
     * @param {string} The string to inspect.
     * @returns {Array} Returns the words of `string`.
     */
    function asciiWords(string) {
      return string.match(reAsciiWord) || [];
    }

    /** Used to detect strings that need a more robust regexp to match words. */
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

    /**
     * Checks if `string` contains a word composed of Unicode symbols.
     *
     * @private
     * @param {string} string The string to inspect.
     * @returns {boolean} Returns `true` if a word is found, else `false`.
     */
    function hasUnicodeWord(string) {
      return reHasUnicodeWord.test(string);
    }

    /** Used to compose unicode character classes. */
    var rsAstralRange$2 = '\\ud800-\\udfff',
        rsComboMarksRange$3 = '\\u0300-\\u036f',
        reComboHalfMarksRange$3 = '\\ufe20-\\ufe2f',
        rsComboSymbolsRange$3 = '\\u20d0-\\u20ff',
        rsComboRange$3 = rsComboMarksRange$3 + reComboHalfMarksRange$3 + rsComboSymbolsRange$3,
        rsDingbatRange = '\\u2700-\\u27bf',
        rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
        rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
        rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
        rsPunctuationRange = '\\u2000-\\u206f',
        rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
        rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
        rsVarRange$2 = '\\ufe0e\\ufe0f',
        rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

    /** Used to compose unicode capture groups. */
    var rsApos = "['\u2019]",
        rsBreak = '[' + rsBreakRange + ']',
        rsCombo$2 = '[' + rsComboRange$3 + ']',
        rsDigits = '\\d+',
        rsDingbat = '[' + rsDingbatRange + ']',
        rsLower = '[' + rsLowerRange + ']',
        rsMisc = '[^' + rsAstralRange$2 + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
        rsFitz$1 = '\\ud83c[\\udffb-\\udfff]',
        rsModifier$1 = '(?:' + rsCombo$2 + '|' + rsFitz$1 + ')',
        rsNonAstral$1 = '[^' + rsAstralRange$2 + ']',
        rsRegional$1 = '(?:\\ud83c[\\udde6-\\uddff]){2}',
        rsSurrPair$1 = '[\\ud800-\\udbff][\\udc00-\\udfff]',
        rsUpper = '[' + rsUpperRange + ']',
        rsZWJ$2 = '\\u200d';

    /** Used to compose unicode regexes. */
    var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
        rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
        rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
        rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
        reOptMod$1 = rsModifier$1 + '?',
        rsOptVar$1 = '[' + rsVarRange$2 + ']?',
        rsOptJoin$1 = '(?:' + rsZWJ$2 + '(?:' + [rsNonAstral$1, rsRegional$1, rsSurrPair$1].join('|') + ')' + rsOptVar$1 + reOptMod$1 + ')*',
        rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
        rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
        rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1,
        rsEmoji = '(?:' + [rsDingbat, rsRegional$1, rsSurrPair$1].join('|') + ')' + rsSeq$1;

    /** Used to match complex or compound words. */
    var reUnicodeWord = RegExp([
      rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
      rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
      rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
      rsUpper + '+' + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join('|'), 'g');

    /**
     * Splits a Unicode `string` into an array of its words.
     *
     * @private
     * @param {string} The string to inspect.
     * @returns {Array} Returns the words of `string`.
     */
    function unicodeWords(string) {
      return string.match(reUnicodeWord) || [];
    }

    /**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */
    function words(string, pattern, guard) {
      string = toString(string);
      pattern = guard ? undefined : pattern;

      if (pattern === undefined) {
        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
      }
      return string.match(pattern) || [];
    }

    /** Used to compose unicode capture groups. */
    var rsApos$1 = "['\u2019]";

    /** Used to match apostrophes. */
    var reApos = RegExp(rsApos$1, 'g');

    /**
     * Creates a function like `_.camelCase`.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */
    function createCompounder(callback) {
      return function(string) {
        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
      };
    }

    /**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar--');
     * // => 'fooBar'
     *
     * _.camelCase('__FOO_BAR__');
     * // => 'fooBar'
     */
    var camelCase = createCompounder(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? capitalize(word) : word);
    });

    /** Error message constants. */
    var FUNC_ERROR_TEXT$1 = 'Expected a function';

    /**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new negated function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */
    function negate(predicate) {
      if (typeof predicate != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT$1);
      }
      return function() {
        var args = arguments;
        switch (args.length) {
          case 0: return !predicate.call(this);
          case 1: return !predicate.call(this, args[0]);
          case 2: return !predicate.call(this, args[0], args[1]);
          case 3: return !predicate.call(this, args[0], args[1], args[2]);
        }
        return !predicate.apply(this, args);
      };
    }

    /**
     * The base implementation of `_.set`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */
    function baseSet(object, path, value, customizer) {
      if (!isObject(object)) {
        return object;
      }
      path = castPath(path, object);

      var index = -1,
          length = path.length,
          lastIndex = length - 1,
          nested = object;

      while (nested != null && ++index < length) {
        var key = toKey(path[index]),
            newValue = value;

        if (index != lastIndex) {
          var objValue = nested[key];
          newValue = customizer ? customizer(objValue, key, nested) : undefined;
          if (newValue === undefined) {
            newValue = isObject(objValue)
              ? objValue
              : (isIndex(path[index + 1]) ? [] : {});
          }
        }
        assignValue(nested, key, newValue);
        nested = nested[key];
      }
      return object;
    }

    /**
     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @param {Function} predicate The function invoked per property.
     * @returns {Object} Returns the new object.
     */
    function basePickBy(object, paths, predicate) {
      var index = -1,
          length = paths.length,
          result = {};

      while (++index < length) {
        var path = paths[index],
            value = baseGet(object, path);

        if (predicate(value, path)) {
          baseSet(result, castPath(path, object), value);
        }
      }
      return result;
    }

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeGetSymbols$1 = Object.getOwnPropertySymbols;

    /**
     * Creates an array of the own and inherited enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbolsIn = !nativeGetSymbols$1 ? stubArray : function(object) {
      var result = [];
      while (object) {
        arrayPush(result, getSymbols(object));
        object = getPrototype(object);
      }
      return result;
    };

    /**
     * Creates an array of own and inherited enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeysIn(object) {
      return baseGetAllKeys(object, keysIn$1, getSymbolsIn);
    }

    /**
     * Creates an object composed of the `object` properties `predicate` returns
     * truthy for. The predicate is invoked with two arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pickBy(object, _.isNumber);
     * // => { 'a': 1, 'c': 3 }
     */
    function pickBy(object, predicate) {
      if (object == null) {
        return {};
      }
      var props = arrayMap(getAllKeysIn(object), function(prop) {
        return [prop];
      });
      predicate = baseIteratee(predicate);
      return basePickBy(object, props, function(value, path) {
        return predicate(value, path[0]);
      });
    }

    /**
     * The opposite of `_.pickBy`; this method creates an object composed of
     * the own and inherited enumerable string keyed properties of `object` that
     * `predicate` doesn't return truthy for. The predicate is invoked with two
     * arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omitBy(object, _.isNumber);
     * // => { 'b': '2' }
     */
    function omitBy(object, predicate) {
      return pickBy(object, negate(baseIteratee(predicate)));
    }

    /**
     * A specialized version of `_.forEach` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns `array`.
     */
    function arrayEach(array, iteratee) {
      var index = -1,
          length = array == null ? 0 : array.length;

      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }

    /**
     * Casts `value` to `identity` if it's not a function.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Function} Returns cast function.
     */
    function castFunction(value) {
      return typeof value == 'function' ? value : identity;
    }

    /**
     * Iterates over elements of `collection` and invokes `iteratee` for each element.
     * The iteratee is invoked with three arguments: (value, index|key, collection).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a "length"
     * property are iterated like arrays. To avoid this behavior use `_.forIn`
     * or `_.forOwn` for object iteration.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias each
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEachRight
     * @example
     *
     * _.forEach([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `1` then `2`.
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */
    function forEach(collection, iteratee) {
      var func = isArray(collection) ? arrayEach : baseEach;
      return func(collection, castFunction(iteratee));
    }

    /**
     * The base implementation of `_.map` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function baseMap(collection, iteratee) {
      var index = -1,
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value, key, collection) {
        result[++index] = iteratee(value, key, collection);
      });
      return result;
    }

    /**
     * Creates an array of values by running each element in `collection` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * _.map([4, 8], square);
     * // => [16, 64]
     *
     * _.map({ 'a': 4, 'b': 8 }, square);
     * // => [16, 64] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */
    function map(collection, iteratee) {
      var func = isArray(collection) ? arrayMap : baseMap;
      return func(collection, baseIteratee(iteratee, 3));
    }

    var COLORS = ['primary', 'secondary', 'success', 'danger', 'warning', 'info', 'light', 'dark', 'white', 'muted'];
    var props = {};

    forEach(['border', 'text', 'bg', 'bg-gradient'], function (namespace) {
      forEach(COLORS, function (color) {
        props[camelCase(prefix(color, namespace))] = Boolean;
      });
    });

    function classes(instance, namespace) {
      return filter(map(COLORS, function (color) {
        return instance[camelCase(color = prefix(color, namespace))] ? color : null;
      }));
    }

    var Colorable = {
      props: props,
      methods: {
        textColor: function textColor() {
          return classes(this, 'text');
        },
        bgColor: function bgColor() {
          return classes(this, 'bg');
        },
        borderColor: function borderColor() {
          return classes(this, 'border');
        },
        bgGradientColor: function bgGradientColor() {
          return classes(this, 'bg-gradient');
        }
      },
      computed: {
        textColorClasses: function textColorClasses() {
          return this.textColor().join(' ').trim() || null;
        },
        borderColorClasses: function borderColorClasses() {
          return this.borderColor().join(' ').trim() || null;
        },
        bgColorClasses: function bgColorClasses() {
          return this.bgColor().join(' ').trim() || null;
        },
        bgGradientColorClasses: function bgGradientColorClasses() {
          return this.bgGradientColor().join(' ').trim() || null;
        },
        colorableClasses: function colorableClasses() {
          var classes = {};
          classes[this.textColorClasses] = !!this.textColorClasses;
          classes[this.borderColorClasses] = !!this.borderColorClasses;
          classes[this.bgColorClasses] = !!this.bgColorClasses;
          classes[this.bgGradientColorClasses] = !!this.bgGradientColorClasses;
          return omitBy(classes, function (key, value) {
            return !key || !value;
          });
        }
      }
    };

    function duration(el) {
      var duration = getComputedStyle(el).transitionDuration;
      var numeric = parseFloat(duration, 10) || 0;
      var unit = duration.match(/m?s/);

      switch (unit[0]) {
        case 's':
          return numeric * 1000;

        case 'ms':
          return numeric;
      }
    }

    function transition(el) {
      return new Promise(function (resolve, reject) {
        try {
          var delay = duration(el);
          setTimeout(function () {
            resolve(delay);
          }, delay);
        } catch (e) {
          reject(e);
        }
      });
    }

    /**
     * This method is like `_.assign` except that it iterates over own and
     * inherited source properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assign
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
     */
    var assignIn = createAssigner(function(object, source) {
      copyObject(source, keysIn$1(source), object);
    });

    /**
     * This method is like `_.assign` except that it recursively merges own and
     * inherited enumerable string keyed properties of source objects into the
     * destination object. Source properties that resolve to `undefined` are
     * skipped if a destination value exists. Array and plain object properties
     * are merged recursively. Other objects and value types are overridden by
     * assignment. Source objects are applied from left to right. Subsequent
     * sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {
     *   'a': [{ 'b': 2 }, { 'd': 4 }]
     * };
     *
     * var other = {
     *   'a': [{ 'c': 3 }, { 'e': 5 }]
     * };
     *
     * _.merge(object, other);
     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
     */
    var merge = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });

    var MergeClasses = {
      methods: {
        mergeClasses: function mergeClasses() {
          var classes = {};

          forEach([].slice.call(arguments), function (arg) {
            if (isObject(arg)) {
              assignIn(classes, arg);
            } else if (isArray(arg)) {
              merge(classes, arg);
            } else if (arg) {
              classes[arg] = true;
            }
          });

          return classes;
        }
      }
    };

    var Btn = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _vm.to ? _c('router-link', {
          class: _vm.classes,
          attrs: {
            "to": _vm.to,
            "disabled": _vm.disabled,
            "role": "button"
          },
          on: {
            "click": _vm.onClick
          }
        }, [_vm._t("default")], 2) : _vm.href ? _c('a', {
          class: _vm.classes,
          attrs: {
            "href": _vm.href,
            "disabled": _vm.disabled,
            "role": "button"
          },
          on: {
            "click": _vm.onClick
          }
        }, [_vm._t("default")], 2) : _vm.label ? _c('label', {
          class: _vm.classes,
          attrs: {
            "disabled": _vm.disabled,
            "role": "button"
          },
          on: {
            "click": _vm.onClick
          }
        }, [_vm._t("default")], 2) : _c('button', {
          class: _vm.classes,
          attrs: {
            "type": _vm.type,
            "disabled": _vm.disabled
          },
          on: {
            "click": _vm.onClick
          }
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'btn',
      mixins: [Variant, Sizeable, Colorable, MergeClasses],
      props: {
        /**
         * Display button with active state
         *
         * @property String
         */
        active: Boolean,

        /**
         * Display button with blocked state
         *
         * @property String
         */
        block: Boolean,

        /**
         * Display button with disabled state
         *
         * @property String
         */
        disabled: Boolean,

        /**
         * If an href is passed, button is an router-link element
         *
         * @property Boolean
         */
        href: String,

        /**
         * Should use <label> as the element for the button. Used for inputs
         * wrappers (toggles).
         *
         * @property Boolean
         */
        label: Boolean,

        /**
         * Display as an outline button
         *
         * @property String
         */
        outline: Boolean,

        /**
         * If an to is passed, button is an router-link element
         *
         * @property Boolean
         */
        to: [Object, String],

        /**
         * The type attribute for the button. Not applied if an anchor
         *
         * @property String
         */
        type: String
      },
      methods: {
        onClick: function onClick(event) {
          this.$emit('click', event);
        }
      },
      computed: {
        variantClassPrefix: function variantClassPrefix() {
          return this.$options.name + (this.outline ? '-outline' : '');
        },
        classes: function classes() {
          return this.mergeClasses('btn', this.variantClass, this.sizeableClass, this.colorableClasses, this.block ? 'btn-block' : '', this.active ? 'active' : '');
        }
      }
    };

    var LOADED_SCRIPTS = {};

    function element(url) {
      var script = document.createElement('script');
      script.setAttribute('src', url);
      script.setAttribute('type', 'text/javascript');
      script.setAttribute('charset', 'utf-8');
      return script;
    }

    function append(script) {
      if (document.querySelector('head')) {
        document.querySelector('head').appendChild(script);
      } else {
        document.querySelector('body').appendChild(script);
      }

      return script;
    }

    function script(url) {
      if (LOADED_SCRIPTS[url] instanceof Promise) {
        return LOADED_SCRIPTS[url];
      } else if (LOADED_SCRIPTS[url] || document.querySelector("script[src=\"".concat(url, "\"]"))) {
        return new Promise(function (resolve, reject) {
          resolve(LOADED_SCRIPTS[url]);
        });
      }

      return LOADED_SCRIPTS[url] = new Promise(function (resolve, reject) {
        try {
          append(element(url)).addEventListener('load', function (event) {
            resolve(LOADED_SCRIPTS[url] = event);
          });
        } catch (e) {
          reject(e);
        }
      });
    }

    var VueInstaller = {
      use: use,
      script: script,
      plugin: plugin,
      plugins: plugins,
      filter: filter$1,
      filters: filters$1,
      component: component,
      components: components,
      directive: directive,
      directives: directives,
      $plugins: {},
      $filters: {},
      $directives: {},
      $components: {}
    };
    function use(plugin) {
      if (typeof window !== 'undefined' && window.Vue) {
        window.Vue.use(plugin);
      }

      return plugin;
    }
    function plugin(Vue, name, def) {
      if (!VueInstaller.$plugins[name]) {
        Vue.use(VueInstaller.$plugins[name] = def);
      }
    }
    function plugins(Vue, plugins) {
      forEach(plugins, function (def, name) {
        plugin(Vue, name, def);
      });
    }
    function filter$1(Vue, name, def) {
      if (!VueInstaller.$filters[name]) {
        Vue.use(VueInstaller.$filters[name] = def);
      }
    }
    function filters$1(Vue, filters) {
      forEach(filters, function (def, name) {
        filter$1(Vue, name, def);
      });
    }
    function component(Vue, name, def) {
      if (!VueInstaller.$components[name]) {
        Vue.component(name, VueInstaller.$components[name] = def);
      }
    }
    function components(Vue, components) {
      forEach(components, function (def, name) {
        component(Vue, name, def);
      });
    }
    function directive(Vue, name, def) {
      if (!VueInstaller.$directives[name]) {
        if (isFunction$1(def)) {
          Vue.use(VueInstaller.$directives[name] = def);
        } else {
          Vue.directive(name, def);
        }
      }
    }
    function directives(Vue, directives) {
      forEach(directives, function (def, name) {
        directive(Vue, name, def);
      });
    }

    var plugin$1 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          Btn: Btn
        });
      }
    });

    var ModalBody = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "modal-body"
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'modal-body'
    };

    var ModalDialog = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "modal-dialog",
          attrs: {
            "role": "document"
          }
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'modal-dialog'
    };

    var ModalTitle = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('h5', {
          staticClass: "modal-title"
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'modal-title'
    };

    var ModalHeader = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "modal-header"
        }, [_vm._t("title", [_c('modal-title', [_vm._t("default")], 2)]), _vm._v(" "), _vm._t("close-button", [_vm.closeable ? _c('button', {
          staticClass: "close",
          attrs: {
            "type": "button",
            "aria-label": "ariaLabel"
          },
          on: {
            "click": function click($event) {
              _vm.$emit('close');
            }
          }
        }, [_c('span', {
          attrs: {
            "aria-hidden": "true"
          }
        }, [_vm._v("")])]) : _vm._e()])], 2);
      },
      staticRenderFns: [],
      name: 'modal-header',
      components: {
        ModalTitle: ModalTitle
      },
      props: {
        ariaLabel: {
          type: String,
          default: 'Close'
        },
        closeable: {
          type: Boolean,
          default: true
        }
      }
    };

    var ModalFooter = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "modal-footer"
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'modal-footer'
    };

    /**
     * Converts `string` to
     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__FOO_BAR__');
     * // => 'foo-bar'
     */
    var kebabCase = createCompounder(function(result, word, index) {
      return result + (index ? '-' : '') + word.toLowerCase();
    });

    var BaseType = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "activity-indicator",
          class: _vm.classes
        }, _vm._l(_vm.nodes, function (i) {
          return _c('div');
        }));
      },
      staticRenderFns: [],
      props: {
        nodes: {
          type: Number,
          default: 3
        },
        size: {
          type: String,
          default: ''
        },
        prefix: {
          type: String,
          default: 'activity-indicator-'
        }
      },
      computed: {
        classes: function classes() {
          var classes = {};
          classes[this.$options.name] = !!this.$options.name;
          classes[this.prefix + this.size.replace(this.prefix, '')] = !!this.size;
          return classes;
        }
      }
    };

    var ActivityIndicatorDots = {
      name: 'activity-indicator-dots',
      extends: BaseType
    };

    var ActivityIndicatorSpinner = {
      name: 'activity-indicator-spinner',
      extends: BaseType,
      props: assignIn({}, BaseType.props, {
        nodes: {
          type: Number,
          default: 12
        }
      })
    };

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeIsFinite = root.isFinite;

    /**
     * Checks if `value` is a finite primitive number.
     *
     * **Note:** This method is based on
     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
     * @example
     *
     * _.isFinite(3);
     * // => true
     *
     * _.isFinite(Number.MIN_VALUE);
     * // => true
     *
     * _.isFinite(Infinity);
     * // => false
     *
     * _.isFinite('3');
     * // => false
     */
    function isFinite$1(value) {
      return typeof value == 'number' && nativeIsFinite(value);
    }

    function unit (height) {
      return isFinite$1(height) ? height + 'px' : height;
    }

    var ActivityIndicator = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _vm.center ? _c('div', {
          staticClass: "center-wrapper",
          class: {
            'position-relative': _vm.relative,
            'position-fixed': _vm.fixed
          },
          style: _vm.style
        }, [_c('div', {
          staticClass: "center-content d-flex flex-column align-items-center"
        }, [_c(_vm.component, {
          tag: "component",
          attrs: {
            "size": _vm.size,
            "prefix": _vm.prefix
          }
        }), _vm._v(" "), _vm.label ? _c('div', {
          staticClass: "activity-indicator-label",
          domProps: {
            "innerHTML": _vm._s(_vm.label)
          }
        }) : _vm._e()], 1)]) : _c('div', {
          staticClass: "d-flex flex-column justify-content-center align-items-center",
          style: _vm.style
        }, [_c(_vm.component, {
          tag: "component",
          attrs: {
            "size": _vm.size,
            "prefix": _vm.prefix
          }
        }), _vm._v(" "), _vm.label ? _c('div', {
          staticClass: "activity-indicator-label",
          domProps: {
            "innerHTML": _vm._s(_vm.label)
          }
        }) : _vm._e()], 1);
      },
      staticRenderFns: [],
      name: 'activity-indicator',
      extends: BaseType,
      props: {
        center: Boolean,
        fixed: Boolean,
        label: String,
        relative: Boolean,
        type: {
          type: String,
          default: 'dots'
        },
        height: [String, Number],
        maxHeight: [String, Number],
        minHeight: [String, Number],
        width: [String, Number],
        maxWidth: [String, Number],
        minWidth: [String, Number]
      },
      components: {
        ActivityIndicatorDots: ActivityIndicatorDots,
        ActivityIndicatorSpinner: ActivityIndicatorSpinner
      },
      computed: {
        style: function style() {
          return {
            width: unit(this.width),
            maxWidth: unit(this.maxWidth),
            minWidth: unit(this.minWidth),
            height: unit(this.height),
            maxHeight: unit(this.maxHeight),
            minHeight: unit(this.minHeight)
          };
        },
        component: function component() {
          return kebabCase(this.prefix + this.type.replace(this.prefix, ''));
        }
      }
    };

    var plugin$2 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          ActivityIndicator: ActivityIndicator
        });
      }
    });

    var convertAnimationDelayToInt = function convertAnimationDelayToInt(delay) {
      var num = parseFloat(delay, 10);
      var matches = delay.match(/m?s/);
      var unit = matches ? matches[0] : false;
      var milliseconds;

      switch (unit) {
        case "s":
          // seconds
          milliseconds = num * 1000;
          break;

        case "ms":
        default:
          milliseconds = num;
          break;
      }

      return milliseconds || 0;
    };

    var animated = function animated(el, callback) {
      var defaultView = (el.ownerDocument || document).defaultView;
      setTimeout(function () {
        callback.apply();
      }, convertAnimationDelayToInt(defaultView.getComputedStyle(el).animationDuration));
    };

    var BtnActivity = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('button', {
          staticClass: "btn",
          class: _vm.classes,
          attrs: {
            "type": _vm.type
          },
          on: {
            "click": _vm.onClick
          }
        }, [_vm.icon ? _c('i', {
          class: _vm.icon
        }) : _vm._e(), _vm._v(" " + _vm._s(_vm.label) + " "), _vm._t("default"), _vm._v(" "), _c('activity-indicator', {
          attrs: {
            "type": _vm.indicator
          }
        })], 2);
      },
      staticRenderFns: [],
      name: 'activity-button',
      components: {
        ActivityIndicator: ActivityIndicator
      },
      props: {
        /**
         * Make the button appear with the active state.
         *
         * @property {Boolea}n}
         */
        active: Boolean,

        /**
         * Show the activity indicator inside the button.
         *
         * @property {Boolea}n}
         */
        activity: Boolean,

        /**
         * Display the button as block width.
         *
         * @property {Boolea}n}
         */
        block: Boolean,

        /**
         * Make the button appear with the disabled state.
         *
         * @property {Boolea}n}
         */
        disabled: Boolean,

        /**
         * The button label. If not passed as a property, label must be passed
         * inside the element's html.
         *
         * @property {String}
         */
        label: String,

        /**
         * The button icon
         *
         * @property {String}
         */
        icon: String,

        /**
         * The `type` attribute for the button element.
         *
         * @property {String}
         */
        type: String,

        /**
         * The size of the button.
         *
         * @property {String}
         */
        size: {
          type: String,
          default: 'md'
        },

        /**
         * The variant of the button.
         *
         * @property {String}
         */
        variant: {
          type: String,
          default: 'primary'
        },

        /**
         * The type of activity indicator inside the button.
         *
         * @property {String}
         */
        indicator: {
          type: String,
          default: 'spinner'
        },

        /**
         * The orientation of the activity button inside the button.
         *
         * @property {String}
         */
        orientation: {
          type: String,
          default: 'right'
        }
      },
      methods: {
        /**
         * Disable the button.
         *
         * @return void
         */
        disable: function disable() {
          this.$el.disabled = true;
        },

        /**
         * Enable the button.
         *
         * @return void
         */
        enable: function enable() {
          this.$el.disabled = false;
        },

        /**
         * Show the activity indicator inside the button.
         *
         * @return void
         */
        showActivity: function showActivity() {
          var _this = this;

          this.disable();
          animated(this.$el, function () {
            _this.$el.classList.add('btn-activity');

            _this.$emit('activity:show');
          });
        },

        /**
         * Hide the activity indicator inside the button.
         *
         * @return void
         */
        hideActivity: function hideActivity() {
          var _this2 = this;

          this.$el.classList.add('btn-hide-activity');
          animated(this.$el, function () {
            _this2.enable();

            _this2.$el.classList.remove('btn-activity', 'btn-hide-activity');

            _this2.$emit('activity:hide');
          });
        },

        /**
         * The click callback function
         *
         * @return void
         */
        onClick: function onClick(event) {
          this.$emit('click', event);
        }
      },
      computed: {
        /**
         * An object of classes to append to the button.
         *
         * @return void
         */
        classes: function classes() {
          var classes = {
            'disabled': this.disabled,
            'active': this.active,
            'btn-block': this.block,
            'btn-activity': this.activity
          };
          classes['btn-' + this.size.replace('btn-', '')] = !!this.size;
          classes['btn-' + this.variant.replace('btn-', '')] = !!this.variant;
          classes['btn-activity-' + this.orientation.replace('btn-activity-', '')] = !!this.orientation;
          classes['btn-activity-indicator-' + this.indicator.replace('btn-activity-indicator-', '')] = !!this.indicator;
          return classes;
        }
      },
      watch: {
        activity: function activity(value) {
          if (value) {
            this.showActivity();
          } else {
            this.hideActivity();
          }
        }
      }
    };

    var plugin$3 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          BtnActivity: BtnActivity
        });
      }
    });

    var ModalContent = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "modal-content"
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'modal-content'
    };

    var ModalBackdrop = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "modal-backdrop",
          class: {
            'fade': _vm.fade,
            'show': _vm.show
          }
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'modal-backdrop',
      props: {
        /**
         * Show the modal with a fade effect.
         *
         * @property Boolean
         */
        fade: {
          type: Boolean,
          default: true
        },

        /**
         * Is the modal showing.
         *
         * @property Boolean
         */
        show: {
          type: Boolean,
          default: true
        }
      }
    };

    /** `Object#toString` result references. */
    var stringTag$2 = '[object String]';

    /**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */
    function isString(value) {
      return typeof value == 'string' ||
        (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag$2);
    }

    var Triggerable = {
      props: {
        /**
         * Show the triggerable element with a animated fade effect.
         *
         * @type {Boolean}
         */
        animation: {
          type: Boolean,
          default: true
        },

        /**
         * Is the triggerable element showing.
         *
         * @property Boolean
         */
        show: {
          type: Boolean,
          defaut: false
        },

        /**
         * The target element used to position the popover.
         *
         * @type {String|Element|Boolean}
         */
        target: {
          type: [String, Element, Boolean],
          default: false
        },

        /**
         * How the modal is triggered - click | hover | focus | manual. You may
         * pass multiple triggers; separate them with a space. `manual` cannot
         * be combined with any other trigger.
         *
         * @type {String}
         */
        trigger: {
          type: [String, Array],
          default: 'click'
        }
      },
      methods: {
        /**
         * Initialize the trigger event for the specified elements
         *
         * @param  {Element} el
         * @return {void}
         */
        initializeTrigger: function initializeTrigger(el) {
          var _this = this;

          forEach(isString(this.trigger) ? this.trigger.split(' ') : this.trigger, function (trigger) {
            el.addEventListener(trigger, function (event) {
              _this.toggle();
            });
          });
        },

        /**
         * Initialize the event triggers
         *
         * @return void
         */
        initializeTriggers: function initializeTriggers() {
          var _this2 = this;

          if (this.target && this.trigger !== 'manual') {
            if (this.target instanceof Element) {
              this.initializeTrigger(this.target);
            } else {
              document.querySelectorAll(this.target).forEach(function (el) {
                _this2.initializeTrigger(el);
              });
            }
          }

          if (this.show || !this.target) {
            this.$nextTick(function () {
              _this2.isShowing = true;
            });
          }
        },

        /**
         * Focus on the first field in the modal (if exists).
         *
         * @return this
         */
        focus: function focus() {
          var _this3 = this;

          this.$nextTick(function () {
            var el = _this3.$el.querySelector('.form-control, input, select, textarea');

            if (el) {
              el.focus();
            } else {
              _this3.$el.focus();
            }
          });
          return this;
        },

        /**
         * Open the triggereable element
         *
         * @return this
         */
        open: function open() {
          var _this4 = this;

          this.isDisplaying = true;
          this.$nextTick(function () {
            transition(_this4.$el).then(function (delay) {
              _this4.isShowing = true;

              _this4.$emit('open');
            });
          });
          return this;
        },

        /**
         * Close the triggereable element
         *
         * @return this
         */
        close: function close(event) {
          var _this5 = this;

          transition(this.$el).then(function (delay) {
            _this5.isDisplaying = false;

            _this5.$emit('close', event);
          });
          this.isShowing = false;
          return this;
        },

        /**
         * Toggle the triggereable element's open/close method.
         *
         * @return this
         */
        toggle: function toggle() {
          if (!this.isShowing) {
            this.open();
          } else {
            this.close();
          }

          return this;
        }
      },
      computed: {
        triggerableClasses: function triggerableClasses() {
          return {
            'fade': this.animation,
            'show': this.isShowing
          };
        }
      },
      watch: {
        isShowing: function isShowing(value) {
          if (value) {
            this.focus();
          }
        },
        show: function show(value) {
          this.isShowing = value;
        }
      },
      mounted: function mounted() {
        this.initializeTriggers();
      },
      data: function data() {
        return {
          isDisplaying: this.show || !this.target,
          isShowing: false
        };
      }
    };

    var Modal = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "modal",
          class: _vm.triggerableClasses,
          style: {
            display: _vm.isDisplaying ? 'block' : 'none'
          },
          attrs: {
            "tabindex": "-1",
            "role": "dialog"
          },
          on: {
            "keydown": function keydown($event) {
              if (!('button' in $event) && _vm._k($event.keyCode, "esc", 27, $event.key, "Escape")) {
                return null;
              }

              return _vm.cancel($event);
            }
          }
        }, [_vm.backdrop ? _c('modal-backdrop', {
          ref: "backdrop"
        }) : _vm._e(), _vm._v(" "), _c('modal-dialog', {
          class: {
            'modal-dialog-centered': _vm.center
          }
        }, [_c('modal-content', [_vm._t("header", [_vm.title ? _c('modal-header', {
          on: {
            "close": _vm.cancel
          }
        }, [_vm._v(_vm._s(_vm.title))]) : _vm._e()]), _vm._v(" "), _vm._t("body", [_c(!_vm.flush ? 'modal-body' : 'div', {
          tag: "component",
          staticClass: "child-component"
        }, [_vm._t("default")], 2)]), _vm._v(" "), _vm._t("footer", [_vm.type ? _c('modal-footer', [_vm.type === 'alert' ? [_c('btn-activity', {
          attrs: {
            "activity": _vm.activity,
            "variant": "primary"
          },
          on: {
            "click": _vm.confirm
          }
        }, [_vm._v(_vm._s(_vm.okLabel))])] : [_c('btn', {
          attrs: {
            "type": "button",
            "variant": "secondary"
          },
          domProps: {
            "innerHTML": _vm._s(_vm.cancelLabel)
          },
          on: {
            "click": _vm.cancel
          }
        }), _vm._v(" "), _c('btn-activity', {
          attrs: {
            "activity": _vm.activity,
            "variant": "primary"
          },
          on: {
            "click": _vm.confirm
          }
        }, [_vm._v(_vm._s(_vm.okLabel))])]], 2) : _vm._e()])], 2)], 1)], 1);
      },
      staticRenderFns: [],
      name: 'modal',
      components: {
        Btn: Btn,
        BtnActivity: BtnActivity,
        ModalBody: ModalBody,
        ModalBackdrop: ModalBackdrop,
        ModalContent: ModalContent,
        ModalDialog: ModalDialog,
        ModalHeader: ModalHeader,
        ModalFooter: ModalFooter
      },
      mixins: [Triggerable],
      props: {
        /**
         * Show the modal activity indicator.
         *
         * @type {Boolean}
         */
        activity: Boolean,

        /**
         * Show the modal with a backdrop.
         *
         * @type {Boolean}
         */
        backdrop: {
          type: Boolean,
          default: true
        },

        /**
         * Is the modal centered in the screen.
         *
         * @type {Boolean}
         */
        center: Boolean,

        /**
         * Is the modal content fixed position
         *
         * @type {Boolean}
         */
        closeable: {
          type: Boolean,
          default: true
        },

        /**
         * Is the modal content flush with the modal edges? If true, no modal-body
         * will be used to wrap the content.
         *
         * @type {Boolean}
         */
        flush: Boolean,

        /**
         * The ok label text.
         *
         * @type {String}
         */
        okLabel: {
          type: String,
          default: 'Ok'
        },

        /**
         * The cancel label text.
         *
         * @type {String}
         */
        cancelLabel: {
          type: String,
          default: 'Cancel'
        },

        /**
         * The modal title.
         *
         * @type {String}
         */
        title: String,

        /**
         * Is the modal type.
         *
         * @type {Boolean}
         */
        type: {
          type: [Boolean, String],
          default: false,
          validate: function validate(value) {
            return ['alert', 'confirm', 'prompt'].indexOf(value) !== -1;
          }
        }
      },
      methods: {
        /**
         * Mount the backdrop to the document body.
         *
         * @return {void}
        mountBackdrop() {
            if(!this.backdropComponent) {
                this.backdropComponent = this.$refs.backdrop.$mount(
                    document.body.appendChild(document.createElement('div'))
                );
            }
        },
        */

        /**
         * Unmount the backdrop from the document body.
         *
         * @return {void}
        unmountBackdrop() {
            if(this.backdropComponent) {
                this.backdropComponent.$destroy();
                this.backdropComponent.$el.remove();
                this.backdropComponent = null;
            }
        },
        */

        /**
         * Cancel the modal
         *
         * @return {void}
         */
        cancel: function cancel(event) {
          this.$emit('cancel', event);
          this.close(event);
        },

        /**
         * Confirm the modal
         *
         * @return {void}
         */
        confirm: function confirm(event) {
          this.$emit('confirm', event);
        },

        /**
         * A callback for the escape function.
         *
         * @return {void}
         */
        onEsc: function onEsc(event) {
          this.type === 'confirm' || this.type === 'prompt' ? this.cancel(event) : this.close(event);
        }
      },
      watch: {
        isShowing: function isShowing(value) {
          if (value) {
            document.querySelector('body').classList.add('modal-open'); //this.mountBackdrop();
          } else {
            document.querySelector('body').classList.remove('modal-open'); //this.unmountBackdrop();
          }

          this.$emit('update:show', value);
        }
      },
      data: function data() {
        return {
          backdropComponent: null,
          isDisplaying: this.show || !this.target,
          isShowing: false
        };
      },
      mounted: function mounted() {
        this.initializeTriggers();
        /*
        if(this.show || !this.target) {
            this.mountBackdrop();
        }
        */
      },
      beforeRouteLeave: function beforeRouteLeave(to, from, next) {
        modal.close();
      }
    };

    var plugin$4 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          Modal: Modal
        });
      }
    });

    function instantiate(Vue, Component, options) {
      if (Component instanceof Vue) {
        return Component;
      }

      if (isObject(Component)) {
        Component = Vue.extend(Component);
      } else if (isString(Component)) {
        var text = Component;
        Component = Vue.extend({
          functional: true,
          render: function render(h, context) {
            return this._v(text);
          }
        });
      }

      return new Component(options);
    }

    function modal$1 (Vue, options) {
      Vue.prototype.$modal = function (Component, options) {
        if (!isObject(options)) {
          options = {};
        }

        var instance = instantiate(Vue, Modal, options.modal);
        instance.$content = instantiate(Vue, Component, options.content);
        instance.$slots.default = [instance.$content.$mount()._vnode];
        instance.$mount(document.body.appendChild(document.createElement('div')));
        return instance;
      };

      Vue.prototype.$alert = function (title, Component, options) {
        var _this = this;

        return new Promise(function (resolve, reject) {
          var modal = _this.$modal(Component, defaultsDeep(options, {
            modal: {
              propsData: {
                title: title,
                type: 'alert'
              }
            }
          }));

          modal.$on('confirm', function (event) {
            modal.close();
          });
          modal.$on('close', function (event) {
            resolve(modal);
          });
        });
      };

      Vue.prototype.$confirm = function (title, Component, options) {
        var _this2 = this;

        return new Promise(function (resolve, reject) {
          var modal = _this2.$modal(Component || title, defaultsDeep(options, {
            modal: {
              propsData: {
                title: Component ? title : null,
                type: 'confirm'
              }
            }
          }));

          modal.$on('cancel', function (event) {
            reject(modal);
          });
          modal.$on('confirm', function (event) {
            resolve(modal.close());
          });
        });
      };

      Vue.prototype.$prompt = function (title, Component, options, predicate) {
        var _this3 = this;

        return new Promise(function (resolve, reject) {
          if (isFunction$1(options)) {
            predicate = options;
            options = {};
          } else if (isObject(options) && isFunction$1(options.predicate)) {
            predicate = options.predicate;
          } else if (!isFunction$1(predicate)) {
            predicate = function predicate() {
              return true;
            };
          }

          var modal = _this3.$modal(Component, defaultsDeep(options, {
            modal: {
              propsData: {
                title: title,
                type: 'prompt'
              }
            }
          }));

          modal.$on('cancel', function (event) {
            reject(modal);
          });
          modal.$on('confirm', function (event) {
            var succeed = function succeed() {
              return resolve(modal.close());
            };

            var fail = function fail() {
              return reject(modal.close());
            };

            if (predicate(modal, succeed, fail) === true) {
              success();
            }
          });
        });
      };
    }

    var OverlayBody = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "overlay-body"
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'overlay-body'
    };

    var Container = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "container"
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'container'
    };

    var plugin$5 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          Container: Container
        });
      }
    });

    var OverlayContent = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('container', {
          staticClass: "overlay-content"
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'overlay-content',
      components: {
        Container: Container
      }
    };

    var Overlay = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "overlay",
          class: _vm.triggerableClasses,
          style: {
            'background': _vm.background,
            'display': _vm.isDisplaying ? 'flex' : 'none'
          },
          attrs: {
            "role": "dialog",
            "tabindex": "-1"
          },
          on: {
            "keydown": function keydown($event) {
              if (!('button' in $event) && _vm._k($event.keyCode, "esc", 27, $event.key, "Escape")) {
                return null;
              }

              return _vm.onEsc($event);
            }
          }
        }, [_vm.closeable && !_vm.hideCloseButton ? _c('button', {
          staticClass: "btn btn-link overlay-close",
          attrs: {
            "type": "button"
          },
          on: {
            "click": _vm.onClickClose
          }
        }, [_c('i', {
          staticClass: "fa fa-times-circle"
        })]) : _vm._e(), _vm._v(" "), _c('overlay-content', {
          class: {
            'overlay-content-fixed': _vm.fixedContent,
            'overlay-content-center': _vm.center
          },
          style: {
            minHeight: _vm.minHeight
          }
        }, [_vm._t("body", [_c('overlay-body', {
          staticClass: "my-4"
        }, [_vm._t("default")], 2)])], 2)], 1);
      },
      staticRenderFns: [],
      name: 'overlay',
      components: {
        OverlayBody: OverlayBody,
        OverlayContent: OverlayContent
      },
      mixins: [Triggerable],
      props: {
        /**
         * The overlay background color.
         *
         * @property String
         */
        background: {
          type: String,
          default: 'rgba(255, 255, 255, .925)'
        },

        /**
         * Is the overlay content fixed position
         *
         * @property Boolean
         */
        closeable: {
          type: Boolean,
          default: true
        },

        /**
         * Center the overlay content on the screen using flex box.
         *
         * @type {Boolean}
         */
        center: {
          type: Boolean,
          default: true
        },

        /**
         * Is the overlay content fixed position
         *
         * @property Boolean
         */
        fixedContent: Boolean,

        /**
         * Is the overlay close button hidden but still closeable.
         *
         * @property Boolean
         */
        hideCloseButton: Boolean,

        /**
         * Is the overlay content minimum height.
         *
         * @property Boolean
         */
        minHeight: [String, Number]
      },
      methods: {
        /**
         * The callback for the `click` event on the close button.
         *
         * @return void
         */
        onClickClose: function onClickClose(event) {
          this.$emit('click:close', event);
          this.close();
        },
        onEsc: function onEsc(event) {
          this.closeable && this.close();
        }
      }
    };

    var plugin$6 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          Overlay: Overlay
        });
      }
    });

    function overlay (Vue, options) {
      Vue.prototype.$overlay = function (target, Component, options) {
        if (!isObject(options)) {
          options = {};
        }

        if (!target.$overlay) {
          target.$overlay = instantiate(Vue, Overlay, defaultsDeep(options.overlay, {
            propsData: {
              target: target
            }
          }));
          target.$overlay.$mount(document.body.appendChild(document.createElement('div')));
          target.$overlay.$content = instantiate(Vue, Component, options.content);
          target.$overlay.$slots.default = [target.$overlay.$content.$mount()._vnode];
          target.$overlay.$nextTick(function () {
            target.$overlay.open();
          });
        }

        return target.$overlay;
      };
    }

    /**!
     * @fileOverview Kickass library to create and place poppers near their reference elements.
     * @version 1.14.3
     * @license
     * Copyright (c) 2016 Federico Zivolo and contributors
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */
    var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';

    var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];
    var timeoutDuration = 0;
    for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
      if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
        timeoutDuration = 1;
        break;
      }
    }

    function microtaskDebounce(fn) {
      var called = false;
      return function () {
        if (called) {
          return;
        }
        called = true;
        window.Promise.resolve().then(function () {
          called = false;
          fn();
        });
      };
    }

    function taskDebounce(fn) {
      var scheduled = false;
      return function () {
        if (!scheduled) {
          scheduled = true;
          setTimeout(function () {
            scheduled = false;
            fn();
          }, timeoutDuration);
        }
      };
    }

    var supportsMicroTasks = isBrowser && window.Promise;

    /**
    * Create a debounced version of a method, that's asynchronously deferred
    * but called in the minimum time possible.
    *
    * @method
    * @memberof Popper.Utils
    * @argument {Function} fn
    * @returns {Function}
    */
    var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;

    /**
     * Check if the given variable is a function
     * @method
     * @memberof Popper.Utils
     * @argument {Any} functionToCheck - variable to check
     * @returns {Boolean} answer to: is a function?
     */
    function isFunction$2(functionToCheck) {
      var getType = {};
      return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
    }

    /**
     * Get CSS computed property of the given element
     * @method
     * @memberof Popper.Utils
     * @argument {Eement} element
     * @argument {String} property
     */
    function getStyleComputedProperty(element, property) {
      if (element.nodeType !== 1) {
        return [];
      }
      // NOTE: 1 DOM access here
      var css = getComputedStyle(element, null);
      return property ? css[property] : css;
    }

    /**
     * Returns the parentNode or the host of the element
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element
     * @returns {Element} parent
     */
    function getParentNode(element) {
      if (element.nodeName === 'HTML') {
        return element;
      }
      return element.parentNode || element.host;
    }

    /**
     * Returns the scrolling parent of the given element
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element
     * @returns {Element} scroll parent
     */
    function getScrollParent(element) {
      // Return body, `getScroll` will take care to get the correct `scrollTop` from it
      if (!element) {
        return document.body;
      }

      switch (element.nodeName) {
        case 'HTML':
        case 'BODY':
          return element.ownerDocument.body;
        case '#document':
          return element.body;
      }

      // Firefox want us to check `-x` and `-y` variations as well

      var _getStyleComputedProp = getStyleComputedProperty(element),
          overflow = _getStyleComputedProp.overflow,
          overflowX = _getStyleComputedProp.overflowX,
          overflowY = _getStyleComputedProp.overflowY;

      if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
        return element;
      }

      return getScrollParent(getParentNode(element));
    }

    var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
    var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);

    /**
     * Determines if the browser is Internet Explorer
     * @method
     * @memberof Popper.Utils
     * @param {Number} version to check
     * @returns {Boolean} isIE
     */
    function isIE(version) {
      if (version === 11) {
        return isIE11;
      }
      if (version === 10) {
        return isIE10;
      }
      return isIE11 || isIE10;
    }

    /**
     * Returns the offset parent of the given element
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element
     * @returns {Element} offset parent
     */
    function getOffsetParent(element) {
      if (!element) {
        return document.documentElement;
      }

      var noOffsetParent = isIE(10) ? document.body : null;

      // NOTE: 1 DOM access here
      var offsetParent = element.offsetParent;
      // Skip hidden elements which don't have an offsetParent
      while (offsetParent === noOffsetParent && element.nextElementSibling) {
        offsetParent = (element = element.nextElementSibling).offsetParent;
      }

      var nodeName = offsetParent && offsetParent.nodeName;

      if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
        return element ? element.ownerDocument.documentElement : document.documentElement;
      }

      // .offsetParent will return the closest TD or TABLE in case
      // no offsetParent is present, I hate this job...
      if (['TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
        return getOffsetParent(offsetParent);
      }

      return offsetParent;
    }

    function isOffsetContainer(element) {
      var nodeName = element.nodeName;

      if (nodeName === 'BODY') {
        return false;
      }
      return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
    }

    /**
     * Finds the root node (document, shadowDOM root) of the given element
     * @method
     * @memberof Popper.Utils
     * @argument {Element} node
     * @returns {Element} root node
     */
    function getRoot(node) {
      if (node.parentNode !== null) {
        return getRoot(node.parentNode);
      }

      return node;
    }

    /**
     * Finds the offset parent common to the two provided nodes
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element1
     * @argument {Element} element2
     * @returns {Element} common offset parent
     */
    function findCommonOffsetParent(element1, element2) {
      // This check is needed to avoid errors in case one of the elements isn't defined for any reason
      if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
        return document.documentElement;
      }

      // Here we make sure to give as "start" the element that comes first in the DOM
      var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
      var start = order ? element1 : element2;
      var end = order ? element2 : element1;

      // Get common ancestor container
      var range = document.createRange();
      range.setStart(start, 0);
      range.setEnd(end, 0);
      var commonAncestorContainer = range.commonAncestorContainer;

      // Both nodes are inside #document

      if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
        if (isOffsetContainer(commonAncestorContainer)) {
          return commonAncestorContainer;
        }

        return getOffsetParent(commonAncestorContainer);
      }

      // one of the nodes is inside shadowDOM, find which one
      var element1root = getRoot(element1);
      if (element1root.host) {
        return findCommonOffsetParent(element1root.host, element2);
      } else {
        return findCommonOffsetParent(element1, getRoot(element2).host);
      }
    }

    /**
     * Gets the scroll value of the given element in the given side (top and left)
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element
     * @argument {String} side `top` or `left`
     * @returns {number} amount of scrolled pixels
     */
    function getScroll(element) {
      var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';

      var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
      var nodeName = element.nodeName;

      if (nodeName === 'BODY' || nodeName === 'HTML') {
        var html = element.ownerDocument.documentElement;
        var scrollingElement = element.ownerDocument.scrollingElement || html;
        return scrollingElement[upperSide];
      }

      return element[upperSide];
    }

    /*
     * Sum or subtract the element scroll values (left and top) from a given rect object
     * @method
     * @memberof Popper.Utils
     * @param {Object} rect - Rect object you want to change
     * @param {HTMLElement} element - The element from the function reads the scroll values
     * @param {Boolean} subtract - set to true if you want to subtract the scroll values
     * @return {Object} rect - The modifier rect object
     */
    function includeScroll(rect, element) {
      var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      var scrollTop = getScroll(element, 'top');
      var scrollLeft = getScroll(element, 'left');
      var modifier = subtract ? -1 : 1;
      rect.top += scrollTop * modifier;
      rect.bottom += scrollTop * modifier;
      rect.left += scrollLeft * modifier;
      rect.right += scrollLeft * modifier;
      return rect;
    }

    /*
     * Helper to detect borders of a given element
     * @method
     * @memberof Popper.Utils
     * @param {CSSStyleDeclaration} styles
     * Result of `getStyleComputedProperty` on the given element
     * @param {String} axis - `x` or `y`
     * @return {number} borders - The borders size of the given axis
     */

    function getBordersSize(styles, axis) {
      var sideA = axis === 'x' ? 'Left' : 'Top';
      var sideB = sideA === 'Left' ? 'Right' : 'Bottom';

      return parseFloat(styles['border' + sideA + 'Width'], 10) + parseFloat(styles['border' + sideB + 'Width'], 10);
    }

    function getSize(axis, body, html, computedStyle) {
      return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? html['offset' + axis] + computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')] + computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')] : 0);
    }

    function getWindowSizes() {
      var body = document.body;
      var html = document.documentElement;
      var computedStyle = isIE(10) && getComputedStyle(html);

      return {
        height: getSize('Height', body, html, computedStyle),
        width: getSize('Width', body, html, computedStyle)
      };
    }

    var classCallCheck = function (instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    };

    var createClass = function () {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();





    var defineProperty$1 = function (obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    };

    var _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    /**
     * Given element offsets, generate an output similar to getBoundingClientRect
     * @method
     * @memberof Popper.Utils
     * @argument {Object} offsets
     * @returns {Object} ClientRect like output
     */
    function getClientRect(offsets) {
      return _extends({}, offsets, {
        right: offsets.left + offsets.width,
        bottom: offsets.top + offsets.height
      });
    }

    /**
     * Get bounding client rect of given element
     * @method
     * @memberof Popper.Utils
     * @param {HTMLElement} element
     * @return {Object} client rect
     */
    function getBoundingClientRect(element) {
      var rect = {};

      // IE10 10 FIX: Please, don't ask, the element isn't
      // considered in DOM in some circumstances...
      // This isn't reproducible in IE10 compatibility mode of IE11
      try {
        if (isIE(10)) {
          rect = element.getBoundingClientRect();
          var scrollTop = getScroll(element, 'top');
          var scrollLeft = getScroll(element, 'left');
          rect.top += scrollTop;
          rect.left += scrollLeft;
          rect.bottom += scrollTop;
          rect.right += scrollLeft;
        } else {
          rect = element.getBoundingClientRect();
        }
      } catch (e) {}

      var result = {
        left: rect.left,
        top: rect.top,
        width: rect.right - rect.left,
        height: rect.bottom - rect.top
      };

      // subtract scrollbar size from sizes
      var sizes = element.nodeName === 'HTML' ? getWindowSizes() : {};
      var width = sizes.width || element.clientWidth || result.right - result.left;
      var height = sizes.height || element.clientHeight || result.bottom - result.top;

      var horizScrollbar = element.offsetWidth - width;
      var vertScrollbar = element.offsetHeight - height;

      // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
      // we make this check conditional for performance reasons
      if (horizScrollbar || vertScrollbar) {
        var styles = getStyleComputedProperty(element);
        horizScrollbar -= getBordersSize(styles, 'x');
        vertScrollbar -= getBordersSize(styles, 'y');

        result.width -= horizScrollbar;
        result.height -= vertScrollbar;
      }

      return getClientRect(result);
    }

    function getOffsetRectRelativeToArbitraryNode(children, parent) {
      var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      var isIE10 = isIE(10);
      var isHTML = parent.nodeName === 'HTML';
      var childrenRect = getBoundingClientRect(children);
      var parentRect = getBoundingClientRect(parent);
      var scrollParent = getScrollParent(children);

      var styles = getStyleComputedProperty(parent);
      var borderTopWidth = parseFloat(styles.borderTopWidth, 10);
      var borderLeftWidth = parseFloat(styles.borderLeftWidth, 10);

      // In cases where the parent is fixed, we must ignore negative scroll in offset calc
      if (fixedPosition && parent.nodeName === 'HTML') {
        parentRect.top = Math.max(parentRect.top, 0);
        parentRect.left = Math.max(parentRect.left, 0);
      }
      var offsets = getClientRect({
        top: childrenRect.top - parentRect.top - borderTopWidth,
        left: childrenRect.left - parentRect.left - borderLeftWidth,
        width: childrenRect.width,
        height: childrenRect.height
      });
      offsets.marginTop = 0;
      offsets.marginLeft = 0;

      // Subtract margins of documentElement in case it's being used as parent
      // we do this only on HTML because it's the only element that behaves
      // differently when margins are applied to it. The margins are included in
      // the box of the documentElement, in the other cases not.
      if (!isIE10 && isHTML) {
        var marginTop = parseFloat(styles.marginTop, 10);
        var marginLeft = parseFloat(styles.marginLeft, 10);

        offsets.top -= borderTopWidth - marginTop;
        offsets.bottom -= borderTopWidth - marginTop;
        offsets.left -= borderLeftWidth - marginLeft;
        offsets.right -= borderLeftWidth - marginLeft;

        // Attach marginTop and marginLeft because in some circumstances we may need them
        offsets.marginTop = marginTop;
        offsets.marginLeft = marginLeft;
      }

      if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
        offsets = includeScroll(offsets, parent);
      }

      return offsets;
    }

    function getViewportOffsetRectRelativeToArtbitraryNode(element) {
      var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      var html = element.ownerDocument.documentElement;
      var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
      var width = Math.max(html.clientWidth, window.innerWidth || 0);
      var height = Math.max(html.clientHeight, window.innerHeight || 0);

      var scrollTop = !excludeScroll ? getScroll(html) : 0;
      var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;

      var offset = {
        top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
        left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
        width: width,
        height: height
      };

      return getClientRect(offset);
    }

    /**
     * Check if the given element is fixed or is inside a fixed parent
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element
     * @argument {Element} customContainer
     * @returns {Boolean} answer to "isFixed?"
     */
    function isFixed(element) {
      var nodeName = element.nodeName;
      if (nodeName === 'BODY' || nodeName === 'HTML') {
        return false;
      }
      if (getStyleComputedProperty(element, 'position') === 'fixed') {
        return true;
      }
      return isFixed(getParentNode(element));
    }

    /**
     * Finds the first parent of an element that has a transformed property defined
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element
     * @returns {Element} first transformed parent or documentElement
     */

    function getFixedPositionOffsetParent(element) {
      // This check is needed to avoid errors in case one of the elements isn't defined for any reason
      if (!element || !element.parentElement || isIE()) {
        return document.documentElement;
      }
      var el = element.parentElement;
      while (el && getStyleComputedProperty(el, 'transform') === 'none') {
        el = el.parentElement;
      }
      return el || document.documentElement;
    }

    /**
     * Computed the boundaries limits and return them
     * @method
     * @memberof Popper.Utils
     * @param {HTMLElement} popper
     * @param {HTMLElement} reference
     * @param {number} padding
     * @param {HTMLElement} boundariesElement - Element used to define the boundaries
     * @param {Boolean} fixedPosition - Is in fixed position mode
     * @returns {Object} Coordinates of the boundaries
     */
    function getBoundaries(popper, reference, padding, boundariesElement) {
      var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

      // NOTE: 1 DOM access here

      var boundaries = { top: 0, left: 0 };
      var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);

      // Handle viewport case
      if (boundariesElement === 'viewport') {
        boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
      } else {
        // Handle other cases based on DOM element used as boundaries
        var boundariesNode = void 0;
        if (boundariesElement === 'scrollParent') {
          boundariesNode = getScrollParent(getParentNode(reference));
          if (boundariesNode.nodeName === 'BODY') {
            boundariesNode = popper.ownerDocument.documentElement;
          }
        } else if (boundariesElement === 'window') {
          boundariesNode = popper.ownerDocument.documentElement;
        } else {
          boundariesNode = boundariesElement;
        }

        var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);

        // In case of HTML, we need a different computation
        if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
          var _getWindowSizes = getWindowSizes(),
              height = _getWindowSizes.height,
              width = _getWindowSizes.width;

          boundaries.top += offsets.top - offsets.marginTop;
          boundaries.bottom = height + offsets.top;
          boundaries.left += offsets.left - offsets.marginLeft;
          boundaries.right = width + offsets.left;
        } else {
          // for all the other DOM elements, this one is good
          boundaries = offsets;
        }
      }

      // Add paddings
      boundaries.left += padding;
      boundaries.top += padding;
      boundaries.right -= padding;
      boundaries.bottom -= padding;

      return boundaries;
    }

    function getArea(_ref) {
      var width = _ref.width,
          height = _ref.height;

      return width * height;
    }

    /**
     * Utility used to transform the `auto` placement to the placement with more
     * available space.
     * @method
     * @memberof Popper.Utils
     * @argument {Object} data - The data object generated by update method
     * @argument {Object} options - Modifiers configuration and options
     * @returns {Object} The data object, properly modified
     */
    function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
      var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

      if (placement.indexOf('auto') === -1) {
        return placement;
      }

      var boundaries = getBoundaries(popper, reference, padding, boundariesElement);

      var rects = {
        top: {
          width: boundaries.width,
          height: refRect.top - boundaries.top
        },
        right: {
          width: boundaries.right - refRect.right,
          height: boundaries.height
        },
        bottom: {
          width: boundaries.width,
          height: boundaries.bottom - refRect.bottom
        },
        left: {
          width: refRect.left - boundaries.left,
          height: boundaries.height
        }
      };

      var sortedAreas = Object.keys(rects).map(function (key) {
        return _extends({
          key: key
        }, rects[key], {
          area: getArea(rects[key])
        });
      }).sort(function (a, b) {
        return b.area - a.area;
      });

      var filteredAreas = sortedAreas.filter(function (_ref2) {
        var width = _ref2.width,
            height = _ref2.height;
        return width >= popper.clientWidth && height >= popper.clientHeight;
      });

      var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;

      var variation = placement.split('-')[1];

      return computedPlacement + (variation ? '-' + variation : '');
    }

    /**
     * Get offsets to the reference element
     * @method
     * @memberof Popper.Utils
     * @param {Object} state
     * @param {Element} popper - the popper element
     * @param {Element} reference - the reference element (the popper will be relative to this)
     * @param {Element} fixedPosition - is in fixed position mode
     * @returns {Object} An object containing the offsets which will be applied to the popper
     */
    function getReferenceOffsets(state, popper, reference) {
      var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

      var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);
      return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
    }

    /**
     * Get the outer sizes of the given element (offset size + margins)
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element
     * @returns {Object} object containing width and height properties
     */
    function getOuterSizes(element) {
      var styles = getComputedStyle(element);
      var x = parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);
      var y = parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);
      var result = {
        width: element.offsetWidth + y,
        height: element.offsetHeight + x
      };
      return result;
    }

    /**
     * Get the opposite placement of the given one
     * @method
     * @memberof Popper.Utils
     * @argument {String} placement
     * @returns {String} flipped placement
     */
    function getOppositePlacement(placement) {
      var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };
      return placement.replace(/left|right|bottom|top/g, function (matched) {
        return hash[matched];
      });
    }

    /**
     * Get offsets to the popper
     * @method
     * @memberof Popper.Utils
     * @param {Object} position - CSS position the Popper will get applied
     * @param {HTMLElement} popper - the popper element
     * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
     * @param {String} placement - one of the valid placement options
     * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
     */
    function getPopperOffsets(popper, referenceOffsets, placement) {
      placement = placement.split('-')[0];

      // Get popper node sizes
      var popperRect = getOuterSizes(popper);

      // Add position, width and height to our offsets object
      var popperOffsets = {
        width: popperRect.width,
        height: popperRect.height
      };

      // depending by the popper placement we have to compute its offsets slightly differently
      var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
      var mainSide = isHoriz ? 'top' : 'left';
      var secondarySide = isHoriz ? 'left' : 'top';
      var measurement = isHoriz ? 'height' : 'width';
      var secondaryMeasurement = !isHoriz ? 'height' : 'width';

      popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
      if (placement === secondarySide) {
        popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
      } else {
        popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
      }

      return popperOffsets;
    }

    /**
     * Mimics the `find` method of Array
     * @method
     * @memberof Popper.Utils
     * @argument {Array} arr
     * @argument prop
     * @argument value
     * @returns index or -1
     */
    function find(arr, check) {
      // use native find if supported
      if (Array.prototype.find) {
        return arr.find(check);
      }

      // use `filter` to obtain the same behavior of `find`
      return arr.filter(check)[0];
    }

    /**
     * Return the index of the matching object
     * @method
     * @memberof Popper.Utils
     * @argument {Array} arr
     * @argument prop
     * @argument value
     * @returns index or -1
     */
    function findIndex(arr, prop, value) {
      // use native findIndex if supported
      if (Array.prototype.findIndex) {
        return arr.findIndex(function (cur) {
          return cur[prop] === value;
        });
      }

      // use `find` + `indexOf` if `findIndex` isn't supported
      var match = find(arr, function (obj) {
        return obj[prop] === value;
      });
      return arr.indexOf(match);
    }

    /**
     * Loop trough the list of modifiers and run them in order,
     * each of them will then edit the data object.
     * @method
     * @memberof Popper.Utils
     * @param {dataObject} data
     * @param {Array} modifiers
     * @param {String} ends - Optional modifier name used as stopper
     * @returns {dataObject}
     */
    function runModifiers(modifiers, data, ends) {
      var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));

      modifiersToRun.forEach(function (modifier) {
        if (modifier['function']) {
          // eslint-disable-line dot-notation
          console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
        }
        var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation
        if (modifier.enabled && isFunction$2(fn)) {
          // Add properties to offsets to make them a complete clientRect object
          // we do this before each modifier to make sure the previous one doesn't
          // mess with these values
          data.offsets.popper = getClientRect(data.offsets.popper);
          data.offsets.reference = getClientRect(data.offsets.reference);

          data = fn(data, modifier);
        }
      });

      return data;
    }

    /**
     * Updates the position of the popper, computing the new offsets and applying
     * the new style.<br />
     * Prefer `scheduleUpdate` over `update` because of performance reasons.
     * @method
     * @memberof Popper
     */
    function update() {
      // if popper is destroyed, don't perform any further update
      if (this.state.isDestroyed) {
        return;
      }

      var data = {
        instance: this,
        styles: {},
        arrowStyles: {},
        attributes: {},
        flipped: false,
        offsets: {}
      };

      // compute reference element offsets
      data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);

      // compute auto placement, store placement inside the data object,
      // modifiers will be able to edit `placement` if needed
      // and refer to originalPlacement to know the original value
      data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);

      // store the computed placement inside `originalPlacement`
      data.originalPlacement = data.placement;

      data.positionFixed = this.options.positionFixed;

      // compute the popper offsets
      data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);

      data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';

      // run the modifiers
      data = runModifiers(this.modifiers, data);

      // the first `update` will call `onCreate` callback
      // the other ones will call `onUpdate` callback
      if (!this.state.isCreated) {
        this.state.isCreated = true;
        this.options.onCreate(data);
      } else {
        this.options.onUpdate(data);
      }
    }

    /**
     * Helper used to know if the given modifier is enabled.
     * @method
     * @memberof Popper.Utils
     * @returns {Boolean}
     */
    function isModifierEnabled(modifiers, modifierName) {
      return modifiers.some(function (_ref) {
        var name = _ref.name,
            enabled = _ref.enabled;
        return enabled && name === modifierName;
      });
    }

    /**
     * Get the prefixed supported property name
     * @method
     * @memberof Popper.Utils
     * @argument {String} property (camelCase)
     * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
     */
    function getSupportedPropertyName(property) {
      var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
      var upperProp = property.charAt(0).toUpperCase() + property.slice(1);

      for (var i = 0; i < prefixes.length; i++) {
        var prefix = prefixes[i];
        var toCheck = prefix ? '' + prefix + upperProp : property;
        if (typeof document.body.style[toCheck] !== 'undefined') {
          return toCheck;
        }
      }
      return null;
    }

    /**
     * Destroy the popper
     * @method
     * @memberof Popper
     */
    function destroy() {
      this.state.isDestroyed = true;

      // touch DOM only if `applyStyle` modifier is enabled
      if (isModifierEnabled(this.modifiers, 'applyStyle')) {
        this.popper.removeAttribute('x-placement');
        this.popper.style.position = '';
        this.popper.style.top = '';
        this.popper.style.left = '';
        this.popper.style.right = '';
        this.popper.style.bottom = '';
        this.popper.style.willChange = '';
        this.popper.style[getSupportedPropertyName('transform')] = '';
      }

      this.disableEventListeners();

      // remove the popper if user explicity asked for the deletion on destroy
      // do not use `remove` because IE11 doesn't support it
      if (this.options.removeOnDestroy) {
        this.popper.parentNode.removeChild(this.popper);
      }
      return this;
    }

    /**
     * Get the window associated with the element
     * @argument {Element} element
     * @returns {Window}
     */
    function getWindow(element) {
      var ownerDocument = element.ownerDocument;
      return ownerDocument ? ownerDocument.defaultView : window;
    }

    function attachToScrollParents(scrollParent, event, callback, scrollParents) {
      var isBody = scrollParent.nodeName === 'BODY';
      var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
      target.addEventListener(event, callback, { passive: true });

      if (!isBody) {
        attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
      }
      scrollParents.push(target);
    }

    /**
     * Setup needed event listeners used to update the popper position
     * @method
     * @memberof Popper.Utils
     * @private
     */
    function setupEventListeners(reference, options, state, updateBound) {
      // Resize event listener on window
      state.updateBound = updateBound;
      getWindow(reference).addEventListener('resize', state.updateBound, { passive: true });

      // Scroll event listener on scroll parents
      var scrollElement = getScrollParent(reference);
      attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
      state.scrollElement = scrollElement;
      state.eventsEnabled = true;

      return state;
    }

    /**
     * It will add resize/scroll events and start recalculating
     * position of the popper element when they are triggered.
     * @method
     * @memberof Popper
     */
    function enableEventListeners() {
      if (!this.state.eventsEnabled) {
        this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
      }
    }

    /**
     * Remove event listeners used to update the popper position
     * @method
     * @memberof Popper.Utils
     * @private
     */
    function removeEventListeners(reference, state) {
      // Remove resize event listener on window
      getWindow(reference).removeEventListener('resize', state.updateBound);

      // Remove scroll event listener on scroll parents
      state.scrollParents.forEach(function (target) {
        target.removeEventListener('scroll', state.updateBound);
      });

      // Reset state
      state.updateBound = null;
      state.scrollParents = [];
      state.scrollElement = null;
      state.eventsEnabled = false;
      return state;
    }

    /**
     * It will remove resize/scroll events and won't recalculate popper position
     * when they are triggered. It also won't trigger onUpdate callback anymore,
     * unless you call `update` method manually.
     * @method
     * @memberof Popper
     */
    function disableEventListeners() {
      if (this.state.eventsEnabled) {
        cancelAnimationFrame(this.scheduleUpdate);
        this.state = removeEventListeners(this.reference, this.state);
      }
    }

    /**
     * Tells if a given input is a number
     * @method
     * @memberof Popper.Utils
     * @param {*} input to check
     * @return {Boolean}
     */
    function isNumeric(n) {
      return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
    }

    /**
     * Set the style to the given popper
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element - Element to apply the style to
     * @argument {Object} styles
     * Object with a list of properties and values which will be applied to the element
     */
    function setStyles(element, styles) {
      Object.keys(styles).forEach(function (prop) {
        var unit = '';
        // add unit if the value is numeric and is one of the following
        if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
          unit = 'px';
        }
        element.style[prop] = styles[prop] + unit;
      });
    }

    /**
     * Set the attributes to the given popper
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element - Element to apply the attributes to
     * @argument {Object} styles
     * Object with a list of properties and values which will be applied to the element
     */
    function setAttributes(element, attributes) {
      Object.keys(attributes).forEach(function (prop) {
        var value = attributes[prop];
        if (value !== false) {
          element.setAttribute(prop, attributes[prop]);
        } else {
          element.removeAttribute(prop);
        }
      });
    }

    /**
     * @function
     * @memberof Modifiers
     * @argument {Object} data - The data object generated by `update` method
     * @argument {Object} data.styles - List of style properties - values to apply to popper element
     * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
     * @argument {Object} options - Modifiers configuration and options
     * @returns {Object} The same data object
     */
    function applyStyle(data) {
      // any property present in `data.styles` will be applied to the popper,
      // in this way we can make the 3rd party modifiers add custom styles to it
      // Be aware, modifiers could override the properties defined in the previous
      // lines of this modifier!
      setStyles(data.instance.popper, data.styles);

      // any property present in `data.attributes` will be applied to the popper,
      // they will be set as HTML attributes of the element
      setAttributes(data.instance.popper, data.attributes);

      // if arrowElement is defined and arrowStyles has some properties
      if (data.arrowElement && Object.keys(data.arrowStyles).length) {
        setStyles(data.arrowElement, data.arrowStyles);
      }

      return data;
    }

    /**
     * Set the x-placement attribute before everything else because it could be used
     * to add margins to the popper margins needs to be calculated to get the
     * correct popper offsets.
     * @method
     * @memberof Popper.modifiers
     * @param {HTMLElement} reference - The reference element used to position the popper
     * @param {HTMLElement} popper - The HTML element used as popper
     * @param {Object} options - Popper.js options
     */
    function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
      // compute reference element offsets
      var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);

      // compute auto placement, store placement inside the data object,
      // modifiers will be able to edit `placement` if needed
      // and refer to originalPlacement to know the original value
      var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);

      popper.setAttribute('x-placement', placement);

      // Apply `position` to popper before anything else because
      // without the position applied we can't guarantee correct computations
      setStyles(popper, { position: options.positionFixed ? 'fixed' : 'absolute' });

      return options;
    }

    /**
     * @function
     * @memberof Modifiers
     * @argument {Object} data - The data object generated by `update` method
     * @argument {Object} options - Modifiers configuration and options
     * @returns {Object} The data object, properly modified
     */
    function computeStyle(data, options) {
      var x = options.x,
          y = options.y;
      var popper = data.offsets.popper;

      // Remove this legacy support in Popper.js v2

      var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
        return modifier.name === 'applyStyle';
      }).gpuAcceleration;
      if (legacyGpuAccelerationOption !== undefined) {
        console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
      }
      var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;

      var offsetParent = getOffsetParent(data.instance.popper);
      var offsetParentRect = getBoundingClientRect(offsetParent);

      // Styles
      var styles = {
        position: popper.position
      };

      // Avoid blurry text by using full pixel integers.
      // For pixel-perfect positioning, top/bottom prefers rounded
      // values, while left/right prefers floored values.
      var offsets = {
        left: Math.floor(popper.left),
        top: Math.round(popper.top),
        bottom: Math.round(popper.bottom),
        right: Math.floor(popper.right)
      };

      var sideA = x === 'bottom' ? 'top' : 'bottom';
      var sideB = y === 'right' ? 'left' : 'right';

      // if gpuAcceleration is set to `true` and transform is supported,
      //  we use `translate3d` to apply the position to the popper we
      // automatically use the supported prefixed version if needed
      var prefixedProperty = getSupportedPropertyName('transform');

      // now, let's make a step back and look at this code closely (wtf?)
      // If the content of the popper grows once it's been positioned, it
      // may happen that the popper gets misplaced because of the new content
      // overflowing its reference element
      // To avoid this problem, we provide two options (x and y), which allow
      // the consumer to define the offset origin.
      // If we position a popper on top of a reference element, we can set
      // `x` to `top` to make the popper grow towards its top instead of
      // its bottom.
      var left = void 0,
          top = void 0;
      if (sideA === 'bottom') {
        top = -offsetParentRect.height + offsets.bottom;
      } else {
        top = offsets.top;
      }
      if (sideB === 'right') {
        left = -offsetParentRect.width + offsets.right;
      } else {
        left = offsets.left;
      }
      if (gpuAcceleration && prefixedProperty) {
        styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
        styles[sideA] = 0;
        styles[sideB] = 0;
        styles.willChange = 'transform';
      } else {
        // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
        var invertTop = sideA === 'bottom' ? -1 : 1;
        var invertLeft = sideB === 'right' ? -1 : 1;
        styles[sideA] = top * invertTop;
        styles[sideB] = left * invertLeft;
        styles.willChange = sideA + ', ' + sideB;
      }

      // Attributes
      var attributes = {
        'x-placement': data.placement
      };

      // Update `data` attributes, styles and arrowStyles
      data.attributes = _extends({}, attributes, data.attributes);
      data.styles = _extends({}, styles, data.styles);
      data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);

      return data;
    }

    /**
     * Helper used to know if the given modifier depends from another one.<br />
     * It checks if the needed modifier is listed and enabled.
     * @method
     * @memberof Popper.Utils
     * @param {Array} modifiers - list of modifiers
     * @param {String} requestingName - name of requesting modifier
     * @param {String} requestedName - name of requested modifier
     * @returns {Boolean}
     */
    function isModifierRequired(modifiers, requestingName, requestedName) {
      var requesting = find(modifiers, function (_ref) {
        var name = _ref.name;
        return name === requestingName;
      });

      var isRequired = !!requesting && modifiers.some(function (modifier) {
        return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
      });

      if (!isRequired) {
        var _requesting = '`' + requestingName + '`';
        var requested = '`' + requestedName + '`';
        console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
      }
      return isRequired;
    }

    /**
     * @function
     * @memberof Modifiers
     * @argument {Object} data - The data object generated by update method
     * @argument {Object} options - Modifiers configuration and options
     * @returns {Object} The data object, properly modified
     */
    function arrow(data, options) {
      var _data$offsets$arrow;

      // arrow depends on keepTogether in order to work
      if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
        return data;
      }

      var arrowElement = options.element;

      // if arrowElement is a string, suppose it's a CSS selector
      if (typeof arrowElement === 'string') {
        arrowElement = data.instance.popper.querySelector(arrowElement);

        // if arrowElement is not found, don't run the modifier
        if (!arrowElement) {
          return data;
        }
      } else {
        // if the arrowElement isn't a query selector we must check that the
        // provided DOM node is child of its popper node
        if (!data.instance.popper.contains(arrowElement)) {
          console.warn('WARNING: `arrow.element` must be child of its popper element!');
          return data;
        }
      }

      var placement = data.placement.split('-')[0];
      var _data$offsets = data.offsets,
          popper = _data$offsets.popper,
          reference = _data$offsets.reference;

      var isVertical = ['left', 'right'].indexOf(placement) !== -1;

      var len = isVertical ? 'height' : 'width';
      var sideCapitalized = isVertical ? 'Top' : 'Left';
      var side = sideCapitalized.toLowerCase();
      var altSide = isVertical ? 'left' : 'top';
      var opSide = isVertical ? 'bottom' : 'right';
      var arrowElementSize = getOuterSizes(arrowElement)[len];

      //
      // extends keepTogether behavior making sure the popper and its
      // reference have enough pixels in conjuction
      //

      // top/left side
      if (reference[opSide] - arrowElementSize < popper[side]) {
        data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
      }
      // bottom/right side
      if (reference[side] + arrowElementSize > popper[opSide]) {
        data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
      }
      data.offsets.popper = getClientRect(data.offsets.popper);

      // compute center of the popper
      var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;

      // Compute the sideValue using the updated popper offsets
      // take popper margin in account because we don't have this info available
      var css = getStyleComputedProperty(data.instance.popper);
      var popperMarginSide = parseFloat(css['margin' + sideCapitalized], 10);
      var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width'], 10);
      var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;

      // prevent arrowElement from being placed not contiguously to its popper
      sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);

      data.arrowElement = arrowElement;
      data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty$1(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty$1(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);

      return data;
    }

    /**
     * Get the opposite placement variation of the given one
     * @method
     * @memberof Popper.Utils
     * @argument {String} placement variation
     * @returns {String} flipped placement variation
     */
    function getOppositeVariation(variation) {
      if (variation === 'end') {
        return 'start';
      } else if (variation === 'start') {
        return 'end';
      }
      return variation;
    }

    /**
     * List of accepted placements to use as values of the `placement` option.<br />
     * Valid placements are:
     * - `auto`
     * - `top`
     * - `right`
     * - `bottom`
     * - `left`
     *
     * Each placement can have a variation from this list:
     * - `-start`
     * - `-end`
     *
     * Variations are interpreted easily if you think of them as the left to right
     * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
     * is right.<br />
     * Vertically (`left` and `right`), `start` is top and `end` is bottom.
     *
     * Some valid examples are:
     * - `top-end` (on top of reference, right aligned)
     * - `right-start` (on right of reference, top aligned)
     * - `bottom` (on bottom, centered)
     * - `auto-right` (on the side with more space available, alignment depends by placement)
     *
     * @static
     * @type {Array}
     * @enum {String}
     * @readonly
     * @method placements
     * @memberof Popper
     */
    var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];

    // Get rid of `auto` `auto-start` and `auto-end`
    var validPlacements = placements.slice(3);

    /**
     * Given an initial placement, returns all the subsequent placements
     * clockwise (or counter-clockwise).
     *
     * @method
     * @memberof Popper.Utils
     * @argument {String} placement - A valid placement (it accepts variations)
     * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
     * @returns {Array} placements including their variations
     */
    function clockwise(placement) {
      var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      var index = validPlacements.indexOf(placement);
      var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
      return counter ? arr.reverse() : arr;
    }

    var BEHAVIORS = {
      FLIP: 'flip',
      CLOCKWISE: 'clockwise',
      COUNTERCLOCKWISE: 'counterclockwise'
    };

    /**
     * @function
     * @memberof Modifiers
     * @argument {Object} data - The data object generated by update method
     * @argument {Object} options - Modifiers configuration and options
     * @returns {Object} The data object, properly modified
     */
    function flip(data, options) {
      // if `inner` modifier is enabled, we can't use the `flip` modifier
      if (isModifierEnabled(data.instance.modifiers, 'inner')) {
        return data;
      }

      if (data.flipped && data.placement === data.originalPlacement) {
        // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
        return data;
      }

      var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);

      var placement = data.placement.split('-')[0];
      var placementOpposite = getOppositePlacement(placement);
      var variation = data.placement.split('-')[1] || '';

      var flipOrder = [];

      switch (options.behavior) {
        case BEHAVIORS.FLIP:
          flipOrder = [placement, placementOpposite];
          break;
        case BEHAVIORS.CLOCKWISE:
          flipOrder = clockwise(placement);
          break;
        case BEHAVIORS.COUNTERCLOCKWISE:
          flipOrder = clockwise(placement, true);
          break;
        default:
          flipOrder = options.behavior;
      }

      flipOrder.forEach(function (step, index) {
        if (placement !== step || flipOrder.length === index + 1) {
          return data;
        }

        placement = data.placement.split('-')[0];
        placementOpposite = getOppositePlacement(placement);

        var popperOffsets = data.offsets.popper;
        var refOffsets = data.offsets.reference;

        // using floor because the reference offsets may contain decimals we are not going to consider here
        var floor = Math.floor;
        var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);

        var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
        var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
        var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
        var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);

        var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;

        // flip the variation if required
        var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
        var flippedVariation = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);

        if (overlapsRef || overflowsBoundaries || flippedVariation) {
          // this boolean to detect any flip loop
          data.flipped = true;

          if (overlapsRef || overflowsBoundaries) {
            placement = flipOrder[index + 1];
          }

          if (flippedVariation) {
            variation = getOppositeVariation(variation);
          }

          data.placement = placement + (variation ? '-' + variation : '');

          // this object contains `position`, we want to preserve it along with
          // any additional property we may add in the future
          data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));

          data = runModifiers(data.instance.modifiers, data, 'flip');
        }
      });
      return data;
    }

    /**
     * @function
     * @memberof Modifiers
     * @argument {Object} data - The data object generated by update method
     * @argument {Object} options - Modifiers configuration and options
     * @returns {Object} The data object, properly modified
     */
    function keepTogether(data) {
      var _data$offsets = data.offsets,
          popper = _data$offsets.popper,
          reference = _data$offsets.reference;

      var placement = data.placement.split('-')[0];
      var floor = Math.floor;
      var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
      var side = isVertical ? 'right' : 'bottom';
      var opSide = isVertical ? 'left' : 'top';
      var measurement = isVertical ? 'width' : 'height';

      if (popper[side] < floor(reference[opSide])) {
        data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
      }
      if (popper[opSide] > floor(reference[side])) {
        data.offsets.popper[opSide] = floor(reference[side]);
      }

      return data;
    }

    /**
     * Converts a string containing value + unit into a px value number
     * @function
     * @memberof {modifiers~offset}
     * @private
     * @argument {String} str - Value + unit string
     * @argument {String} measurement - `height` or `width`
     * @argument {Object} popperOffsets
     * @argument {Object} referenceOffsets
     * @returns {Number|String}
     * Value in pixels, or original string if no values were extracted
     */
    function toValue(str, measurement, popperOffsets, referenceOffsets) {
      // separate value from unit
      var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
      var value = +split[1];
      var unit = split[2];

      // If it's not a number it's an operator, I guess
      if (!value) {
        return str;
      }

      if (unit.indexOf('%') === 0) {
        var element = void 0;
        switch (unit) {
          case '%p':
            element = popperOffsets;
            break;
          case '%':
          case '%r':
          default:
            element = referenceOffsets;
        }

        var rect = getClientRect(element);
        return rect[measurement] / 100 * value;
      } else if (unit === 'vh' || unit === 'vw') {
        // if is a vh or vw, we calculate the size based on the viewport
        var size = void 0;
        if (unit === 'vh') {
          size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
        } else {
          size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
        }
        return size / 100 * value;
      } else {
        // if is an explicit pixel unit, we get rid of the unit and keep the value
        // if is an implicit unit, it's px, and we return just the value
        return value;
      }
    }

    /**
     * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
     * @function
     * @memberof {modifiers~offset}
     * @private
     * @argument {String} offset
     * @argument {Object} popperOffsets
     * @argument {Object} referenceOffsets
     * @argument {String} basePlacement
     * @returns {Array} a two cells array with x and y offsets in numbers
     */
    function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
      var offsets = [0, 0];

      // Use height if placement is left or right and index is 0 otherwise use width
      // in this way the first offset will use an axis and the second one
      // will use the other one
      var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;

      // Split the offset string to obtain a list of values and operands
      // The regex addresses values with the plus or minus sign in front (+10, -20, etc)
      var fragments = offset.split(/(\+|\-)/).map(function (frag) {
        return frag.trim();
      });

      // Detect if the offset string contains a pair of values or a single one
      // they could be separated by comma or space
      var divider = fragments.indexOf(find(fragments, function (frag) {
        return frag.search(/,|\s/) !== -1;
      }));

      if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
        console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
      }

      // If divider is found, we divide the list of values and operands to divide
      // them by ofset X and Y.
      var splitRegex = /\s*,\s*|\s+/;
      var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];

      // Convert the values with units to absolute pixels to allow our computations
      ops = ops.map(function (op, index) {
        // Most of the units rely on the orientation of the popper
        var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
        var mergeWithPrevious = false;
        return op
        // This aggregates any `+` or `-` sign that aren't considered operators
        // e.g.: 10 + +5 => [10, +, +5]
        .reduce(function (a, b) {
          if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
            a[a.length - 1] = b;
            mergeWithPrevious = true;
            return a;
          } else if (mergeWithPrevious) {
            a[a.length - 1] += b;
            mergeWithPrevious = false;
            return a;
          } else {
            return a.concat(b);
          }
        }, [])
        // Here we convert the string values into number values (in px)
        .map(function (str) {
          return toValue(str, measurement, popperOffsets, referenceOffsets);
        });
      });

      // Loop trough the offsets arrays and execute the operations
      ops.forEach(function (op, index) {
        op.forEach(function (frag, index2) {
          if (isNumeric(frag)) {
            offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
          }
        });
      });
      return offsets;
    }

    /**
     * @function
     * @memberof Modifiers
     * @argument {Object} data - The data object generated by update method
     * @argument {Object} options - Modifiers configuration and options
     * @argument {Number|String} options.offset=0
     * The offset value as described in the modifier description
     * @returns {Object} The data object, properly modified
     */
    function offset(data, _ref) {
      var offset = _ref.offset;
      var placement = data.placement,
          _data$offsets = data.offsets,
          popper = _data$offsets.popper,
          reference = _data$offsets.reference;

      var basePlacement = placement.split('-')[0];

      var offsets = void 0;
      if (isNumeric(+offset)) {
        offsets = [+offset, 0];
      } else {
        offsets = parseOffset(offset, popper, reference, basePlacement);
      }

      if (basePlacement === 'left') {
        popper.top += offsets[0];
        popper.left -= offsets[1];
      } else if (basePlacement === 'right') {
        popper.top += offsets[0];
        popper.left += offsets[1];
      } else if (basePlacement === 'top') {
        popper.left += offsets[0];
        popper.top -= offsets[1];
      } else if (basePlacement === 'bottom') {
        popper.left += offsets[0];
        popper.top += offsets[1];
      }

      data.popper = popper;
      return data;
    }

    /**
     * @function
     * @memberof Modifiers
     * @argument {Object} data - The data object generated by `update` method
     * @argument {Object} options - Modifiers configuration and options
     * @returns {Object} The data object, properly modified
     */
    function preventOverflow(data, options) {
      var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);

      // If offsetParent is the reference element, we really want to
      // go one step up and use the next offsetParent as reference to
      // avoid to make this modifier completely useless and look like broken
      if (data.instance.reference === boundariesElement) {
        boundariesElement = getOffsetParent(boundariesElement);
      }

      // NOTE: DOM access here
      // resets the popper's position so that the document size can be calculated excluding
      // the size of the popper element itself
      var transformProp = getSupportedPropertyName('transform');
      var popperStyles = data.instance.popper.style; // assignment to help minification
      var top = popperStyles.top,
          left = popperStyles.left,
          transform = popperStyles[transformProp];

      popperStyles.top = '';
      popperStyles.left = '';
      popperStyles[transformProp] = '';

      var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);

      // NOTE: DOM access here
      // restores the original style properties after the offsets have been computed
      popperStyles.top = top;
      popperStyles.left = left;
      popperStyles[transformProp] = transform;

      options.boundaries = boundaries;

      var order = options.priority;
      var popper = data.offsets.popper;

      var check = {
        primary: function primary(placement) {
          var value = popper[placement];
          if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
            value = Math.max(popper[placement], boundaries[placement]);
          }
          return defineProperty$1({}, placement, value);
        },
        secondary: function secondary(placement) {
          var mainSide = placement === 'right' ? 'left' : 'top';
          var value = popper[mainSide];
          if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
            value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
          }
          return defineProperty$1({}, mainSide, value);
        }
      };

      order.forEach(function (placement) {
        var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
        popper = _extends({}, popper, check[side](placement));
      });

      data.offsets.popper = popper;

      return data;
    }

    /**
     * @function
     * @memberof Modifiers
     * @argument {Object} data - The data object generated by `update` method
     * @argument {Object} options - Modifiers configuration and options
     * @returns {Object} The data object, properly modified
     */
    function shift(data) {
      var placement = data.placement;
      var basePlacement = placement.split('-')[0];
      var shiftvariation = placement.split('-')[1];

      // if shift shiftvariation is specified, run the modifier
      if (shiftvariation) {
        var _data$offsets = data.offsets,
            reference = _data$offsets.reference,
            popper = _data$offsets.popper;

        var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
        var side = isVertical ? 'left' : 'top';
        var measurement = isVertical ? 'width' : 'height';

        var shiftOffsets = {
          start: defineProperty$1({}, side, reference[side]),
          end: defineProperty$1({}, side, reference[side] + reference[measurement] - popper[measurement])
        };

        data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
      }

      return data;
    }

    /**
     * @function
     * @memberof Modifiers
     * @argument {Object} data - The data object generated by update method
     * @argument {Object} options - Modifiers configuration and options
     * @returns {Object} The data object, properly modified
     */
    function hide(data) {
      if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
        return data;
      }

      var refRect = data.offsets.reference;
      var bound = find(data.instance.modifiers, function (modifier) {
        return modifier.name === 'preventOverflow';
      }).boundaries;

      if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
        // Avoid unnecessary DOM access if visibility hasn't changed
        if (data.hide === true) {
          return data;
        }

        data.hide = true;
        data.attributes['x-out-of-boundaries'] = '';
      } else {
        // Avoid unnecessary DOM access if visibility hasn't changed
        if (data.hide === false) {
          return data;
        }

        data.hide = false;
        data.attributes['x-out-of-boundaries'] = false;
      }

      return data;
    }

    /**
     * @function
     * @memberof Modifiers
     * @argument {Object} data - The data object generated by `update` method
     * @argument {Object} options - Modifiers configuration and options
     * @returns {Object} The data object, properly modified
     */
    function inner(data) {
      var placement = data.placement;
      var basePlacement = placement.split('-')[0];
      var _data$offsets = data.offsets,
          popper = _data$offsets.popper,
          reference = _data$offsets.reference;

      var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;

      var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;

      popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);

      data.placement = getOppositePlacement(placement);
      data.offsets.popper = getClientRect(popper);

      return data;
    }

    /**
     * Modifier function, each modifier can have a function of this type assigned
     * to its `fn` property.<br />
     * These functions will be called on each update, this means that you must
     * make sure they are performant enough to avoid performance bottlenecks.
     *
     * @function ModifierFn
     * @argument {dataObject} data - The data object generated by `update` method
     * @argument {Object} options - Modifiers configuration and options
     * @returns {dataObject} The data object, properly modified
     */

    /**
     * Modifiers are plugins used to alter the behavior of your poppers.<br />
     * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
     * needed by the library.
     *
     * Usually you don't want to override the `order`, `fn` and `onLoad` props.
     * All the other properties are configurations that could be tweaked.
     * @namespace modifiers
     */
    var modifiers = {
      /**
       * Modifier used to shift the popper on the start or end of its reference
       * element.<br />
       * It will read the variation of the `placement` property.<br />
       * It can be one either `-end` or `-start`.
       * @memberof modifiers
       * @inner
       */
      shift: {
        /** @prop {number} order=100 - Index used to define the order of execution */
        order: 100,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: shift
      },

      /**
       * The `offset` modifier can shift your popper on both its axis.
       *
       * It accepts the following units:
       * - `px` or unitless, interpreted as pixels
       * - `%` or `%r`, percentage relative to the length of the reference element
       * - `%p`, percentage relative to the length of the popper element
       * - `vw`, CSS viewport width unit
       * - `vh`, CSS viewport height unit
       *
       * For length is intended the main axis relative to the placement of the popper.<br />
       * This means that if the placement is `top` or `bottom`, the length will be the
       * `width`. In case of `left` or `right`, it will be the height.
       *
       * You can provide a single value (as `Number` or `String`), or a pair of values
       * as `String` divided by a comma or one (or more) white spaces.<br />
       * The latter is a deprecated method because it leads to confusion and will be
       * removed in v2.<br />
       * Additionally, it accepts additions and subtractions between different units.
       * Note that multiplications and divisions aren't supported.
       *
       * Valid examples are:
       * ```
       * 10
       * '10%'
       * '10, 10'
       * '10%, 10'
       * '10 + 10%'
       * '10 - 5vh + 3%'
       * '-10px + 5vh, 5px - 6%'
       * ```
       * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
       * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
       * > More on this [reading this issue](https://github.com/FezVrasta/popper.js/issues/373)
       *
       * @memberof modifiers
       * @inner
       */
      offset: {
        /** @prop {number} order=200 - Index used to define the order of execution */
        order: 200,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: offset,
        /** @prop {Number|String} offset=0
         * The offset value as described in the modifier description
         */
        offset: 0
      },

      /**
       * Modifier used to prevent the popper from being positioned outside the boundary.
       *
       * An scenario exists where the reference itself is not within the boundaries.<br />
       * We can say it has "escaped the boundaries"  or just "escaped".<br />
       * In this case we need to decide whether the popper should either:
       *
       * - detach from the reference and remain "trapped" in the boundaries, or
       * - if it should ignore the boundary and "escape with its reference"
       *
       * When `escapeWithReference` is set to`true` and reference is completely
       * outside its boundaries, the popper will overflow (or completely leave)
       * the boundaries in order to remain attached to the edge of the reference.
       *
       * @memberof modifiers
       * @inner
       */
      preventOverflow: {
        /** @prop {number} order=300 - Index used to define the order of execution */
        order: 300,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: preventOverflow,
        /**
         * @prop {Array} [priority=['left','right','top','bottom']]
         * Popper will try to prevent overflow following these priorities by default,
         * then, it could overflow on the left and on top of the `boundariesElement`
         */
        priority: ['left', 'right', 'top', 'bottom'],
        /**
         * @prop {number} padding=5
         * Amount of pixel used to define a minimum distance between the boundaries
         * and the popper this makes sure the popper has always a little padding
         * between the edges of its container
         */
        padding: 5,
        /**
         * @prop {String|HTMLElement} boundariesElement='scrollParent'
         * Boundaries used by the modifier, can be `scrollParent`, `window`,
         * `viewport` or any DOM element.
         */
        boundariesElement: 'scrollParent'
      },

      /**
       * Modifier used to make sure the reference and its popper stay near eachothers
       * without leaving any gap between the two. Expecially useful when the arrow is
       * enabled and you want to assure it to point to its reference element.
       * It cares only about the first axis, you can still have poppers with margin
       * between the popper and its reference element.
       * @memberof modifiers
       * @inner
       */
      keepTogether: {
        /** @prop {number} order=400 - Index used to define the order of execution */
        order: 400,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: keepTogether
      },

      /**
       * This modifier is used to move the `arrowElement` of the popper to make
       * sure it is positioned between the reference element and its popper element.
       * It will read the outer size of the `arrowElement` node to detect how many
       * pixels of conjuction are needed.
       *
       * It has no effect if no `arrowElement` is provided.
       * @memberof modifiers
       * @inner
       */
      arrow: {
        /** @prop {number} order=500 - Index used to define the order of execution */
        order: 500,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: arrow,
        /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
        element: '[x-arrow]'
      },

      /**
       * Modifier used to flip the popper's placement when it starts to overlap its
       * reference element.
       *
       * Requires the `preventOverflow` modifier before it in order to work.
       *
       * **NOTE:** this modifier will interrupt the current update cycle and will
       * restart it if it detects the need to flip the placement.
       * @memberof modifiers
       * @inner
       */
      flip: {
        /** @prop {number} order=600 - Index used to define the order of execution */
        order: 600,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: flip,
        /**
         * @prop {String|Array} behavior='flip'
         * The behavior used to change the popper's placement. It can be one of
         * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
         * placements (with optional variations).
         */
        behavior: 'flip',
        /**
         * @prop {number} padding=5
         * The popper will flip if it hits the edges of the `boundariesElement`
         */
        padding: 5,
        /**
         * @prop {String|HTMLElement} boundariesElement='viewport'
         * The element which will define the boundaries of the popper position,
         * the popper will never be placed outside of the defined boundaries
         * (except if keepTogether is enabled)
         */
        boundariesElement: 'viewport'
      },

      /**
       * Modifier used to make the popper flow toward the inner of the reference element.
       * By default, when this modifier is disabled, the popper will be placed outside
       * the reference element.
       * @memberof modifiers
       * @inner
       */
      inner: {
        /** @prop {number} order=700 - Index used to define the order of execution */
        order: 700,
        /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
        enabled: false,
        /** @prop {ModifierFn} */
        fn: inner
      },

      /**
       * Modifier used to hide the popper when its reference element is outside of the
       * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
       * be used to hide with a CSS selector the popper when its reference is
       * out of boundaries.
       *
       * Requires the `preventOverflow` modifier before it in order to work.
       * @memberof modifiers
       * @inner
       */
      hide: {
        /** @prop {number} order=800 - Index used to define the order of execution */
        order: 800,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: hide
      },

      /**
       * Computes the style that will be applied to the popper element to gets
       * properly positioned.
       *
       * Note that this modifier will not touch the DOM, it just prepares the styles
       * so that `applyStyle` modifier can apply it. This separation is useful
       * in case you need to replace `applyStyle` with a custom implementation.
       *
       * This modifier has `850` as `order` value to maintain backward compatibility
       * with previous versions of Popper.js. Expect the modifiers ordering method
       * to change in future major versions of the library.
       *
       * @memberof modifiers
       * @inner
       */
      computeStyle: {
        /** @prop {number} order=850 - Index used to define the order of execution */
        order: 850,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: computeStyle,
        /**
         * @prop {Boolean} gpuAcceleration=true
         * If true, it uses the CSS 3d transformation to position the popper.
         * Otherwise, it will use the `top` and `left` properties.
         */
        gpuAcceleration: true,
        /**
         * @prop {string} [x='bottom']
         * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
         * Change this if your popper should grow in a direction different from `bottom`
         */
        x: 'bottom',
        /**
         * @prop {string} [x='left']
         * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
         * Change this if your popper should grow in a direction different from `right`
         */
        y: 'right'
      },

      /**
       * Applies the computed styles to the popper element.
       *
       * All the DOM manipulations are limited to this modifier. This is useful in case
       * you want to integrate Popper.js inside a framework or view library and you
       * want to delegate all the DOM manipulations to it.
       *
       * Note that if you disable this modifier, you must make sure the popper element
       * has its position set to `absolute` before Popper.js can do its work!
       *
       * Just disable this modifier and define you own to achieve the desired effect.
       *
       * @memberof modifiers
       * @inner
       */
      applyStyle: {
        /** @prop {number} order=900 - Index used to define the order of execution */
        order: 900,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: applyStyle,
        /** @prop {Function} */
        onLoad: applyStyleOnLoad,
        /**
         * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
         * @prop {Boolean} gpuAcceleration=true
         * If true, it uses the CSS 3d transformation to position the popper.
         * Otherwise, it will use the `top` and `left` properties.
         */
        gpuAcceleration: undefined
      }
    };

    /**
     * The `dataObject` is an object containing all the informations used by Popper.js
     * this object get passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
     * @name dataObject
     * @property {Object} data.instance The Popper.js instance
     * @property {String} data.placement Placement applied to popper
     * @property {String} data.originalPlacement Placement originally defined on init
     * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
     * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper.
     * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
     * @property {Object} data.styles Any CSS property defined here will be applied to the popper, it expects the JavaScript nomenclature (eg. `marginBottom`)
     * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow, it expects the JavaScript nomenclature (eg. `marginBottom`)
     * @property {Object} data.boundaries Offsets of the popper boundaries
     * @property {Object} data.offsets The measurements of popper, reference and arrow elements.
     * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
     * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
     * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
     */

    /**
     * Default options provided to Popper.js constructor.<br />
     * These can be overriden using the `options` argument of Popper.js.<br />
     * To override an option, simply pass as 3rd argument an object with the same
     * structure of this object, example:
     * ```
     * new Popper(ref, pop, {
     *   modifiers: {
     *     preventOverflow: { enabled: false }
     *   }
     * })
     * ```
     * @type {Object}
     * @static
     * @memberof Popper
     */
    var Defaults = {
      /**
       * Popper's placement
       * @prop {Popper.placements} placement='bottom'
       */
      placement: 'bottom',

      /**
       * Set this to true if you want popper to position it self in 'fixed' mode
       * @prop {Boolean} positionFixed=false
       */
      positionFixed: false,

      /**
       * Whether events (resize, scroll) are initially enabled
       * @prop {Boolean} eventsEnabled=true
       */
      eventsEnabled: true,

      /**
       * Set to true if you want to automatically remove the popper when
       * you call the `destroy` method.
       * @prop {Boolean} removeOnDestroy=false
       */
      removeOnDestroy: false,

      /**
       * Callback called when the popper is created.<br />
       * By default, is set to no-op.<br />
       * Access Popper.js instance with `data.instance`.
       * @prop {onCreate}
       */
      onCreate: function onCreate() {},

      /**
       * Callback called when the popper is updated, this callback is not called
       * on the initialization/creation of the popper, but only on subsequent
       * updates.<br />
       * By default, is set to no-op.<br />
       * Access Popper.js instance with `data.instance`.
       * @prop {onUpdate}
       */
      onUpdate: function onUpdate() {},

      /**
       * List of modifiers used to modify the offsets before they are applied to the popper.
       * They provide most of the functionalities of Popper.js
       * @prop {modifiers}
       */
      modifiers: modifiers
    };

    /**
     * @callback onCreate
     * @param {dataObject} data
     */

    /**
     * @callback onUpdate
     * @param {dataObject} data
     */

    // Utils
    // Methods
    var Popper = function () {
      /**
       * Create a new Popper.js instance
       * @class Popper
       * @param {HTMLElement|referenceObject} reference - The reference element used to position the popper
       * @param {HTMLElement} popper - The HTML element used as popper.
       * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
       * @return {Object} instance - The generated Popper.js instance
       */
      function Popper(reference, popper) {
        var _this = this;

        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        classCallCheck(this, Popper);

        this.scheduleUpdate = function () {
          return requestAnimationFrame(_this.update);
        };

        // make update() debounced, so that it only runs at most once-per-tick
        this.update = debounce(this.update.bind(this));

        // with {} we create a new object with the options inside it
        this.options = _extends({}, Popper.Defaults, options);

        // init state
        this.state = {
          isDestroyed: false,
          isCreated: false,
          scrollParents: []
        };

        // get reference and popper elements (allow jQuery wrappers)
        this.reference = reference && reference.jquery ? reference[0] : reference;
        this.popper = popper && popper.jquery ? popper[0] : popper;

        // Deep merge modifiers options
        this.options.modifiers = {};
        Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
          _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
        });

        // Refactoring modifiers' list (Object => Array)
        this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
          return _extends({
            name: name
          }, _this.options.modifiers[name]);
        })
        // sort the modifiers by order
        .sort(function (a, b) {
          return a.order - b.order;
        });

        // modifiers have the ability to execute arbitrary code when Popper.js get inited
        // such code is executed in the same order of its modifier
        // they could add new properties to their options configuration
        // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!
        this.modifiers.forEach(function (modifierOptions) {
          if (modifierOptions.enabled && isFunction$2(modifierOptions.onLoad)) {
            modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
          }
        });

        // fire the first update to position the popper in the right place
        this.update();

        var eventsEnabled = this.options.eventsEnabled;
        if (eventsEnabled) {
          // setup event listeners, they will take care of update the position in specific situations
          this.enableEventListeners();
        }

        this.state.eventsEnabled = eventsEnabled;
      }

      // We can't use class properties because they don't get listed in the
      // class prototype and break stuff like Sinon stubs


      createClass(Popper, [{
        key: 'update',
        value: function update$$1() {
          return update.call(this);
        }
      }, {
        key: 'destroy',
        value: function destroy$$1() {
          return destroy.call(this);
        }
      }, {
        key: 'enableEventListeners',
        value: function enableEventListeners$$1() {
          return enableEventListeners.call(this);
        }
      }, {
        key: 'disableEventListeners',
        value: function disableEventListeners$$1() {
          return disableEventListeners.call(this);
        }

        /**
         * Schedule an update, it will run on the next UI update available
         * @method scheduleUpdate
         * @memberof Popper
         */


        /**
         * Collection of utilities useful when writing custom modifiers.
         * Starting from version 1.7, this method is available only if you
         * include `popper-utils.js` before `popper.js`.
         *
         * **DEPRECATION**: This way to access PopperUtils is deprecated
         * and will be removed in v2! Use the PopperUtils module directly instead.
         * Due to the high instability of the methods contained in Utils, we can't
         * guarantee them to follow semver. Use them at your own risk!
         * @static
         * @private
         * @type {Object}
         * @deprecated since version 1.8
         * @member Utils
         * @memberof Popper
         */

      }]);
      return Popper;
    }();

    /**
     * The `referenceObject` is an object that provides an interface compatible with Popper.js
     * and lets you use it as replacement of a real DOM node.<br />
     * You can use this method to position a popper relatively to a set of coordinates
     * in case you don't have a DOM node to use as reference.
     *
     * ```
     * new Popper(referenceObject, popperNode);
     * ```
     *
     * NB: This feature isn't supported in Internet Explorer 10
     * @name referenceObject
     * @property {Function} data.getBoundingClientRect
     * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
     * @property {number} data.clientWidth
     * An ES6 getter that will return the width of the virtual reference element.
     * @property {number} data.clientHeight
     * An ES6 getter that will return the height of the virtual reference element.
     */


    Popper.Utils = (typeof window !== 'undefined' ? window : global$1).PopperUtils;
    Popper.placements = placements;
    Popper.Defaults = Defaults;
    //# sourceMappingURL=popper.js.map

    var Popover = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          directives: [{
            name: "show",
            rawName: "v-show",
            value: _vm.isDisplaying,
            expression: "isDisplaying"
          }],
          staticClass: "popover",
          class: _vm.mergeClasses(_vm.triggerableClasses, _vm.classes),
          attrs: {
            "role": "tooltip"
          }
        }, [_c('div', {
          staticClass: "arrow"
        }), _vm._v(" "), _vm.title ? _c('popover-header', {
          domProps: {
            "innerHTML": _vm._s(_vm.title)
          }
        }) : _vm._e(), _vm._v(" "), _c('popover-body', [_vm._t("default")], 2)], 1);
      },
      staticRenderFns: [],
      name: 'popover',
      mixins: [Triggerable, MergeClasses],
      props: {
        /**
         * Apply a CSS fade transition to the popover
         *
         * @type {Boolean}
         */
        animation: {
          type: Boolean,
          default: true
        },

        /**
         * Overflow constraint boundary of the popover. Accepts the values of
         * 'viewport', 'window', 'scrollParent', or an HTMLElement reference
         * (JavaScript only). For more information refer to Popper.js's
         * preventOverflow docs.
         *
         * @type {Object}
         */
        boundary: {
          type: [String, Array],
          default: 'scrollParent',
          validate: function validate(value) {
            return ['viewport', 'window', 'viewport'].indexOf(value) !== -1;
          }
        },

        /**
         * Appends the popover to a specific element.
         *
         * Example: container: 'body'.
         *
         * This option is particularly useful in that it allows you to position
         * the popover in the flow of the document near the triggering element -
         * which will prevent the popover from floating away from thetriggering
         * element during a window resize.
         *
         * @type {String|Element|Boolean}
         */
        container: {
          type: [String, Element, Boolean],
          default: false
        },

        /**
         * Delay closeing and hiding the popover (ms) - does not apply to manual trigger type
         *
         * If a number is supplied, delay is applied to both open/close
         *
         * Object structure is: delay: { "close": 500, "open": 100 }
         *
         * @type {Number|Object}
         */
        delay: {
          type: [Number, Object],
          default: 0
        },

        /**
         * Allow to specify which position Popper will use on fallback. For more
         * information refer to Popper.js's behavior docs
         *
         * @type {String|Array}
         */
        fallbackPlacement: {
          type: [String, Array],
          default: 'flip'
        },

        /**
         * Offset of the popover relative to its target. For more information
         * refer to Popper.js's offset docs.
         *
         * @type {Number|String}
         */
        offset: {
          type: [Number, String],
          default: 0
        },

        /**
         * How to position the popover - auto | top | bottom | left | right.
         *
         * When auto is specified, it will dynamically reorient the popover.
         *
         * When a function is used to determine the placement, it is called with
         * the popover DOM node as its first argument and the triggering element
         * DOM node as its second. The this context is set to the popover
         * instance.
         *
         * @type {String|Function}
         */
        placement: {
          type: [String, Function],
          default: 'top',
          validate: function validate(value) {
            return ['auto', 'top', 'bottom', 'left', 'right'].indexOf(value) !== -1;
          }
        },

        /**
         * If this property is passed, it will force the popover to be visible
         * by default.
         *
         * @type {Boolean}
         */
        show: Boolean,

        /**
         * If a selector is provided, popover objects will be delegated to the
         * specified targets. In practice, this is used to enable dynamic HTML
         * content to have popovers added. See this and an informative example.
         *
         * @type {Boolean|String}
         */
        selector: {
          type: [Boolean, String],
          default: false
        },

        /**
         * The target element used to position the popover.
         *
         * @type {String|Element|Boolean}
         */
        target: {
          type: [String, Element, Boolean],
          default: false
        },

        /**
         * The popover title
         *
         * @type {String}
         */
        title: String,

        /**
         * How popover is triggered - click | hover | focus | manual. You may
         * pass multiple triggers; separate them with a space. `manual` cannot
         * be combined with any other trigger.
         *
         * @type {String}
         */
        trigger: {
          type: [String, Array],
          default: 'click'
        }
      },
      methods: {
        align: function align() {
          forEach(this.$poppers, function (el) {
            el.popper.update();
          });
        },
        createPopper: function createPopper(el) {
          return new Popper(el, this.$el, {
            offset: this.offset,
            placement: this.placement,
            modifiers: {
              flip: {
                boundariesElement: this.container,
                behavior: this.fallbackPlacement
              },
              offset: {
                enabled: !!this.offset,
                offset: this.offset
              },
              arrow: {
                enable: true,
                element: this.$el.querySelector('.arrow')
              }
            }
          });
        },
        getArrowElement: function getArrowElement() {
          return this.$el.querySelector('.arrow');
        },

        /**
         * Initialize the trigger event for the specified elements
         *
         * @param  {Element} el
         * @return {void}
         */
        initializeTrigger: function initializeTrigger(el) {
          var _this = this;

          this.$poppers[el] = {
            trigger: isString(this.trigger) ? this.trigger.split(' ') : this.trigger,
            popper: this.createPopper(el),
            event: function event(_event) {
              _this.toggle();

              _this.$poppers[el].popper.update();
            }
          };

          forEach(this.$poppers[el].trigger, function (trigger) {
            el.addEventListener(trigger, _this.$poppers[el].event);
          });
        }
      },
      watch: {
        isShowing: function isShowing(value) {
          var _this2 = this;

          this.$nextTick(function () {
            _this2.align();

            if (value) {
              _this2.focus();
            }
          });
        }
      },
      computed: {
        classes: function classes() {
          return prefix({
            'top': this.placement === 'top',
            'bottom': this.placement === 'bottom',
            'left': this.placement === 'left',
            'right': this.placement === 'right'
          }, 'bs-popover');
        }
      },
      beforeCreate: function beforeCreate() {
        if (!this.$poppers) {
          this.$poppers = {};
        }
      }
    };

    var PopoverBody = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "popover-body"
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'popover-body'
    };

    var PopoverHeader = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c(_vm.tag, {
          tag: "component",
          staticClass: "popover-header"
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'popover-header',
      props: {
        /**
         * The component HTML element
         *
         * @type {String}
         */
        tag: {
          type: String,
          default: 'h3'
        }
      }
    };

    var plugin$7 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          Popover: Popover,
          PopoverBody: PopoverBody,
          PopoverHeader: PopoverHeader
        });
      }
    });

    function popover (Vue, options) {
      Vue.prototype.$popover = function (target, Component, options) {
        if (!isObject(options)) {
          options = {};
        }

        if (!target.$popover) {
          target.$popover = instantiate(Vue, Popover, defaultsDeep(options.popover, {
            propsData: {
              target: target
            }
          }));
          target.$popover.$mount(document.body.appendChild(document.createElement('div')));
          var content = instantiate(Vue, Component, options.content);
          target.$popover.$slots.default = [content.$mount()._vnode];
          target.$popover.$nextTick(function () {
            target.$popover.open();
          });
        }

        return target.$popover;
      };
    }



    var plugins$1 = /*#__PURE__*/Object.freeze({
        modal: modal$1,
        overlay: overlay,
        popover: popover
    });

    var AlertClose = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('button', {
          staticClass: "close",
          attrs: {
            "type": "button",
            "data-dismiss": "alert",
            "aria-label": "Close"
          },
          on: {
            "click": _vm.onClick
          }
        }, [_c('span', {
          attrs: {
            "aria-hidden": "true"
          }
        }, [_vm._v("")])]);
      },
      staticRenderFns: [],
      name: 'alert-close',
      methods: {
        onClick: function onClick(event) {
          this.$emit('click', event);
        }
      }
    };

    var AlertHeading = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('h4', {
          staticClass: "alert-heading"
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'alert-heading'
    };

    var ProgressBar = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "progress",
          style: {
            'height': _vm.formattedHeight
          }
        }, [_c('div', {
          staticClass: "progress-bar",
          class: _vm.mergeClasses(_vm.progressClasses, _vm.variantClass),
          style: _vm.styles,
          attrs: {
            "role": "progressbar",
            "aria-valuenow": _vm.offsetValue,
            "aria-valuemin": _vm.min,
            "aria-valuemax": _vm.max
          }
        }, [!!_vm.label ? _c('span', [_vm.label !== true ? [_vm._v(_vm._s(_vm.label))] : _vm._e(), _vm._v(" " + _vm._s(_vm.offsetValue) + "%")], 2) : _c('span', [_vm._t("default")], 2)])]);
      },
      staticRenderFns: [],
      name: 'progress-bar',
      mixins: [Variant, MergeClasses],
      props: {
        /**
         * A custom color to be applied inline in the styles vs a contextual
         * variant.
         *
         * @property String
         */
        color: String,

        /**
         * The progress bar percentage value
         *
         * @property String
         */
        value: {
          type: Number,
          required: true
        },

        /**
         * The height of the progress bar
         *
         * @property String
         */
        height: [Number, String],

        /**
         * Show the progress bar value as a label inside the bar
         *
         * @property String
         */
        label: [String, Boolean],

        /**
         * Should the progress bar appear with stripes
         *
         * @property String
         */
        striped: Boolean,

        /**
         * Should the progress bar appear with animated stripes
         *
         * @property String
         */
        animated: Boolean,

        /**
         * The minimum value
         *
         * @property String
         */
        min: {
          type: Number,
          default: 0
        },

        /**
         * The max value
         *
         * @property String
         */
        max: {
          type: Number,
          default: 100
        }
      },
      computed: {
        variantClassPrefix: function variantClassPrefix() {
          return 'bg';
        },
        offsetValue: function offsetValue() {
          return this.value / this.max * 100;
        },
        formattedHeight: function formattedHeight() {
          return this.height ? unit(this.height) : null;
        },
        progressClasses: function progressClasses() {
          return {
            'progress-bar-striped': this.striped,
            'progress-bar-animated': this.animated
          };
        },
        styles: function styles() {
          return {
            width: "".concat(this.offsetValue, "%"),
            background: "".concat(this.color, " !important")
          };
        }
      }
    };

    var plugin$8 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          ProgressBar: ProgressBar
        });
      }
    });

    var Alert = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "alert",
          class: _vm.mergeClasses(_vm.variantClass, {
            show: _vm.isVisible,
            fade: _vm.fade
          }),
          attrs: {
            "role": "alert"
          }
        }, [_vm.title || _vm.heading ? _c('alert-heading', [_vm._v(_vm._s(_vm.title || _vm.heading))]) : _vm._e(), _vm._v(" "), _vm._t("default"), _vm._v(" "), _vm.dismissible ? _c('alert-close', {
          on: {
            "click": function click($event) {
              _vm.dismiss();
            }
          }
        }) : _vm._e(), _vm._v(" "), typeof _vm.show === 'number' ? _c('progress-bar', {
          staticClass: "my-3",
          attrs: {
            "variant": _vm.variant,
            "height": 5,
            "value": _vm.dismissCount,
            "max": _vm.show
          }
        }) : _vm._e()], 2);
      },
      staticRenderFns: [],
      name: 'alert',
      components: {
        AlertClose: AlertClose,
        AlertHeading: AlertHeading,
        ProgressBar: ProgressBar
      },
      mixins: [Variant, MergeClasses],
      props: {
        /**
         * Is the alert dismissible
         *
         * @property Boolean
         */
        dismissible: Boolean,

        /**
         * The alert's title/heading
         *
         * @property Boolean
         */
        heading: String,

        /**
         * The alert's title/heading
         *
         * @property Boolean
         */
        title: String,

        /**
         * Should the alert fade when hidden
         *
         * @property Boolean
         */
        fade: {
          type: Boolean,
          default: true
        },

        /**
         * Should the alert be visible by default. If passed a number, alert
         * will be shown for the number of seconds that are passed.
         *
         * @property Boolean
         */
        show: {
          type: [Number, Boolean],
          default: true
        }
      },
      methods: {
        dismiss: function dismiss() {
          var _this = this;

          transition(this.$el).then(function (delay) {
            _this.$emit('dismissed');
          });
          this.$emit('update:visible', this.isVisible = false);
        }
      },
      mounted: function mounted() {
        var _this2 = this;

        if (typeof this.show === 'number') {
          var el = this.$el.querySelector('.progress-bar');
          this.$emit('dismiss-countdown', this.dismissCount = this.show);
          var interval = setInterval(function () {
            _this2.$emit('dismiss-countdown', _this2.dismissCount -= 1);

            if (!_this2.dismissCount) {
              clearInterval(interval);
              transition(el).then(function (delay) {
                return _this2.dismiss();
              });
            }
          }, 1000);
        }
      },
      data: function data() {
        return {
          dismissCount: this.show,
          isVisible: this.show
        };
      }
    };

    var AlertLink = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('a', {
          staticClass: "alert-link"
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'alert-link'
    };

    var plugin$9 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          Alert: Alert,
          AlertLink: AlertLink,
          AlertClose: AlertClose,
          AlertHeading: AlertHeading
        });
      }
    });

    var Badge = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _vm.href ? _c('a', {
          staticClass: "badge",
          class: _vm.mergeClasses(_vm.classes, _vm.variantClass),
          attrs: {
            "href": _vm.href
          }
        }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))]), _vm._v(" "), _c('span', {
          staticClass: "sr-only",
          domProps: {
            "innerHTML": _vm._s(_vm.accessibility)
          }
        })], 2) : _c('span', {
          staticClass: "badge",
          class: _vm.mergeClasses(_vm.classes, _vm.variantClass)
        }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))]), _vm._v(" "), _c('span', {
          staticClass: "sr-only",
          domProps: {
            "innerHTML": _vm._s(_vm.accessibility)
          }
        })], 2);
      },
      staticRenderFns: [],
      name: 'badge',
      mixins: [Variant, MergeClasses],
      props: {
        /**
         * The screen reader accessibility label.
         *
         * @property String
         */
        accessibility: String,

        /**
         * If an href attribute is passed, the badge becomes an anchor.
         *
         * @property String
         */
        href: String,

        /**
         * The badge appear as pill shaped.
         *
         * @property String
         */
        pill: Boolean,

        /**
         * The badge label.
         *
         * @property String
         */
        label: [Number, String],

        /**
         * The badge appear as secondary in size to the parent element.
         *
         * @property String
         */
        secondary: Boolean
      },
      computed: {
        classes: function classes() {
          return prefix({
            'pill': this.pill,
            'secondary': this.secondary
          }, this.$options.name);
        }
      }
    };

    var plugin$10 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          Badge: Badge
        });
      }
    });

    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      return Constructor;
    }

    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }

    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }

      return _assertThisInitialized(self);
    }

    /**
     * The base implementation of `_.reduce` and `_.reduceRight`, without support
     * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} accumulator The initial value.
     * @param {boolean} initAccum Specify using the first or last element of
     *  `collection` as the initial value.
     * @param {Function} eachFunc The function to iterate over `collection`.
     * @returns {*} Returns the accumulated value.
     */
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function(value, index, collection) {
        accumulator = initAccum
          ? (initAccum = false, value)
          : iteratee(accumulator, value, index, collection);
      });
      return accumulator;
    }

    /**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` thru `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not given, the first element of `collection` is used as the initial
     * value. The iteratee is invoked with four arguments:
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
     * and `sortBy`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduceRight
     * @example
     *
     * _.reduce([1, 2], function(sum, n) {
     *   return sum + n;
     * }, 0);
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     *   return result;
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
     */
    function reduce(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduce : baseReduce,
          initAccum = arguments.length < 3;

      return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);
    }

    /**
     * Gets the size of an ASCII `string`.
     *
     * @private
     * @param {string} string The string inspect.
     * @returns {number} Returns the string size.
     */
    var asciiSize = baseProperty('length');

    /** Used to compose unicode character classes. */
    var rsAstralRange$3 = '\\ud800-\\udfff',
        rsComboMarksRange$4 = '\\u0300-\\u036f',
        reComboHalfMarksRange$4 = '\\ufe20-\\ufe2f',
        rsComboSymbolsRange$4 = '\\u20d0-\\u20ff',
        rsComboRange$4 = rsComboMarksRange$4 + reComboHalfMarksRange$4 + rsComboSymbolsRange$4,
        rsVarRange$3 = '\\ufe0e\\ufe0f';

    /** Used to compose unicode capture groups. */
    var rsAstral$1 = '[' + rsAstralRange$3 + ']',
        rsCombo$3 = '[' + rsComboRange$4 + ']',
        rsFitz$2 = '\\ud83c[\\udffb-\\udfff]',
        rsModifier$2 = '(?:' + rsCombo$3 + '|' + rsFitz$2 + ')',
        rsNonAstral$2 = '[^' + rsAstralRange$3 + ']',
        rsRegional$2 = '(?:\\ud83c[\\udde6-\\uddff]){2}',
        rsSurrPair$2 = '[\\ud800-\\udbff][\\udc00-\\udfff]',
        rsZWJ$3 = '\\u200d';

    /** Used to compose unicode regexes. */
    var reOptMod$2 = rsModifier$2 + '?',
        rsOptVar$2 = '[' + rsVarRange$3 + ']?',
        rsOptJoin$2 = '(?:' + rsZWJ$3 + '(?:' + [rsNonAstral$2, rsRegional$2, rsSurrPair$2].join('|') + ')' + rsOptVar$2 + reOptMod$2 + ')*',
        rsSeq$2 = rsOptVar$2 + reOptMod$2 + rsOptJoin$2,
        rsSymbol$1 = '(?:' + [rsNonAstral$2 + rsCombo$3 + '?', rsCombo$3, rsRegional$2, rsSurrPair$2, rsAstral$1].join('|') + ')';

    /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
    var reUnicode$1 = RegExp(rsFitz$2 + '(?=' + rsFitz$2 + ')|' + rsSymbol$1 + rsSeq$2, 'g');

    /**
     * Gets the size of a Unicode `string`.
     *
     * @private
     * @param {string} string The string inspect.
     * @returns {number} Returns the string size.
     */
    function unicodeSize(string) {
      var result = reUnicode$1.lastIndex = 0;
      while (reUnicode$1.test(string)) {
        ++result;
      }
      return result;
    }

    /**
     * Gets the number of symbols in `string`.
     *
     * @private
     * @param {string} string The string to inspect.
     * @returns {number} Returns the string size.
     */
    function stringSize(string) {
      return hasUnicode(string)
        ? unicodeSize(string)
        : asciiSize(string);
    }

    /** `Object#toString` result references. */
    var mapTag$3 = '[object Map]',
        setTag$3 = '[object Set]';

    /**
     * Gets the size of `collection` by returning its length for array-like
     * values or the number of own enumerable string keyed properties for objects.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns the collection size.
     * @example
     *
     * _.size([1, 2, 3]);
     * // => 3
     *
     * _.size({ 'a': 1, 'b': 2 });
     * // => 2
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      if (collection == null) {
        return 0;
      }
      if (isArrayLike(collection)) {
        return isString(collection) ? stringSize(collection) : collection.length;
      }
      var tag = getTag$1(collection);
      if (tag == mapTag$3 || tag == setTag$3) {
        return collection.size;
      }
      return baseKeys(collection).length;
    }

    /**
     * The base implementation of `_.assign` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }

    /**
     * The base implementation of `_.assignIn` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssignIn(object, source) {
      return object && copyObject(source, keysIn$1(source), object);
    }

    /**
     * Copies own symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }

    /**
     * Copies own and inherited symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbolsIn(source, object) {
      return copyObject(source, getSymbolsIn(source), object);
    }

    /** Used for built-in method references. */
    var objectProto$15 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$12 = objectProto$15.hasOwnProperty;

    /**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */
    function initCloneArray(array) {
      var length = array.length,
          result = new array.constructor(length);

      // Add properties assigned by `RegExp#exec`.
      if (length && typeof array[0] == 'string' && hasOwnProperty$12.call(array, 'index')) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }

    /**
     * Creates a clone of `dataView`.
     *
     * @private
     * @param {Object} dataView The data view to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned data view.
     */
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }

    /** Used to match `RegExp` flags from their coerced string values. */
    var reFlags = /\w*$/;

    /**
     * Creates a clone of `regexp`.
     *
     * @private
     * @param {Object} regexp The regexp to clone.
     * @returns {Object} Returns the cloned regexp.
     */
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }

    /** Used to convert symbols to primitives and strings. */
    var symbolProto$2 = Symbol$1 ? Symbol$1.prototype : undefined,
        symbolValueOf$1 = symbolProto$2 ? symbolProto$2.valueOf : undefined;

    /**
     * Creates a clone of the `symbol` object.
     *
     * @private
     * @param {Object} symbol The symbol object to clone.
     * @returns {Object} Returns the cloned symbol object.
     */
    function cloneSymbol(symbol) {
      return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
    }

    /** `Object#toString` result references. */
    var boolTag$3 = '[object Boolean]',
        dateTag$2 = '[object Date]',
        mapTag$4 = '[object Map]',
        numberTag$2 = '[object Number]',
        regexpTag$2 = '[object RegExp]',
        setTag$4 = '[object Set]',
        stringTag$3 = '[object String]',
        symbolTag$2 = '[object Symbol]';

    var arrayBufferTag$2 = '[object ArrayBuffer]',
        dataViewTag$3 = '[object DataView]',
        float32Tag$1 = '[object Float32Array]',
        float64Tag$1 = '[object Float64Array]',
        int8Tag$1 = '[object Int8Array]',
        int16Tag$1 = '[object Int16Array]',
        int32Tag$1 = '[object Int32Array]',
        uint8Tag$1 = '[object Uint8Array]',
        uint8ClampedTag$1 = '[object Uint8ClampedArray]',
        uint16Tag$1 = '[object Uint16Array]',
        uint32Tag$1 = '[object Uint32Array]';

    /**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag$2:
          return cloneArrayBuffer(object);

        case boolTag$3:
        case dateTag$2:
          return new Ctor(+object);

        case dataViewTag$3:
          return cloneDataView(object, isDeep);

        case float32Tag$1: case float64Tag$1:
        case int8Tag$1: case int16Tag$1: case int32Tag$1:
        case uint8Tag$1: case uint8ClampedTag$1: case uint16Tag$1: case uint32Tag$1:
          return cloneTypedArray(object, isDeep);

        case mapTag$4:
          return new Ctor;

        case numberTag$2:
        case stringTag$3:
          return new Ctor(object);

        case regexpTag$2:
          return cloneRegExp(object);

        case setTag$4:
          return new Ctor;

        case symbolTag$2:
          return cloneSymbol(object);
      }
    }

    /** `Object#toString` result references. */
    var mapTag$5 = '[object Map]';

    /**
     * The base implementation of `_.isMap` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     */
    function baseIsMap(value) {
      return isObjectLike(value) && getTag$1(value) == mapTag$5;
    }

    /* Node.js helper references. */
    var nodeIsMap = nodeUtil && nodeUtil.isMap;

    /**
     * Checks if `value` is classified as a `Map` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     * @example
     *
     * _.isMap(new Map);
     * // => true
     *
     * _.isMap(new WeakMap);
     * // => false
     */
    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

    /** `Object#toString` result references. */
    var setTag$5 = '[object Set]';

    /**
     * The base implementation of `_.isSet` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     */
    function baseIsSet(value) {
      return isObjectLike(value) && getTag$1(value) == setTag$5;
    }

    /* Node.js helper references. */
    var nodeIsSet = nodeUtil && nodeUtil.isSet;

    /**
     * Checks if `value` is classified as a `Set` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     * @example
     *
     * _.isSet(new Set);
     * // => true
     *
     * _.isSet(new WeakSet);
     * // => false
     */
    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

    /** Used to compose bitmasks for cloning. */
    var CLONE_DEEP_FLAG = 1,
        CLONE_FLAT_FLAG = 2,
        CLONE_SYMBOLS_FLAG = 4;

    /** `Object#toString` result references. */
    var argsTag$3 = '[object Arguments]',
        arrayTag$2 = '[object Array]',
        boolTag$4 = '[object Boolean]',
        dateTag$3 = '[object Date]',
        errorTag$2 = '[object Error]',
        funcTag$2 = '[object Function]',
        genTag$1 = '[object GeneratorFunction]',
        mapTag$6 = '[object Map]',
        numberTag$3 = '[object Number]',
        objectTag$4 = '[object Object]',
        regexpTag$3 = '[object RegExp]',
        setTag$6 = '[object Set]',
        stringTag$4 = '[object String]',
        symbolTag$3 = '[object Symbol]',
        weakMapTag$2 = '[object WeakMap]';

    var arrayBufferTag$3 = '[object ArrayBuffer]',
        dataViewTag$4 = '[object DataView]',
        float32Tag$2 = '[object Float32Array]',
        float64Tag$2 = '[object Float64Array]',
        int8Tag$2 = '[object Int8Array]',
        int16Tag$2 = '[object Int16Array]',
        int32Tag$2 = '[object Int32Array]',
        uint8Tag$2 = '[object Uint8Array]',
        uint8ClampedTag$2 = '[object Uint8ClampedArray]',
        uint16Tag$2 = '[object Uint16Array]',
        uint32Tag$2 = '[object Uint32Array]';

    /** Used to identify `toStringTag` values supported by `_.clone`. */
    var cloneableTags = {};
    cloneableTags[argsTag$3] = cloneableTags[arrayTag$2] =
    cloneableTags[arrayBufferTag$3] = cloneableTags[dataViewTag$4] =
    cloneableTags[boolTag$4] = cloneableTags[dateTag$3] =
    cloneableTags[float32Tag$2] = cloneableTags[float64Tag$2] =
    cloneableTags[int8Tag$2] = cloneableTags[int16Tag$2] =
    cloneableTags[int32Tag$2] = cloneableTags[mapTag$6] =
    cloneableTags[numberTag$3] = cloneableTags[objectTag$4] =
    cloneableTags[regexpTag$3] = cloneableTags[setTag$6] =
    cloneableTags[stringTag$4] = cloneableTags[symbolTag$3] =
    cloneableTags[uint8Tag$2] = cloneableTags[uint8ClampedTag$2] =
    cloneableTags[uint16Tag$2] = cloneableTags[uint32Tag$2] = true;
    cloneableTags[errorTag$2] = cloneableTags[funcTag$2] =
    cloneableTags[weakMapTag$2] = false;

    /**
     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
     * traversed objects.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Deep clone
     *  2 - Flatten inherited properties
     *  4 - Clone symbols
     * @param {Function} [customizer] The function to customize cloning.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The parent object of `value`.
     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, bitmask, customizer, key, object, stack) {
      var result,
          isDeep = bitmask & CLONE_DEEP_FLAG,
          isFlat = bitmask & CLONE_FLAT_FLAG,
          isFull = bitmask & CLONE_SYMBOLS_FLAG;

      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== undefined) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag$1(value),
            isFunc = tag == funcTag$2 || tag == genTag$1;

        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag$4 || tag == argsTag$3 || (isFunc && !object)) {
          result = (isFlat || isFunc) ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat
              ? copySymbolsIn(value, baseAssignIn(result, value))
              : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      // Check for circular references and return its corresponding clone.
      stack || (stack = new Stack);
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);

      if (isSet(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
        });

        return result;
      }

      if (isMap(value)) {
        value.forEach(function(subValue, key) {
          result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
        });

        return result;
      }

      var keysFunc = isFull
        ? (isFlat ? getAllKeysIn : getAllKeys)
        : (isFlat ? keysIn : keys);

      var props = isArr ? undefined : keysFunc(value);
      arrayEach(props || value, function(subValue, key) {
        if (props) {
          key = subValue;
          subValue = value[key];
        }
        // Recursively populate clone (susceptible to call stack limits).
        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
      });
      return result;
    }

    /** Used to compose bitmasks for cloning. */
    var CLONE_DEEP_FLAG$1 = 1,
        CLONE_SYMBOLS_FLAG$1 = 4;

    /**
     * This method is like `_.clone` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @returns {*} Returns the deep cloned value.
     * @see _.clone
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var deep = _.cloneDeep(objects);
     * console.log(deep[0] === objects[0]);
     * // => false
     */
    function cloneDeep(value) {
      return baseClone(value, CLONE_DEEP_FLAG$1 | CLONE_SYMBOLS_FLAG$1);
    }

    /**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias first
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.head([1, 2, 3]);
     * // => 1
     *
     * _.head([]);
     * // => undefined
     */
    function head(array) {
      return (array && array.length) ? array[0] : undefined;
    }

    /** Used to store function metadata. */
    var metaMap = WeakMap && new WeakMap;

    /**
     * The base implementation of `setData` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var baseSetData = !metaMap ? identity : function(func, data) {
      metaMap.set(func, data);
      return func;
    };

    /**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCtor(Ctor) {
      return function() {
        // Use a `switch` statement to work with class constructors. See
        // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
        // for more details.
        var args = arguments;
        switch (args.length) {
          case 0: return new Ctor;
          case 1: return new Ctor(args[0]);
          case 2: return new Ctor(args[0], args[1]);
          case 3: return new Ctor(args[0], args[1], args[2]);
          case 4: return new Ctor(args[0], args[1], args[2], args[3]);
          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
        }
        var thisBinding = baseCreate(Ctor.prototype),
            result = Ctor.apply(thisBinding, args);

        // Mimic the constructor's `return` behavior.
        // See https://es5.github.io/#x13.2.2 for more details.
        return isObject(result) ? result : thisBinding;
      };
    }

    /** Used to compose bitmasks for function metadata. */
    var WRAP_BIND_FLAG = 1;

    /**
     * Creates a function that wraps `func` to invoke it with the optional `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createBind(func, bitmask, thisArg) {
      var isBind = bitmask & WRAP_BIND_FLAG,
          Ctor = createCtor(func);

      function wrapper() {
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return fn.apply(isBind ? thisArg : this, arguments);
      }
      return wrapper;
    }

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeMax$1 = Math.max;

    /**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgs(args, partials, holders, isCurried) {
      var argsIndex = -1,
          argsLength = args.length,
          holdersLength = holders.length,
          leftIndex = -1,
          leftLength = partials.length,
          rangeLength = nativeMax$1(argsLength - holdersLength, 0),
          result = Array(leftLength + rangeLength),
          isUncurried = !isCurried;

      while (++leftIndex < leftLength) {
        result[leftIndex] = partials[leftIndex];
      }
      while (++argsIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[holders[argsIndex]] = args[argsIndex];
        }
      }
      while (rangeLength--) {
        result[leftIndex++] = args[argsIndex++];
      }
      return result;
    }

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeMax$2 = Math.max;

    /**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgsRight(args, partials, holders, isCurried) {
      var argsIndex = -1,
          argsLength = args.length,
          holdersIndex = -1,
          holdersLength = holders.length,
          rightIndex = -1,
          rightLength = partials.length,
          rangeLength = nativeMax$2(argsLength - holdersLength, 0),
          result = Array(rangeLength + rightLength),
          isUncurried = !isCurried;

      while (++argsIndex < rangeLength) {
        result[argsIndex] = args[argsIndex];
      }
      var offset = argsIndex;
      while (++rightIndex < rightLength) {
        result[offset + rightIndex] = partials[rightIndex];
      }
      while (++holdersIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[offset + holders[holdersIndex]] = args[argsIndex++];
        }
      }
      return result;
    }

    /**
     * Gets the number of `placeholder` occurrences in `array`.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} placeholder The placeholder to search for.
     * @returns {number} Returns the placeholder count.
     */
    function countHolders(array, placeholder) {
      var length = array.length,
          result = 0;

      while (length--) {
        if (array[length] === placeholder) {
          ++result;
        }
      }
      return result;
    }

    /**
     * The function whose prototype chain sequence wrappers inherit from.
     *
     * @private
     */
    function baseLodash() {
      // No operation performed.
    }

    /** Used as references for the maximum length and index of an array. */
    var MAX_ARRAY_LENGTH = 4294967295;

    /**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @constructor
     * @param {*} value The value to wrap.
     */
    function LazyWrapper(value) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__dir__ = 1;
      this.__filtered__ = false;
      this.__iteratees__ = [];
      this.__takeCount__ = MAX_ARRAY_LENGTH;
      this.__views__ = [];
    }

    // Ensure `LazyWrapper` is an instance of `baseLodash`.
    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
    LazyWrapper.prototype.constructor = LazyWrapper;

    /**
     * This method returns `undefined`.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Util
     * @example
     *
     * _.times(2, _.noop);
     * // => [undefined, undefined]
     */
    function noop() {
      // No operation performed.
    }

    /**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */
    var getData = !metaMap ? noop : function(func) {
      return metaMap.get(func);
    };

    /** Used to lookup unminified function names. */
    var realNames = {};

    /** Used for built-in method references. */
    var objectProto$16 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$13 = objectProto$16.hasOwnProperty;

    /**
     * Gets the name of `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {string} Returns the function name.
     */
    function getFuncName(func) {
      var result = (func.name + ''),
          array = realNames[result],
          length = hasOwnProperty$13.call(realNames, result) ? array.length : 0;

      while (length--) {
        var data = array[length],
            otherFunc = data.func;
        if (otherFunc == null || otherFunc == func) {
          return data.name;
        }
      }
      return result;
    }

    /**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable explicit method chain sequences.
     */
    function LodashWrapper(value, chainAll) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__chain__ = !!chainAll;
      this.__index__ = 0;
      this.__values__ = undefined;
    }

    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
    LodashWrapper.prototype.constructor = LodashWrapper;

    /**
     * Creates a clone of `wrapper`.
     *
     * @private
     * @param {Object} wrapper The wrapper to clone.
     * @returns {Object} Returns the cloned wrapper.
     */
    function wrapperClone(wrapper) {
      if (wrapper instanceof LazyWrapper) {
        return wrapper.clone();
      }
      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
      result.__actions__ = copyArray(wrapper.__actions__);
      result.__index__  = wrapper.__index__;
      result.__values__ = wrapper.__values__;
      return result;
    }

    /** Used for built-in method references. */
    var objectProto$17 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$14 = objectProto$17.hasOwnProperty;

    /**
     * Creates a `lodash` object which wraps `value` to enable implicit method
     * chain sequences. Methods that operate on and return arrays, collections,
     * and functions can be chained together. Methods that retrieve a single value
     * or may return a primitive value will automatically end the chain sequence
     * and return the unwrapped value. Otherwise, the value must be unwrapped
     * with `_#value`.
     *
     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
     * enabled using `_.chain`.
     *
     * The execution of chained methods is lazy, that is, it's deferred until
     * `_#value` is implicitly or explicitly called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion.
     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
     * the creation of intermediate arrays and can greatly reduce the number of
     * iteratee executions. Sections of a chain sequence qualify for shortcut
     * fusion if the section is applied to an array and iteratees accept only
     * one argument. The heuristic for whether a section qualifies for shortcut
     * fusion is subject to change.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers have `Array` and `String` methods.
     *
     * The wrapper `Array` methods are:
     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
     *
     * The wrapper `String` methods are:
     * `replace` and `split`
     *
     * The wrapper methods that support shortcut fusion are:
     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
     * `zipObject`, `zipObjectDeep`, and `zipWith`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
     * `upperFirst`, `value`, and `words`
     *
     * @name _
     * @constructor
     * @category Seq
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // Returns an unwrapped value.
     * wrapped.reduce(_.add);
     * // => 6
     *
     * // Returns a wrapped value.
     * var squares = wrapped.map(square);
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
        if (value instanceof LodashWrapper) {
          return value;
        }
        if (hasOwnProperty$14.call(value, '__wrapped__')) {
          return wrapperClone(value);
        }
      }
      return new LodashWrapper(value);
    }

    // Ensure wrappers are instances of `baseLodash`.
    lodash.prototype = baseLodash.prototype;
    lodash.prototype.constructor = lodash;

    /**
     * Checks if `func` has a lazy counterpart.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
     *  else `false`.
     */
    function isLaziable(func) {
      var funcName = getFuncName(func),
          other = lodash[funcName];

      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
        return false;
      }
      if (func === other) {
        return true;
      }
      var data = getData(other);
      return !!data && func === data[0];
    }

    /**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity
     * function to avoid garbage collection pauses in V8. See
     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var setData = shortOut(baseSetData);

    /** Used to match wrap detail comments. */
    var reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
        reSplitDetails = /,? & /;

    /**
     * Extracts wrapper details from the `source` body comment.
     *
     * @private
     * @param {string} source The source to inspect.
     * @returns {Array} Returns the wrapper details.
     */
    function getWrapDetails(source) {
      var match = source.match(reWrapDetails);
      return match ? match[1].split(reSplitDetails) : [];
    }

    /** Used to match wrap detail comments. */
    var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/;

    /**
     * Inserts wrapper `details` in a comment at the top of the `source` body.
     *
     * @private
     * @param {string} source The source to modify.
     * @returns {Array} details The details to insert.
     * @returns {string} Returns the modified source.
     */
    function insertWrapDetails(source, details) {
      var length = details.length;
      if (!length) {
        return source;
      }
      var lastIndex = length - 1;
      details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
      details = details.join(length > 2 ? ', ' : ' ');
      return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
    }

    /**
     * The base implementation of `_.findIndex` and `_.findLastIndex` without
     * support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} predicate The function invoked per iteration.
     * @param {number} fromIndex The index to search from.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length,
          index = fromIndex + (fromRight ? 1 : -1);

      while ((fromRight ? index-- : ++index < length)) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * The base implementation of `_.isNaN` without support for number objects.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     */
    function baseIsNaN(value) {
      return value !== value;
    }

    /**
     * A specialized version of `_.indexOf` which performs strict equality
     * comparisons of values, i.e. `===`.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} fromIndex The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function strictIndexOf(array, value, fromIndex) {
      var index = fromIndex - 1,
          length = array.length;

      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }

    /**
     * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} fromIndex The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function baseIndexOf(array, value, fromIndex) {
      return value === value
        ? strictIndexOf(array, value, fromIndex)
        : baseFindIndex(array, baseIsNaN, fromIndex);
    }

    /**
     * A specialized version of `_.includes` for arrays without support for
     * specifying an index to search from.
     *
     * @private
     * @param {Array} [array] The array to inspect.
     * @param {*} target The value to search for.
     * @returns {boolean} Returns `true` if `target` is found, else `false`.
     */
    function arrayIncludes(array, value) {
      var length = array == null ? 0 : array.length;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }

    /** Used to compose bitmasks for function metadata. */
    var WRAP_BIND_FLAG$1 = 1,
        WRAP_BIND_KEY_FLAG = 2,
        WRAP_CURRY_FLAG = 8,
        WRAP_CURRY_RIGHT_FLAG = 16,
        WRAP_PARTIAL_FLAG = 32,
        WRAP_PARTIAL_RIGHT_FLAG = 64,
        WRAP_ARY_FLAG = 128,
        WRAP_REARG_FLAG = 256,
        WRAP_FLIP_FLAG = 512;

    /** Used to associate wrap methods with their bit flags. */
    var wrapFlags = [
      ['ary', WRAP_ARY_FLAG],
      ['bind', WRAP_BIND_FLAG$1],
      ['bindKey', WRAP_BIND_KEY_FLAG],
      ['curry', WRAP_CURRY_FLAG],
      ['curryRight', WRAP_CURRY_RIGHT_FLAG],
      ['flip', WRAP_FLIP_FLAG],
      ['partial', WRAP_PARTIAL_FLAG],
      ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
      ['rearg', WRAP_REARG_FLAG]
    ];

    /**
     * Updates wrapper `details` based on `bitmask` flags.
     *
     * @private
     * @returns {Array} details The details to modify.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Array} Returns `details`.
     */
    function updateWrapDetails(details, bitmask) {
      arrayEach(wrapFlags, function(pair) {
        var value = '_.' + pair[0];
        if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
          details.push(value);
        }
      });
      return details.sort();
    }

    /**
     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
     * with wrapper details in a comment at the top of the source body.
     *
     * @private
     * @param {Function} wrapper The function to modify.
     * @param {Function} reference The reference function.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Function} Returns `wrapper`.
     */
    function setWrapToString(wrapper, reference, bitmask) {
      var source = (reference + '');
      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
    }

    /** Used to compose bitmasks for function metadata. */
    var WRAP_BIND_FLAG$2 = 1,
        WRAP_BIND_KEY_FLAG$1 = 2,
        WRAP_CURRY_BOUND_FLAG = 4,
        WRAP_CURRY_FLAG$1 = 8,
        WRAP_PARTIAL_FLAG$1 = 32,
        WRAP_PARTIAL_RIGHT_FLAG$1 = 64;

    /**
     * Creates a function that wraps `func` to continue currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {Function} wrapFunc The function to create the `func` wrapper.
     * @param {*} placeholder The placeholder value.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
      var isCurry = bitmask & WRAP_CURRY_FLAG$1,
          newHolders = isCurry ? holders : undefined,
          newHoldersRight = isCurry ? undefined : holders,
          newPartials = isCurry ? partials : undefined,
          newPartialsRight = isCurry ? undefined : partials;

      bitmask |= (isCurry ? WRAP_PARTIAL_FLAG$1 : WRAP_PARTIAL_RIGHT_FLAG$1);
      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG$1 : WRAP_PARTIAL_FLAG$1);

      if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
        bitmask &= ~(WRAP_BIND_FLAG$2 | WRAP_BIND_KEY_FLAG$1);
      }
      var newData = [
        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
        newHoldersRight, argPos, ary, arity
      ];

      var result = wrapFunc.apply(undefined, newData);
      if (isLaziable(func)) {
        setData(result, newData);
      }
      result.placeholder = placeholder;
      return setWrapToString(result, func, bitmask);
    }

    /**
     * Gets the argument placeholder value for `func`.
     *
     * @private
     * @param {Function} func The function to inspect.
     * @returns {*} Returns the placeholder value.
     */
    function getHolder(func) {
      var object = func;
      return object.placeholder;
    }

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeMin = Math.min;

    /**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */
    function reorder(array, indexes) {
      var arrLength = array.length,
          length = nativeMin(indexes.length, arrLength),
          oldArray = copyArray(array);

      while (length--) {
        var index = indexes[length];
        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
      }
      return array;
    }

    /** Used as the internal argument placeholder. */
    var PLACEHOLDER = '__lodash_placeholder__';

    /**
     * Replaces all `placeholder` elements in `array` with an internal placeholder
     * and returns an array of their indexes.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {*} placeholder The placeholder to replace.
     * @returns {Array} Returns the new array of placeholder indexes.
     */
    function replaceHolders(array, placeholder) {
      var index = -1,
          length = array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value === placeholder || value === PLACEHOLDER) {
          array[index] = PLACEHOLDER;
          result[resIndex++] = index;
        }
      }
      return result;
    }

    /** Used to compose bitmasks for function metadata. */
    var WRAP_BIND_FLAG$3 = 1,
        WRAP_BIND_KEY_FLAG$2 = 2,
        WRAP_CURRY_FLAG$2 = 8,
        WRAP_CURRY_RIGHT_FLAG$1 = 16,
        WRAP_ARY_FLAG$1 = 128,
        WRAP_FLIP_FLAG$1 = 512;

    /**
     * Creates a function that wraps `func` to invoke it with optional `this`
     * binding of `thisArg`, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided
     *  to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
      var isAry = bitmask & WRAP_ARY_FLAG$1,
          isBind = bitmask & WRAP_BIND_FLAG$3,
          isBindKey = bitmask & WRAP_BIND_KEY_FLAG$2,
          isCurried = bitmask & (WRAP_CURRY_FLAG$2 | WRAP_CURRY_RIGHT_FLAG$1),
          isFlip = bitmask & WRAP_FLIP_FLAG$1,
          Ctor = isBindKey ? undefined : createCtor(func);

      function wrapper() {
        var length = arguments.length,
            args = Array(length),
            index = length;

        while (index--) {
          args[index] = arguments[index];
        }
        if (isCurried) {
          var placeholder = getHolder(wrapper),
              holdersCount = countHolders(args, placeholder);
        }
        if (partials) {
          args = composeArgs(args, partials, holders, isCurried);
        }
        if (partialsRight) {
          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
        }
        length -= holdersCount;
        if (isCurried && length < arity) {
          var newHolders = replaceHolders(args, placeholder);
          return createRecurry(
            func, bitmask, createHybrid, wrapper.placeholder, thisArg,
            args, newHolders, argPos, ary, arity - length
          );
        }
        var thisBinding = isBind ? thisArg : this,
            fn = isBindKey ? thisBinding[func] : func;

        length = args.length;
        if (argPos) {
          args = reorder(args, argPos);
        } else if (isFlip && length > 1) {
          args.reverse();
        }
        if (isAry && ary < length) {
          args.length = ary;
        }
        if (this && this !== root && this instanceof wrapper) {
          fn = Ctor || createCtor(fn);
        }
        return fn.apply(thisBinding, args);
      }
      return wrapper;
    }

    /**
     * Creates a function that wraps `func` to enable currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {number} arity The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCurry(func, bitmask, arity) {
      var Ctor = createCtor(func);

      function wrapper() {
        var length = arguments.length,
            args = Array(length),
            index = length,
            placeholder = getHolder(wrapper);

        while (index--) {
          args[index] = arguments[index];
        }
        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
          ? []
          : replaceHolders(args, placeholder);

        length -= holders.length;
        if (length < arity) {
          return createRecurry(
            func, bitmask, createHybrid, wrapper.placeholder, undefined,
            args, holders, undefined, undefined, arity - length);
        }
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return apply(fn, this, args);
      }
      return wrapper;
    }

    /** Used to compose bitmasks for function metadata. */
    var WRAP_BIND_FLAG$4 = 1;

    /**
     * Creates a function that wraps `func` to invoke it with the `this` binding
     * of `thisArg` and `partials` prepended to the arguments it receives.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to
     *  the new function.
     * @returns {Function} Returns the new wrapped function.
     */
    function createPartial(func, bitmask, thisArg, partials) {
      var isBind = bitmask & WRAP_BIND_FLAG$4,
          Ctor = createCtor(func);

      function wrapper() {
        var argsIndex = -1,
            argsLength = arguments.length,
            leftIndex = -1,
            leftLength = partials.length,
            args = Array(leftLength + argsLength),
            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

        while (++leftIndex < leftLength) {
          args[leftIndex] = partials[leftIndex];
        }
        while (argsLength--) {
          args[leftIndex++] = arguments[++argsIndex];
        }
        return apply(fn, isBind ? thisArg : this, args);
      }
      return wrapper;
    }

    /** Used as the internal argument placeholder. */
    var PLACEHOLDER$1 = '__lodash_placeholder__';

    /** Used to compose bitmasks for function metadata. */
    var WRAP_BIND_FLAG$5 = 1,
        WRAP_BIND_KEY_FLAG$3 = 2,
        WRAP_CURRY_BOUND_FLAG$1 = 4,
        WRAP_CURRY_FLAG$3 = 8,
        WRAP_ARY_FLAG$2 = 128,
        WRAP_REARG_FLAG$1 = 256;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeMin$1 = Math.min;

    /**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers used to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and
     * `_.rearg` modify function arguments, making the order in which they are
     * executed important, preventing the merging of metadata. However, we make
     * an exception for a safe combined case where curried functions have `_.ary`
     * and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */
    function mergeData(data, source) {
      var bitmask = data[1],
          srcBitmask = source[1],
          newBitmask = bitmask | srcBitmask,
          isCommon = newBitmask < (WRAP_BIND_FLAG$5 | WRAP_BIND_KEY_FLAG$3 | WRAP_ARY_FLAG$2);

      var isCombo =
        ((srcBitmask == WRAP_ARY_FLAG$2) && (bitmask == WRAP_CURRY_FLAG$3)) ||
        ((srcBitmask == WRAP_ARY_FLAG$2) && (bitmask == WRAP_REARG_FLAG$1) && (data[7].length <= source[8])) ||
        ((srcBitmask == (WRAP_ARY_FLAG$2 | WRAP_REARG_FLAG$1)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG$3));

      // Exit early if metadata can't be merged.
      if (!(isCommon || isCombo)) {
        return data;
      }
      // Use source `thisArg` if available.
      if (srcBitmask & WRAP_BIND_FLAG$5) {
        data[2] = source[2];
        // Set when currying a bound function.
        newBitmask |= bitmask & WRAP_BIND_FLAG$5 ? 0 : WRAP_CURRY_BOUND_FLAG$1;
      }
      // Compose partial arguments.
      var value = source[3];
      if (value) {
        var partials = data[3];
        data[3] = partials ? composeArgs(partials, value, source[4]) : value;
        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER$1) : source[4];
      }
      // Compose partial right arguments.
      value = source[5];
      if (value) {
        partials = data[5];
        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER$1) : source[6];
      }
      // Use source `argPos` if available.
      value = source[7];
      if (value) {
        data[7] = value;
      }
      // Use source `ary` if it's smaller.
      if (srcBitmask & WRAP_ARY_FLAG$2) {
        data[8] = data[8] == null ? source[8] : nativeMin$1(data[8], source[8]);
      }
      // Use source `arity` if one is not provided.
      if (data[9] == null) {
        data[9] = source[9];
      }
      // Use source `func` and merge bitmasks.
      data[0] = source[0];
      data[1] = newBitmask;

      return data;
    }

    /** Used as references for various `Number` constants. */
    var NAN = 0 / 0;

    /** Used to match leading and trailing whitespace. */
    var reTrim = /^\s+|\s+$/g;

    /** Used to detect bad signed hexadecimal string values. */
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

    /** Used to detect binary string values. */
    var reIsBinary = /^0b[01]+$/i;

    /** Used to detect octal string values. */
    var reIsOctal = /^0o[0-7]+$/i;

    /** Built-in method references without a dependency on `root`. */
    var freeParseInt = parseInt;

    /**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */
    function toNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
        value = isObject(other) ? (other + '') : other;
      }
      if (typeof value != 'string') {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, '');
      var isBinary = reIsBinary.test(value);
      return (isBinary || reIsOctal.test(value))
        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
        : (reIsBadHex.test(value) ? NAN : +value);
    }

    /** Used as references for various `Number` constants. */
    var INFINITY$2 = 1 / 0,
        MAX_INTEGER = 1.7976931348623157e+308;

    /**
     * Converts `value` to a finite number.
     *
     * @static
     * @memberOf _
     * @since 4.12.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted number.
     * @example
     *
     * _.toFinite(3.2);
     * // => 3.2
     *
     * _.toFinite(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toFinite(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toFinite('3.2');
     * // => 3.2
     */
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY$2 || value === -INFINITY$2) {
        var sign = (value < 0 ? -1 : 1);
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }

    /**
     * Converts `value` to an integer.
     *
     * **Note:** This method is loosely based on
     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toInteger(3.2);
     * // => 3
     *
     * _.toInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toInteger(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toInteger('3.2');
     * // => 3
     */
    function toInteger(value) {
      var result = toFinite(value),
          remainder = result % 1;

      return result === result ? (remainder ? result - remainder : result) : 0;
    }

    /** Error message constants. */
    var FUNC_ERROR_TEXT$2 = 'Expected a function';

    /** Used to compose bitmasks for function metadata. */
    var WRAP_BIND_FLAG$6 = 1,
        WRAP_BIND_KEY_FLAG$4 = 2,
        WRAP_CURRY_FLAG$4 = 8,
        WRAP_CURRY_RIGHT_FLAG$2 = 16,
        WRAP_PARTIAL_FLAG$2 = 32,
        WRAP_PARTIAL_RIGHT_FLAG$2 = 64;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeMax$3 = Math.max;

    /**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags.
     *    1 - `_.bind`
     *    2 - `_.bindKey`
     *    4 - `_.curry` or `_.curryRight` of a bound function
     *    8 - `_.curry`
     *   16 - `_.curryRight`
     *   32 - `_.partial`
     *   64 - `_.partialRight`
     *  128 - `_.rearg`
     *  256 - `_.ary`
     *  512 - `_.flip`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG$4;
      if (!isBindKey && typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT$2);
      }
      var length = partials ? partials.length : 0;
      if (!length) {
        bitmask &= ~(WRAP_PARTIAL_FLAG$2 | WRAP_PARTIAL_RIGHT_FLAG$2);
        partials = holders = undefined;
      }
      ary = ary === undefined ? ary : nativeMax$3(toInteger(ary), 0);
      arity = arity === undefined ? arity : toInteger(arity);
      length -= holders ? holders.length : 0;

      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG$2) {
        var partialsRight = partials,
            holdersRight = holders;

        partials = holders = undefined;
      }
      var data = isBindKey ? undefined : getData(func);

      var newData = [
        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
        argPos, ary, arity
      ];

      if (data) {
        mergeData(newData, data);
      }
      func = newData[0];
      bitmask = newData[1];
      thisArg = newData[2];
      partials = newData[3];
      holders = newData[4];
      arity = newData[9] = newData[9] === undefined
        ? (isBindKey ? 0 : func.length)
        : nativeMax$3(newData[9] - length, 0);

      if (!arity && bitmask & (WRAP_CURRY_FLAG$4 | WRAP_CURRY_RIGHT_FLAG$2)) {
        bitmask &= ~(WRAP_CURRY_FLAG$4 | WRAP_CURRY_RIGHT_FLAG$2);
      }
      if (!bitmask || bitmask == WRAP_BIND_FLAG$6) {
        var result = createBind(func, bitmask, thisArg);
      } else if (bitmask == WRAP_CURRY_FLAG$4 || bitmask == WRAP_CURRY_RIGHT_FLAG$2) {
        result = createCurry(func, bitmask, arity);
      } else if ((bitmask == WRAP_PARTIAL_FLAG$2 || bitmask == (WRAP_BIND_FLAG$6 | WRAP_PARTIAL_FLAG$2)) && !holders.length) {
        result = createPartial(func, bitmask, thisArg, partials);
      } else {
        result = createHybrid.apply(undefined, newData);
      }
      var setter = data ? baseSetData : setData;
      return setWrapToString(setter(result, newData), func, bitmask);
    }

    /** Used to compose bitmasks for function metadata. */
    var WRAP_BIND_FLAG$7 = 1,
        WRAP_PARTIAL_FLAG$3 = 32;

    /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and `partials` prepended to the arguments it receives.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * function greet(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * }
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */
    var bind = baseRest(function(func, thisArg, partials) {
      var bitmask = WRAP_BIND_FLAG$7;
      if (partials.length) {
        var holders = replaceHolders(partials, getHolder(bind));
        bitmask |= WRAP_PARTIAL_FLAG$3;
      }
      return createWrap(func, bitmask, thisArg, partials, holders);
    });

    // Assign default placeholders.
    bind.placeholder = {};

    var RequestOptions = {
      // `responseType` indicates the type of data that the server will respond with
      // options are 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream'
      responseType: 'json',
      // default
      // `transformRequest` allows changes to the request data before it is sent to the server
      // This is only applicable for request methods 'PUT', 'POST', and 'PATCH'
      // The last function in the array must return a string or an instance of Buffer, ArrayBuffer,
      // FormData or Stream
      // You may modify the headers object.
      transformRequest: [],
      // `transformResponse` allows changes to the response data to be made before
      // it is passed to then/catch
      transformResponse: []
      /*
      // `url` is the server URL that will be used for the request
       // `method` is the request method to be used when making the request
      method: 'get', // default
       // `baseURL` will be prepended to `url` unless `url` is absolute.
      // It can be convenient to set `baseURL` for an instance of axios to pass relative URLs
      // to methods of that instance.
      baseURL: 'https://some-domain.com/api/',
       // `headers` are custom headers to be sent
      headers: {'X-Requested-With': 'XMLHttpRequest'},
       // `params` are the URL parameters to be sent with the request
      // Must be a plain object or a URLSearchParams object
      params: {
          ID: 12345
      },
       // `paramsSerializer` is an optional function in charge of serializing `params`
      // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)
      paramsSerializer: function(params) {
          return Qs.stringify(params, {arrayFormat: 'brackets'})
      },
       // `data` is the data to be sent as the request body
      // Only applicable for request methods 'PUT', 'POST', and 'PATCH'
      // When no `transformRequest` is set, must be of one of the following types:
      // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams
      // - Browser only: FormData, File, Blob
      // - Node only: Stream, Buffer
      data: {
          firstName: 'Fred'
      },
       // `timeout` specifies the number of milliseconds before the request times out.
      // If the request takes longer than `timeout`, the request will be aborted.
      timeout: 1000,
       // `withCredentials` indicates whether or not cross-site Access-Control requests
      // should be made using credentials
      withCredentials: false, // default
       // `adapter` allows custom handling of requests which makes testing easier.
      // Return a promise and supply a valid response (see lib/adapters/README.md).
      adapter: function (config) {
          //
      },
       // `auth` indicates that HTTP Basic auth should be used, and supplies credentials.
      // This will set an `Authorization` header, overwriting any existing
      // `Authorization` custom headers you have set using `headers`.
      auth: {
          username: 'janedoe',
          password: 's00pers3cret'
      },
       // `responseEncoding` indicates encoding to use for decoding responses
      // Note: Ignored for `responseType` of 'stream' or client-side requests
      responseEncoding: 'utf8', // default
       // `xsrfCookieName` is the name of the cookie to use as a value for xsrf token
      xsrfCookieName: 'XSRF-TOKEN', // default
       // `xsrfHeaderName` is the name of the http header that carries the xsrf token value
      xsrfHeaderName: 'X-XSRF-TOKEN', // default
       // `onUploadProgress` allows handling of progress events for uploads
      onUploadProgress: function (progressEvent) {
          // Do whatever you want with the native progress event
      },
       // `onDownloadProgress` allows handling of progress events for downloads
      onDownloadProgress: function (progressEvent) {
          // Do whatever you want with the native progress event
      },
       // `maxContentLength` defines the max size of the http response content in bytes allowed
      maxContentLength: 2000,
       // `validateStatus` defines whether to resolve or reject the promise for a given
      // HTTP response status code. If `validateStatus` returns `true` (or is set to `null`
      // or `undefined`), the promise will be resolved; otherwise, the promise will be
      // rejected.
      validateStatus: function (status) {
          return status >= 200 && status < 300; // default
      },
       // `maxRedirects` defines the maximum number of redirects to follow in node.js.
      // If set to 0, no redirects will be followed.
      maxRedirects: 5, // default
       // `socketPath` defines a UNIX Socket to be used in node.js.
      // e.g. '/var/run/docker.sock' to send requests to the docker daemon.
      // Only either `socketPath` or `proxy` can be specified.
      // If both are specified, `socketPath` is used.
      socketPath: null, // default
       // `httpAgent` and `httpsAgent` define a custom agent to be used when performing http
      // and https requests, respectively, in node.js. This allows options to be added like
      // `keepAlive` that are not enabled by default.
      httpAgent: new http.Agent({ keepAlive: true }),
      httpsAgent: new https.Agent({ keepAlive: true }),
       // 'proxy' defines the hostname and port of the proxy server
      // Use `false` to disable proxies, ignoring environment variables.
      // `auth` indicates that HTTP Basic auth should be used to connect to the proxy, and
      // supplies credentials.
      // This will set an `Proxy-Authorization` header, overwriting any existing
      // `Proxy-Authorization` custom headers you have set using `headers`.
      proxy: {
          host: '127.0.0.1',
          port: 9000,
          auth: {
              username: 'mikeymike',
              password: 'rapunz3l'
          }
      },
       // `cancelToken` specifies a cancel token that can be used to cancel the request
      // (see Cancellation section below for details)
      cancelToken: new CancelToken(function (cancel) {
       })
      */

    };

    function transformRequest(transformer, context) {
      if (!isFunction$1(transformer)) {
        throw new Error('The transformer must be defined as a function with two arguments (data, headers).');
      }

      (context || RequestOptions.transformRequest).push(transformer);
    }

    function transformResponse(transformer, context) {
      if (!isFunction$1(transformer)) {
        throw new Error('The transformer must be defined as a function (data).');
      }

      (context || RequestOptions.transformResponse).push(transformer);
    }

    var PROXY_OPTION_PROPERTIES = ['headers', 'params', 'data'];
    var PROXY_OPTION_METHODS = {
      get: function get(prop, context) {
        return function () {
          return context[prop];
        };
      },
      set: function set(prop, context) {
        return function (value) {
          context[prop] = value;
        };
      },
      add: function add(prop, context) {
        return function (key, value) {
          context[prop][key] = value;
        };
      },
      remove: function remove(prop, context) {
        return function (key) {
          delete context[prop][key];
        };
      },
      merge: function merge(prop, context) {
        return function (key, values) {
          assignIn(context[prop], key);
        };
      }
    };

    var method = function method(action, prop) {
      return camelCase([action, prop].join(' '));
    };

    var chainable = function chainable(prop) {
      var _this = this;

      return function (key, value) {
        if (key instanceof FormData) {
          _this[method('set', prop)](key);
        } else if (isObject(key)) {
          _this[method('merge', prop)](key);
        } else {
          _this[method('add', prop)](key, value);
        }

        return _this;
      };
    };

    function merge$1() {
      var args = [].slice.call(arguments);
      var items = args.splice(1);

      var subject = head(args);

      for (var i in items) {
        subject = mergeWith(subject, items[i], function (subject, value) {
          if (isArray(subject)) {
            return subject.concat(value);
          } else if (isObject(subject)) {
            return assignIn(subject, value);
          }

          return value;
        });
      }

      return subject;
    }

    var Request =
    /*#__PURE__*/
    function () {
      function Request(url) {
        var _this2 = this;

        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        _classCallCheck(this, Request);

        this.$options = merge$1({
          url: url,
          data: {},
          headers: {},
          params: {}
        }, cloneDeep(RequestOptions), options, {
          cancelToken: new axios.CancelToken(function (cancel) {
            _this2.$cancel = cancel;
          })
        });

        forEach(PROXY_OPTION_METHODS, function (callback, key) {
          _this2[method(key, 'option')] = bind(callback)('$options', _this2);
        });

        forEach(PROXY_OPTION_PROPERTIES, function (prop) {
          forEach(PROXY_OPTION_METHODS, function (callback, key) {
            _this2[method(key, prop)] = bind(callback)(prop, _this2.$options);
          });

          _this2[prop] = bind(chainable, _this2)(prop);
        });

        this.reset();
      }

      _createClass(Request, [{
        key: "reset",
        value: function reset() {
          this.$error = null;
          this.$status = null;
          this.$statusText = null;
          this.$response = null;
          this.$requestSentAt = null;
          this.$responseReceivedAt = null;
        }
      }, {
        key: "hasSent",
        value: function hasSent() {
          return !!this.$requestSentAt;
        }
      }, {
        key: "hasResponse",
        value: function hasResponse() {
          return !!this.$responseReceivedAt;
        }
      }, {
        key: "passed",
        value: function passed() {
          return this.hasResponse() && !this.$error;
        }
      }, {
        key: "failed",
        value: function failed() {
          return this.hasResponse() && !!this.$error;
        }
      }, {
        key: "cancel",
        value: function cancel() {
          !this.$response && this.$cancel();
        }
      }, {
        key: "get",
        value: function get() {
          var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          var headers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          return this.params(params).headers(headers).send('get');
        }
      }, {
        key: "post",
        value: function post() {
          var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          var headers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          return this.data(data).headers(headers).send('post');
        }
      }, {
        key: "put",
        value: function put() {
          var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          var headers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          return this.data(data).headers(headers).send('put');
        }
      }, {
        key: "delete",
        value: function _delete() {
          var headers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          return this.headers(headers).send('delete');
        }
      }, {
        key: "send",
        value: function send(method) {
          var _this3 = this;

          this.reset();
          this.$requestSentAt = moment();
          this.addOption('method', method);
          return new Promise(function (resolve, reject) {
            axios(_this3.$options).then(function (response) {
              _this3.$response = response;
              _this3.$responseReceivedAt = moment();
              _this3.$status = response.status;
              _this3.$statusText = response.statusText;
              resolve(response.data);
            }, function (error) {
              _this3.$error = error;
              _this3.$response = error.response;
              _this3.$responseReceivedAt = moment();
              _this3.$status = error.response ? error.response.status : null;
              _this3.$statusText = error.response ? error.response.statusText : null;
              reject(error.response || error);
            });
          });
        }
      }, {
        key: "transformRequest",
        value: function transformRequest$$1(transformer) {
          if (!this.$options.transformRequest) {
            this.$options.transformRequest = [];
          }

          transformRequest(transformer, this.$options.transformRequest);
        }
      }, {
        key: "transformResponse",
        value: function transformResponse$$1(transformer) {
          if (this.$options.transformResponse) {
            this.$options.transformResponse = [];
          }

          transformResponse(transformer, this.$options.transformResponse);
        }
      }], [{
        key: "interceptRequest",
        value: function interceptRequest(success, error) {
          this.interceptors().request.use(success, error);
        }
      }, {
        key: "interceptResponse",
        value: function interceptResponse(success, error) {
          this.interceptors().response.use(success, error);
        }
      }, {
        key: "interceptors",
        value: function interceptors() {
          return axios.interceptors;
        }
      }, {
        key: "option",
        value: function option(key, value) {
          if (isObject(key)) {
            merge$1(RequestOptions, key);
          } else {
            var option = {};
            option[key] = value;
            merge$1(RequestOptions, option);
          }
        }
      }, {
        key: "make",
        value: function make(url) {
          var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          return new this(url, params);
        }
      }]);

      return Request;
    }();

    var Model =
    /*#__PURE__*/
    function () {
      /**
       * Construct the model instance
       *
       * @param data object
       * @return void
       */
      function Model() {
        var _this = this;

        var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        _classCallCheck(this, Model);

        this.$request = null;
        this.$key = this.key();
        this.$files = this.files();
        this.$properties = this.properties();

        forEach(params, function (value, key) {
          _this[key] = value;
        });

        this.initialize(data);
      }
      /**
       * Initialize the model with the given data without considering the data
       * as "changed".
       *
       * @param data object
       * @return this
       */


      _createClass(Model, [{
        key: "initialize",
        value: function initialize(data) {
          this.$exists = false;
          this.$changed = {};
          this.$attributes = {};
          this.fill(data);
          this.$initialized = true;
          return this;
        }
        /**
         * Define the corresponding API endpoint slug
         *
         * @return string
         */

      }, {
        key: "endpoint",
        value: function endpoint() {} //

        /**
         * Define the corresponding uri schema.
         *
         * @return string
         */

      }, {
        key: "uri",
        value: function uri() {
          return filter([this.endpoint() || '', this.exists() ? this.id() : null].concat([].slice.call(arguments))).join('/');
        }
        /**
         * Return the primary key value for the model
         *
         * @return {Number}
         */

      }, {
        key: "id",
        value: function id() {
          return this.get(this.key());
        }
        /**
         * Define a primary key. This is used to determine if the model exists and
         * which endpoint to use.
         *
         * @return string
         */

      }, {
        key: "key",
        value: function key() {
          return 'id';
        }
        /**
         * Return an array of properties that are sent to the API. If no properties
         * are defined, then all the attributes will be included in the request.
         *
         * @return array
         */

      }, {
        key: "properties",
        value: function properties() {
          return [];
        }
        /**
         * Return an array of file properties that are sent to the API. If no fies
         * are defined, then request will always be sent with JSON vs. multipart.
         *
         * @return array
         */

      }, {
        key: "files",
        value: function files() {
          return [];
        }
        /**
         * Set the attributes in the model with the data given.
         *
         * @param data object
         * @return this
         */

      }, {
        key: "fill",
        value: function fill(data) {
          this.setAttributes(data);
          return this;
        }
        /**
         * Get one or more attributes from the model.
         *
         * @param data string|array
         * @return array|mixed
         */

      }, {
        key: "get",
        value: function get(key) {
          if (isArray(key) || isObject(key)) {
            return this.getAttributes().filter(function (value) {
              return data.indexOf(value) !== -1;
            });
          } else {
            return this.getAttribute(key);
          }
        }
        /**
         * Alias for setAttributes() except this method returns `this`. This method
         * also accepts an array of values or key/value pair.
         *
         * @return this
         */

      }, {
        key: "set",
        value: function set(key) {
          var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

          if (isArray(key) || isObject(key)) {
            this.setAttributes(key);
          } else {
            this.setAttribute(key, value);
          }

          return this;
        }
        /**
         * Get all the defined attributes.
         *
         * @return array
         */

      }, {
        key: "getAttributes",
        value: function getAttributes() {
          return this.$attributes;
        }
        /**
         * Get the changed attributes
         *
         * @return array
         */

      }, {
        key: "getChangedAttributes",
        value: function getChangedAttributes() {
          return keys(this.$changed);
        }
        /**
         * Get the changed attributes
         *
         * @return array
         */

      }, {
        key: "getOriginalValue",
        value: function getOriginalValue(key) {
          return this.$changed[key] || this.$attributes[key];
        }
        /**
         * Get the Request object.
         *
         * @return {mixed}
         */

      }, {
        key: "getRequest",
        value: function getRequest() {
          return this.$request;
        }
        /**
         * Get the unchanged attributes
         *
         * @return array
         */

      }, {
        key: "getUnchangedAttributes",
        value: function getUnchangedAttributes() {
          var _this2 = this;

          return filter(keys(this.$attributes), function (key) {
            return !(key in _this2.$changed);
          });
        }
        /**
         * Get an attribute with a given key. If no key is defined
         *
         * @param key string
         * @param default undefined|mixed
         * @return array
         */

      }, {
        key: "getAttribute",
        value: function getAttribute(key) {
          var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
          return this.$attributes[key] || value;
        }
        /**
         * Set an array or object of data as attributes.
         *
         * @param attributes array|object
         * @return void
         */

      }, {
        key: "setAttributes",
        value: function setAttributes(data) {
          var _this3 = this;

          if (isArray(data) || isObject(data)) {
            forEach(data, function (value, key) {
              _this3.setAttribute(key, value);
            });
          }
        }
        /**
         * Set an attribute with a given key/value pair. This will track the changes
         * in the model within the `this.$changed` property. If the primary key
         * is set, it will also change the `this.$exists` property.
         *
         * @param key string
         * @param value mixed
         * @return void
         */

      }, {
        key: "setAttribute",
        value: function setAttribute(key, value) {
          if (this.getAttribute(key) !== value) {
            this.handleAttributeChange(key, value);

            if (isUndefined(value)) {
              delete this.$attributes[key];
            } else {
              this.$attributes[key] = value;
            }
          }
        }
        /**
         * Revert the model to its original state.
         *
         * @return bool
         */

      }, {
        key: "revert",
        value: function revert() {
          var _this4 = this;

          forEach(this.$changed, function (value, key) {
            if (!isUndefined(value)) {
              _this4.$attributes[key] = value;
            } else {
              delete _this4.$attributes[key];
            }
          });

          this.$changed = {};
        }
        /**
         * Returns if the model has a primary key set.
         *
         * @return bool
         */

      }, {
        key: "exists",
        value: function exists() {
          return !!this.$exists;
        }
        /**
         * Returns the model been changed or not.
         *
         * @return bool
         */

      }, {
        key: "hasChanged",
        value: function hasChanged(key) {
          return !key ? size(this.$changed) > 0 : !isUndefined(this.$changed[key]);
        }
        /**
         * Does the model have any File objects. If so, need to send as multipart.
         *
         * @return bool
         */

      }, {
        key: "hasFiles",
        value: function hasFiles() {
          function count(files) {
            var total = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            return reduce(files, function (carry, value) {
              if (isArray(value)) {
                return carry + count(value, total);
              } else if (value instanceof File || value instanceof FileList) {
                return carry + 1;
              } else {
                return carry;
              }
            }, total);
          }

          return count(this.toJSON()) !== 0;
        }
        /**
         * Handle settings the $changed attributes when an attribute value is set.
         *
         * @param key string
         * @param value mixed
         * @return void
         */

      }, {
        key: "handleAttributeChange",
        value: function handleAttributeChange(key, value) {
          if (this.$initialized) {
            if (this.$changed[key] === value) {
              delete this.$changed[key];
            } else if (!(key in this.$changed)) {
              this.$changed[key] = this.getAttribute(key);
            }
          }

          this.handlePrimaryKeyChange(key, value);
        }
        /**
         * Set an array or object of data as attributes.
         *
         * @param key string
         * @param value mixed
         * @return void
         */

      }, {
        key: "handlePrimaryKeyChange",
        value: function handlePrimaryKeyChange(key, value) {
          if (this.$key === key) {
            this.$exists = !isUndefined(value) && !isNull(value);
          }
        }
        /**
         * Cancel the current request
         *
         * @param data object
         * @return bool
         */

      }, {
        key: "cancel",
        value: function cancel() {
          this.$request && this.$request.cancel();
        }
        /**
         * Save the model to the database
         *
         * @param data object
         * @return bool
         */

      }, {
        key: "save",
        value: function save() {
          var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          return !this.exists() ? this.create(data, config) : this.update(data, config);
        }
        /**
         * Create a new model
         *
         * @param data object
         * @return bool
         */

      }, {
        key: "create",
        value: function create() {
          var _this5 = this;

          var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          this.fill(data);
          return new Promise(function (resolve, reject) {
            var data = !_this5.hasFiles() ? _this5.toJson() : _this5.toFormData();
            _this5.$request = _this5.constructor.request(_this5.uri(), Object.assign({}, config));

            _this5.$request.post(data).then(function (response) {
              resolve(_this5.fill(response));
            }, reject);
          });
        }
        /**
         * Update an existing model
         *
         * @param data object
         * @return bool
         */

      }, {
        key: "update",
        value: function update() {
          var _this6 = this;

          var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          this.fill(data);
          return new Promise(function (resolve, reject) {
            var data = !_this6.hasFiles() ? _this6.toJson() : _this6.toFormData();
            _this6.$request = _this6.constructor.request(_this6.uri(), config);

            _this6.$request[_this6.hasFiles() ? 'post' : 'put'](data).then(function (response) {
              resolve(_this6.fill(response));
            }, reject);
          });
        }
        /**
         * Delete an existing model
         *
         * @param  {object} config
         * @return {bool}
         */

      }, {
        key: "delete",
        value: function _delete() {
          var _this7 = this;

          var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          return new Promise(function (resolve, reject) {
            if (!_this7.exists()) {
              reject(new Error('The model must have a primary key before it can be delete.'));
            }

            _this7.$request = _this7.constructor.request(_this7.uri(), config);

            _this7.$request.delete().then(function (response) {
              resolve(response);
            }, reject);
          });
        }
        /**
         * Cancel the current HTTP request if one exists.
         *
         * @return {self}
         */

      }, {
        key: "cancel",
        value: function cancel() {
          if (this.$request) {
            this.$request.cancel();
          }

          return this;
        }
        /**
         * Convert the Model instance to a FormData instance
         *
         * @return object
         */

      }, {
        key: "toFormData",
        value: function toFormData() {
          var form = new FormData();

          forEach(this.toJSON(), function (value, key) {
            if (isArray(value)) {
              forEach(value, function (item) {
                if (!(item instanceof File) && (isObject(item) || isArray(item))) {
                  item = JSON.stringify(item);
                }

                form.append(key.replace(/(.+)(\[.+\]?)$/, '$1') + '[]', item);
              });
            } else if (!(value instanceof File) && isObject(value)) {
              form.append(key, JSON.stringify(value));
            } else if (!isNull(value)) {
              form.append(key, value);
            }
          });

          return form;
        }
        /**
         * Convert the instance to JSON payload
         *
         * @return object
         */

      }, {
        key: "toJSON",
        value: function toJSON() {
          var _this8 = this;

          return pickBy(this.$attributes, function (value, key) {
            return !_this8.$properties.length || key === _this8.key() || _this8.$properties.indexOf(key) !== -1;
          });
        }
        /**
         * Alias for toJSON
         *
         * @return object
         */

      }, {
        key: "toJson",
        value: function toJson() {
          return this.toJSON();
        }
        /**
         * Search for a collection of models
         *
         * @param data object
         * @return bool
         */

      }], [{
        key: "search",
        value: function search() {
          var _this9 = this;

          var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          var model = new this();
          return new Promise(function (resolve, reject) {
            model.$request = _this9.request(config.uri || model.uri(), config);
            model.$request.get(params).then(function (response) {
              response.data = response.data.map(function (data) {
                return new _this9(data);
              });
              resolve(response);
            }, function (errors) {
              reject(errors);
            });
          });
        }
        /**
         * Find an existing model by id
         *
         * @param data object
         * @return bool
         */

      }, {
        key: "find",
        value: function find(id) {
          var _this10 = this;

          var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          return new Promise(function (resolve, reject) {
            var model = new _this10();
            model.$request = _this10.request(model.uri(id), config);
            model.$request.get().then(function (response) {
              resolve(model.initialize(response));
            }, function (error) {
              reject(error);
            });
          });
        }
        /**
         * Create a request from the model data
         *
         * @param data object
         * @return bool
         */

      }, {
        key: "request",
        value: function request(url) {
          var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          return new Request(url, config);
        }
      }]);

      return Model;
    }();

    var BaseForm = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('form', {
          class: {
            'form-inline': _vm.inline
          },
          attrs: {
            "novalidate": _vm.novalidate
          },
          on: {
            "submit": function submit($event) {
              $event.preventDefault();
              return _vm.onSubmit($event);
            }
          }
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      props: {
        /**
         * The Model method used to send the request.
         *
         * @property Boolean
         */
        method: {
          type: String,
          default: 'save',
          validate: function validate(value) {
            return this.model && isFunction$1(this.model[value]);
          }
        },

        /**
         * An object of form data
         *
         * @property Object
         */
        data: {
          type: Object,
          default: function _default() {
            return {};
          }
        },

        /**
         * A JSON object of request headers
         *
         * @property Object
         */
        headers: Object,

        /**
         * Display the form fields inline
         *
         * @property Object
         */
        model: {
          type: Object,
          validate: function validate(value) {
            return value instanceof Model;
          }
        },

        /**
         * Display the form fields inline
         *
         * @property Boolean
         */
        inline: Boolean,

        /**
         * A callback function for the `submit` event
         *
         * @property Boolean
         */
        novalidate: {
          type: Boolean,
          default: true
        },

        /**
         * A JSON object of key/value pairs to build the query string.
         *
         * @property Object
         */
        query: Object,

        /**
         * A URI or URL used to redirect user after form submits successfully.
         *
         * @property Function|String
         */
        redirect: [Object, String, Function],

        /**
         * A callback function for the `submit` event
         *
         * @property Function
         */
        onSubmit: {
          type: Function,
          default: function _default(event) {
            this.model && this.submit(event);
          }
        },

        /**
         * A callback function for the `submit:success` event
         *
         * @property Function
         */
        onSubmitSuccess: {
          type: Function,
          default: function _default(event, data) {
            this.$emit('submit:success', event, data);
            this.$emit('submit:complete', event, true, data);

            if (this.redirect && isFunction$1(this.redirect)) {
              this.redirect(this);
            } else if (this.redirect) {
              this.$router.push(this.redirect);
            }
          }
        },

        /**
         * A callback function for the `submit:success` event
         *
         * @property Function
         */
        onSubmitFailed: {
          type: Function,
          default: function _default(event, errors) {
            this.$emit('submit:failed', event, errors);
            this.$emit('submit:complete', event, false, errors);
          }
        }
      },
      methods: {
        submit: function submit(event) {
          var _this = this;

          this.$emit('submit', event);
          return this.model[this.method](this.data, {
            query: this.query,
            headers: this.headers,
            onUploadProgress: function onUploadProgress(event) {
              _this.$emit('submit:progress', event);
            }
          }).then(function (data) {
            _this.onSubmitSuccess(event, data);
          }, function (errors) {
            _this.onSubmitFailed(event, errors);
          });
        }
      },
      data: function data() {
        return {
          errors: {}
        };
      }
    };

    var plugin$11 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          BaseForm: BaseForm
        });
      }
    });

    var BreadcrumbItem = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('li', {
          staticClass: "breadcrumb-item",
          class: {
            'active': _vm.active
          },
          attrs: {
            "aria-current": _vm.active ? 'page' : false
          }
        }, [!_vm.active && _vm.href ? _c('a', {
          attrs: {
            "href": _vm.href
          }
        }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))])], 2) : !_vm.active && _vm.to ? _c('router-link', {
          attrs: {
            "to": _vm.to
          }
        }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))])], 2) : [_vm._t("default", [_vm._v(_vm._s(_vm.label))])]], 2);
      },
      staticRenderFns: [],
      name: 'breadcrumb-item',
      props: {
        /**
         * Is the item active?
         *
         * @prop {Boolean}
         */
        active: Boolean,

        /**
         * An href attribute
         *
         * @prop {String}
         */
        href: String,

        /**
         * An breadcrumb label
         *
         * @prop {String}
         */
        label: String,

        /**
         * The to attribute which is passed to the <router-link> component.
         *
         * @prop {Object}
         */
        to: [String, Object]
      }
    };

    var Breadcrumb = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('nav', {
          attrs: {
            "aria-label": "breadcrumb"
          }
        }, [_c('ol', {
          staticClass: "breadcrumb"
        }, [_vm._l(_vm.items, function (item, i) {
          return _vm.items.length ? _c('breadcrumb-item', _vm._b({
            key: i,
            attrs: {
              "current": i === item.length - 1
            }
          }, 'breadcrumb-item', item, false)) : _vm._e();
        }), _vm._v(" "), _vm._t("default")], 2)]);
      },
      staticRenderFns: [],
      name: 'breadcrumb',
      components: {
        BreadcrumbItem: BreadcrumbItem
      },
      props: {
        /**
         * An array of breadcrumbs
         *
         * @prop {Array}
         */
        items: Array
      }
    };

    var plugin$12 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          Breadcrumb: Breadcrumb,
          BreadcrumbItem: BreadcrumbItem
        });
      }
    });

    var Screenreaders = {
      props: {
        /**
         * Should show only for screenreaders
         *
         * @property Boolean
         */
        srOnly: Boolean,

        /**
         * Should be focusable for screenreaders
         *
         * @property Boolean
         */
        srOnlyFocusable: Boolean
      },
      computed: {
        screenreaderClasses: function screenreaderClasses() {
          return {
            'sr-only': this.srOnly,
            'sr-only-focusable': this.srOnlyFocusable
          };
        }
      }
    };

    var HelpText = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('small', {
          staticClass: "form-text",
          class: _vm.classes
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'help-text',
      mixins: [Colorable, Screenreaders],
      computed: {
        classes: function classes() {
          return assignIn({}, this.screenreaderClasses, this.colorableClasses);
        }
      }
    };

    var plugin$13 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          HelpText: HelpText
        });
      }
    });

    var FormGroup = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "form-group"
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'form-group'
    };

    var plugin$14 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          FormGroup: FormGroup
        });
      }
    });

    var FormLabel = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('label', {
          class: _vm.classes
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'form-label',
      mixins: [Colorable, Screenreaders],
      computed: {
        classes: function classes() {
          return assignIn({}, this.screenreaderClasses, this.colorableClasses);
        }
      }
    };

    var plugin$15 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          FormLabel: FormLabel
        });
      }
    });

    var FormFeedback = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          class: {
            'invalid-feedback': _vm.invalid,
            'valid-feedback': _vm.valid && !_vm.invalid
          }
        }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))])], 2);
      },
      staticRenderFns: [],
      name: 'form-feedback',
      mixins: [Colorable],
      props: {
        /**
         * The value of label element. If no value, no label will appear.
         *
         * @property String
         */
        label: String,

        /**
         * Should the feedback marked as invalid
         *
         * @property String
         */
        invalid: Boolean,

        /**
         * Should the feedback marked as invalid
         *
         * @property String
         */
        valid: Boolean
      }
    };

    var plugin$16 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          FormFeedback: FormFeedback
        });
      }
    });

    var FormControl = {
      props: {
        /**
         * The autocomplete attribute value.
         *
         * @property String
         */
        autocomplete: String,

        /**
         * The field id attribute value.
         *
         * @property String
         */
        id: [Number, String],

        /**
         * The value of label element. If no value, no label will appear.
         *
         * @property String
         */
        label: [Number, String],

        /**
         * The field name attribute value.
         *
         * @property String
         */
        name: String,

        /**
         * The field id attribute value.
         *
         * @property String
         */
        value: {
          default: null
        },

        /**
         * The placeholder attribute value.
         *
         * @property String
         */
        placeholder: String,

        /**
         * Is the field required.
         *
         * @property String
         */
        required: Boolean,

        /**
         * Add form-group wrapper to input
         *
         * @property String
         */
        group: {
          type: Boolean,
          value: true
        },

        /**
         * The regex pattern for validation.
         *
         * @property String
         */
        pattern: String,

        /**
         * An inline field validation error.
         *
         * @property String|Boolean
         */
        error: String,

        /**
         * An inline field validation errors passed as object with key/value
         * pairs. If errors passed as an object, the form name will be used for
         * the key.
         *
         * @property Object|Boolean
         */
        errors: {
          type: Object,
          default: function _default() {
            return {};
          }
        },

        /**
         * Some feedback to add to the field once the field is successfully
         * valid.
         *
         * @property String
         */
        feedback: [String, Array],

        /**
         * An array of event names that correlate with callback functions
         *
         * @property Function
         */
        bindEvents: {
          type: Array,
          default: function _default() {
            return ['focus', 'blur', 'change', 'click', 'keyup', 'keydown', 'progress', 'paste'];
          }
        },

        /**
         * The default class name assigned to the control element
         *
         * @property String
         */
        defaultControlClass: {
          type: String,
          default: 'form-control'
        },

        /**
         * Hide the label for browsers, but leave it for screen readers.
         *
         * @property String
         */
        hideLabel: Boolean,

        /**
         * Additional margin/padding classes for fine control of spacing
         *
         * @property String
         */
        spacing: String,

        /**
         * The size of the form control
         *
         * @property String
         */
        size: {
          type: String,
          default: 'md',
          validate: function validate(value) {
            return ['sm', 'md', 'lg'].indexOf(value) !== -1;
          }
        },

        /**
         * Display the form field inline
         *
         * @property String
         */
        inline: Boolean,

        /**
         * If the form control is readonly, display only as text?
         *
         * @property String
         */
        plaintext: Boolean,

        /**
         * Is the form control readonly?
         *
         * @property String
         */
        readonly: Boolean,

        /**
         * Is the form control disabled?
         *
         * @property String
         */
        disabled: Boolean,

        /**
         * Some instructions to appear under the field label
         *
         * @property String
         */
        helpText: [Number, String],

        /**
         * The maxlength attribute
         *
         * @property String
         */
        maxlength: [Number, String]
      },
      directives: {
        bindEvents: {
          bind: function bind(el, binding, vnode) {
            var events = binding.value || vnode.context.bindEvents;

            forEach(events, function (name) {
              el.addEventListener(name, function (event) {
                vnode.context.$emit(name, event);
              });
            });
          }
        }
      },
      methods: {
        blur: function blur() {
          if (this.getInputField()) {
            this.getInputField().blur();
          }
        },
        focus: function focus() {
          if (this.getInputField()) {
            this.getInputField().focus();
          }
        },
        getInputField: function getInputField() {
          return this.$el.querySelector('.form-control, input, select, textarea');
        },
        getFieldErrors: function getFieldErrors() {
          var errors = this.error || this.errors;

          if (isObject(this.errors)) {
            errors = this.errors[this.name || this.id];
          }

          return !errors || isArray(errors) || isObject(errors) ? errors : [errors];
        }
      },
      computed: {
        callbacks: function callbacks() {
          var _this = this;

          return this.bindEvents.map(function (event) {
            return {
              name: event,
              callback: _this[camelCase(['on', event].join(' '))]
            };
          }).filter(function (event) {
            return !isUndefined(event.callback);
          });
        },
        invalidFeedback: function invalidFeedback() {
          if (this.error) {
            return this.error;
          }

          var errors = this.getFieldErrors();
          return isArray(errors) ? errors.join('<br>') : errors;
        },
        validFeedback: function validFeedback() {
          return isArray(this.feedback) ? this.feedback.join('<br>') : this.feedback;
        },
        controlClass: function controlClass() {
          return this.defaultControlClass + (this.plaintext ? '-plaintext' : '');
        },
        controlSizeClass: function controlSizeClass() {
          return prefix(this.size, this.controlClass);
        },
        controlClasses: function controlClasses() {
          return [this.controlClass, this.controlSizeClass, this.spacing || '', this.invalidFeedback ? 'is-invalid' : ''].join(' ');
        },
        hasDefaultSlot: function hasDefaultSlot() {
          return !!this.$slots.default;
        }
      }
    };

    var InputField = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('form-group', {
          staticClass: "input-field",
          class: {
            'has-activity': _vm.activity
          }
        }, [_vm._t("label", [_vm.label || _vm.hasDefaultSlot ? _c('form-label', {
          ref: "label",
          attrs: {
            "for": _vm.id
          },
          domProps: {
            "innerHTML": _vm._s(_vm.label)
          }
        }) : _vm._e()]), _vm._v(" "), _c('div', {
          staticClass: "position-relative"
        }, [_vm._t("control", [_c('input', {
          directives: [{
            name: "bind-events",
            rawName: "v-bind-events",
            value: _vm.bindEvents,
            expression: "bindEvents"
          }],
          ref: "control",
          class: _vm.mergeClasses(_vm.controlClasses, _vm.colorableClasses),
          attrs: {
            "id": _vm.id,
            "type": _vm.type,
            "name": _vm.name,
            "pattern": _vm.pattern,
            "readonly": _vm.readonly,
            "required": _vm.required,
            "maxlength": _vm.maxlength,
            "placeholder": _vm.placeholder,
            "disabled": _vm.disabled || _vm.readonly,
            "aria-label": _vm.label,
            "aria-describedby": _vm.id,
            "autocomplete": _vm.autocomplete
          },
          domProps: {
            "value": _vm.value
          },
          on: {
            "input": function input($event) {
              _vm.$emit('input', $event.target.value);
            }
          }
        })]), _vm._v(" "), _vm._t("activity", [_c('transition', {
          attrs: {
            "name": "slide-fade"
          }
        }, [_vm.activity ? _c('activity-indicator', {
          key: "test",
          ref: "activity",
          attrs: {
            "type": "dots",
            "size": _vm.size
          }
        }) : _vm._e()], 1)]), _vm._v(" "), _vm._t("feedback", [_vm.validFeedback ? _c('form-feedback', {
          ref: "feedback",
          attrs: {
            "valid": ""
          },
          domProps: {
            "innerHTML": _vm._s(_vm.validFeedback)
          }
        }) : _vm.invalidFeedback ? _c('form-feedback', {
          ref: "feedback",
          attrs: {
            "invalid": ""
          },
          domProps: {
            "innerHTML": _vm._s(_vm.invalidFeedback)
          }
        }) : _vm._e()])], 2), _vm._v(" "), _vm._t("help", [_vm.helpText ? _c('help-text', {
          ref: "help",
          domProps: {
            "innerHTML": _vm._s(_vm.helpText)
          }
        }) : _vm._e()])], 2);
      },
      staticRenderFns: [],
      name: 'input-field',
      mixins: [Colorable, FormControl, MergeClasses],
      components: {
        HelpText: HelpText,
        FormGroup: FormGroup,
        FormLabel: FormLabel,
        FormFeedback: FormFeedback,
        ActivityIndicator: ActivityIndicator
      },
      props: {
        /**
         * Show type activity indicator.
         *
         * @property Boolean
         */
        activity: {
          type: Boolean,
          default: false
        },

        /**
         * The type attribute
         *
         * @property String
         */
        type: {
          type: String,
          default: 'text'
        }
      }
    };

    var plugin$17 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          InputField: InputField
        });
      }
    });

    var FileField = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('form-group', [_vm._t("label", [_vm.label || _vm.hasDefaultSlot ? _c('form-label', {
          attrs: {
            "for": _vm.id
          }
        }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))])], 2) : _vm._e()]), _vm._v(" "), _c('div', {
          staticClass: "custom-file"
        }, [_vm._t("placeholder", [_c('form-label', {
          class: _vm.mergeClasses(_vm.colorableClasses, 'custom-file-label'),
          attrs: {
            "for": _vm.id
          },
          domProps: {
            "innerHTML": _vm._s(_vm.placeholder || 'Choose file')
          }
        })]), _vm._v(" "), _c('input', {
          directives: [{
            name: "bind-events",
            rawName: "v-bind-events"
          }],
          class: _vm.controlClasses,
          attrs: {
            "type": "file",
            "id": _vm.id,
            "width": _vm.width,
            "height": _vm.height,
            "required": _vm.required,
            "multiple": _vm.multiple,
            "readonly": _vm.readonly
          },
          on: {
            "change": function change($event) {
              _vm.$emit('change', $event.target.files);
            }
          }
        }), _vm._v(" "), _vm._t("help", [_vm.helpText ? _c('help-text', {
          domProps: {
            "innerHTML": _vm._s(_vm.helpText)
          }
        }) : _vm._e()]), _vm._v(" "), _vm._t("feedback", [_vm.validFeedback ? _c('form-feedback', {
          attrs: {
            "valid": ""
          },
          domProps: {
            "innerHTML": _vm._s(_vm.validFeedback)
          }
        }) : _vm._e(), _vm._v(" "), _vm.invalidFeedback ? _c('form-feedback', {
          attrs: {
            "invalid": ""
          },
          domProps: {
            "innerHTML": _vm._s(_vm.invalidFeedback)
          }
        }) : _vm._e()])], 2)], 2);
      },
      staticRenderFns: [],
      name: 'file-field',
      extends: InputField,
      components: {
        HelpText: HelpText,
        FormGroup: FormGroup,
        FormLabel: FormLabel,
        FormFeedback: FormFeedback,
        MergeClasses: MergeClasses
      },
      model: {
        event: 'change'
      },
      props: {
        /**
         * An array of event names that correlate with callback functions
         *
         * @property Function
         */
        bindEvents: {
          type: Array,
          default: function _default() {
            return ['focus', 'blur', 'input', 'click', 'keyup', 'keydown', 'progress'];
          }
        },

        /**
         * The class name assigned to the control element
         *
         * @property String
         */
        defaultControlClass: {
          type: String,
          default: 'custom-file-input'
        },

        /**
         * An array of valid extensions
         *
         * @property String
         */
        extensions: Array,

        /**
         * The type attribute
         *
         * @property String
         */
        multiple: Boolean,

        /**
         * The height attribute for the control element
         *
         * @property String
         */
        height: [Number, String],

        /**
         * The width attribute for the control element
         *
         * @property String
         */
        width: [Number, String]
      }
    };

    var plugin$18 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          FileField: FileField
        });
      }
    });

    var BtnFile = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('btn', {
          staticClass: "btn-file",
          attrs: {
            "type": _vm.type,
            "variant": _vm.variant,
            "block": _vm.block,
            "size": _vm.size,
            "disabled": _vm.disabled,
            "active": _vm.active
          }
        }, [_vm._t("default"), _vm._v(" "), _c('input', {
          directives: [{
            name: "bind-events",
            rawName: "v-bind-events"
          }],
          class: _vm.controlClasses,
          attrs: {
            "type": "file",
            "id": _vm.id,
            "width": _vm.width,
            "height": _vm.height,
            "required": _vm.required,
            "multiple": _vm.multiple,
            "readonly": _vm.readonly
          },
          on: {
            "change": function change($event) {
              _vm.$emit('change', _vm.multiple ? $event.target.files : $event.target.files[0]);
            }
          }
        })], 2);
      },
      staticRenderFns: [],
      name: 'btn-file',
      mixins: [FileField],
      components: {
        Btn: Btn,
        FileField: FileField
      },
      model: {
        event: 'change'
      },
      props: {
        /**
         * The type attribute for the button. Not applied if an anchor
         *
         * @property String
         */
        type: {
          type: String,
          default: 'button'
        }
      }
    };

    var plugin$19 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          BtnFile: BtnFile
        });
      }
    });

    var BtnGroup = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          class: _vm.classes,
          attrs: {
            "data-toggle": _vm.toggle ? 'buttons' : false,
            "role": "group"
          }
        }, [_vm._l(_vm.buttons, function (button, i) {
          return _vm.buttons ? _c('btn', _vm._b({
            key: i
          }, 'btn', button, false)) : _vm._e();
        }), _vm._v(" "), _vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'btn-group',
      components: {
        Btn: Btn
      },
      mixins: [Colorable, MergeClasses],
      props: {
        /**
         * An array of buttons
         *
         * @type {Array}
         */
        buttons: Array,

        /**
         * Denote the button group as toggle buttons
         *
         * @type {Boolean}
         */
        toggle: Boolean,

        /**
         * Display the buttons vertically
         *
         * @type {Boolean}
         */
        vertical: Boolean
      },
      computed: {
        classes: function classes() {
          return this.mergeClasses(this.colorableClasses, {
            'btn-group': !this.vertical,
            'btn-group-toggle': this.toggle,
            'btn-group-vertical': this.vertical
          });
        }
      }
    };

    var BtnGroupToggle = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "btn-group-toggle",
          attrs: {
            "data-toggle": "buttons"
          }
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'btn-group-toggle'
    };

    var BtnToolbar = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "btn-toolbar",
          attrs: {
            "role": "toolbar"
          }
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'btn-toolbar'
    };

    var plugin$20 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          BtnGroup: BtnGroup,
          BtnGroupToggle: BtnGroupToggle,
          BtnToolbar: BtnToolbar
        });
      }
    });

    function uuid() {
      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        var r = Math.random() * 16 | 0,
            v = c == 'x' ? r : r & 0x3 | 0x8;
        return v.toString(16);
      });
    }

    var Proxy = {
      methods: {
        proxy: function proxy(callback, event) {
          if (isFunction$1(callback)) {
            callback.apply(this, [].slice.call(arguments).splice(1));
            event.preventDefault();
          }
        }
      }
    };

    var DropdownMenuItem = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c(_vm.component, {
          tag: "component",
          staticClass: "dropdown-item",
          class: {
            'active': _vm.active
          },
          attrs: {
            "href": _vm.href || (_vm.component === 'a' ? '#' : false),
            "type": _vm.component === 'button' ? 'button' : false
          },
          on: {
            "click": _vm.onClick
          }
        }, [_vm.icon ? _c('i', {
          class: _vm.icon
        }) : _vm._e(), _vm._v(" "), _vm._t("default", [_vm._v(_vm._s(_vm.label))])], 2);
      },
      staticRenderFns: [],
      mixins: [Proxy],
      props: {
        /**
         * Is the menu item active.
         *
         * @property Object
         */
        active: Boolean,

        /**
         * Is the menu item a button
         *
         * @property Object
         */
        button: Boolean,

        /**
         * The `element` attribute.
         *
         * @property Object
         */
        element: String,

        /**
         * The `href` attribute.
         *
         * @property Object
         */
        href: String,

        /**
         * The icon of the dropdown menu item.
         *
         * @property Object
         */
        icon: String,

        /**
         * The label of the dropdown menu item.
         *
         * @property Object
         */
        label: String
      },
      computed: {
        component: function component() {
          return this.element || (this.button ? 'button' : 'a');
        }
      },
      methods: {
        /**
         * A callback function for the `click` event.
         *
         * @property Object
         */
        onClick: function onClick(event) {
          this.$emit('click', event);
        }
      }
    };

    var DropdownMenuHeader = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('h5', {
          staticClass: "dropdown-header"
        }, [_vm._t("default", [_vm._v(_vm._s(_vm.header))])], 2);
      },
      staticRenderFns: [],
      name: 'dropdown-menu-header',
      props: {
        /**
         * The value of the header
         *
         * @property Object
         */
        header: String
      }
    };

    var DropdownMenuDivider = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "dropdown-divider"
        });
      },
      staticRenderFns: [],
      name: 'dropdown-menu-divider'
    };

    var DropdownMenu = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "dropdown-menu",
          class: {
            'dropdown-menu-right': _vm.align === 'right',
            'show': _vm.show
          },
          attrs: {
            "aria-labelledby": _vm.id,
            "tabindex": "-1"
          },
          on: {
            "click": _vm.onClick
          }
        }, [_vm._l(_vm.items, function (item) {
          return [_c(_vm.prefix(item.type || 'item', 'dropdown-menu'), _vm._b({
            tag: "component"
          }, 'component', item, false))];
        }), _vm._v(" "), _vm._t("default")], 2);
      },
      staticRenderFns: [],
      components: {
        DropdownMenuItem: DropdownMenuItem,
        DropdownMenuHeader: DropdownMenuHeader,
        DropdownMenuDivider: DropdownMenuDivider
      },
      props: {
        /**
         * The `id` attribute on the toggle button and aria label. If no `id` is
         * defined, then a UUID will be generated instead.
         *
         * @property Object
         */
        id: {
          type: String,
          default: uuid
        },

        /**
         * Display the dropdown menu aligned left or right
         *
         * @property String
         */
        align: {
          type: String,
          default: 'left',
          validate: function validate(value) {
            return ['left', 'right'].indexOf(value.toLowerCase()) !== -1;
          }
        },

        /**
         * The default visibility of the dropdown menu.
         *
         * @property Object
         */
        show: Boolean,

        /**
         * An array of dropdown items. If an key/value pair isn't defined, the
         * default value will be used. If no items are defined, then the slot
         * named "items" can be used to define the options with HTML.
         *
         * [{
         *      type: 'item', // String [item|header|divider]
         *      href: '#', // String
         *      label: 'Some label', // String
         *      onClick: (event) => {} // Function
         * }]
         *
         * @property Array
         */
        items: Array
      },
      methods: {
        prefix: prefix,

        /**
         * A callback function for the `click` event.
         *
         * @param Object event
         * @param Object item
         * @return void
         */
        onClick: function onClick(event) {
          this.$emit('click', event);
        },

        /**
         * A callback function for the `click` event.
         *
         * @param Object event
         * @param Object item
         * @return void
         */
        onItemClick: function onItemClick(event, item) {
          this.$emit('item:click', event, item);
        }
      },
      mounted: function mounted() {
        var _this = this;

        forEach(this.$children, function (child) {
          child.$on('click', function (event) {
            _this.onItemClick(event, child);
          });
        });
      }
    };

    var plugin$21 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          DropdownMenu: DropdownMenu,
          DropdownMenuDivider: DropdownMenuDivider,
          DropdownMenuHeader: DropdownMenuHeader,
          DropdownMenuItem: DropdownMenuItem
        });
      }
    });

    var TAB_KEYCODE = 9;
    var LEFT_ARROW_KEYCODE = 37;
    var RIGHT_ARROW_KEYCODE = 39;
    var UP_ARROW_KEYCODE = 38;
    var DOWN_ARROW_KEYCODE = 40;
    var ignoreBlurEvent = false;
    var BtnDropdown = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _vm.split ? _c('btn-group', [!_vm.dropleft ? [_vm.href ? _c('a', {
          class: _vm.actionClasses,
          attrs: {
            "href": _vm.href
          },
          on: {
            "click": _vm.onClick
          }
        }, [_vm._t("label", [_vm.icon ? _c('i', {
          class: _vm.icon
        }) : _vm._e(), _vm._v(" " + _vm._s(_vm.label))])], 2) : _c('button', {
          class: _vm.actionClasses,
          attrs: {
            "type": _vm.type
          },
          on: {
            "click": _vm.onClick
          }
        }, [_vm._t("label-wrapper", [_vm.icon ? _c('i', {
          class: _vm.icon
        }) : _vm._e(), _vm._v(" "), _vm._t("label", [_vm._v(_vm._s(_vm.label))])])], 2)] : _vm._e(), _vm._v(" "), _c('btn-group', {
          class: {
            'dropup': _vm.dropup,
            'dropright': _vm.dropright,
            'dropleft': _vm.dropleft
          }
        }, [_c('button', {
          class: _vm.toggleClasses,
          attrs: {
            "type": "button",
            "aria-haspopup": "true",
            "aria-expanded": _vm.isDropdownShowing,
            "id": _vm.id
          },
          on: {
            "click": function click($event) {
              $event.preventDefault();
              !_vm.isDropdownShowing ? _vm.show() : _vm.hide();
            },
            "blur": _vm.onBlur
          }
        }), _vm._v(" "), _c('dropdown-menu', {
          attrs: {
            "id": _vm.id,
            "align": _vm.align,
            "show": _vm.isDropdownShowing
          },
          on: {
            "update:show": function updateShow($event) {
              _vm.isDropdownShowing = $event;
            },
            "click": _vm.onMenuClick,
            "item:click": _vm.onItemClick
          }
        }, [_vm._t("default")], 2)], 1), _vm._v(" "), _vm.dropleft ? [_vm.href ? _c('a', {
          class: _vm.actionClasses,
          attrs: {
            "href": _vm.href
          },
          on: {
            "click": _vm.onClick
          }
        }, [_vm._t("label", [_vm.icon ? _c('i', {
          class: _vm.icon
        }) : _vm._e(), _vm._v(" " + _vm._s(_vm.label))])], 2) : _c('button', {
          class: _vm.actionClasses,
          attrs: {
            "type": _vm.type
          },
          on: {
            "click": _vm.onClick
          }
        }, [_vm._t("label-wrapper", [_vm.icon ? _c('i', {
          class: _vm.icon
        }) : _vm._e(), _vm._v(" "), _vm._t("label", [_vm._v(_vm._s(_vm.label))])])], 2)] : _vm._e()], 2) : _c('btn-group', {
          class: {
            'dropup': _vm.dropup,
            'dropright': _vm.dropright,
            'dropleft': _vm.dropleft
          },
          on: {
            "click": _vm.onClick
          }
        }, [_c('button', {
          class: _vm.toggleClasses,
          attrs: {
            "aria-haspopup": "true",
            "aria-expanded": _vm.isDropdownShowing,
            "type": _vm.type,
            "id": _vm.id
          },
          on: {
            "click": function click($event) {
              $event.preventDefault();
              !_vm.isDropdownShowing ? _vm.show() : _vm.hide();
            },
            "blur": _vm.onBlur
          }
        }, [_vm._t("label", [_vm.icon ? _c('i', {
          class: _vm.icon
        }) : _vm._e(), _vm._v(" " + _vm._s(_vm.label))])], 2), _vm._v(" "), _c('dropdown-menu', {
          attrs: {
            "id": _vm.id,
            "align": _vm.align,
            "show": _vm.isDropdownShowing
          },
          on: {
            "update:show": function updateShow($event) {
              _vm.isDropdownShowing = $event;
            },
            "click": _vm.onMenuClick,
            "item:click": _vm.onItemClick
          }
        }, [_vm._t("default")], 2)], 1);
      },
      staticRenderFns: [],
      name: 'btn-dropdown',
      extends: Btn,
      components: {
        BtnGroup: BtnGroup,
        DropdownMenu: DropdownMenu
      },
      props: {
        /**
         * The button icon that appears before the label.
         *
         * @property String
         */
        autoclose: Boolean,

        /**
         * The button icon that appears before the label.
         *
         * @property String
         */
        icon: String,

        /**
         * The toggle button's label. If not defined as an attribute,
         * you can override with the component's slot (inner html).
         *
         * @property String
         */
        label: String,

        /**
         * The `id` attribute on the toggle button and aria label. If no `id` is
         * defined, then a UUID will be generated instead.
         *
         * @property String
         */
        id: {
          type: String,
          default: uuid
        },

        /**
         * The button type attribute.
         *
         * @property String
         */
        type: {
          type: String,
          default: 'button'
        },

        /**
         * Display the dropdown menu aligned left or right
         *
         * @property String
         */
        align: {
          type: String,
          default: 'left',
          validate: function validate(value) {
            return ['left', 'right'].indexOf(value.toLowerCase()) !== -1;
          }
        },

        /**
         * Display the dropdown button with a split toggle button.
         *
         * @property Boolean
         */
        split: {
          type: Boolean,
          default: false
        },

        /**
         * Display as a dropup instead of a dropdown.
         *
         * @property Boolean
         */
        dropup: {
          type: Boolean,
          default: false
        },

        /**
         * Display as a dropright instead of a dropdown.
         *
         * @property Boolean
         */
        dropright: {
          type: Boolean,
          default: false
        },

        /**
         * Display as a dropleft instead of a dropdown.
         *
         * @property Boolean
         */
        dropleft: {
          type: Boolean,
          default: false
        }
      },
      methods: {
        /**
         * Focus on the the dropdown toggle button
         *
         * @return void
         */
        focus: function focus() {
          this.$el.querySelector('.dropdown-toggle').focus();
        },

        /**
         * Focus on the the dropdown toggle button
         *
         * @return void
         */
        queryFocusable: function queryFocusable() {
          return this.$el.querySelector('.dropdown-menu').querySelectorAll('label, input, select, textarea, [tabindex]:not([tabindex="-1"])');
        },

        /**
         * Method to check if the given element is focusable.
         *
         * @return void
         */
        isFocusable: function isFocusable(element) {
          var nodes = this.queryFocusable();

          for (var i in nodes) {
            if (element === nodes[i]) {
              return true;
            }
          }

          return false;
        },

        /**
         * Toggle the dropdown menu
         *
         * @return void
         */
        toggle: function toggle() {
          !this.isDropdownShowing ? this.show() : this.hide();
        },

        /**
         * Show the dropdown menu
         *
         * @return void
         */
        show: function show() {
          var _this = this;

          this.isDropdownShowing = true;
          this.$nextTick(function () {
            var side = 'bottom';

            if (_this.dropup) {
              side = 'top';
            } else if (_this.dropleft) {
              side = 'left';
            } else if (_this.dropright) {
              side = 'right';
            }

            var menu = _this.$el.querySelector('.dropdown-menu');

            var toggle = _this.$el.querySelector('.dropdown-toggle');

            var position = [side, _this.align === 'left' ? 'start' : 'end'];
            new Popper(toggle, menu, {
              placement: position.join('-')
            });

            if (_this.queryFocusable().item(0)) {
              _this.$el.querySelector('input, select, textarea').focus();
            }

            _this.$emit('show');
          });
        },

        /**
         * Hide the dropdown menu
         *
         * @return void
         */
        hide: function hide() {
          this.$emit('toggle', this.isDropdownShowing = false);
          this.$emit('hide');
        },

        /**
         * A callback function for the `click` event for the action button
         *
         * @return void
         */
        onClick: function onClick(event) {
          this.hide();
          this.$emit('click', event);
        },

        /**
         * A callback function for the `blur` event for the action button
         *
         * @return void
         */
        onBlur: function onBlur(event) {
          if (!this.$el.contains(event.relatedTarget)) {
            this.hide();
          }
        },

        /**
         * A callback function for the `item:click` event for the action button
         *
         * @return void
         */
        onMenuClick: function onMenuClick(event, item) {
          if (event.target === this.$el.querySelector('.dropdown-menu')) {
            this.focus();
          }
        },

        /**
         * A callback function for the `item:click` event for the action button
         *
         * @return void
         */
        onItemClick: function onItemClick(event, item) {
          if (!this.isFocusable(event.target)) {
            this.hide();
          }

          this.$emit('item:click', event, item);
        }
      },
      computed: {
        variantClassPrefix: function variantClassPrefix() {
          return 'btn' + (this.outline ? '-outline' : '');
        },
        sizeableClassPrefix: function sizeableClassPrefix() {
          return 'btn';
        },
        actionClasses: function actionClasses() {
          return ['btn', prefix(this.size, 'btn'), prefix(this.variant, 'btn')].join(' ');
        },
        toggleClasses: function toggleClasses() {
          return ['btn', 'dropdown-toggle', this.variantClass, this.sizeableClass, this.active ? 'active' : '', this.block ? 'btn-block' : '', this.split ? 'dropdown-toggle-split' : ''].join(' ');
        }
      },
      data: function data() {
        return {
          isDropdownShowing: false
        };
      },
      mounted: function mounted() {
        var _this2 = this;

        forEach(this.$el.querySelectorAll('[type=submit], input, select, textarea, [tabindex]:not([tabindex="-1"]'), function (el) {
          var keydown = function keydown(event) {
            var ignore = [LEFT_ARROW_KEYCODE, RIGHT_ARROW_KEYCODE, UP_ARROW_KEYCODE, DOWN_ARROW_KEYCODE, TAB_KEYCODE];

            if (ignore.indexOf(event.keyCode) !== -1) {
              ignoreBlurEvent = true;
            }
          };

          var blur = function blur(event) {
            if (!ignoreBlurEvent) {
              _this2.focus();
            }

            ignoreBlurEvent = false;
          };

          var focus = function focus(event) {
            ignoreBlurEvent = false;
          };

          var mousedown = function mousedown(event) {
            ignoreBlurEvent = true;
          };

          el.addEventListener('blur', blur);
          el.addEventListener('focus', focus);
          el.addEventListener('keydown', keydown);
          el.addEventListener('mousedown', mousedown);
        });
      }
    };

    var plugin$22 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          BtnDropdown: BtnDropdown
        });
      }
    });

    var HasSlots = {
      methods: {
        getSlot: function getSlot(slot) {
          return this.$slots[slot];
        },
        hasSlot: function hasSlot(slot) {
          return !!this.$slots[slot];
        },
        hasSlots: function hasSlots(slots) {
          for (var i in slots) {
            if (!this.hasSlot(slots[i])) {
              return false;
            }
          }
        }
      },
      computed: {
        hasDefaultSlot: function hasDefaultSlot() {
          return this.hasSlot('default');
        }
      }
    };

    var Card = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          class: _vm.mergeClasses(_vm.className, _vm.colorableClasses)
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'card',
      mixins: [HasSlots, Colorable, MergeClasses],
      computed: {
        className: function className() {
          return this.$options.name;
        }
      }
    };

    var CardBody = {
      name: 'card-body',
      extends: Card
    };

    var CardBtnGroup = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('btn-group', {
          staticClass: "card-btn-group"
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'card-btn-group',
      extends: Card
    };

    var CardDeck = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "card-deck"
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'card-deck'
    };

    var CardHeader = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c(_vm.tag, {
          tag: "component",
          class: _vm.mergeClasses(_vm.className, _vm.colorableClasses)
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'card-header',
      extends: Card,
      mixins: [MergeClasses],
      props: {
        /**
         * The component's HTML tag name
         *
         * @property String
         */
        tag: {
          type: String,
          default: 'h5'
        }
      }
    };

    var CardFooter = {
      name: 'card-footer',
      extends: CardHeader,
      props: {
        /**
         * The component's HTML tag name
         *
         * @property String
         */
        tag: {
          type: String,
          default: 'div'
        }
      }
    };

    var CardImg = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "d-flex justify-content-center align-items-center",
          class: _vm.mergeClasses(_vm.className),
          style: {
            height: _vm.unit(_vm.height)
          }
        }, [_vm.background ? _c('div', {
          staticClass: "card-img-bg",
          style: {
            background: _vm.background ? "url(".concat(this.src, ")") : null,
            overflow: _vm.blur ? 'hidden' : 'inherit',
            filter: _vm.blur ? "blur(".concat(_vm.unit(_vm.blur), ")") : null
          }
        }) : _vm._e(), _vm._v(" "), !_vm.background && _vm.src ? _c('img', {
          staticClass: "img-fluid",
          attrs: {
            "src": _vm.src,
            "alt": _vm.alt
          }
        }) : _vm._e(), _vm._v(" "), _c('div', {
          staticClass: "card-img-content",
          class: {
            'text-truncate': _vm.textTruncate
          }
        }, [_vm._t("default")], 2)]);
      },
      staticRenderFns: [],
      name: 'card-img',
      extends: Card,
      mixins: [MergeClasses],
      props: {
        /**
         * The alt attribute
         *
         * @property String
         */
        alt: String,

        /**
         * Display the image as a background image fit with CSS cover.
         *
         * @property String
         */
        background: Boolean,

        /**
         * The amount to blur the background image.
         *
         * @property String
         */
        blur: [Number, String],

        /**
         * The height attribute
         *
         * @property String
         */
        height: [Number, String],

        /**
         * Truncate the text in the content
         *
         * @property String
         */
        textTruncate: Boolean,

        /**
         * The src attribute
         *
         * @property String
         */
        src: String
      },
      methods: {
        unit: function unit$$1(value) {
          return unit(value);
        }
      }
    };

    var CardImgTop = {
      name: 'card-img-top',
      extends: CardImg
    };

    var CardImgBottom = {
      name: 'card-img-bottom',
      extends: CardImg
    };

    var CardImgOverlay = {
      name: 'card-img-overlay',
      extends: Card
    };

    var CardLink = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('router-link', {
          class: _vm.mergeClasses(_vm.className, _vm.colorableClasses),
          attrs: {
            "to": _vm.href
          },
          on: {
            "click": _vm.onClick
          }
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'card-link',
      extends: Card,
      mixins: [MergeClasses],
      props: {
        /**
         * The alt attribute
         *
         * @property String
         */
        alt: String,

        /**
         * The href attribute
         *
         * @property String
         */
        href: String,

        /**
         * The to attribute
         *
         * @property String
         */
        to: [Object, String]
      },
      methods: {
        onClick: function onClick(event) {
          this.$emit('click', event);
        }
      }
    };

    var CardSubtitle = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('h6', {
          class: _vm.mergeClasses(_vm.className, _vm.colorableClasses)
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'card-subtitle',
      extends: Card,
      mixins: [MergeClasses]
    };

    var CardTitle = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('h5', {
          class: _vm.mergeClasses(_vm.className, _vm.colorableClasses)
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'card-title',
      mixins: [Card, MergeClasses]
    };

    var plugin$23 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          Card: Card,
          CardBody: CardBody,
          CardBtnGroup: CardBtnGroup,
          CardDeck: CardDeck,
          CardFooter: CardFooter,
          CardHeader: CardHeader,
          CardImg: CardImg,
          CardImgTop: CardImgTop,
          CardImgBottom: CardImgBottom,
          CardImgOverlay: CardImgOverlay,
          CardLink: CardLink,
          CardSubtitle: CardSubtitle,
          CardTitle: CardTitle
        });
      }
    });

    var RadioField = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          class: _vm.mergeClasses(_vm.controlClass, _vm.customControlClass, _vm.sizeableClass, _vm.inline ? _vm.inlineClass : '')
        }, [_vm.custom && _vm.id ? [_c('input', {
          directives: [{
            name: "bind-events",
            rawName: "v-bind-events"
          }],
          class: _vm.mergeClasses(_vm.inputClass, _vm.invalidFeedback ? 'is-invalid' : ''),
          attrs: {
            "type": "radio",
            "name": _vm.name,
            "id": _vm.id,
            "required": _vm.required,
            "disabled": _vm.disabled || _vm.readonly,
            "readonly": _vm.readonly,
            "pattern": _vm.pattern
          },
          domProps: {
            "value": _vm.value,
            "checked": _vm.checkedValue === _vm.value || _vm.checked
          },
          on: {
            "change": function change($event) {
              _vm.$emit('change', $event.target.value);
            }
          }
        }), _vm._v(" "), _c('label', {
          class: _vm.mergeClasses(_vm.labelClass, _vm.colorableClasses),
          attrs: {
            "for": _vm.id
          }
        }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))]), _vm._v(" "), _vm._t("feedback", [_vm.validFeedback ? _c('form-feedback', {
          attrs: {
            "valid": ""
          },
          domProps: {
            "innerHTML": _vm._s(_vm.validFeedback)
          }
        }) : _vm._e(), _vm._v(" "), _vm.invalidFeedback ? _c('form-feedback', {
          attrs: {
            "invalid": ""
          },
          domProps: {
            "innerHTML": _vm._s(_vm.invalidFeedback)
          }
        }) : _vm._e()])], 2)] : [_c('label', {
          class: _vm.mergeClasses(_vm.labelClass, _vm.colorableClasses),
          attrs: {
            "for": _vm.id
          }
        }, [_c('input', {
          directives: [{
            name: "bind-events",
            rawName: "v-bind-events"
          }],
          class: _vm.mergeClasses(_vm.inputClass, _vm.invalidFeedback ? 'is-invalid' : ''),
          attrs: {
            "type": "radio",
            "name": _vm.name,
            "id": _vm.id,
            "required": _vm.required,
            "disabled": _vm.disabled || _vm.readonly,
            "readonly": _vm.readonly,
            "pattern": _vm.pattern
          },
          domProps: {
            "value": _vm.value,
            "checked": _vm.checkedValue === _vm.value || _vm.checked
          },
          on: {
            "change": function change($event) {
              _vm.$emit('change', $event.target.value);
            }
          }
        }), _vm._v(" "), _vm._t("default", [_vm._v(_vm._s(_vm.label))]), _vm._v(" "), _vm._t("feedback", [_vm.validFeedback ? _c('form-feedback', {
          attrs: {
            "valid": ""
          },
          domProps: {
            "innerHTML": _vm._s(_vm.validFeedback)
          }
        }) : _vm._e(), _vm._v(" "), _vm.invalidFeedback ? _c('form-feedback', {
          attrs: {
            "invalid": ""
          },
          domProps: {
            "innerHTML": _vm._s(_vm.invalidFeedback)
          }
        }) : _vm._e()])], 2)], _vm._v(" "), _vm._t("help", [_vm.helpText ? _c('help-text', {
          domProps: {
            "innerHTML": _vm._s(_vm.helpText)
          }
        }) : _vm._e()])], 2);
      },
      staticRenderFns: [],
      name: 'radio-field',
      components: {
        HelpText: HelpText,
        FormFeedback: FormFeedback
      },
      mixins: [Colorable, FormControl, MergeClasses],
      model: {
        event: 'change',
        prop: 'checkedValue'
      },
      props: {
        /**
         * An array of event names that correlate with callback functions
         *
         * @property Function
         */
        bindEvents: {
          type: Array,
          default: function _default() {
            return ['focus', 'blur', 'input', 'click', 'keyup', 'keydown', 'progress'];
          }
        },

        /**
         * Is this a custom element
         *
         * @property String
         */
        custom: Boolean,

        /**
         * Display the form field and label inline
         *
         * @property Function
         */
        inline: Boolean,

        /**
         * The checked values
         *
         * @property String
         */
        checked: Boolean,

        /**
         * The checked value
         *
         * @property String
         */
        checkedValue: [Boolean, Number, String, Object],

        /**
         * The class name assigned to the control element
         *
         * @property String
         */
        defaultControlClass: {
          type: String,
          default: 'form-check'
        }
      },
      computed: {
        labelClass: function labelClass() {
          return prefix('label', this.controlClass);
        },
        inputClass: function inputClass() {
          return prefix('input', this.controlClass);
        },
        inlineClass: function inlineClass() {
          return prefix('inline', this.controlClass);
        },
        controlClass: function controlClass() {
          return this.custom ? 'custom-control' : this.defaultControlClass;
        },
        customControlClass: function customControlClass() {
          return this.custom ? prefix(this.$options.name.replace('-field', ''), 'custom') : '';
        },
        sizeableClass: function sizeableClass() {
          return prefix(this.size, 'form-control');
        }
      }
    };

    var plugin$24 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          RadioField: RadioField
        });
      }
    });

    var CheckboxField = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          class: _vm.mergeClasses(_vm.controlClass, _vm.customControlClass, _vm.sizeableClass, _vm.inline ? _vm.inlineClass : '')
        }, [_vm.custom && _vm.id ? [_c('input', {
          directives: [{
            name: "bind-events",
            rawName: "v-bind-events"
          }],
          class: _vm.mergeClasses(_vm.inputClass, _vm.invalidFeedback ? 'is-invalid' : ''),
          attrs: {
            "type": "checkbox",
            "name": _vm.name,
            "id": _vm.id,
            "required": _vm.required,
            "disabled": _vm.disabled || _vm.readonly,
            "readonly": _vm.readonly,
            "pattern": _vm.pattern
          },
          domProps: {
            "value": _vm.value,
            "checked": _vm.checkedValues.indexOf(_vm.value) !== -1 || _vm.checked
          },
          on: {
            "change": function change($event) {
              _vm.update($event.target.value);
            }
          }
        }), _vm._v(" "), _c('label', {
          class: _vm.mergeClasses(_vm.labelClass, _vm.colorableClasses),
          attrs: {
            "for": _vm.id
          }
        }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))]), _vm._v(" "), _vm._t("feedback", [_vm.validFeedback ? _c('form-feedback', {
          attrs: {
            "valid": ""
          },
          domProps: {
            "innerHTML": _vm._s(_vm.validFeedback)
          }
        }) : _vm._e(), _vm._v(" "), _vm.invalidFeedback ? _c('form-feedback', {
          attrs: {
            "invalid": ""
          },
          domProps: {
            "innerHTML": _vm._s(_vm.invalidFeedback)
          }
        }) : _vm._e()])], 2)] : [_c('label', {
          class: _vm.mergeClasses(_vm.labelClass, _vm.colorableClasses),
          attrs: {
            "for": _vm.id
          }
        }, [_c('input', {
          directives: [{
            name: "bind-events",
            rawName: "v-bind-events"
          }],
          class: _vm.mergeClasses(_vm.inputClass, _vm.invalidFeedback ? 'is-invalid' : ''),
          attrs: {
            "type": "checkbox",
            "name": _vm.name,
            "id": _vm.id,
            "required": _vm.required,
            "disabled": _vm.disabled || _vm.readonly,
            "readonly": _vm.readonly,
            "pattern": _vm.pattern
          },
          domProps: {
            "value": _vm.value,
            "checked": _vm.checkedValues.indexOf(_vm.value) !== -1 || _vm.checked
          },
          on: {
            "change": function change($event) {
              _vm.update($event.target.value);
            }
          }
        }), _vm._v(" "), _vm._t("default", [_vm._v(_vm._s(_vm.label))]), _vm._v(" "), _vm._t("feedback", [_vm.validFeedback ? _c('form-feedback', {
          attrs: {
            "valid": ""
          },
          domProps: {
            "innerHTML": _vm._s(_vm.validFeedback)
          }
        }) : _vm._e(), _vm._v(" "), _vm.invalidFeedback ? _c('form-feedback', {
          attrs: {
            "invalid": ""
          },
          domProps: {
            "innerHTML": _vm._s(_vm.invalidFeedback)
          }
        }) : _vm._e()])], 2)], _vm._v(" "), _vm._t("help", [_vm.helpText ? _c('help-text', {
          domProps: {
            "innerHTML": _vm._s(_vm.helpText)
          }
        }) : _vm._e()])], 2);
      },
      staticRenderFns: [],
      name: 'checkbox-field',
      extends: RadioField,
      mixins: [MergeClasses],
      model: {
        event: 'change',
        prop: 'checkedValues'
      },
      props: {
        /**
         * The checked values
         *
         * @property String
         */
        checkedValues: {
          type: Array,
          default: function _default() {
            return [];
          }
        }
      },
      methods: {
        update: function update(value) {
          var checked = this.checkedValues.slice(0);
          var index = this.checkedValues.indexOf(value);

          if (index === -1) {
            checked.push(value);
          } else {
            checked.splice(index, 1);
          }

          this.$emit('change', checked);
        }
      }
    };

    var plugin$25 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          CheckboxField: CheckboxField
        });
      }
    });

    var Dropzone = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "dropzone",
          class: {
            'is-dragging': _vm.isDragging
          },
          on: {
            "drop": function drop($event) {
              $event.preventDefault();
              return _vm.onDrop($event);
            },
            "dragover": function dragover($event) {
              $event.preventDefault();
              return _vm.onDragover($event);
            },
            "dragenter": function dragenter($event) {
              $event.preventDefault();
              return _vm.onDragenter($event);
            },
            "dragleave": function dragleave($event) {
              $event.preventDefault();
              return _vm.onDragleave($event);
            }
          }
        }, [_vm._t("placeholder", [_c('div', {
          staticClass: "dropzone-placeholder text-center"
        }, [_c('card', [_c('card-body', [_c('h1', {
          staticClass: "mt-4"
        }, [_vm._v("Drag & Drop")]), _vm._v(" "), _c('p', [_vm._v("Drag and drop your files here to upload them!")]), _vm._v(" "), _c('div', {
          staticClass: "mt-3"
        }, [_c('i', {
          staticClass: "fa fa-image"
        })])])], 1)], 1)]), _vm._v(" "), _vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'dropzone',
      components: {
        Card: Card,
        CardBody: CardBody
      },
      methods: {
        onDrop: function onDrop(event) {
          this.isDragging = false;
          this.$emit('drop', event);
        },
        onDragover: function onDragover(event) {
          this.isDragging = true;
          this.$emit('dragover', event);
        },
        onDragenter: function onDragenter(event) {
          this.isDragging = true;
          this.$emit('dragenter', event);
          this.onDragover(event);
        },
        onDragleave: function onDragleave(event) {
          this.isDragging = false;
          this.$emit('dragleave', event);
        }
      },
      data: function data() {
        return {
          files: null,
          isDragging: false
        };
      }
    };

    var plugin$26 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          Dropzone: Dropzone
        });
      }
    });

    function readFile(file, progress) {
      if (!(file instanceof File)) {
        throw new Error('The first argument be an instance of File object.');
      }

      return new Promise(function (resolve, reject) {
        var reader = new FileReader();

        if (isFunction$1(progress)) {
          reader.onprogress = function (e) {
            return progress(e, reader);
          };
        }

        reader.onload = function (e) {
          return resolve(e);
        };

        reader.onerror = function (e) {
          return reject(e);
        };

        reader.onabort = function (e) {
          return reject(e);
        };

        reader.readAsDataURL(file);
      });
    }

    var FilePreview = {
      render: function render() {
        var _this = this;

        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "file-preview",
          class: {
            'has-image': !!_vm.image
          }
        }, [_c('div', {
          staticClass: "file-preview-inner"
        }, [!_vm.hideClose ? _c('a', {
          staticClass: "file-preview-close",
          attrs: {
            "href": "#"
          },
          on: {
            "click": function click($event) {
              $event.preventDefault();

              _vm.$emit('close', _vm.file);
            }
          }
        }, [_c('i', {
          staticClass: "fa fa-times-circle"
        })]) : _vm._e(), _vm._v(" "), !!_vm.poster || _vm.isImage ? _c('div', {
          staticClass: "file-preview-image"
        }, [!!_vm.poster || !!_vm.image ? _c('img', {
          staticClass: "file-preview-thumbnail",
          attrs: {
            "src": _vm.poster || _vm.image
          },
          on: {
            "load": _vm.onLoad
          }
        }) : _vm._e()]) : _c('div', {
          directives: [{
            name: "ready",
            rawName: "v-ready",
            value: function value() {
              return _this.$emit('loaded');
            },
            expression: "() => this.$emit('loaded')"
          }],
          staticClass: "file-preview-icon"
        }, [_c('i', {
          staticClass: "fa",
          class: {
            'fa-file-video-o': _vm.isVideo,
            'fa-file-o': !_vm.isVideo
          }
        })]), _vm._v(" "), _vm.progress || _vm.isImage && _vm.loaded !== false ? _c('progress-bar', {
          directives: [{
            name: "ready",
            rawName: "v-ready",
            value: _vm.readFile,
            expression: "readFile"
          }],
          staticClass: "mt-3",
          attrs: {
            "value": _vm.progress || _vm.loaded || 0,
            "height": 10
          }
        }) : _vm._e(), _vm._v(" "), _c('div', {
          staticClass: "file-preview-filename",
          domProps: {
            "innerHTML": _vm._s(_vm.name)
          }
        }), _vm._v(" "), _c('div', {
          staticClass: "file-preview-filesize"
        }, [_vm._v("(" + _vm._s(_vm.size) + ")")]), _vm._v(" "), _c('div')], 1)]);
      },
      staticRenderFns: [],
      name: 'file-preview',
      components: {
        ProgressBar: ProgressBar
      },
      directives: {
        ready: {
          inserted: function inserted(el, binding, vnode) {
            if (isFunction$1(binding.value)) {
              vnode.context.$nextTick(binding.value);
            }
          }
        }
      },
      props: {
        /**
         * Hide the close button for the preview
         *
         * @property Object
         */
        hideClose: Boolean,

        /**
         * The uploaded File object
         *
         * @property Object
         */
        file: {
          type: [Object, File],
          required: true
        },

        /**
         * An image URL to instead of using the file reader.
         * @property {String}
         */
        poster: String,

        /**
         * Progress that can be passed from a parent comparent, for instance
         * use to show an ajax request with a single progress bar. If a progress
         * value is passed, even a 0, the progress bar will not be used to show
         * the progress of the file reader.
         * @property {Number}
         */
        progress: {
          type: Number,
          default: undefined
        }
      },
      computed: {
        /**
         * Get the file name
         *
         * @property String
         */
        name: function name() {
          return this.file instanceof File ? this.file.name : this.file.orig_filename;
        },

        /**
         * Get the file extension
         *
         * @property String
         */
        extension: function extension() {
          return this.file instanceof File ? this.file.name.split('.').pop().toLowerCase() : this.file.extension;
        },

        /**
         * Get the file formatted size
         *
         * @property String
         */
        size: function size() {
          return this.bytesToSize(this.file.size);
        },

        /**
         * Get the file type
         *
         * @property String
         */
        type: function type() {
          return this.file instanceof File ? this.file.type : this.file.mime;
        },

        /**
         * Check to see if the file is an image.
         *
         * @property String
         */
        isImage: function isImage() {
          return !!this.type.match(/^image/);
        },

        /**
         * Check to see if the file is a video.
         *
         * @property String
         */
        isVideo: function isVideo() {
          return !!this.type.match(/^video/);
        },

        /**
         * Get the last time the file was modified (as timestamp)
         *
         * @property String
         */
        lastModified: function lastModified() {
          return this.file instanceof File ? this.file.lastModified : null;
        },

        /**
         * Get the last time the file was modified (as Date)
         *
         * @property String
         */
        lastModifiedDate: function lastModifiedDate() {
          return this.file instanceof File ? this.file.lastModifiedDate : null;
        }
      },
      methods: {
        readFile: function readFile$$1() {
          var _this2 = this;

          if (this.file instanceof File) {
            var start = moment();
            this.loaded = 0;
            this.$nextTick(function () {
              readFile(_this2.file, function (e) {
                if (e.lengthComputable) {
                  _this2.$emit('progress', _this2.loaded = parseInt(e.loaded / e.total * 100, 10));
                }
              }).then(function (event) {
                _this2.$emit('read', event);

                setTimeout(function () {
                  _this2.image = event.target.result;

                  _this2.$nextTick(function () {
                    _this2.loaded = false;
                  });
                }, 500 - moment().diff(start));
              }, function (error) {
                _this2.$emit('error', error);
              });
            });
          }
        },
        bytesToSize: function bytesToSize(bytes) {
          var sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
          if (bytes == 0) return '0 Byte';
          var i = parseInt(Math.floor(Math.log(bytes) / Math.log(1024)));
          return Math.round(bytes / Math.pow(1024, i), 2) + ' ' + sizes[i];
        },
        onLoad: function onLoad(event) {
          this.$emit('loaded');
        }
      },
      data: function data() {
        return {
          image: this.file.url,
          loaded: this.file instanceof File ? 0 : false
        };
      }
    };

    var plugin$27 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          FilePreview: FilePreview
        });
      }
    });

    var FormControl$1 = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c(!_vm.select ? 'input' : 'select', {
          directives: [{
            name: "bind-events",
            rawName: "v-bind-events",
            value: _vm.bindEvents,
            expression: "bindEvents"
          }],
          tag: "component",
          class: _vm.mergeClasses(_vm.controlClasses, _vm.colorableClasses),
          attrs: {
            "name": _vm.name,
            "id": _vm.id,
            "type": !_vm.select ? _vm.type : false,
            "value": _vm.value,
            "pattern": _vm.pattern,
            "required": _vm.required,
            "readonly": _vm.readonly,
            "placeholder": _vm.placeholder,
            "disabled": _vm.disabled || _vm.readonly,
            "aria-label": _vm.label,
            "aria-describedby": _vm.id
          }
        });
      },
      staticRenderFns: [],
      name: 'form-control',
      mixins: [Colorable, FormControl, MergeClasses],
      props: {
        /**
         * Is the element a select?
         *
         * @property String
         */
        select: Boolean,

        /**
         * The type attribute
         *
         * @property String
         */
        type: {
          type: String,
          default: 'text'
        }
      }
    };

    var plugin$28 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          FormControl: FormControl$1
        });
      }
    });

    /**
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the W3C SOFTWARE AND DOCUMENT NOTICE AND LICENSE.
     *
     *  https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
     *
     */

    (function(window, document) {


    // Exits early if all IntersectionObserver and IntersectionObserverEntry
    // features are natively supported.
    if ('IntersectionObserver' in window &&
        'IntersectionObserverEntry' in window &&
        'intersectionRatio' in window.IntersectionObserverEntry.prototype) {

      // Minimal polyfill for Edge 15's lack of `isIntersecting`
      // See: https://github.com/w3c/IntersectionObserver/issues/211
      if (!('isIntersecting' in window.IntersectionObserverEntry.prototype)) {
        Object.defineProperty(window.IntersectionObserverEntry.prototype,
          'isIntersecting', {
          get: function () {
            return this.intersectionRatio > 0;
          }
        });
      }
      return;
    }


    /**
     * Creates the global IntersectionObserverEntry constructor.
     * https://w3c.github.io/IntersectionObserver/#intersection-observer-entry
     * @param {Object} entry A dictionary of instance properties.
     * @constructor
     */
    function IntersectionObserverEntry(entry) {
      this.time = entry.time;
      this.target = entry.target;
      this.rootBounds = entry.rootBounds;
      this.boundingClientRect = entry.boundingClientRect;
      this.intersectionRect = entry.intersectionRect || getEmptyRect();
      this.isIntersecting = !!entry.intersectionRect;

      // Calculates the intersection ratio.
      var targetRect = this.boundingClientRect;
      var targetArea = targetRect.width * targetRect.height;
      var intersectionRect = this.intersectionRect;
      var intersectionArea = intersectionRect.width * intersectionRect.height;

      // Sets intersection ratio.
      if (targetArea) {
        this.intersectionRatio = intersectionArea / targetArea;
      } else {
        // If area is zero and is intersecting, sets to 1, otherwise to 0
        this.intersectionRatio = this.isIntersecting ? 1 : 0;
      }
    }


    /**
     * Creates the global IntersectionObserver constructor.
     * https://w3c.github.io/IntersectionObserver/#intersection-observer-interface
     * @param {Function} callback The function to be invoked after intersection
     *     changes have queued. The function is not invoked if the queue has
     *     been emptied by calling the `takeRecords` method.
     * @param {Object=} opt_options Optional configuration options.
     * @constructor
     */
    function IntersectionObserver(callback, opt_options) {

      var options = opt_options || {};

      if (typeof callback != 'function') {
        throw new Error('callback must be a function');
      }

      if (options.root && options.root.nodeType != 1) {
        throw new Error('root must be an Element');
      }

      // Binds and throttles `this._checkForIntersections`.
      this._checkForIntersections = throttle(
          this._checkForIntersections.bind(this), this.THROTTLE_TIMEOUT);

      // Private properties.
      this._callback = callback;
      this._observationTargets = [];
      this._queuedEntries = [];
      this._rootMarginValues = this._parseRootMargin(options.rootMargin);

      // Public properties.
      this.thresholds = this._initThresholds(options.threshold);
      this.root = options.root || null;
      this.rootMargin = this._rootMarginValues.map(function(margin) {
        return margin.value + margin.unit;
      }).join(' ');
    }


    /**
     * The minimum interval within which the document will be checked for
     * intersection changes.
     */
    IntersectionObserver.prototype.THROTTLE_TIMEOUT = 100;


    /**
     * The frequency in which the polyfill polls for intersection changes.
     * this can be updated on a per instance basis and must be set prior to
     * calling `observe` on the first target.
     */
    IntersectionObserver.prototype.POLL_INTERVAL = null;

    /**
     * Use a mutation observer on the root element
     * to detect intersection changes.
     */
    IntersectionObserver.prototype.USE_MUTATION_OBSERVER = true;


    /**
     * Starts observing a target element for intersection changes based on
     * the thresholds values.
     * @param {Element} target The DOM element to observe.
     */
    IntersectionObserver.prototype.observe = function(target) {
      var isTargetAlreadyObserved = this._observationTargets.some(function(item) {
        return item.element == target;
      });

      if (isTargetAlreadyObserved) {
        return;
      }

      if (!(target && target.nodeType == 1)) {
        throw new Error('target must be an Element');
      }

      this._registerInstance();
      this._observationTargets.push({element: target, entry: null});
      this._monitorIntersections();
      this._checkForIntersections();
    };


    /**
     * Stops observing a target element for intersection changes.
     * @param {Element} target The DOM element to observe.
     */
    IntersectionObserver.prototype.unobserve = function(target) {
      this._observationTargets =
          this._observationTargets.filter(function(item) {

        return item.element != target;
      });
      if (!this._observationTargets.length) {
        this._unmonitorIntersections();
        this._unregisterInstance();
      }
    };


    /**
     * Stops observing all target elements for intersection changes.
     */
    IntersectionObserver.prototype.disconnect = function() {
      this._observationTargets = [];
      this._unmonitorIntersections();
      this._unregisterInstance();
    };


    /**
     * Returns any queue entries that have not yet been reported to the
     * callback and clears the queue. This can be used in conjunction with the
     * callback to obtain the absolute most up-to-date intersection information.
     * @return {Array} The currently queued entries.
     */
    IntersectionObserver.prototype.takeRecords = function() {
      var records = this._queuedEntries.slice();
      this._queuedEntries = [];
      return records;
    };


    /**
     * Accepts the threshold value from the user configuration object and
     * returns a sorted array of unique threshold values. If a value is not
     * between 0 and 1 and error is thrown.
     * @private
     * @param {Array|number=} opt_threshold An optional threshold value or
     *     a list of threshold values, defaulting to [0].
     * @return {Array} A sorted list of unique and valid threshold values.
     */
    IntersectionObserver.prototype._initThresholds = function(opt_threshold) {
      var threshold = opt_threshold || [0];
      if (!Array.isArray(threshold)) threshold = [threshold];

      return threshold.sort().filter(function(t, i, a) {
        if (typeof t != 'number' || isNaN(t) || t < 0 || t > 1) {
          throw new Error('threshold must be a number between 0 and 1 inclusively');
        }
        return t !== a[i - 1];
      });
    };


    /**
     * Accepts the rootMargin value from the user configuration object
     * and returns an array of the four margin values as an object containing
     * the value and unit properties. If any of the values are not properly
     * formatted or use a unit other than px or %, and error is thrown.
     * @private
     * @param {string=} opt_rootMargin An optional rootMargin value,
     *     defaulting to '0px'.
     * @return {Array<Object>} An array of margin objects with the keys
     *     value and unit.
     */
    IntersectionObserver.prototype._parseRootMargin = function(opt_rootMargin) {
      var marginString = opt_rootMargin || '0px';
      var margins = marginString.split(/\s+/).map(function(margin) {
        var parts = /^(-?\d*\.?\d+)(px|%)$/.exec(margin);
        if (!parts) {
          throw new Error('rootMargin must be specified in pixels or percent');
        }
        return {value: parseFloat(parts[1]), unit: parts[2]};
      });

      // Handles shorthand.
      margins[1] = margins[1] || margins[0];
      margins[2] = margins[2] || margins[0];
      margins[3] = margins[3] || margins[1];

      return margins;
    };


    /**
     * Starts polling for intersection changes if the polling is not already
     * happening, and if the page's visibilty state is visible.
     * @private
     */
    IntersectionObserver.prototype._monitorIntersections = function() {
      if (!this._monitoringIntersections) {
        this._monitoringIntersections = true;

        // If a poll interval is set, use polling instead of listening to
        // resize and scroll events or DOM mutations.
        if (this.POLL_INTERVAL) {
          this._monitoringInterval = setInterval(
              this._checkForIntersections, this.POLL_INTERVAL);
        }
        else {
          addEvent(window, 'resize', this._checkForIntersections, true);
          addEvent(document, 'scroll', this._checkForIntersections, true);

          if (this.USE_MUTATION_OBSERVER && 'MutationObserver' in window) {
            this._domObserver = new MutationObserver(this._checkForIntersections);
            this._domObserver.observe(document, {
              attributes: true,
              childList: true,
              characterData: true,
              subtree: true
            });
          }
        }
      }
    };


    /**
     * Stops polling for intersection changes.
     * @private
     */
    IntersectionObserver.prototype._unmonitorIntersections = function() {
      if (this._monitoringIntersections) {
        this._monitoringIntersections = false;

        clearInterval(this._monitoringInterval);
        this._monitoringInterval = null;

        removeEvent(window, 'resize', this._checkForIntersections, true);
        removeEvent(document, 'scroll', this._checkForIntersections, true);

        if (this._domObserver) {
          this._domObserver.disconnect();
          this._domObserver = null;
        }
      }
    };


    /**
     * Scans each observation target for intersection changes and adds them
     * to the internal entries queue. If new entries are found, it
     * schedules the callback to be invoked.
     * @private
     */
    IntersectionObserver.prototype._checkForIntersections = function() {
      var rootIsInDom = this._rootIsInDom();
      var rootRect = rootIsInDom ? this._getRootRect() : getEmptyRect();

      this._observationTargets.forEach(function(item) {
        var target = item.element;
        var targetRect = getBoundingClientRect(target);
        var rootContainsTarget = this._rootContainsTarget(target);
        var oldEntry = item.entry;
        var intersectionRect = rootIsInDom && rootContainsTarget &&
            this._computeTargetAndRootIntersection(target, rootRect);

        var newEntry = item.entry = new IntersectionObserverEntry({
          time: now(),
          target: target,
          boundingClientRect: targetRect,
          rootBounds: rootRect,
          intersectionRect: intersectionRect
        });

        if (!oldEntry) {
          this._queuedEntries.push(newEntry);
        } else if (rootIsInDom && rootContainsTarget) {
          // If the new entry intersection ratio has crossed any of the
          // thresholds, add a new entry.
          if (this._hasCrossedThreshold(oldEntry, newEntry)) {
            this._queuedEntries.push(newEntry);
          }
        } else {
          // If the root is not in the DOM or target is not contained within
          // root but the previous entry for this target had an intersection,
          // add a new record indicating removal.
          if (oldEntry && oldEntry.isIntersecting) {
            this._queuedEntries.push(newEntry);
          }
        }
      }, this);

      if (this._queuedEntries.length) {
        this._callback(this.takeRecords(), this);
      }
    };


    /**
     * Accepts a target and root rect computes the intersection between then
     * following the algorithm in the spec.
     * TODO(philipwalton): at this time clip-path is not considered.
     * https://w3c.github.io/IntersectionObserver/#calculate-intersection-rect-algo
     * @param {Element} target The target DOM element
     * @param {Object} rootRect The bounding rect of the root after being
     *     expanded by the rootMargin value.
     * @return {?Object} The final intersection rect object or undefined if no
     *     intersection is found.
     * @private
     */
    IntersectionObserver.prototype._computeTargetAndRootIntersection =
        function(target, rootRect) {

      // If the element isn't displayed, an intersection can't happen.
      if (window.getComputedStyle(target).display == 'none') return;

      var targetRect = getBoundingClientRect(target);
      var intersectionRect = targetRect;
      var parent = getParentNode(target);
      var atRoot = false;

      while (!atRoot) {
        var parentRect = null;
        var parentComputedStyle = parent.nodeType == 1 ?
            window.getComputedStyle(parent) : {};

        // If the parent isn't displayed, an intersection can't happen.
        if (parentComputedStyle.display == 'none') return;

        if (parent == this.root || parent == document) {
          atRoot = true;
          parentRect = rootRect;
        } else {
          // If the element has a non-visible overflow, and it's not the <body>
          // or <html> element, update the intersection rect.
          // Note: <body> and <html> cannot be clipped to a rect that's not also
          // the document rect, so no need to compute a new intersection.
          if (parent != document.body &&
              parent != document.documentElement &&
              parentComputedStyle.overflow != 'visible') {
            parentRect = getBoundingClientRect(parent);
          }
        }

        // If either of the above conditionals set a new parentRect,
        // calculate new intersection data.
        if (parentRect) {
          intersectionRect = computeRectIntersection(parentRect, intersectionRect);

          if (!intersectionRect) break;
        }
        parent = getParentNode(parent);
      }
      return intersectionRect;
    };


    /**
     * Returns the root rect after being expanded by the rootMargin value.
     * @return {Object} The expanded root rect.
     * @private
     */
    IntersectionObserver.prototype._getRootRect = function() {
      var rootRect;
      if (this.root) {
        rootRect = getBoundingClientRect(this.root);
      } else {
        // Use <html>/<body> instead of window since scroll bars affect size.
        var html = document.documentElement;
        var body = document.body;
        rootRect = {
          top: 0,
          left: 0,
          right: html.clientWidth || body.clientWidth,
          width: html.clientWidth || body.clientWidth,
          bottom: html.clientHeight || body.clientHeight,
          height: html.clientHeight || body.clientHeight
        };
      }
      return this._expandRectByRootMargin(rootRect);
    };


    /**
     * Accepts a rect and expands it by the rootMargin value.
     * @param {Object} rect The rect object to expand.
     * @return {Object} The expanded rect.
     * @private
     */
    IntersectionObserver.prototype._expandRectByRootMargin = function(rect) {
      var margins = this._rootMarginValues.map(function(margin, i) {
        return margin.unit == 'px' ? margin.value :
            margin.value * (i % 2 ? rect.width : rect.height) / 100;
      });
      var newRect = {
        top: rect.top - margins[0],
        right: rect.right + margins[1],
        bottom: rect.bottom + margins[2],
        left: rect.left - margins[3]
      };
      newRect.width = newRect.right - newRect.left;
      newRect.height = newRect.bottom - newRect.top;

      return newRect;
    };


    /**
     * Accepts an old and new entry and returns true if at least one of the
     * threshold values has been crossed.
     * @param {?IntersectionObserverEntry} oldEntry The previous entry for a
     *    particular target element or null if no previous entry exists.
     * @param {IntersectionObserverEntry} newEntry The current entry for a
     *    particular target element.
     * @return {boolean} Returns true if a any threshold has been crossed.
     * @private
     */
    IntersectionObserver.prototype._hasCrossedThreshold =
        function(oldEntry, newEntry) {

      // To make comparing easier, an entry that has a ratio of 0
      // but does not actually intersect is given a value of -1
      var oldRatio = oldEntry && oldEntry.isIntersecting ?
          oldEntry.intersectionRatio || 0 : -1;
      var newRatio = newEntry.isIntersecting ?
          newEntry.intersectionRatio || 0 : -1;

      // Ignore unchanged ratios
      if (oldRatio === newRatio) return;

      for (var i = 0; i < this.thresholds.length; i++) {
        var threshold = this.thresholds[i];

        // Return true if an entry matches a threshold or if the new ratio
        // and the old ratio are on the opposite sides of a threshold.
        if (threshold == oldRatio || threshold == newRatio ||
            threshold < oldRatio !== threshold < newRatio) {
          return true;
        }
      }
    };


    /**
     * Returns whether or not the root element is an element and is in the DOM.
     * @return {boolean} True if the root element is an element and is in the DOM.
     * @private
     */
    IntersectionObserver.prototype._rootIsInDom = function() {
      return !this.root || containsDeep(document, this.root);
    };


    /**
     * Returns whether or not the target element is a child of root.
     * @param {Element} target The target element to check.
     * @return {boolean} True if the target element is a child of root.
     * @private
     */
    IntersectionObserver.prototype._rootContainsTarget = function(target) {
      return containsDeep(this.root || document, target);
    };


    /**
     * Adds the instance to the global IntersectionObserver registry if it isn't
     * already present.
     * @private
     */
    IntersectionObserver.prototype._registerInstance = function() {
    };


    /**
     * Removes the instance from the global IntersectionObserver registry.
     * @private
     */
    IntersectionObserver.prototype._unregisterInstance = function() {
    };


    /**
     * Returns the result of the performance.now() method or null in browsers
     * that don't support the API.
     * @return {number} The elapsed time since the page was requested.
     */
    function now() {
      return window.performance && performance.now && performance.now();
    }


    /**
     * Throttles a function and delays its executiong, so it's only called at most
     * once within a given time period.
     * @param {Function} fn The function to throttle.
     * @param {number} timeout The amount of time that must pass before the
     *     function can be called again.
     * @return {Function} The throttled function.
     */
    function throttle(fn, timeout) {
      var timer = null;
      return function () {
        if (!timer) {
          timer = setTimeout(function() {
            fn();
            timer = null;
          }, timeout);
        }
      };
    }


    /**
     * Adds an event handler to a DOM node ensuring cross-browser compatibility.
     * @param {Node} node The DOM node to add the event handler to.
     * @param {string} event The event name.
     * @param {Function} fn The event handler to add.
     * @param {boolean} opt_useCapture Optionally adds the even to the capture
     *     phase. Note: this only works in modern browsers.
     */
    function addEvent(node, event, fn, opt_useCapture) {
      if (typeof node.addEventListener == 'function') {
        node.addEventListener(event, fn, opt_useCapture || false);
      }
      else if (typeof node.attachEvent == 'function') {
        node.attachEvent('on' + event, fn);
      }
    }


    /**
     * Removes a previously added event handler from a DOM node.
     * @param {Node} node The DOM node to remove the event handler from.
     * @param {string} event The event name.
     * @param {Function} fn The event handler to remove.
     * @param {boolean} opt_useCapture If the event handler was added with this
     *     flag set to true, it should be set to true here in order to remove it.
     */
    function removeEvent(node, event, fn, opt_useCapture) {
      if (typeof node.removeEventListener == 'function') {
        node.removeEventListener(event, fn, opt_useCapture || false);
      }
      else if (typeof node.detatchEvent == 'function') {
        node.detatchEvent('on' + event, fn);
      }
    }


    /**
     * Returns the intersection between two rect objects.
     * @param {Object} rect1 The first rect.
     * @param {Object} rect2 The second rect.
     * @return {?Object} The intersection rect or undefined if no intersection
     *     is found.
     */
    function computeRectIntersection(rect1, rect2) {
      var top = Math.max(rect1.top, rect2.top);
      var bottom = Math.min(rect1.bottom, rect2.bottom);
      var left = Math.max(rect1.left, rect2.left);
      var right = Math.min(rect1.right, rect2.right);
      var width = right - left;
      var height = bottom - top;

      return (width >= 0 && height >= 0) && {
        top: top,
        bottom: bottom,
        left: left,
        right: right,
        width: width,
        height: height
      };
    }


    /**
     * Shims the native getBoundingClientRect for compatibility with older IE.
     * @param {Element} el The element whose bounding rect to get.
     * @return {Object} The (possibly shimmed) rect of the element.
     */
    function getBoundingClientRect(el) {
      var rect;

      try {
        rect = el.getBoundingClientRect();
      } catch (err) {
        // Ignore Windows 7 IE11 "Unspecified error"
        // https://github.com/w3c/IntersectionObserver/pull/205
      }

      if (!rect) return getEmptyRect();

      // Older IE
      if (!(rect.width && rect.height)) {
        rect = {
          top: rect.top,
          right: rect.right,
          bottom: rect.bottom,
          left: rect.left,
          width: rect.right - rect.left,
          height: rect.bottom - rect.top
        };
      }
      return rect;
    }


    /**
     * Returns an empty rect object. An empty rect is returned when an element
     * is not in the DOM.
     * @return {Object} The empty rect.
     */
    function getEmptyRect() {
      return {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0,
        width: 0,
        height: 0
      };
    }

    /**
     * Checks to see if a parent element contains a child elemnt (including inside
     * shadow DOM).
     * @param {Node} parent The parent element.
     * @param {Node} child The child element.
     * @return {boolean} True if the parent node contains the child node.
     */
    function containsDeep(parent, child) {
      var node = child;
      while (node) {
        if (node == parent) return true;

        node = getParentNode(node);
      }
      return false;
    }


    /**
     * Gets the parent node of an element or its host element if the parent node
     * is a shadow root.
     * @param {Node} node The node whose parent to get.
     * @return {Node|null} The parent node or null if no parent exists.
     */
    function getParentNode(node) {
      var parent = node.parentNode;

      if (parent && parent.nodeType == 11 && parent.host) {
        // If the parent is a shadow root, return the host element.
        return parent.host;
      }
      return parent;
    }


    // Exposes the constructors globally.
    window.IntersectionObserver = IntersectionObserver;
    window.IntersectionObserverEntry = IntersectionObserverEntry;

    }(window, document));

    var InfiniteScrolling = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "infinite-scrolling",
          style: {
            height: _vm.heightUnit,
            background: _vm.background
          }
        }, [_vm.activity ? _c('activity-indicator', {
          attrs: {
            "size": _vm.size,
            "type": _vm.type,
            "center": ""
          }
        }) : _vm._e()], 1);
      },
      staticRenderFns: [],
      name: 'infinite-scrolling',
      components: {
        ActivityIndicator: ActivityIndicator
      },
      props: {
        /**
         * Is the activity indicator showing
         *
         * @property String
         */
        activity: Boolean,

        /**
         * The activity indicator background style
         *
         * @property String
         */
        background: String,

        /**
         * The activity indicator size
         *
         * @property String
         */
        height: {
          type: Number,
          default: 100
        },

        /**
         * The activity indicator size
         *
         * @property String
         */
        size: String,

        /**
         * The activity indicator type
         *
         * @property String
         */
        type: String,

        /**
         * The scroll observer threshold for when an element is considered
         * into view. Must be a validate between 0 and 1, and is a percentage.
         *
         * @property Number
         */
        threshold: {
          type: Number,
          default: .75,
          validate: function validate(value) {
            return value >= 0 && value <= 1;
          }
        }
      },
      methods: {
        scrollIntoViewport: function scrollIntoViewport(entry) {
          this.$emit('scroll:in', entry);

          if (!this.activity) {
            this.$emit('load', entry);
          }
        },
        scrollOutViewport: function scrollOutViewport(entry) {
          this.$emit('scroll:out', entry);
        }
      },
      computed: {
        heightUnit: function heightUnit() {
          return unit(this.height);
        }
      },
      mounted: function mounted() {
        var _this = this;

        this.$nextTick(function () {
          new IntersectionObserver(function (entries, observer) {
            entries.forEach(function (entry) {
              if (entry.isIntersecting && !_this.hasScrolledIntoViewport) {
                _this.scrollIntoViewport(entry, observer);

                _this.hasScrolledIntoViewport = true;
              } else if (_this.hasScrolledIntoViewport) {
                _this.scrollOutViewport(entry, observer);

                _this.hasScrolledIntoViewport = false;
              }
            });
          }, {
            threshold: _this.threshold
          }).observe(_this.$el);
        });
      },
      data: function data() {
        return {
          hasScrolledIntoViewport: false
        };
      }
    };

    var InputGroupText = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('span', {
          staticClass: "input-group-text",
          attrs: {
            "id": _vm.id
          }
        }, [_vm._t("default", [_vm._v(_vm._s(_vm.text))])], 2);
      },
      staticRenderFns: [],
      name: 'input-group-text',
      props: {
        /**
         * The id attribute
         *
         * @property String
         */
        id: String,

        /**
         * The type attribute
         *
         * @property String
         */
        text: [Array, Number, String]
      }
    };

    var InputGroupAppend = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "input-group-append"
        }, [_vm.text ? _c('input-group-text', [_vm._t("default")], 2) : _vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'input-group-append',
      props: {
        /**
         * The type attribute
         *
         * @property String
         */
        text: Boolean
      }
    };

    var InputGroupPrepend = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "input-group-prepend"
        }, [_vm.text ? _c('input-group-text', [_vm._t("default")], 2) : _vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'input-group-prepend',
      props: {
        /**
         * The type attribute
         *
         * @property String
         */
        text: Boolean
      }
    };

    var InputGroup = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "input-group",
          class: _vm.mergeClasses(_vm.colorableClasses, _vm.sizeableClass)
        }, [_vm._t("prepend", [_vm.prepend instanceof Array ? [_c('input-group-prepend', _vm._l(_vm.prepend, function (value) {
          return _c('input-group-text', {
            attrs: {
              "text": value
            }
          });
        }))] : _vm.prepend ? [_c('input-group-prepend', {
          attrs: {
            "text": ""
          }
        }, [_vm._v(_vm._s(_vm.prepend))])] : _vm._e()]), _vm._v(" "), _vm._t("default"), _vm._v(" "), _vm._t("append", [_vm.append instanceof Array ? [_c('input-group-append', _vm._l(_vm.append, function (value) {
          return _c('input-group-text', {
            attrs: {
              "text": value
            }
          });
        }))] : _vm.append ? [_c('input-group-append', {
          attrs: {
            "text": ""
          }
        }, [_vm._v(_vm._s(_vm.append))])] : _vm._e()])], 2);
      },
      staticRenderFns: [],
      name: 'input-group',
      components: {
        InputGroupText: InputGroupText,
        InputGroupAppend: InputGroupAppend,
        InputGroupPrepend: InputGroupPrepend
      },
      mixins: [HasSlots, Sizeable, Colorable, MergeClasses],
      props: {
        append: [Array, Number, String],
        prepend: [Array, Number, String]
      }
    };

    var plugin$29 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          InputGroup: InputGroup,
          InputGroupAppend: InputGroupAppend,
          InputGroupPrepend: InputGroupPrepend,
          InputGroupText: InputGroupText
        });
      }
    });

    var LightSwitchField = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('form-group', [_vm._t("label", [_vm.label ? _c('form-label', {
          attrs: {
            "for": _vm.id
          },
          domProps: {
            "innerHTML": _vm._s(_vm.label)
          }
        }) : _vm._e()]), _vm._v(" "), _c('div', {
          class: _vm.controlClasses,
          attrs: {
            "tabindex": "0"
          },
          on: {
            "click": function click($event) {
              _vm.toggle();
            },
            "keyup": [function ($event) {
              if (!('button' in $event) && $event.keyCode !== 32) {
                return null;
              }

              _vm.toggle();
            }, function ($event) {
              if (!('button' in $event) && $event.keyCode !== 37) {
                return null;
              }

              _vm.toggle(_vm.offValue);
            }, function ($event) {
              if (!('button' in $event) && $event.keyCode !== 39) {
                return null;
              }

              _vm.toggle(_vm.onValue);
            }]
          }
        }, [_c('div', {
          staticClass: "light-switch-handle"
        }), _vm._v(" "), _c('div', {
          staticClass: "light-switch-container"
        }, [_c('div', {
          staticClass: "light-switch-label on-value"
        }), _vm._v(" "), _c('div', {
          staticClass: "light-switch-label off-value"
        })])]), _vm._v(" "), _c('form-control', {
          staticClass: "d-none",
          attrs: {
            "name": _vm.name,
            "value": _vm.value,
            "id": _vm.id
          }
        }), _vm._v(" "), _vm._t("feedback", [_vm.validFeedback ? _c('form-feedback', {
          attrs: {
            "valid": ""
          },
          domProps: {
            "innerHTML": _vm._s(_vm.validFeedback)
          }
        }) : _vm._e(), _vm._v(" "), _vm.invalidFeedback ? _c('form-feedback', {
          attrs: {
            "invalid": ""
          },
          domProps: {
            "innerHTML": _vm._s(_vm.invalidFeedback)
          }
        }) : _vm._e()]), _vm._v(" "), _vm._t("help", [_vm.helpText ? _c('help-text', {
          domProps: {
            "innerHTML": _vm._s(_vm.helpText)
          }
        }) : _vm._e()])], 2);
      },
      staticRenderFns: [],
      name: 'light-switch-field',
      components: {
        HelpText: HelpText,
        FormGroup: FormGroup,
        FormLabel: FormLabel,
        FormControl: FormControl$1,
        FormFeedback: FormFeedback
      },
      mixins: [FormControl],
      props: {
        /**
         * The class name assigned to the control element
         *
         * @property String
         */
        defaultControlClass: {
          type: String,
          default: 'form-control light-switch'
        },

        /**
         * The class name assigned to the control element
         *
         * @property String
         */
        activeClass: {
          type: String,
          default: 'on'
        },

        /**
         * The class name assigned to the control element
         *
         * @property String
         */
        onValue: {
          default: 1
        },

        /**
         * The class name assigned to the control element
         *
         * @property String
         */
        offValue: {
          default: 0
        }
      },
      computed: {
        isActive: function isActive() {
          return this.value === this.onValue;
        },
        controlClasses: function controlClasses() {
          return [this.controlClass, this.controlSizeClass, this.spacing || '', this.invalidFeedback ? 'is-invalid' : '', this.dragging ? 'is-dragging' : '', this.isActive ? 'is-active' : ''].join(' ');
        }
      },
      methods: {
        getTransitionInMilliseconds: function getTransitionInMilliseconds() {
          var duration = getComputedStyle(this.$el.querySelector('.light-switch-handle')).transitionDuration;
          var numeric = parseFloat(duration, 10);
          var unit = duration.match(/m?s/);

          switch (unit[0]) {
            case 's':
              return numeric * 1000;

            case 'ms':
              return numeric;
          }

          throw new Error("\"".concat(unit[0], "\" is not a valid unit of measure. Unit must be \"s\" (seconds) or \"ms\" (milliseconds)."));
        },
        toggle: function toggle(value) {
          this.$emit('input', !isUndefined(value) ? value : this.isActive ? this.offValue : this.onValue);
        }
      },
      watch: {
        value: function value() {
          var _this = this;

          this.dragging = true;
          setTimeout(function () {
            _this.dragging = false;
          }, this.getTransitionInMilliseconds());
        }
      },
      data: function data() {
        return {
          dragging: false
        };
      }
    };

    var plugin$30 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          LightSwitchField: LightSwitchField
        });
      }
    });

    var ListGroupItem = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _vm.to ? _c('router-link', {
          class: _vm.classes,
          attrs: {
            "to": _vm.to
          },
          on: {
            "click": function click($event) {
              _vm.$emit('click', $event);
            }
          }
        }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))]), _vm._v(" "), _vm.badge ? _c('badge', _vm._b({}, 'badge', _vm.badgeOptions, false)) : _vm._e()], 2) : _vm.action ? _c('button', {
          class: _vm.classes,
          attrs: {
            "type": "button"
          },
          on: {
            "click": function click($event) {
              $event.preventDefault();

              _vm.$emit('click', $event);
            }
          }
        }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))]), _vm._v(" "), _vm.badge ? _c('badge', _vm._b({}, 'badge', _vm.badgeOptions, false)) : _vm._e()], 2) : _c('div', {
          class: _vm.classes,
          on: {
            "click": function click($event) {
              _vm.$emit('click', $event);
            }
          }
        }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))]), _vm._v(" "), _vm.badge ? _c('badge', _vm._b({}, 'badge', _vm.badgeOptions, false)) : _vm._e()], 2);
      },
      staticRenderFns: [],
      components: {
        Badge: Badge
      },
      props: {
        /**
         * The badge label (if number or string) or object of options to pass to
         * the component.
         *
         * @property String|Object
         */
        badge: [Number, String, Object],

        /**
         * The list group item href attribute.
         *
         * @property String
         */
        href: String,

        /**
         * The list group item variant.
         *
         * @property String
         */
        variant: String,

        /**
         * Optionally pass the item as a object to use programmatically later.
         *
         * @property String
         */
        item: Object,

        /**
         * The list group item an action, or clickable item.
         *
         * @property Boolean
         */
        action: {
          type: Boolean,
          default: false
        },

        /**
         * The list group item active.
         *
         * @property Boolean
         */
        active: {
          type: Boolean,
          default: false
        },

        /**
         * The list group item disabled.
         *
         * @property Boolean
         */
        disabled: {
          type: Boolean,
          default: false
        },

        /**
         * The list item label.
         *
         * @property Object
         */
        label: {
          type: [Number, String],
          value: null
        },

        /**
         * The to attribute to be passed to a <router-link> component.
         *
         * @property String
         */
        to: [String, Object]
      },
      computed: {
        classes: function classes() {
          var classes = prefix({
            'action': this.action
          }, 'list-group-item');
          classes['list-group-item'] = true;
          classes['active'] = this.active;
          classes['disabled'] = this.disabled;

          if (this.variant) {
            classes[prefix(this.variant, 'list-group-item')] = true;
          }

          return classes;
        },
        badgeOptions: function badgeOptions() {
          return isObject(this.badge) ? this.badge : {
            label: this.badge
          };
        }
      },
      watch: {
        active: function active(value, prevValue) {
          this.$emit('toggle', value);
          this.$emit(!!value ? 'activate' : 'deactivate');
        }
      }
    };

    var ListGroup = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "list-group",
          class: _vm.classes
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      components: {
        ListGroupItem: ListGroupItem
      },
      props: {
        /**
         * The list group appear flush (without some borders).
         *
         * @property Boolean
         */
        flush: {
          type: Boolean,
          default: false
        },

        /**
         * Can activate multiple list items
         *
         * @property Boolean
         */
        multiple: {
          type: Boolean,
          default: false
        }
      },
      computed: {
        classes: function classes() {
          return prefix({
            'flush': this.flush
          }, 'list-group');
        }
      },
      methods: {
        bindEventsToChildren: function bindEventsToChildren() {
          var _this = this;

          forEach(this.$children, function (child) {
            child.$off('click', function (event) {
              return _this.onClickItem(event, child);
            });
            child.$on('click', function (event) {
              return _this.onClickItem(event, child);
            });
          });
        },

        /**
         * The callback function for the `click` event.
         *
         * @return void
         */
        onClick: function onClick(event) {
          this.$emit('click', event);
        },

        /**
         * The callback function for the child `click` events.
         *
         * @return void
         */
        onClickItem: function onClickItem(event, child) {
          this.$emit('item:click', event, child);
        }
      },
      mounted: function mounted() {
        this.bindEventsToChildren();
      },
      updated: function updated() {
        this.bindEventsToChildren();
      }
    };

    var plugin$31 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          ListGroup: ListGroup
        });
      }
    });

    var NavbarBrand = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c(_vm.component, {
          tag: "component",
          staticClass: "navbar-brand",
          class: {
            'h1': _vm.h1
          },
          attrs: {
            "to": _vm.to,
            "href": _vm.href
          }
        }, [_vm.src ? _c('img', {
          staticClass: "d-inline-block align-center",
          attrs: {
            "src": _vm.src,
            "width": _vm.unit(_vm.width),
            "height": _vm.unit(_vm.height),
            "alt": _vm.alt
          }
        }) : _vm._e(), _vm._v(" "), _vm._t("default")], 2);
      },
      staticRenderFns: [],
      props: {
        /**
         * The img `alt` attribute. `src` must be define before this prop has
         * any affect.
         *
         * @property Object
         */
        alt: String,

        /**
         * The HTML wrapping tag.
         *
         * @property Object
         */
        tag: String,

        /**
         * The img `width` attribute. `src` must be define before this prop has
         * any affect.
         *
         * @property Object
         */
        width: [Number, String],

        /**
         * The img `height` attribute. `src` must be define before this prop has
         * any affect.
         *
         * @property Object
         */
        height: [Number, String],

        /**
         * The `to` attribute that is passed to the component.
         *
         * @property Object
         */
        to: [Object, String],

        /**
         * The `href` attribute that is passed to the component.
         *
         * @property Object
         */
        href: String,

        /**
         * Append the `h1` class to increase the display size
         *
         * @property Object
         */
        h1: Boolean,

        /**
         * If a `src` attribute is passed, then use it to add an img tag
         *
         * @property Object
         */
        src: String
      },
      computed: {
        component: function component() {
          return this.tag || (this.to ? 'router-link' : this.href ? 'a' : 'span');
        }
      },
      methods: {
        unit: function unit$$1(value) {
          return unit(value);
        }
      }
    };

    var NavbarCollapse = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "navbar-collapse",
          class: {
            'collapse': _vm.collapse
          },
          attrs: {
            "id": "navbarCollapse"
          }
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'navbar-collapse',
      props: {
        collapse: {
          type: Boolean,
          default: true
        }
      }
    };

    var NavbarText = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('span', {
          staticClass: "navbar-text"
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'navbar-text'
    };

    var NavbarTogglerIcon = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('span', {
          staticClass: "navbar-toggler-icon"
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'navbar-toggler-icon'
    };

    var NavbarToggler = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('button', {
          staticClass: "navbar-toggler",
          attrs: {
            "type": "button",
            "data-toggle": "collapse",
            "data-target": _vm.target,
            "aria-controls": _vm.target,
            "aria-expanded": _vm.expanded,
            "aria-label": _vm.label
          },
          on: {
            "click": _vm.onClick
          }
        }, [_vm._t("default", [_c('navbar-toggler-icon')])], 2);
      },
      staticRenderFns: [],
      name: 'navbar-toggler',
      components: {
        NavbarTogglerIcon: NavbarTogglerIcon
      },
      props: {
        expanded: Boolean,
        label: {
          type: String,
          default: 'Toggle navigation'
        },
        target: {
          type: String,
          default: '.navbar-collapse'
        }
      },
      methods: {
        onClick: function onClick(event) {
          this.$emit('click', event);
        }
      }
    };

    var Navbar = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('nav', {
          class: _vm.classes
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'navbar',
      components: {
        NavbarBrand: NavbarBrand,
        NavbarCollapse: NavbarCollapse,
        NavbarText: NavbarText,
        NavbarToggler: NavbarToggler,
        NavbarTogglerIcon: NavbarTogglerIcon
      },
      mixins: [Variant, Colorable, MergeClasses],
      props: {
        /**
         * Expand the navbar. If true, applies to all size, otherwise pass a string.
         *
         * @property Object
         */
        expand: {
          type: [Boolean, String],
          default: 'lg',
          validate: function validate(value) {
            ['xs', 'sm', 'md', 'lg', 'xl'].indexOf(value) !== -1 || isBoolean(value);
          }
        },

        /**
         * The should the navbar be fixed at the top.
         *
         * @property String
         */
        fixed: {
          type: [String, Boolean],
          validate: function validate(value) {
            ['top', 'bottom'].indexOf(value) !== -1 || isBoolean(value);
          }
        },

        /**
         * The should the navbar be stickied at the top.
         *
         * @property String
         */
        sticky: {
          type: [String, Boolean],
          validate: function validate(value) {
            ['top', 'bottom'].indexOf(value) !== -1 || isBoolean(value);
          }
        },

        /**
         * The variant attribute
         *
         * @property String
         */
        variant: {
          type: String,
          default: 'light',
          validate: function validate(value) {
            return ['light', 'dark'].indexOf(value) !== -1;
          }
        }
      },
      computed: {
        expandedClass: function expandedClass() {
          if (isBoolean(this.expand)) {
            return this.expand;
          }

          return prefix(prefix(this.expand, 'expand'), 'navbar');
        },
        classes: function classes() {
          return this.mergeClasses('navbar', prefix(this.sticky === true ? 'top' : this.sticky, 'sticky'), prefix(this.fixed === true ? 'top' : this.fixed, 'fixed'), this.expandedClass, this.variantClass, this.colorableClasses);
        }
      },
      data: function data() {
        return {};
      }
    };

    var NavigationError = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('span', {
          staticClass: "navigation-error fa-stack fa-md",
          attrs: {
            "title": _vm.error
          }
        }, [_c('i', {
          staticClass: "fa fa-stack-2x fa-certificate"
        }), _vm._v(" "), _c('i', {
          staticClass: "fa fa-stack-1x fa-exclamation fa-inverse"
        })]);
      },
      staticRenderFns: [],
      name: 'navigation-error',
      props: {
        error: {
          type: String,
          required: true
        }
      }
    };

    var NavigationLink = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c(_vm.component, {
          tag: "component",
          class: _vm.classes,
          attrs: {
            "href": _vm.href || (_vm.to ? '#' : null),
            "to": _vm.to
          },
          on: {
            "click": function click($event) {
              _vm.$emit('click', $event);
            }
          }
        }, [_vm._t("default"), _vm._v(" "), _vm.error ? _c('navigation-error', {
          attrs: {
            "error": _vm.error
          }
        }) : _vm._e()], 2);
      },
      staticRenderFns: [],
      name: 'navigation-link',
      components: {
        NavigationError: NavigationError
      },
      props: {
        /**
         * Is the navigation item active
         *
         * @prop {Boolean}
         */
        active: Boolean,

        /**
         * Is the navigation item disabled
         *
         * @prop {Boolean}
         */
        disabled: Boolean,

        /**
         * The error string.
         *
         * @prop {String}
         */
        error: String,

        /**
         * The href attribute
         *
         * @prop {String}
         */
        href: String,

        /**
         * The component HTML tag
         *
         * @prop {String}
         */
        tag: String,

        /**
         * The to attribute, will be passed to router-link.
         *
         * @prop {String}
         */
        to: [Object, String],

        /**
         * Add the nav-item class to the link
         *
         * @prop {Boolean}
         */
        item: {
          type: Boolean,
          default: true
        }
      },
      computed: {
        component: function component() {
          return this.tag || (this.to ? 'router-link' : 'a');
        },
        classes: function classes() {
          var _this = this;

          this.$nextTick(function () {
            if (!_this.isItem) {
              _this.isItem = !_this.$parent.$el.classList.contains('nav-item');
            }
          });
          return {
            'nav-link': !!this.href || !!this.to,
            'nav-item': !!this.item,
            'active': this.active,
            'disabled': this.disabled
          };
        }
      }
    };

    var NavigationItem = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c(_vm.component, {
          tag: "component",
          class: _vm.classes,
          on: {
            "click": function click($event) {
              _vm.$emit('click', $event);
            }
          }
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'navigation-item',
      extends: NavigationLink,
      props: {
        /**
         * The HTML element
         *
         * @prop {String}
         */
        element: String,

        /**
         * Is the component a list element
         *
         * @prop {Boolean}
         */
        list: Boolean,

        /**
         * Add the nav-item class to the link
         *
         * @prop {Boolean}
         */
        item: {
          type: Boolean,
          default: true
        }
      },
      computed: {
        component: function component() {
          if (this.element) {
            return this.element;
          } else if (this.href) {
            return 'a';
          } else if (this.list) {
            return 'li';
          }

          return 'div';
        }
      }
    };

    var Navigation = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('nav', {
          staticClass: "nav",
          class: _vm.classes,
          attrs: {
            "role": _vm.role
          }
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'navigation',
      components: {
        NavigationItem: NavigationItem
      },
      mixins: [Colorable, MergeClasses],
      props: {
        /**
         * Helper to add the justify-content-X class.
         *
         * @prop {Array}
         */
        align: String,

        /**
         * An array of buttons
         *
         * @prop {Array}
         */
        buttons: Array,

        /**
         * The navigation inside a card
         *
         * @prop {Boolean}
         */
        card: Boolean,

        /**
         * Justify nav items to fill the width equally (using flex).
         *
         * @prop {Array}
         */
        fill: Boolean,

        /**
         * Add `nav-justified` class to the component.
         *
         * @prop {Array}
         */
        justified: Boolean,

        /**
         * Display items as pill shapes
         *
         * @prop {Array}
         */
        pills: Boolean,

        /**
         * Display items as tab shapes
         *
         * @prop {Array}
         */
        tabs: Boolean,

        /**
         * Display the buttons vertically
         *
         * @prop {Boolean}
         */
        vertical: Boolean,

        /**
         * The role attribute
         *
         * @prop {String}
         */
        role: String
      },
      computed: {
        classes: function classes() {
          var _this = this;

          this.$nextTick(function () {
            if (!_this.isCard) {
              _this.isCard = _this.$parent.$el.classList.contains('card-header');
            }
          });
          return this.mergeClasses(prefix(this.align, 'justify-content'), this.colorableClasses, {
            'card-header-tabs': this.isCard && this.tabs,
            'card-header-pills': this.isCard && this.pills,
            'nav-justified': this.justified,
            'nav-fill': this.fill,
            'nav-pills': this.pills,
            'nav-tabs': this.tabs,
            'flex-column': this.vertical
          });
        }
      },
      data: function data() {
        return {
          isCard: this.card
        };
      }
    };

    var NavigationDropdown = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('navigation-item', {
          staticClass: "dropdown"
        }, [_vm._t("toggle-button", [_c('navigation-link', {
          staticClass: "dropdown-toggle",
          attrs: {
            "href": "#",
            "data-toggle": "dropdown",
            "role": "button",
            "aria-haspopup": "true",
            "aria-expanded": _vm.isDropdownShowing
          },
          on: {
            "blur": _vm.onBlur
          },
          nativeOn: {
            "click": function click($event) {
              $event.preventDefault();

              _vm.toggle();
            }
          }
        }, [_vm._v(" " + _vm._s(_vm.label) + " ")])]), _vm._v(" "), _vm._t("dropdown-menu", [_c('dropdown-menu', {
          attrs: {
            "id": _vm.id,
            "items": _vm.items,
            "align": _vm.align,
            "show": _vm.isDropdownShowing
          },
          on: {
            "update:show": function updateShow($event) {
              _vm.isDropdownShowing = $event;
            },
            "item:click": _vm.onItemClick
          }
        }, [_vm._t("default")], 2)])], 2);
      },
      staticRenderFns: [],
      name: 'navigation-dropdown',
      extends: BtnDropdown,
      components: {
        BtnDropdown: BtnDropdown,
        DropdownMenu: DropdownMenu,
        NavigationItem: NavigationItem,
        NavigationLink: NavigationLink
      }
    };

    var plugin$32 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          Navigation: Navigation,
          NavigationError: NavigationError,
          NavigationItem: NavigationItem,
          NavigationLink: NavigationLink,
          NavigationDropdown: NavigationDropdown
        });
      }
    });

    var NavbarNav = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('ul', {
          staticClass: "navbar-nav",
          class: _vm.classes,
          attrs: {
            "role": _vm.role
          }
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'navbar-nav',
      components: {
        Navigation: Navigation
      }
    };

    var plugin$33 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          Navbar: Navbar,
          NavbarBrand: NavbarBrand,
          NavbarCollapse: NavbarCollapse,
          NavbarNav: NavbarNav,
          NavbarText: NavbarText,
          NavbarToggler: NavbarToggler,
          NavbarTogglerIcon: NavbarTogglerIcon
        });
      }
    });

    var Pagination = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('nav', {
          attrs: {
            "aria-label": "Page navigation example"
          }
        }, [_c('ul', {
          staticClass: "pagination",
          class: _vm.classes
        }, [_c('li', {
          staticClass: "page-item",
          class: {
            'disabled': _vm.currentPage === 1
          }
        }, [_c('a', {
          staticClass: "page-link",
          attrs: {
            "href": "#",
            "aria-label": "Previous"
          },
          on: {
            "click": function click($event) {
              $event.preventDefault();

              _vm.prev($event);
            }
          }
        }, [_c('span', {
          attrs: {
            "aria-hidden": "true"
          }
        }, [_vm._v("")])])]), _vm._v(" "), _vm._l(_vm.pages, function (item) {
          return _c('li', {
            staticClass: "page-item",
            class: {
              'active': item.page === _vm.currentPage,
              'disabled': !!item.divider
            },
            attrs: {
              "data-page": item.page
            }
          }, [_vm._t("default", [item.divider ? _c('a', {
            staticClass: "page-link"
          }, [_vm._v("")]) : _c('a', {
            staticClass: "page-link",
            class: item.class,
            attrs: {
              "href": "#",
              "data-label": item.label
            },
            on: {
              "click": function click($event) {
                $event.preventDefault();

                _vm.paginate(item.page, $event);
              }
            }
          }, [item.label ? _c('span', {
            attrs: {
              "aria-hidden": "true"
            },
            domProps: {
              "innerHTML": _vm._s(item.label)
            }
          }) : _vm._e(), _vm._v(" "), item.page ? _c('span', {
            attrs: {
              "aria-hidden": "true"
            },
            domProps: {
              "innerHTML": _vm._s(item.page)
            }
          }) : _vm._e()])], {
            item: item
          })], 2);
        }), _vm._v(" "), _c('li', {
          staticClass: "page-item",
          class: {
            'disabled': _vm.currentPage >= _vm.totalPages
          }
        }, [_c('a', {
          staticClass: "page-link",
          attrs: {
            "href": "#",
            "aria-label": "Next"
          },
          on: {
            "click": function click($event) {
              $event.preventDefault();

              _vm.next($event);
            }
          }
        }, [_c('span', {
          attrs: {
            "aria-hidden": "true"
          }
        }, [_vm._v("")])])])], 2)]);
      },
      staticRenderFns: [],
      name: 'pagination',
      props: {
        /**
         * The alignment of the pagination component.
         *
         * @prop String
         */
        align: {
          type: String,
          validate: function validate(value) {
            return ['start', 'end', 'center'].indexOf(value) !== -1;
          }
        },

        /**
         * The page on which the paginator should start.
         *
         * @prop String
         */
        page: {
          type: Number,
          default: 1
        },

        /**
         * The total number of pages in the paginator.
         *
         * @prop String
         */
        totalPages: {
          type: Number,
          default: 1
        },

        /**
         * The number of pages to show when the total number of pages is
         * greater than the number of pages that should be shown.
         *
         * @prop String
         */
        showPages: {
          type: Number,
          default: 6
        }
      },
      methods: {
        next: function next(event) {
          this.paginate(this.currentPage >= this.totalPages ? this.currentPage : this.currentPage + 1, event);
        },
        prev: function prev(event) {
          this.paginate(this.currentPage <= 1 ? this.currentPage : this.currentPage - 1, event);
        },
        paginate: function paginate(page, event) {
          if (event.currentTarget.parentNode.classList.contains('disabled')) {
            return;
          }

          this.setActivePage(page);
          this.$emit('paginate', page, event);
        },
        setActivePage: function setActivePage(page) {
          if (this.currentPage !== page) {
            this.currentPage = page;
          }
        },
        generate: function generate() {
          var pages = [];
          var showPages = this.showPages % 2 ? this.showPages + 1 : this.showPages;
          var startPage = this.currentPage >= showPages ? this.currentPage - showPages / 2 : 1;
          var startOffset = showPages + startPage;
          var endPage = this.totalPages < startOffset ? this.totalPages : startOffset;
          var diff = startPage - endPage + showPages;
          startPage -= startPage - diff > 0 ? diff : 0;

          if (startPage > 1) {
            pages.push({
              page: 1
            });
          }

          if (startPage > 2) {
            pages.push({
              divider: true
            });
          }

          for (var i = startPage; i < endPage; i++) {
            pages.push({
              page: i
            });
          }

          if (endPage <= this.totalPages) {
            if (this.totalPages - 1 > endPage) {
              pages.push({
                divider: true
              });
            }

            pages.push({
              page: this.totalPages
            });
          }

          return pages;
        }
      },
      computed: {
        pages: function pages() {
          return this.generate();
        },
        classes: function classes() {
          var classes = {};
          classes['justify-content-' + this.align] = true;
          return classes;
        }
      },
      data: function data() {
        return {
          currentPage: this.page
        };
      }
    };

    var plugin$34 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          Pagination: Pagination
        });
      }
    });

    var CUSTOM_SELECT_PREFIX = 'custom-select-';
    var SelectField = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('form-group', [_vm._t("label", [_vm.label ? _c('form-label', {
          attrs: {
            "for": _vm.id
          },
          domProps: {
            "innerHTML": _vm._s(_vm.label)
          }
        }) : _vm._e()]), _vm._v(" "), _vm._t("control", [_c('select', {
          class: _vm.mergeClasses(_vm.controlClasses, _vm.colorableClasses),
          attrs: {
            "id": _vm.id,
            "name": _vm.name,
            "required": _vm.required,
            "disabled": _vm.disabled || _vm.readonly,
            "readonly": _vm.readonly,
            "pattern": _vm.pattern
          },
          domProps: {
            "value": _vm.value
          },
          on: {
            "input": function input($event) {
              _vm.$emit('input', $event.target.value);
            }
          }
        }, [_vm._t("default")], 2)]), _vm._v(" "), _vm._t("help", [_vm.helpText ? _c('help-text', {
          domProps: {
            "innerHTML": _vm._s(_vm.helpText)
          }
        }) : _vm._e()]), _vm._v(" "), _vm._t("feedback", [_vm.validFeedback ? _c('form-feedback', {
          attrs: {
            "valid": ""
          },
          domProps: {
            "innerHTML": _vm._s(_vm.validFeedback)
          }
        }) : _vm._e(), _vm._v(" "), _vm.invalidFeedback ? _c('form-feedback', {
          attrs: {
            "invalid": ""
          },
          domProps: {
            "innerHTML": _vm._s(_vm.invalidFeedback)
          }
        }) : _vm._e()])], 2);
      },
      staticRenderFns: [],
      name: 'select-field',
      components: {
        HelpText: HelpText,
        FormGroup: FormGroup,
        FormLabel: FormLabel,
        FormFeedback: FormFeedback
      },
      extends: FormControl,
      mixins: [Colorable, FormControl, MergeClasses],
      props: {
        /**
         * Add `custom-select` to the form control if true.
         *
         * @property String
         */
        custom: Boolean
      },
      computed: {
        controlClass: function controlClass() {
          var controlClass = this.custom ? 'custom-select' : this.defaultControlClass;
          return this.plaintext ? "".concat(controlClass, "-plaintext") : controlClass;
        },
        customSelectClasses: function customSelectClasses() {
          return [CUSTOM_SELECT_PREFIX.replace(/\-$/, '') + (this.plaintext ? '-plaintext' : ''), this.customSelectSizeClass, this.spacing || ''].join(' ');
        }
      }
    };

    var plugin$35 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          SelectField: SelectField
        });
      }
    });

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeMax$4 = Math.max;

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(o) { return o.user == 'barney'; });
     * // => 0
     *
     * // The `_.matches` iteratee shorthand.
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findIndex(users, ['active', false]);
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.findIndex(users, 'active');
     * // => 2
     */
    function findIndex$1(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax$4(length + index, 0);
      }
      return baseFindIndex(array, baseIteratee(predicate, 3), index);
    }

    var Slides = {
      name: 'slides',
      props: {
        /**
         * The active slide index or key.
         *
         * @type {String|Number}
         */
        active: {
          type: [String, Number],
          default: 0
        }
      },
      watch: {
        active: function active(value, oldValue) {
          this.lastSlide = oldValue;
          this.currentSlide = value;
        }
      },
      methods: {
        /**
         * Get the HTML nodes from the default slots (exluding children without tags).
         *
         * @return {Array}
         */
        slides: function slides() {
          return map(filter(this.$slots.default, function (vnode, i) {
            return !!vnode.tag;
          }), function (vnode, i) {
            if (!vnode.key || !vnode.data && !vnode.data.key) {
              vnode.data = assignIn(vnode.data, {
                key: vnode.key = i
              });
            }

            return vnode;
          });
        },

        /**
         * Get a slide by index.
         *
         * @return {Array}
         */
        slide: function slide(index) {
          return this.findSlideByKey(index) || this.findSlideByIndex(index) || this.findSlideByIndex(0);
        },

        /**
         * Find a slide by a given key or return null if non found.
         *
         * @param  {Number|String} key
         * @return {VNode|null}
         */
        findSlideByKey: function findSlideByKey(key) {
          return head(filter(this.slides(), function (vnode, i) {
            if (vnode.key === key) {
              return vnode;
            } else if (vnode.data && vnode.data.key === key) {
              return vnode;
            }

            return null;
          }));
        },

        /**
         * Find a slide by a given index or return null if non found.
         *
         * @param  {Number|String} key
         * @return {VNode|null}
         */
        findSlideByIndex: function findSlideByIndex(index) {
          return this.slides()[index] || null;
        },

        /**
         * Get the slide index for a give slide object or key
         *
         * @param  {Number|String} slide
         * @return {VNode|null}
         */
        getSlideIndex: function getSlideIndex(slide) {
          var key = !isUndefined(slide.data) ? slide.data.key : slide.key || slide;
          return findIndex$1(this.slides(), function (vnode, i) {
            if (slide === vnode) {
              return true;
            } else if (vnode.data && vnode.data.key === key) {
              return true;
            } else if (vnode.key && vnode.key === key) {
              return true;
            } else if (i === slide) {
              return true;
            }

            return false;
          });
        }
      },
      data: function data() {
        return {
          lastSlide: null,
          currentSlide: this.active
        };
      },
      render: function render(h) {
        return this.slide(this.currentSlide);
      }
    };

    var SlideDeckControls = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "slide-deck-controls"
        }, _vm._l(_vm.slides, function (slide) {
          return _c('a', {
            staticClass: "slide-deck-control-icon",
            class: {
              'is-active': (slide.data ? slide.data.key : slide.key) === _vm.active
            },
            attrs: {
              "href": "#"
            },
            on: {
              "click": function click($event) {
                $event.preventDefault();

                _vm.onClick($event, slide);
              }
            }
          }, [_c('i', {
            staticClass: "fa fa-circle"
          })]);
        }));
      },
      staticRenderFns: [],
      name: 'slide-deck-controls',
      props: {
        /**
         * The slide key or index that should show.
         *
         * @type {Number}
         */
        active: {
          type: [String, Number],
          default: 0
        },

        /**
         * An array of slide vnodes
         *
         * @type {Number}
         */
        slides: {
          type: Array,
          required: true
        }
      },
      methods: {
        onClick: function onClick(event, slide) {
          this.$emit('click', event, slide);
        }
      },
      computed: {},
      data: function data() {
        return {};
      }
    };

    var SlideDeck = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "slide-deck",
          class: {
            'slide-deck-flex': _vm.center
          }
        }, [_c('div', {
          ref: "content",
          staticClass: "slide-deck-content",
          style: {
            width: _vm.width,
            height: _vm.height
          }
        }, [_c('keep-alive', [_c('transition', {
          attrs: {
            "name": "slide-".concat(_vm.direction)
          },
          on: {
            "after-enter": _vm.onSlideAfterEnter,
            "before-enter": _vm.onSlideBeforeEnter,
            "enter": _vm.onSlideEnter,
            "after-leave": _vm.onSlideAfterLeave,
            "before-leave": _vm.onSlideBeforeLeave,
            "leave": _vm.onSlideLeave
          }
        }, [_c('slides', {
          key: _vm.currentSlide,
          ref: "slides",
          attrs: {
            "active": _vm.currentSlide
          }
        }, [_vm._t("default")], 2)], 1)], 1)], 1), _vm._v(" "), _vm._t("controls", [_vm.controls ? _c('slide-deck-controls', {
          ref: "controls",
          attrs: {
            "slides": _vm.slides(),
            "active": _vm.currentSlide
          },
          on: {
            "click": _vm.onClickControl
          }
        }) : _vm._e()])], 2);
      },
      staticRenderFns: [],
      name: 'slide-deck',
      components: {
        Slides: Slides,
        SlideDeckControls: SlideDeckControls
      },
      props: {
        /**
         * The slide key or index that should show.
         *
         * @type {Number}
         */
        active: {
          type: [String, Number],
          default: 0
        },

        /**
         * Center the slide-deck.
         *
         * @type Boolean
         */
        center: {
          type: Boolean,
          default: true
        },

        /**
         * Show the slide-deck controls to change the slide.
         *
         * @type Boolean
         */
        controls: Boolean,

        /**
         * Flex the content within the popover.
         *
         * @type Boolean
         */
        flex: {
          type: Boolean,
          default: true
        },

        /**
         * Give a selector or Element to use apply a hidden overflow. If false,
         * no overflow will be applied. Defaults to the slide deck's container.
         *
         * @type {String|Element|Boolean}
         */
        overflow: {
          type: [Object, String, Element, Boolean],
          default: true
        },

        /**
         * The mode determines how the popover content will flex based on the
         * varying heights of the slides.
         *
         * @type Boolean
         */
        resizeMode: {
          type: [Function, Boolean, String],
          default: 'auto',
          validate: function validate(value) {
            return ['auto', 'initial', 'inherit'].indexOf(value) !== 1;
          }
        }
      },
      watch: {
        active: function active(value, oldValue) {
          this.lastSlide = oldValue;
          this.currentSlide = value;
        },
        currentSlide: function currentSlide(value, oldValue) {
          this.direction = this.$refs.slides.getSlideIndex(oldValue) > this.$refs.slides.getSlideIndex(value) ? 'backward' : 'forward';
        }
      },
      methods: {
        resize: function resize(el) {
          if (isFunction$1(this.resizeMode)) {
            this.resizeMode.call(this, el || this.$el);
          } else {
            var style = getComputedStyle(el);

            if (!el.style.width) {
              el.width = el.style.width = "calc(".concat(style.width, " + ").concat(style.marginLeft, " + ").concat(style.marginRight, ")");
            }

            if (!el.style.height) {
              el.height = el.style.height = "calc(".concat(style.height, " + ").concat(style.marginTop, " + ").concat(style.marginBottom, ")");
            }
          }
        },
        slide: function slide(index) {
          return this.$refs.slides ? this.$refs.slides.slide(index || this.active) : null;
        },
        slides: function slides() {
          return this.$refs.slides ? this.$refs.slides.slides() : [];
        },
        onClickControl: function onClickControl(event, vnode) {
          this.currentSlide = vnode.data ? vnode.data.key : vnode.key;
        },
        onSlideAfterEnter: function onSlideAfterEnter(el) {
          if (el.width) {
            el.width = el.style.width = null;
          }

          if (el.height) {
            el.height = el.style.height = null;
          }

          this.width = null;
          this.height = null;
          this.$emit('after-enter', this.$refs.slides.slide(this.currentSlide), this.$refs.slides.slide(this.lastSlide));
        },
        onSlideBeforeEnter: function onSlideBeforeEnter(el) {
          this.$emit('before-enter', this.$refs.slides.slide(this.currentSlide), this.$refs.slides.slide(this.lastSlide));
        },
        onSlideEnter: function onSlideEnter(el, done) {
          var _this = this;

          this.resize(el);
          this.width = el.style.width;
          this.height = el.style.height;
          transition(el).then(function (delay) {
            _this.$nextTick(done);
          });
          this.$emit('enter', this.$refs.slides.slide(this.currentSlide), this.$refs.slides.slide(this.lastSlide));
        },
        onSlideAfterLeave: function onSlideAfterLeave(el) {
          var _this2 = this;

          if (el.width) {
            el.width = el.style.width = null;
          }

          if (el.height) {
            el.height = el.style.height = null;
          }

          this.$nextTick(function () {
            _this2.$emit('after-leave', _this2.$refs.slides.slide(_this2.lastSlide), _this2.$refs.slides.slide(_this2.currentSlide));
          });
        },
        onSlideBeforeLeave: function onSlideBeforeLeave(el) {
          this.resize(el);
          this.$emit('before-leave', this.$refs.slides.slide(this.lastSlide), this.$refs.slides.slide(this.currentSlide));
        },
        onSlideLeave: function onSlideLeave(el, done) {
          var _this3 = this;

          transition(el).then(function (delay) {
            _this3.$nextTick(done);
          });
          this.$emit('leave', this.$refs.slides.slide(this.lastSlide), this.$refs.slides.slide(this.currentSlide));
        }
      },
      computed: {
        overflowElement: function overflowElement() {
          if (this.overflow === true) {
            return this.$el;
          } else if (this.overflow instanceof Element) {
            return this.overflow;
          } else if (this.overflow && this.overflow.elm) {
            return this.overflow.elm;
          } else if (this.overflow) {
            return document.querySelector(this.overflow);
          }

          return null;
        },
        nodes: function nodes() {
          return this.$slots.default;
        }
      },
      mounted: function mounted() {
        if (this.overflowElement) {
          this.overflowElement.style.overflow = 'hidden';
        }
      },
      data: function data() {
        return {
          height: null,
          width: null,
          lastSlide: null,
          currentSlide: this.active,
          direction: 'forward'
        };
      }
    };

    var plugin$36 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          Slides: Slides,
          SlideDeck: SlideDeck
        });
      }
    });

    var TableViewHeader = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('th', {
          attrs: {
            "scope": "col"
          }
        }, [_vm.id && _vm.request ? [_c('a', {
          staticClass: "sort",
          attrs: {
            "href": "#",
            "data-id": _vm.id
          },
          on: {
            "click": function click($event) {
              $event.preventDefault();

              _vm.$emit('order', _vm.id);
            }
          }
        }, [!_vm.$slots.default ? [_vm._v(" " + _vm._s(_vm.label || _vm.name || _vm.id) + " ")] : _vm._e(), _vm._v(" "), _vm._t("default")], 2), _vm._v(" "), _vm.request.params.order === _vm.id && _vm.request.params.sort === 'asc' ? _c('i', {
          staticClass: "sort-icon fa fa-sort-asc"
        }) : _vm._e(), _vm._v(" "), _vm.request.params.order === _vm.id && _vm.request.params.sort === 'desc' ? _c('i', {
          staticClass: "sort-icon fa fa-sort-desc"
        }) : _vm._e()] : [!_vm.$slots.default ? [_vm._v(" " + _vm._s(_vm.label || _vm.name || _vm.id) + " ")] : _vm._e(), _vm._v(" "), _vm._t("default")]], 2);
      },
      staticRenderFns: [],
      name: 'table-view-header',
      props: {
        id: [Number, String],
        label: [Number, String],
        name: [Number, String],
        request: Object
      }
    };

    var DataTable = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('table', {
          staticClass: "table",
          class: {
            'table-hover': _vm.hover && !_vm.loading && _vm.data.length
          }
        }, [_c('thead', {
          attrs: {
            "slot": "thead"
          },
          slot: "thead"
        }, [_vm.columns.length || _vm.$slots.columns ? _c('tr', {
          attrs: {
            "slot": "columns"
          },
          slot: "columns"
        }, _vm._l(_vm.tableColumns, function (column, key) {
          return _c('table-view-header', _vm._g(_vm._b({
            key: key,
            attrs: {
              "request": _vm.request
            },
            on: {
              "order": function order(id) {
                return _vm.$emit('order', id);
              }
            }
          }, 'table-view-header', column.props || column, false), column.events));
        })) : _vm._e()]), _vm._v(" "), _c('tbody', [_vm.loading ? _c('tr', [_c('td', {
          staticClass: "position-relative",
          style: {
            'height': _vm.height(_vm.minHeight)
          },
          attrs: {
            "colspan": _vm.tableColumns.length
          }
        }, [_c('activity-indicator', {
          attrs: {
            "center": true
          }
        })], 1)]) : !_vm.data.length ? _c('tr', [_c('td', {
          staticClass: "position-relative",
          attrs: {
            "colspan": _vm.tableColumns.length
          }
        }, [_c('alert', {
          staticClass: "my-3",
          attrs: {
            "variant": "warning"
          }
        }, [_c('i', {
          staticClass: "fa fa-warning"
        }), _vm._v(" There are no results found. ")])], 1)]) : _vm._t("default", _vm._l(_vm.data, function (row, i) {
          return _c('tr', _vm._l(_vm.tableColumns, function (column) {
            return _c('td', {
              domProps: {
                "innerHTML": _vm._s(row[column.id] || row[column.name])
              }
            });
          }));
        }), {
          data: _vm.data,
          columns: _vm.tableColumns
        })], 2), _vm._v(" "), _vm._t("tfoot", [_vm.paginate && _vm.response ? _c('tfoot', [_c('td', {
          staticClass: "table-view-footer",
          attrs: {
            "colspan": _vm.tableColumns.length || 1
          }
        }, [_vm._t("pagination", [_c('pagination', {
          attrs: {
            "align": "center",
            "page": _vm.response.current_page,
            "total-pages": _vm.response.last_page
          },
          on: {
            "paginate": function paginate($event) {
              _vm.$emit('paginate');
            }
          }
        })])], 2)]) : _vm._e()])], 2);
      },
      staticRenderFns: [],
      components: {
        Alert: Alert,
        Pagination: Pagination,
        TableViewHeader: TableViewHeader,
        ActivityIndicator: ActivityIndicator
      },
      props: {
        // (array) An array of table column
        // [{id: 'database_id', name: 'Database id', width: '20%'}]
        columns: {
          type: Array,
          default: function _default() {
            return [];
          }
        },
        data: {
          type: Array,
          required: true
        },
        // (string) Add table-hover to the table element
        hover: {
          type: Boolean,
          default: true
        },
        loading: Boolean,
        // (integer) The minimum height of the row when loading data
        minHeight: {
          type: Number,
          default: 400
        },
        // (bool) Should show the pagination for this table
        paginate: {
          type: Boolean,
          default: true
        }
      },
      methods: {
        height: function height(min) {
          var elements = [// this.$el.querySelector('thead'),
          this.$el.querySelector('tbody')];
          var height = 0;

          forEach(elements, function (el) {
            height += el.getBoundingClientRect().height;
          });

          return unit(Math.max(min, height));
        }
      },
      computed: {
        tableColumns: function tableColumns() {
          var columns = this.columns;

          if (!columns || !columns.length) {
            columns = keys(this.data[0]);
          }

          return columns.map(function (column) {
            return isObject(column) ? column : {
              name: column
            };
          });
        }
      }
    };

    var Transformer =
    /*#__PURE__*/
    function () {
      /**
       * Initialize the transformer instance using an HTTP response object.
       *
       * @param data object
       * @return void
       */
      function Transformer(response) {
        _classCallCheck(this, Transformer);

        if (!isObject(this.$originalResponse = response)) {
          throw new Error('The transformer must be instantiated with a response object.');
        }

        if (!isArray(this.$required = this.required()) || !this.$required.length) {
          throw new Error('A transformer must have at least one required property.');
        }

        this.$transformedResponse = this.transform(response);
        this.validate();
        this.initialize();
      }
      /**
       * A method to override to perform logic to finished initializing.
       *
       * @return void
       */


      _createClass(Transformer, [{
        key: "initialize",
        value: function initialize() {} //

        /**
         * Define an array of required properties with at least one value.
         *
         * @return void
         */

      }, {
        key: "required",
        value: function required() {} //

        /**
         * Tranform the response object
         *
         * @property String
         */

      }, {
        key: "transform",
        value: function transform(response) {
          return response;
        }
        /**
         * Get the tranformed response
         *
         * @property String
         */

      }, {
        key: "response",
        value: function response() {
          return this.$transformedResponse;
        }
        /**
         * Validate the tranformed response.
         *
         * @return void
         */

      }, {
        key: "validate",
        value: function validate() {
          var _this = this;

          if (!isObject(this.$transformedResponse)) {
            throw new Error('The transformed response must be an object.');
          }

          forEach(this.$required, function (key) {
            if (!(key in _this.$transformedResponse)) {
              throw new Error("\"".concat(key, "\" is a required property and does not exist in the tranformed response."));
            }
          });
        }
      }]);

      return Transformer;
    }();

    var TableViewTransformer =
    /*#__PURE__*/
    function (_Transformer) {
      _inherits(TableViewTransformer, _Transformer);

      function TableViewTransformer() {
        _classCallCheck(this, TableViewTransformer);

        return _possibleConstructorReturn(this, (TableViewTransformer.__proto__ || Object.getPrototypeOf(TableViewTransformer)).apply(this, arguments));
      }

      _createClass(TableViewTransformer, [{
        key: "required",
        value: function required() {
          return [// The end of the count of the paginated list.
          'to', // The start of the count of the paginated list.
          'from', // The total number of items (not just included in the pagination)
          'total', // The number of items per page
          'per_page', // The last page number (or total pages)
          'last_page', // The current page number
          'current_page', // The actual response data to appear in the table
          'data'];
        }
      }, {
        key: "data",
        value: function data() {
          return this.$transformedResponse.data;
        }
      }, {
        key: "initialize",
        value: function initialize() {
          if (!isArray(this.data())) {
            throw new Error('The data property must be an array.');
          }
        }
      }]);

      return TableViewTransformer;
    }(Transformer);

    var TableView = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "table-view"
        }, [_vm.heading || _vm.description || _vm.$slots.buttons ? _c('div', {
          staticClass: "d-flex justify-content-between align-items-center"
        }, [_vm._t("heading", [_vm.heading ? _c('h2', {
          domProps: {
            "innerHTML": _vm._s(_vm.heading)
          }
        }) : _vm._e()]), _vm._v(" "), _vm._t("description", [_vm.description ? _c('p', {
          domProps: {
            "innerHTML": _vm._s(_vm.description)
          }
        }) : _vm._e()]), _vm._v(" "), _vm.$slots.buttons ? _c('div', {
          staticClass: "ml-auto my-3"
        }, [_vm._t("buttons")], 2) : _vm._e()], 2) : _vm._e(), _vm._v(" "), _vm.card ? _c('card', [_c('data-table', {
          attrs: {
            "columns": _vm.columns,
            "data": _vm.data,
            "hover": _vm.hover,
            "loading": _vm.loading,
            "min-height": _vm.minHeight,
            "paginate": _vm.paginate
          },
          on: {
            "paginate": _vm.onPaginate,
            "order": function order(id) {
              return _vm.orderBy(id);
            }
          }
        }, [_vm._t("default", null, {
          data: _vm.data,
          columns: _vm.columns
        })], 2)], 1) : _c('data-table', {
          attrs: {
            "columns": _vm.columns,
            "data": _vm.data,
            "hover": _vm.hover,
            "loading": _vm.loading,
            "min-height": _vm.minHeight,
            "paginate": _vm.paginate
          },
          on: {
            "paginate": _vm.onPaginate,
            "order": function order(id) {
              return _vm.orderBy(id);
            }
          }
        }, [_vm._t("default", null, {
          data: _vm.data,
          columns: _vm.columns
        })], 2)], 1);
      },
      staticRenderFns: [],
      name: 'table-view',
      mixins: [Proxy],
      components: {
        Card: Card,
        DataTable: DataTable,
        TableViewHeader: TableViewHeader
      },
      props: {
        // (boolean) Show the table in a card.
        card: Boolean,
        // (string) A relative or absolute endpoint URL used to fetch data
        url: {
          type: String,
          required: true
        },
        // (integer) The starting page of the table
        page: {
          type: Number,
          default: 1
        },
        // (integer) The total number of results per page
        limit: {
          type: Number,
          default: 20
        },
        // (string) The column used to order the data
        order: String,
        // (string) The sort direction (asc|desc)
        sort: {
          type: String,
          validate: function validate(value) {
            return ['asc', 'desc'].indexOf(value) !== -1;
          }
        },
        // (integer) The minimum height of the row when loading data
        minHeight: {
          type: Number,
          default: 400
        },
        // (array) An array of button objects
        // [{href: 'test-123', label: 'Test 123'}]
        buttons: {
          type: Array,
          default: function _default() {
            return [];
          }
        },
        // (array) An array of table column
        // [{id: 'database_id', name: 'Database id', width: '20%'}]
        columns: {
          type: Array,
          default: function _default() {
            return [];
          }
        },
        // (string) The table heading
        heading: String,
        // (string) Add table-hover to the table element
        hover: {
          type: Boolean,
          default: true
        },
        // (string) The table description
        description: String,
        // (bool) Should show the pagination for this table
        paginate: {
          type: Boolean,
          default: true
        },
        // (object) The HTTP response transformer instance
        transformer: {
          type: Object,
          validate: function validate(value) {
            return value instanceof TableViewTransformer;
          }
        }
      },
      methods: {
        orderBy: function orderBy(order) {
          var defaultSort = 'desc';
          var currentSort = this.getRequestParam('sort');
          var currentOrder = this.getRequestParam('order');
          this.addRequestParam('order', order);
          this.addRequestParam('sort', currentOrder !== order || !currentSort ? defaultSort : currentSort === defaultSort ? 'asc' : null);
          this.fetch();
        },
        getRequestHeader: function getRequestHeader(key, value) {
          return this.request.headers[key] || value;
        },
        addRequestHeader: function addRequestHeader(key, value) {
          if (!this.request.headers) {
            this.request.headers = {};
          }

          this.request.headers[key] = value;
        },
        getRequestParam: function getRequestParam(key, value) {
          return this.request.params[key] || value;
        },
        addRequestParam: function addRequestParam(key, value) {
          if (!this.request.params) {
            this.request.params = {};
          }

          this.request.params[key] = value;
        },
        fetch: function fetch() {
          var _this = this;

          var request = new Request(this.url, this.request);
          this.loading = true;
          return request.get().then(function (response) {
            var transformer = _this.transformer || new TableViewTransformer(response);
            _this.response = transformer.response();
            _this.data = transformer.data();
            _this.loading = false;
          }, function (errors) {
            _this.loading = false;
          });
        },
        onPaginate: function onPaginate(page, event) {
          if (!this.request.params) {
            this.request.params = {};
          }

          this.request.params.page = page;
          this.fetch();
        }
      },
      data: function data() {
        return {
          // (array) The dataset for the table
          data: this.$attrs.data || [],
          // (bool) Is the table currently loading data
          loading: false,
          // (null|object) The response object
          response: null,
          // (object) The HTTP request object
          request: assignIn({
            headers: {},
            params: {
              page: this.page,
              limit: this.limit,
              order: this.order,
              sort: this.sort
            }
          }, this.$attrs.request)
        };
      },
      mounted: function mounted() {
        this.fetch();
      },
      beforeDestroy: function beforeDestroy() {
        this.$off();
      }
    };

    var plugin$37 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          TableView: TableView
        });
      }
    });

    var TextareaField = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('form-group', [_vm._t("label", [_vm.label || _vm.hasDefaultSlot ? _c('form-label', {
          attrs: {
            "for": _vm.id
          }
        }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))])], 2) : _vm._e()]), _vm._v(" "), _vm._t("control", [_c('div', {
          staticClass: "position-relative"
        }, [_c('textarea', {
          directives: [{
            name: "bind-events",
            rawName: "v-bind-events",
            value: _vm.bindEvents,
            expression: "bindEvents"
          }],
          class: _vm.mergeClasses(_vm.controlClasses, _vm.colorableClasses),
          attrs: {
            "id": _vm.id,
            "rows": _vm.rows,
            "errors": _vm.errors,
            "pattern": _vm.pattern,
            "readonly": _vm.readonly,
            "required": _vm.required,
            "maxlength": _vm.maxlength,
            "placeholder": _vm.placeholder,
            "disabled": _vm.disabled || _vm.readonly
          },
          domProps: {
            "value": _vm.value
          },
          on: {
            "input": function input($event) {
              _vm.$emit('input', $event.target.value);
            }
          }
        }), _vm._v(" "), _vm._t("feedback", [_vm.validFeedback ? _c('form-feedback', {
          attrs: {
            "valid": ""
          },
          domProps: {
            "innerHTML": _vm._s(_vm.validFeedback)
          }
        }) : _vm._e(), _vm._v(" "), _vm.invalidFeedback ? _c('form-feedback', {
          attrs: {
            "invalid": ""
          },
          domProps: {
            "innerHTML": _vm._s(_vm.invalidFeedback)
          }
        }) : _vm._e()])], 2)]), _vm._v(" "), _vm._t("help", [_vm.helpText ? _c('help-text', {
          domProps: {
            "innerHTML": _vm._s(_vm.helpText)
          }
        }) : _vm._e()])], 2);
      },
      staticRenderFns: [],
      name: 'textarea-field',
      components: {
        HelpText: HelpText,
        FormGroup: FormGroup,
        FormLabel: FormLabel,
        FormFeedback: FormFeedback
      },
      mixins: [Colorable, FormControl, MergeClasses],
      props: {
        /**
         * The type attribute
         *
         * @property String
         */
        type: {
          type: String,
          default: 'text'
        },

        /**
         * The rows attribute
         *
         * @property String
         */
        rows: [Number, String]
      }
    };

    var plugin$38 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          TextareaField: TextareaField
        });
      }
    });

    var ThumbnailListItem = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "thumbnail-list-item",
          style: {
            height: _vm.unit(_vm.height),
            width: _vm.unit(_vm.width),
            minHeight: _vm.unit(_vm.minHeight),
            maxHeight: _vm.unit(_vm.maxHeight),
            minWidth: _vm.unit(_vm.minWidth),
            maxWidth: _vm.unit(_vm.maxWidth)
          }
        }, [_vm.src ? _c('img', {
          class: {
            'img-fluid': _vm.fluid
          },
          attrs: {
            "src": _vm.src,
            "alt": _vm.alt
          }
        }) : _vm._e(), _vm._v(" "), _vm._t("default")], 2);
      },
      staticRenderFns: [],
      props: {
        alt: String,
        src: String,
        width: [String, Number],
        height: [String, Number],
        minHeight: [String, Number],
        maxHeight: [String, Number],
        minWidth: [String, Number],
        maxWidth: [String, Number],
        fluid: {
          type: Boolean,
          default: true
        }
      },
      methods: {
        unit: unit
      }
    };

    var ThumbnailList = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "thumbnail-list",
          class: _vm.classes
        }, [_vm._l(_vm.images, function (image) {
          return !!_vm.images ? _c('thumbnail-list-item', {
            attrs: {
              "src": image,
              "width": _vm.width
            }
          }) : _vm._e();
        }), _vm._v(" "), _vm._t("default")], 2);
      },
      staticRenderFns: [],
      components: {
        ThumbnailListItem: ThumbnailListItem
      },
      props: {
        fill: Boolean,
        flex: Boolean,
        noFlex: Boolean,
        grid: Boolean,
        wrap: Boolean,
        images: Array,
        width: {
          type: [String, Number],
          default: 75
        }
      },
      computed: {
        classes: function classes() {
          return {
            'thumbnail-list-fill': this.fill,
            'thumbnail-list-flex': this.flex,
            'thumbnail-list-noflex': this.noFlex,
            'thumbnail-list-grid': this.grid,
            'thumbnail-list-wrap': this.wrap
          };
        }
      }
    };

    var plugin$39 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          ThumbnailList: ThumbnailList
        });
      }
    });

    /**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */
    function last(array) {
      var length = array == null ? 0 : array.length;
      return length ? array[length - 1] : undefined;
    }

    /**
     * Gets the parent value at `path` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} path The path to get the parent value of.
     * @returns {*} Returns the parent value.
     */
    function parent(object, path) {
      return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
    }

    /**
     * The base implementation of `_.unset`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The property path to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     */
    function baseUnset(object, path) {
      path = castPath(path, object);
      object = parent(object, path);
      return object == null || delete object[toKey(last(path))];
    }

    /** Used for built-in method references. */
    var arrayProto$1 = Array.prototype;

    /** Built-in value references. */
    var splice$1 = arrayProto$1.splice;

    /**
     * The base implementation of `_.pullAt` without support for individual
     * indexes or capturing the removed elements.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {number[]} indexes The indexes of elements to remove.
     * @returns {Array} Returns `array`.
     */
    function basePullAt(array, indexes) {
      var length = array ? indexes.length : 0,
          lastIndex = length - 1;

      while (length--) {
        var index = indexes[length];
        if (length == lastIndex || index !== previous) {
          var previous = index;
          if (isIndex(index)) {
            splice$1.call(array, index, 1);
          } else {
            baseUnset(array, index);
          }
        }
      }
      return array;
    }

    /**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is invoked
     * with three arguments: (value, index, array).
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
     * to pull elements from an array by value.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */
    function remove(array, predicate) {
      var result = [];
      if (!(array && array.length)) {
        return result;
      }
      var index = -1,
          indexes = [],
          length = array.length;

      predicate = baseIteratee(predicate, 3);
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result.push(value);
          indexes.push(index);
        }
      }
      basePullAt(array, indexes);
      return result;
    }

    var _methods;
    var UploadField = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('form-group', {
          staticClass: "upload-field",
          class: {
            'enable-dropzone': _vm.dropzone,
            'enable-multiple': _vm.multiple
          }
        }, [_c('dropzone', {
          on: {
            "drop": _vm.onDrop
          }
        }, [_vm.multiple && (!_vm.maxUploads || _vm.maxUploads > _vm.value.length) || !_vm.multiple && !_vm.value ? _c('file-field', {
          attrs: {
            "name": _vm.name,
            "label": _vm.label,
            "placeholder": _vm.placeholder,
            "help-text": _vm.helpText,
            "multiple": _vm.multiple,
            "errors": _vm.errors
          },
          on: {
            "change": _vm.onChange
          }
        }) : _vm._e(), _vm._v(" "), _vm.files && _vm.files.length ? _c('thumbnail-list', {
          staticClass: "mt-4",
          attrs: {
            "wrap": ""
          }
        }, _vm._l(_vm.files, function (file, key) {
          return _c('thumbnail-list-item', {
            key: file.lastModified + '-' + file.lastModifiedDate + '-' + file.size + '-' + file.type + '-' + file.name,
            class: {
              'uploading': !!_vm.progressBars[key]
            },
            attrs: {
              "width": _vm.width,
              "min-width": _vm.minWidth,
              "max-width": _vm.maxWidth,
              "height": _vm.height,
              "min-height": _vm.minHeight,
              "max-height": _vm.maxHeight
            }
          }, [_c('file-preview', {
            attrs: {
              "file": file,
              "progress": _vm.progressBars[key] || 0
            },
            on: {
              "loaded": _vm.onLoadedPreview,
              "close": function close($event) {
                _vm.removeFile(file);
              }
            }
          }), _vm._v(" "), _vm._t("default", null, {
            file: file
          }), _vm._v(" "), _c('thumbnail-list-item')], 2);
        })) : _vm._e(), _vm._v(" "), _vm.showDropElement ? _c('div', {
          staticClass: "upload-field-dropzone",
          style: {
            'min-height': _vm.dropzoneMinHeight
          },
          on: {
            "drop": function drop($event) {
              $event.preventDefault();
              return _vm.onDrop($event);
            }
          }
        }, [_c('i', {
          staticClass: "fa fa-cloud-upload"
        }), _vm._v(" "), _c('div', [_vm._v("Drag and drop files to upload")])]) : _vm._e()], 1)], 1);
      },
      staticRenderFns: [],
      name: 'upload-field',
      mixins: [FormControl],
      components: {
        Dropzone: Dropzone,
        FormGroup: FormGroup,
        FileField: FileField,
        FilePreview: FilePreview,
        ThumbnailList: ThumbnailList,
        ThumbnailListItem: ThumbnailListItem
      },
      model: {
        prop: 'value',
        event: 'change'
      },
      props: {
        /**
         * Can user upload multiple files
         *
         * @property String
         */
        multiple: Boolean,

        /**
         * The maximum number of files that a user can upload
         *
         * @property String
         */
        maxUploads: Number,

        /**
         * The height attribute for the control element
         *
         * @property String
         */
        height: [Number, String],

        /**
         * The minimum height attribute for the control element
         *
         * @property String
         */
        minHeight: [Number, String],

        /**
         * The maximum height attribute for the control element
         *
         * @property String
         */
        maxHeight: [Number, String],

        /**
         * The width attribute for the control element
         *
         * @property String
         */
        width: [Number, String],

        /**
         * The minimum width attribute for the control element
         *
         * @property String
         */
        minWidth: [Number, String],

        /**
         * The maximum width attribute for the control element
         *
         * @property String
         */
        maxWidth: [Number, String],

        /**
         * Can user drag/drop files into browser to upload them.
         *
         * @property String
         */
        dropzoneMinHeight: [Number, String],

        /**
         * Is the user dragging a file over the dropzone
         *
         * @property String
         */
        dragging: {
          type: [String, Boolean],
          default: function _default() {
            return undefined;
          }
        },

        /**
         * Can user drag/drop files into browser to upload them.
         *
         * @property String
         */
        dropzone: {
          type: Boolean,
          default: true
        },

        /**
         * The data attribute
         *
         * @property File|FileList|Array
         */
        value: {
          type: [Object, File, FileList, Array],
          default: function _default() {
            return !this.multiple ? null : [];
          }
        },

        /**
         * An HTTP Model used to send the request
         *
         * @type Model
         */
        model: [Model, Function],
        request: Object
      },
      methods: (_methods = {
        removeFile: function removeFile(data) {
          if (this.multiple) {
            var files = isArray(this.value) ? this.value.slice(0) : [];

            if (data instanceof File) {
              if (data.request && data.request.cancel) {
                data.request.cancel();
              }

              remove(files, {
                name: data.name,
                size: data.size,
                lastModified: data.lastModified
              });
            } else {
              remove(files, data);
            }

            this.$emit('change', files);
          } else {
            if (data.request && data.request.cancel) {
              data.request.cancel();
            }

            this.$emit('change', null);
          }
        },
        addFile: function addFile(file, subject) {
          var data = {
            name: file.name,
            lastModified: file.lastModified,
            lastModifiedDate: file.lastModifiedDate,
            size: file.size,
            type: file.type
          };

          if (this.multiple) {
            var files = subject || (isArray(this.value) ? this.value.slice(0) : []);

            if ((!this.maxUploads || this.maxUploads > files.length) && findIndex$1(files, data) === -1) {
              files.push(file);
              this.$emit('change', files);
              this.upload(file);
            }
          } else {
            this.$emit('change', file);
            this.upload(file);
          }
        },
        addFiles: function addFiles(files) {
          var _this = this;

          var subject = isArray(this.value) ? this.value.slice(0) : [];

          forEach(files, function (file) {
            _this.addFile(file, subject);
          });

          event.target.value = null;
        },

        /**
         * Upload function that handles auto-uploading fields asynchronously.
         * This is designed to work with REST API's and replace the file Object
         * with the RESTful returned by the server.
         *
         * @type Object
         */
        upload: function upload(file) {
          var _this2 = this;

          // Stop upload silently if no model is defined.
          if (!this.model) {
            return Promise.resolve();
          }

          var model = this.model;

          if (!(this.model instanceof Model)) {
            model = new this.model();
          }

          model.set(this.name, file);
          this.$emit('uploading', model);
          this.$set(this.progressBars, this.multiple ? this.value ? this.value.length : 0 : 0, 0);
          return model.save(null, assignIn({
            onUploadProgress: function onUploadProgress(e) {
              if (!file.index) {
                file.index = findIndex$1(_this2.files, file);
              }

              if (!file.request) {
                file.request = model.getRequest();
              }

              _this2.$set(_this2.progressBars, file.index, parseInt(e.loaded / e.total * 100, 10));

              _this2.$emit('progress', model, _this2.progressBars[file.index]);
            }
          }, this.request)).then(function (response) {
            _this2.$nextTick(function () {
              _this2.$emit('upload', model);

              _this2.progressBars[file.index] = false;
            });

            return response;
          });
        },

        /**
         * The `drop` event callback.
         *
         * @type Object
         */
        onDrop: function onDrop(event) {
          this.onChange(event.dataTransfer.files);
        },

        /**
         * The `change` event callback.
         *
         * @type Object
         */
        onChange: function onChange(files) {
          if (files instanceof FileList) {
            this.addFiles(files);
          } else {
            this.addFile(files);
          }
        },

        /**
         * The `dragover` event callback.
         *
         * @type Object
         */
        onDragOver: function onDragOver(event) {
          this.isDraggingInside = true;
          this.$emit('update:dragging', true);
          this.$emit('drag:over', event);
        },

        /**
         * The `dragover` event callback.
         *
         * @type Object
         */
        onDragEnter: function onDragEnter(event) {
          this.isDraggingInside = true;
          this.$emit('update:dragging', true);
          this.$emit('drag:enter', event);
        },

        /**
         * The `dragleave` event callback.
         *
         * @type Object
         */
        onDragLeave: function onDragLeave(event) {
          this.isDraggingInside = false;
          this.$emit('update:dragging', false);
          this.$emit('drag:leave', event);
        }
      }, _defineProperty(_methods, "onDrop", function onDrop(event) {
        this.isDraggingInside = false;
        this.addFiles(event.dataTransfer.files);
        this.$emit('update:dragging', false);
        this.$emit('drop', event);
      }), _defineProperty(_methods, "onLoadedPreview", function onLoadedPreview(event) {
        this.$emit('loaded', event);
      }), _methods),
      computed: {
        files: function files() {
          return this.multiple ? this.value : this.value ? [this.value] : [];
        },
        showDropElement: function showDropElement() {
          return !isUndefined(this.dragging) ? this.dragging : this.isDraggingInside;
        }
      },
      data: function data() {
        return {
          progressBars: {},
          isDraggingInside: false
        };
      }
    };

    var plugin$40 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          UploadField: UploadField
        });
      }
    });

    /**
     * Creates a `_.find` or `_.findLast` function.
     *
     * @private
     * @param {Function} findIndexFunc The function to find the collection index.
     * @returns {Function} Returns the new find function.
     */
    function createFind(findIndexFunc) {
      return function(collection, predicate, fromIndex) {
        var iterable = Object(collection);
        if (!isArrayLike(collection)) {
          var iteratee = baseIteratee(predicate, 3);
          collection = keys(collection);
          predicate = function(key) { return iteratee(iterable[key], key, iterable); };
        }
        var index = findIndexFunc(collection, predicate, fromIndex);
        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
      };
    }

    /**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': true }
     * ];
     *
     * _.find(users, function(o) { return o.age < 40; });
     * // => object for 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.find(users, { 'age': 1, 'active': true });
     * // => object for 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.find(users, ['active', false]);
     * // => object for 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.find(users, 'active');
     * // => object for 'barney'
     */
    var find$1 = createFind(findIndex$1);

    var WizardButtons = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "wizard-buttons"
        }, [_c('btn-group', {
          ref: "left",
          staticClass: "wizard-buttons-left"
        }, [_vm._t("buttons-left"), _vm._v(" "), _c('btn', {
          ref: "back",
          attrs: {
            "type": "button",
            "variant": "secondary",
            "disabled": _vm.backButton === false || _vm.active === 0 && _vm.backButton !== true,
            "size": _vm.sizeableClass
          },
          on: {
            "click": _vm.onClickBack
          }
        }, [_c('i', {
          staticClass: "fa fa-long-arrow-left"
        }), _vm._v(" Back ")])], 2), _vm._v(" "), _c('btn-group', {
          ref: "right",
          staticClass: "wizard-buttons-right"
        }, [_vm._t("buttons-right"), _vm._v(" "), _vm.active === _vm.steps.length - 1 ? _c('btn-activity', {
          ref: "finish",
          attrs: {
            "activity": _vm.activity,
            "size": _vm.sizeableClass,
            "disabled": _vm.finishButton === false,
            "type": "button",
            "variant": "success"
          },
          on: {
            "click": _vm.onClickFinish
          }
        }, [_vm._v(" Finish ")]) : _vm._e(), _vm._v(" "), _vm.active < _vm.steps.length - 1 ? _c('btn-activity', {
          ref: "next",
          attrs: {
            "activity": _vm.activity,
            "size": _vm.sizeableClass,
            "disabled": _vm.nextButton === false,
            "type": "button",
            "variant": "primary"
          },
          on: {
            "click": _vm.onClickNext
          }
        }, [_vm._v(" Next "), _c('i', {
          staticClass: "fa fa-long-arrow-right"
        })]) : _vm._e()], 2)], 1);
      },
      staticRenderFns: [],
      name: 'wizard-buttons',
      mixins: [Sizeable],
      components: {
        Btn: Btn,
        BtnGroup: BtnGroup,
        BtnActivity: BtnActivity
      },
      props: {
        /**
         * The index or key of the active step.
         *
         * @type {String|Number}
         */
        active: {
          type: [String, Number],
          default: 0
        },

        /**
         * Show the activity indicator in the next or finish button.
         *
         * @type {Boolean}
         */
        activity: Boolean,

        /**
         * Show should the "Back" button.
         *
         * @type {Boolean}
         */
        backButton: Boolean,

        /**
         * Show should the "Finish" button.
         *
         * @type {Boolean}
         */
        finishButton: Boolean,

        /**
         * Show should the "Next" button.
         *
         * @type {Boolean}
         */
        nextButton: Boolean,

        /**
         * An array of steps passed from the parent.
         *
         * @type {Array}
         */
        steps: {
          type: Array,
          required: true
        }
      },
      computed: {
        /**
         * Override the class prefix with an empty string...
         * @return {String}
         */
        sizeableClassPrefix: function sizeableClassPrefix() {
          return '';
        }
      },
      methods: {
        onClickBack: function onClickBack(event) {
          if (this.backButton !== false) {
            this.$emit('click:back', event);
          }
        },
        onClickFinish: function onClickFinish(event) {
          if (this.finishButton !== false) {
            this.$emit('click:finish', event);
          }
        },
        onClickNext: function onClickNext(event) {
          if (this.nextButton !== false) {
            this.$emit('click:next', event);
          }
        }
      }
    };

    var WizardStep = {
      name: 'wizard-step',
      props: {
        /**
         * The parent wizard component instance.
         *
         * @type {String}
        wizard: {
            //required: true,
            type: Object
        },
        */

        /**
         * The step's label in the progress bar.
         *
         * @type {String}
         */
        label: String,

        /**
         * A predicate function to determine if the back button should show.
         * Can also be a boolean value.
         *
         * @type {Function|Boolean}
         */
        backButton: {
          type: [Function, Boolean],
          default: function _default() {
            return null;
          }
        },

        /**
         * Validate if the data input for the step is valid. Required Boolean
         * or a predicate function.
         *
         * @type {Function|Boolean}
         */
        validate: {
          type: [Function, Boolean],
          default: function _default() {
            return true;
          }
        }
      },
      methods: {
        checkValidity: function checkValidity(prop) {
          // Validate the property for the step first.
          if (isFunction$1(this[prop]) ? this[prop](this) === false : this[prop] === false) {
            return false;
          } // Then validate the property of the wizard, this is the global validator


          if (this.$refs.wizard) {
            if (isFunction$1(this.$refs.wizard[prop]) ? this.$refs.wizard[prop](this) === false : this.$refs.wizard[prop] === false) {
              return false;
            }
          }

          return true;
        },
        performValidityChecks: function performValidityChecks() {
          if (this.$refs.wizard) {
            this.checkValidity('validate') ? this.enable() : this.disable();
            this.checkValidity('backButton') ? this.$refs.wizard.enableBackButton() : this.$refs.wizard.disableBackButton();
          }
        },
        disable: function disable() {
          if (this.$refs.wizard) {
            this.$refs.wizard.disableNextButton();
            this.$refs.wizard.disableFinishButton();
          }
        },
        enable: function enable() {
          if (this.$refs.wizard) {
            this.$refs.wizard.enableNextButton();
            this.$refs.wizard.enableFinishButton();
          }
        }
      },
      updated: function updated() {
        this.performValidityChecks();
      },
      mounted: function mounted() {
        this.$nextTick(this.performValidityChecks);
      },
      render: function render(h) {
        if (this.$slots.default.length !== 1) {
          throw new Error('The <wizard-slot> must contain a single parent DOM node.');
        }

        return this.$slots.default[0];
      }
    };

    var WizardError = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "wizard-error"
        }, [_vm.icon ? _c('div', {
          staticClass: "wizard-error-icon"
        }, [_c('i', {
          class: _vm.icon
        })]) : _vm._e(), _vm._v(" "), _vm.title ? _c('h3', {
          staticClass: "wizard-error-title",
          domProps: {
            "innerHTML": _vm._s(_vm.title)
          }
        }) : _vm._e(), _vm._v(" "), _vm._t("default"), _vm._v(" "), _c('div', {
          staticClass: "row justify-content-center"
        }, [_c('div', {
          staticClass: "col-sm-6"
        }, [_vm.errors ? _c('div', {
          staticClass: "my-5"
        }, [_c('ul', {
          staticClass: "mb-0 text-left"
        }, _vm._l(_vm.errors, function (error, i) {
          return _c('li', {
            key: i
          }, [_vm._v(" " + _vm._s(error[0]) + " ")]);
        }))]) : _vm._e(), _vm._v(" "), _c('btn', {
          attrs: {
            "size": "lg",
            "variant": "danger",
            "block": ""
          },
          on: {
            "click": function click($event) {
              _vm.$emit('back');
            }
          }
        }, [_c('i', {
          staticClass: "fa fa-long-arrow-left"
        }), _vm._v(" Go Back ")])], 1)])], 2);
      },
      staticRenderFns: [],
      name: 'wizard-error',
      extends: WizardStep,
      components: {
        Btn: Btn
      },
      props: {
        icon: {
          type: String,
          default: 'fa fa-3x fa-check'
        },
        title: {
          type: String,
          default: 'Error!'
        },
        errors: [Array, Object]
      }
    };

    var WizardHeader = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c(_vm.tag, {
          tag: "component",
          staticClass: "wizard-header",
          class: {
            'text-center': _vm.center
          }
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'wizard-header',
      props: {
        center: {
          type: Boolean,
          default: true
        },

        /**
         * The HTML tag
         *
         * @type {String}
         */
        tag: {
          type: String,
          default: 'h2'
        }
      }
    };

    var WizardProgress = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "wizard-progress"
        }, _vm._l(_vm.steps, function (step, i) {
          return _c('a', {
            staticClass: "wizard-step",
            class: {
              'active': i === _vm.active,
              'disabled': i > _vm.highestStep,
              'complete': i + 1 <= _vm.highestStep
            },
            style: {
              width: "".concat(100 / _vm.steps.length, "%")
            },
            attrs: {
              "href": "#",
              "data-step": i,
              "title": step.label || step.title
            },
            on: {
              "click": function click($event) {
                $event.preventDefault();

                _vm.onClick($event, step);
              }
            }
          }, [step.componentOptions && step.componentOptions.propsData.label ? _c('span', {
            staticClass: "wizard-step-label",
            domProps: {
              "innerHTML": _vm._s(step.componentOptions.propsData.label)
            }
          }) : step.componentOptions && step.componentOptions.propsData.title ? _c('span', {
            staticClass: "wizard-step-label",
            domProps: {
              "innerHTML": _vm._s(step.componentOptions.propsData.title)
            }
          }) : _vm._e()]);
        }));
      },
      staticRenderFns: [],
      name: 'wizard-progress',
      props: {
        /**
         * The index or key of the active step.
         *
         * @type {String|Number}
         */
        active: {
          type: [String, Number],
          default: 0
        },

        /**
         * The wizard highest available to the user.
         *
         * @type {Array}
         */
        highestStep: {
          type: Number,
          required: true
        },

        /**
         * The wizard steps
         *
         * @type {Array}
         */
        steps: {
          type: Array,
          required: true
        }
      },
      methods: {
        onClick: function onClick(event, step) {
          if (!event.target.classList.contains('disabled')) {
            this.$emit('click', event, step);
          }
        }
      },
      data: function data() {
        return {
          isActive: false
        };
      }
    };

    var WizardSuccess = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "wizard-success"
        }, [_vm.icon ? _c('div', {
          staticClass: "wizard-success-icon"
        }, [_c('i', {
          class: _vm.icon
        })]) : _vm._e(), _vm._v(" "), _vm.title ? _c('h3', {
          staticClass: "wizard-success-title",
          domProps: {
            "innerHTML": _vm._s(_vm.title)
          }
        }) : _vm._e(), _vm._v(" "), _vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'wizard-success',
      extends: WizardStep,
      props: {
        icon: {
          type: String,
          default: 'fa fa-check'
        },
        title: {
          type: String,
          default: 'Success!'
        }
      }
    };

    var Wizard = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "wizard"
        }, [_vm.header && !_vm.isFinished ? _c('wizard-header', {
          ref: "header",
          domProps: {
            "innerHTML": _vm._s(_vm.header)
          }
        }) : _vm._e(), _vm._v(" "), !_vm.isFinished ? _c('wizard-progress', {
          ref: "progress",
          attrs: {
            "active": _vm.currentStep,
            "highest-step": _vm.highestStep,
            "steps": _vm.steps
          },
          on: {
            "click": _vm.onProgressClick
          }
        }) : _vm._e(), _vm._v(" "), _c('div', {
          ref: "content",
          staticClass: "wizard-content"
        }, [!_vm.isFinished ? _vm._t("content") : _vm._e(), _vm._v(" "), !_vm.isFinished ? _c('slide-deck', {
          ref: "slideDeck",
          attrs: {
            "active": _vm.currentStep,
            "resize-model": _vm.resizeMode
          },
          on: {
            "before-enter": _vm.onBeforeEnter,
            "enter": _vm.onEnter,
            "leave": _vm.onLeave
          }
        }, [_vm._t("default")], 2) : _vm.isFinished && !_vm.hasFailed ? _vm._t("success", [_c('wizard-success', {
          ref: "success"
        })]) : _vm.isFinished && _vm.hasFailed ? _vm._t("error", [_c('wizard-error', {
          ref: "error",
          attrs: {
            "errors": _vm.errors
          },
          on: {
            "back": _vm.onClickTest
          }
        })]) : _vm._e()], 2), _vm._v(" "), !_vm.isFinished ? _vm._t("buttons", [_c('hr'), _vm._v(" "), _c('wizard-buttons', {
          ref: "buttons",
          attrs: {
            "size": "lg",
            "steps": _vm.steps,
            "active": _vm.currentStep,
            "activity": _vm.activity,
            "back-button": !_vm.isBackButtonDisabled,
            "next-button": !_vm.isNextButtonDisabled,
            "finish-button": !_vm.isFinishButtonDisabled
          },
          on: {
            "click:back": _vm.onClickBack,
            "click:finish": _vm.onClickFinish,
            "click:next": _vm.onClickNext
          }
        })]) : _vm._e()], 2);
      },
      staticRenderFns: [],
      name: 'wizard',
      components: {
        SlideDeck: SlideDeck,
        WizardButtons: WizardButtons,
        WizardError: WizardError,
        WizardHeader: WizardHeader,
        WizardProgress: WizardProgress,
        WizardSuccess: WizardSuccess
      },
      props: {
        /**
         * The index or key of the active step.
         *
         * @type {String|Number}
         */
        active: {
          type: [String, Number],
          default: 0
        },

        /**
         * The the index or key of the max completed step.
         *
         * @type {String|Number}
         */
        completed: [String, Number],

        /**
         * Show the activity indicator in the next or finish button.
         *
         * @type {Boolean}
         */
        activity: Boolean,

        /**
         * Show should the "Back" button.
         *
         * @type {Boolean}
         */
        backButton: {
          type: [Function, Boolean],
          default: function _default() {
            return this.currentStep > 0;
          }
        },

        /**
         * Show should the "Finish" button.
         *
         * @type {Boolean}
         */
        finishButton: {
          type: Boolean,
          default: true
        },

        /**
         * Pass a header as a string.
         *
         * @type {String}
         */
        header: String,

        /**
         * Show should the "Next" button.
         *
         * @type {Boolean}
         */
        nextButton: {
          type: Boolean,
          default: true
        },

        /**
         * The mode determines how the popover content will flex based on the
         * varying heights of the slides.
         *
         * @type Boolean
         */
        resizeMode: {
          type: [Function, Boolean, String],
          default: 'auto',
          validate: function validate(value) {
            return ['auto', 'initial', 'inherit'].indexOf(value) !== 1;
          }
        },

        /**
         * Validate if the data input for the step is valid. Required Boolean
         * or a predicate function.
         *
         * @type {Function|Boolean}
         */
        validate: {
          type: [Function, Boolean],
          default: function _default() {
            return true;
          }
        }
      },
      watch: {
        active: function active() {
          this.currentStep = this.index();
        }
      },
      methods: {
        back: function back() {
          this.$emit('update:step', this.currentStep = Math.max(this.currentStep - 1, 0));
        },
        disableButtons: function disableButtons() {
          this.isBackButtonDisabled = true;
          this.isFinishButtonDisabled = true;
          this.isNextButtonDisabled = true;
        },
        disableBackButton: function disableBackButton() {
          this.isBackButtonDisabled = true;
        },
        disableFinishButton: function disableFinishButton() {
          this.isFinishButtonDisabled = true;
        },
        disableNextButton: function disableNextButton() {
          this.isNextButtonDisabled = true;
        },
        emitBubbleEvent: function emitBubbleEvent(key) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }

          this.$refs.slideDeck.slide(this.currentStep).componentInstance.$emit.apply(this.$refs.slideDeck.slide(this.currentStep).componentInstance, args = [key].concat(args));
          this.$emit.apply(this, args);
        },
        enableButtons: function enableButtons() {
          this.isBackButtonDisabled = false;
          this.isFinishButtonDisabled = false;
          this.isNextButtonDisabled = false;
        },
        enableBackButton: function enableBackButton() {
          this.isBackButtonDisabled = false;
        },
        enableFinishButton: function enableFinishButton() {
          this.isFinishButtonDisabled = false;
        },
        enableNextButton: function enableNextButton() {
          this.isNextButtonDisabled = false;
        },
        finish: function finish(status) {
          var errors = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          this.errors = errors;
          this.hasFailed = status === false;
          this.isFinished = true;
        },
        index: function index() {
          var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
          return Math.max(0, this.$slots.default.indexOf(find$1(this.$slots.default, ['key', key || this.active]) || this.$slots.default[key || this.active]));
        },
        next: function next() {
          this.$emit('update:step', this.currentStep = Math.min(this.currentStep + 1, this.$refs.slideDeck.slides().length - 1));
        },
        onBeforeEnter: function onBeforeEnter(slide, prev) {
          slide.context.$emit('before-enter', slide, prev);
          this.$emit('before-enter', slide, prev);
        },
        onClickTest: function onClickTest(event) {
          this.isFinished = false;
        },
        onClickBack: function onClickBack(event) {
          this.emitBubbleEvent('back', event);

          if (event.defaultPrevented !== true) {
            this.back();
          }
        },
        onClickFinish: function onClickFinish(event) {
          this.emitBubbleEvent('finish', event);

          if (event.defaultPrevented !== true) {
            this.finish(true);
          }
        },
        onClickNext: function onClickNext(event) {
          this.emitBubbleEvent('next', event);

          if (event.defaultPrevented !== true) {
            this.next();
          }
        },
        onEnter: function onEnter(slide, prev) {
          this.highestStep = Math.max(this.highestStep, this.$refs.slideDeck.$refs.slides.getSlideIndex(slide));
          slide.componentInstance.$refs.wizard = this;
          slide.context.$emit('enter', slide, prev);
          this.$emit('enter', slide, prev);
        },
        onLeave: function onLeave(slide, prev) {
          slide.context.$emit('leave', slide, prev);
          this.$emit('leave', slide, prev);
        },
        onProgressClick: function onProgressClick(event, slide) {
          if (this.$refs.slideDeck) {
            this.currentStep = this.$refs.slideDeck.$refs.slides.getSlideIndex(slide);
          } else {
            this.isFinished = false;
            this.currentStep = this.index(slide.key);
          }
        }
      },
      mounted: function mounted() {
        var slide = this.$refs.slideDeck.slide(this.currentStep);

        if (slide) {
          (slide.componentInstance || slide.context).$refs.wizard = this;
          (slide.componentInstance || slide.context).$emit('enter');
          this.$emit('enter', slide);
        }

        this.steps = this.$refs.slideDeck.slides();
      },
      data: function data() {
        return {
          steps: [],
          errors: null,
          hasFailed: false,
          isFinished: false,
          currentStep: this.index(),
          highestStep: this.index(this.completed),
          isBackButtonDisabled: this.backButton === false,
          isNextButtonDisabled: this.nextButton === false,
          isFinishButtonDisabled: this.finishButton === false
        };
      }
    };

    var plugin$41 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          Wizard: Wizard,
          WizardButtons: WizardButtons,
          WizardHeader: WizardHeader,
          WizardProgress: WizardProgress,
          WizardStep: WizardStep,
          WizardSuccess: WizardSuccess,
          WizardError: WizardError
        });
      }
    });



    var components$1 = /*#__PURE__*/Object.freeze({
        ActivityIndicator: ActivityIndicator,
        Alert: Alert,
        AlertClose: AlertClose,
        AlertHeading: AlertHeading,
        AlertLink: AlertLink,
        Badge: Badge,
        BaseForm: BaseForm,
        Breadcrumb: Breadcrumb,
        BreadcrumbItem: BreadcrumbItem,
        Btn: Btn,
        BtnActivity: BtnActivity,
        BtnFile: BtnFile,
        BtnGroup: BtnGroup,
        BtnGroupToggle: BtnGroupToggle,
        BtnToolbar: BtnToolbar,
        BtnDropdown: BtnDropdown,
        Card: Card,
        CardBody: CardBody,
        CardBtnGroup: CardBtnGroup,
        CardDeck: CardDeck,
        CardFooter: CardFooter,
        CardHeader: CardHeader,
        CardImg: CardImg,
        CardImgTop: CardImgTop,
        CardImgBottom: CardImgBottom,
        CardImgOverlay: CardImgOverlay,
        CardLink: CardLink,
        CardSubtitle: CardSubtitle,
        CardTitle: CardTitle,
        CheckboxField: CheckboxField,
        Container: Container,
        DropdownMenu: DropdownMenu,
        DropdownMenuItem: DropdownMenuItem,
        DropdownMenuHeader: DropdownMenuHeader,
        DropdownMenuDivider: DropdownMenuDivider,
        Dropzone: Dropzone,
        FileField: FileField,
        FilePreview: FilePreview,
        FormControl: FormControl$1,
        FormFeedback: FormFeedback,
        FormGroup: FormGroup,
        FormLabel: FormLabel,
        HelpText: HelpText,
        InfiniteScrolling: InfiniteScrolling,
        InputField: InputField,
        InputGroup: InputGroup,
        InputGroupAppend: InputGroupAppend,
        InputGroupPrepend: InputGroupPrepend,
        InputGroupText: InputGroupText,
        LightSwitchField: LightSwitchField,
        ListGroup: ListGroup,
        ListGroupItem: ListGroupItem,
        Navbar: Navbar,
        NavbarBrand: NavbarBrand,
        NavbarCollapse: NavbarCollapse,
        NavbarNav: NavbarNav,
        NavbarText: NavbarText,
        NavbarToggler: NavbarToggler,
        NavbarTogglerIcon: NavbarTogglerIcon,
        Modal: Modal,
        ModalBackdrop: ModalBackdrop,
        ModalBody: ModalBody,
        ModalContent: ModalContent,
        ModalDialog: ModalDialog,
        ModalFooter: ModalFooter,
        ModalHeader: ModalHeader,
        ModalTitle: ModalTitle,
        Navigation: Navigation,
        NavigationError: NavigationError,
        NavigationItem: NavigationItem,
        NavigationLink: NavigationLink,
        NavigationDropdown: NavigationDropdown,
        Overlay: Overlay,
        Pagination: Pagination,
        Popover: Popover,
        PopoverBody: PopoverBody,
        PopoverHeader: PopoverHeader,
        ProgressBar: ProgressBar,
        RadioField: RadioField,
        SelectField: SelectField,
        SlideDeck: SlideDeck,
        Slides: Slides,
        TableView: TableView,
        TextareaField: TextareaField,
        ThumbnailList: ThumbnailList,
        ThumbnailListItem: ThumbnailListItem,
        UploadField: UploadField,
        Wizard: Wizard,
        WizardButtons: WizardButtons,
        WizardHeader: WizardHeader,
        WizardProgress: WizardProgress,
        WizardStep: WizardStep,
        WizardSuccess: WizardSuccess
    });

    var STYLE_ATTRIBUTES = ['font', 'fontFamily', 'fontKerning', 'fontSize', 'fontStretch', 'fontStyle', 'fontVariant', 'fontVariantLigatures', 'fontVariantCaps', 'fontVariantNumeric', 'fontVariantEastAsian', 'fontWeight', 'lineHeight', 'letterSpacing', 'padding', 'margin', 'textAlign', 'textAlignLast', 'textDecoration', 'textDecorationLine', 'textDecorationStyle', 'textDecorationColor', 'textDecorationSkipInk', 'textDecorationPosition', 'textIndent', 'textRendering', 'textShadow', 'textSizeAdjust', 'textOverflow', 'textTransform', 'width', 'wordBreak', 'wordSpacing', 'wordWrap'];

    function int(str) {
      if (typeof str === "number") {
        return str;
      } else if (!str || !str.replace) {
        return 0;
      }

      return parseInt(str.replace(/[^\d.]+/g, ''));
    }

    function input(div, el) {
      div.innerHTML = el.value.replace(/(?:\r\n|\r|\n)/g, '<br />');
    }

    function height(el) {
      return int(el.getBoundingClientRect().height);
    }

    function style(el, attr) {
      return window.getComputedStyle(el)[attr];
    }

    function resize(target, div, minHeight, maxHeight) {
      var dynamicHeight = Math.max(height(div) + int(style(div, 'lineHeight')), minHeight);
      target.style.height = (!maxHeight || dynamicHeight < maxHeight ? dynamicHeight : maxHeight) + 'px';
    }

    function mimic(el) {
      var div = document.createElement('div');
      var styles = window.getComputedStyle(el);

      for (var i in STYLE_ATTRIBUTES) {
        var key = STYLE_ATTRIBUTES[i];
        div.style[key] = styles[key];
      }

      div.style.position = 'absolute';
      div.style.bottom = '100%';
      div.style.zIndex = -1;
      div.style.visibility = 'hidden';
      return div;
    }

    function init(el, maxHeight) {
      var div = mimic(el);
      var minHeight = height(el);
      el.addEventListener('input', function (event) {
        input(div, event.target);
        resize(el, div, minHeight, maxHeight);
      });
      document.body.appendChild(div);
      input(div, el);
      resize(el, div, minHeight, maxHeight);
    }

    var Autogrow = {
      inserted: function inserted(el, binding, vnode) {
        if (el.tagName.toLowerCase() !== 'textarea') {
          el = el.querySelector('textarea');
        }

        if (!el) {
          throw new Error('A textarea is required for the v-autogrow directive.');
        }

        init(el, binding.value);
      }
    };

    function show(el, target, vnode) {
      target.classList.remove('collapse');
      target.classList.add('show');
      target.$collapsedHeight = getComputedStyle(target).height;
      target.classList.add('collapsing');
      vnode.context.$nextTick(function () {
        target.style.height = target.$collapsedHeight;
      });
      transition(target).then(function (delay) {
        target.style.height = null;
        target.classList.add('collapse');
        target.classList.remove('collapsing');
        el.classList.remove('collapsed');
      });
    }

    function hide$1(el, target, vnode) {
      target.style.height = target.$collapsedHeight;
      target.classList.add('collapsing');
      target.classList.remove('collapse');
      vnode.context.$nextTick(function () {
        target.style.height = 0;
      });
      transition(target).then(function (delay) {
        target.style.height = null;
        target.classList.add('collapse');
        target.classList.remove('show', 'collapsing');
        el.classList.add('collapsed');
      });
    }

    var Collapse = {
      inserted: function inserted(el, binding, vnode) {
        if (isUndefined(binding.value) || binding.value === true) {
          el.classList.add('collapsed');
          el.setAttribute('data-toggle', 'collapse');
          var target = el.getAttribute('data-target') || el.getAttribute('href');
          var elements = document.querySelectorAll(target);
          el.addEventListener('click', function (event) {
            elements.forEach(function (element) {
              if (!element.classList.contains('show')) {
                show(el, element, vnode);
              } else {
                hide$1(el, element, vnode);
              }
            });
            event.preventDefault();
          });
          elements.forEach(function (element) {
            /*
            if(!element.$collapsedHeight) {
                element.$collapsedHeight = getComputedStyle(element).height;
            }
            */
            if (!element.classList.contains('collapse')) {
              element.classList.add('collapse');
            }
          });
        }
      }
    };

    var Slug = {
      inserted: function inserted(el, binding, vnode) {
        var input = el.querySelector('input, textarea') || el;

        var value = get(vnode.context, binding.expression);

        var editable = !input.value;

        var update = function update(value) {
          if (editable) {
            input.value = kebabCase(value);
            input.dispatchEvent(new Event('input'));
          }
        };

        vnode.context.$watch(binding.expression, update);
        input.addEventListener('keyup', function (event) {
          input.value = kebabCase(event.target.value) + (event.target.value.match(/\s$/) ? ' ' : '');
        });
        input.addEventListener('input', function (event) {
          if (event instanceof InputEvent) {
            editable = !event.target.value;
          }
        });
        input.addEventListener('blur', function (event) {
          input.value = kebabCase(event.target.value || binding.expression.split('.').reduce(function (o, i) {
            return o[i];
          }, vnode.context));
          input.dispatchEvent(new Event('input'));
        });
        !input.value && update(value);
      }
    };



    var directives$1 = /*#__PURE__*/Object.freeze({
        Autogrow: Autogrow,
        Collapse: Collapse,
        Slug: Slug
    });

    function blob(url, progress) {
      return new Promise(function (resolve, reject) {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, true);
        xhr.responseType = 'blob';

        if (isFunction(progress)) {
          xhr.onprogress = function (e) {
            return progress(e, xhr);
          };
        }

        xhr.onerror = function (e) {
          return reject(e);
        };

        xhr.onabort = function (e) {
          return reject(e);
        };

        xhr.onload = function (e) {
          if (this.status === 200) {
            resolve(this.response);
          } else {
            reject(e);
          }
        };

        xhr.send();
      });
    }

    /** Used to compose bitmasks for function metadata. */
    var WRAP_PARTIAL_FLAG$4 = 32;

    /**
     * Creates a function that invokes `func` with `partials` prepended to the
     * arguments it receives. This method is like `_.bind` except it does **not**
     * alter the `this` binding.
     *
     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 0.2.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var sayHelloTo = _.partial(greet, 'hello');
     * sayHelloTo('fred');
     * // => 'hello fred'
     *
     * // Partially applied with placeholders.
     * var greetFred = _.partial(greet, _, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     */
    var partial = baseRest(function(func, partials) {
      var holders = replaceHolders(partials, getHolder(partial));
      return createWrap(func, WRAP_PARTIAL_FLAG$4, undefined, partials, holders);
    });

    // Assign default placeholders.
    partial.placeholder = {};

    /**
     * Creates a function that provides `value` to `wrapper` as its first
     * argument. Any additional arguments provided to the function are appended
     * to those provided to the `wrapper`. The wrapper is invoked with the `this`
     * binding of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {*} value The value to wrap.
     * @param {Function} [wrapper=identity] The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('fred, barney, & pebbles');
     * // => '<p>fred, barney, &amp; pebbles</p>'
     */
    function wrap(value, wrapper) {
      return partial(castFunction(wrapper), value);
    }

    function elapsed(milliseconds, callback, elapsedCallback) {
      var hasElapsed = false;

      function start() {
        return setTimeout(function () {
          hasElapsed = true;

          if (isFunction$1(elapsedCallback)) {
            elapsedCallback();
          }
        }, milliseconds);
      }

      function stop() {
        clearTimeout(interval);
      }

      var interval = start(),
          promise = new Promise(function (resolve, reject) {
        function resolver(resolver, response) {
          return resolver(response || hasElapsed);
        }
        callback(wrap(resolve, resolver), wrap(reject, resolver));
      });
      return promise.finally(stop, stop);
    }

    var easings = {
      linear: function linear(t) {
        return t;
      },
      easeInQuad: function easeInQuad(t) {
        return t * t;
      },
      easeOutQuad: function easeOutQuad(t) {
        return t * (2 - t);
      },
      easeInOutQuad: function easeInOutQuad(t) {
        return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
      },
      easeInCubic: function easeInCubic(t) {
        return t * t * t;
      },
      easeOutCubic: function easeOutCubic(t) {
        return --t * t * t + 1;
      },
      easeInOutCubic: function easeInOutCubic(t) {
        return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
      },
      easeInQuart: function easeInQuart(t) {
        return t * t * t * t;
      },
      easeOutQuart: function easeOutQuart(t) {
        return 1 - --t * t * t * t;
      },
      easeInOutQuart: function easeInOutQuart(t) {
        return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;
      },
      easeInQuint: function easeInQuint(t) {
        return t * t * t * t * t;
      },
      easeOutQuint: function easeOutQuint(t) {
        return 1 + --t * t * t * t * t;
      },
      easeInOutQuint: function easeInOutQuint(t) {
        return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;
      }
    };
    function scrollTo(destination) {
      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;
      var easing = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'easeInQuad';
      var viewport = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

      if (!viewport) {
        viewport = document.querySelector('body');
      }

      var viewportBounds = viewport.getBoundingClientRect();
      var destinationBounds = destination.getBoundingClientRect();
      var destinationOffsetToScroll = Math.ceil(destinationBounds.top + document.documentElement.scrollTop);

      function isScrollBottom() {
        return document.documentElement.scrollTop >= Math.floor(viewportBounds.height) - window.innerHeight;
      }

      return new Promise(function (resolve, reject) {
        var startTime = performance.now();
        var isStartingBottom = isScrollBottom();

        function scroll() {
          var start = document.documentElement.scrollTop;
          var time = Math.min(1, (performance.now() - startTime) / duration);
          var timeFunction = easings[easing](time);
          window.scroll(0, Math.ceil(timeFunction * (destinationOffsetToScroll - start) + start));

          if (document.documentElement.scrollTop === destinationOffsetToScroll || isScrollBottom() && !isStartingBottom) {
            resolve();
            return;
          }

          requestAnimationFrame(scroll);
        }

        scroll();
      });
    }

    /**
     * The base implementation of methods like `_.findKey` and `_.findLastKey`,
     * without support for iteratee shorthands, which iterates over `collection`
     * using `eachFunc`.
     *
     * @private
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} predicate The function invoked per iteration.
     * @param {Function} eachFunc The function to iterate over `collection`.
     * @returns {*} Returns the found element or its key, else `undefined`.
     */
    function baseFindKey(collection, predicate, eachFunc) {
      var result;
      eachFunc(collection, function(value, key, collection) {
        if (predicate(value, key, collection)) {
          result = key;
          return false;
        }
      });
      return result;
    }

    /**
     * This method is like `_.find` except that it returns the key of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findKey(users, function(o) { return o.age < 40; });
     * // => 'barney' (iteration order is not guaranteed)
     *
     * // The `_.matches` iteratee shorthand.
     * _.findKey(users, { 'age': 1, 'active': true });
     * // => 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findKey(users, 'active');
     * // => 'barney'
     */
    function findKey(object, predicate) {
      return baseFindKey(object, baseIteratee(predicate, 3), baseForOwn);
    }

    var CALLBACKS = {};

    function id(callback) {
      return findKey(CALLBACKS, function (compare) {
        return callback.toString() == compare.toString();
      });
    }

    function restart(callback, milliseconds) {
      stop(id(callback));
      start(callback, milliseconds);
    }

    function stop(id) {
      clearTimeout(id);
      delete CALLBACKS[id];
    }

    function start(callback, milliseconds) {
      return CALLBACKS[setTimeout(callback, milliseconds)] = callback;
    }

    function wait(milliseconds, callback) {
      return new Promise(function (resolve, reject) {
        function resolver(resolver, response) {
          return resolver(response);
        }
        restart(wrap(callback, function (callback) {
          return callback(wrap(resolve, resolver), wrap(reject, resolver));
        }), milliseconds);
      });
      return promise.finally(stop, stop);
    }
    /*
    import { wrap } from 'lodash-es';
    import { isFunction } from 'lodash-es';

    export default function elapsed(delay, callback, elapsedCallback) {
        let hasElapsed = false;

        function start() {
            return setInterval(() => {
                hasElapsed = true;

                if(isFunction(elapsedCallback)) {
                    elapsedCallback();
                }
            }, delay)
        }

        function stop() {
            clearInterval(interval);
        }

        const interval = start(), promise = new Promise((resolve, reject) => {
            function resolver(resolver, response) {
                return resolver(response || hasElapsed);
            };

            callback(wrap(resolve, resolver), wrap(reject, resolver));
        });

        return promise.finally(stop, stop);
    }

     */

    var main = VueInstaller.use({
      install: function install(Vue) {
        VueInstaller.plugins(Vue, plugins$1);
        VueInstaller.filters(Vue, filters);
        VueInstaller.directives(Vue, directives$1);
        VueInstaller.components(Vue, components$1);
      }
    });

    exports.default = main;
    exports.Model = Model;
    exports.Request = Request;
    exports.RequestOptions = RequestOptions;
    exports.transformRequest = transformRequest;
    exports.transformResponse = transformResponse;
    exports.Colorable = Colorable;
    exports.FormControlMixin = FormControl;
    exports.HasSlots = HasSlots;
    exports.MergeClasses = MergeClasses;
    exports.Proxy = Proxy;
    exports.Screenreaders = Screenreaders;
    exports.Sizeable = Sizeable;
    exports.Triggerable = Triggerable;
    exports.Variant = Variant;
    exports.blob = blob;
    exports.elapsed = elapsed;
    exports.instantiate = instantiate;
    exports.prefix = prefix;
    exports.readFile = readFile;
    exports.script = script;
    exports.scrollTo = scrollTo;
    exports.transition = transition;
    exports.unit = unit;
    exports.uuid = uuid;
    exports.wait = wait;
    exports.modal = modal$1;
    exports.overlay = overlay;
    exports.popover = popover;
    exports.ActivityIndicator = ActivityIndicator;
    exports.Alert = Alert;
    exports.AlertClose = AlertClose;
    exports.AlertHeading = AlertHeading;
    exports.AlertLink = AlertLink;
    exports.Badge = Badge;
    exports.BaseForm = BaseForm;
    exports.Breadcrumb = Breadcrumb;
    exports.BreadcrumbItem = BreadcrumbItem;
    exports.Btn = Btn;
    exports.BtnActivity = BtnActivity;
    exports.BtnFile = BtnFile;
    exports.BtnGroup = BtnGroup;
    exports.BtnGroupToggle = BtnGroupToggle;
    exports.BtnToolbar = BtnToolbar;
    exports.BtnDropdown = BtnDropdown;
    exports.Card = Card;
    exports.CardBody = CardBody;
    exports.CardBtnGroup = CardBtnGroup;
    exports.CardDeck = CardDeck;
    exports.CardFooter = CardFooter;
    exports.CardHeader = CardHeader;
    exports.CardImg = CardImg;
    exports.CardImgTop = CardImgTop;
    exports.CardImgBottom = CardImgBottom;
    exports.CardImgOverlay = CardImgOverlay;
    exports.CardLink = CardLink;
    exports.CardSubtitle = CardSubtitle;
    exports.CardTitle = CardTitle;
    exports.CheckboxField = CheckboxField;
    exports.Container = Container;
    exports.DropdownMenu = DropdownMenu;
    exports.DropdownMenuItem = DropdownMenuItem;
    exports.DropdownMenuHeader = DropdownMenuHeader;
    exports.DropdownMenuDivider = DropdownMenuDivider;
    exports.Dropzone = Dropzone;
    exports.FileField = FileField;
    exports.FilePreview = FilePreview;
    exports.FormControl = FormControl$1;
    exports.FormFeedback = FormFeedback;
    exports.FormGroup = FormGroup;
    exports.FormLabel = FormLabel;
    exports.HelpText = HelpText;
    exports.InfiniteScrolling = InfiniteScrolling;
    exports.InputField = InputField;
    exports.InputGroup = InputGroup;
    exports.InputGroupAppend = InputGroupAppend;
    exports.InputGroupPrepend = InputGroupPrepend;
    exports.InputGroupText = InputGroupText;
    exports.LightSwitchField = LightSwitchField;
    exports.ListGroup = ListGroup;
    exports.ListGroupItem = ListGroupItem;
    exports.Navbar = Navbar;
    exports.NavbarBrand = NavbarBrand;
    exports.NavbarCollapse = NavbarCollapse;
    exports.NavbarNav = NavbarNav;
    exports.NavbarText = NavbarText;
    exports.NavbarToggler = NavbarToggler;
    exports.NavbarTogglerIcon = NavbarTogglerIcon;
    exports.Modal = Modal;
    exports.ModalBackdrop = ModalBackdrop;
    exports.ModalBody = ModalBody;
    exports.ModalContent = ModalContent;
    exports.ModalDialog = ModalDialog;
    exports.ModalFooter = ModalFooter;
    exports.ModalHeader = ModalHeader;
    exports.ModalTitle = ModalTitle;
    exports.Navigation = Navigation;
    exports.NavigationError = NavigationError;
    exports.NavigationItem = NavigationItem;
    exports.NavigationLink = NavigationLink;
    exports.NavigationDropdown = NavigationDropdown;
    exports.Overlay = Overlay;
    exports.Pagination = Pagination;
    exports.Popover = Popover;
    exports.PopoverBody = PopoverBody;
    exports.PopoverHeader = PopoverHeader;
    exports.ProgressBar = ProgressBar;
    exports.RadioField = RadioField;
    exports.SelectField = SelectField;
    exports.SlideDeck = SlideDeck;
    exports.Slides = Slides;
    exports.TableView = TableView;
    exports.TextareaField = TextareaField;
    exports.ThumbnailList = ThumbnailList;
    exports.ThumbnailListItem = ThumbnailListItem;
    exports.UploadField = UploadField;
    exports.Wizard = Wizard;
    exports.WizardButtons = WizardButtons;
    exports.WizardHeader = WizardHeader;
    exports.WizardProgress = WizardProgress;
    exports.WizardStep = WizardStep;
    exports.WizardSuccess = WizardSuccess;
    exports.Autogrow = Autogrow;
    exports.Collapse = Collapse;
    exports.Slug = Slug;
    exports.DateFilter = index;
    exports.MomentFilter = index;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidnVlLWludGVyZmFjZS5qcyIsInNvdXJjZXMiOlsiLi4vc3JjL0ZpbHRlcnMvRGF0ZS9EYXRlRmlsdGVyLmpzIiwiLi4vc3JjL0ZpbHRlcnMvRGF0ZS9Nb21lbnRGaWx0ZXIuanMiLCIuLi9zcmMvRmlsdGVycy9EYXRlL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXBwbHkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lkZW50aXR5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fb3ZlclJlc3QuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2NvbnN0YW50LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3JvbGx1cC1wbHVnaW4tbm9kZS1nbG9iYWxzL3NyYy9nbG9iYWwuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19mcmVlR2xvYmFsLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fcm9vdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX1N5bWJvbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldFJhd1RhZy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX29iamVjdFRvU3RyaW5nLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUdldFRhZy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNPYmplY3QuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzRnVuY3Rpb24uanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jb3JlSnNEYXRhLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNNYXNrZWQuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL190b1NvdXJjZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VJc05hdGl2ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldFZhbHVlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0TmF0aXZlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZGVmaW5lUHJvcGVydHkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlU2V0VG9TdHJpbmcuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zaG9ydE91dC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3NldFRvU3RyaW5nLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVJlc3QuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19saXN0Q2FjaGVDbGVhci5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvZXEuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hc3NvY0luZGV4T2YuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19saXN0Q2FjaGVEZWxldGUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19saXN0Q2FjaGVHZXQuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19saXN0Q2FjaGVIYXMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19saXN0Q2FjaGVTZXQuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19MaXN0Q2FjaGUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zdGFja0NsZWFyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc3RhY2tEZWxldGUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zdGFja0dldC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3N0YWNrSGFzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fTWFwLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbmF0aXZlQ3JlYXRlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faGFzaENsZWFyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faGFzaERlbGV0ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2hhc2hHZXQuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19oYXNoSGFzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faGFzaFNldC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX0hhc2guanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19tYXBDYWNoZUNsZWFyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNLZXlhYmxlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0TWFwRGF0YS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcENhY2hlRGVsZXRlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbWFwQ2FjaGVHZXQuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19tYXBDYWNoZUhhcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcENhY2hlU2V0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fTWFwQ2FjaGUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zdGFja1NldC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX1N0YWNrLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUFzc2lnblZhbHVlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXNzaWduTWVyZ2VWYWx1ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NyZWF0ZUJhc2VGb3IuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlRm9yLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY2xvbmVCdWZmZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19VaW50OEFycmF5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY2xvbmVBcnJheUJ1ZmZlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Nsb25lVHlwZWRBcnJheS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NvcHlBcnJheS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VDcmVhdGUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19vdmVyQXJnLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0UHJvdG90eXBlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNQcm90b3R5cGUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pbml0Q2xvbmVPYmplY3QuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzT2JqZWN0TGlrZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VJc0FyZ3VtZW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNBcmd1bWVudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQXJyYXkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzTGVuZ3RoLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0FycmF5TGlrZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNBcnJheUxpa2VPYmplY3QuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3N0dWJGYWxzZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNCdWZmZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzUGxhaW5PYmplY3QuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXNUeXBlZEFycmF5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVVuYXJ5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbm9kZVV0aWwuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzVHlwZWRBcnJheS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3NhZmVHZXQuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hc3NpZ25WYWx1ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NvcHlPYmplY3QuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlVGltZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc0luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXJyYXlMaWtlS2V5cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX25hdGl2ZUtleXNJbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VLZXlzSW4uanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2tleXNJbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdG9QbGFpbk9iamVjdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VNZXJnZURlZXAuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlTWVyZ2UuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jdXN0b21EZWZhdWx0c01lcmdlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNJdGVyYXRlZUNhbGwuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jcmVhdGVBc3NpZ25lci5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvbWVyZ2VXaXRoLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9kZWZhdWx0c0RlZXAuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzVW5kZWZpbmVkLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0Jvb2xlYW4uanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19uYXRpdmVLZXlzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUtleXMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2tleXMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlRm9yT3duLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc2V0Q2FjaGVBZGQuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zZXRDYWNoZUhhcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX1NldENhY2hlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXJyYXlTb21lLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY2FjaGVIYXMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19lcXVhbEFycmF5cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcFRvQXJyYXkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zZXRUb0FycmF5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZXF1YWxCeVRhZy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FycmF5UHVzaC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VHZXRBbGxLZXlzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXJyYXlGaWx0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3N0dWJBcnJheS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldFN5bWJvbHMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRBbGxLZXlzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZXF1YWxPYmplY3RzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fRGF0YVZpZXcuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19Qcm9taXNlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fU2V0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fV2Vha01hcC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldFRhZy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VJc0VxdWFsRGVlcC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VJc0VxdWFsLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzTWF0Y2guanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc1N0cmljdENvbXBhcmFibGUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRNYXRjaERhdGEuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19tYXRjaGVzU3RyaWN0Q29tcGFyYWJsZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VNYXRjaGVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc1N5bWJvbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2lzS2V5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9tZW1vaXplLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbWVtb2l6ZUNhcHBlZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3N0cmluZ1RvUGF0aC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FycmF5TWFwLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVRvU3RyaW5nLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy90b1N0cmluZy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Nhc3RQYXRoLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fdG9LZXkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlR2V0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9nZXQuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSGFzSW4uanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19oYXNQYXRoLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9oYXNJbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VNYXRjaGVzUHJvcGVydHkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlUHJvcGVydHkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlUHJvcGVydHlEZWVwLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9wcm9wZXJ0eS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VJdGVyYXRlZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvbWFwS2V5cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNOdWxsLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY3JlYXRlQmFzZUVhY2guanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlRWFjaC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VGaWx0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2ZpbHRlci5qcyIsIi4uL3NyYy9IZWxwZXJzL1ByZWZpeC9QcmVmaXguanMiLCIuLi9zcmMvTWl4aW5zL1ZhcmlhbnQvVmFyaWFudC5qcyIsIi4uL3NyYy9NaXhpbnMvU2l6ZWFibGUvU2l6ZWFibGUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlU2xpY2UuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jYXN0U2xpY2UuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19oYXNVbmljb2RlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXNjaWlUb0FycmF5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fdW5pY29kZVRvQXJyYXkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zdHJpbmdUb0FycmF5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY3JlYXRlQ2FzZUZpcnN0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy91cHBlckZpcnN0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9jYXBpdGFsaXplLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXJyYXlSZWR1Y2UuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlUHJvcGVydHlPZi5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2RlYnVyckxldHRlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvZGVidXJyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXNjaWlXb3Jkcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2hhc1VuaWNvZGVXb3JkLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fdW5pY29kZVdvcmRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy93b3Jkcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NyZWF0ZUNvbXBvdW5kZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2NhbWVsQ2FzZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvbmVnYXRlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVNldC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VQaWNrQnkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRTeW1ib2xzSW4uanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRBbGxLZXlzSW4uanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3BpY2tCeS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvb21pdEJ5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXJyYXlFYWNoLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY2FzdEZ1bmN0aW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9mb3JFYWNoLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZU1hcC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvbWFwLmpzIiwiLi4vc3JjL01peGlucy9Db2xvcmFibGUvQ29sb3JhYmxlLmpzIiwiLi4vc3JjL0hlbHBlcnMvVHJhbnNpdGlvbi9UcmFuc2l0aW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9hc3NpZ25Jbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvbWVyZ2UuanMiLCIuLi9zcmMvTWl4aW5zL01lcmdlQ2xhc3Nlcy9NZXJnZUNsYXNzZXMuanMiLCIuLi9zcmMvQ29tcG9uZW50cy9CdG4vQnRuLnZ1ZSIsIi4uL3NyYy9IZWxwZXJzL1NjcmlwdC9TY3JpcHQuanMiLCIuLi9zcmMvSGVscGVycy9WdWVJbnN0YWxsZXIvVnVlSW5zdGFsbGVyLmpzIiwiLi4vc3JjL0NvbXBvbmVudHMvQnRuL2luZGV4LmpzIiwiLi4vc3JjL0NvbXBvbmVudHMvTW9kYWwvTW9kYWxCb2R5LnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL01vZGFsL01vZGFsRGlhbG9nLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL01vZGFsL01vZGFsVGl0bGUudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvTW9kYWwvTW9kYWxIZWFkZXIudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvTW9kYWwvTW9kYWxGb290ZXIudnVlIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9rZWJhYkNhc2UuanMiLCIuLi9zcmMvQ29tcG9uZW50cy9BY3Rpdml0eUluZGljYXRvci9UeXBlcy9CYXNlVHlwZS52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9BY3Rpdml0eUluZGljYXRvci9UeXBlcy9Eb3RzLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL0FjdGl2aXR5SW5kaWNhdG9yL1R5cGVzL1NwaW5uZXIudnVlIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0Zpbml0ZS5qcyIsIi4uL3NyYy9IZWxwZXJzL1VuaXQvVW5pdC5qcyIsIi4uL3NyYy9Db21wb25lbnRzL0FjdGl2aXR5SW5kaWNhdG9yL0FjdGl2aXR5SW5kaWNhdG9yLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL0FjdGl2aXR5SW5kaWNhdG9yL2luZGV4LmpzIiwiLi4vc3JjL0NvbXBvbmVudHMvQnRuQWN0aXZpdHkvQnRuQWN0aXZpdHkudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvQnRuQWN0aXZpdHkvaW5kZXguanMiLCIuLi9zcmMvQ29tcG9uZW50cy9Nb2RhbC9Nb2RhbENvbnRlbnQudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvTW9kYWwvTW9kYWxCYWNrZHJvcC52dWUiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzU3RyaW5nLmpzIiwiLi4vc3JjL01peGlucy9UcmlnZ2VyYWJsZS9UcmlnZ2VyYWJsZS5qcyIsIi4uL3NyYy9Db21wb25lbnRzL01vZGFsL01vZGFsLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL01vZGFsL2luZGV4LmpzIiwiLi4vc3JjL0hlbHBlcnMvSW5zdGFudGlhdGUvSW5zdGFudGlhdGUuanMiLCIuLi9zcmMvUGx1Z2lucy9Nb2RhbC9Nb2RhbC5qcyIsIi4uL3NyYy9Db21wb25lbnRzL092ZXJsYXkvT3ZlcmxheUJvZHkudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvQ29udGFpbmVyL0NvbnRhaW5lci52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9Db250YWluZXIvaW5kZXguanMiLCIuLi9zcmMvQ29tcG9uZW50cy9PdmVybGF5L092ZXJsYXlDb250ZW50LnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL092ZXJsYXkvT3ZlcmxheS52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9PdmVybGF5L2luZGV4LmpzIiwiLi4vc3JjL1BsdWdpbnMvT3ZlcmxheS9PdmVybGF5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3BvcHBlci5qcy9kaXN0L2VzbS9wb3BwZXIuanMiLCIuLi9zcmMvQ29tcG9uZW50cy9Qb3BvdmVyL1BvcG92ZXIudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvUG9wb3Zlci9Qb3BvdmVyQm9keS52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9Qb3BvdmVyL1BvcG92ZXJIZWFkZXIudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvUG9wb3Zlci9pbmRleC5qcyIsIi4uL3NyYy9QbHVnaW5zL1BvcG92ZXIvUG9wb3Zlci5qcyIsIi4uL3NyYy9Db21wb25lbnRzL0FsZXJ0L0FsZXJ0Q2xvc2UudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvQWxlcnQvQWxlcnRIZWFkaW5nLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL1Byb2dyZXNzQmFyL1Byb2dyZXNzQmFyLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL1Byb2dyZXNzQmFyL2luZGV4LmpzIiwiLi4vc3JjL0NvbXBvbmVudHMvQWxlcnQvQWxlcnQudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvQWxlcnQvQWxlcnRMaW5rLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL0FsZXJ0L2luZGV4LmpzIiwiLi4vc3JjL0NvbXBvbmVudHMvQmFkZ2UvQmFkZ2UudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvQmFkZ2UvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlUmVkdWNlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9yZWR1Y2UuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hc2NpaVNpemUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL191bmljb2RlU2l6ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3N0cmluZ1NpemUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3NpemUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlQXNzaWduLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUFzc2lnbkluLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY29weVN5bWJvbHMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jb3B5U3ltYm9sc0luLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faW5pdENsb25lQXJyYXkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jbG9uZURhdGFWaWV3LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY2xvbmVSZWdFeHAuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jbG9uZVN5bWJvbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2luaXRDbG9uZUJ5VGFnLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzTWFwLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc01hcC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VJc1NldC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNTZXQuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlQ2xvbmUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2Nsb25lRGVlcC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaGVhZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21ldGFNYXAuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlU2V0RGF0YS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NyZWF0ZUN0b3IuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jcmVhdGVCaW5kLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY29tcG9zZUFyZ3MuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jb21wb3NlQXJnc1JpZ2h0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY291bnRIb2xkZXJzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUxvZGFzaC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX0xhenlXcmFwcGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9ub29wLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0RGF0YS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3JlYWxOYW1lcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldEZ1bmNOYW1lLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fTG9kYXNoV3JhcHBlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3dyYXBwZXJDbG9uZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvd3JhcHBlckxvZGFzaC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2lzTGF6aWFibGUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zZXREYXRhLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0V3JhcERldGFpbHMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pbnNlcnRXcmFwRGV0YWlscy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VGaW5kSW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXNOYU4uanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zdHJpY3RJbmRleE9mLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUluZGV4T2YuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheUluY2x1ZGVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fdXBkYXRlV3JhcERldGFpbHMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zZXRXcmFwVG9TdHJpbmcuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jcmVhdGVSZWN1cnJ5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0SG9sZGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fcmVvcmRlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3JlcGxhY2VIb2xkZXJzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY3JlYXRlSHlicmlkLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY3JlYXRlQ3VycnkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jcmVhdGVQYXJ0aWFsLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbWVyZ2VEYXRhLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy90b051bWJlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdG9GaW5pdGUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3RvSW50ZWdlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NyZWF0ZVdyYXAuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2JpbmQuanMiLCIuLi9zcmMvSHR0cC9SZXF1ZXN0L1JlcXVlc3RPcHRpb25zLmpzIiwiLi4vc3JjL0h0dHAvUmVxdWVzdC9UcmFuc2Zvcm1SZXF1ZXN0LmpzIiwiLi4vc3JjL0h0dHAvUmVxdWVzdC9UcmFuc2Zvcm1SZXNwb25zZS5qcyIsIi4uL3NyYy9IdHRwL1JlcXVlc3QvUmVxdWVzdC5qcyIsIi4uL3NyYy9IdHRwL01vZGVsL01vZGVsLmpzIiwiLi4vc3JjL0NvbXBvbmVudHMvQmFzZUZvcm0vQmFzZUZvcm0udnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvQmFzZUZvcm0vaW5kZXguanMiLCIuLi9zcmMvQ29tcG9uZW50cy9CcmVhZGNydW1iL0JyZWFkY3J1bWJJdGVtLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL0JyZWFkY3J1bWIvQnJlYWRjcnVtYi52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9CcmVhZGNydW1iL2luZGV4LmpzIiwiLi4vc3JjL01peGlucy9TY3JlZW5yZWFkZXJzL1NjcmVlbnJlYWRlcnMuanMiLCIuLi9zcmMvQ29tcG9uZW50cy9IZWxwVGV4dC9IZWxwVGV4dC52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9IZWxwVGV4dC9pbmRleC5qcyIsIi4uL3NyYy9Db21wb25lbnRzL0Zvcm1Hcm91cC9Gb3JtR3JvdXAudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvRm9ybUdyb3VwL2luZGV4LmpzIiwiLi4vc3JjL0NvbXBvbmVudHMvRm9ybUxhYmVsL0Zvcm1MYWJlbC52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9Gb3JtTGFiZWwvaW5kZXguanMiLCIuLi9zcmMvQ29tcG9uZW50cy9Gb3JtRmVlZGJhY2svRm9ybUZlZWRiYWNrLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL0Zvcm1GZWVkYmFjay9pbmRleC5qcyIsIi4uL3NyYy9NaXhpbnMvRm9ybUNvbnRyb2wvRm9ybUNvbnRyb2wuanMiLCIuLi9zcmMvQ29tcG9uZW50cy9JbnB1dEZpZWxkL0lucHV0RmllbGQudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvSW5wdXRGaWVsZC9pbmRleC5qcyIsIi4uL3NyYy9Db21wb25lbnRzL0ZpbGVGaWVsZC9GaWxlRmllbGQudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvRmlsZUZpZWxkL2luZGV4LmpzIiwiLi4vc3JjL0NvbXBvbmVudHMvQnRuRmlsZS9CdG5GaWxlLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL0J0bkZpbGUvaW5kZXguanMiLCIuLi9zcmMvQ29tcG9uZW50cy9CdG5Hcm91cC9CdG5Hcm91cC52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9CdG5Hcm91cC9CdG5Hcm91cFRvZ2dsZS52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9CdG5Hcm91cC9CdG5Ub29sYmFyLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL0J0bkdyb3VwL2luZGV4LmpzIiwiLi4vc3JjL0hlbHBlcnMvVXVpZC9VdWlkLmpzIiwiLi4vc3JjL01peGlucy9Qcm94eS9Qcm94eS5qcyIsIi4uL3NyYy9Db21wb25lbnRzL0Ryb3Bkb3duTWVudS9Ecm9wZG93bk1lbnVJdGVtLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL0Ryb3Bkb3duTWVudS9Ecm9wZG93bk1lbnVIZWFkZXIudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvRHJvcGRvd25NZW51L0Ryb3Bkb3duTWVudURpdmlkZXIudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvRHJvcGRvd25NZW51L0Ryb3Bkb3duTWVudS52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9Ecm9wZG93bk1lbnUvaW5kZXguanMiLCIuLi9zcmMvQ29tcG9uZW50cy9CdG5Ecm9wZG93bi9CdG5Ecm9wZG93bi52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9CdG5Ecm9wZG93bi9pbmRleC5qcyIsIi4uL3NyYy9NaXhpbnMvSGFzU2xvdHMvSGFzU2xvdHMuanMiLCIuLi9zcmMvQ29tcG9uZW50cy9DYXJkL0NhcmQudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvQ2FyZC9DYXJkQm9keS52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9DYXJkL0NhcmRCdG5Hcm91cC52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9DYXJkL0NhcmREZWNrLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL0NhcmQvQ2FyZEhlYWRlci52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9DYXJkL0NhcmRGb290ZXIudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvQ2FyZC9DYXJkSW1nLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL0NhcmQvQ2FyZEltZ1RvcC52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9DYXJkL0NhcmRJbWdCb3R0b20udnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvQ2FyZC9DYXJkSW1nT3ZlcmxheS52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9DYXJkL0NhcmRMaW5rLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL0NhcmQvQ2FyZFN1YnRpdGxlLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL0NhcmQvQ2FyZFRpdGxlLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL0NhcmQvaW5kZXguanMiLCIuLi9zcmMvQ29tcG9uZW50cy9SYWRpb0ZpZWxkL1JhZGlvRmllbGQudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvUmFkaW9GaWVsZC9pbmRleC5qcyIsIi4uL3NyYy9Db21wb25lbnRzL0NoZWNrYm94RmllbGQvQ2hlY2tib3hGaWVsZC52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9DaGVja2JveEZpZWxkL2luZGV4LmpzIiwiLi4vc3JjL0NvbXBvbmVudHMvRHJvcHpvbmUvRHJvcHpvbmUudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvRHJvcHpvbmUvaW5kZXguanMiLCIuLi9zcmMvSGVscGVycy9SZWFkRmlsZS9SZWFkRmlsZS5qcyIsIi4uL3NyYy9Db21wb25lbnRzL0ZpbGVQcmV2aWV3L0ZpbGVQcmV2aWV3LnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL0ZpbGVQcmV2aWV3L2luZGV4LmpzIiwiLi4vc3JjL0NvbXBvbmVudHMvRm9ybUNvbnRyb2wvRm9ybUNvbnRyb2wudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvRm9ybUNvbnRyb2wvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvaW50ZXJzZWN0aW9uLW9ic2VydmVyL2ludGVyc2VjdGlvbi1vYnNlcnZlci5qcyIsIi4uL3NyYy9Db21wb25lbnRzL0luZmluaXRlU2Nyb2xsaW5nL0luZmluaXRlU2Nyb2xsaW5nLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL0lucHV0R3JvdXAvSW5wdXRHcm91cFRleHQudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvSW5wdXRHcm91cC9JbnB1dEdyb3VwQXBwZW5kLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL0lucHV0R3JvdXAvSW5wdXRHcm91cFByZXBlbmQudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvSW5wdXRHcm91cC9JbnB1dEdyb3VwLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL0lucHV0R3JvdXAvaW5kZXguanMiLCIuLi9zcmMvQ29tcG9uZW50cy9MaWdodFN3aXRjaEZpZWxkL0xpZ2h0U3dpdGNoRmllbGQudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvTGlnaHRTd2l0Y2hGaWVsZC9pbmRleC5qcyIsIi4uL3NyYy9Db21wb25lbnRzL0xpc3RHcm91cC9MaXN0R3JvdXBJdGVtLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL0xpc3RHcm91cC9MaXN0R3JvdXAudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvTGlzdEdyb3VwL2luZGV4LmpzIiwiLi4vc3JjL0NvbXBvbmVudHMvTmF2YmFyL05hdmJhckJyYW5kLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL05hdmJhci9OYXZiYXJDb2xsYXBzZS52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9OYXZiYXIvTmF2YmFyVGV4dC52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9OYXZiYXIvTmF2YmFyVG9nZ2xlckljb24udnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvTmF2YmFyL05hdmJhclRvZ2dsZXIudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvTmF2YmFyL05hdmJhci52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9OYXZpZ2F0aW9uL05hdmlnYXRpb25FcnJvci52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9OYXZpZ2F0aW9uL05hdmlnYXRpb25MaW5rLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL05hdmlnYXRpb24vTmF2aWdhdGlvbkl0ZW0udnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvTmF2aWdhdGlvbi9OYXZpZ2F0aW9uLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL05hdmlnYXRpb24vTmF2aWdhdGlvbkRyb3Bkb3duLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL05hdmlnYXRpb24vaW5kZXguanMiLCIuLi9zcmMvQ29tcG9uZW50cy9OYXZiYXIvTmF2YmFyTmF2LnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL05hdmJhci9pbmRleC5qcyIsIi4uL3NyYy9Db21wb25lbnRzL1BhZ2luYXRpb24vUGFnaW5hdGlvbi52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9QYWdpbmF0aW9uL2luZGV4LmpzIiwiLi4vc3JjL0NvbXBvbmVudHMvU2VsZWN0RmllbGQvU2VsZWN0RmllbGQudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvU2VsZWN0RmllbGQvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2ZpbmRJbmRleC5qcyIsIi4uL3NyYy9Db21wb25lbnRzL1NsaWRlRGVjay9TbGlkZXMudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvU2xpZGVEZWNrL1NsaWRlRGVja0NvbnRyb2xzLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL1NsaWRlRGVjay9TbGlkZURlY2sudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvU2xpZGVEZWNrL2luZGV4LmpzIiwiLi4vc3JjL0NvbXBvbmVudHMvVGFibGVWaWV3L1RhYmxlVmlld0hlYWRlci52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9UYWJsZVZpZXcvVGFibGUudnVlIiwiLi4vc3JjL0h0dHAvVHJhbnNmb3JtZXIvVHJhbnNmb3JtZXIuanMiLCIuLi9zcmMvSHR0cC9UYWJsZVZpZXdUcmFuc2Zvcm1lci9UYWJsZVZpZXdUcmFuc2Zvcm1lci5qcyIsIi4uL3NyYy9Db21wb25lbnRzL1RhYmxlVmlldy9UYWJsZVZpZXcudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvVGFibGVWaWV3L2luZGV4LmpzIiwiLi4vc3JjL0NvbXBvbmVudHMvVGV4dGFyZWFGaWVsZC9UZXh0YXJlYUZpZWxkLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL1RleHRhcmVhRmllbGQvaW5kZXguanMiLCIuLi9zcmMvQ29tcG9uZW50cy9UaHVtYm5haWxMaXN0L1RodW1ibmFpbExpc3RJdGVtLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL1RodW1ibmFpbExpc3QvVGh1bWJuYWlsTGlzdC52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9UaHVtYm5haWxMaXN0L2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9sYXN0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fcGFyZW50LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVVuc2V0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVB1bGxBdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvcmVtb3ZlLmpzIiwiLi4vc3JjL0NvbXBvbmVudHMvVXBsb2FkRmllbGQvVXBsb2FkRmllbGQudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvVXBsb2FkRmllbGQvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jcmVhdGVGaW5kLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9maW5kLmpzIiwiLi4vc3JjL0NvbXBvbmVudHMvV2l6YXJkL1dpemFyZEJ1dHRvbnMudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvV2l6YXJkL1dpemFyZFN0ZXAudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvV2l6YXJkL1dpemFyZEVycm9yLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL1dpemFyZC9XaXphcmRIZWFkZXIudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvV2l6YXJkL1dpemFyZFByb2dyZXNzLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL1dpemFyZC9XaXphcmRTdWNjZXNzLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL1dpemFyZC9XaXphcmQudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvV2l6YXJkL2luZGV4LmpzIiwiLi4vc3JjL0RpcmVjdGl2ZXMvQXV0b2dyb3cvQXV0b2dyb3cuanMiLCIuLi9zcmMvRGlyZWN0aXZlcy9Db2xsYXBzZS9Db2xsYXBzZS5qcyIsIi4uL3NyYy9EaXJlY3RpdmVzL1NsdWcvU2x1Zy5qcyIsIi4uL3NyYy9IZWxwZXJzL0Jsb2IvQmxvYi5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvcGFydGlhbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvd3JhcC5qcyIsIi4uL3NyYy9IZWxwZXJzL0VsYXBzZWQvRWxhcHNlZC5qcyIsIi4uL3NyYy9IZWxwZXJzL1Njcm9sbFRvL1Njcm9sbFRvLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUZpbmRLZXkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2ZpbmRLZXkuanMiLCIuLi9zcmMvSGVscGVycy9XYWl0L1dhaXQuanMiLCIuLi9zcmMvbWFpbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbW9tZW50IGZyb20gJ21vbWVudCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlLCBmb3JtYXQpIHtcbiAgICBpZih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbW9tZW50KFN0cmluZyh2YWx1ZSkpLmZvcm1hdChmb3JtYXQpO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbn1cbiIsImltcG9ydCBtb21lbnQgZnJvbSAnbW9tZW50JztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWUsIGZvcm1hdCkge1xuICAgIHJldHVybiB2YWx1ZSA/IG1vbWVudChTdHJpbmcodmFsdWUpKSA6IG51bGw7XG59XG4iLCJpbXBvcnQgRGF0ZUZpbHRlciBmcm9tICcuL0RhdGVGaWx0ZXInO1xuaW1wb3J0IE1vbWVudEZpbHRlciBmcm9tICcuL01vbWVudEZpbHRlcic7XG5cbmV4cG9ydCB7XG4gICAgRGF0ZUZpbHRlcixcbiAgICBNb21lbnRGaWx0ZXJcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKFZ1ZSwgb3B0aW9ucykge1xuICAgIFZ1ZS5maWx0ZXIoJ2RhdGUnLCBEYXRlRmlsdGVyKTtcbiAgICBWdWUuZmlsdGVyKCdtb21lbnQnLCBNb21lbnRGaWx0ZXIpO1xufTtcbiIsIi8qKlxuICogQSBmYXN0ZXIgYWx0ZXJuYXRpdmUgdG8gYEZ1bmN0aW9uI2FwcGx5YCwgdGhpcyBmdW5jdGlvbiBpbnZva2VzIGBmdW5jYFxuICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgIGFuZCB0aGUgYXJndW1lbnRzIG9mIGBhcmdzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5KGZ1bmMsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnKTtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgfVxuICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXBwbHk7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IGl0IHJlY2VpdmVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICpcbiAqIGNvbnNvbGUubG9nKF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpZGVudGl0eTtcbiIsImltcG9ydCBhcHBseSBmcm9tICcuL19hcHBseS5qcyc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VSZXN0YCB3aGljaCB0cmFuc2Zvcm1zIHRoZSByZXN0IGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSByZXN0IGFycmF5IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyUmVzdChmdW5jLCBzdGFydCwgdHJhbnNmb3JtKSB7XG4gIHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0ID09PSB1bmRlZmluZWQgPyAoZnVuYy5sZW5ndGggLSAxKSA6IHN0YXJ0LCAwKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBzdGFydCwgMCksXG4gICAgICAgIGFycmF5ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBhcnJheVtpbmRleF0gPSBhcmdzW3N0YXJ0ICsgaW5kZXhdO1xuICAgIH1cbiAgICBpbmRleCA9IC0xO1xuICAgIHZhciBvdGhlckFyZ3MgPSBBcnJheShzdGFydCArIDEpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgc3RhcnQpIHtcbiAgICAgIG90aGVyQXJnc1tpbmRleF0gPSBhcmdzW2luZGV4XTtcbiAgICB9XG4gICAgb3RoZXJBcmdzW3N0YXJ0XSA9IHRyYW5zZm9ybShhcnJheSk7XG4gICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIG90aGVyQXJncyk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IG92ZXJSZXN0O1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB2YWx1ZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBmcm9tIHRoZSBuZXcgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb25zdGFudCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBfLnRpbWVzKDIsIF8uY29uc3RhbnQoeyAnYSc6IDEgfSkpO1xuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHMpO1xuICogLy8gPT4gW3sgJ2EnOiAxIH0sIHsgJ2EnOiAxIH1dXG4gKlxuICogY29uc29sZS5sb2cob2JqZWN0c1swXSA9PT0gb2JqZWN0c1sxXSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGNvbnN0YW50KHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNvbnN0YW50O1xuIiwiZXhwb3J0IGRlZmF1bHQgdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6XG4gICAgICAgICAgICB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOlxuICAgICAgICAgICAgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9XG4iLCIvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG5leHBvcnQgZGVmYXVsdCBmcmVlR2xvYmFsO1xuIiwiaW1wb3J0IGZyZWVHbG9iYWwgZnJvbSAnLi9fZnJlZUdsb2JhbC5qcyc7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuZXhwb3J0IGRlZmF1bHQgcm9vdDtcbiIsImltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxuZXhwb3J0IGRlZmF1bHQgU3ltYm9sO1xuIiwiaW1wb3J0IFN5bWJvbCBmcm9tICcuL19TeW1ib2wuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSxcbiAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuICB0cnkge1xuICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHVubWFza2VkKSB7XG4gICAgaWYgKGlzT3duKSB7XG4gICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldFJhd1RhZztcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBvYmplY3RUb1N0cmluZztcbiIsImltcG9ydCBTeW1ib2wgZnJvbSAnLi9fU3ltYm9sLmpzJztcbmltcG9ydCBnZXRSYXdUYWcgZnJvbSAnLi9fZ2V0UmF3VGFnLmpzJztcbmltcG9ydCBvYmplY3RUb1N0cmluZyBmcm9tICcuL19vYmplY3RUb1N0cmluZy5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gIH1cbiAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgID8gZ2V0UmF3VGFnKHZhbHVlKVxuICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlR2V0VGFnO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzT2JqZWN0O1xuIiwiaW1wb3J0IGJhc2VHZXRUYWcgZnJvbSAnLi9fYmFzZUdldFRhZy5qcyc7XG5pbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdC5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIHByb3h5VGFnID0gJ1tvYmplY3QgUHJveHldJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzRnVuY3Rpb247XG4iLCJpbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxuZXhwb3J0IGRlZmF1bHQgY29yZUpzRGF0YTtcbiIsImltcG9ydCBjb3JlSnNEYXRhIGZyb20gJy4vX2NvcmVKc0RhdGEuanMnO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xudmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbn0oKSk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc01hc2tlZDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovXG5mdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuZXhwb3J0IGRlZmF1bHQgdG9Tb3VyY2U7XG4iLCJpbXBvcnQgaXNGdW5jdGlvbiBmcm9tICcuL2lzRnVuY3Rpb24uanMnO1xuaW1wb3J0IGlzTWFza2VkIGZyb20gJy4vX2lzTWFza2VkLmpzJztcbmltcG9ydCBpc09iamVjdCBmcm9tICcuL2lzT2JqZWN0LmpzJztcbmltcG9ydCB0b1NvdXJjZSBmcm9tICcuL190b1NvdXJjZS5qcyc7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hdGl2ZWAgd2l0aG91dCBiYWQgc2hpbSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gaXNGdW5jdGlvbih2YWx1ZSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICByZXR1cm4gcGF0dGVybi50ZXN0KHRvU291cmNlKHZhbHVlKSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VJc05hdGl2ZTtcbiIsIi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXRWYWx1ZTtcbiIsImltcG9ydCBiYXNlSXNOYXRpdmUgZnJvbSAnLi9fYmFzZUlzTmF0aXZlLmpzJztcbmltcG9ydCBnZXRWYWx1ZSBmcm9tICcuL19nZXRWYWx1ZS5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldE5hdGl2ZTtcbiIsImltcG9ydCBnZXROYXRpdmUgZnJvbSAnLi9fZ2V0TmF0aXZlLmpzJztcblxudmFyIGRlZmluZVByb3BlcnR5ID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHZhciBmdW5jID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2RlZmluZVByb3BlcnR5Jyk7XG4gICAgZnVuYyh7fSwgJycsIHt9KTtcbiAgICByZXR1cm4gZnVuYztcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbmV4cG9ydCBkZWZhdWx0IGRlZmluZVByb3BlcnR5O1xuIiwiaW1wb3J0IGNvbnN0YW50IGZyb20gJy4vY29uc3RhbnQuanMnO1xuaW1wb3J0IGRlZmluZVByb3BlcnR5IGZyb20gJy4vX2RlZmluZVByb3BlcnR5LmpzJztcbmltcG9ydCBpZGVudGl0eSBmcm9tICcuL2lkZW50aXR5LmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgc2V0VG9TdHJpbmdgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaG90IGxvb3Agc2hvcnRpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovXG52YXIgYmFzZVNldFRvU3RyaW5nID0gIWRlZmluZVByb3BlcnR5ID8gaWRlbnRpdHkgOiBmdW5jdGlvbihmdW5jLCBzdHJpbmcpIHtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5KGZ1bmMsICd0b1N0cmluZycsIHtcbiAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAnZW51bWVyYWJsZSc6IGZhbHNlLFxuICAgICd2YWx1ZSc6IGNvbnN0YW50KHN0cmluZyksXG4gICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICB9KTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VTZXRUb1N0cmluZztcbiIsIi8qKiBVc2VkIHRvIGRldGVjdCBob3QgZnVuY3Rpb25zIGJ5IG51bWJlciBvZiBjYWxscyB3aXRoaW4gYSBzcGFuIG9mIG1pbGxpc2Vjb25kcy4gKi9cbnZhciBIT1RfQ09VTlQgPSA4MDAsXG4gICAgSE9UX1NQQU4gPSAxNjtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU5vdyA9IERhdGUubm93O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0J2xsIHNob3J0IG91dCBhbmQgaW52b2tlIGBpZGVudGl0eWAgaW5zdGVhZFxuICogb2YgYGZ1bmNgIHdoZW4gaXQncyBjYWxsZWQgYEhPVF9DT1VOVGAgb3IgbW9yZSB0aW1lcyBpbiBgSE9UX1NQQU5gXG4gKiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc2hvcnRhYmxlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBzaG9ydE91dChmdW5jKSB7XG4gIHZhciBjb3VudCA9IDAsXG4gICAgICBsYXN0Q2FsbGVkID0gMDtcblxuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YW1wID0gbmF0aXZlTm93KCksXG4gICAgICAgIHJlbWFpbmluZyA9IEhPVF9TUEFOIC0gKHN0YW1wIC0gbGFzdENhbGxlZCk7XG5cbiAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgaWYgKHJlbWFpbmluZyA+IDApIHtcbiAgICAgIGlmICgrK2NvdW50ID49IEhPVF9DT1VOVCkge1xuICAgICAgICByZXR1cm4gYXJndW1lbnRzWzBdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb3VudCA9IDA7XG4gICAgfVxuICAgIHJldHVybiBmdW5jLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc2hvcnRPdXQ7XG4iLCJpbXBvcnQgYmFzZVNldFRvU3RyaW5nIGZyb20gJy4vX2Jhc2VTZXRUb1N0cmluZy5qcyc7XG5pbXBvcnQgc2hvcnRPdXQgZnJvbSAnLi9fc2hvcnRPdXQuanMnO1xuXG4vKipcbiAqIFNldHMgdGhlIGB0b1N0cmluZ2AgbWV0aG9kIG9mIGBmdW5jYCB0byByZXR1cm4gYHN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovXG52YXIgc2V0VG9TdHJpbmcgPSBzaG9ydE91dChiYXNlU2V0VG9TdHJpbmcpO1xuXG5leHBvcnQgZGVmYXVsdCBzZXRUb1N0cmluZztcbiIsImltcG9ydCBpZGVudGl0eSBmcm9tICcuL2lkZW50aXR5LmpzJztcbmltcG9ydCBvdmVyUmVzdCBmcm9tICcuL19vdmVyUmVzdC5qcyc7XG5pbXBvcnQgc2V0VG9TdHJpbmcgZnJvbSAnLi9fc2V0VG9TdHJpbmcuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlc3RgIHdoaWNoIGRvZXNuJ3QgdmFsaWRhdGUgb3IgY29lcmNlIGFyZ3VtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUmVzdChmdW5jLCBzdGFydCkge1xuICByZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYywgc3RhcnQsIGlkZW50aXR5KSwgZnVuYyArICcnKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVJlc3Q7XG4iLCIvKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gW107XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGxpc3RDYWNoZUNsZWFyO1xuIiwiLyoqXG4gKiBQZXJmb3JtcyBhXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoJ2EnLCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoTmFOLCBOYU4pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGVxO1xuIiwiaW1wb3J0IGVxIGZyb20gJy4vZXEuanMnO1xuXG4vKipcbiAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5leHBvcnQgZGVmYXVsdCBhc3NvY0luZGV4T2Y7XG4iLCJpbXBvcnQgYXNzb2NJbmRleE9mIGZyb20gJy4vX2Fzc29jSW5kZXhPZi5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZTtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgIGRhdGEucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICB9XG4gIC0tdGhpcy5zaXplO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbGlzdENhY2hlRGVsZXRlO1xuIiwiaW1wb3J0IGFzc29jSW5kZXhPZiBmcm9tICcuL19hc3NvY0luZGV4T2YuanMnO1xuXG4vKipcbiAqIEdldHMgdGhlIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xufVxuXG5leHBvcnQgZGVmYXVsdCBsaXN0Q2FjaGVHZXQ7XG4iLCJpbXBvcnQgYXNzb2NJbmRleE9mIGZyb20gJy4vX2Fzc29jSW5kZXhPZi5qcyc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xufVxuXG5leHBvcnQgZGVmYXVsdCBsaXN0Q2FjaGVIYXM7XG4iLCJpbXBvcnQgYXNzb2NJbmRleE9mIGZyb20gJy4vX2Fzc29jSW5kZXhPZi5qcyc7XG5cbi8qKlxuICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgKyt0aGlzLnNpemU7XG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuZXhwb3J0IGRlZmF1bHQgbGlzdENhY2hlU2V0O1xuIiwiaW1wb3J0IGxpc3RDYWNoZUNsZWFyIGZyb20gJy4vX2xpc3RDYWNoZUNsZWFyLmpzJztcbmltcG9ydCBsaXN0Q2FjaGVEZWxldGUgZnJvbSAnLi9fbGlzdENhY2hlRGVsZXRlLmpzJztcbmltcG9ydCBsaXN0Q2FjaGVHZXQgZnJvbSAnLi9fbGlzdENhY2hlR2V0LmpzJztcbmltcG9ydCBsaXN0Q2FjaGVIYXMgZnJvbSAnLi9fbGlzdENhY2hlSGFzLmpzJztcbmltcG9ydCBsaXN0Q2FjaGVTZXQgZnJvbSAnLi9fbGlzdENhY2hlU2V0LmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbkxpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbkxpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBsaXN0Q2FjaGVHZXQ7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbkxpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuXG5leHBvcnQgZGVmYXVsdCBMaXN0Q2FjaGU7XG4iLCJpbXBvcnQgTGlzdENhY2hlIGZyb20gJy4vX0xpc3RDYWNoZS5qcyc7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqL1xuZnVuY3Rpb24gc3RhY2tDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0YWNrQ2xlYXI7XG4iLCIvKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0RlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgcmVzdWx0ID0gZGF0YVsnZGVsZXRlJ10oa2V5KTtcblxuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0YWNrRGVsZXRlO1xuIiwiLyoqXG4gKiBHZXRzIHRoZSBzdGFjayB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tHZXQoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmdldChrZXkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzdGFja0dldDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGEgc3RhY2sgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0hhcyhrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGtleSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0YWNrSGFzO1xuIiwiaW1wb3J0IGdldE5hdGl2ZSBmcm9tICcuL19nZXROYXRpdmUuanMnO1xuaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpO1xuXG5leHBvcnQgZGVmYXVsdCBNYXA7XG4iLCJpbXBvcnQgZ2V0TmF0aXZlIGZyb20gJy4vX2dldE5hdGl2ZS5qcyc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbmV4cG9ydCBkZWZhdWx0IG5hdGl2ZUNyZWF0ZTtcbiIsImltcG9ydCBuYXRpdmVDcmVhdGUgZnJvbSAnLi9fbmF0aXZlQ3JlYXRlLmpzJztcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIEhhc2hcbiAqL1xuZnVuY3Rpb24gaGFzaENsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmF0aXZlQ3JlYXRlID8gbmF0aXZlQ3JlYXRlKG51bGwpIDoge307XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGhhc2hDbGVhcjtcbiIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGhhc2hEZWxldGU7XG4iLCJpbXBvcnQgbmF0aXZlQ3JlYXRlIGZyb20gJy4vX25hdGl2ZUNyZWF0ZS5qcyc7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaGFzaEdldDtcbiIsImltcG9ydCBuYXRpdmVDcmVhdGUgZnJvbSAnLi9fbmF0aXZlQ3JlYXRlLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHJldHVybiBuYXRpdmVDcmVhdGUgPyAoZGF0YVtrZXldICE9PSB1bmRlZmluZWQpIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBoYXNoSGFzO1xuIiwiaW1wb3J0IG5hdGl2ZUNyZWF0ZSBmcm9tICcuL19uYXRpdmVDcmVhdGUuanMnO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhrZXkpID8gMCA6IDE7XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxuZXhwb3J0IGRlZmF1bHQgaGFzaFNldDtcbiIsImltcG9ydCBoYXNoQ2xlYXIgZnJvbSAnLi9faGFzaENsZWFyLmpzJztcbmltcG9ydCBoYXNoRGVsZXRlIGZyb20gJy4vX2hhc2hEZWxldGUuanMnO1xuaW1wb3J0IGhhc2hHZXQgZnJvbSAnLi9faGFzaEdldC5qcyc7XG5pbXBvcnQgaGFzaEhhcyBmcm9tICcuL19oYXNoSGFzLmpzJztcbmltcG9ydCBoYXNoU2V0IGZyb20gJy4vX2hhc2hTZXQuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbkhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbkhhc2gucHJvdG90eXBlLmdldCA9IGhhc2hHZXQ7XG5IYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxuZXhwb3J0IGRlZmF1bHQgSGFzaDtcbiIsImltcG9ydCBIYXNoIGZyb20gJy4vX0hhc2guanMnO1xuaW1wb3J0IExpc3RDYWNoZSBmcm9tICcuL19MaXN0Q2FjaGUuanMnO1xuaW1wb3J0IE1hcCBmcm9tICcuL19NYXAuanMnO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuICB0aGlzLnNpemUgPSAwO1xuICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICdoYXNoJzogbmV3IEhhc2gsXG4gICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSksXG4gICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1hcENhY2hlQ2xlYXI7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nKVxuICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzS2V5YWJsZTtcbiIsImltcG9ydCBpc0tleWFibGUgZnJvbSAnLi9faXNLZXlhYmxlLmpzJztcblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICA6IGRhdGEubWFwO1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXRNYXBEYXRhO1xuIiwiaW1wb3J0IGdldE1hcERhdGEgZnJvbSAnLi9fZ2V0TWFwRGF0YS5qcyc7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBtYXBDYWNoZURlbGV0ZTtcbiIsImltcG9ydCBnZXRNYXBEYXRhIGZyb20gJy4vX2dldE1hcERhdGEuanMnO1xuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1hcENhY2hlR2V0O1xuIiwiaW1wb3J0IGdldE1hcERhdGEgZnJvbSAnLi9fZ2V0TWFwRGF0YS5qcyc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1hcENhY2hlSGFzO1xuIiwiaW1wb3J0IGdldE1hcERhdGEgZnJvbSAnLi9fZ2V0TWFwRGF0YS5qcyc7XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IGdldE1hcERhdGEodGhpcywga2V5KSxcbiAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSArPSBkYXRhLnNpemUgPT0gc2l6ZSA/IDAgOiAxO1xuICByZXR1cm4gdGhpcztcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWFwQ2FjaGVTZXQ7XG4iLCJpbXBvcnQgbWFwQ2FjaGVDbGVhciBmcm9tICcuL19tYXBDYWNoZUNsZWFyLmpzJztcbmltcG9ydCBtYXBDYWNoZURlbGV0ZSBmcm9tICcuL19tYXBDYWNoZURlbGV0ZS5qcyc7XG5pbXBvcnQgbWFwQ2FjaGVHZXQgZnJvbSAnLi9fbWFwQ2FjaGVHZXQuanMnO1xuaW1wb3J0IG1hcENhY2hlSGFzIGZyb20gJy4vX21hcENhY2hlSGFzLmpzJztcbmltcG9ydCBtYXBDYWNoZVNldCBmcm9tICcuL19tYXBDYWNoZVNldC5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5NYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuXG5leHBvcnQgZGVmYXVsdCBNYXBDYWNoZTtcbiIsImltcG9ydCBMaXN0Q2FjaGUgZnJvbSAnLi9fTGlzdENhY2hlLmpzJztcbmltcG9ydCBNYXAgZnJvbSAnLi9fTWFwLmpzJztcbmltcG9ydCBNYXBDYWNoZSBmcm9tICcuL19NYXBDYWNoZS5qcyc7XG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKlxuICogU2V0cyB0aGUgc3RhY2sgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgc3RhY2sgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAoZGF0YSBpbnN0YW5jZW9mIExpc3RDYWNoZSkge1xuICAgIHZhciBwYWlycyA9IGRhdGEuX19kYXRhX187XG4gICAgaWYgKCFNYXAgfHwgKHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSkge1xuICAgICAgcGFpcnMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgdGhpcy5zaXplID0gKytkYXRhLnNpemU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUocGFpcnMpO1xuICB9XG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiB0aGlzO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzdGFja1NldDtcbiIsImltcG9ydCBMaXN0Q2FjaGUgZnJvbSAnLi9fTGlzdENhY2hlLmpzJztcbmltcG9ydCBzdGFja0NsZWFyIGZyb20gJy4vX3N0YWNrQ2xlYXIuanMnO1xuaW1wb3J0IHN0YWNrRGVsZXRlIGZyb20gJy4vX3N0YWNrRGVsZXRlLmpzJztcbmltcG9ydCBzdGFja0dldCBmcm9tICcuL19zdGFja0dldC5qcyc7XG5pbXBvcnQgc3RhY2tIYXMgZnJvbSAnLi9fc3RhY2tIYXMuanMnO1xuaW1wb3J0IHN0YWNrU2V0IGZyb20gJy4vX3N0YWNrU2V0LmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RhY2sgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU3RhY2soZW50cmllcykge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlKGVudHJpZXMpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG5TdGFjay5wcm90b3R5cGUuY2xlYXIgPSBzdGFja0NsZWFyO1xuU3RhY2sucHJvdG90eXBlWydkZWxldGUnXSA9IHN0YWNrRGVsZXRlO1xuU3RhY2sucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0O1xuU3RhY2sucHJvdG90eXBlLmhhcyA9IHN0YWNrSGFzO1xuU3RhY2sucHJvdG90eXBlLnNldCA9IHN0YWNrU2V0O1xuXG5leHBvcnQgZGVmYXVsdCBTdGFjaztcbiIsImltcG9ydCBkZWZpbmVQcm9wZXJ0eSBmcm9tICcuL19kZWZpbmVQcm9wZXJ0eS5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGFzc2lnblZhbHVlYCBhbmQgYGFzc2lnbk1lcmdlVmFsdWVgIHdpdGhvdXRcbiAqIHZhbHVlIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgPT0gJ19fcHJvdG9fXycgJiYgZGVmaW5lUHJvcGVydHkpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIGtleSwge1xuICAgICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgICAnZW51bWVyYWJsZSc6IHRydWUsXG4gICAgICAndmFsdWUnOiB2YWx1ZSxcbiAgICAgICd3cml0YWJsZSc6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VBc3NpZ25WYWx1ZTtcbiIsImltcG9ydCBiYXNlQXNzaWduVmFsdWUgZnJvbSAnLi9fYmFzZUFzc2lnblZhbHVlLmpzJztcbmltcG9ydCBlcSBmcm9tICcuL2VxLmpzJztcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGFzc2lnblZhbHVlYCBleGNlcHQgdGhhdCBpdCBkb2Vzbid0IGFzc2lnblxuICogYHVuZGVmaW5lZGAgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIGlmICgodmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZXEob2JqZWN0W2tleV0sIHZhbHVlKSkgfHxcbiAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgYXNzaWduTWVyZ2VWYWx1ZTtcbiIsIi8qKlxuICogQ3JlYXRlcyBhIGJhc2UgZnVuY3Rpb24gZm9yIG1ldGhvZHMgbGlrZSBgXy5mb3JJbmAgYW5kIGBfLmZvck93bmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUZvcihmcm9tUmlnaHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUsIGtleXNGdW5jKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KG9iamVjdCksXG4gICAgICAgIHByb3BzID0ga2V5c0Z1bmMob2JqZWN0KSxcbiAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcHNbZnJvbVJpZ2h0ID8gbGVuZ3RoIDogKytpbmRleF07XG4gICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVCYXNlRm9yO1xuIiwiaW1wb3J0IGNyZWF0ZUJhc2VGb3IgZnJvbSAnLi9fY3JlYXRlQmFzZUZvci5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGJhc2VGb3JPd25gIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYG9iamVjdGBcbiAqIHByb3BlcnRpZXMgcmV0dXJuZWQgYnkgYGtleXNGdW5jYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LlxuICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG52YXIgYmFzZUZvciA9IGNyZWF0ZUJhc2VGb3IoKTtcblxuZXhwb3J0IGRlZmF1bHQgYmFzZUZvcjtcbiIsImltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICBhbGxvY1Vuc2FmZSA9IEJ1ZmZlciA/IEJ1ZmZlci5hbGxvY1Vuc2FmZSA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgIGBidWZmZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIFRoZSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge0J1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY2xvbmVCdWZmZXIoYnVmZmVyLCBpc0RlZXApIHtcbiAgaWYgKGlzRGVlcCkge1xuICAgIHJldHVybiBidWZmZXIuc2xpY2UoKTtcbiAgfVxuICB2YXIgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGFsbG9jVW5zYWZlID8gYWxsb2NVbnNhZmUobGVuZ3RoKSA6IG5ldyBidWZmZXIuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICBidWZmZXIuY29weShyZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbG9uZUJ1ZmZlcjtcbiIsImltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBVaW50OEFycmF5ID0gcm9vdC5VaW50OEFycmF5O1xuXG5leHBvcnQgZGVmYXVsdCBVaW50OEFycmF5O1xuIiwiaW1wb3J0IFVpbnQ4QXJyYXkgZnJvbSAnLi9fVWludDhBcnJheS5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBhcnJheUJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5QnVmZmVyIFRoZSBhcnJheSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBhcnJheSBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBhcnJheUJ1ZmZlci5jb25zdHJ1Y3RvcihhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgbmV3IFVpbnQ4QXJyYXkocmVzdWx0KS5zZXQobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xvbmVBcnJheUJ1ZmZlcjtcbiIsImltcG9ydCBjbG9uZUFycmF5QnVmZmVyIGZyb20gJy4vX2Nsb25lQXJyYXlCdWZmZXIuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgdHlwZWRBcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlZEFycmF5IFRoZSB0eXBlZCBhcnJheSB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgdHlwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNsb25lVHlwZWRBcnJheSh0eXBlZEFycmF5LCBpc0RlZXApIHtcbiAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIodHlwZWRBcnJheS5idWZmZXIpIDogdHlwZWRBcnJheS5idWZmZXI7XG4gIHJldHVybiBuZXcgdHlwZWRBcnJheS5jb25zdHJ1Y3RvcihidWZmZXIsIHR5cGVkQXJyYXkuYnl0ZU9mZnNldCwgdHlwZWRBcnJheS5sZW5ndGgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbG9uZVR5cGVkQXJyYXk7XG4iLCIvKipcbiAqIENvcGllcyB0aGUgdmFsdWVzIG9mIGBzb3VyY2VgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheT1bXV0gVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIHRvLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlBcnJheShzb3VyY2UsIGFycmF5KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcblxuICBhcnJheSB8fCAoYXJyYXkgPSBBcnJheShsZW5ndGgpKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtpbmRleF0gPSBzb3VyY2VbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY29weUFycmF5O1xuIiwiaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNyZWF0ZWAgd2l0aG91dCBzdXBwb3J0IGZvciBhc3NpZ25pbmdcbiAqIHByb3BlcnRpZXMgdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvdG8gVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICovXG52YXIgYmFzZUNyZWF0ZSA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gb2JqZWN0KCkge31cbiAgcmV0dXJuIGZ1bmN0aW9uKHByb3RvKSB7XG4gICAgaWYgKCFpc09iamVjdChwcm90bykpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgaWYgKG9iamVjdENyZWF0ZSkge1xuICAgICAgcmV0dXJuIG9iamVjdENyZWF0ZShwcm90byk7XG4gICAgfVxuICAgIG9iamVjdC5wcm90b3R5cGUgPSBwcm90bztcbiAgICB2YXIgcmVzdWx0ID0gbmV3IG9iamVjdDtcbiAgICBvYmplY3QucHJvdG90eXBlID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59KCkpO1xuXG5leHBvcnQgZGVmYXVsdCBiYXNlQ3JlYXRlO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IG92ZXJBcmc7XG4iLCJpbXBvcnQgb3ZlckFyZyBmcm9tICcuL19vdmVyQXJnLmpzJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgZ2V0UHJvdG90eXBlID0gb3ZlckFyZyhPYmplY3QuZ2V0UHJvdG90eXBlT2YsIE9iamVjdCk7XG5cbmV4cG9ydCBkZWZhdWx0IGdldFByb3RvdHlwZTtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNQcm90b3R5cGU7XG4iLCJpbXBvcnQgYmFzZUNyZWF0ZSBmcm9tICcuL19iYXNlQ3JlYXRlLmpzJztcbmltcG9ydCBnZXRQcm90b3R5cGUgZnJvbSAnLi9fZ2V0UHJvdG90eXBlLmpzJztcbmltcG9ydCBpc1Byb3RvdHlwZSBmcm9tICcuL19pc1Byb3RvdHlwZS5qcyc7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lT2JqZWN0KG9iamVjdCkge1xuICByZXR1cm4gKHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNQcm90b3R5cGUob2JqZWN0KSlcbiAgICA/IGJhc2VDcmVhdGUoZ2V0UHJvdG90eXBlKG9iamVjdCkpXG4gICAgOiB7fTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaW5pdENsb25lT2JqZWN0O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzT2JqZWN0TGlrZTtcbiIsImltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqL1xuZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VJc0FyZ3VtZW50cztcbiIsImltcG9ydCBiYXNlSXNBcmd1bWVudHMgZnJvbSAnLi9fYmFzZUlzQXJndW1lbnRzLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgaXNBcmd1bWVudHM7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuZXhwb3J0IGRlZmF1bHQgaXNBcnJheTtcbiIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNMZW5ndGg7XG4iLCJpbXBvcnQgaXNGdW5jdGlvbiBmcm9tICcuL2lzRnVuY3Rpb24uanMnO1xuaW1wb3J0IGlzTGVuZ3RoIGZyb20gJy4vaXNMZW5ndGguanMnO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNBcnJheUxpa2U7XG4iLCJpbXBvcnQgaXNBcnJheUxpa2UgZnJvbSAnLi9pc0FycmF5TGlrZS5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmlzQXJyYXlMaWtlYCBleGNlcHQgdGhhdCBpdCBhbHNvIGNoZWNrcyBpZiBgdmFsdWVgXG4gKiBpcyBhbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXktbGlrZSBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNBcnJheUxpa2UodmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0FycmF5TGlrZU9iamVjdDtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3R1YkZhbHNlO1xuIiwiaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5pbXBvcnQgc3R1YkZhbHNlIGZyb20gJy4vc3R1YkZhbHNlLmpzJztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlciA/IEJ1ZmZlci5pc0J1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlO1xuXG5leHBvcnQgZGVmYXVsdCBpc0J1ZmZlcjtcbiIsImltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IGdldFByb3RvdHlwZSBmcm9tICcuL19nZXRQcm90b3R5cGUuanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGluZmVyIHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3Rvci4gKi9cbnZhciBvYmplY3RDdG9yU3RyaW5nID0gZnVuY1RvU3RyaW5nLmNhbGwoT2JqZWN0KTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgdGhhdCBpcywgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlXG4gKiBgT2JqZWN0YCBjb25zdHJ1Y3RvciBvciBvbmUgd2l0aCBhIGBbW1Byb3RvdHlwZV1dYCBvZiBgbnVsbGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjguMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogfVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChuZXcgRm9vKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdCh7ICd4JzogMCwgJ3knOiAwIH0pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgfHwgYmFzZUdldFRhZyh2YWx1ZSkgIT0gb2JqZWN0VGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwcm90byA9IGdldFByb3RvdHlwZSh2YWx1ZSk7XG4gIGlmIChwcm90byA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBDdG9yID0gaGFzT3duUHJvcGVydHkuY2FsbChwcm90bywgJ2NvbnN0cnVjdG9yJykgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IgaW5zdGFuY2VvZiBDdG9yICYmXG4gICAgZnVuY1RvU3RyaW5nLmNhbGwoQ3RvcikgPT0gb2JqZWN0Q3RvclN0cmluZztcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNQbGFpbk9iamVjdDtcbiIsImltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IGlzTGVuZ3RoIGZyb20gJy4vaXNMZW5ndGguanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xudHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG50eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG50eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG50eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG50eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG50eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG50eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUlzVHlwZWRBcnJheTtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVVuYXJ5O1xuIiwiaW1wb3J0IGZyZWVHbG9iYWwgZnJvbSAnLi9fZnJlZUdsb2JhbC5qcyc7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBwcm9jZXNzYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzICYmIGZyZWVHbG9iYWwucHJvY2VzcztcblxuLyoqIFVzZWQgdG8gYWNjZXNzIGZhc3RlciBOb2RlLmpzIGhlbHBlcnMuICovXG52YXIgbm9kZVV0aWwgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxuZXhwb3J0IGRlZmF1bHQgbm9kZVV0aWw7XG4iLCJpbXBvcnQgYmFzZUlzVHlwZWRBcnJheSBmcm9tICcuL19iYXNlSXNUeXBlZEFycmF5LmpzJztcbmltcG9ydCBiYXNlVW5hcnkgZnJvbSAnLi9fYmFzZVVuYXJ5LmpzJztcbmltcG9ydCBub2RlVXRpbCBmcm9tICcuL19ub2RlVXRpbC5qcyc7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG5leHBvcnQgZGVmYXVsdCBpc1R5cGVkQXJyYXk7XG4iLCIvKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgLCB1bmxlc3MgYGtleWAgaXMgXCJfX3Byb3RvX19cIi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHNhZmVHZXQob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIGtleSA9PSAnX19wcm90b19fJ1xuICAgID8gdW5kZWZpbmVkXG4gICAgOiBvYmplY3Rba2V5XTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc2FmZUdldDtcbiIsImltcG9ydCBiYXNlQXNzaWduVmFsdWUgZnJvbSAnLi9fYmFzZUFzc2lnblZhbHVlLmpzJztcbmltcG9ydCBlcSBmcm9tICcuL2VxLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBc3NpZ25zIGB2YWx1ZWAgdG8gYGtleWAgb2YgYG9iamVjdGAgaWYgdGhlIGV4aXN0aW5nIHZhbHVlIGlzIG5vdCBlcXVpdmFsZW50XG4gKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgaWYgKCEoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYgZXEob2JqVmFsdWUsIHZhbHVlKSkgfHxcbiAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgYXNzaWduVmFsdWU7XG4iLCJpbXBvcnQgYXNzaWduVmFsdWUgZnJvbSAnLi9fYXNzaWduVmFsdWUuanMnO1xuaW1wb3J0IGJhc2VBc3NpZ25WYWx1ZSBmcm9tICcuL19iYXNlQXNzaWduVmFsdWUuanMnO1xuXG4vKipcbiAqIENvcGllcyBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMgdG8gY29weS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvcGllZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5T2JqZWN0KHNvdXJjZSwgcHJvcHMsIG9iamVjdCwgY3VzdG9taXplcikge1xuICB2YXIgaXNOZXcgPSAhb2JqZWN0O1xuICBvYmplY3QgfHwgKG9iamVjdCA9IHt9KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG5cbiAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICA/IGN1c3RvbWl6ZXIob2JqZWN0W2tleV0sIHNvdXJjZVtrZXldLCBrZXksIG9iamVjdCwgc291cmNlKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbmV3VmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gICAgaWYgKGlzTmV3KSB7XG4gICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY29weU9iamVjdDtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VUaW1lcztcbiIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuXG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlID09ICdudW1iZXInIHx8XG4gICAgICAodHlwZSAhPSAnc3ltYm9sJyAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkpICYmXG4gICAgICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNJbmRleDtcbiIsImltcG9ydCBiYXNlVGltZXMgZnJvbSAnLi9fYmFzZVRpbWVzLmpzJztcbmltcG9ydCBpc0FyZ3VtZW50cyBmcm9tICcuL2lzQXJndW1lbnRzLmpzJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5pbXBvcnQgaXNCdWZmZXIgZnJvbSAnLi9pc0J1ZmZlci5qcyc7XG5pbXBvcnQgaXNJbmRleCBmcm9tICcuL19pc0luZGV4LmpzJztcbmltcG9ydCBpc1R5cGVkQXJyYXkgZnJvbSAnLi9pc1R5cGVkQXJyYXkuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksXG4gICAgICBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50cyh2YWx1ZSksXG4gICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyKHZhbHVlKSxcbiAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLFxuICAgICAgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLFxuICAgICAgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxuICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XG4gICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbiAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcbiAgICAgICAgKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFycmF5TGlrZUtleXM7XG4iLCIvKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZVxuICogW2BPYmplY3Qua2V5c2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZXhjZXB0IHRoYXQgaXQgaW5jbHVkZXMgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gbmF0aXZlS2V5c0luKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChvYmplY3QgIT0gbnVsbCkge1xuICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbmF0aXZlS2V5c0luO1xuIiwiaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuaW1wb3J0IGlzUHJvdG90eXBlIGZyb20gJy4vX2lzUHJvdG90eXBlLmpzJztcbmltcG9ydCBuYXRpdmVLZXlzSW4gZnJvbSAnLi9fbmF0aXZlS2V5c0luLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzSW5gIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXNJbihvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXNJbihvYmplY3QpO1xuICB9XG4gIHZhciBpc1Byb3RvID0gaXNQcm90b3R5cGUob2JqZWN0KSxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICBpZiAoIShrZXkgPT0gJ2NvbnN0cnVjdG9yJyAmJiAoaXNQcm90byB8fCAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUtleXNJbjtcbiIsImltcG9ydCBhcnJheUxpa2VLZXlzIGZyb20gJy4vX2FycmF5TGlrZUtleXMuanMnO1xuaW1wb3J0IGJhc2VLZXlzSW4gZnJvbSAnLi9fYmFzZUtleXNJbi5qcyc7XG5pbXBvcnQgaXNBcnJheUxpa2UgZnJvbSAnLi9pc0FycmF5TGlrZS5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXNJbihuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJywgJ2MnXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICovXG5mdW5jdGlvbiBrZXlzSW4ob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QsIHRydWUpIDogYmFzZUtleXNJbihvYmplY3QpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBrZXlzSW47XG4iLCJpbXBvcnQgY29weU9iamVjdCBmcm9tICcuL19jb3B5T2JqZWN0LmpzJztcbmltcG9ydCBrZXlzSW4gZnJvbSAnLi9rZXlzSW4uanMnO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBwbGFpbiBvYmplY3QgZmxhdHRlbmluZyBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmdcbiAqIGtleWVkIHByb3BlcnRpZXMgb2YgYHZhbHVlYCB0byBvd24gcHJvcGVydGllcyBvZiB0aGUgcGxhaW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29udmVydGVkIHBsYWluIG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgbmV3IEZvbyk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAqXG4gKiBfLmFzc2lnbih7ICdhJzogMSB9LCBfLnRvUGxhaW5PYmplY3QobmV3IEZvbykpO1xuICogLy8gPT4geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH1cbiAqL1xuZnVuY3Rpb24gdG9QbGFpbk9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gY29weU9iamVjdCh2YWx1ZSwga2V5c0luKHZhbHVlKSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHRvUGxhaW5PYmplY3Q7XG4iLCJpbXBvcnQgYXNzaWduTWVyZ2VWYWx1ZSBmcm9tICcuL19hc3NpZ25NZXJnZVZhbHVlLmpzJztcbmltcG9ydCBjbG9uZUJ1ZmZlciBmcm9tICcuL19jbG9uZUJ1ZmZlci5qcyc7XG5pbXBvcnQgY2xvbmVUeXBlZEFycmF5IGZyb20gJy4vX2Nsb25lVHlwZWRBcnJheS5qcyc7XG5pbXBvcnQgY29weUFycmF5IGZyb20gJy4vX2NvcHlBcnJheS5qcyc7XG5pbXBvcnQgaW5pdENsb25lT2JqZWN0IGZyb20gJy4vX2luaXRDbG9uZU9iamVjdC5qcyc7XG5pbXBvcnQgaXNBcmd1bWVudHMgZnJvbSAnLi9pc0FyZ3VtZW50cy5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuaW1wb3J0IGlzQXJyYXlMaWtlT2JqZWN0IGZyb20gJy4vaXNBcnJheUxpa2VPYmplY3QuanMnO1xuaW1wb3J0IGlzQnVmZmVyIGZyb20gJy4vaXNCdWZmZXIuanMnO1xuaW1wb3J0IGlzRnVuY3Rpb24gZnJvbSAnLi9pc0Z1bmN0aW9uLmpzJztcbmltcG9ydCBpc09iamVjdCBmcm9tICcuL2lzT2JqZWN0LmpzJztcbmltcG9ydCBpc1BsYWluT2JqZWN0IGZyb20gJy4vaXNQbGFpbk9iamVjdC5qcyc7XG5pbXBvcnQgaXNUeXBlZEFycmF5IGZyb20gJy4vaXNUeXBlZEFycmF5LmpzJztcbmltcG9ydCBzYWZlR2V0IGZyb20gJy4vX3NhZmVHZXQuanMnO1xuaW1wb3J0IHRvUGxhaW5PYmplY3QgZnJvbSAnLi90b1BsYWluT2JqZWN0LmpzJztcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VNZXJnZWAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICogZGVlcCBtZXJnZXMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAqIHJlZmVyZW5jZXMgdG8gYmUgbWVyZ2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBtZXJnZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzcmNJbmRleCBUaGUgaW5kZXggb2YgYHNvdXJjZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXJnZUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1lcmdlIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkXG4gKiAgY291bnRlcnBhcnRzLlxuICovXG5mdW5jdGlvbiBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIHNyY0luZGV4LCBtZXJnZUZ1bmMsIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIHZhciBvYmpWYWx1ZSA9IHNhZmVHZXQob2JqZWN0LCBrZXkpLFxuICAgICAgc3JjVmFsdWUgPSBzYWZlR2V0KHNvdXJjZSwga2V5KSxcbiAgICAgIHN0YWNrZWQgPSBzdGFjay5nZXQoc3JjVmFsdWUpO1xuXG4gIGlmIChzdGFja2VkKSB7XG4gICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgc3RhY2tlZCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCAoa2V5ICsgJycpLCBvYmplY3QsIHNvdXJjZSwgc3RhY2spXG4gICAgOiB1bmRlZmluZWQ7XG5cbiAgdmFyIGlzQ29tbW9uID0gbmV3VmFsdWUgPT09IHVuZGVmaW5lZDtcblxuICBpZiAoaXNDb21tb24pIHtcbiAgICB2YXIgaXNBcnIgPSBpc0FycmF5KHNyY1ZhbHVlKSxcbiAgICAgICAgaXNCdWZmID0gIWlzQXJyICYmIGlzQnVmZmVyKHNyY1ZhbHVlKSxcbiAgICAgICAgaXNUeXBlZCA9ICFpc0FyciAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheShzcmNWYWx1ZSk7XG5cbiAgICBuZXdWYWx1ZSA9IHNyY1ZhbHVlO1xuICAgIGlmIChpc0FyciB8fCBpc0J1ZmYgfHwgaXNUeXBlZCkge1xuICAgICAgaWYgKGlzQXJyYXkob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gb2JqVmFsdWU7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc0FycmF5TGlrZU9iamVjdChvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBjb3B5QXJyYXkob2JqVmFsdWUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNCdWZmKSB7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIG5ld1ZhbHVlID0gY2xvbmVCdWZmZXIoc3JjVmFsdWUsIHRydWUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNUeXBlZCkge1xuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICBuZXdWYWx1ZSA9IGNsb25lVHlwZWRBcnJheShzcmNWYWx1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbmV3VmFsdWUgPSBbXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNQbGFpbk9iamVjdChzcmNWYWx1ZSkgfHwgaXNBcmd1bWVudHMoc3JjVmFsdWUpKSB7XG4gICAgICBuZXdWYWx1ZSA9IG9ialZhbHVlO1xuICAgICAgaWYgKGlzQXJndW1lbnRzKG9ialZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IHRvUGxhaW5PYmplY3Qob2JqVmFsdWUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoIWlzT2JqZWN0KG9ialZhbHVlKSB8fCAoc3JjSW5kZXggJiYgaXNGdW5jdGlvbihvYmpWYWx1ZSkpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gaW5pdENsb25lT2JqZWN0KHNyY1ZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAoaXNDb21tb24pIHtcbiAgICAvLyBSZWN1cnNpdmVseSBtZXJnZSBvYmplY3RzIGFuZCBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBzdGFjay5zZXQoc3JjVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICBtZXJnZUZ1bmMobmV3VmFsdWUsIHNyY1ZhbHVlLCBzcmNJbmRleCwgY3VzdG9taXplciwgc3RhY2spO1xuICAgIHN0YWNrWydkZWxldGUnXShzcmNWYWx1ZSk7XG4gIH1cbiAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlTWVyZ2VEZWVwO1xuIiwiaW1wb3J0IFN0YWNrIGZyb20gJy4vX1N0YWNrLmpzJztcbmltcG9ydCBhc3NpZ25NZXJnZVZhbHVlIGZyb20gJy4vX2Fzc2lnbk1lcmdlVmFsdWUuanMnO1xuaW1wb3J0IGJhc2VGb3IgZnJvbSAnLi9fYmFzZUZvci5qcyc7XG5pbXBvcnQgYmFzZU1lcmdlRGVlcCBmcm9tICcuL19iYXNlTWVyZ2VEZWVwLmpzJztcbmltcG9ydCBpc09iamVjdCBmcm9tICcuL2lzT2JqZWN0LmpzJztcbmltcG9ydCBrZXlzSW4gZnJvbSAnLi9rZXlzSW4uanMnO1xuaW1wb3J0IHNhZmVHZXQgZnJvbSAnLi9fc2FmZUdldC5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWVyZ2VgIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzcmNJbmRleCBUaGUgaW5kZXggb2YgYHNvdXJjZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBtZXJnZWQgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAqICBjb3VudGVycGFydHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIGlmIChvYmplY3QgPT09IHNvdXJjZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBiYXNlRm9yKHNvdXJjZSwgZnVuY3Rpb24oc3JjVmFsdWUsIGtleSkge1xuICAgIGlmIChpc09iamVjdChzcmNWYWx1ZSkpIHtcbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIHNyY0luZGV4LCBiYXNlTWVyZ2UsIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICAgID8gY3VzdG9taXplcihzYWZlR2V0KG9iamVjdCwga2V5KSwgc3JjVmFsdWUsIChrZXkgKyAnJyksIG9iamVjdCwgc291cmNlLCBzdGFjaylcbiAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gc3JjVmFsdWU7XG4gICAgICB9XG4gICAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfVxuICB9LCBrZXlzSW4pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlTWVyZ2U7XG4iLCJpbXBvcnQgYmFzZU1lcmdlIGZyb20gJy4vX2Jhc2VNZXJnZS5qcyc7XG5pbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdC5qcyc7XG5cbi8qKlxuICogVXNlZCBieSBgXy5kZWZhdWx0c0RlZXBgIHRvIGN1c3RvbWl6ZSBpdHMgYF8ubWVyZ2VgIHVzZSB0byBtZXJnZSBzb3VyY2VcbiAqIG9iamVjdHMgaW50byBkZXN0aW5hdGlvbiBvYmplY3RzIHRoYXQgYXJlIHBhc3NlZCB0aHJ1LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IG9ialZhbHVlIFRoZSBkZXN0aW5hdGlvbiB2YWx1ZS5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHNvdXJjZSB2YWx1ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gbWVyZ2UuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBwYXJlbnQgb2JqZWN0IG9mIGBvYmpWYWx1ZWAuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBwYXJlbnQgb2JqZWN0IG9mIGBzcmNWYWx1ZWAuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICogIGNvdW50ZXJwYXJ0cy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGN1c3RvbURlZmF1bHRzTWVyZ2Uob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjaykge1xuICBpZiAoaXNPYmplY3Qob2JqVmFsdWUpICYmIGlzT2JqZWN0KHNyY1ZhbHVlKSkge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IG1lcmdlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIHN0YWNrLnNldChzcmNWYWx1ZSwgb2JqVmFsdWUpO1xuICAgIGJhc2VNZXJnZShvYmpWYWx1ZSwgc3JjVmFsdWUsIHVuZGVmaW5lZCwgY3VzdG9tRGVmYXVsdHNNZXJnZSwgc3RhY2spO1xuICAgIHN0YWNrWydkZWxldGUnXShzcmNWYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIG9ialZhbHVlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjdXN0b21EZWZhdWx0c01lcmdlO1xuIiwiaW1wb3J0IGVxIGZyb20gJy4vZXEuanMnO1xuaW1wb3J0IGlzQXJyYXlMaWtlIGZyb20gJy4vaXNBcnJheUxpa2UuanMnO1xuaW1wb3J0IGlzSW5kZXggZnJvbSAnLi9faXNJbmRleC5qcyc7XG5pbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdC5qcyc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIHZhbHVlIGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBpbmRleCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIGluZGV4IG9yIGtleSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgb2JqZWN0IGFyZ3VtZW50LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiBpbmRleDtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcidcbiAgICAgICAgPyAoaXNBcnJheUxpa2Uob2JqZWN0KSAmJiBpc0luZGV4KGluZGV4LCBvYmplY3QubGVuZ3RoKSlcbiAgICAgICAgOiAodHlwZSA9PSAnc3RyaW5nJyAmJiBpbmRleCBpbiBvYmplY3QpXG4gICAgICApIHtcbiAgICByZXR1cm4gZXEob2JqZWN0W2luZGV4XSwgdmFsdWUpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNJdGVyYXRlZUNhbGw7XG4iLCJpbXBvcnQgYmFzZVJlc3QgZnJvbSAnLi9fYmFzZVJlc3QuanMnO1xuaW1wb3J0IGlzSXRlcmF0ZWVDYWxsIGZyb20gJy4vX2lzSXRlcmF0ZWVDYWxsLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5hc3NpZ25gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25lciBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFzc2lnbmVyIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVBc3NpZ25lcihhc3NpZ25lcikge1xuICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2VzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoLFxuICAgICAgICBjdXN0b21pemVyID0gbGVuZ3RoID4gMSA/IHNvdXJjZXNbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQsXG4gICAgICAgIGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICBjdXN0b21pemVyID0gKGFzc2lnbmVyLmxlbmd0aCA+IDMgJiYgdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJylcbiAgICAgID8gKGxlbmd0aC0tLCBjdXN0b21pemVyKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc291cmNlc1swXSwgc291cmNlc1sxXSwgZ3VhcmQpKSB7XG4gICAgICBjdXN0b21pemVyID0gbGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IGN1c3RvbWl6ZXI7XG4gICAgICBsZW5ndGggPSAxO1xuICAgIH1cbiAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICBhc3NpZ25lcihvYmplY3QsIHNvdXJjZSwgaW5kZXgsIGN1c3RvbWl6ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlQXNzaWduZXI7XG4iLCJpbXBvcnQgYmFzZU1lcmdlIGZyb20gJy4vX2Jhc2VNZXJnZS5qcyc7XG5pbXBvcnQgY3JlYXRlQXNzaWduZXIgZnJvbSAnLi9fY3JlYXRlQXNzaWduZXIuanMnO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ubWVyZ2VgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgIHdoaWNoXG4gKiBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIG1lcmdlZCB2YWx1ZXMgb2YgdGhlIGRlc3RpbmF0aW9uIGFuZCBzb3VyY2VcbiAqIHByb3BlcnRpZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgLCBtZXJnaW5nIGlzIGhhbmRsZWQgYnkgdGhlXG4gKiBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkIHdpdGggc2l4IGFyZ3VtZW50czpcbiAqIChvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKS5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gc291cmNlcyBUaGUgc291cmNlIG9iamVjdHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUpIHtcbiAqICAgaWYgKF8uaXNBcnJheShvYmpWYWx1ZSkpIHtcbiAqICAgICByZXR1cm4gb2JqVmFsdWUuY29uY2F0KHNyY1ZhbHVlKTtcbiAqICAgfVxuICogfVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogWzFdLCAnYic6IFsyXSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IFszXSwgJ2InOiBbNF0gfTtcbiAqXG4gKiBfLm1lcmdlV2l0aChvYmplY3QsIG90aGVyLCBjdXN0b21pemVyKTtcbiAqIC8vID0+IHsgJ2EnOiBbMSwgM10sICdiJzogWzIsIDRdIH1cbiAqL1xudmFyIG1lcmdlV2l0aCA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcikge1xuICBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyKTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBtZXJnZVdpdGg7XG4iLCJpbXBvcnQgYXBwbHkgZnJvbSAnLi9fYXBwbHkuanMnO1xuaW1wb3J0IGJhc2VSZXN0IGZyb20gJy4vX2Jhc2VSZXN0LmpzJztcbmltcG9ydCBjdXN0b21EZWZhdWx0c01lcmdlIGZyb20gJy4vX2N1c3RvbURlZmF1bHRzTWVyZ2UuanMnO1xuaW1wb3J0IG1lcmdlV2l0aCBmcm9tICcuL21lcmdlV2l0aC5qcyc7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5kZWZhdWx0c2AgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgYXNzaWduc1xuICogZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4xMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKiBAc2VlIF8uZGVmYXVsdHNcbiAqIEBleGFtcGxlXG4gKlxuICogXy5kZWZhdWx0c0RlZXAoeyAnYSc6IHsgJ2InOiAyIH0gfSwgeyAnYSc6IHsgJ2InOiAxLCAnYyc6IDMgfSB9KTtcbiAqIC8vID0+IHsgJ2EnOiB7ICdiJzogMiwgJ2MnOiAzIH0gfVxuICovXG52YXIgZGVmYXVsdHNEZWVwID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xuICBhcmdzLnB1c2godW5kZWZpbmVkLCBjdXN0b21EZWZhdWx0c01lcmdlKTtcbiAgcmV0dXJuIGFwcGx5KG1lcmdlV2l0aCwgdW5kZWZpbmVkLCBhcmdzKTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBkZWZhdWx0c0RlZXA7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGB1bmRlZmluZWRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGB1bmRlZmluZWRgLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNVbmRlZmluZWQodm9pZCAwKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVW5kZWZpbmVkKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzVW5kZWZpbmVkO1xuIiwiaW1wb3J0IGJhc2VHZXRUYWcgZnJvbSAnLi9fYmFzZUdldFRhZy5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGJvb2xlYW4gcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJvb2xlYW4sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Jvb2xlYW4oZmFsc2UpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNCb29sZWFuKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNCb29sZWFuKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gZmFsc2UgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBib29sVGFnKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNCb29sZWFuO1xuIiwiaW1wb3J0IG92ZXJBcmcgZnJvbSAnLi9fb3ZlckFyZy5qcyc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KTtcblxuZXhwb3J0IGRlZmF1bHQgbmF0aXZlS2V5cztcbiIsImltcG9ydCBpc1Byb3RvdHlwZSBmcm9tICcuL19pc1Byb3RvdHlwZS5qcyc7XG5pbXBvcnQgbmF0aXZlS2V5cyBmcm9tICcuL19uYXRpdmVLZXlzLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlS2V5cztcbiIsImltcG9ydCBhcnJheUxpa2VLZXlzIGZyb20gJy4vX2FycmF5TGlrZUtleXMuanMnO1xuaW1wb3J0IGJhc2VLZXlzIGZyb20gJy4vX2Jhc2VLZXlzLmpzJztcbmltcG9ydCBpc0FycmF5TGlrZSBmcm9tICcuL2lzQXJyYXlMaWtlLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy5rZXlzKCdoaScpO1xuICogLy8gPT4gWycwJywgJzEnXVxuICovXG5mdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGtleXM7XG4iLCJpbXBvcnQgYmFzZUZvciBmcm9tICcuL19iYXNlRm9yLmpzJztcbmltcG9ydCBrZXlzIGZyb20gJy4va2V5cy5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yT3duYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUZvck93bihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gIHJldHVybiBvYmplY3QgJiYgYmFzZUZvcihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUZvck93bjtcbiIsIi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqXG4gKiBBZGRzIGB2YWx1ZWAgdG8gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBhZGRcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQGFsaWFzIHB1c2hcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNhY2hlLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlQWRkKHZhbHVlKSB7XG4gIHRoaXMuX19kYXRhX18uc2V0KHZhbHVlLCBIQVNIX1VOREVGSU5FRCk7XG4gIHJldHVybiB0aGlzO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzZXRDYWNoZUFkZDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVIYXModmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc2V0Q2FjaGVIYXM7XG4iLCJpbXBvcnQgTWFwQ2FjaGUgZnJvbSAnLi9fTWFwQ2FjaGUuanMnO1xuaW1wb3J0IHNldENhY2hlQWRkIGZyb20gJy4vX3NldENhY2hlQWRkLmpzJztcbmltcG9ydCBzZXRDYWNoZUhhcyBmcm9tICcuL19zZXRDYWNoZUhhcy5qcyc7XG5cbi8qKlxuICpcbiAqIENyZWF0ZXMgYW4gYXJyYXkgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIHVuaXF1ZSB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU2V0Q2FjaGUodmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzID09IG51bGwgPyAwIDogdmFsdWVzLmxlbmd0aDtcblxuICB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHRoaXMuYWRkKHZhbHVlc1tpbmRleF0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTZXRDYWNoZWAuXG5TZXRDYWNoZS5wcm90b3R5cGUuYWRkID0gU2V0Q2FjaGUucHJvdG90eXBlLnB1c2ggPSBzZXRDYWNoZUFkZDtcblNldENhY2hlLnByb3RvdHlwZS5oYXMgPSBzZXRDYWNoZUhhcztcblxuZXhwb3J0IGRlZmF1bHQgU2V0Q2FjaGU7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zb21lYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlTb21lKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheVNvbWU7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBhIGBjYWNoZWAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGNhY2hlIFRoZSBjYWNoZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBjYWNoZUhhcyhjYWNoZSwga2V5KSB7XG4gIHJldHVybiBjYWNoZS5oYXMoa2V5KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2FjaGVIYXM7XG4iLCJpbXBvcnQgU2V0Q2FjaGUgZnJvbSAnLi9fU2V0Q2FjaGUuanMnO1xuaW1wb3J0IGFycmF5U29tZSBmcm9tICcuL19hcnJheVNvbWUuanMnO1xuaW1wb3J0IGNhY2hlSGFzIGZyb20gJy4vX2NhY2hlSGFzLmpzJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgYXJyYXlzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0FycmF5fSBvdGhlciBUaGUgb3RoZXIgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYGFycmF5YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcnJheXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxBcnJheXMoYXJyYXksIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBvdGhMZW5ndGggPSBvdGhlci5sZW5ndGg7XG5cbiAgaWYgKGFyckxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIShpc1BhcnRpYWwgJiYgb3RoTGVuZ3RoID4gYXJyTGVuZ3RoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KGFycmF5KTtcbiAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICB9XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gdHJ1ZSxcbiAgICAgIHNlZW4gPSAoYml0bWFzayAmIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpID8gbmV3IFNldENhY2hlIDogdW5kZWZpbmVkO1xuXG4gIHN0YWNrLnNldChhcnJheSwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIGFycmF5KTtcblxuICAvLyBJZ25vcmUgbm9uLWluZGV4IHByb3BlcnRpZXMuXG4gIHdoaWxlICgrK2luZGV4IDwgYXJyTGVuZ3RoKSB7XG4gICAgdmFyIGFyclZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2luZGV4XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBhcnJWYWx1ZSwgaW5kZXgsIG90aGVyLCBhcnJheSwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihhcnJWYWx1ZSwgb3RoVmFsdWUsIGluZGV4LCBhcnJheSwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgaWYgKGNvbXBhcmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChjb21wYXJlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKHNlZW4pIHtcbiAgICAgIGlmICghYXJyYXlTb21lKG90aGVyLCBmdW5jdGlvbihvdGhWYWx1ZSwgb3RoSW5kZXgpIHtcbiAgICAgICAgICAgIGlmICghY2FjaGVIYXMoc2Vlbiwgb3RoSW5kZXgpICYmXG4gICAgICAgICAgICAgICAgKGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzZWVuLnB1c2gob3RoSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKSB7XG4gICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEoXG4gICAgICAgICAgYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8XG4gICAgICAgICAgICBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKGFycmF5KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZXF1YWxBcnJheXM7XG4iLCIvKipcbiAqIENvbnZlcnRzIGBtYXBgIHRvIGl0cyBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gKi9cbmZ1bmN0aW9uIG1hcFRvQXJyYXkobWFwKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobWFwLnNpemUpO1xuXG4gIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSBba2V5LCB2YWx1ZV07XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBtYXBUb0FycmF5O1xuIiwiLyoqXG4gKiBDb252ZXJ0cyBgc2V0YCB0byBhbiBhcnJheSBvZiBpdHMgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBzZXRUb0FycmF5KHNldCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc2V0VG9BcnJheTtcbiIsImltcG9ydCBTeW1ib2wgZnJvbSAnLi9fU3ltYm9sLmpzJztcbmltcG9ydCBVaW50OEFycmF5IGZyb20gJy4vX1VpbnQ4QXJyYXkuanMnO1xuaW1wb3J0IGVxIGZyb20gJy4vZXEuanMnO1xuaW1wb3J0IGVxdWFsQXJyYXlzIGZyb20gJy4vX2VxdWFsQXJyYXlzLmpzJztcbmltcG9ydCBtYXBUb0FycmF5IGZyb20gJy4vX21hcFRvQXJyYXkuanMnO1xuaW1wb3J0IHNldFRvQXJyYXkgZnJvbSAnLi9fc2V0VG9BcnJheS5qcyc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGNvbXBhcmluZyBvYmplY3RzIG9mXG4gKiB0aGUgc2FtZSBgdG9TdHJpbmdUYWdgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY29tcGFyaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3RzIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCB0YWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgIChvYmplY3QuYnl0ZU9mZnNldCAhPSBvdGhlci5ieXRlT2Zmc2V0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBvYmplY3QuYnVmZmVyO1xuICAgICAgb3RoZXIgPSBvdGhlci5idWZmZXI7XG5cbiAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgICFlcXVhbEZ1bmMobmV3IFVpbnQ4QXJyYXkob2JqZWN0KSwgbmV3IFVpbnQ4QXJyYXkob3RoZXIpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgYm9vbFRhZzpcbiAgICBjYXNlIGRhdGVUYWc6XG4gICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAvLyBDb2VyY2UgYm9vbGVhbnMgdG8gYDFgIG9yIGAwYCBhbmQgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzLlxuICAgICAgLy8gSW52YWxpZCBkYXRlcyBhcmUgY29lcmNlZCB0byBgTmFOYC5cbiAgICAgIHJldHVybiBlcSgrb2JqZWN0LCArb3RoZXIpO1xuXG4gICAgY2FzZSBlcnJvclRhZzpcbiAgICAgIHJldHVybiBvYmplY3QubmFtZSA9PSBvdGhlci5uYW1lICYmIG9iamVjdC5tZXNzYWdlID09IG90aGVyLm1lc3NhZ2U7XG5cbiAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIC8vIENvZXJjZSByZWdleGVzIHRvIHN0cmluZ3MgYW5kIHRyZWF0IHN0cmluZ3MsIHByaW1pdGl2ZXMgYW5kIG9iamVjdHMsXG4gICAgICAvLyBhcyBlcXVhbC4gU2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1yZWdleHAucHJvdG90eXBlLnRvc3RyaW5nXG4gICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgcmV0dXJuIG9iamVjdCA9PSAob3RoZXIgKyAnJyk7XG5cbiAgICBjYXNlIG1hcFRhZzpcbiAgICAgIHZhciBjb252ZXJ0ID0gbWFwVG9BcnJheTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRztcbiAgICAgIGNvbnZlcnQgfHwgKGNvbnZlcnQgPSBzZXRUb0FycmF5KTtcblxuICAgICAgaWYgKG9iamVjdC5zaXplICE9IG90aGVyLnNpemUgJiYgIWlzUGFydGlhbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gICAgICB9XG4gICAgICBiaXRtYXNrIHw9IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUc7XG5cbiAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgICAgdmFyIHJlc3VsdCA9IGVxdWFsQXJyYXlzKGNvbnZlcnQob2JqZWN0KSwgY29udmVydChvdGhlciksIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICBpZiAoc3ltYm9sVmFsdWVPZikge1xuICAgICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZi5jYWxsKG9iamVjdCkgPT0gc3ltYm9sVmFsdWVPZi5jYWxsKG90aGVyKTtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGVxdWFsQnlUYWc7XG4iLCIvKipcbiAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFycmF5UHVzaDtcbiIsImltcG9ydCBhcnJheVB1c2ggZnJvbSAnLi9fYXJyYXlQdXNoLmpzJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldEFsbEtleXNgIGFuZCBgZ2V0QWxsS2V5c0luYCB3aGljaCB1c2VzXG4gKiBga2V5c0Z1bmNgIGFuZCBgc3ltYm9sc0Z1bmNgIHRvIGdldCB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzeW1ib2xzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzRnVuYywgc3ltYm9sc0Z1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXNGdW5jKG9iamVjdCk7XG4gIHJldHVybiBpc0FycmF5KG9iamVjdCkgPyByZXN1bHQgOiBhcnJheVB1c2gocmVzdWx0LCBzeW1ib2xzRnVuYyhvYmplY3QpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUdldEFsbEtleXM7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5maWx0ZXJgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlGaWx0ZXIoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFycmF5RmlsdGVyO1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGVtcHR5IGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZW1wdHkgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBhcnJheXMgPSBfLnRpbWVzKDIsIF8uc3R1YkFycmF5KTtcbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXMpO1xuICogLy8gPT4gW1tdLCBbXV1cbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXNbMF0gPT09IGFycmF5c1sxXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBzdHViQXJyYXkoKSB7XG4gIHJldHVybiBbXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3R1YkFycmF5O1xuIiwiaW1wb3J0IGFycmF5RmlsdGVyIGZyb20gJy4vX2FycmF5RmlsdGVyLmpzJztcbmltcG9ydCBzdHViQXJyYXkgZnJvbSAnLi9zdHViQXJyYXkuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICovXG52YXIgZ2V0U3ltYm9scyA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgcmV0dXJuIGFycmF5RmlsdGVyKG5hdGl2ZUdldFN5bWJvbHMob2JqZWN0KSwgZnVuY3Rpb24oc3ltYm9sKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqZWN0LCBzeW1ib2wpO1xuICB9KTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGdldFN5bWJvbHM7XG4iLCJpbXBvcnQgYmFzZUdldEFsbEtleXMgZnJvbSAnLi9fYmFzZUdldEFsbEtleXMuanMnO1xuaW1wb3J0IGdldFN5bWJvbHMgZnJvbSAnLi9fZ2V0U3ltYm9scy5qcyc7XG5pbXBvcnQga2V5cyBmcm9tICcuL2tleXMuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGdldEFsbEtleXMob2JqZWN0KSB7XG4gIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXMsIGdldFN5bWJvbHMpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXRBbGxLZXlzO1xuIiwiaW1wb3J0IGdldEFsbEtleXMgZnJvbSAnLi9fZ2V0QWxsS2V5cy5qcyc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIG9iamVjdHMgd2l0aCBzdXBwb3J0IGZvclxuICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcbiAgICAgIG9ialByb3BzID0gZ2V0QWxsS2V5cyhvYmplY3QpLFxuICAgICAgb2JqTGVuZ3RoID0gb2JqUHJvcHMubGVuZ3RoLFxuICAgICAgb3RoUHJvcHMgPSBnZXRBbGxLZXlzKG90aGVyKSxcbiAgICAgIG90aExlbmd0aCA9IG90aFByb3BzLmxlbmd0aDtcblxuICBpZiAob2JqTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBpbmRleCA9IG9iakxlbmd0aDtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIGlmICghKGlzUGFydGlhbCA/IGtleSBpbiBvdGhlciA6IGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsIGtleSkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICB9XG4gIHZhciByZXN1bHQgPSB0cnVlO1xuICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gIHN0YWNrLnNldChvdGhlciwgb2JqZWN0KTtcblxuICB2YXIgc2tpcEN0b3IgPSBpc1BhcnRpYWw7XG4gIHdoaWxlICgrK2luZGV4IDwgb2JqTGVuZ3RoKSB7XG4gICAga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2tleV07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgb2JqVmFsdWUsIGtleSwgb3RoZXIsIG9iamVjdCwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihvYmpWYWx1ZSwgb3RoVmFsdWUsIGtleSwgb2JqZWN0LCBvdGhlciwgc3RhY2spO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBpZiAoIShjb21wYXJlZCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyAob2JqVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhvYmpWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSlcbiAgICAgICAgICA6IGNvbXBhcmVkXG4gICAgICAgICkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHNraXBDdG9yIHx8IChza2lwQ3RvciA9IGtleSA9PSAnY29uc3RydWN0b3InKTtcbiAgfVxuICBpZiAocmVzdWx0ICYmICFza2lwQ3Rvcikge1xuICAgIHZhciBvYmpDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICBvdGhDdG9yID0gb3RoZXIuY29uc3RydWN0b3I7XG5cbiAgICAvLyBOb24gYE9iamVjdGAgb2JqZWN0IGluc3RhbmNlcyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVhbC5cbiAgICBpZiAob2JqQ3RvciAhPSBvdGhDdG9yICYmXG4gICAgICAgICgnY29uc3RydWN0b3InIGluIG9iamVjdCAmJiAnY29uc3RydWN0b3InIGluIG90aGVyKSAmJlxuICAgICAgICAhKHR5cGVvZiBvYmpDdG9yID09ICdmdW5jdGlvbicgJiYgb2JqQ3RvciBpbnN0YW5jZW9mIG9iakN0b3IgJiZcbiAgICAgICAgICB0eXBlb2Ygb3RoQ3RvciA9PSAnZnVuY3Rpb24nICYmIG90aEN0b3IgaW5zdGFuY2VvZiBvdGhDdG9yKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBlcXVhbE9iamVjdHM7XG4iLCJpbXBvcnQgZ2V0TmF0aXZlIGZyb20gJy4vX2dldE5hdGl2ZS5qcyc7XG5pbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIERhdGFWaWV3ID0gZ2V0TmF0aXZlKHJvb3QsICdEYXRhVmlldycpO1xuXG5leHBvcnQgZGVmYXVsdCBEYXRhVmlldztcbiIsImltcG9ydCBnZXROYXRpdmUgZnJvbSAnLi9fZ2V0TmF0aXZlLmpzJztcbmltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgUHJvbWlzZSA9IGdldE5hdGl2ZShyb290LCAnUHJvbWlzZScpO1xuXG5leHBvcnQgZGVmYXVsdCBQcm9taXNlO1xuIiwiaW1wb3J0IGdldE5hdGl2ZSBmcm9tICcuL19nZXROYXRpdmUuanMnO1xuaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBTZXQgPSBnZXROYXRpdmUocm9vdCwgJ1NldCcpO1xuXG5leHBvcnQgZGVmYXVsdCBTZXQ7XG4iLCJpbXBvcnQgZ2V0TmF0aXZlIGZyb20gJy4vX2dldE5hdGl2ZS5qcyc7XG5pbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFdlYWtNYXAgPSBnZXROYXRpdmUocm9vdCwgJ1dlYWtNYXAnKTtcblxuZXhwb3J0IGRlZmF1bHQgV2Vha01hcDtcbiIsImltcG9ydCBEYXRhVmlldyBmcm9tICcuL19EYXRhVmlldy5qcyc7XG5pbXBvcnQgTWFwIGZyb20gJy4vX01hcC5qcyc7XG5pbXBvcnQgUHJvbWlzZSBmcm9tICcuL19Qcm9taXNlLmpzJztcbmltcG9ydCBTZXQgZnJvbSAnLi9fU2V0LmpzJztcbmltcG9ydCBXZWFrTWFwIGZyb20gJy4vX1dlYWtNYXAuanMnO1xuaW1wb3J0IGJhc2VHZXRUYWcgZnJvbSAnLi9fYmFzZUdldFRhZy5qcyc7XG5pbXBvcnQgdG9Tb3VyY2UgZnJvbSAnLi9fdG9Tb3VyY2UuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcHJvbWlzZVRhZyA9ICdbb2JqZWN0IFByb21pc2VdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWFwcywgc2V0cywgYW5kIHdlYWttYXBzLiAqL1xudmFyIGRhdGFWaWV3Q3RvclN0cmluZyA9IHRvU291cmNlKERhdGFWaWV3KSxcbiAgICBtYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoTWFwKSxcbiAgICBwcm9taXNlQ3RvclN0cmluZyA9IHRvU291cmNlKFByb21pc2UpLFxuICAgIHNldEN0b3JTdHJpbmcgPSB0b1NvdXJjZShTZXQpLFxuICAgIHdlYWtNYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoV2Vha01hcCk7XG5cbi8qKlxuICogR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbnZhciBnZXRUYWcgPSBiYXNlR2V0VGFnO1xuXG4vLyBGYWxsYmFjayBmb3IgZGF0YSB2aWV3cywgbWFwcywgc2V0cywgYW5kIHdlYWsgbWFwcyBpbiBJRSAxMSBhbmQgcHJvbWlzZXMgaW4gTm9kZS5qcyA8IDYuXG5pZiAoKERhdGFWaWV3ICYmIGdldFRhZyhuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpKSkgIT0gZGF0YVZpZXdUYWcpIHx8XG4gICAgKE1hcCAmJiBnZXRUYWcobmV3IE1hcCkgIT0gbWFwVGFnKSB8fFxuICAgIChQcm9taXNlICYmIGdldFRhZyhQcm9taXNlLnJlc29sdmUoKSkgIT0gcHJvbWlzZVRhZykgfHxcbiAgICAoU2V0ICYmIGdldFRhZyhuZXcgU2V0KSAhPSBzZXRUYWcpIHx8XG4gICAgKFdlYWtNYXAgJiYgZ2V0VGFnKG5ldyBXZWFrTWFwKSAhPSB3ZWFrTWFwVGFnKSkge1xuICBnZXRUYWcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSBiYXNlR2V0VGFnKHZhbHVlKSxcbiAgICAgICAgQ3RvciA9IHJlc3VsdCA9PSBvYmplY3RUYWcgPyB2YWx1ZS5jb25zdHJ1Y3RvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgY3RvclN0cmluZyA9IEN0b3IgPyB0b1NvdXJjZShDdG9yKSA6ICcnO1xuXG4gICAgaWYgKGN0b3JTdHJpbmcpIHtcbiAgICAgIHN3aXRjaCAoY3RvclN0cmluZykge1xuICAgICAgICBjYXNlIGRhdGFWaWV3Q3RvclN0cmluZzogcmV0dXJuIGRhdGFWaWV3VGFnO1xuICAgICAgICBjYXNlIG1hcEN0b3JTdHJpbmc6IHJldHVybiBtYXBUYWc7XG4gICAgICAgIGNhc2UgcHJvbWlzZUN0b3JTdHJpbmc6IHJldHVybiBwcm9taXNlVGFnO1xuICAgICAgICBjYXNlIHNldEN0b3JTdHJpbmc6IHJldHVybiBzZXRUYWc7XG4gICAgICAgIGNhc2Ugd2Vha01hcEN0b3JTdHJpbmc6IHJldHVybiB3ZWFrTWFwVGFnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXRUYWc7XG4iLCJpbXBvcnQgU3RhY2sgZnJvbSAnLi9fU3RhY2suanMnO1xuaW1wb3J0IGVxdWFsQXJyYXlzIGZyb20gJy4vX2VxdWFsQXJyYXlzLmpzJztcbmltcG9ydCBlcXVhbEJ5VGFnIGZyb20gJy4vX2VxdWFsQnlUYWcuanMnO1xuaW1wb3J0IGVxdWFsT2JqZWN0cyBmcm9tICcuL19lcXVhbE9iamVjdHMuanMnO1xuaW1wb3J0IGdldFRhZyBmcm9tICcuL19nZXRUYWcuanMnO1xuaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5LmpzJztcbmltcG9ydCBpc0J1ZmZlciBmcm9tICcuL2lzQnVmZmVyLmpzJztcbmltcG9ydCBpc1R5cGVkQXJyYXkgZnJvbSAnLi9pc1R5cGVkQXJyYXkuanMnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDE7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAqIGRlZXAgY29tcGFyaXNvbnMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAqIHJlZmVyZW5jZXMgdG8gYmUgY29tcGFyZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsRGVlcChvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBvYmpJc0FyciA9IGlzQXJyYXkob2JqZWN0KSxcbiAgICAgIG90aElzQXJyID0gaXNBcnJheShvdGhlciksXG4gICAgICBvYmpUYWcgPSBvYmpJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG9iamVjdCksXG4gICAgICBvdGhUYWcgPSBvdGhJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG90aGVyKTtcblxuICBvYmpUYWcgPSBvYmpUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG9ialRhZztcbiAgb3RoVGFnID0gb3RoVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvdGhUYWc7XG5cbiAgdmFyIG9iaklzT2JqID0gb2JqVGFnID09IG9iamVjdFRhZyxcbiAgICAgIG90aElzT2JqID0gb3RoVGFnID09IG9iamVjdFRhZyxcbiAgICAgIGlzU2FtZVRhZyA9IG9ialRhZyA9PSBvdGhUYWc7XG5cbiAgaWYgKGlzU2FtZVRhZyAmJiBpc0J1ZmZlcihvYmplY3QpKSB7XG4gICAgaWYgKCFpc0J1ZmZlcihvdGhlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgb2JqSXNBcnIgPSB0cnVlO1xuICAgIG9iaklzT2JqID0gZmFsc2U7XG4gIH1cbiAgaWYgKGlzU2FtZVRhZyAmJiAhb2JqSXNPYmopIHtcbiAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgIHJldHVybiAob2JqSXNBcnIgfHwgaXNUeXBlZEFycmF5KG9iamVjdCkpXG4gICAgICA/IGVxdWFsQXJyYXlzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spXG4gICAgICA6IGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgb2JqVGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgfVxuICBpZiAoIShiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcpKSB7XG4gICAgdmFyIG9iaklzV3JhcHBlZCA9IG9iaklzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCAnX193cmFwcGVkX18nKSxcbiAgICAgICAgb3RoSXNXcmFwcGVkID0gb3RoSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwgJ19fd3JhcHBlZF9fJyk7XG5cbiAgICBpZiAob2JqSXNXcmFwcGVkIHx8IG90aElzV3JhcHBlZCkge1xuICAgICAgdmFyIG9ialVud3JhcHBlZCA9IG9iaklzV3JhcHBlZCA/IG9iamVjdC52YWx1ZSgpIDogb2JqZWN0LFxuICAgICAgICAgIG90aFVud3JhcHBlZCA9IG90aElzV3JhcHBlZCA/IG90aGVyLnZhbHVlKCkgOiBvdGhlcjtcblxuICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgIHJldHVybiBlcXVhbEZ1bmMob2JqVW53cmFwcGVkLCBvdGhVbndyYXBwZWQsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFpc1NhbWVUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgcmV0dXJuIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUlzRXF1YWxEZWVwO1xuIiwiaW1wb3J0IGJhc2VJc0VxdWFsRGVlcCBmcm9tICcuL19iYXNlSXNFcXVhbERlZXAuanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAgd2hpY2ggc3VwcG9ydHMgcGFydGlhbCBjb21wYXJpc29uc1xuICogYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gKiAgMSAtIFVub3JkZXJlZCBjb21wYXJpc29uXG4gKiAgMiAtIFBhcnRpYWwgY29tcGFyaXNvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgaWYgKHZhbHVlID09PSBvdGhlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsIHx8IG90aGVyID09IG51bGwgfHwgKCFpc09iamVjdExpa2UodmFsdWUpICYmICFpc09iamVjdExpa2Uob3RoZXIpKSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyO1xuICB9XG4gIHJldHVybiBiYXNlSXNFcXVhbERlZXAodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBiYXNlSXNFcXVhbCwgc3RhY2spO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlSXNFcXVhbDtcbiIsImltcG9ydCBTdGFjayBmcm9tICcuL19TdGFjay5qcyc7XG5pbXBvcnQgYmFzZUlzRXF1YWwgZnJvbSAnLi9fYmFzZUlzRXF1YWwuanMnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNNYXRjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gKiBAcGFyYW0ge0FycmF5fSBtYXRjaERhdGEgVGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhLCBjdXN0b21pemVyKSB7XG4gIHZhciBpbmRleCA9IG1hdGNoRGF0YS5sZW5ndGgsXG4gICAgICBsZW5ndGggPSBpbmRleCxcbiAgICAgIG5vQ3VzdG9taXplciA9ICFjdXN0b21pemVyO1xuXG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiAhbGVuZ3RoO1xuICB9XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIHZhciBkYXRhID0gbWF0Y2hEYXRhW2luZGV4XTtcbiAgICBpZiAoKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKVxuICAgICAgICAgID8gZGF0YVsxXSAhPT0gb2JqZWN0W2RhdGFbMF1dXG4gICAgICAgICAgOiAhKGRhdGFbMF0gaW4gb2JqZWN0KVxuICAgICAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBkYXRhID0gbWF0Y2hEYXRhW2luZGV4XTtcbiAgICB2YXIga2V5ID0gZGF0YVswXSxcbiAgICAgICAgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgc3JjVmFsdWUgPSBkYXRhWzFdO1xuXG4gICAgaWYgKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKSB7XG4gICAgICBpZiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0YWNrID0gbmV3IFN0YWNrO1xuICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjayk7XG4gICAgICB9XG4gICAgICBpZiAoIShyZXN1bHQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICAgICA6IHJlc3VsdFxuICAgICAgICAgICkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUlzTWF0Y2g7XG4iLCJpbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdC5qcyc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpZiBzdWl0YWJsZSBmb3Igc3RyaWN0XG4gKiAgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgJiYgIWlzT2JqZWN0KHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNTdHJpY3RDb21wYXJhYmxlO1xuIiwiaW1wb3J0IGlzU3RyaWN0Q29tcGFyYWJsZSBmcm9tICcuL19pc1N0cmljdENvbXBhcmFibGUuanMnO1xuaW1wb3J0IGtleXMgZnJvbSAnLi9rZXlzLmpzJztcblxuLyoqXG4gKiBHZXRzIHRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBtYXRjaCBkYXRhIG9mIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBnZXRNYXRjaERhdGEob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBrZXlzKG9iamVjdCksXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIHZhciBrZXkgPSByZXN1bHRbbGVuZ3RoXSxcbiAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgIHJlc3VsdFtsZW5ndGhdID0gW2tleSwgdmFsdWUsIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSldO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldE1hdGNoRGF0YTtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBtYXRjaGVzUHJvcGVydHlgIGZvciBzb3VyY2UgdmFsdWVzIHN1aXRhYmxlXG4gKiBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUoa2V5LCBzcmNWYWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Rba2V5XSA9PT0gc3JjVmFsdWUgJiZcbiAgICAgIChzcmNWYWx1ZSAhPT0gdW5kZWZpbmVkIHx8IChrZXkgaW4gT2JqZWN0KG9iamVjdCkpKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWF0Y2hlc1N0cmljdENvbXBhcmFibGU7XG4iLCJpbXBvcnQgYmFzZUlzTWF0Y2ggZnJvbSAnLi9fYmFzZUlzTWF0Y2guanMnO1xuaW1wb3J0IGdldE1hdGNoRGF0YSBmcm9tICcuL19nZXRNYXRjaERhdGEuanMnO1xuaW1wb3J0IG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlIGZyb20gJy4vX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlLmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzYCB3aGljaCBkb2Vzbid0IGNsb25lIGBzb3VyY2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hdGNoZXMoc291cmNlKSB7XG4gIHZhciBtYXRjaERhdGEgPSBnZXRNYXRjaERhdGEoc291cmNlKTtcbiAgaWYgKG1hdGNoRGF0YS5sZW5ndGggPT0gMSAmJiBtYXRjaERhdGFbMF1bMl0pIHtcbiAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUobWF0Y2hEYXRhWzBdWzBdLCBtYXRjaERhdGFbMF1bMV0pO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09PSBzb3VyY2UgfHwgYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VNYXRjaGVzO1xuIiwiaW1wb3J0IGJhc2VHZXRUYWcgZnJvbSAnLi9fYmFzZUdldFRhZy5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc1N5bWJvbDtcbiIsImltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5pbXBvcnQgaXNTeW1ib2wgZnJvbSAnLi9pc1N5bWJvbC5qcyc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUlzRGVlcFByb3AgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqP1xcMSlcXF0vLFxuICAgIHJlSXNQbGFpblByb3AgPSAvXlxcdyokLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUgYW5kIG5vdCBhIHByb3BlcnR5IHBhdGguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleSh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJyB8fFxuICAgICAgdmFsdWUgPT0gbnVsbCB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmVJc1BsYWluUHJvcC50ZXN0KHZhbHVlKSB8fCAhcmVJc0RlZXBQcm9wLnRlc3QodmFsdWUpIHx8XG4gICAgKG9iamVjdCAhPSBudWxsICYmIHZhbHVlIGluIE9iamVjdChvYmplY3QpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNLZXk7XG4iLCJpbXBvcnQgTWFwQ2FjaGUgZnJvbSAnLi9fTWFwQ2FjaGUuanMnO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gKiBwcm92aWRlZCwgaXQgZGV0ZXJtaW5lcyB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHQgYmFzZWQgb24gdGhlXG4gKiBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgYXJndW1lbnRcbiAqIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBtYXAgY2FjaGUga2V5LiBUaGUgYGZ1bmNgXG4gKiBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXG4gKiBmdW5jdGlvbi4gSXRzIGNyZWF0aW9uIG1heSBiZSBjdXN0b21pemVkIGJ5IHJlcGxhY2luZyB0aGUgYF8ubWVtb2l6ZS5DYWNoZWBcbiAqIGNvbnN0cnVjdG9yIHdpdGggb25lIHdob3NlIGluc3RhbmNlcyBpbXBsZW1lbnQgdGhlXG4gKiBbYE1hcGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLW1hcC1wcm90b3R5cGUtb2JqZWN0KVxuICogbWV0aG9kIGludGVyZmFjZSBvZiBgY2xlYXJgLCBgZGVsZXRlYCwgYGdldGAsIGBoYXNgLCBhbmQgYHNldGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2MnOiAzLCAnZCc6IDQgfTtcbiAqXG4gKiB2YXIgdmFsdWVzID0gXy5tZW1vaXplKF8udmFsdWVzKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogdmFsdWVzKG90aGVyKTtcbiAqIC8vID0+IFszLCA0XVxuICpcbiAqIG9iamVjdC5hID0gMjtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogLy8gTW9kaWZ5IHRoZSByZXN1bHQgY2FjaGUuXG4gKiB2YWx1ZXMuY2FjaGUuc2V0KG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsnYScsICdiJ11cbiAqXG4gKiAvLyBSZXBsYWNlIGBfLm1lbW9pemUuQ2FjaGVgLlxuICogXy5tZW1vaXplLkNhY2hlID0gV2Vha01hcDtcbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJyB8fCAocmVzb2x2ZXIgIT0gbnVsbCAmJiB0eXBlb2YgcmVzb2x2ZXIgIT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuICAgICAgICBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuXG4gICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KSB8fCBjYWNoZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBtZW1vaXplZC5jYWNoZSA9IG5ldyAobWVtb2l6ZS5DYWNoZSB8fCBNYXBDYWNoZSk7XG4gIHJldHVybiBtZW1vaXplZDtcbn1cblxuLy8gRXhwb3NlIGBNYXBDYWNoZWAuXG5tZW1vaXplLkNhY2hlID0gTWFwQ2FjaGU7XG5cbmV4cG9ydCBkZWZhdWx0IG1lbW9pemU7XG4iLCJpbXBvcnQgbWVtb2l6ZSBmcm9tICcuL21lbW9pemUuanMnO1xuXG4vKiogVXNlZCBhcyB0aGUgbWF4aW11bSBtZW1vaXplIGNhY2hlIHNpemUuICovXG52YXIgTUFYX01FTU9JWkVfU0laRSA9IDUwMDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWVtb2l6ZWAgd2hpY2ggY2xlYXJzIHRoZSBtZW1vaXplZCBmdW5jdGlvbidzXG4gKiBjYWNoZSB3aGVuIGl0IGV4Y2VlZHMgYE1BWF9NRU1PSVpFX1NJWkVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZUNhcHBlZChmdW5jKSB7XG4gIHZhciByZXN1bHQgPSBtZW1vaXplKGZ1bmMsIGZ1bmN0aW9uKGtleSkge1xuICAgIGlmIChjYWNoZS5zaXplID09PSBNQVhfTUVNT0laRV9TSVpFKSB7XG4gICAgICBjYWNoZS5jbGVhcigpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5O1xuICB9KTtcblxuICB2YXIgY2FjaGUgPSByZXN1bHQuY2FjaGU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1lbW9pemVDYXBwZWQ7XG4iLCJpbXBvcnQgbWVtb2l6ZUNhcHBlZCBmcm9tICcuL19tZW1vaXplQ2FwcGVkLmpzJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlUHJvcE5hbWUgPSAvW14uW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JCkpL2c7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nO1xuXG4vKipcbiAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGEgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbnZhciBzdHJpbmdUb1BhdGggPSBtZW1vaXplQ2FwcGVkKGZ1bmN0aW9uKHN0cmluZykge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChzdHJpbmcuY2hhckNvZGVBdCgwKSA9PT0gNDYgLyogLiAqLykge1xuICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgfVxuICBzdHJpbmcucmVwbGFjZShyZVByb3BOYW1lLCBmdW5jdGlvbihtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3ViU3RyaW5nKSB7XG4gICAgcmVzdWx0LnB1c2gocXVvdGUgPyBzdWJTdHJpbmcucmVwbGFjZShyZUVzY2FwZUNoYXIsICckMScpIDogKG51bWJlciB8fCBtYXRjaCkpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBzdHJpbmdUb1BhdGg7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheU1hcDtcbiIsImltcG9ydCBTeW1ib2wgZnJvbSAnLi9fU3ltYm9sLmpzJztcbmltcG9ydCBhcnJheU1hcCBmcm9tICcuL19hcnJheU1hcC5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuaW1wb3J0IGlzU3ltYm9sIGZyb20gJy4vaXNTeW1ib2wuanMnO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgdmFsdWVzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCBiYXNlVG9TdHJpbmcpICsgJyc7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlVG9TdHJpbmc7XG4iLCJpbXBvcnQgYmFzZVRvU3RyaW5nIGZyb20gJy4vX2Jhc2VUb1N0cmluZy5qcyc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAqIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b1N0cmluZyhudWxsKTtcbiAqIC8vID0+ICcnXG4gKlxuICogXy50b1N0cmluZygtMCk7XG4gKiAvLyA9PiAnLTAnXG4gKlxuICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICogLy8gPT4gJzEsMiwzJ1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdG9TdHJpbmc7XG4iLCJpbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuaW1wb3J0IGlzS2V5IGZyb20gJy4vX2lzS2V5LmpzJztcbmltcG9ydCBzdHJpbmdUb1BhdGggZnJvbSAnLi9fc3RyaW5nVG9QYXRoLmpzJztcbmltcG9ydCB0b1N0cmluZyBmcm9tICcuL3RvU3RyaW5nLmpzJztcblxuLyoqXG4gKiBDYXN0cyBgdmFsdWVgIHRvIGEgcGF0aCBhcnJheSBpZiBpdCdzIG5vdCBvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNhc3RQYXRoKHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiBpc0tleSh2YWx1ZSwgb2JqZWN0KSA/IFt2YWx1ZV0gOiBzdHJpbmdUb1BhdGgodG9TdHJpbmcodmFsdWUpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2FzdFBhdGg7XG4iLCJpbXBvcnQgaXNTeW1ib2wgZnJvbSAnLi9pc1N5bWJvbC5qcyc7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAqL1xuZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCB0b0tleTtcbiIsImltcG9ydCBjYXN0UGF0aCBmcm9tICcuL19jYXN0UGF0aC5qcyc7XG5pbXBvcnQgdG9LZXkgZnJvbSAnLi9fdG9LZXkuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmdldGAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWZhdWx0IHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldChvYmplY3QsIHBhdGgpIHtcbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gMCxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gIHdoaWxlIChvYmplY3QgIT0gbnVsbCAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgIG9iamVjdCA9IG9iamVjdFt0b0tleShwYXRoW2luZGV4KytdKV07XG4gIH1cbiAgcmV0dXJuIChpbmRleCAmJiBpbmRleCA9PSBsZW5ndGgpID8gb2JqZWN0IDogdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlR2V0O1xuIiwiaW1wb3J0IGJhc2VHZXQgZnJvbSAnLi9fYmFzZUdldC5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXNcbiAqIGB1bmRlZmluZWRgLCB0aGUgYGRlZmF1bHRWYWx1ZWAgaXMgcmV0dXJuZWQgaW4gaXRzIHBsYWNlLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy43LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSByZXR1cm5lZCBmb3IgYHVuZGVmaW5lZGAgcmVzb2x2ZWQgdmFsdWVzLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2FbMF0uYi5jJyk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCBbJ2EnLCAnMCcsICdiJywgJ2MnXSk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCAnYS5iLmMnLCAnZGVmYXVsdCcpO1xuICogLy8gPT4gJ2RlZmF1bHQnXG4gKi9cbmZ1bmN0aW9uIGdldChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0O1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5oYXNJbmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUhhc0luKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBrZXkgaW4gT2JqZWN0KG9iamVjdCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VIYXNJbjtcbiIsImltcG9ydCBjYXN0UGF0aCBmcm9tICcuL19jYXN0UGF0aC5qcyc7XG5pbXBvcnQgaXNBcmd1bWVudHMgZnJvbSAnLi9pc0FyZ3VtZW50cy5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuaW1wb3J0IGlzSW5kZXggZnJvbSAnLi9faXNJbmRleC5qcyc7XG5pbXBvcnQgaXNMZW5ndGggZnJvbSAnLi9pc0xlbmd0aC5qcyc7XG5pbXBvcnQgdG9LZXkgZnJvbSAnLi9fdG9LZXkuanMnO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgZXhpc3RzIG9uIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrIHByb3BlcnRpZXMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgaGFzRnVuYykge1xuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gZmFsc2U7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gdG9LZXkocGF0aFtpbmRleF0pO1xuICAgIGlmICghKHJlc3VsdCA9IG9iamVjdCAhPSBudWxsICYmIGhhc0Z1bmMob2JqZWN0LCBrZXkpKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG9iamVjdCA9IG9iamVjdFtrZXldO1xuICB9XG4gIGlmIChyZXN1bHQgfHwgKytpbmRleCAhPSBsZW5ndGgpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGxlbmd0aCA9IG9iamVjdCA9PSBudWxsID8gMCA6IG9iamVjdC5sZW5ndGg7XG4gIHJldHVybiAhIWxlbmd0aCAmJiBpc0xlbmd0aChsZW5ndGgpICYmIGlzSW5kZXgoa2V5LCBsZW5ndGgpICYmXG4gICAgKGlzQXJyYXkob2JqZWN0KSB8fCBpc0FyZ3VtZW50cyhvYmplY3QpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaGFzUGF0aDtcbiIsImltcG9ydCBiYXNlSGFzSW4gZnJvbSAnLi9fYmFzZUhhc0luLmpzJztcbmltcG9ydCBoYXNQYXRoIGZyb20gJy4vX2hhc1BhdGguanMnO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgaXMgYSBkaXJlY3Qgb3IgaW5oZXJpdGVkIHByb3BlcnR5IG9mIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IF8uY3JlYXRlKHsgJ2EnOiBfLmNyZWF0ZSh7ICdiJzogMiB9KSB9KTtcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EuYicpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2InKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGhhc0luKG9iamVjdCwgcGF0aCkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzUGF0aChvYmplY3QsIHBhdGgsIGJhc2VIYXNJbik7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGhhc0luO1xuIiwiaW1wb3J0IGJhc2VJc0VxdWFsIGZyb20gJy4vX2Jhc2VJc0VxdWFsLmpzJztcbmltcG9ydCBnZXQgZnJvbSAnLi9nZXQuanMnO1xuaW1wb3J0IGhhc0luIGZyb20gJy4vaGFzSW4uanMnO1xuaW1wb3J0IGlzS2V5IGZyb20gJy4vX2lzS2V5LmpzJztcbmltcG9ydCBpc1N0cmljdENvbXBhcmFibGUgZnJvbSAnLi9faXNTdHJpY3RDb21wYXJhYmxlLmpzJztcbmltcG9ydCBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSBmcm9tICcuL19tYXRjaGVzU3RyaWN0Q29tcGFyYWJsZS5qcyc7XG5pbXBvcnQgdG9LZXkgZnJvbSAnLi9fdG9LZXkuanMnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc1Byb3BlcnR5YCB3aGljaCBkb2Vzbid0IGNsb25lIGBzcmNWYWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzUHJvcGVydHkocGF0aCwgc3JjVmFsdWUpIHtcbiAgaWYgKGlzS2V5KHBhdGgpICYmIGlzU3RyaWN0Q29tcGFyYWJsZShzcmNWYWx1ZSkpIHtcbiAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUodG9LZXkocGF0aCksIHNyY1ZhbHVlKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIG9ialZhbHVlID0gZ2V0KG9iamVjdCwgcGF0aCk7XG4gICAgcmV0dXJuIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmIG9ialZhbHVlID09PSBzcmNWYWx1ZSlcbiAgICAgID8gaGFzSW4ob2JqZWN0LCBwYXRoKVxuICAgICAgOiBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRyk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VNYXRjaGVzUHJvcGVydHk7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlUHJvcGVydHk7XG4iLCJpbXBvcnQgYmFzZUdldCBmcm9tICcuL19iYXNlR2V0LmpzJztcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VQcm9wZXJ0eWAgd2hpY2ggc3VwcG9ydHMgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VQcm9wZXJ0eURlZXA7XG4iLCJpbXBvcnQgYmFzZVByb3BlcnR5IGZyb20gJy4vX2Jhc2VQcm9wZXJ0eS5qcyc7XG5pbXBvcnQgYmFzZVByb3BlcnR5RGVlcCBmcm9tICcuL19iYXNlUHJvcGVydHlEZWVwLmpzJztcbmltcG9ydCBpc0tleSBmcm9tICcuL19pc0tleS5qcyc7XG5pbXBvcnQgdG9LZXkgZnJvbSAnLi9fdG9LZXkuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBhIGdpdmVuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IFtcbiAqICAgeyAnYSc6IHsgJ2InOiAyIH0gfSxcbiAqICAgeyAnYSc6IHsgJ2InOiAxIH0gfVxuICogXTtcbiAqXG4gKiBfLm1hcChvYmplY3RzLCBfLnByb3BlcnR5KCdhLmInKSk7XG4gKiAvLyA9PiBbMiwgMV1cbiAqXG4gKiBfLm1hcChfLnNvcnRCeShvYmplY3RzLCBfLnByb3BlcnR5KFsnYScsICdiJ10pKSwgJ2EuYicpO1xuICogLy8gPT4gWzEsIDJdXG4gKi9cbmZ1bmN0aW9uIHByb3BlcnR5KHBhdGgpIHtcbiAgcmV0dXJuIGlzS2V5KHBhdGgpID8gYmFzZVByb3BlcnR5KHRvS2V5KHBhdGgpKSA6IGJhc2VQcm9wZXJ0eURlZXAocGF0aCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHByb3BlcnR5O1xuIiwiaW1wb3J0IGJhc2VNYXRjaGVzIGZyb20gJy4vX2Jhc2VNYXRjaGVzLmpzJztcbmltcG9ydCBiYXNlTWF0Y2hlc1Byb3BlcnR5IGZyb20gJy4vX2Jhc2VNYXRjaGVzUHJvcGVydHkuanMnO1xuaW1wb3J0IGlkZW50aXR5IGZyb20gJy4vaWRlbnRpdHkuanMnO1xuaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5LmpzJztcbmltcG9ydCBwcm9wZXJ0eSBmcm9tICcuL3Byb3BlcnR5LmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pdGVyYXRlZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gW3ZhbHVlPV8uaWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGFuIGl0ZXJhdGVlLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBpdGVyYXRlZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUl0ZXJhdGVlKHZhbHVlKSB7XG4gIC8vIERvbid0IHN0b3JlIHRoZSBgdHlwZW9mYCByZXN1bHQgaW4gYSB2YXJpYWJsZSB0byBhdm9pZCBhIEpJVCBidWcgaW4gU2FmYXJpIDkuXG4gIC8vIFNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTU2MDM0IGZvciBtb3JlIGRldGFpbHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBpZGVudGl0eTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpXG4gICAgICA/IGJhc2VNYXRjaGVzUHJvcGVydHkodmFsdWVbMF0sIHZhbHVlWzFdKVxuICAgICAgOiBiYXNlTWF0Y2hlcyh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHByb3BlcnR5KHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUl0ZXJhdGVlO1xuIiwiaW1wb3J0IGJhc2VBc3NpZ25WYWx1ZSBmcm9tICcuL19iYXNlQXNzaWduVmFsdWUuanMnO1xuaW1wb3J0IGJhc2VGb3JPd24gZnJvbSAnLi9fYmFzZUZvck93bi5qcyc7XG5pbXBvcnQgYmFzZUl0ZXJhdGVlIGZyb20gJy4vX2Jhc2VJdGVyYXRlZS5qcyc7XG5cbi8qKlxuICogVGhlIG9wcG9zaXRlIG9mIGBfLm1hcFZhbHVlc2A7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYW4gb2JqZWN0IHdpdGggdGhlXG4gKiBzYW1lIHZhbHVlcyBhcyBgb2JqZWN0YCBhbmQga2V5cyBnZW5lcmF0ZWQgYnkgcnVubmluZyBlYWNoIG93biBlbnVtZXJhYmxlXG4gKiBzdHJpbmcga2V5ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAgdGhydSBgaXRlcmF0ZWVgLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZFxuICogd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwga2V5LCBvYmplY3QpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy44LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgb2JqZWN0LlxuICogQHNlZSBfLm1hcFZhbHVlc1xuICogQGV4YW1wbGVcbiAqXG4gKiBfLm1hcEtleXMoeyAnYSc6IDEsICdiJzogMiB9LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gKiAgIHJldHVybiBrZXkgKyB2YWx1ZTtcbiAqIH0pO1xuICogLy8gPT4geyAnYTEnOiAxLCAnYjInOiAyIH1cbiAqL1xuZnVuY3Rpb24gbWFwS2V5cyhvYmplY3QsIGl0ZXJhdGVlKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgaXRlcmF0ZWUgPSBiYXNlSXRlcmF0ZWUoaXRlcmF0ZWUsIDMpO1xuXG4gIGJhc2VGb3JPd24ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICBiYXNlQXNzaWduVmFsdWUocmVzdWx0LCBpdGVyYXRlZSh2YWx1ZSwga2V5LCBvYmplY3QpLCB2YWx1ZSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBtYXBLZXlzO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgbnVsbGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYG51bGxgLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNOdWxsKG51bGwpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNOdWxsKHZvaWQgMCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc051bGwodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBudWxsO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc051bGw7XG4iLCJpbXBvcnQgaXNBcnJheUxpa2UgZnJvbSAnLi9pc0FycmF5TGlrZS5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBiYXNlRWFjaGAgb3IgYGJhc2VFYWNoUmlnaHRgIGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGEgY29sbGVjdGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUVhY2goZWFjaEZ1bmMsIGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9XG4gICAgaWYgKCFpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKTtcbiAgICB9XG4gICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxuICAgICAgICBpbmRleCA9IGZyb21SaWdodCA/IGxlbmd0aCA6IC0xLFxuICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChjb2xsZWN0aW9uKTtcblxuICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVbaW5kZXhdLCBpbmRleCwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZUJhc2VFYWNoO1xuIiwiaW1wb3J0IGJhc2VGb3JPd24gZnJvbSAnLi9fYmFzZUZvck93bi5qcyc7XG5pbXBvcnQgY3JlYXRlQmFzZUVhY2ggZnJvbSAnLi9fY3JlYXRlQmFzZUVhY2guanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckVhY2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICovXG52YXIgYmFzZUVhY2ggPSBjcmVhdGVCYXNlRWFjaChiYXNlRm9yT3duKTtcblxuZXhwb3J0IGRlZmF1bHQgYmFzZUVhY2g7XG4iLCJpbXBvcnQgYmFzZUVhY2ggZnJvbSAnLi9fYmFzZUVhY2guanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbHRlcmAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlRmlsdGVyKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSkge1xuICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VGaWx0ZXI7XG4iLCJpbXBvcnQgYXJyYXlGaWx0ZXIgZnJvbSAnLi9fYXJyYXlGaWx0ZXIuanMnO1xuaW1wb3J0IGJhc2VGaWx0ZXIgZnJvbSAnLi9fYmFzZUZpbHRlci5qcyc7XG5pbXBvcnQgYmFzZUl0ZXJhdGVlIGZyb20gJy4vX2Jhc2VJdGVyYXRlZS5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuXG4vKipcbiAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gLCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgYWxsIGVsZW1lbnRzXG4gKiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHRocmVlXG4gKiBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAqXG4gKiAqKk5vdGU6KiogVW5saWtlIGBfLnJlbW92ZWAsIHRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICogQHNlZSBfLnJlamVjdFxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgdXNlcnMgPSBbXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAqIF07XG4gKlxuICogXy5maWx0ZXIodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XG4gKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnXVxuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbHRlcih1c2VycywgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0pO1xuICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmlsdGVyKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnXVxuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maWx0ZXIodXNlcnMsICdhY3RpdmUnKTtcbiAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAqL1xuZnVuY3Rpb24gZmlsdGVyKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUZpbHRlciA6IGJhc2VGaWx0ZXI7XG4gIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGJhc2VJdGVyYXRlZShwcmVkaWNhdGUsIDMpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZmlsdGVyO1xuIiwiaW1wb3J0IHsgZmlsdGVyIH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCB7IGlzTnVsbCB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgeyBtYXBLZXlzIH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCB7IGlzT2JqZWN0IH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCB7IGlzQm9vbGVhbiB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgeyBpc1VuZGVmaW5lZCB9IGZyb20gJ2xvZGFzaC1lcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHByZWZpeChzdWJqZWN0LCBwcmVmaXgsIGRlbGltZXRlciA9ICctJykge1xuICAgIGNvbnN0IHByZWZpeGVyID0gKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgY29uc3Qgc3RyaW5nID0ga2V5IHx8IHZhbHVlO1xuXG4gICAgICAgIHJldHVybiBmaWx0ZXIoW1xuICAgICAgICAgICAgcHJlZml4LFxuICAgICAgICAgICAgc3RyaW5nLnJlcGxhY2UobmV3IFJlZ0V4cChgXiR7cHJlZml4fSR7ZGVsaW1ldGVyfT9gKSwgJycpXG4gICAgICAgIF0pLmpvaW4oZGVsaW1ldGVyKTtcbiAgICB9XG5cbiAgICBpZihpc0Jvb2xlYW4oc3ViamVjdCkgfHwgaXNOdWxsKHN1YmplY3QpIHx8IGlzVW5kZWZpbmVkKHN1YmplY3QpKSB7XG4gICAgICAgIHJldHVybiBzdWJqZWN0O1xuICAgIH1cblxuICAgIGlmKGlzT2JqZWN0KHN1YmplY3QpKSB7XG4gICAgICAgIHJldHVybiBtYXBLZXlzKHN1YmplY3QsIHByZWZpeGVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJlZml4ZXIoc3ViamVjdCk7XG59XG4iLCJpbXBvcnQgcHJlZml4IGZyb20gJy4uLy4uL0hlbHBlcnMvUHJlZml4L1ByZWZpeCc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB2YXJpYW50IGF0dHJpYnV0ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICB2YXJpYW50OiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAncHJpbWFyeSdcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGNvbXB1dGVkOiB7XG5cbiAgICAgICAgdmFyaWFudENsYXNzUHJlZml4KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJG9wdGlvbnMubmFtZTtcbiAgICAgICAgfSxcblxuICAgICAgICB2YXJpYW50Q2xhc3MoKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJlZml4KHRoaXMudmFyaWFudCwgdGhpcy52YXJpYW50Q2xhc3NQcmVmaXgpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbn1cbiIsImltcG9ydCBwcmVmaXggZnJvbSAnLi4vLi4vSGVscGVycy9QcmVmaXgvUHJlZml4JztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgcHJvcHM6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNpemUgb2YgdGhlIGZvcm0gY29udHJvbFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBzaXplOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAnbWQnLFxuICAgICAgICAgICAgdmFsaWRhdGU6IHZhbHVlID0+IFsnc20nLCAnbWQnLCAnbGcnXS5pbmRleE9mKHZhbHVlKSAhPT0gLTFcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGNvbXB1dGVkOiB7XG5cbiAgICAgICAgc2l6ZWFibGVDbGFzc1ByZWZpeCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRvcHRpb25zLm5hbWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2l6ZWFibGVDbGFzcygpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmVmaXgodGhpcy5zaXplLCB0aGlzLnNpemVhYmxlQ2xhc3NQcmVmaXgpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbn1cbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2xpY2VgIHdpdGhvdXQgYW4gaXRlcmF0ZWUgY2FsbCBndWFyZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNsaWNlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VTbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAtc3RhcnQgPiBsZW5ndGggPyAwIDogKGxlbmd0aCArIHN0YXJ0KTtcbiAgfVxuICBlbmQgPSBlbmQgPiBsZW5ndGggPyBsZW5ndGggOiBlbmQ7XG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlbmd0aDtcbiAgfVxuICBsZW5ndGggPSBzdGFydCA+IGVuZCA/IDAgOiAoKGVuZCAtIHN0YXJ0KSA+Pj4gMCk7XG4gIHN0YXJ0ID4+Pj0gMDtcblxuICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gYXJyYXlbaW5kZXggKyBzdGFydF07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVNsaWNlO1xuIiwiaW1wb3J0IGJhc2VTbGljZSBmcm9tICcuL19iYXNlU2xpY2UuanMnO1xuXG4vKipcbiAqIENhc3RzIGBhcnJheWAgdG8gYSBzbGljZSBpZiBpdCdzIG5lZWRlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IHNsaWNlLlxuICovXG5mdW5jdGlvbiBjYXN0U2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiBlbmQ7XG4gIHJldHVybiAoIXN0YXJ0ICYmIGVuZCA+PSBsZW5ndGgpID8gYXJyYXkgOiBiYXNlU2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjYXN0U2xpY2U7XG4iLCIvKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2hhcmFjdGVyIGNsYXNzZXMuICovXG52YXIgcnNBc3RyYWxSYW5nZSA9ICdcXFxcdWQ4MDAtXFxcXHVkZmZmJyxcbiAgICByc0NvbWJvTWFya3NSYW5nZSA9ICdcXFxcdTAzMDAtXFxcXHUwMzZmJyxcbiAgICByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgPSAnXFxcXHVmZTIwLVxcXFx1ZmUyZicsXG4gICAgcnNDb21ib1N5bWJvbHNSYW5nZSA9ICdcXFxcdTIwZDAtXFxcXHUyMGZmJyxcbiAgICByc0NvbWJvUmFuZ2UgPSByc0NvbWJvTWFya3NSYW5nZSArIHJlQ29tYm9IYWxmTWFya3NSYW5nZSArIHJzQ29tYm9TeW1ib2xzUmFuZ2UsXG4gICAgcnNWYXJSYW5nZSA9ICdcXFxcdWZlMGVcXFxcdWZlMGYnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2FwdHVyZSBncm91cHMuICovXG52YXIgcnNaV0ogPSAnXFxcXHUyMDBkJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHN0cmluZ3Mgd2l0aCBbemVyby13aWR0aCBqb2luZXJzIG9yIGNvZGUgcG9pbnRzIGZyb20gdGhlIGFzdHJhbCBwbGFuZXNdKGh0dHA6Ly9lZXYuZWUvYmxvZy8yMDE1LzA5LzEyL2RhcmstY29ybmVycy1vZi11bmljb2RlLykuICovXG52YXIgcmVIYXNVbmljb2RlID0gUmVnRXhwKCdbJyArIHJzWldKICsgcnNBc3RyYWxSYW5nZSAgKyByc0NvbWJvUmFuZ2UgKyByc1ZhclJhbmdlICsgJ10nKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHN0cmluZ2AgY29udGFpbnMgVW5pY29kZSBzeW1ib2xzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhIHN5bWJvbCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNVbmljb2RlKHN0cmluZykge1xuICByZXR1cm4gcmVIYXNVbmljb2RlLnRlc3Qoc3RyaW5nKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaGFzVW5pY29kZTtcbiIsIi8qKlxuICogQ29udmVydHMgYW4gQVNDSUkgYHN0cmluZ2AgdG8gYW4gYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFzY2lpVG9BcnJheShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5zcGxpdCgnJyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFzY2lpVG9BcnJheTtcbiIsIi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjaGFyYWN0ZXIgY2xhc3Nlcy4gKi9cbnZhciByc0FzdHJhbFJhbmdlID0gJ1xcXFx1ZDgwMC1cXFxcdWRmZmYnLFxuICAgIHJzQ29tYm9NYXJrc1JhbmdlID0gJ1xcXFx1MDMwMC1cXFxcdTAzNmYnLFxuICAgIHJlQ29tYm9IYWxmTWFya3NSYW5nZSA9ICdcXFxcdWZlMjAtXFxcXHVmZTJmJyxcbiAgICByc0NvbWJvU3ltYm9sc1JhbmdlID0gJ1xcXFx1MjBkMC1cXFxcdTIwZmYnLFxuICAgIHJzQ29tYm9SYW5nZSA9IHJzQ29tYm9NYXJrc1JhbmdlICsgcmVDb21ib0hhbGZNYXJrc1JhbmdlICsgcnNDb21ib1N5bWJvbHNSYW5nZSxcbiAgICByc1ZhclJhbmdlID0gJ1xcXFx1ZmUwZVxcXFx1ZmUwZic7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjYXB0dXJlIGdyb3Vwcy4gKi9cbnZhciByc0FzdHJhbCA9ICdbJyArIHJzQXN0cmFsUmFuZ2UgKyAnXScsXG4gICAgcnNDb21ibyA9ICdbJyArIHJzQ29tYm9SYW5nZSArICddJyxcbiAgICByc0ZpdHogPSAnXFxcXHVkODNjW1xcXFx1ZGZmYi1cXFxcdWRmZmZdJyxcbiAgICByc01vZGlmaWVyID0gJyg/OicgKyByc0NvbWJvICsgJ3wnICsgcnNGaXR6ICsgJyknLFxuICAgIHJzTm9uQXN0cmFsID0gJ1teJyArIHJzQXN0cmFsUmFuZ2UgKyAnXScsXG4gICAgcnNSZWdpb25hbCA9ICcoPzpcXFxcdWQ4M2NbXFxcXHVkZGU2LVxcXFx1ZGRmZl0pezJ9JyxcbiAgICByc1N1cnJQYWlyID0gJ1tcXFxcdWQ4MDAtXFxcXHVkYmZmXVtcXFxcdWRjMDAtXFxcXHVkZmZmXScsXG4gICAgcnNaV0ogPSAnXFxcXHUyMDBkJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIHJlZ2V4ZXMuICovXG52YXIgcmVPcHRNb2QgPSByc01vZGlmaWVyICsgJz8nLFxuICAgIHJzT3B0VmFyID0gJ1snICsgcnNWYXJSYW5nZSArICddPycsXG4gICAgcnNPcHRKb2luID0gJyg/OicgKyByc1pXSiArICcoPzonICsgW3JzTm9uQXN0cmFsLCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyXS5qb2luKCd8JykgKyAnKScgKyByc09wdFZhciArIHJlT3B0TW9kICsgJykqJyxcbiAgICByc1NlcSA9IHJzT3B0VmFyICsgcmVPcHRNb2QgKyByc09wdEpvaW4sXG4gICAgcnNTeW1ib2wgPSAnKD86JyArIFtyc05vbkFzdHJhbCArIHJzQ29tYm8gKyAnPycsIHJzQ29tYm8sIHJzUmVnaW9uYWwsIHJzU3VyclBhaXIsIHJzQXN0cmFsXS5qb2luKCd8JykgKyAnKSc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIFtzdHJpbmcgc3ltYm9sc10oaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtdW5pY29kZSkuICovXG52YXIgcmVVbmljb2RlID0gUmVnRXhwKHJzRml0eiArICcoPz0nICsgcnNGaXR6ICsgJyl8JyArIHJzU3ltYm9sICsgcnNTZXEsICdnJyk7XG5cbi8qKlxuICogQ29udmVydHMgYSBVbmljb2RlIGBzdHJpbmdgIHRvIGFuIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiB1bmljb2RlVG9BcnJheShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5tYXRjaChyZVVuaWNvZGUpIHx8IFtdO1xufVxuXG5leHBvcnQgZGVmYXVsdCB1bmljb2RlVG9BcnJheTtcbiIsImltcG9ydCBhc2NpaVRvQXJyYXkgZnJvbSAnLi9fYXNjaWlUb0FycmF5LmpzJztcbmltcG9ydCBoYXNVbmljb2RlIGZyb20gJy4vX2hhc1VuaWNvZGUuanMnO1xuaW1wb3J0IHVuaWNvZGVUb0FycmF5IGZyb20gJy4vX3VuaWNvZGVUb0FycmF5LmpzJztcblxuLyoqXG4gKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhbiBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gc3RyaW5nVG9BcnJheShzdHJpbmcpIHtcbiAgcmV0dXJuIGhhc1VuaWNvZGUoc3RyaW5nKVxuICAgID8gdW5pY29kZVRvQXJyYXkoc3RyaW5nKVxuICAgIDogYXNjaWlUb0FycmF5KHN0cmluZyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0cmluZ1RvQXJyYXk7XG4iLCJpbXBvcnQgY2FzdFNsaWNlIGZyb20gJy4vX2Nhc3RTbGljZS5qcyc7XG5pbXBvcnQgaGFzVW5pY29kZSBmcm9tICcuL19oYXNVbmljb2RlLmpzJztcbmltcG9ydCBzdHJpbmdUb0FycmF5IGZyb20gJy4vX3N0cmluZ1RvQXJyYXkuanMnO1xuaW1wb3J0IHRvU3RyaW5nIGZyb20gJy4vdG9TdHJpbmcuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmxvd2VyRmlyc3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZSBUaGUgbmFtZSBvZiB0aGUgYFN0cmluZ2AgY2FzZSBtZXRob2QgdG8gdXNlLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2FzZUZpcnN0KG1ldGhvZE5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG5cbiAgICB2YXIgc3RyU3ltYm9scyA9IGhhc1VuaWNvZGUoc3RyaW5nKVxuICAgICAgPyBzdHJpbmdUb0FycmF5KHN0cmluZylcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgdmFyIGNociA9IHN0clN5bWJvbHNcbiAgICAgID8gc3RyU3ltYm9sc1swXVxuICAgICAgOiBzdHJpbmcuY2hhckF0KDApO1xuXG4gICAgdmFyIHRyYWlsaW5nID0gc3RyU3ltYm9sc1xuICAgICAgPyBjYXN0U2xpY2Uoc3RyU3ltYm9scywgMSkuam9pbignJylcbiAgICAgIDogc3RyaW5nLnNsaWNlKDEpO1xuXG4gICAgcmV0dXJuIGNoclttZXRob2ROYW1lXSgpICsgdHJhaWxpbmc7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZUNhc2VGaXJzdDtcbiIsImltcG9ydCBjcmVhdGVDYXNlRmlyc3QgZnJvbSAnLi9fY3JlYXRlQ2FzZUZpcnN0LmpzJztcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGBzdHJpbmdgIHRvIHVwcGVyIGNhc2UuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udXBwZXJGaXJzdCgnZnJlZCcpO1xuICogLy8gPT4gJ0ZyZWQnXG4gKlxuICogXy51cHBlckZpcnN0KCdGUkVEJyk7XG4gKiAvLyA9PiAnRlJFRCdcbiAqL1xudmFyIHVwcGVyRmlyc3QgPSBjcmVhdGVDYXNlRmlyc3QoJ3RvVXBwZXJDYXNlJyk7XG5cbmV4cG9ydCBkZWZhdWx0IHVwcGVyRmlyc3Q7XG4iLCJpbXBvcnQgdG9TdHJpbmcgZnJvbSAnLi90b1N0cmluZy5qcyc7XG5pbXBvcnQgdXBwZXJGaXJzdCBmcm9tICcuL3VwcGVyRmlyc3QuanMnO1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYHN0cmluZ2AgdG8gdXBwZXIgY2FzZSBhbmQgdGhlIHJlbWFpbmluZ1xuICogdG8gbG93ZXIgY2FzZS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjYXBpdGFsaXplLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY2FwaXRhbGl6ZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmNhcGl0YWxpemUoJ0ZSRUQnKTtcbiAqIC8vID0+ICdGcmVkJ1xuICovXG5mdW5jdGlvbiBjYXBpdGFsaXplKHN0cmluZykge1xuICByZXR1cm4gdXBwZXJGaXJzdCh0b1N0cmluZyhzdHJpbmcpLnRvTG93ZXJDYXNlKCkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjYXBpdGFsaXplO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ucmVkdWNlYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbml0QWNjdW1dIFNwZWNpZnkgdXNpbmcgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YCBhc1xuICogIHRoZSBpbml0aWFsIHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBhcnJheVJlZHVjZShhcnJheSwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0pIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICBpZiAoaW5pdEFjY3VtICYmIGxlbmd0aCkge1xuICAgIGFjY3VtdWxhdG9yID0gYXJyYXlbKytpbmRleF07XG4gIH1cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhY2N1bXVsYXRvciA9IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCBhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIGFjY3VtdWxhdG9yO1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheVJlZHVjZTtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlPZmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5T2Yob2JqZWN0KSB7XG4gIHJldHVybiBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVByb3BlcnR5T2Y7XG4iLCJpbXBvcnQgYmFzZVByb3BlcnR5T2YgZnJvbSAnLi9fYmFzZVByb3BlcnR5T2YuanMnO1xuXG4vKiogVXNlZCB0byBtYXAgTGF0aW4gVW5pY29kZSBsZXR0ZXJzIHRvIGJhc2ljIExhdGluIGxldHRlcnMuICovXG52YXIgZGVidXJyZWRMZXR0ZXJzID0ge1xuICAvLyBMYXRpbi0xIFN1cHBsZW1lbnQgYmxvY2suXG4gICdcXHhjMCc6ICdBJywgICdcXHhjMSc6ICdBJywgJ1xceGMyJzogJ0EnLCAnXFx4YzMnOiAnQScsICdcXHhjNCc6ICdBJywgJ1xceGM1JzogJ0EnLFxuICAnXFx4ZTAnOiAnYScsICAnXFx4ZTEnOiAnYScsICdcXHhlMic6ICdhJywgJ1xceGUzJzogJ2EnLCAnXFx4ZTQnOiAnYScsICdcXHhlNSc6ICdhJyxcbiAgJ1xceGM3JzogJ0MnLCAgJ1xceGU3JzogJ2MnLFxuICAnXFx4ZDAnOiAnRCcsICAnXFx4ZjAnOiAnZCcsXG4gICdcXHhjOCc6ICdFJywgICdcXHhjOSc6ICdFJywgJ1xceGNhJzogJ0UnLCAnXFx4Y2InOiAnRScsXG4gICdcXHhlOCc6ICdlJywgICdcXHhlOSc6ICdlJywgJ1xceGVhJzogJ2UnLCAnXFx4ZWInOiAnZScsXG4gICdcXHhjYyc6ICdJJywgICdcXHhjZCc6ICdJJywgJ1xceGNlJzogJ0knLCAnXFx4Y2YnOiAnSScsXG4gICdcXHhlYyc6ICdpJywgICdcXHhlZCc6ICdpJywgJ1xceGVlJzogJ2knLCAnXFx4ZWYnOiAnaScsXG4gICdcXHhkMSc6ICdOJywgICdcXHhmMSc6ICduJyxcbiAgJ1xceGQyJzogJ08nLCAgJ1xceGQzJzogJ08nLCAnXFx4ZDQnOiAnTycsICdcXHhkNSc6ICdPJywgJ1xceGQ2JzogJ08nLCAnXFx4ZDgnOiAnTycsXG4gICdcXHhmMic6ICdvJywgICdcXHhmMyc6ICdvJywgJ1xceGY0JzogJ28nLCAnXFx4ZjUnOiAnbycsICdcXHhmNic6ICdvJywgJ1xceGY4JzogJ28nLFxuICAnXFx4ZDknOiAnVScsICAnXFx4ZGEnOiAnVScsICdcXHhkYic6ICdVJywgJ1xceGRjJzogJ1UnLFxuICAnXFx4ZjknOiAndScsICAnXFx4ZmEnOiAndScsICdcXHhmYic6ICd1JywgJ1xceGZjJzogJ3UnLFxuICAnXFx4ZGQnOiAnWScsICAnXFx4ZmQnOiAneScsICdcXHhmZic6ICd5JyxcbiAgJ1xceGM2JzogJ0FlJywgJ1xceGU2JzogJ2FlJyxcbiAgJ1xceGRlJzogJ1RoJywgJ1xceGZlJzogJ3RoJyxcbiAgJ1xceGRmJzogJ3NzJyxcbiAgLy8gTGF0aW4gRXh0ZW5kZWQtQSBibG9jay5cbiAgJ1xcdTAxMDAnOiAnQScsICAnXFx1MDEwMic6ICdBJywgJ1xcdTAxMDQnOiAnQScsXG4gICdcXHUwMTAxJzogJ2EnLCAgJ1xcdTAxMDMnOiAnYScsICdcXHUwMTA1JzogJ2EnLFxuICAnXFx1MDEwNic6ICdDJywgICdcXHUwMTA4JzogJ0MnLCAnXFx1MDEwYSc6ICdDJywgJ1xcdTAxMGMnOiAnQycsXG4gICdcXHUwMTA3JzogJ2MnLCAgJ1xcdTAxMDknOiAnYycsICdcXHUwMTBiJzogJ2MnLCAnXFx1MDEwZCc6ICdjJyxcbiAgJ1xcdTAxMGUnOiAnRCcsICAnXFx1MDExMCc6ICdEJywgJ1xcdTAxMGYnOiAnZCcsICdcXHUwMTExJzogJ2QnLFxuICAnXFx1MDExMic6ICdFJywgICdcXHUwMTE0JzogJ0UnLCAnXFx1MDExNic6ICdFJywgJ1xcdTAxMTgnOiAnRScsICdcXHUwMTFhJzogJ0UnLFxuICAnXFx1MDExMyc6ICdlJywgICdcXHUwMTE1JzogJ2UnLCAnXFx1MDExNyc6ICdlJywgJ1xcdTAxMTknOiAnZScsICdcXHUwMTFiJzogJ2UnLFxuICAnXFx1MDExYyc6ICdHJywgICdcXHUwMTFlJzogJ0cnLCAnXFx1MDEyMCc6ICdHJywgJ1xcdTAxMjInOiAnRycsXG4gICdcXHUwMTFkJzogJ2cnLCAgJ1xcdTAxMWYnOiAnZycsICdcXHUwMTIxJzogJ2cnLCAnXFx1MDEyMyc6ICdnJyxcbiAgJ1xcdTAxMjQnOiAnSCcsICAnXFx1MDEyNic6ICdIJywgJ1xcdTAxMjUnOiAnaCcsICdcXHUwMTI3JzogJ2gnLFxuICAnXFx1MDEyOCc6ICdJJywgICdcXHUwMTJhJzogJ0knLCAnXFx1MDEyYyc6ICdJJywgJ1xcdTAxMmUnOiAnSScsICdcXHUwMTMwJzogJ0knLFxuICAnXFx1MDEyOSc6ICdpJywgICdcXHUwMTJiJzogJ2knLCAnXFx1MDEyZCc6ICdpJywgJ1xcdTAxMmYnOiAnaScsICdcXHUwMTMxJzogJ2knLFxuICAnXFx1MDEzNCc6ICdKJywgICdcXHUwMTM1JzogJ2onLFxuICAnXFx1MDEzNic6ICdLJywgICdcXHUwMTM3JzogJ2snLCAnXFx1MDEzOCc6ICdrJyxcbiAgJ1xcdTAxMzknOiAnTCcsICAnXFx1MDEzYic6ICdMJywgJ1xcdTAxM2QnOiAnTCcsICdcXHUwMTNmJzogJ0wnLCAnXFx1MDE0MSc6ICdMJyxcbiAgJ1xcdTAxM2EnOiAnbCcsICAnXFx1MDEzYyc6ICdsJywgJ1xcdTAxM2UnOiAnbCcsICdcXHUwMTQwJzogJ2wnLCAnXFx1MDE0Mic6ICdsJyxcbiAgJ1xcdTAxNDMnOiAnTicsICAnXFx1MDE0NSc6ICdOJywgJ1xcdTAxNDcnOiAnTicsICdcXHUwMTRhJzogJ04nLFxuICAnXFx1MDE0NCc6ICduJywgICdcXHUwMTQ2JzogJ24nLCAnXFx1MDE0OCc6ICduJywgJ1xcdTAxNGInOiAnbicsXG4gICdcXHUwMTRjJzogJ08nLCAgJ1xcdTAxNGUnOiAnTycsICdcXHUwMTUwJzogJ08nLFxuICAnXFx1MDE0ZCc6ICdvJywgICdcXHUwMTRmJzogJ28nLCAnXFx1MDE1MSc6ICdvJyxcbiAgJ1xcdTAxNTQnOiAnUicsICAnXFx1MDE1Nic6ICdSJywgJ1xcdTAxNTgnOiAnUicsXG4gICdcXHUwMTU1JzogJ3InLCAgJ1xcdTAxNTcnOiAncicsICdcXHUwMTU5JzogJ3InLFxuICAnXFx1MDE1YSc6ICdTJywgICdcXHUwMTVjJzogJ1MnLCAnXFx1MDE1ZSc6ICdTJywgJ1xcdTAxNjAnOiAnUycsXG4gICdcXHUwMTViJzogJ3MnLCAgJ1xcdTAxNWQnOiAncycsICdcXHUwMTVmJzogJ3MnLCAnXFx1MDE2MSc6ICdzJyxcbiAgJ1xcdTAxNjInOiAnVCcsICAnXFx1MDE2NCc6ICdUJywgJ1xcdTAxNjYnOiAnVCcsXG4gICdcXHUwMTYzJzogJ3QnLCAgJ1xcdTAxNjUnOiAndCcsICdcXHUwMTY3JzogJ3QnLFxuICAnXFx1MDE2OCc6ICdVJywgICdcXHUwMTZhJzogJ1UnLCAnXFx1MDE2Yyc6ICdVJywgJ1xcdTAxNmUnOiAnVScsICdcXHUwMTcwJzogJ1UnLCAnXFx1MDE3Mic6ICdVJyxcbiAgJ1xcdTAxNjknOiAndScsICAnXFx1MDE2Yic6ICd1JywgJ1xcdTAxNmQnOiAndScsICdcXHUwMTZmJzogJ3UnLCAnXFx1MDE3MSc6ICd1JywgJ1xcdTAxNzMnOiAndScsXG4gICdcXHUwMTc0JzogJ1cnLCAgJ1xcdTAxNzUnOiAndycsXG4gICdcXHUwMTc2JzogJ1knLCAgJ1xcdTAxNzcnOiAneScsICdcXHUwMTc4JzogJ1knLFxuICAnXFx1MDE3OSc6ICdaJywgICdcXHUwMTdiJzogJ1onLCAnXFx1MDE3ZCc6ICdaJyxcbiAgJ1xcdTAxN2EnOiAneicsICAnXFx1MDE3Yyc6ICd6JywgJ1xcdTAxN2UnOiAneicsXG4gICdcXHUwMTMyJzogJ0lKJywgJ1xcdTAxMzMnOiAnaWonLFxuICAnXFx1MDE1Mic6ICdPZScsICdcXHUwMTUzJzogJ29lJyxcbiAgJ1xcdTAxNDknOiBcIiduXCIsICdcXHUwMTdmJzogJ3MnXG59O1xuXG4vKipcbiAqIFVzZWQgYnkgYF8uZGVidXJyYCB0byBjb252ZXJ0IExhdGluLTEgU3VwcGxlbWVudCBhbmQgTGF0aW4gRXh0ZW5kZWQtQVxuICogbGV0dGVycyB0byBiYXNpYyBMYXRpbiBsZXR0ZXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gbGV0dGVyIFRoZSBtYXRjaGVkIGxldHRlciB0byBkZWJ1cnIuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBkZWJ1cnJlZCBsZXR0ZXIuXG4gKi9cbnZhciBkZWJ1cnJMZXR0ZXIgPSBiYXNlUHJvcGVydHlPZihkZWJ1cnJlZExldHRlcnMpO1xuXG5leHBvcnQgZGVmYXVsdCBkZWJ1cnJMZXR0ZXI7XG4iLCJpbXBvcnQgZGVidXJyTGV0dGVyIGZyb20gJy4vX2RlYnVyckxldHRlci5qcyc7XG5pbXBvcnQgdG9TdHJpbmcgZnJvbSAnLi90b1N0cmluZy5qcyc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIExhdGluIFVuaWNvZGUgbGV0dGVycyAoZXhjbHVkaW5nIG1hdGhlbWF0aWNhbCBvcGVyYXRvcnMpLiAqL1xudmFyIHJlTGF0aW4gPSAvW1xceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHhmZlxcdTAxMDAtXFx1MDE3Zl0vZztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNoYXJhY3RlciBjbGFzc2VzLiAqL1xudmFyIHJzQ29tYm9NYXJrc1JhbmdlID0gJ1xcXFx1MDMwMC1cXFxcdTAzNmYnLFxuICAgIHJlQ29tYm9IYWxmTWFya3NSYW5nZSA9ICdcXFxcdWZlMjAtXFxcXHVmZTJmJyxcbiAgICByc0NvbWJvU3ltYm9sc1JhbmdlID0gJ1xcXFx1MjBkMC1cXFxcdTIwZmYnLFxuICAgIHJzQ29tYm9SYW5nZSA9IHJzQ29tYm9NYXJrc1JhbmdlICsgcmVDb21ib0hhbGZNYXJrc1JhbmdlICsgcnNDb21ib1N5bWJvbHNSYW5nZTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNhcHR1cmUgZ3JvdXBzLiAqL1xudmFyIHJzQ29tYm8gPSAnWycgKyByc0NvbWJvUmFuZ2UgKyAnXSc7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBbY29tYmluaW5nIGRpYWNyaXRpY2FsIG1hcmtzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3MpIGFuZFxuICogW2NvbWJpbmluZyBkaWFjcml0aWNhbCBtYXJrcyBmb3Igc3ltYm9sc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzX2Zvcl9TeW1ib2xzKS5cbiAqL1xudmFyIHJlQ29tYm9NYXJrID0gUmVnRXhwKHJzQ29tYm8sICdnJyk7XG5cbi8qKlxuICogRGVidXJycyBgc3RyaW5nYCBieSBjb252ZXJ0aW5nXG4gKiBbTGF0aW4tMSBTdXBwbGVtZW50XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MYXRpbi0xX1N1cHBsZW1lbnRfKFVuaWNvZGVfYmxvY2spI0NoYXJhY3Rlcl90YWJsZSlcbiAqIGFuZCBbTGF0aW4gRXh0ZW5kZWQtQV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGF0aW5fRXh0ZW5kZWQtQSlcbiAqIGxldHRlcnMgdG8gYmFzaWMgTGF0aW4gbGV0dGVycyBhbmQgcmVtb3ZpbmdcbiAqIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3NdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrcykuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gZGVidXJyLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZGVidXJyZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmRlYnVycignZMOpasOgIHZ1Jyk7XG4gKiAvLyA9PiAnZGVqYSB2dSdcbiAqL1xuZnVuY3Rpb24gZGVidXJyKHN0cmluZykge1xuICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICByZXR1cm4gc3RyaW5nICYmIHN0cmluZy5yZXBsYWNlKHJlTGF0aW4sIGRlYnVyckxldHRlcikucmVwbGFjZShyZUNvbWJvTWFyaywgJycpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBkZWJ1cnI7XG4iLCIvKiogVXNlZCB0byBtYXRjaCB3b3JkcyBjb21wb3NlZCBvZiBhbHBoYW51bWVyaWMgY2hhcmFjdGVycy4gKi9cbnZhciByZUFzY2lpV29yZCA9IC9bXlxceDAwLVxceDJmXFx4M2EtXFx4NDBcXHg1Yi1cXHg2MFxceDdiLVxceDdmXSsvZztcblxuLyoqXG4gKiBTcGxpdHMgYW4gQVNDSUkgYHN0cmluZ2AgaW50byBhbiBhcnJheSBvZiBpdHMgd29yZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdvcmRzIG9mIGBzdHJpbmdgLlxuICovXG5mdW5jdGlvbiBhc2NpaVdvcmRzKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlQXNjaWlXb3JkKSB8fCBbXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXNjaWlXb3JkcztcbiIsIi8qKiBVc2VkIHRvIGRldGVjdCBzdHJpbmdzIHRoYXQgbmVlZCBhIG1vcmUgcm9idXN0IHJlZ2V4cCB0byBtYXRjaCB3b3Jkcy4gKi9cbnZhciByZUhhc1VuaWNvZGVXb3JkID0gL1thLXpdW0EtWl18W0EtWl17Mix9W2Etel18WzAtOV1bYS16QS1aXXxbYS16QS1aXVswLTldfFteYS16QS1aMC05IF0vO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgc3RyaW5nYCBjb250YWlucyBhIHdvcmQgY29tcG9zZWQgb2YgVW5pY29kZSBzeW1ib2xzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhIHdvcmQgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzVW5pY29kZVdvcmQoc3RyaW5nKSB7XG4gIHJldHVybiByZUhhc1VuaWNvZGVXb3JkLnRlc3Qoc3RyaW5nKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaGFzVW5pY29kZVdvcmQ7XG4iLCIvKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2hhcmFjdGVyIGNsYXNzZXMuICovXG52YXIgcnNBc3RyYWxSYW5nZSA9ICdcXFxcdWQ4MDAtXFxcXHVkZmZmJyxcbiAgICByc0NvbWJvTWFya3NSYW5nZSA9ICdcXFxcdTAzMDAtXFxcXHUwMzZmJyxcbiAgICByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgPSAnXFxcXHVmZTIwLVxcXFx1ZmUyZicsXG4gICAgcnNDb21ib1N5bWJvbHNSYW5nZSA9ICdcXFxcdTIwZDAtXFxcXHUyMGZmJyxcbiAgICByc0NvbWJvUmFuZ2UgPSByc0NvbWJvTWFya3NSYW5nZSArIHJlQ29tYm9IYWxmTWFya3NSYW5nZSArIHJzQ29tYm9TeW1ib2xzUmFuZ2UsXG4gICAgcnNEaW5nYmF0UmFuZ2UgPSAnXFxcXHUyNzAwLVxcXFx1MjdiZicsXG4gICAgcnNMb3dlclJhbmdlID0gJ2EtelxcXFx4ZGYtXFxcXHhmNlxcXFx4ZjgtXFxcXHhmZicsXG4gICAgcnNNYXRoT3BSYW5nZSA9ICdcXFxceGFjXFxcXHhiMVxcXFx4ZDdcXFxceGY3JyxcbiAgICByc05vbkNoYXJSYW5nZSA9ICdcXFxceDAwLVxcXFx4MmZcXFxceDNhLVxcXFx4NDBcXFxceDViLVxcXFx4NjBcXFxceDdiLVxcXFx4YmYnLFxuICAgIHJzUHVuY3R1YXRpb25SYW5nZSA9ICdcXFxcdTIwMDAtXFxcXHUyMDZmJyxcbiAgICByc1NwYWNlUmFuZ2UgPSAnIFxcXFx0XFxcXHgwYlxcXFxmXFxcXHhhMFxcXFx1ZmVmZlxcXFxuXFxcXHJcXFxcdTIwMjhcXFxcdTIwMjlcXFxcdTE2ODBcXFxcdTE4MGVcXFxcdTIwMDBcXFxcdTIwMDFcXFxcdTIwMDJcXFxcdTIwMDNcXFxcdTIwMDRcXFxcdTIwMDVcXFxcdTIwMDZcXFxcdTIwMDdcXFxcdTIwMDhcXFxcdTIwMDlcXFxcdTIwMGFcXFxcdTIwMmZcXFxcdTIwNWZcXFxcdTMwMDAnLFxuICAgIHJzVXBwZXJSYW5nZSA9ICdBLVpcXFxceGMwLVxcXFx4ZDZcXFxceGQ4LVxcXFx4ZGUnLFxuICAgIHJzVmFyUmFuZ2UgPSAnXFxcXHVmZTBlXFxcXHVmZTBmJyxcbiAgICByc0JyZWFrUmFuZ2UgPSByc01hdGhPcFJhbmdlICsgcnNOb25DaGFyUmFuZ2UgKyByc1B1bmN0dWF0aW9uUmFuZ2UgKyByc1NwYWNlUmFuZ2U7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjYXB0dXJlIGdyb3Vwcy4gKi9cbnZhciByc0Fwb3MgPSBcIlsnXFx1MjAxOV1cIixcbiAgICByc0JyZWFrID0gJ1snICsgcnNCcmVha1JhbmdlICsgJ10nLFxuICAgIHJzQ29tYm8gPSAnWycgKyByc0NvbWJvUmFuZ2UgKyAnXScsXG4gICAgcnNEaWdpdHMgPSAnXFxcXGQrJyxcbiAgICByc0RpbmdiYXQgPSAnWycgKyByc0RpbmdiYXRSYW5nZSArICddJyxcbiAgICByc0xvd2VyID0gJ1snICsgcnNMb3dlclJhbmdlICsgJ10nLFxuICAgIHJzTWlzYyA9ICdbXicgKyByc0FzdHJhbFJhbmdlICsgcnNCcmVha1JhbmdlICsgcnNEaWdpdHMgKyByc0RpbmdiYXRSYW5nZSArIHJzTG93ZXJSYW5nZSArIHJzVXBwZXJSYW5nZSArICddJyxcbiAgICByc0ZpdHogPSAnXFxcXHVkODNjW1xcXFx1ZGZmYi1cXFxcdWRmZmZdJyxcbiAgICByc01vZGlmaWVyID0gJyg/OicgKyByc0NvbWJvICsgJ3wnICsgcnNGaXR6ICsgJyknLFxuICAgIHJzTm9uQXN0cmFsID0gJ1teJyArIHJzQXN0cmFsUmFuZ2UgKyAnXScsXG4gICAgcnNSZWdpb25hbCA9ICcoPzpcXFxcdWQ4M2NbXFxcXHVkZGU2LVxcXFx1ZGRmZl0pezJ9JyxcbiAgICByc1N1cnJQYWlyID0gJ1tcXFxcdWQ4MDAtXFxcXHVkYmZmXVtcXFxcdWRjMDAtXFxcXHVkZmZmXScsXG4gICAgcnNVcHBlciA9ICdbJyArIHJzVXBwZXJSYW5nZSArICddJyxcbiAgICByc1pXSiA9ICdcXFxcdTIwMGQnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgcmVnZXhlcy4gKi9cbnZhciByc01pc2NMb3dlciA9ICcoPzonICsgcnNMb3dlciArICd8JyArIHJzTWlzYyArICcpJyxcbiAgICByc01pc2NVcHBlciA9ICcoPzonICsgcnNVcHBlciArICd8JyArIHJzTWlzYyArICcpJyxcbiAgICByc09wdENvbnRyTG93ZXIgPSAnKD86JyArIHJzQXBvcyArICcoPzpkfGxsfG18cmV8c3x0fHZlKSk/JyxcbiAgICByc09wdENvbnRyVXBwZXIgPSAnKD86JyArIHJzQXBvcyArICcoPzpEfExMfE18UkV8U3xUfFZFKSk/JyxcbiAgICByZU9wdE1vZCA9IHJzTW9kaWZpZXIgKyAnPycsXG4gICAgcnNPcHRWYXIgPSAnWycgKyByc1ZhclJhbmdlICsgJ10/JyxcbiAgICByc09wdEpvaW4gPSAnKD86JyArIHJzWldKICsgJyg/OicgKyBbcnNOb25Bc3RyYWwsIHJzUmVnaW9uYWwsIHJzU3VyclBhaXJdLmpvaW4oJ3wnKSArICcpJyArIHJzT3B0VmFyICsgcmVPcHRNb2QgKyAnKSonLFxuICAgIHJzT3JkTG93ZXIgPSAnXFxcXGQqKD86MXN0fDJuZHwzcmR8KD8hWzEyM10pXFxcXGR0aCkoPz1cXFxcYnxbQS1aX10pJyxcbiAgICByc09yZFVwcGVyID0gJ1xcXFxkKig/OjFTVHwyTkR8M1JEfCg/IVsxMjNdKVxcXFxkVEgpKD89XFxcXGJ8W2Etel9dKScsXG4gICAgcnNTZXEgPSByc09wdFZhciArIHJlT3B0TW9kICsgcnNPcHRKb2luLFxuICAgIHJzRW1vamkgPSAnKD86JyArIFtyc0RpbmdiYXQsIHJzUmVnaW9uYWwsIHJzU3VyclBhaXJdLmpvaW4oJ3wnKSArICcpJyArIHJzU2VxO1xuXG4vKiogVXNlZCB0byBtYXRjaCBjb21wbGV4IG9yIGNvbXBvdW5kIHdvcmRzLiAqL1xudmFyIHJlVW5pY29kZVdvcmQgPSBSZWdFeHAoW1xuICByc1VwcGVyICsgJz8nICsgcnNMb3dlciArICcrJyArIHJzT3B0Q29udHJMb3dlciArICcoPz0nICsgW3JzQnJlYWssIHJzVXBwZXIsICckJ10uam9pbignfCcpICsgJyknLFxuICByc01pc2NVcHBlciArICcrJyArIHJzT3B0Q29udHJVcHBlciArICcoPz0nICsgW3JzQnJlYWssIHJzVXBwZXIgKyByc01pc2NMb3dlciwgJyQnXS5qb2luKCd8JykgKyAnKScsXG4gIHJzVXBwZXIgKyAnPycgKyByc01pc2NMb3dlciArICcrJyArIHJzT3B0Q29udHJMb3dlcixcbiAgcnNVcHBlciArICcrJyArIHJzT3B0Q29udHJVcHBlcixcbiAgcnNPcmRVcHBlcixcbiAgcnNPcmRMb3dlcixcbiAgcnNEaWdpdHMsXG4gIHJzRW1vamlcbl0uam9pbignfCcpLCAnZycpO1xuXG4vKipcbiAqIFNwbGl0cyBhIFVuaWNvZGUgYHN0cmluZ2AgaW50byBhbiBhcnJheSBvZiBpdHMgd29yZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdvcmRzIG9mIGBzdHJpbmdgLlxuICovXG5mdW5jdGlvbiB1bmljb2RlV29yZHMoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcubWF0Y2gocmVVbmljb2RlV29yZCkgfHwgW107XG59XG5cbmV4cG9ydCBkZWZhdWx0IHVuaWNvZGVXb3JkcztcbiIsImltcG9ydCBhc2NpaVdvcmRzIGZyb20gJy4vX2FzY2lpV29yZHMuanMnO1xuaW1wb3J0IGhhc1VuaWNvZGVXb3JkIGZyb20gJy4vX2hhc1VuaWNvZGVXb3JkLmpzJztcbmltcG9ydCB0b1N0cmluZyBmcm9tICcuL3RvU3RyaW5nLmpzJztcbmltcG9ydCB1bmljb2RlV29yZHMgZnJvbSAnLi9fdW5pY29kZVdvcmRzLmpzJztcblxuLyoqXG4gKiBTcGxpdHMgYHN0cmluZ2AgaW50byBhbiBhcnJheSBvZiBpdHMgd29yZHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7UmVnRXhwfHN0cmluZ30gW3BhdHRlcm5dIFRoZSBwYXR0ZXJuIHRvIG1hdGNoIHdvcmRzLlxuICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgd29yZHMgb2YgYHN0cmluZ2AuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8ud29yZHMoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJyk7XG4gKiAvLyA9PiBbJ2ZyZWQnLCAnYmFybmV5JywgJ3BlYmJsZXMnXVxuICpcbiAqIF8ud29yZHMoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJywgL1teLCBdKy9nKTtcbiAqIC8vID0+IFsnZnJlZCcsICdiYXJuZXknLCAnJicsICdwZWJibGVzJ11cbiAqL1xuZnVuY3Rpb24gd29yZHMoc3RyaW5nLCBwYXR0ZXJuLCBndWFyZCkge1xuICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICBwYXR0ZXJuID0gZ3VhcmQgPyB1bmRlZmluZWQgOiBwYXR0ZXJuO1xuXG4gIGlmIChwYXR0ZXJuID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gaGFzVW5pY29kZVdvcmQoc3RyaW5nKSA/IHVuaWNvZGVXb3JkcyhzdHJpbmcpIDogYXNjaWlXb3JkcyhzdHJpbmcpO1xuICB9XG4gIHJldHVybiBzdHJpbmcubWF0Y2gocGF0dGVybikgfHwgW107XG59XG5cbmV4cG9ydCBkZWZhdWx0IHdvcmRzO1xuIiwiaW1wb3J0IGFycmF5UmVkdWNlIGZyb20gJy4vX2FycmF5UmVkdWNlLmpzJztcbmltcG9ydCBkZWJ1cnIgZnJvbSAnLi9kZWJ1cnIuanMnO1xuaW1wb3J0IHdvcmRzIGZyb20gJy4vd29yZHMuanMnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2FwdHVyZSBncm91cHMuICovXG52YXIgcnNBcG9zID0gXCJbJ1xcdTIwMTldXCI7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGFwb3N0cm9waGVzLiAqL1xudmFyIHJlQXBvcyA9IFJlZ0V4cChyc0Fwb3MsICdnJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uY2FtZWxDYXNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGNvbWJpbmUgZWFjaCB3b3JkLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29tcG91bmRlciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ29tcG91bmRlcihjYWxsYmFjaykge1xuICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgcmV0dXJuIGFycmF5UmVkdWNlKHdvcmRzKGRlYnVycihzdHJpbmcpLnJlcGxhY2UocmVBcG9zLCAnJykpLCBjYWxsYmFjaywgJycpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVDb21wb3VuZGVyO1xuIiwiaW1wb3J0IGNhcGl0YWxpemUgZnJvbSAnLi9jYXBpdGFsaXplLmpzJztcbmltcG9ydCBjcmVhdGVDb21wb3VuZGVyIGZyb20gJy4vX2NyZWF0ZUNvbXBvdW5kZXIuanMnO1xuXG4vKipcbiAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIFtjYW1lbCBjYXNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DYW1lbENhc2UpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjYW1lbCBjYXNlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uY2FtZWxDYXNlKCdGb28gQmFyJyk7XG4gKiAvLyA9PiAnZm9vQmFyJ1xuICpcbiAqIF8uY2FtZWxDYXNlKCctLWZvby1iYXItLScpO1xuICogLy8gPT4gJ2Zvb0JhcidcbiAqXG4gKiBfLmNhbWVsQ2FzZSgnX19GT09fQkFSX18nKTtcbiAqIC8vID0+ICdmb29CYXInXG4gKi9cbnZhciBjYW1lbENhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgd29yZCA9IHdvcmQudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/IGNhcGl0YWxpemUod29yZCkgOiB3b3JkKTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBjYW1lbENhc2U7XG4iLCIvKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG5lZ2F0ZXMgdGhlIHJlc3VsdCBvZiB0aGUgcHJlZGljYXRlIGBmdW5jYC4gVGhlXG4gKiBgZnVuY2AgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgYW5kIGFyZ3VtZW50cyBvZiB0aGVcbiAqIGNyZWF0ZWQgZnVuY3Rpb24uXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIHByZWRpY2F0ZSB0byBuZWdhdGUuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBuZWdhdGVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBpc0V2ZW4obikge1xuICogICByZXR1cm4gbiAlIDIgPT0gMDtcbiAqIH1cbiAqXG4gKiBfLmZpbHRlcihbMSwgMiwgMywgNCwgNSwgNl0sIF8ubmVnYXRlKGlzRXZlbikpO1xuICogLy8gPT4gWzEsIDMsIDVdXG4gKi9cbmZ1bmN0aW9uIG5lZ2F0ZShwcmVkaWNhdGUpIHtcbiAgaWYgKHR5cGVvZiBwcmVkaWNhdGUgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOiByZXR1cm4gIXByZWRpY2F0ZS5jYWxsKHRoaXMpO1xuICAgICAgY2FzZSAxOiByZXR1cm4gIXByZWRpY2F0ZS5jYWxsKHRoaXMsIGFyZ3NbMF0pO1xuICAgICAgY2FzZSAyOiByZXR1cm4gIXByZWRpY2F0ZS5jYWxsKHRoaXMsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgY2FzZSAzOiByZXR1cm4gIXByZWRpY2F0ZS5jYWxsKHRoaXMsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgIH1cbiAgICByZXR1cm4gIXByZWRpY2F0ZS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbmVnYXRlO1xuIiwiaW1wb3J0IGFzc2lnblZhbHVlIGZyb20gJy4vX2Fzc2lnblZhbHVlLmpzJztcbmltcG9ydCBjYXN0UGF0aCBmcm9tICcuL19jYXN0UGF0aC5qcyc7XG5pbXBvcnQgaXNJbmRleCBmcm9tICcuL19pc0luZGV4LmpzJztcbmltcG9ydCBpc09iamVjdCBmcm9tICcuL2lzT2JqZWN0LmpzJztcbmltcG9ydCB0b0tleSBmcm9tICcuL190b0tleS5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2V0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBwYXRoIGNyZWF0aW9uLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZVNldChvYmplY3QsIHBhdGgsIHZhbHVlLCBjdXN0b21pemVyKSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBvYmplY3Q7XG4gIH1cbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgIGxhc3RJbmRleCA9IGxlbmd0aCAtIDEsXG4gICAgICBuZXN0ZWQgPSBvYmplY3Q7XG5cbiAgd2hpbGUgKG5lc3RlZCAhPSBudWxsICYmICsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gdG9LZXkocGF0aFtpbmRleF0pLFxuICAgICAgICBuZXdWYWx1ZSA9IHZhbHVlO1xuXG4gICAgaWYgKGluZGV4ICE9IGxhc3RJbmRleCkge1xuICAgICAgdmFyIG9ialZhbHVlID0gbmVzdGVkW2tleV07XG4gICAgICBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXIgPyBjdXN0b21pemVyKG9ialZhbHVlLCBrZXksIG5lc3RlZCkgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuZXdWYWx1ZSA9IGlzT2JqZWN0KG9ialZhbHVlKVxuICAgICAgICAgID8gb2JqVmFsdWVcbiAgICAgICAgICA6IChpc0luZGV4KHBhdGhbaW5kZXggKyAxXSkgPyBbXSA6IHt9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgYXNzaWduVmFsdWUobmVzdGVkLCBrZXksIG5ld1ZhbHVlKTtcbiAgICBuZXN0ZWQgPSBuZXN0ZWRba2V5XTtcbiAgfVxuICByZXR1cm4gb2JqZWN0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlU2V0O1xuIiwiaW1wb3J0IGJhc2VHZXQgZnJvbSAnLi9fYmFzZUdldC5qcyc7XG5pbXBvcnQgYmFzZVNldCBmcm9tICcuL19iYXNlU2V0LmpzJztcbmltcG9ydCBjYXN0UGF0aCBmcm9tICcuL19jYXN0UGF0aC5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgIGBfLnBpY2tCeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aHMgVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIHByb3BlcnR5LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYmFzZVBpY2tCeShvYmplY3QsIHBhdGhzLCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRocy5sZW5ndGgsXG4gICAgICByZXN1bHQgPSB7fTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBwYXRoID0gcGF0aHNbaW5kZXhdLFxuICAgICAgICB2YWx1ZSA9IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcblxuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIHBhdGgpKSB7XG4gICAgICBiYXNlU2V0KHJlc3VsdCwgY2FzdFBhdGgocGF0aCwgb2JqZWN0KSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlUGlja0J5O1xuIiwiaW1wb3J0IGFycmF5UHVzaCBmcm9tICcuL19hcnJheVB1c2guanMnO1xuaW1wb3J0IGdldFByb3RvdHlwZSBmcm9tICcuL19nZXRQcm90b3R5cGUuanMnO1xuaW1wb3J0IGdldFN5bWJvbHMgZnJvbSAnLi9fZ2V0U3ltYm9scy5qcyc7XG5pbXBvcnQgc3R1YkFycmF5IGZyb20gJy4vc3R1YkFycmF5LmpzJztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICovXG52YXIgZ2V0U3ltYm9sc0luID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB3aGlsZSAob2JqZWN0KSB7XG4gICAgYXJyYXlQdXNoKHJlc3VsdCwgZ2V0U3ltYm9scyhvYmplY3QpKTtcbiAgICBvYmplY3QgPSBnZXRQcm90b3R5cGUob2JqZWN0KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgZ2V0U3ltYm9sc0luO1xuIiwiaW1wb3J0IGJhc2VHZXRBbGxLZXlzIGZyb20gJy4vX2Jhc2VHZXRBbGxLZXlzLmpzJztcbmltcG9ydCBnZXRTeW1ib2xzSW4gZnJvbSAnLi9fZ2V0U3ltYm9sc0luLmpzJztcbmltcG9ydCBrZXlzSW4gZnJvbSAnLi9rZXlzSW4uanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGdldEFsbEtleXNJbihvYmplY3QpIHtcbiAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0luLCBnZXRTeW1ib2xzSW4pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXRBbGxLZXlzSW47XG4iLCJpbXBvcnQgYXJyYXlNYXAgZnJvbSAnLi9fYXJyYXlNYXAuanMnO1xuaW1wb3J0IGJhc2VJdGVyYXRlZSBmcm9tICcuL19iYXNlSXRlcmF0ZWUuanMnO1xuaW1wb3J0IGJhc2VQaWNrQnkgZnJvbSAnLi9fYmFzZVBpY2tCeS5qcyc7XG5pbXBvcnQgZ2V0QWxsS2V5c0luIGZyb20gJy4vX2dldEFsbEtleXNJbi5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIGBvYmplY3RgIHByb3BlcnRpZXMgYHByZWRpY2F0ZWAgcmV0dXJuc1xuICogdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50czogKHZhbHVlLCBrZXkpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBwcm9wZXJ0eS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAnMicsICdjJzogMyB9O1xuICpcbiAqIF8ucGlja0J5KG9iamVjdCwgXy5pc051bWJlcik7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2MnOiAzIH1cbiAqL1xuZnVuY3Rpb24gcGlja0J5KG9iamVjdCwgcHJlZGljYXRlKSB7XG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICB2YXIgcHJvcHMgPSBhcnJheU1hcChnZXRBbGxLZXlzSW4ob2JqZWN0KSwgZnVuY3Rpb24ocHJvcCkge1xuICAgIHJldHVybiBbcHJvcF07XG4gIH0pO1xuICBwcmVkaWNhdGUgPSBiYXNlSXRlcmF0ZWUocHJlZGljYXRlKTtcbiAgcmV0dXJuIGJhc2VQaWNrQnkob2JqZWN0LCBwcm9wcywgZnVuY3Rpb24odmFsdWUsIHBhdGgpIHtcbiAgICByZXR1cm4gcHJlZGljYXRlKHZhbHVlLCBwYXRoWzBdKTtcbiAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHBpY2tCeTtcbiIsImltcG9ydCBiYXNlSXRlcmF0ZWUgZnJvbSAnLi9fYmFzZUl0ZXJhdGVlLmpzJztcbmltcG9ydCBuZWdhdGUgZnJvbSAnLi9uZWdhdGUuanMnO1xuaW1wb3J0IHBpY2tCeSBmcm9tICcuL3BpY2tCeS5qcyc7XG5cbi8qKlxuICogVGhlIG9wcG9zaXRlIG9mIGBfLnBpY2tCeWA7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mXG4gKiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBgb2JqZWN0YCB0aGF0XG4gKiBgcHJlZGljYXRlYCBkb2Vzbid0IHJldHVybiB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0d29cbiAqIGFyZ3VtZW50czogKHZhbHVlLCBrZXkpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBwcm9wZXJ0eS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAnMicsICdjJzogMyB9O1xuICpcbiAqIF8ub21pdEJ5KG9iamVjdCwgXy5pc051bWJlcik7XG4gKiAvLyA9PiB7ICdiJzogJzInIH1cbiAqL1xuZnVuY3Rpb24gb21pdEJ5KG9iamVjdCwgcHJlZGljYXRlKSB7XG4gIHJldHVybiBwaWNrQnkob2JqZWN0LCBuZWdhdGUoYmFzZUl0ZXJhdGVlKHByZWRpY2F0ZSkpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgb21pdEJ5O1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZm9yRWFjaGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RWFjaChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkgPT09IGZhbHNlKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheUVhY2g7XG4iLCJpbXBvcnQgaWRlbnRpdHkgZnJvbSAnLi9pZGVudGl0eS5qcyc7XG5cbi8qKlxuICogQ2FzdHMgYHZhbHVlYCB0byBgaWRlbnRpdHlgIGlmIGl0J3Mgbm90IGEgZnVuY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgY2FzdCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY2FzdEZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlIDogaWRlbnRpdHk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNhc3RGdW5jdGlvbjtcbiIsImltcG9ydCBhcnJheUVhY2ggZnJvbSAnLi9fYXJyYXlFYWNoLmpzJztcbmltcG9ydCBiYXNlRWFjaCBmcm9tICcuL19iYXNlRWFjaC5qcyc7XG5pbXBvcnQgY2FzdEZ1bmN0aW9uIGZyb20gJy4vX2Nhc3RGdW5jdGlvbi5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuXG4vKipcbiAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggZWxlbWVudC5cbiAqIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gKlxuICogKipOb3RlOioqIEFzIHdpdGggb3RoZXIgXCJDb2xsZWN0aW9uc1wiIG1ldGhvZHMsIG9iamVjdHMgd2l0aCBhIFwibGVuZ3RoXCJcbiAqIHByb3BlcnR5IGFyZSBpdGVyYXRlZCBsaWtlIGFycmF5cy4gVG8gYXZvaWQgdGhpcyBiZWhhdmlvciB1c2UgYF8uZm9ySW5gXG4gKiBvciBgXy5mb3JPd25gIGZvciBvYmplY3QgaXRlcmF0aW9uLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBhbGlhcyBlYWNoXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAqIEBzZWUgXy5mb3JFYWNoUmlnaHRcbiAqIEBleGFtcGxlXG4gKlxuICogXy5mb3JFYWNoKFsxLCAyXSwgZnVuY3Rpb24odmFsdWUpIHtcbiAqICAgY29uc29sZS5sb2codmFsdWUpO1xuICogfSk7XG4gKiAvLyA9PiBMb2dzIGAxYCB0aGVuIGAyYC5cbiAqXG4gKiBfLmZvckVhY2goeyAnYSc6IDEsICdiJzogMiB9LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gKiB9KTtcbiAqIC8vID0+IExvZ3MgJ2EnIHRoZW4gJ2InIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpLlxuICovXG5mdW5jdGlvbiBmb3JFYWNoKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RWFjaCA6IGJhc2VFYWNoO1xuICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBjYXN0RnVuY3Rpb24oaXRlcmF0ZWUpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZm9yRWFjaDtcbiIsImltcG9ydCBiYXNlRWFjaCBmcm9tICcuL19iYXNlRWFjaC5qcyc7XG5pbXBvcnQgaXNBcnJheUxpa2UgZnJvbSAnLi9pc0FycmF5TGlrZS5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWFwYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBpc0FycmF5TGlrZShjb2xsZWN0aW9uKSA/IEFycmF5KGNvbGxlY3Rpb24ubGVuZ3RoKSA6IFtdO1xuXG4gIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSBpdGVyYXRlZSh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VNYXA7XG4iLCJpbXBvcnQgYXJyYXlNYXAgZnJvbSAnLi9fYXJyYXlNYXAuanMnO1xuaW1wb3J0IGJhc2VJdGVyYXRlZSBmcm9tICcuL19iYXNlSXRlcmF0ZWUuanMnO1xuaW1wb3J0IGJhc2VNYXAgZnJvbSAnLi9fYmFzZU1hcC5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdmFsdWVzIGJ5IHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCB0aHJ1XG4gKiBgaXRlcmF0ZWVgLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAqICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAqXG4gKiBNYW55IGxvZGFzaCBtZXRob2RzIGFyZSBndWFyZGVkIHRvIHdvcmsgYXMgaXRlcmF0ZWVzIGZvciBtZXRob2RzIGxpa2VcbiAqIGBfLmV2ZXJ5YCwgYF8uZmlsdGVyYCwgYF8ubWFwYCwgYF8ubWFwVmFsdWVzYCwgYF8ucmVqZWN0YCwgYW5kIGBfLnNvbWVgLlxuICpcbiAqIFRoZSBndWFyZGVkIG1ldGhvZHMgYXJlOlxuICogYGFyeWAsIGBjaHVua2AsIGBjdXJyeWAsIGBjdXJyeVJpZ2h0YCwgYGRyb3BgLCBgZHJvcFJpZ2h0YCwgYGV2ZXJ5YCxcbiAqIGBmaWxsYCwgYGludmVydGAsIGBwYXJzZUludGAsIGByYW5kb21gLCBgcmFuZ2VgLCBgcmFuZ2VSaWdodGAsIGByZXBlYXRgLFxuICogYHNhbXBsZVNpemVgLCBgc2xpY2VgLCBgc29tZWAsIGBzb3J0QnlgLCBgc3BsaXRgLCBgdGFrZWAsIGB0YWtlUmlnaHRgLFxuICogYHRlbXBsYXRlYCwgYHRyaW1gLCBgdHJpbUVuZGAsIGB0cmltU3RhcnRgLCBhbmQgYHdvcmRzYFxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAqICAgcmV0dXJuIG4gKiBuO1xuICogfVxuICpcbiAqIF8ubWFwKFs0LCA4XSwgc3F1YXJlKTtcbiAqIC8vID0+IFsxNiwgNjRdXG4gKlxuICogXy5tYXAoeyAnYSc6IDQsICdiJzogOCB9LCBzcXVhcmUpO1xuICogLy8gPT4gWzE2LCA2NF0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiB2YXIgdXNlcnMgPSBbXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JyB9LFxuICogICB7ICd1c2VyJzogJ2ZyZWQnIH1cbiAqIF07XG4gKlxuICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLm1hcCh1c2VycywgJ3VzZXInKTtcbiAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICovXG5mdW5jdGlvbiBtYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlNYXAgOiBiYXNlTWFwO1xuICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBiYXNlSXRlcmF0ZWUoaXRlcmF0ZWUsIDMpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWFwO1xuIiwiaW1wb3J0IHsgbWFwIH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCB7IGVhY2ggfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IHsgZmlsdGVyIH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCB7IG9taXRCeSB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgeyBjYW1lbENhc2UgfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IHByZWZpeCBmcm9tICcuLi8uLi9IZWxwZXJzL1ByZWZpeC9QcmVmaXgnO1xuXG5jb25zdCBDT0xPUlMgPSBbXG4gICAgJ3ByaW1hcnknLFxuICAgICdzZWNvbmRhcnknLFxuICAgICdzdWNjZXNzJyxcbiAgICAnZGFuZ2VyJyxcbiAgICAnd2FybmluZycsXG4gICAgJ2luZm8nLFxuICAgICdsaWdodCcsXG4gICAgJ2RhcmsnLFxuICAgICd3aGl0ZScsXG4gICAgJ211dGVkJ1xuXTtcblxuY29uc3QgcHJvcHMgPSB7fTtcblxuZWFjaChbJ2JvcmRlcicsICd0ZXh0JywgJ2JnJywgJ2JnLWdyYWRpZW50J10sIG5hbWVzcGFjZSA9PiB7XG4gICAgZWFjaChDT0xPUlMsIGNvbG9yID0+IHtcbiAgICAgICAgcHJvcHNbY2FtZWxDYXNlKHByZWZpeChjb2xvciwgbmFtZXNwYWNlKSldID0gQm9vbGVhbjtcbiAgICB9KTtcbn0pO1xuXG5mdW5jdGlvbiBjbGFzc2VzKGluc3RhbmNlLCBuYW1lc3BhY2UpIHtcbiAgICByZXR1cm4gZmlsdGVyKG1hcChDT0xPUlMsIGNvbG9yID0+IHtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlW2NhbWVsQ2FzZShjb2xvciA9IHByZWZpeChjb2xvciwgbmFtZXNwYWNlKSldID8gY29sb3IgOiBudWxsO1xuICAgIH0pKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgcHJvcHM6IHByb3BzLFxuXG4gICAgbWV0aG9kczoge1xuXG4gICAgICAgIHRleHRDb2xvcigpIHtcbiAgICAgICAgICAgIHJldHVybiBjbGFzc2VzKHRoaXMsICd0ZXh0Jyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYmdDb2xvcigpIHtcbiAgICAgICAgICAgIHJldHVybiBjbGFzc2VzKHRoaXMsICdiZycpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGJvcmRlckNvbG9yKCkge1xuICAgICAgICAgICAgcmV0dXJuIGNsYXNzZXModGhpcywgJ2JvcmRlcicpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGJnR3JhZGllbnRDb2xvcigpIHtcbiAgICAgICAgICAgIHJldHVybiBjbGFzc2VzKHRoaXMsICdiZy1ncmFkaWVudCcpO1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgY29tcHV0ZWQ6IHtcblxuICAgICAgICB0ZXh0Q29sb3JDbGFzc2VzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGV4dENvbG9yKCkuam9pbignICcpLnRyaW0oKSB8fCBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIGJvcmRlckNvbG9yQ2xhc3NlcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJvcmRlckNvbG9yKCkuam9pbignICcpLnRyaW0oKSB8fCBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIGJnQ29sb3JDbGFzc2VzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmdDb2xvcigpLmpvaW4oJyAnKS50cmltKCkgfHwgbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICBiZ0dyYWRpZW50Q29sb3JDbGFzc2VzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmdHcmFkaWVudENvbG9yKCkuam9pbignICcpLnRyaW0oKSB8fCBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNvbG9yYWJsZUNsYXNzZXMoKSB7XG4gICAgICAgICAgICBjb25zdCBjbGFzc2VzID0ge307XG5cbiAgICAgICAgICAgIGNsYXNzZXNbdGhpcy50ZXh0Q29sb3JDbGFzc2VzXSA9ICEhdGhpcy50ZXh0Q29sb3JDbGFzc2VzO1xuICAgICAgICAgICAgY2xhc3Nlc1t0aGlzLmJvcmRlckNvbG9yQ2xhc3Nlc10gPSAhIXRoaXMuYm9yZGVyQ29sb3JDbGFzc2VzO1xuICAgICAgICAgICAgY2xhc3Nlc1t0aGlzLmJnQ29sb3JDbGFzc2VzXSA9ICEhdGhpcy5iZ0NvbG9yQ2xhc3NlcztcbiAgICAgICAgICAgIGNsYXNzZXNbdGhpcy5iZ0dyYWRpZW50Q29sb3JDbGFzc2VzXSA9ICEhdGhpcy5iZ0dyYWRpZW50Q29sb3JDbGFzc2VzO1xuXG4gICAgICAgICAgICByZXR1cm4gb21pdEJ5KGNsYXNzZXMsIChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFrZXkgfHwgIXZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgIH1cblxufVxuIiwiZnVuY3Rpb24gZHVyYXRpb24oZWwpIHtcbiAgICBjb25zdCBkdXJhdGlvbiA9IGdldENvbXB1dGVkU3R5bGUoZWwpLnRyYW5zaXRpb25EdXJhdGlvbjtcbiAgICBjb25zdCBudW1lcmljID0gcGFyc2VGbG9hdChkdXJhdGlvbiwgMTApIHx8IDA7XG4gICAgY29uc3QgdW5pdCA9IGR1cmF0aW9uLm1hdGNoKC9tP3MvKTtcblxuICAgIHN3aXRjaCAodW5pdFswXSkge1xuICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgIHJldHVybiBudW1lcmljICogMTAwMDtcbiAgICAgICAgY2FzZSAnbXMnOlxuICAgICAgICAgICAgcmV0dXJuIG51bWVyaWM7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0cmFuc2l0aW9uKGVsKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGRlbGF5ID0gZHVyYXRpb24oZWwpO1xuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKGRlbGF5KVxuICAgICAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoKGUpIHtcbiAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuIiwiaW1wb3J0IGNvcHlPYmplY3QgZnJvbSAnLi9fY29weU9iamVjdC5qcyc7XG5pbXBvcnQgY3JlYXRlQXNzaWduZXIgZnJvbSAnLi9fY3JlYXRlQXNzaWduZXIuanMnO1xuaW1wb3J0IGtleXNJbiBmcm9tICcuL2tleXNJbi5qcyc7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25gIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgb3duIGFuZFxuICogaW5oZXJpdGVkIHNvdXJjZSBwcm9wZXJ0aWVzLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBhbGlhcyBleHRlbmRcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqIEBzZWUgXy5hc3NpZ25cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogfVxuICpcbiAqIGZ1bmN0aW9uIEJhcigpIHtcbiAqICAgdGhpcy5jID0gMztcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmIgPSAyO1xuICogQmFyLnByb3RvdHlwZS5kID0gNDtcbiAqXG4gKiBfLmFzc2lnbkluKHsgJ2EnOiAwIH0sIG5ldyBGb28sIG5ldyBCYXIpO1xuICogLy8gPT4geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzLCAnZCc6IDQgfVxuICovXG52YXIgYXNzaWduSW4gPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSkge1xuICBjb3B5T2JqZWN0KHNvdXJjZSwga2V5c0luKHNvdXJjZSksIG9iamVjdCk7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgYXNzaWduSW47XG4iLCJpbXBvcnQgYmFzZU1lcmdlIGZyb20gJy4vX2Jhc2VNZXJnZS5qcyc7XG5pbXBvcnQgY3JlYXRlQXNzaWduZXIgZnJvbSAnLi9fY3JlYXRlQXNzaWduZXIuanMnO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYXNzaWduYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBtZXJnZXMgb3duIGFuZFxuICogaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdHMgaW50byB0aGVcbiAqIGRlc3RpbmF0aW9uIG9iamVjdC4gU291cmNlIHByb3BlcnRpZXMgdGhhdCByZXNvbHZlIHRvIGB1bmRlZmluZWRgIGFyZVxuICogc2tpcHBlZCBpZiBhIGRlc3RpbmF0aW9uIHZhbHVlIGV4aXN0cy4gQXJyYXkgYW5kIHBsYWluIG9iamVjdCBwcm9wZXJ0aWVzXG4gKiBhcmUgbWVyZ2VkIHJlY3Vyc2l2ZWx5LiBPdGhlciBvYmplY3RzIGFuZCB2YWx1ZSB0eXBlcyBhcmUgb3ZlcnJpZGRlbiBieVxuICogYXNzaWdubWVudC4gU291cmNlIG9iamVjdHMgYXJlIGFwcGxpZWQgZnJvbSBsZWZ0IHRvIHJpZ2h0LiBTdWJzZXF1ZW50XG4gKiBzb3VyY2VzIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyBzb3VyY2VzLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC41LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHtcbiAqICAgJ2EnOiBbeyAnYic6IDIgfSwgeyAnZCc6IDQgfV1cbiAqIH07XG4gKlxuICogdmFyIG90aGVyID0ge1xuICogICAnYSc6IFt7ICdjJzogMyB9LCB7ICdlJzogNSB9XVxuICogfTtcbiAqXG4gKiBfLm1lcmdlKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4geyAnYSc6IFt7ICdiJzogMiwgJ2MnOiAzIH0sIHsgJ2QnOiA0LCAnZSc6IDUgfV0gfVxuICovXG52YXIgbWVyZ2UgPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgpIHtcbiAgYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCk7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgbWVyZ2U7XG4iLCJpbXBvcnQgeyBlYWNoIH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCB7IG1lcmdlIH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCB7IGV4dGVuZCB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgeyBpc0FycmF5IH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCB7IGlzT2JqZWN0IH0gZnJvbSAnbG9kYXNoLWVzJztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbWV0aG9kczoge1xuXG4gICAgICAgIG1lcmdlQ2xhc3NlcygpIHtcbiAgICAgICAgICAgIGNvbnN0IGNsYXNzZXMgPSB7fTtcblxuICAgICAgICAgICAgZWFjaChbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyksIGFyZyA9PiB7XG4gICAgICAgICAgICAgICAgaWYoaXNPYmplY3QoYXJnKSkge1xuICAgICAgICAgICAgICAgICAgICBleHRlbmQoY2xhc3NlcywgYXJnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZihpc0FycmF5KGFyZykpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2UoY2xhc3NlcywgYXJnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZihhcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3Nlc1thcmddID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGNsYXNzZXM7XG4gICAgICAgIH1cblxuICAgIH1cblxufVxuIiwiPHRlbXBsYXRlPlxuICAgIDxyb3V0ZXItbGluayB2LWlmPVwidG9cIiA6dG89XCJ0b1wiIDpkaXNhYmxlZD1cImRpc2FibGVkXCIgOmNsYXNzPVwiY2xhc3Nlc1wiIEBjbGljaz1cIm9uQ2xpY2tcIiByb2xlPVwiYnV0dG9uXCI+XG4gICAgICAgIDxzbG90Lz5cbiAgICA8L3JvdXRlci1saW5rPlxuICAgIDxhIHYtZWxzZS1pZj1cImhyZWZcIiA6aHJlZj1cImhyZWZcIiA6ZGlzYWJsZWQ9XCJkaXNhYmxlZFwiIDpjbGFzcz1cImNsYXNzZXNcIiBAY2xpY2s9XCJvbkNsaWNrXCIgcm9sZT1cImJ1dHRvblwiPlxuICAgICAgICA8c2xvdC8+XG4gICAgPC9hPlxuICAgIDxsYWJlbCB2LWVsc2UtaWY9XCJsYWJlbFwiIDpkaXNhYmxlZD1cImRpc2FibGVkXCIgOmNsYXNzPVwiY2xhc3Nlc1wiIEBjbGljaz1cIm9uQ2xpY2tcIiByb2xlPVwiYnV0dG9uXCI+XG4gICAgICAgIDxzbG90Lz5cbiAgICA8L2xhYmVsPlxuICAgIDxidXR0b24gdi1lbHNlIDp0eXBlPVwidHlwZVwiIDpkaXNhYmxlZD1cImRpc2FibGVkXCIgOmNsYXNzPVwiY2xhc3Nlc1wiIEBjbGljaz1cIm9uQ2xpY2tcIj5cbiAgICAgICAgPHNsb3QvPlxuICAgIDwvYnV0dG9uPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBWYXJpYW50IGZyb20gJy4uLy4uL01peGlucy9WYXJpYW50JztcbmltcG9ydCBTaXplYWJsZSBmcm9tICcuLi8uLi9NaXhpbnMvU2l6ZWFibGUnO1xuaW1wb3J0IENvbG9yYWJsZSBmcm9tICcuLi8uLi9NaXhpbnMvQ29sb3JhYmxlJztcbmltcG9ydCB0cmFuc2l0aW9uIGZyb20gJy4uLy4uL0hlbHBlcnMvVHJhbnNpdGlvbic7XG5pbXBvcnQgTWVyZ2VDbGFzc2VzIGZyb20gJy4uLy4uL01peGlucy9NZXJnZUNsYXNzZXMnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAnYnRuJyxcblxuICAgIG1peGluczogW1xuICAgICAgICBWYXJpYW50LFxuICAgICAgICBTaXplYWJsZSxcbiAgICAgICAgQ29sb3JhYmxlLFxuICAgICAgICBNZXJnZUNsYXNzZXNcbiAgICBdLFxuXG4gICAgcHJvcHM6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzcGxheSBidXR0b24gd2l0aCBhY3RpdmUgc3RhdGVcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgYWN0aXZlOiBCb29sZWFuLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwbGF5IGJ1dHRvbiB3aXRoIGJsb2NrZWQgc3RhdGVcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgYmxvY2s6IEJvb2xlYW4sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc3BsYXkgYnV0dG9uIHdpdGggZGlzYWJsZWQgc3RhdGVcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgZGlzYWJsZWQ6IEJvb2xlYW4sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGFuIGhyZWYgaXMgcGFzc2VkLCBidXR0b24gaXMgYW4gcm91dGVyLWxpbmsgZWxlbWVudFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgQm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgaHJlZjogU3RyaW5nLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG91bGQgdXNlIDxsYWJlbD4gYXMgdGhlIGVsZW1lbnQgZm9yIHRoZSBidXR0b24uIFVzZWQgZm9yIGlucHV0c1xuICAgICAgICAgKiB3cmFwcGVycyAodG9nZ2xlcykuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBCb29sZWFuXG4gICAgICAgICAqL1xuICAgICAgICBsYWJlbDogQm9vbGVhbixcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzcGxheSBhcyBhbiBvdXRsaW5lIGJ1dHRvblxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBvdXRsaW5lOiBCb29sZWFuLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBhbiB0byBpcyBwYXNzZWQsIGJ1dHRvbiBpcyBhbiByb3V0ZXItbGluayBlbGVtZW50XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBCb29sZWFuXG4gICAgICAgICAqL1xuICAgICAgICB0bzogW09iamVjdCwgU3RyaW5nXSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHR5cGUgYXR0cmlidXRlIGZvciB0aGUgYnV0dG9uLiBOb3QgYXBwbGllZCBpZiBhbiBhbmNob3JcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgdHlwZTogU3RyaW5nXG5cbiAgICB9LFxuXG4gICAgbWV0aG9kczoge1xuXG4gICAgICAgIG9uQ2xpY2soZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2NsaWNrJywgZXZlbnQpO1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgY29tcHV0ZWQ6IHtcblxuICAgICAgICB2YXJpYW50Q2xhc3NQcmVmaXgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kb3B0aW9ucy5uYW1lICsgKHRoaXMub3V0bGluZSA/ICctb3V0bGluZScgOiAnJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xhc3NlcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1lcmdlQ2xhc3NlcyhcbiAgICAgICAgICAgICAgICAnYnRuJyxcbiAgICAgICAgICAgICAgICB0aGlzLnZhcmlhbnRDbGFzcyxcbiAgICAgICAgICAgICAgICB0aGlzLnNpemVhYmxlQ2xhc3MsXG4gICAgICAgICAgICAgICAgdGhpcy5jb2xvcmFibGVDbGFzc2VzLFxuICAgICAgICAgICAgICAgIHRoaXMuYmxvY2sgPyAnYnRuLWJsb2NrJyA6ICcnLFxuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlID8gJ2FjdGl2ZScgOiAnJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG59XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJzY3NzXCI+XG5AaW1wb3J0ICcuL25vZGVfbW9kdWxlcy9ib290c3RyYXAvc2Nzcy9taXhpbnMuc2Nzcyc7XG5AaW1wb3J0ICcuL25vZGVfbW9kdWxlcy9ib290c3RyYXAvc2Nzcy9mdW5jdGlvbnMuc2Nzcyc7XG5AaW1wb3J0ICcuL25vZGVfbW9kdWxlcy9ib290c3RyYXAvc2Nzcy92YXJpYWJsZXMuc2Nzcyc7XG5cbkBtaXhpbiBidXR0b24tYmxvY2soJHNpemUpIHtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBkaXNwbGF5OiBibG9jaztcbn1cblxuQGluY2x1ZGUgbWVkaWEtYnJlYWtwb2ludC1kb3duKHhzKSB7XG4gICAgLmJ0bi14cy1ibG9jayB7XG4gICAgICAgIEBpbmNsdWRlIGJ1dHRvbi1ibG9jayh4cyk7XG5cbiAgICAgICAgKyAuYnRuLXhzLWJsb2NrIHtcbiAgICAgICAgICAgIG1hcmdpbi10b3A6ICRidG4tYmxvY2stc3BhY2luZy15O1xuICAgICAgICB9XG4gICAgfVxufVxuXG5AaW5jbHVkZSBtZWRpYS1icmVha3BvaW50LWRvd24oc20pIHtcbiAgICAuYnRuLXNtLWJsb2NrIHtcbiAgICAgICAgQGluY2x1ZGUgYnV0dG9uLWJsb2NrKHNtKTtcblxuICAgICAgICArIC5idG4teHMtYmxvY2ssXG4gICAgICAgICsgLmJ0bi1zbS1ibG9jayB7XG4gICAgICAgICAgICBtYXJnaW4tdG9wOiAkYnRuLWJsb2NrLXNwYWNpbmcteTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuQGluY2x1ZGUgbWVkaWEtYnJlYWtwb2ludC1kb3duKG1kKSB7XG4gICAgLmJ0bi1tZC1ibG9jayB7XG4gICAgICAgIEBpbmNsdWRlIGJ1dHRvbi1ibG9jayhtZCk7XG5cbiAgICAgICAgKyAuYnRuLXhzLWJsb2NrLFxuICAgICAgICArIC5idG4tc20tYmxvY2ssXG4gICAgICAgICsgLmJ0bi1tZC1ibG9jayB7XG4gICAgICAgICAgICBtYXJnaW4tdG9wOiAkYnRuLWJsb2NrLXNwYWNpbmcteTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuQGluY2x1ZGUgbWVkaWEtYnJlYWtwb2ludC1kb3duKGxnKSB7XG4gICAgLmJ0bi1sZy1ibG9jayB7XG4gICAgICAgIEBpbmNsdWRlIGJ1dHRvbi1ibG9jayhsZyk7XG5cbiAgICAgICAgKyAuYnRuLXhzLWJsb2NrLFxuICAgICAgICArIC5idG4tc20tYmxvY2ssXG4gICAgICAgICsgLmJ0bi1tZC1ibG9jayxcbiAgICAgICAgKyAuYnRuLWxnLWJsb2NrIHtcbiAgICAgICAgICAgIG1hcmdpbi10b3A6ICRidG4tYmxvY2stc3BhY2luZy15O1xuICAgICAgICB9XG4gICAgfVxufVxuXG5AaW5jbHVkZSBtZWRpYS1icmVha3BvaW50LWRvd24oeGwpIHtcbiAgICAuYnRuLXhsLWJsb2NrIHtcbiAgICAgICAgQGluY2x1ZGUgYnV0dG9uLWJsb2NrKHhsKTtcblxuICAgICAgICArIC5idG4teHMtYmxvY2ssXG4gICAgICAgICsgLmJ0bi1zbS1ibG9jayxcbiAgICAgICAgKyAuYnRuLW1kLWJsb2NrLFxuICAgICAgICArIC5idG4tbGctYmxvY2ssXG4gICAgICAgICsgLmJ0bi14bC1ibG9jayB7XG4gICAgICAgICAgICBtYXJnaW4tdG9wOiAkYnRuLWJsb2NrLXNwYWNpbmcteTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuPC9zdHlsZT5cbiIsImNvbnN0IExPQURFRF9TQ1JJUFRTID0ge307XG5cbmZ1bmN0aW9uIGVsZW1lbnQodXJsKSB7XG4gICAgY29uc3Qgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgc2NyaXB0LnNldEF0dHJpYnV0ZSgnc3JjJywgdXJsKTtcbiAgICBzY3JpcHQuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQvamF2YXNjcmlwdCcpO1xuICAgIHNjcmlwdC5zZXRBdHRyaWJ1dGUoJ2NoYXJzZXQnLCAndXRmLTgnKTtcbiAgICByZXR1cm4gc2NyaXB0O1xufVxuXG5mdW5jdGlvbiBhcHBlbmQoc2NyaXB0KSB7XG4gICAgaWYoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaGVhZCcpKSB7XG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2hlYWQnKS5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYm9keScpLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNjcmlwdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2NyaXB0KHVybCkge1xuICAgIGlmKExPQURFRF9TQ1JJUFRTW3VybF0gaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHJldHVybiBMT0FERURfU0NSSVBUU1t1cmxdO1xuICAgIH1cbiAgICBlbHNlIGlmKExPQURFRF9TQ1JJUFRTW3VybF0gfHwgZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihgc2NyaXB0W3NyYz1cIiR7dXJsfVwiXWApKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlKExPQURFRF9TQ1JJUFRTW3VybF0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gTE9BREVEX1NDUklQVFNbdXJsXSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGFwcGVuZChlbGVtZW50KHVybCkpLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShMT0FERURfU0NSSVBUU1t1cmxdID0gZXZlbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2goZSkge1xuICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4iLCJpbXBvcnQgeyBlYWNoIH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCB7IGlzRnVuY3Rpb24gfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IHNjcmlwdCBmcm9tICcuLi9TY3JpcHQnO1xuXG5jb25zdCBWdWVJbnN0YWxsZXIgPSB7XG4gICAgdXNlLFxuICAgIHNjcmlwdCxcbiAgICBwbHVnaW4sXG4gICAgcGx1Z2lucyxcbiAgICBmaWx0ZXIsXG4gICAgZmlsdGVycyxcbiAgICBjb21wb25lbnQsXG4gICAgY29tcG9uZW50cyxcbiAgICBkaXJlY3RpdmUsXG4gICAgZGlyZWN0aXZlcyxcbiAgICAkcGx1Z2luczoge30sXG4gICAgJGZpbHRlcnM6IHt9LFxuICAgICRkaXJlY3RpdmVzOiB7fSxcbiAgICAkY29tcG9uZW50czoge30sXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlKHBsdWdpbikge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuVnVlKSB7XG4gICAgICAgIHdpbmRvdy5WdWUudXNlKHBsdWdpbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBsdWdpbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBsdWdpbihWdWUsIG5hbWUsIGRlZikge1xuICAgIGlmKCFWdWVJbnN0YWxsZXIuJHBsdWdpbnNbbmFtZV0pIHtcbiAgICAgICAgVnVlLnVzZShWdWVJbnN0YWxsZXIuJHBsdWdpbnNbbmFtZV0gPSBkZWYpO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBsdWdpbnMoVnVlLCBwbHVnaW5zKSB7XG4gICAgZWFjaChwbHVnaW5zLCAoZGVmLCBuYW1lKSA9PiB7XG4gICAgICAgIHBsdWdpbihWdWUsIG5hbWUsIGRlZik7XG4gICAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaWx0ZXIoVnVlLCBuYW1lLCBkZWYpIHtcbiAgICBpZighVnVlSW5zdGFsbGVyLiRmaWx0ZXJzW25hbWVdKSB7XG4gICAgICAgIFZ1ZS51c2UoVnVlSW5zdGFsbGVyLiRmaWx0ZXJzW25hbWVdID0gZGVmKTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaWx0ZXJzKFZ1ZSwgZmlsdGVycykge1xuICAgIGVhY2goZmlsdGVycywgKGRlZiwgbmFtZSkgPT4ge1xuICAgICAgICBmaWx0ZXIoVnVlLCBuYW1lLCBkZWYpO1xuICAgIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcG9uZW50KFZ1ZSwgbmFtZSwgZGVmKSB7XG4gICAgaWYoIVZ1ZUluc3RhbGxlci4kY29tcG9uZW50c1tuYW1lXSkge1xuICAgICAgICBWdWUuY29tcG9uZW50KG5hbWUsIFZ1ZUluc3RhbGxlci4kY29tcG9uZW50c1tuYW1lXSA9IGRlZik7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcG9uZW50cyhWdWUsIGNvbXBvbmVudHMpIHtcbiAgICBlYWNoKGNvbXBvbmVudHMsIChkZWYsIG5hbWUpID0+IHtcbiAgICAgICAgY29tcG9uZW50KFZ1ZSwgbmFtZSwgZGVmKTtcbiAgICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpcmVjdGl2ZShWdWUsIG5hbWUsIGRlZikge1xuICAgIGlmKCFWdWVJbnN0YWxsZXIuJGRpcmVjdGl2ZXNbbmFtZV0pIHtcbiAgICAgICAgaWYoaXNGdW5jdGlvbihkZWYpKSB7XG4gICAgICAgICAgICBWdWUudXNlKFZ1ZUluc3RhbGxlci4kZGlyZWN0aXZlc1tuYW1lXSA9IGRlZik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBWdWUuZGlyZWN0aXZlKG5hbWUsIGRlZik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaXJlY3RpdmVzKFZ1ZSwgZGlyZWN0aXZlcykge1xuICAgIGVhY2goZGlyZWN0aXZlcywgKGRlZiwgbmFtZSkgPT4ge1xuICAgICAgICBkaXJlY3RpdmUoVnVlLCBuYW1lLCBkZWYpO1xuICAgIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBWdWVJbnN0YWxsZXI7XG4iLCJpbXBvcnQgQnRuIGZyb20gJy4vQnRuJztcbmltcG9ydCBWdWVJbnN0YWxsZXIgZnJvbSAnLi4vLi4vSGVscGVycy9WdWVJbnN0YWxsZXIvVnVlSW5zdGFsbGVyJztcblxuY29uc3QgcGx1Z2luID0gVnVlSW5zdGFsbGVyLnVzZSh7XG5cbiAgICBpbnN0YWxsKFZ1ZSwgb3B0aW9ucykge1xuICAgICAgICBWdWVJbnN0YWxsZXIuY29tcG9uZW50cyh7XG4gICAgICAgICAgICBCdG5cbiAgICAgICAgfSk7XG4gICAgfVxuXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgQnRuO1xuIiwiPHRlbXBsYXRlPlxuICAgIDxkaXYgY2xhc3M9XCJtb2RhbC1ib2R5XCI+PHNsb3QvPjwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdtb2RhbC1ib2R5J1xuXG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgICA8ZGl2IGNsYXNzPVwibW9kYWwtZGlhbG9nXCIgcm9sZT1cImRvY3VtZW50XCI+PHNsb3QvPjwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdtb2RhbC1kaWFsb2cnXG5cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICAgIDxoNSBjbGFzcz1cIm1vZGFsLXRpdGxlXCI+PHNsb3QvPjwvaDU+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ21vZGFsLXRpdGxlJ1xuXG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgICA8ZGl2IGNsYXNzPVwibW9kYWwtaGVhZGVyXCI+XG4gICAgICAgIDxzbG90IG5hbWU9XCJ0aXRsZVwiPlxuICAgICAgICAgICAgPG1vZGFsLXRpdGxlPjxzbG90Lz48L21vZGFsLXRpdGxlPlxuICAgICAgICA8L3Nsb3Q+XG5cbiAgICAgICAgPHNsb3QgbmFtZT1cImNsb3NlLWJ1dHRvblwiPlxuICAgICAgICAgICAgPGJ1dHRvbiB2LWlmPVwiY2xvc2VhYmxlXCIgdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiY2xvc2VcIiBhcmlhLWxhYmVsPVwiYXJpYUxhYmVsXCIgQGNsaWNrPVwiJGVtaXQoJ2Nsb3NlJylcIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj4mdGltZXM7PC9zcGFuPlxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDwvc2xvdD5cbiAgICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgTW9kYWxUaXRsZSBmcm9tICcuL01vZGFsVGl0bGUnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAnbW9kYWwtaGVhZGVyJyxcblxuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgICAgTW9kYWxUaXRsZVxuICAgIH0sXG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIGFyaWFMYWJlbDoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJ0Nsb3NlJ1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsb3NlYWJsZToge1xuICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICAgICAgfVxuXG4gICAgfVxuXG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgICA8ZGl2IGNsYXNzPVwibW9kYWwtZm9vdGVyXCI+PHNsb3QvPjwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdtb2RhbC1mb290ZXInXG5cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IGNyZWF0ZUNvbXBvdW5kZXIgZnJvbSAnLi9fY3JlYXRlQ29tcG91bmRlci5qcyc7XG5cbi8qKlxuICogQ29udmVydHMgYHN0cmluZ2AgdG9cbiAqIFtrZWJhYiBjYXNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MZXR0ZXJfY2FzZSNTcGVjaWFsX2Nhc2Vfc3R5bGVzKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUga2ViYWIgY2FzZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmtlYmFiQ2FzZSgnRm9vIEJhcicpO1xuICogLy8gPT4gJ2Zvby1iYXInXG4gKlxuICogXy5rZWJhYkNhc2UoJ2Zvb0JhcicpO1xuICogLy8gPT4gJ2Zvby1iYXInXG4gKlxuICogXy5rZWJhYkNhc2UoJ19fRk9PX0JBUl9fJyk7XG4gKiAvLyA9PiAnZm9vLWJhcidcbiAqL1xudmFyIGtlYmFiQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJy0nIDogJycpICsgd29yZC50b0xvd2VyQ2FzZSgpO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGtlYmFiQ2FzZTtcbiIsIjx0ZW1wbGF0ZT5cbiAgICA8ZGl2IGNsYXNzPVwiYWN0aXZpdHktaW5kaWNhdG9yXCIgOmNsYXNzPVwiY2xhc3Nlc1wiPlxuICAgICAgICA8ZGl2IHYtZm9yPVwiaSBpbiBub2Rlc1wiPjwvZGl2PlxuICAgIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIHByb3BzOiB7XG4gICAgICAgIG5vZGVzOiB7XG4gICAgICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgICAgICBkZWZhdWx0OiAzXG4gICAgICAgIH0sXG4gICAgICAgIHNpemU6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICcnXG4gICAgICAgIH0sXG4gICAgICAgIHByZWZpeDoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJ2FjdGl2aXR5LWluZGljYXRvci0nXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgY2xhc3NlczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjb25zdCBjbGFzc2VzID0ge307XG5cbiAgICAgICAgICAgIGNsYXNzZXNbdGhpcy4kb3B0aW9ucy5uYW1lXSA9ICEhdGhpcy4kb3B0aW9ucy5uYW1lO1xuICAgICAgICAgICAgY2xhc3Nlc1t0aGlzLnByZWZpeCArIHRoaXMuc2l6ZS5yZXBsYWNlKHRoaXMucHJlZml4LCAnJyldID0gISF0aGlzLnNpemU7XG5cbiAgICAgICAgICAgIHJldHVybiBjbGFzc2VzO1xuICAgICAgICB9XG4gICAgfVxuXG59XG48L3NjcmlwdD5cbiIsIjxzY3JpcHQ+XG5pbXBvcnQgQmFzZVR5cGUgZnJvbSAnLi9CYXNlVHlwZSc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdhY3Rpdml0eS1pbmRpY2F0b3ItZG90cycsXG5cbiAgICBleHRlbmRzOiBCYXNlVHlwZVxufVxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwic2Nzc1wiPlxuQGltcG9ydCAnLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwL3Njc3MvZnVuY3Rpb25zLnNjc3MnO1xuQGltcG9ydCAnLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwL3Njc3MvdmFyaWFibGVzLnNjc3MnO1xuXG4kYWN0aXZpdHktaW5kaWNhdG9yLWRvdC1zaXplOiAuNnJlbTtcblxuLmFjdGl2aXR5LWluZGljYXRvci1kb3RzIHtcblxuICAgICYgPiBkaXYge1xuICAgICAgICBib3JkZXItcmFkaXVzOiAxMDAlO1xuICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICRncmF5LTkwMDtcbiAgICAgICAgd2lkdGg6ICRhY3Rpdml0eS1pbmRpY2F0b3ItZG90LXNpemU7XG4gICAgICAgIGhlaWdodDogJGFjdGl2aXR5LWluZGljYXRvci1kb3Qtc2l6ZTtcbiAgICAgICAgYW5pbWF0aW9uOiBhY3Rpdml0eS1pbmRpY2F0b3ItZG90cyAxLjRzIGluZmluaXRlIGVhc2UtaW4tb3V0IGJvdGg7XG4gICAgfVxuXG4gICAgJiA+IGRpdjpub3QoOmxhc3QtY2hpbGQpIHtcbiAgICAgICAgbWFyZ2luLXJpZ2h0OiAkYWN0aXZpdHktaW5kaWNhdG9yLWRvdC1zaXplICogLjMzO1xuICAgIH1cblxuICAgICYuYWN0aXZpdHktaW5kaWNhdG9yLXhzID4gZGl2IHtcbiAgICAgICAgd2lkdGg6ICRhY3Rpdml0eS1pbmRpY2F0b3ItZG90LXNpemUgKiAuNTtcbiAgICAgICAgaGVpZ2h0OiAkYWN0aXZpdHktaW5kaWNhdG9yLWRvdC1zaXplICogLjU7XG4gICAgfVxuXG4gICAgJi5hY3Rpdml0eS1pbmRpY2F0b3Itc20gPiBkaXYge1xuICAgICAgICB3aWR0aDogJGFjdGl2aXR5LWluZGljYXRvci1kb3Qtc2l6ZSAqIC43NTtcbiAgICAgICAgaGVpZ2h0OiAkYWN0aXZpdHktaW5kaWNhdG9yLWRvdC1zaXplICogLjc1O1xuICAgIH1cblxuICAgICYuYWN0aXZpdHktaW5kaWNhdG9yLW1kID4gZGl2IHtcbiAgICAgICAgd2lkdGg6ICRhY3Rpdml0eS1pbmRpY2F0b3ItZG90LXNpemUgKiAxO1xuICAgICAgICBoZWlnaHQ6ICRhY3Rpdml0eS1pbmRpY2F0b3ItZG90LXNpemUgKiAxO1xuICAgIH1cblxuICAgICYuYWN0aXZpdHktaW5kaWNhdG9yLWxnID4gZGl2IHtcbiAgICAgICAgd2lkdGg6ICRhY3Rpdml0eS1pbmRpY2F0b3ItZG90LXNpemUgKiAxLjU7XG4gICAgICAgIGhlaWdodDogJGFjdGl2aXR5LWluZGljYXRvci1kb3Qtc2l6ZSAqIDEuNTtcbiAgICB9XG5cbiAgICAmLmFjdGl2aXR5LWluZGljYXRvci14bCA+IGRpdiB7XG4gICAgICAgIHdpZHRoOiAkYWN0aXZpdHktaW5kaWNhdG9yLWRvdC1zaXplICogMjtcbiAgICAgICAgaGVpZ2h0OiAkYWN0aXZpdHktaW5kaWNhdG9yLWRvdC1zaXplICogMjtcbiAgICB9XG5cbiAgICBAZm9yICRpIGZyb20gMCB0aHJvdWdoIDEyIHtcbiAgICAgICAgJiA+IGRpdjpudGgtY2hpbGQoI3skaSArIDF9KSB7XG4gICAgICAgICAgICBhbmltYXRpb24tZGVsYXk6ICRpICogLjE2cztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIEBrZXlmcmFtZXMgYWN0aXZpdHktaW5kaWNhdG9yLWRvdHMge1xuICAgICAgICAwJSwgODAlLCAxMDAlIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMCk7XG4gICAgICAgIH0gNDAlIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMS4wKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyB7XG4gICAgJjpub3QoLmJ0bi13YXJuaW5nKSAuYWN0aXZpdHktaW5kaWNhdG9yLWRvdHMgPiBkaXYge1xuICAgICAgICBiYWNrZ3JvdW5kOiB3aGl0ZTtcbiAgICB9XG59XG5cbjwvc3R5bGU+XG4iLCI8c2NyaXB0PlxuaW1wb3J0IEJhc2VUeXBlIGZyb20gJy4vQmFzZVR5cGUnO1xuaW1wb3J0IHsgZXh0ZW5kIH0gZnJvbSAnbG9kYXNoLWVzJztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ2FjdGl2aXR5LWluZGljYXRvci1zcGlubmVyJyxcblxuICAgIGV4dGVuZHM6IEJhc2VUeXBlLFxuXG4gICAgcHJvcHM6IGV4dGVuZCh7fSwgQmFzZVR5cGUucHJvcHMsIHtcbiAgICAgICAgbm9kZXM6IHtcbiAgICAgICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgICAgIGRlZmF1bHQ6IDEyXG4gICAgICAgIH1cbiAgICB9KVxufVxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwic2Nzc1wiPlxuQGltcG9ydCAnLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwL3Njc3MvZnVuY3Rpb25zLnNjc3MnO1xuQGltcG9ydCAnLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwL3Njc3MvdmFyaWFibGVzLnNjc3MnO1xuXG4kYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXItc2l6ZTogJGZvbnQtc2l6ZS1iYXNlICogMi4yNTtcbiRhY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lci13aWR0aDogMTAlO1xuJGFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyLWhlaWdodDogMzAlO1xuJGFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyLWRlbGF5OiAxcztcblxuQG1peGluIHNwaW5uZXItcm90YXRlLXNlbGVjdG9ycygkc3RhcnQ6MSwgJGVuZDoxNiwgJGRlbGF5OjEuMnMpIHtcbiAgICBAZm9yICRpIGZyb20gJHN0YXJ0IHRocm91Z2ggJGVuZCB7XG4gICAgICAgICYgPiBkaXY6Zmlyc3QtY2hpbGQ6bnRoLWxhc3QtY2hpbGQoI3skaX0pLFxuICAgICAgICAmID4gZGl2OmZpcnN0LWNoaWxkOm50aC1sYXN0LWNoaWxkKCN7JGl9KSB+IGRpdiB7XG4gICAgICAgICAgICBAaW5jbHVkZSBzcGlubmVyLXJvdGF0ZS10cmFuc2Zvcm0oJGksICRkZWxheSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbkBtaXhpbiBzcGlubmVyLXJvdGF0ZS10cmFuc2Zvcm0oJHRvdGFsLCAkZGVsYXk6MS4ycykge1xuICAgIEBmb3IgJGkgZnJvbSAxIHRocm91Z2ggJHRvdGFsIHtcbiAgICAgICAgJjpudGgtY2hpbGQoI3skaX0pIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogcm90YXRlKCN7MzYwIC8gJHRvdGFsICogJGl9ZGVnKTtcblxuICAgICAgICAgICAgJjpiZWZvcmUge1xuICAgICAgICAgICAgICAgIGFuaW1hdGlvbi1kZWxheTogLSN7JGRlbGF5IC0gKCRkZWxheSAvICR0b3RhbCAqICgkaSAtIDEpKX07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi5hY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lciB7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIHdpZHRoOiAkYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXItc2l6ZTtcbiAgICBoZWlnaHQ6ICRhY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lci1zaXplO1xuXG4gICAgJiA+IGRpdiAge1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIHRvcDogMDtcblxuICAgICAgICAmOmJlZm9yZSB7XG4gICAgICAgICAgICBjb250ZW50OiAnJztcbiAgICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICAgICAgbWFyZ2luOiAwIGF1dG87XG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkZ3JheS05MDA7XG4gICAgICAgICAgICB3aWR0aDogJGFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyLXdpZHRoO1xuICAgICAgICAgICAgaGVpZ2h0OiAkYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXItaGVpZ2h0O1xuICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogNXB4O1xuICAgICAgICAgICAgYW5pbWF0aW9uOiBhY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lciAkYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXItZGVsYXkgaW5maW5pdGUgZWFzZS1pbi1vdXQgYm90aDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgICYuYWN0aXZpdHktaW5kaWNhdG9yLXhzIHtcbiAgICAgICAgd2lkdGg6ICRhY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lci1zaXplICogLjU7XG4gICAgICAgIGhlaWdodDogJGFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyLXNpemUgKiAuNTtcbiAgICB9XG4gICAgJi5hY3Rpdml0eS1pbmRpY2F0b3Itc20ge1xuICAgICAgICB3aWR0aDogJGFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyLXNpemUgKiAuNzU7XG4gICAgICAgIGhlaWdodDogJGFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyLXNpemUgKiAuNzU7XG4gICAgfVxuICAgICYuYWN0aXZpdHktaW5kaWNhdG9yLW1kIHtcbiAgICAgICAgd2lkdGg6ICRhY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lci1zaXplICogMTtcbiAgICAgICAgaGVpZ2h0OiAkYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXItc2l6ZSAqIDE7XG4gICAgfVxuICAgICYuYWN0aXZpdHktaW5kaWNhdG9yLWxnIHtcbiAgICAgICAgd2lkdGg6ICRhY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lci1zaXplICogMS41O1xuICAgICAgICBoZWlnaHQ6ICRhY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lci1zaXplICogMS41O1xuICAgIH1cbiAgICAmLmFjdGl2aXR5LWluZGljYXRvci14bCB7XG4gICAgICAgIHdpZHRoOiAkYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXItc2l6ZSAqIDI7XG4gICAgICAgIGhlaWdodDogJGFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyLXNpemUgKiAyO1xuICAgIH1cblxuICAgIEBpbmNsdWRlIHNwaW5uZXItcm90YXRlLXNlbGVjdG9ycygxLCAxMiwgJGFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyLWRlbGF5KTtcblxuICAgIEBrZXlmcmFtZXMgYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIge1xuICAgICAgICAwJSwgMzklLCAxMDAlIHsgb3BhY2l0eTogMDsgfVxuICAgICAgICA0MCUgeyBvcGFjaXR5OiAxOyB9XG4gICAgfVxufVxuXG4uYnRuLWFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyIHtcbiAgICAmOm5vdCguYnRuLXdhcm5pbmcpIC5hY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lciA+IGRpdjpiZWZvcmUge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcbiAgICB9XG59XG5cbjwvc3R5bGU+XG4iLCJpbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUlzRmluaXRlID0gcm9vdC5pc0Zpbml0ZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGZpbml0ZSBwcmltaXRpdmUgbnVtYmVyLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICogW2BOdW1iZXIuaXNGaW5pdGVgXShodHRwczovL21kbi5pby9OdW1iZXIvaXNGaW5pdGUpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZmluaXRlIG51bWJlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRmluaXRlKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGaW5pdGUoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Zpbml0ZShJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNGaW5pdGUoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRmluaXRlKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgbmF0aXZlSXNGaW5pdGUodmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0Zpbml0ZTtcbiIsImltcG9ydCB7IGlzRmluaXRlIH0gZnJvbSAnbG9kYXNoLWVzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaGVpZ2h0KSB7XG4gICAgcmV0dXJuIGlzRmluaXRlKGhlaWdodCkgPyBoZWlnaHQgKyAncHgnIDogaGVpZ2h0O1xufVxuIiwiPHRlbXBsYXRlPlxuICAgIDxkaXYgdi1pZj1cImNlbnRlclwiIGNsYXNzPVwiY2VudGVyLXdyYXBwZXJcIiA6Y2xhc3M9XCJ7J3Bvc2l0aW9uLXJlbGF0aXZlJzogcmVsYXRpdmUsICdwb3NpdGlvbi1maXhlZCc6IGZpeGVkfVwiIDpzdHlsZT1cInN0eWxlXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJjZW50ZXItY29udGVudCBkLWZsZXggZmxleC1jb2x1bW4gYWxpZ24taXRlbXMtY2VudGVyXCI+XG4gICAgICAgICAgICA8Y29tcG9uZW50IDppcz1cImNvbXBvbmVudFwiIDpzaXplPVwic2l6ZVwiIDpwcmVmaXg9XCJwcmVmaXhcIi8+XG4gICAgICAgICAgICA8ZGl2IHYtaWY9XCJsYWJlbFwiIHYtaHRtbD1cImxhYmVsXCIgY2xhc3M9XCJhY3Rpdml0eS1pbmRpY2F0b3ItbGFiZWxcIi8+XG4gICAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICAgIDxkaXYgdi1lbHNlIGNsYXNzPVwiZC1mbGV4IGZsZXgtY29sdW1uIGp1c3RpZnktY29udGVudC1jZW50ZXIgYWxpZ24taXRlbXMtY2VudGVyXCIgOnN0eWxlPVwic3R5bGVcIj5cbiAgICAgICAgPGNvbXBvbmVudCA6aXM9XCJjb21wb25lbnRcIiA6c2l6ZT1cInNpemVcIiA6cHJlZml4PVwicHJlZml4XCIvPlxuICAgICAgICA8ZGl2IHYtaWY9XCJsYWJlbFwiIHYtaHRtbD1cImxhYmVsXCIgY2xhc3M9XCJhY3Rpdml0eS1pbmRpY2F0b3ItbGFiZWxcIi8+XG4gICAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IHsga2ViYWJDYXNlIH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCBCYXNlVHlwZSBmcm9tICcuL1R5cGVzL0Jhc2VUeXBlJztcbmltcG9ydCBBY3Rpdml0eUluZGljYXRvckRvdHMgZnJvbSAnLi9UeXBlcy9Eb3RzJztcbmltcG9ydCBBY3Rpdml0eUluZGljYXRvclNwaW5uZXIgZnJvbSAnLi9UeXBlcy9TcGlubmVyJztcbmltcG9ydCB1bml0IGZyb20gJy4uLy4uL0hlbHBlcnMvVW5pdCc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdhY3Rpdml0eS1pbmRpY2F0b3InLFxuXG4gICAgZXh0ZW5kczogQmFzZVR5cGUsXG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIGNlbnRlcjogQm9vbGVhbixcblxuICAgICAgICBmaXhlZDogQm9vbGVhbixcblxuICAgICAgICBsYWJlbDogU3RyaW5nLFxuXG4gICAgICAgIHJlbGF0aXZlOiBCb29sZWFuLFxuXG4gICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdkb3RzJ1xuICAgICAgICB9LFxuXG4gICAgICAgIGhlaWdodDogW1N0cmluZywgTnVtYmVyXSxcblxuICAgICAgICBtYXhIZWlnaHQ6IFtTdHJpbmcsIE51bWJlcl0sXG5cbiAgICAgICAgbWluSGVpZ2h0OiBbU3RyaW5nLCBOdW1iZXJdLFxuXG4gICAgICAgIHdpZHRoOiBbU3RyaW5nLCBOdW1iZXJdLFxuXG4gICAgICAgIG1heFdpZHRoOiBbU3RyaW5nLCBOdW1iZXJdLFxuXG4gICAgICAgIG1pbldpZHRoOiBbU3RyaW5nLCBOdW1iZXJdXG5cbiAgICB9LFxuXG4gICAgY29tcG9uZW50czoge1xuICAgICAgICBBY3Rpdml0eUluZGljYXRvckRvdHMsXG4gICAgICAgIEFjdGl2aXR5SW5kaWNhdG9yU3Bpbm5lclxuICAgIH0sXG5cbiAgICBjb21wdXRlZDoge1xuXG4gICAgICAgIHN0eWxlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogdW5pdCh0aGlzLndpZHRoKSxcbiAgICAgICAgICAgICAgICBtYXhXaWR0aDogdW5pdCh0aGlzLm1heFdpZHRoKSxcbiAgICAgICAgICAgICAgICBtaW5XaWR0aDogdW5pdCh0aGlzLm1pbldpZHRoKSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHVuaXQodGhpcy5oZWlnaHQpLFxuICAgICAgICAgICAgICAgIG1heEhlaWdodDogdW5pdCh0aGlzLm1heEhlaWdodCksXG4gICAgICAgICAgICAgICAgbWluSGVpZ2h0OiB1bml0KHRoaXMubWluSGVpZ2h0KVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGNvbXBvbmVudCgpIHtcbiAgICAgICAgICAgIHJldHVybiBrZWJhYkNhc2UodGhpcy5wcmVmaXggKyB0aGlzLnR5cGUucmVwbGFjZSh0aGlzLnByZWZpeCwgJycpKTtcbiAgICAgICAgfVxuICAgIH1cblxufVxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwic2Nzc1wiPlxuQGltcG9ydCAnLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwL3Njc3MvZnVuY3Rpb25zLnNjc3MnO1xuQGltcG9ydCAnLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwL3Njc3MvdmFyaWFibGVzLnNjc3MnO1xuXG4vLyBDb250ZW50IFBvc2l0aW9uaW5nIEhlbHBlcnNcbi5jZW50ZXItd3JhcHBlciB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHRvcDogMDtcbiAgICBsZWZ0OiAwO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogMTAwJTtcbn1cbi5jZW50ZXItY29udGVudCB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHRvcDogNTAlO1xuICAgIGxlZnQ6IDUwJTtcbiAgICBtYXJnaW4tcmlnaHQ6IC01MCU7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwgLTUwJSlcbn1cblxuPC9zdHlsZT5cbiIsImltcG9ydCBBY3Rpdml0eUluZGljYXRvciBmcm9tICcuL0FjdGl2aXR5SW5kaWNhdG9yJztcbmltcG9ydCBWdWVJbnN0YWxsZXIgZnJvbSAnLi4vLi4vSGVscGVycy9WdWVJbnN0YWxsZXIvVnVlSW5zdGFsbGVyJztcblxuY29uc3QgcGx1Z2luID0gVnVlSW5zdGFsbGVyLnVzZSh7XG5cbiAgICBpbnN0YWxsKFZ1ZSwgb3B0aW9ucykge1xuICAgICAgICBWdWVJbnN0YWxsZXIuY29tcG9uZW50cyh7XG4gICAgICAgICAgICBBY3Rpdml0eUluZGljYXRvclxuICAgICAgICB9KTtcbiAgICB9XG5cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBBY3Rpdml0eUluZGljYXRvcjtcbiIsIjx0ZW1wbGF0ZT5cbiAgICA8YnV0dG9uIDp0eXBlPVwidHlwZVwiIGNsYXNzPVwiYnRuXCIgOmNsYXNzPVwiY2xhc3Nlc1wiIEBjbGljaz1cIm9uQ2xpY2tcIj5cbiAgICAgICAgPGkgdi1pZj1cImljb25cIiA6Y2xhc3M9XCJpY29uXCIvPiB7e2xhYmVsfX1cbiAgICAgICAgPHNsb3QvPlxuICAgICAgICA8YWN0aXZpdHktaW5kaWNhdG9yIDp0eXBlPVwiaW5kaWNhdG9yXCIgLz5cbiAgICA8L2J1dHRvbj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgQWN0aXZpdHlJbmRpY2F0b3IgZnJvbSAnLi4vQWN0aXZpdHlJbmRpY2F0b3InO1xuXG5jb25zdCBjb252ZXJ0QW5pbWF0aW9uRGVsYXlUb0ludCA9IGZ1bmN0aW9uKGRlbGF5KSB7XG4gICAgY29uc3QgbnVtID0gcGFyc2VGbG9hdChkZWxheSwgMTApO1xuICAgIGNvbnN0IG1hdGNoZXMgPSBkZWxheS5tYXRjaCgvbT9zLyk7XG4gICAgY29uc3QgdW5pdCA9IG1hdGNoZXMgPyBtYXRjaGVzWzBdIDogZmFsc2U7XG5cbiAgICBsZXQgbWlsbGlzZWNvbmRzO1xuXG4gICAgc3dpdGNoICh1bml0KSB7XG4gICAgICAgIGNhc2UgXCJzXCI6IC8vIHNlY29uZHNcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IG51bSAqIDEwMDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm1zXCI6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBtaWxsaXNlY29uZHMgPSBudW07XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gbWlsbGlzZWNvbmRzIHx8IDA7XG59O1xuXG5jb25zdCBhbmltYXRlZCA9IGZ1bmN0aW9uKGVsLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGRlZmF1bHRWaWV3ID0gKGVsLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQpLmRlZmF1bHRWaWV3O1xuXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNhbGxiYWNrLmFwcGx5KCk7XG4gICAgfSwgY29udmVydEFuaW1hdGlvbkRlbGF5VG9JbnQoZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbCkuYW5pbWF0aW9uRHVyYXRpb24pKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdhY3Rpdml0eS1idXR0b24nLFxuXG4gICAgY29tcG9uZW50czoge1xuICAgICAgICBBY3Rpdml0eUluZGljYXRvclxuICAgIH0sXG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYWtlIHRoZSBidXR0b24gYXBwZWFyIHdpdGggdGhlIGFjdGl2ZSBzdGF0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IHtCb29sZWF9bn1cbiAgICAgICAgICovXG4gICAgICAgIGFjdGl2ZTogQm9vbGVhbixcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvdyB0aGUgYWN0aXZpdHkgaW5kaWNhdG9yIGluc2lkZSB0aGUgYnV0dG9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkge0Jvb2xlYX1ufVxuICAgICAgICAgKi9cbiAgICAgICAgYWN0aXZpdHk6IEJvb2xlYW4sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc3BsYXkgdGhlIGJ1dHRvbiBhcyBibG9jayB3aWR0aC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IHtCb29sZWF9bn1cbiAgICAgICAgICovXG4gICAgICAgIGJsb2NrOiBCb29sZWFuLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYWtlIHRoZSBidXR0b24gYXBwZWFyIHdpdGggdGhlIGRpc2FibGVkIHN0YXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkge0Jvb2xlYX1ufVxuICAgICAgICAgKi9cbiAgICAgICAgZGlzYWJsZWQ6IEJvb2xlYW4sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBidXR0b24gbGFiZWwuIElmIG5vdCBwYXNzZWQgYXMgYSBwcm9wZXJ0eSwgbGFiZWwgbXVzdCBiZSBwYXNzZWRcbiAgICAgICAgICogaW5zaWRlIHRoZSBlbGVtZW50J3MgaHRtbC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IHtTdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBsYWJlbDogU3RyaW5nLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYnV0dG9uIGljb25cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IHtTdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBpY29uOiBTdHJpbmcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBgdHlwZWAgYXR0cmlidXRlIGZvciB0aGUgYnV0dG9uIGVsZW1lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdHlwZTogU3RyaW5nLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc2l6ZSBvZiB0aGUgYnV0dG9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkge1N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHNpemU6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdtZCdcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHZhcmlhbnQgb2YgdGhlIGJ1dHRvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IHtTdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB2YXJpYW50OiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAncHJpbWFyeSdcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHR5cGUgb2YgYWN0aXZpdHkgaW5kaWNhdG9yIGluc2lkZSB0aGUgYnV0dG9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkge1N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIGluZGljYXRvcjoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJ3NwaW5uZXInXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBvcmllbnRhdGlvbiBvZiB0aGUgYWN0aXZpdHkgYnV0dG9uIGluc2lkZSB0aGUgYnV0dG9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkge1N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIG9yaWVudGF0aW9uOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAncmlnaHQnXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWV0aG9kczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNhYmxlIHRoZSBidXR0b24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAgICAgKi9cbiAgICAgICAgZGlzYWJsZSgpIHtcbiAgICAgICAgICAgIHRoaXMuJGVsLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5hYmxlIHRoZSBidXR0b24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAgICAgKi9cbiAgICAgICAgZW5hYmxlKCkge1xuICAgICAgICAgICAgdGhpcy4kZWwuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvdyB0aGUgYWN0aXZpdHkgaW5kaWNhdG9yIGluc2lkZSB0aGUgYnV0dG9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgICAgICovXG4gICAgICAgIHNob3dBY3Rpdml0eSgpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzYWJsZSgpO1xuXG4gICAgICAgICAgICBhbmltYXRlZCh0aGlzLiRlbCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuJGVsLmNsYXNzTGlzdC5hZGQoJ2J0bi1hY3Rpdml0eScpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2FjdGl2aXR5OnNob3cnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIaWRlIHRoZSBhY3Rpdml0eSBpbmRpY2F0b3IgaW5zaWRlIHRoZSBidXR0b24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAgICAgKi9cbiAgICAgICAgaGlkZUFjdGl2aXR5KCkge1xuICAgICAgICAgICAgdGhpcy4kZWwuY2xhc3NMaXN0LmFkZCgnYnRuLWhpZGUtYWN0aXZpdHknKTtcblxuICAgICAgICAgICAgYW5pbWF0ZWQodGhpcy4kZWwsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmVuYWJsZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGVsLmNsYXNzTGlzdC5yZW1vdmUoJ2J0bi1hY3Rpdml0eScsICdidG4taGlkZS1hY3Rpdml0eScpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2FjdGl2aXR5OmhpZGUnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY2xpY2sgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB2b2lkXG4gICAgICAgICAqL1xuICAgICAgICBvbkNsaWNrKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCdjbGljaycsIGV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGNvbXB1dGVkOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIG9iamVjdCBvZiBjbGFzc2VzIHRvIGFwcGVuZCB0byB0aGUgYnV0dG9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzZXMoKSB7XG4gICAgICAgICAgICBjb25zdCBjbGFzc2VzID0ge1xuICAgICAgICAgICAgICAgICdkaXNhYmxlZCc6IHRoaXMuZGlzYWJsZWQsXG4gICAgICAgICAgICAgICAgJ2FjdGl2ZSc6IHRoaXMuYWN0aXZlLFxuICAgICAgICAgICAgICAgICdidG4tYmxvY2snOiB0aGlzLmJsb2NrLFxuICAgICAgICAgICAgICAgICdidG4tYWN0aXZpdHknOiB0aGlzLmFjdGl2aXR5XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBjbGFzc2VzWydidG4tJyArIHRoaXMuc2l6ZS5yZXBsYWNlKCdidG4tJywgJycpXSA9ICEhdGhpcy5zaXplO1xuICAgICAgICAgICAgY2xhc3Nlc1snYnRuLScgKyB0aGlzLnZhcmlhbnQucmVwbGFjZSgnYnRuLScsICcnKV0gPSAhIXRoaXMudmFyaWFudDtcbiAgICAgICAgICAgIGNsYXNzZXNbJ2J0bi1hY3Rpdml0eS0nICsgdGhpcy5vcmllbnRhdGlvbi5yZXBsYWNlKCdidG4tYWN0aXZpdHktJywgJycpXSA9ICEhdGhpcy5vcmllbnRhdGlvbjtcbiAgICAgICAgICAgIGNsYXNzZXNbJ2J0bi1hY3Rpdml0eS1pbmRpY2F0b3ItJyArIHRoaXMuaW5kaWNhdG9yLnJlcGxhY2UoJ2J0bi1hY3Rpdml0eS1pbmRpY2F0b3ItJywgJycpXSA9ICEhdGhpcy5pbmRpY2F0b3I7XG5cbiAgICAgICAgICAgIHJldHVybiBjbGFzc2VzO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHdhdGNoOiB7XG5cbiAgICAgICAgYWN0aXZpdHkodmFsdWUpIHtcbiAgICAgICAgICAgIGlmKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaG93QWN0aXZpdHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaGlkZUFjdGl2aXR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH1cblxufVxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwic2Nzc1wiPlxuQGltcG9ydCAnLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwL3Njc3MvZnVuY3Rpb25zLnNjc3MnO1xuQGltcG9ydCAnLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwL3Njc3MvdmFyaWFibGVzLnNjc3MnO1xuXG4vLyBBY3Rpdml0eSBJbmRpY2F0b3IgdmFyaWFibGVzXG4kYWN0aXZpdHktaW5kaWNhdG9yLWFuaW1hdGVkLWRlbGF5LWluOiAzMzNtcztcbiRhY3Rpdml0eS1pbmRpY2F0b3ItYW5pbWF0ZWQtZGVsYXktb3V0OiAzMzNtcztcblxuJGFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyLXNpemU6ICRmb250LXNpemUtYmFzZSAqIDIuMjU7XG4kYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXItd2lkdGg6IDEwJTtcbiRhY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lci1oZWlnaHQ6IDMwJTtcbiRhY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lci1kZWxheTogMXM7XG5cbkBrZXlmcmFtZXMgYnRuLWFjdGl2aXR5LWluIHtcbiAgICAwJSwgMTAwJSB7XG4gICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMSk7XG4gICAgfSAzMCUge1xuICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKC45OCk7XG4gICAgfVxufVxuXG5Aa2V5ZnJhbWVzIGJ0bi1hY3Rpdml0eS1vdXQge1xuICAgIDAlLCAxMDAlIHtcbiAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgxKTtcbiAgICB9IDcwJSB7XG4gICAgICAgIHRyYW5zZm9ybTogc2NhbGUoLjk4KTtcbiAgICB9XG59XG5cbi8vIEFjdGl2aXR5IEluZGljYXRvciBCdXR0b25cbi5idG4tYWN0aXZpdHktdG9wLFxuLmJ0bi1hY3Rpdml0eS1ib3R0b20sXG4uYnRuLWFjdGl2aXR5LWxlZnQsXG4uYnRuLWFjdGl2aXR5LXJpZ2h0IHtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgdHJhbnNpdGlvbjogcGFkZGluZyAoJGFjdGl2aXR5LWluZGljYXRvci1hbmltYXRlZC1kZWxheS1pbiAvIDIpIGVhc2UtaW47XG5cbiAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICBvcGFjaXR5OiAwO1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcbiAgICAgICAgdHJhbnNpdGlvbjogb3BhY2l0eSAkYWN0aXZpdHktaW5kaWNhdG9yLWFuaW1hdGVkLWRlbGF5LW91dCBlYXNlLWluO1xuICAgIH1cbn1cblxuLmJ0bi1hY3Rpdml0eS10b3AgLmFjdGl2aXR5LWluZGljYXRvcixcbi5idG4tYWN0aXZpdHktYm90dG9tIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgIGxlZnQ6IDUwJTtcbiAgICBtYXJnaW4tcmlnaHQ6IC01MCU7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MCUpO1xufVxuLmJ0bi1hY3Rpdml0eS1sZWZ0IC5hY3Rpdml0eS1pbmRpY2F0b3IsXG4uYnRuLWFjdGl2aXR5LXJpZ2h0IC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgIHRvcDogNTAlO1xuICAgIG1hcmdpbi1ib3R0b206IC01MCU7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC01MCUpO1xufVxuXG4uYnRuLWFjdGl2aXR5Om5vdCguYnRuLWxpbmspIHtcbiAgICBhbmltYXRpb246IGJ0bi1hY3Rpdml0eS1pbiAkYWN0aXZpdHktaW5kaWNhdG9yLWFuaW1hdGVkLWRlbGF5LWluO1xufVxuLmJ0bi1oaWRlLWFjdGl2aXR5Om5vdCguYnRuLWxpbmspIHtcbiAgICBhbmltYXRpb246IGJ0bi1hY3Rpdml0eS1vdXQgJGFjdGl2aXR5LWluZGljYXRvci1hbmltYXRlZC1kZWxheS1vdXQ7XG59XG5cbi5idG4tYWN0aXZpdHkge1xuXG4gICAgJi5idG4taGlkZS1hY3Rpdml0eSAuYWN0aXZpdHktaW5kaWNhdG9yIHtcbiAgICAgICAgb3BhY2l0eTogMDtcbiAgICB9XG5cbiAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICBvcGFjaXR5OiAxO1xuICAgICAgICB2aXNpYmlsaXR5OiB2aXNpYmxlO1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgfVxuXG4gICAgJi5idG4tb3V0bGluZS1wcmltYXJ5LmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lciAuYWN0aXZpdHktaW5kaWNhdG9yID4gZGl2OmJlZm9yZSB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICRwcmltYXJ5O1xuICAgIH1cbiAgICAmLmJ0bi1vdXRsaW5lLXNlY29uZGFyeS5idG4tYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIgLmFjdGl2aXR5LWluZGljYXRvciA+IGRpdjpiZWZvcmUge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkc3VjY2VzcztcbiAgICB9XG4gICAgJi5idG4tb3V0bGluZS1kYW5nZXIuYnRuLWFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyIC5hY3Rpdml0eS1pbmRpY2F0b3IgPiBkaXY6YmVmb3JlIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogJGRhbmdlcjtcbiAgICB9XG4gICAgJi5idG4tb3V0bGluZS1zdWNjZXNzLmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lciAuYWN0aXZpdHktaW5kaWNhdG9yID4gZGl2OmJlZm9yZSB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICRzdWNjZXNzO1xuICAgIH1cbiAgICAmLmJ0bi1vdXRsaW5lLXdhcm5pbmcuYnRuLWFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyIC5hY3Rpdml0eS1pbmRpY2F0b3IgPiBkaXY6YmVmb3JlIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogJHdhcm5pbmc7XG4gICAgfVxuICAgICYuYnRuLW91dGxpbmUtaW5mby5idG4tYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIgLmFjdGl2aXR5LWluZGljYXRvciA+IGRpdjpiZWZvcmUge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkaW5mbztcbiAgICB9XG4gICAgJi5idG4tb3V0bGluZS1saW5rLmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lciAuYWN0aXZpdHktaW5kaWNhdG9yID4gZGl2OmJlZm9yZSB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICRsaW5rLWNvbG9yO1xuICAgIH1cblxuICAgICYuYnRuLXhzIHtcbiAgICAgICAgJi5idG4tYWN0aXZpdHktdG9wLmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyB7XG4gICAgICAgICAgICBwYWRkaW5nLXRvcDogJGZvbnQtc2l6ZS1iYXNlICogMS4yNTtcblxuICAgICAgICAgICAgJiAuYWN0aXZpdHktaW5kaWNhdG9yIHtcbiAgICAgICAgICAgICAgICB0b3A6ICRmb250LXNpemUtYmFzZSAqIC41O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJi5idG4tYWN0aXZpdHktYm90dG9tLmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyB7XG4gICAgICAgICAgICBwYWRkaW5nLWJvdHRvbTogJGZvbnQtc2l6ZS1iYXNlICogMS4yNTtcblxuICAgICAgICAgICAgJiAuYWN0aXZpdHktaW5kaWNhdG9yIHtcbiAgICAgICAgICAgICAgICBib3R0b206ICRmb250LXNpemUtYmFzZSAqIC41O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJi5idG4tYWN0aXZpdHktbGVmdC5idG4tYWN0aXZpdHktaW5kaWNhdG9yLWRvdHMge1xuICAgICAgICAgICAgcGFkZGluZy1sZWZ0OiAkZm9udC1zaXplLWJhc2UgKiAyLjMzO1xuXG4gICAgICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICAgICAgICAgIGxlZnQ6ICRmb250LXNpemUtYmFzZSAqIC41O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJi5idG4tYWN0aXZpdHktcmlnaHQuYnRuLWFjdGl2aXR5LWluZGljYXRvci1kb3RzIHtcbiAgICAgICAgICAgIHBhZGRpbmctcmlnaHQ6ICRmb250LXNpemUtYmFzZSAqIDIuMzM7XG5cbiAgICAgICAgICAgICYgLmFjdGl2aXR5LWluZGljYXRvciB7XG4gICAgICAgICAgICAgICAgcmlnaHQ6ICRmb250LXNpemUtYmFzZSAqIC41O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJi5idG4tYWN0aXZpdHktaW5kaWNhdG9yLWRvdHMgLmFjdGl2aXR5LWluZGljYXRvciA+IGRpdixcbiAgICAgICAgJiAuYWN0aXZpdHktaW5kaWNhdG9yLWRvdHMgPiBkaXYge1xuICAgICAgICAgICAgd2lkdGg6ICRmb250LXNpemUtYmFzZSAvIDM7XG4gICAgICAgICAgICBoZWlnaHQ6ICRmb250LXNpemUtYmFzZSAvIDM7XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS10b3AuYnRuLWFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyIHtcbiAgICAgICAgICAgIHBhZGRpbmctdG9wOiAkZm9udC1zaXplLWJhc2UgKiAxLjY2O1xuXG4gICAgICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICAgICAgICAgIHRvcDogJGZvbnQtc2l6ZS1iYXNlICogLjI1O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJi5idG4tYWN0aXZpdHktYm90dG9tLmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lciB7XG4gICAgICAgICAgICBwYWRkaW5nLWJvdHRvbTogJGZvbnQtc2l6ZS1iYXNlICogMS42NjtcblxuICAgICAgICAgICAgJiAuYWN0aXZpdHktaW5kaWNhdG9yIHtcbiAgICAgICAgICAgICAgICBib3R0b206ICRmb250LXNpemUtYmFzZSAqIC4yNTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICYuYnRuLWFjdGl2aXR5LWxlZnQuYnRuLWFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyIHtcbiAgICAgICAgICAgIHBhZGRpbmctbGVmdDogJGZvbnQtc2l6ZS1iYXNlICogMS42NjtcblxuICAgICAgICAgICAgJiAuYWN0aXZpdHktaW5kaWNhdG9yIHtcbiAgICAgICAgICAgICAgICBsZWZ0OiAkZm9udC1zaXplLWJhc2UgKiAuMjU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1yaWdodC5idG4tYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIge1xuICAgICAgICAgICAgcGFkZGluZy1yaWdodDogJGZvbnQtc2l6ZS1iYXNlICogMS42NjtcblxuICAgICAgICAgICAgJiAuYWN0aXZpdHktaW5kaWNhdG9yIHtcbiAgICAgICAgICAgICAgICByaWdodDogJGZvbnQtc2l6ZS1iYXNlICogLjI1O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJi5idG4tYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIgLmFjdGl2aXR5LWluZGljYXRvcixcbiAgICAgICAgJiAuYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIge1xuICAgICAgICAgICAgd2lkdGg6ICRmb250LXNpemUtYmFzZSAqIDE7XG4gICAgICAgICAgICBoZWlnaHQ6ICRmb250LXNpemUtYmFzZSAqIDE7XG5cbiAgICAgICAgICAgICYgPiBkaXY6YmVmb3JlIHtcbiAgICAgICAgICAgICAgICAvL3dpZHRoOiAkYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXItd2lkdGggKiAuNjM7XG4gICAgICAgICAgICAgICAgLy9oZWlnaHQ6ICRhY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lci1oZWlnaHQgKiAuNjY7XG4gICAgICAgICAgICAgICAgd2lkdGg6ICRhY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lci13aWR0aCAqIC44NDtcbiAgICAgICAgICAgICAgICBoZWlnaHQ6ICRhY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lci1oZWlnaHQgKiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgJi5idG4tc20ge1xuICAgICAgICAmLmJ0bi1hY3Rpdml0eS10b3AuYnRuLWFjdGl2aXR5LWluZGljYXRvci1kb3RzIHtcbiAgICAgICAgICAgIHBhZGRpbmctdG9wOiAkZm9udC1zaXplLWJhc2UgKiAxLjc1O1xuXG4gICAgICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICAgICAgICAgIHRvcDogJGZvbnQtc2l6ZS1iYXNlICogLjU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1ib3R0b20uYnRuLWFjdGl2aXR5LWluZGljYXRvci1kb3RzIHtcbiAgICAgICAgICAgIHBhZGRpbmctYm90dG9tOiAkZm9udC1zaXplLWJhc2UgKiAxLjc1O1xuXG4gICAgICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICAgICAgICAgIGJvdHRvbTogJGZvbnQtc2l6ZS1iYXNlICogLjU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1sZWZ0LmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyB7XG4gICAgICAgICAgICBwYWRkaW5nLWxlZnQ6ICRmb250LXNpemUtYmFzZSAqIDM7XG5cbiAgICAgICAgICAgICYgLmFjdGl2aXR5LWluZGljYXRvciB7XG4gICAgICAgICAgICAgICAgbGVmdDogJGZvbnQtc2l6ZS1iYXNlICogLjU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1yaWdodC5idG4tYWN0aXZpdHktaW5kaWNhdG9yLWRvdHMge1xuICAgICAgICAgICAgcGFkZGluZy1yaWdodDogJGZvbnQtc2l6ZS1iYXNlICogMztcblxuICAgICAgICAgICAgJiAuYWN0aXZpdHktaW5kaWNhdG9yIHtcbiAgICAgICAgICAgICAgICByaWdodDogJGZvbnQtc2l6ZS1iYXNlICogLjU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyAuYWN0aXZpdHktaW5kaWNhdG9yID4gZGl2LFxuICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyA+IGRpdiB7XG4gICAgICAgICAgICB3aWR0aDogJGZvbnQtc2l6ZS1iYXNlIC8gMjtcbiAgICAgICAgICAgIGhlaWdodDogJGZvbnQtc2l6ZS1iYXNlIC8gMjtcbiAgICAgICAgfVxuXG4gICAgICAgICYuYnRuLWFjdGl2aXR5LXRvcC5idG4tYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIge1xuICAgICAgICAgICAgcGFkZGluZy10b3A6ICRmb250LXNpemUtYmFzZSAqIDI7XG5cbiAgICAgICAgICAgICYgLmFjdGl2aXR5LWluZGljYXRvciB7XG4gICAgICAgICAgICAgICAgdG9wOiAkZm9udC1zaXplLWJhc2UgKiAuMzM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1ib3R0b20uYnRuLWFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyIHtcbiAgICAgICAgICAgIHBhZGRpbmctYm90dG9tOiAkZm9udC1zaXplLWJhc2UgKiAyO1xuXG4gICAgICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICAgICAgICAgIGJvdHRvbTogJGZvbnQtc2l6ZS1iYXNlICogLjMzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJi5idG4tYWN0aXZpdHktbGVmdC5idG4tYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIge1xuICAgICAgICAgICAgcGFkZGluZy1sZWZ0OiAkZm9udC1zaXplLWJhc2UgKiAyLjU7XG5cbiAgICAgICAgICAgICYgLmFjdGl2aXR5LWluZGljYXRvciB7XG4gICAgICAgICAgICAgICAgbGVmdDogJGZvbnQtc2l6ZS1iYXNlICogLjU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1yaWdodC5idG4tYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIge1xuICAgICAgICAgICAgcGFkZGluZy1yaWdodDogJGZvbnQtc2l6ZS1iYXNlICogMi41O1xuXG4gICAgICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICAgICAgICAgIHJpZ2h0OiAkZm9udC1zaXplLWJhc2UgKiAuNTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICYuYnRuLWFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyIC5hY3Rpdml0eS1pbmRpY2F0b3IsXG4gICAgICAgICYgLmFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyIHtcbiAgICAgICAgICAgIHdpZHRoOiAkZm9udC1zaXplLWJhc2UgKiAxLjU7XG4gICAgICAgICAgICBoZWlnaHQ6ICRmb250LXNpemUtYmFzZSAqIDEuNTtcblxuICAgICAgICAgICAgJiA+IGRpdjpiZWZvcmUge1xuICAgICAgICAgICAgICAgIHdpZHRoOiAkYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXItd2lkdGggKiAuNTY7XG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAkYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXItaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgJjpub3QoLmJ0bi14cyk6bm90KC5idG4tc20pOm5vdCguYnRuLW1kKTpub3QoLmJ0bi1sZyk6bm90KC5idG4teGwpLFxuICAgICYuYnRuLW1kIHtcbiAgICAgICAgJi5idG4tYWN0aXZpdHktdG9wLmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyB7XG4gICAgICAgICAgICBwYWRkaW5nLXRvcDogJGZvbnQtc2l6ZS1iYXNlICogMjtcblxuICAgICAgICAgICAgJiAuYWN0aXZpdHktaW5kaWNhdG9yIHtcbiAgICAgICAgICAgICAgICB0b3A6ICRmb250LXNpemUtYmFzZSAqIC42NjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICYuYnRuLWFjdGl2aXR5LWJvdHRvbS5idG4tYWN0aXZpdHktaW5kaWNhdG9yLWRvdHMge1xuICAgICAgICAgICAgcGFkZGluZy1ib3R0b206ICRmb250LXNpemUtYmFzZSAqIDI7XG5cbiAgICAgICAgICAgICYgLmFjdGl2aXR5LWluZGljYXRvciB7XG4gICAgICAgICAgICAgICAgYm90dG9tOiAkZm9udC1zaXplLWJhc2UgKiAuNjY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1sZWZ0LmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyB7XG4gICAgICAgICAgICBwYWRkaW5nLWxlZnQ6ICRmb250LXNpemUtYmFzZSAqIDQ7XG5cbiAgICAgICAgICAgICYgLmFjdGl2aXR5LWluZGljYXRvciB7XG4gICAgICAgICAgICAgICAgbGVmdDogJGZvbnQtc2l6ZS1iYXNlICogLjU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1yaWdodC5idG4tYWN0aXZpdHktaW5kaWNhdG9yLWRvdHMge1xuICAgICAgICAgICAgcGFkZGluZy1yaWdodDogJGZvbnQtc2l6ZS1iYXNlICogNDtcblxuICAgICAgICAgICAgJiAuYWN0aXZpdHktaW5kaWNhdG9yIHtcbiAgICAgICAgICAgICAgICByaWdodDogJGZvbnQtc2l6ZS1iYXNlICogLjU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyAuYWN0aXZpdHktaW5kaWNhdG9yID4gZGl2LFxuICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyA+IGRpdiB7XG4gICAgICAgICAgICB3aWR0aDogJGZvbnQtc2l6ZS1iYXNlIC8gMS4yNTtcbiAgICAgICAgICAgIGhlaWdodDogJGZvbnQtc2l6ZS1iYXNlIC8gMS4yNTtcbiAgICAgICAgfVxuXG4gICAgICAgICYuYnRuLWFjdGl2aXR5LXRvcC5idG4tYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIge1xuICAgICAgICAgICAgcGFkZGluZy10b3A6ICRmb250LXNpemUtYmFzZSAqIDIuNzU7XG5cbiAgICAgICAgICAgICYgLmFjdGl2aXR5LWluZGljYXRvciB7XG4gICAgICAgICAgICAgICAgdG9wOiAkZm9udC1zaXplLWJhc2UgKiAuMzM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1ib3R0b20uYnRuLWFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyIHtcbiAgICAgICAgICAgIHBhZGRpbmctYm90dG9tOiAkZm9udC1zaXplLWJhc2UgKiAyLjc1O1xuXG4gICAgICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICAgICAgICAgIGJvdHRvbTogJGZvbnQtc2l6ZS1iYXNlICogLjMzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJi5idG4tYWN0aXZpdHktbGVmdC5idG4tYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIge1xuICAgICAgICAgICAgcGFkZGluZy1sZWZ0OiAkZm9udC1zaXplLWJhc2UgKiAyLjc1O1xuXG4gICAgICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICAgICAgICAgIGxlZnQ6ICRmb250LXNpemUtYmFzZSAqIC41O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJi5idG4tYWN0aXZpdHktcmlnaHQuYnRuLWFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyIHtcbiAgICAgICAgICAgIHBhZGRpbmctcmlnaHQ6ICRmb250LXNpemUtYmFzZSAqIDIuNzU7XG5cbiAgICAgICAgICAgICYgLmFjdGl2aXR5LWluZGljYXRvciB7XG4gICAgICAgICAgICAgICAgcmlnaHQ6ICRmb250LXNpemUtYmFzZSAqIC41O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJi5idG4tYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIgLmFjdGl2aXR5LWluZGljYXRvcixcbiAgICAgICAgJiAuYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIge1xuICAgICAgICAgICAgd2lkdGg6ICRmb250LXNpemUtYmFzZSAqIDEuNzU7XG4gICAgICAgICAgICBoZWlnaHQ6ICRmb250LXNpemUtYmFzZSAqIDEuNzU7XG5cbiAgICAgICAgICAgICYgPiBkaXY6YmVmb3JlIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogJGFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyLXdpZHRoICogLjY2O1xuICAgICAgICAgICAgICAgIGhlaWdodDogJGFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyLWhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgICYuYnRuLWxnIHtcbiAgICAgICAgJi5idG4tYWN0aXZpdHktdG9wLmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyB7XG4gICAgICAgICAgICBwYWRkaW5nLXRvcDogJGZvbnQtc2l6ZS1iYXNlICogMi43NTtcblxuICAgICAgICAgICAgJiAuYWN0aXZpdHktaW5kaWNhdG9yIHtcbiAgICAgICAgICAgICAgICB0b3A6ICRmb250LXNpemUtYmFzZSAqIC42NjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICYuYnRuLWFjdGl2aXR5LWJvdHRvbS5idG4tYWN0aXZpdHktaW5kaWNhdG9yLWRvdHMge1xuICAgICAgICAgICAgcGFkZGluZy1ib3R0b206ICRmb250LXNpemUtYmFzZSAqIDIuNzU7XG5cbiAgICAgICAgICAgICYgLmFjdGl2aXR5LWluZGljYXRvciB7XG4gICAgICAgICAgICAgICAgYm90dG9tOiAkZm9udC1zaXplLWJhc2UgKiAuNjY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1sZWZ0LmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyB7XG4gICAgICAgICAgICBwYWRkaW5nLWxlZnQ6ICRmb250LXNpemUtYmFzZSAqIDU7XG5cbiAgICAgICAgICAgICYgLmFjdGl2aXR5LWluZGljYXRvciB7XG4gICAgICAgICAgICAgICAgbGVmdDogJGZvbnQtc2l6ZS1iYXNlICogLjU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1yaWdodC5idG4tYWN0aXZpdHktaW5kaWNhdG9yLWRvdHMge1xuICAgICAgICAgICAgcGFkZGluZy1yaWdodDogJGZvbnQtc2l6ZS1iYXNlICogNTtcblxuICAgICAgICAgICAgJiAuYWN0aXZpdHktaW5kaWNhdG9yIHtcbiAgICAgICAgICAgICAgICByaWdodDogJGZvbnQtc2l6ZS1iYXNlICogLjU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyAuYWN0aXZpdHktaW5kaWNhdG9yID4gZGl2LFxuICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyA+IGRpdiB7XG4gICAgICAgICAgICB3aWR0aDogJGZvbnQtc2l6ZS1iYXNlICogMS4xO1xuICAgICAgICAgICAgaGVpZ2h0OiAkZm9udC1zaXplLWJhc2UgKiAxLjE7XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS10b3AuYnRuLWFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyIHtcbiAgICAgICAgICAgIHBhZGRpbmctdG9wOiAkZm9udC1zaXplLWJhc2UgKiAzLjU7XG5cbiAgICAgICAgICAgICYgLmFjdGl2aXR5LWluZGljYXRvciB7XG4gICAgICAgICAgICAgICAgdG9wOiAkZm9udC1zaXplLWJhc2UgKiAuNTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICYuYnRuLWFjdGl2aXR5LWJvdHRvbS5idG4tYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIge1xuICAgICAgICAgICAgcGFkZGluZy1ib3R0b206ICRmb250LXNpemUtYmFzZSAqIDMuNTtcblxuICAgICAgICAgICAgJiAuYWN0aXZpdHktaW5kaWNhdG9yIHtcbiAgICAgICAgICAgICAgICBib3R0b206ICRmb250LXNpemUtYmFzZSAqIC41O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJi5idG4tYWN0aXZpdHktbGVmdC5idG4tYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIge1xuICAgICAgICAgICAgcGFkZGluZy1sZWZ0OiAkZm9udC1zaXplLWJhc2UgKiAzLjI1O1xuXG4gICAgICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICAgICAgICAgIGxlZnQ6ICRmb250LXNpemUtYmFzZSAqIC41O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJi5idG4tYWN0aXZpdHktcmlnaHQuYnRuLWFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyIHtcbiAgICAgICAgICAgIHBhZGRpbmctcmlnaHQ6ICRmb250LXNpemUtYmFzZSAqIDMuMjU7XG5cbiAgICAgICAgICAgICYgLmFjdGl2aXR5LWluZGljYXRvciB7XG4gICAgICAgICAgICAgICAgcmlnaHQ6ICRmb250LXNpemUtYmFzZSAqIC41O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJi5idG4tYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIgLmFjdGl2aXR5LWluZGljYXRvcixcbiAgICAgICAgJiAuYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIge1xuICAgICAgICAgICAgd2lkdGg6ICRmb250LXNpemUtYmFzZSAqIDIuMTU7XG4gICAgICAgICAgICBoZWlnaHQ6ICRmb250LXNpemUtYmFzZSAqIDIuMTU7XG5cbiAgICAgICAgICAgICYgPiBkaXY6YmVmb3JlIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogJGFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyLXdpZHRoICogLjc1O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgJi5idG4teGwge1xuICAgICAgICAmLmJ0bi1hY3Rpdml0eS10b3AuYnRuLWFjdGl2aXR5LWluZGljYXRvci1kb3RzIHtcbiAgICAgICAgICAgIHBhZGRpbmctdG9wOiAkZm9udC1zaXplLWJhc2UgKiAzLjc1O1xuXG4gICAgICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICAgICAgICAgIHRvcDogJGZvbnQtc2l6ZS1iYXNlICogMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICYuYnRuLWFjdGl2aXR5LWJvdHRvbS5idG4tYWN0aXZpdHktaW5kaWNhdG9yLWRvdHMge1xuICAgICAgICAgICAgcGFkZGluZy1ib3R0b206ICRmb250LXNpemUtYmFzZSAqIDMuNzU7XG5cbiAgICAgICAgICAgICYgLmFjdGl2aXR5LWluZGljYXRvciB7XG4gICAgICAgICAgICAgICAgYm90dG9tOiAkZm9udC1zaXplLWJhc2UgKiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJi5idG4tYWN0aXZpdHktbGVmdC5idG4tYWN0aXZpdHktaW5kaWNhdG9yLWRvdHMge1xuICAgICAgICAgICAgcGFkZGluZy1sZWZ0OiAkZm9udC1zaXplLWJhc2UgKiA2O1xuXG4gICAgICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICAgICAgICAgIGxlZnQ6ICRmb250LXNpemUtYmFzZSAqIC43NTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICYuYnRuLWFjdGl2aXR5LXJpZ2h0LmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyB7XG4gICAgICAgICAgICBwYWRkaW5nLXJpZ2h0OiAkZm9udC1zaXplLWJhc2UgKiA2O1xuXG4gICAgICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICAgICAgICAgIHJpZ2h0OiAkZm9udC1zaXplLWJhc2UgKiAuNzU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyAuYWN0aXZpdHktaW5kaWNhdG9yID4gZGl2LFxuICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyA+IGRpdiB7XG4gICAgICAgICAgICB3aWR0aDogJGZvbnQtc2l6ZS1iYXNlICogMS4yNTtcbiAgICAgICAgICAgIGhlaWdodDogJGZvbnQtc2l6ZS1iYXNlICogMS4yNTtcbiAgICAgICAgfVxuXG4gICAgICAgICYuYnRuLWFjdGl2aXR5LXRvcC5idG4tYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIge1xuICAgICAgICAgICAgcGFkZGluZy10b3A6ICRmb250LXNpemUtYmFzZSAqIDQuMjU7XG5cbiAgICAgICAgICAgICYgLmFjdGl2aXR5LWluZGljYXRvciB7XG4gICAgICAgICAgICAgICAgdG9wOiAkZm9udC1zaXplLWJhc2UgKiAuNjY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1ib3R0b20uYnRuLWFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyIHtcbiAgICAgICAgICAgIHBhZGRpbmctYm90dG9tOiAkZm9udC1zaXplLWJhc2UgKiA0LjI1O1xuXG4gICAgICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICAgICAgICAgIGJvdHRvbTogJGZvbnQtc2l6ZS1iYXNlICogLjY2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJi5idG4tYWN0aXZpdHktbGVmdC5idG4tYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIge1xuICAgICAgICAgICAgcGFkZGluZy1sZWZ0OiAkZm9udC1zaXplLWJhc2UgKiA0O1xuXG4gICAgICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICAgICAgICAgIGxlZnQ6ICRmb250LXNpemUtYmFzZSAqIC43NTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICYuYnRuLWFjdGl2aXR5LXJpZ2h0LmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lciB7XG4gICAgICAgICAgICBwYWRkaW5nLXJpZ2h0OiAkZm9udC1zaXplLWJhc2UgKiA0O1xuXG4gICAgICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICAgICAgICAgIHJpZ2h0OiAkZm9udC1zaXplLWJhc2UgKiAuNzU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lciAuYWN0aXZpdHktaW5kaWNhdG9yLFxuICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lciB7XG4gICAgICAgICAgICB3aWR0aDogJGZvbnQtc2l6ZS1iYXNlICogMi41O1xuICAgICAgICAgICAgaGVpZ2h0OiAkZm9udC1zaXplLWJhc2UgKiAyLjU7XG5cbiAgICAgICAgICAgICYgPiBkaXY6YmVmb3JlIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogJGFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyLXdpZHRoICogLjc1O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG59XG48L3N0eWxlPlxuIiwiaW1wb3J0IEJ0bkFjdGl2aXR5IGZyb20gJy4vQnRuQWN0aXZpdHknO1xuaW1wb3J0IFZ1ZUluc3RhbGxlciBmcm9tICcuLi8uLi9IZWxwZXJzL1Z1ZUluc3RhbGxlci9WdWVJbnN0YWxsZXInO1xuXG5jb25zdCBwbHVnaW4gPSBWdWVJbnN0YWxsZXIudXNlKHtcblxuICAgIGluc3RhbGwoVnVlLCBvcHRpb25zKSB7XG4gICAgICAgIFZ1ZUluc3RhbGxlci5jb21wb25lbnRzKHtcbiAgICAgICAgICAgIEJ0bkFjdGl2aXR5XG4gICAgICAgIH0pXG4gICAgfVxuXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgQnRuQWN0aXZpdHk7XG4iLCI8dGVtcGxhdGU+XG4gICAgPGRpdiBjbGFzcz1cIm1vZGFsLWNvbnRlbnRcIj48c2xvdC8+PC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ21vZGFsLWNvbnRlbnQnXG5cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICAgIDxkaXYgY2xhc3M9XCJtb2RhbC1iYWNrZHJvcFwiIDpjbGFzcz1cInsnZmFkZSc6IGZhZGUsICdzaG93Jzogc2hvd31cIj5cbiAgICAgICAgPHNsb3QvPlxuICAgIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdtb2RhbC1iYWNrZHJvcCcsXG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG93IHRoZSBtb2RhbCB3aXRoIGEgZmFkZSBlZmZlY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBCb29sZWFuXG4gICAgICAgICAqL1xuICAgICAgICBmYWRlOiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJcyB0aGUgbW9kYWwgc2hvd2luZy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IEJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIHNob3c6IHtcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgICBkZWZhdWx0OiB0cnVlXG4gICAgICAgIH1cblxuICAgIH1cblxufVxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgYmFzZUdldFRhZyBmcm9tICcuL19iYXNlR2V0VGFnLmpzJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3RyaW5nYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3RyaW5nLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTdHJpbmcoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTdHJpbmcoMSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8XG4gICAgKCFpc0FycmF5KHZhbHVlKSAmJiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN0cmluZ1RhZyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzU3RyaW5nO1xuIiwiaW1wb3J0IHsgZWFjaCB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgeyBpc1N0cmluZyB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgdHJhbnNpdGlvbiBmcm9tICcuLi8uLi9IZWxwZXJzL1RyYW5zaXRpb24nO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG93IHRoZSB0cmlnZ2VyYWJsZSBlbGVtZW50IHdpdGggYSBhbmltYXRlZCBmYWRlIGVmZmVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBhbmltYXRpb246IHtcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgICBkZWZhdWx0OiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElzIHRoZSB0cmlnZ2VyYWJsZSBlbGVtZW50IHNob3dpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBCb29sZWFuXG4gICAgICAgICAqL1xuICAgICAgICBzaG93OiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgZGVmYXV0OiBmYWxzZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGFyZ2V0IGVsZW1lbnQgdXNlZCB0byBwb3NpdGlvbiB0aGUgcG9wb3Zlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge1N0cmluZ3xFbGVtZW50fEJvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0YXJnZXQ6IHtcbiAgICAgICAgICAgIHR5cGU6IFtTdHJpbmcsIEVsZW1lbnQsIEJvb2xlYW5dLFxuICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSG93IHRoZSBtb2RhbCBpcyB0cmlnZ2VyZWQgLSBjbGljayB8IGhvdmVyIHwgZm9jdXMgfCBtYW51YWwuIFlvdSBtYXlcbiAgICAgICAgICogcGFzcyBtdWx0aXBsZSB0cmlnZ2Vyczsgc2VwYXJhdGUgdGhlbSB3aXRoIGEgc3BhY2UuIGBtYW51YWxgIGNhbm5vdFxuICAgICAgICAgKiBiZSBjb21iaW5lZCB3aXRoIGFueSBvdGhlciB0cmlnZ2VyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdHJpZ2dlcjoge1xuICAgICAgICAgICAgdHlwZTogW1N0cmluZywgQXJyYXldLFxuICAgICAgICAgICAgZGVmYXVsdDogJ2NsaWNrJ1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgbWV0aG9kczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbml0aWFsaXplIHRoZSB0cmlnZ2VyIGV2ZW50IGZvciB0aGUgc3BlY2lmaWVkIGVsZW1lbnRzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSAge0VsZW1lbnR9IGVsXG4gICAgICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICAgICAqL1xuICAgICAgICBpbml0aWFsaXplVHJpZ2dlcihlbCkge1xuICAgICAgICAgICAgZWFjaChpc1N0cmluZyh0aGlzLnRyaWdnZXIpID8gdGhpcy50cmlnZ2VyLnNwbGl0KCcgJykgOiB0aGlzLnRyaWdnZXIsIHRyaWdnZXIgPT4ge1xuICAgICAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIodHJpZ2dlciwgZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvZ2dsZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluaXRpYWxpemUgdGhlIGV2ZW50IHRyaWdnZXJzXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAgICAgKi9cbiAgICAgICAgaW5pdGlhbGl6ZVRyaWdnZXJzKCkge1xuICAgICAgICAgICAgaWYodGhpcy50YXJnZXQgJiYgdGhpcy50cmlnZ2VyICE9PSAnbWFudWFsJykge1xuICAgICAgICAgICAgICAgIGlmKHRoaXMudGFyZ2V0IGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluaXRpYWxpemVUcmlnZ2VyKHRoaXMudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwodGhpcy50YXJnZXQpLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplVHJpZ2dlcihlbCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYodGhpcy5zaG93IHx8ICF0aGlzLnRhcmdldCkge1xuICAgICAgICAgICAgICAgIHRoaXMuJG5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc1Nob3dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb2N1cyBvbiB0aGUgZmlyc3QgZmllbGQgaW4gdGhlIG1vZGFsIChpZiBleGlzdHMpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgICAgICovXG4gICAgICAgIGZvY3VzKCkge1xuICAgICAgICAgICAgdGhpcy4kbmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVsID0gdGhpcy4kZWwucXVlcnlTZWxlY3RvcignLmZvcm0tY29udHJvbCwgaW5wdXQsIHNlbGVjdCwgdGV4dGFyZWEnKTtcblxuICAgICAgICAgICAgICAgIGlmKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRlbC5mb2N1cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogT3BlbiB0aGUgdHJpZ2dlcmVhYmxlIGVsZW1lbnRcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB0aGlzXG4gICAgICAgICAqL1xuICAgICAgICBvcGVuKCkge1xuICAgICAgICAgICAgdGhpcy5pc0Rpc3BsYXlpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICB0aGlzLiRuZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbih0aGlzLiRlbCkudGhlbihkZWxheSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNTaG93aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZW1pdCgnb3BlbicpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbG9zZSB0aGUgdHJpZ2dlcmVhYmxlIGVsZW1lbnRcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB0aGlzXG4gICAgICAgICAqL1xuICAgICAgICBjbG9zZShldmVudCkge1xuICAgICAgICAgICAgdHJhbnNpdGlvbih0aGlzLiRlbCkudGhlbihkZWxheSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0Rpc3BsYXlpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdjbG9zZScsIGV2ZW50KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLmlzU2hvd2luZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVG9nZ2xlIHRoZSB0cmlnZ2VyZWFibGUgZWxlbWVudCdzIG9wZW4vY2xvc2UgbWV0aG9kLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgICAgICovXG4gICAgICAgIHRvZ2dsZSgpIHtcbiAgICAgICAgICAgIGlmKCF0aGlzLmlzU2hvd2luZykge1xuICAgICAgICAgICAgICAgIHRoaXMub3BlbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGNvbXB1dGVkOiB7XG5cbiAgICAgICAgdHJpZ2dlcmFibGVDbGFzc2VzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAnZmFkZSc6IHRoaXMuYW5pbWF0aW9uLFxuICAgICAgICAgICAgICAgICdzaG93JzogdGhpcy5pc1Nob3dpbmdcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICB3YXRjaDoge1xuXG4gICAgICAgIGlzU2hvd2luZyh2YWx1ZSkge1xuICAgICAgICAgICAgaWYodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2hvdyh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5pc1Nob3dpbmcgPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIG1vdW50ZWQoKSB7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZVRyaWdnZXJzKCk7XG4gICAgfSxcblxuICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpc0Rpc3BsYXlpbmc6IHRoaXMuc2hvdyB8fCAhdGhpcy50YXJnZXQsXG4gICAgICAgICAgICBpc1Nob3dpbmc6IGZhbHNlXG4gICAgICAgIH1cbiAgICB9XG5cbn1cbiIsIjx0ZW1wbGF0ZT5cblxuICAgIDxkaXYgY2xhc3M9XCJtb2RhbFwiIDpjbGFzcz1cInRyaWdnZXJhYmxlQ2xhc3Nlc1wiIDpzdHlsZT1cIntkaXNwbGF5OiBpc0Rpc3BsYXlpbmcgPyAnYmxvY2snIDogJ25vbmUnfVwiIHRhYmluZGV4PVwiLTFcIiByb2xlPVwiZGlhbG9nXCIgQGtleWRvd24uZXNjPVwiY2FuY2VsXCI+XG5cbiAgICAgICAgPG1vZGFsLWJhY2tkcm9wIHYtaWY9XCJiYWNrZHJvcFwiIHJlZj1cImJhY2tkcm9wXCIvPlxuXG4gICAgICAgIDxtb2RhbC1kaWFsb2cgOmNsYXNzPVwieydtb2RhbC1kaWFsb2ctY2VudGVyZWQnOiBjZW50ZXJ9XCI+XG5cbiAgICAgICAgICAgIDxtb2RhbC1jb250ZW50PlxuXG4gICAgICAgICAgICAgICAgPHNsb3QgbmFtZT1cImhlYWRlclwiPlxuICAgICAgICAgICAgICAgICAgICA8bW9kYWwtaGVhZGVyIHYtaWY9XCJ0aXRsZVwiIEBjbG9zZT1cImNhbmNlbFwiPnt7dGl0bGV9fTwvbW9kYWwtaGVhZGVyPlxuICAgICAgICAgICAgICAgIDwvc2xvdD5cblxuICAgICAgICAgICAgICAgIDxzbG90IG5hbWU9XCJib2R5XCI+XG4gICAgICAgICAgICAgICAgICAgIDxjb21wb25lbnQgOmlzPVwiIWZsdXNoID8gJ21vZGFsLWJvZHknIDogJ2RpdidcIiBjbGFzcz1cImNoaWxkLWNvbXBvbmVudFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHNsb3QvPlxuICAgICAgICAgICAgICAgICAgICA8L2NvbXBvbmVudD5cbiAgICAgICAgICAgICAgICA8L3Nsb3Q+XG5cbiAgICAgICAgICAgICAgICA8c2xvdCBuYW1lPVwiZm9vdGVyXCI+XG4gICAgICAgICAgICAgICAgICAgIDxtb2RhbC1mb290ZXIgdi1pZj1cInR5cGVcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZSB2LWlmPVwidHlwZSA9PT0gJ2FsZXJ0J1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidG4tYWN0aXZpdHkgOmFjdGl2aXR5PVwiYWN0aXZpdHlcIiB2YXJpYW50PVwicHJpbWFyeVwiIEBjbGljaz1cImNvbmZpcm1cIj57e29rTGFiZWx9fTwvYnRuLWFjdGl2aXR5PlxuICAgICAgICAgICAgICAgICAgICAgICAgPC90ZW1wbGF0ZT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZSB2LWVsc2U+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ0biB0eXBlPVwiYnV0dG9uXCIgdmFyaWFudD1cInNlY29uZGFyeVwiIEBjbGljaz1cImNhbmNlbFwiIHYtaHRtbD1cImNhbmNlbExhYmVsXCIvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidG4tYWN0aXZpdHkgOmFjdGl2aXR5PVwiYWN0aXZpdHlcIiB2YXJpYW50PVwicHJpbWFyeVwiIEBjbGljaz1cImNvbmZpcm1cIj57e29rTGFiZWx9fTwvYnRuLWFjdGl2aXR5PlxuICAgICAgICAgICAgICAgICAgICAgICAgPC90ZW1wbGF0ZT5cbiAgICAgICAgICAgICAgICAgICAgPC9tb2RhbC1mb290ZXI+XG4gICAgICAgICAgICAgICAgPC9zbG90PlxuXG4gICAgICAgICAgICA8L21vZGFsLWNvbnRlbnQ+XG5cbiAgICAgICAgPC9tb2RhbC1kaWFsb2c+XG5cbiAgICA8L2Rpdj5cblxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBCdG4gZnJvbSAnLi4vQnRuJztcbmltcG9ydCB7IGVhY2ggfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IE1vZGFsQm9keSBmcm9tICcuL01vZGFsQm9keSc7XG5pbXBvcnQgeyBpc1N0cmluZyB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgTW9kYWxEaWFsb2cgZnJvbSAnLi9Nb2RhbERpYWxvZyc7XG5pbXBvcnQgTW9kYWxIZWFkZXIgZnJvbSAnLi9Nb2RhbEhlYWRlcic7XG5pbXBvcnQgTW9kYWxGb290ZXIgZnJvbSAnLi9Nb2RhbEZvb3Rlcic7XG5pbXBvcnQgQnRuQWN0aXZpdHkgZnJvbSAnLi4vQnRuQWN0aXZpdHknO1xuaW1wb3J0IE1vZGFsQ29udGVudCBmcm9tICcuL01vZGFsQ29udGVudCc7XG5pbXBvcnQgTW9kYWxCYWNrZHJvcCBmcm9tICcuL01vZGFsQmFja2Ryb3AnO1xuaW1wb3J0IFRyaWdnZXJhYmxlIGZyb20gJy4uLy4uL01peGlucy9UcmlnZ2VyYWJsZSc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdtb2RhbCcsXG5cbiAgICBjb21wb25lbnRzOiB7XG4gICAgICAgIEJ0bixcbiAgICAgICAgQnRuQWN0aXZpdHksXG4gICAgICAgIE1vZGFsQm9keSxcbiAgICAgICAgTW9kYWxCYWNrZHJvcCxcbiAgICAgICAgTW9kYWxDb250ZW50LFxuICAgICAgICBNb2RhbERpYWxvZyxcbiAgICAgICAgTW9kYWxIZWFkZXIsXG4gICAgICAgIE1vZGFsRm9vdGVyXG4gICAgfSxcblxuICAgIG1peGluczogW1xuICAgICAgICBUcmlnZ2VyYWJsZVxuICAgIF0sXG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG93IHRoZSBtb2RhbCBhY3Rpdml0eSBpbmRpY2F0b3IuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgYWN0aXZpdHk6IEJvb2xlYW4sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3cgdGhlIG1vZGFsIHdpdGggYSBiYWNrZHJvcC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBiYWNrZHJvcDoge1xuICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElzIHRoZSBtb2RhbCBjZW50ZXJlZCBpbiB0aGUgc2NyZWVuLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGNlbnRlcjogQm9vbGVhbixcblxuICAgICAgICAvKipcbiAgICAgICAgICogSXMgdGhlIG1vZGFsIGNvbnRlbnQgZml4ZWQgcG9zaXRpb25cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBjbG9zZWFibGU6IHtcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgICBkZWZhdWx0OiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElzIHRoZSBtb2RhbCBjb250ZW50IGZsdXNoIHdpdGggdGhlIG1vZGFsIGVkZ2VzPyBJZiB0cnVlLCBubyBtb2RhbC1ib2R5XG4gICAgICAgICAqIHdpbGwgYmUgdXNlZCB0byB3cmFwIHRoZSBjb250ZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGZsdXNoOiBCb29sZWFuLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgb2sgbGFiZWwgdGV4dC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIG9rTGFiZWw6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdPaydcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNhbmNlbCBsYWJlbCB0ZXh0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgY2FuY2VsTGFiZWw6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdDYW5jZWwnXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtb2RhbCB0aXRsZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRpdGxlOiBTdHJpbmcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElzIHRoZSBtb2RhbCB0eXBlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgIHR5cGU6IFtCb29sZWFuLCBTdHJpbmddLFxuICAgICAgICAgICAgZGVmYXVsdDogZmFsc2UsXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbJ2FsZXJ0JywgJ2NvbmZpcm0nLCAncHJvbXB0J10uaW5kZXhPZih2YWx1ZSkgIT09IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgbWV0aG9kczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNb3VudCB0aGUgYmFja2Ryb3AgdG8gdGhlIGRvY3VtZW50IGJvZHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICAgIG1vdW50QmFja2Ryb3AoKSB7XG4gICAgICAgICAgICBpZighdGhpcy5iYWNrZHJvcENvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYmFja2Ryb3BDb21wb25lbnQgPSB0aGlzLiRyZWZzLmJhY2tkcm9wLiRtb3VudChcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVbm1vdW50IHRoZSBiYWNrZHJvcCBmcm9tIHRoZSBkb2N1bWVudCBib2R5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAgICB1bm1vdW50QmFja2Ryb3AoKSB7XG4gICAgICAgICAgICBpZih0aGlzLmJhY2tkcm9wQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5iYWNrZHJvcENvbXBvbmVudC4kZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuYmFja2Ryb3BDb21wb25lbnQuJGVsLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuYmFja2Ryb3BDb21wb25lbnQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYW5jZWwgdGhlIG1vZGFsXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICAgICAqL1xuICAgICAgICBjYW5jZWwoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2NhbmNlbCcsIGV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoZXZlbnQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25maXJtIHRoZSBtb2RhbFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAgICAgKi9cbiAgICAgICAgY29uZmlybShldmVudCkge1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgnY29uZmlybScsIGV2ZW50KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBjYWxsYmFjayBmb3IgdGhlIGVzY2FwZSBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgICAgICovXG4gICAgICAgIG9uRXNjKGV2ZW50KSB7XG4gICAgICAgICAgICAodGhpcy50eXBlID09PSAnY29uZmlybScgfHwgdGhpcy50eXBlID09PSAgJ3Byb21wdCcpID8gdGhpcy5jYW5jZWwoZXZlbnQpIDogdGhpcy5jbG9zZShldmVudCk7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICB3YXRjaDoge1xuXG4gICAgICAgIGlzU2hvd2luZyh2YWx1ZSkge1xuICAgICAgICAgICAgaWYodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdib2R5JykuY2xhc3NMaXN0LmFkZCgnbW9kYWwtb3BlbicpO1xuICAgICAgICAgICAgICAgIC8vdGhpcy5tb3VudEJhY2tkcm9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdib2R5JykuY2xhc3NMaXN0LnJlbW92ZSgnbW9kYWwtb3BlbicpO1xuICAgICAgICAgICAgICAgIC8vdGhpcy51bm1vdW50QmFja2Ryb3AoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy4kZW1pdCgndXBkYXRlOnNob3cnLCB2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYmFja2Ryb3BDb21wb25lbnQ6IG51bGwsXG4gICAgICAgICAgICBpc0Rpc3BsYXlpbmc6IHRoaXMuc2hvdyB8fCAhdGhpcy50YXJnZXQsXG4gICAgICAgICAgICBpc1Nob3dpbmc6IGZhbHNlXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbW91bnRlZCgpIHtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplVHJpZ2dlcnMoKTtcbiAgICAgICAgLypcbiAgICAgICAgaWYodGhpcy5zaG93IHx8ICF0aGlzLnRhcmdldCkge1xuICAgICAgICAgICAgdGhpcy5tb3VudEJhY2tkcm9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgKi9cbiAgICB9LFxuXG4gICAgYmVmb3JlUm91dGVMZWF2ZSh0bywgZnJvbSwgbmV4dCkge1xuICAgICAgICBtb2RhbC5jbG9zZSgpO1xuICAgIH1cblxufVxuXG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJzY3NzXCI+XG4ubW9kYWwge1xuICAgIC5tb2RhbC1iYWNrZHJvcCArIC5tb2RhbC1kaWFsb2cge1xuICAgICAgICB6LWluZGV4OiAxMDUwO1xuICAgIH1cbn1cbjwvc3R5bGU+XG4iLCJpbXBvcnQgTW9kYWwgZnJvbSAnLi9Nb2RhbCc7XG5pbXBvcnQgTW9kYWxCYWNrZHJvcCBmcm9tICcuL01vZGFsQmFja2Ryb3AnO1xuaW1wb3J0IE1vZGFsQm9keSBmcm9tICcuL01vZGFsQm9keSc7XG5pbXBvcnQgTW9kYWxDb250ZW50IGZyb20gJy4vTW9kYWxDb250ZW50JztcbmltcG9ydCBNb2RhbERpYWxvZyBmcm9tICcuL01vZGFsRGlhbG9nJztcbmltcG9ydCBNb2RhbEZvb3RlciBmcm9tICcuL01vZGFsRm9vdGVyJztcbmltcG9ydCBNb2RhbEhlYWRlciBmcm9tICcuL01vZGFsSGVhZGVyJztcbmltcG9ydCBWdWVJbnN0YWxsZXIgZnJvbSAnLi4vLi4vSGVscGVycy9WdWVJbnN0YWxsZXIvVnVlSW5zdGFsbGVyJztcblxuY29uc3QgcGx1Z2luID0gVnVlSW5zdGFsbGVyLnVzZSh7XG5cbiAgICBpbnN0YWxsKFZ1ZSwgb3B0aW9ucykge1xuICAgICAgICBWdWVJbnN0YWxsZXIuY29tcG9uZW50cyh7XG4gICAgICAgICAgICBNb2RhbFxuICAgICAgICB9KTtcbiAgICB9XG5cbn0pO1xuXG5leHBvcnQge1xuICAgIE1vZGFsQmFja2Ryb3AsXG4gICAgTW9kYWxCb2R5LFxuICAgIE1vZGFsQ29udGVudCxcbiAgICBNb2RhbERpYWxvZyxcbiAgICBNb2RhbEZvb3RlcixcbiAgICBNb2RhbEhlYWRlclxufVxuXG5leHBvcnQgZGVmYXVsdCBNb2RhbDtcbiIsImltcG9ydCB7IGlzT2JqZWN0IH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCB7IGlzU3RyaW5nIH0gZnJvbSAnbG9kYXNoLWVzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaW5zdGFudGlhdGUoVnVlLCBDb21wb25lbnQsIG9wdGlvbnMpIHtcbiAgICBpZihDb21wb25lbnQgaW5zdGFuY2VvZiBWdWUpIHtcbiAgICAgICAgcmV0dXJuIENvbXBvbmVudDtcbiAgICB9XG5cbiAgICBpZihpc09iamVjdChDb21wb25lbnQpKSB7XG4gICAgICAgIENvbXBvbmVudCA9IFZ1ZS5leHRlbmQoQ29tcG9uZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZihpc1N0cmluZyhDb21wb25lbnQpKSB7XG4gICAgICAgIGNvbnN0IHRleHQgPSBDb21wb25lbnQ7XG5cbiAgICAgICAgQ29tcG9uZW50ID0gVnVlLmV4dGVuZCh7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uYWw6IHRydWUsXG5cbiAgICAgICAgICAgIHJlbmRlcihoLCBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3YodGV4dCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBDb21wb25lbnQob3B0aW9ucyk7XG59XG4iLCJpbXBvcnQgeyBpc09iamVjdCB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgeyBpc0Z1bmN0aW9uIH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCB7IGRlZmF1bHRzRGVlcCB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgTW9kYWwgZnJvbSAnLi4vLi4vQ29tcG9uZW50cy9Nb2RhbCc7XG5pbXBvcnQgaW5zdGFudGlhdGUgZnJvbSAnLi4vLi4vSGVscGVycy9JbnN0YW50aWF0ZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKFZ1ZSwgb3B0aW9ucykge1xuXG4gICAgVnVlLnByb3RvdHlwZS4kbW9kYWwgPSBmdW5jdGlvbihDb21wb25lbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYoIWlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGluc3RhbnRpYXRlKFZ1ZSwgTW9kYWwsIG9wdGlvbnMubW9kYWwpO1xuXG4gICAgICAgIGluc3RhbmNlLiRjb250ZW50ID0gaW5zdGFudGlhdGUoVnVlLCBDb21wb25lbnQsIG9wdGlvbnMuY29udGVudCk7XG4gICAgICAgIGluc3RhbmNlLiRzbG90cy5kZWZhdWx0ID0gW2luc3RhbmNlLiRjb250ZW50LiRtb3VudCgpLl92bm9kZV07XG4gICAgICAgIGluc3RhbmNlLiRtb3VudChcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykpXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH07XG5cbiAgICBWdWUucHJvdG90eXBlLiRhbGVydCA9IGZ1bmN0aW9uKHRpdGxlLCBDb21wb25lbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1vZGFsID0gdGhpcy4kbW9kYWwoQ29tcG9uZW50LCBkZWZhdWx0c0RlZXAob3B0aW9ucywge1xuICAgICAgICAgICAgICAgIG1vZGFsOiB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzRGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2FsZXJ0J1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICBtb2RhbC4kb24oJ2NvbmZpcm0nLCBldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgbW9kYWwuY2xvc2UoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBtb2RhbC4kb24oJ2Nsb3NlJywgZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgIHJlc29sdmUobW9kYWwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBWdWUucHJvdG90eXBlLiRjb25maXJtID0gZnVuY3Rpb24odGl0bGUsIENvbXBvbmVudCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbW9kYWwgPSB0aGlzLiRtb2RhbChDb21wb25lbnQgfHwgdGl0bGUsIGRlZmF1bHRzRGVlcChvcHRpb25zLCB7XG4gICAgICAgICAgICAgICAgbW9kYWw6IHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHNEYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogQ29tcG9uZW50ID8gdGl0bGUgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NvbmZpcm0nXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgIG1vZGFsLiRvbignY2FuY2VsJywgZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgIHJlamVjdChtb2RhbCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbW9kYWwuJG9uKCdjb25maXJtJywgZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgIHJlc29sdmUobW9kYWwuY2xvc2UoKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIFZ1ZS5wcm90b3R5cGUuJHByb21wdCA9IGZ1bmN0aW9uKHRpdGxlLCBDb21wb25lbnQsIG9wdGlvbnMsIHByZWRpY2F0ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgaWYoaXNGdW5jdGlvbihvcHRpb25zKSkge1xuICAgICAgICAgICAgICAgIHByZWRpY2F0ZSA9IG9wdGlvbnM7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZihpc09iamVjdChvcHRpb25zKSAmJiBpc0Z1bmN0aW9uKG9wdGlvbnMucHJlZGljYXRlKSkge1xuICAgICAgICAgICAgICAgIHByZWRpY2F0ZSA9IG9wdGlvbnMucHJlZGljYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZighaXNGdW5jdGlvbihwcmVkaWNhdGUpKSB7XG4gICAgICAgICAgICAgICAgcHJlZGljYXRlID0gKCkgPT4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgbW9kYWwgPSB0aGlzLiRtb2RhbChDb21wb25lbnQsIGRlZmF1bHRzRGVlcChvcHRpb25zLCB7XG4gICAgICAgICAgICAgICAgbW9kYWw6IHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHNEYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogdGl0bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAncHJvbXB0J1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICBtb2RhbC4kb24oJ2NhbmNlbCcsIGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICByZWplY3QobW9kYWwpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG1vZGFsLiRvbignY29uZmlybScsIGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdWNjZWVkID0gKCkgPT4gcmVzb2x2ZShtb2RhbC5jbG9zZSgpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmYWlsID0gKCkgPT4gcmVqZWN0KG1vZGFsLmNsb3NlKCkpO1xuXG4gICAgICAgICAgICAgICAgaWYocHJlZGljYXRlKG1vZGFsLCBzdWNjZWVkLCBmYWlsKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbn1cbiIsIjx0ZW1wbGF0ZT5cbiAgICA8ZGl2IGNsYXNzPVwib3ZlcmxheS1ib2R5XCI+PHNsb3QvPjwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdvdmVybGF5LWJvZHknXG5cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuXG4gICAgPGRpdiBjbGFzcz1cImNvbnRhaW5lclwiPjxzbG90Lz48L2Rpdj5cblxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cblxuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAnY29udGFpbmVyJ1xuXG59XG5cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IENvbnRhaW5lciBmcm9tICcuL0NvbnRhaW5lcic7XG5pbXBvcnQgVnVlSW5zdGFsbGVyIGZyb20gJy4uLy4uL0hlbHBlcnMvVnVlSW5zdGFsbGVyL1Z1ZUluc3RhbGxlcic7XG5cbmNvbnN0IHBsdWdpbiA9IFZ1ZUluc3RhbGxlci51c2Uoe1xuXG4gICAgaW5zdGFsbChWdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgVnVlSW5zdGFsbGVyLmNvbXBvbmVudHMoe1xuICAgICAgICAgICAgQ29udGFpbmVyXG4gICAgICAgIH0pO1xuICAgIH1cblxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IENvbnRhaW5lcjtcbiIsIjx0ZW1wbGF0ZT5cbiAgICA8Y29udGFpbmVyIGNsYXNzPVwib3ZlcmxheS1jb250ZW50XCI+XG4gICAgICAgIDxzbG90Lz5cbiAgICA8L2NvbnRhaW5lcj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgQ29udGFpbmVyIGZyb20gJy4uL0NvbnRhaW5lcic7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdvdmVybGF5LWNvbnRlbnQnLFxuXG4gICAgY29tcG9uZW50czoge1xuICAgICAgICBDb250YWluZXJcbiAgICB9XG5cbn1cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cInNjc3NcIj5cbkBpbXBvcnQgJy4vbm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC9zY3NzL2Z1bmN0aW9ucy5zY3NzJztcbkBpbXBvcnQgJy4vbm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC9zY3NzL3ZhcmlhYmxlcy5zY3NzJztcblxuLm92ZXJsYXktY29udGVudCB7XG4gICAgbWFyZ2luOiAwIGF1dG87XG4gICAgb3ZlcmZsb3cteTogYXV0bztcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG5cbiAgICAvKlxuICAgICYub3ZlcmxheS1jb250ZW50LWNlbnRlciB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuXG4gICAgICAgIC5vdmVybGF5LWJvZHkge1xuICAgICAgICAgICAgZmxleDogMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAqL1xuXG4gICAgJi5vdmVybGF5LWNvbnRlbnQtZml4ZWQge1xuICAgICAgICB0b3A6IDA7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIHBhZGRpbmc6IDA7XG4gICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgICBtYXgtd2lkdGg6IG5vbmU7XG4gICAgfVxuXG4gICAgLm92ZXJsYXktY29udHJvbHMge1xuICAgICAgICBmbG9hdDogcmlnaHQ7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgdG9wOiA0cHg7XG4gICAgICAgIHBhZGRpbmctcmlnaHQ6IDA7XG4gICAgICAgIHBhZGRpbmctYm90dG9tOiAkZm9udC1zaXplLWJhc2U7XG5cbiAgICAgICAgJi5sZWZ0IHtcbiAgICAgICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIH1cbiAgICAgICAgJi5yaWdodCB7XG4gICAgICAgICAgICByaWdodDogMDtcbiAgICAgICAgfVxuXG4gICAgICAgICYgKyAqIHtcbiAgICAgICAgICAgIGNsZWFyOiBib3RoO1xuICAgICAgICB9XG4gICAgfVxufVxuPC9zdHlsZT5cbiIsIjx0ZW1wbGF0ZT5cbiAgICA8ZGl2IGNsYXNzPVwib3ZlcmxheVwiIDpjbGFzcz1cInRyaWdnZXJhYmxlQ2xhc3Nlc1wiIDpzdHlsZT1cInsnYmFja2dyb3VuZCc6IGJhY2tncm91bmQsICdkaXNwbGF5JzogaXNEaXNwbGF5aW5nID8gJ2ZsZXgnIDogJ25vbmUnfVwiIHJvbGU9XCJkaWFsb2dcIiB0YWJpbmRleD1cIi0xXCIgQGtleWRvd24uZXNjPVwib25Fc2NcIj5cbiAgICAgICAgPGJ1dHRvbiB2LWlmPVwiY2xvc2VhYmxlICYmICFoaWRlQ2xvc2VCdXR0b25cIiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLWxpbmsgb3ZlcmxheS1jbG9zZVwiIEBjbGljaz1cIm9uQ2xpY2tDbG9zZVwiPlxuICAgICAgICAgICAgPGkgY2xhc3M9XCJmYSBmYS10aW1lcy1jaXJjbGVcIj48L2k+XG4gICAgICAgIDwvYnV0dG9uPlxuXG4gICAgICAgIDxvdmVybGF5LWNvbnRlbnQgOmNsYXNzPVwieydvdmVybGF5LWNvbnRlbnQtZml4ZWQnOiBmaXhlZENvbnRlbnQsICdvdmVybGF5LWNvbnRlbnQtY2VudGVyJzogY2VudGVyfVwiIDpzdHlsZT1cInttaW5IZWlnaHQ6IG1pbkhlaWdodH1cIj5cbiAgICAgICAgICAgIDxzbG90IG5hbWU9XCJib2R5XCI+XG4gICAgICAgICAgICAgICAgPG92ZXJsYXktYm9keSBjbGFzcz1cIm15LTRcIj5cbiAgICAgICAgICAgICAgICAgICAgPHNsb3QvPlxuICAgICAgICAgICAgICAgIDwvb3ZlcmxheS1ib2R5PlxuICAgICAgICAgICAgPC9zbG90PlxuICAgICAgICA8L292ZXJsYXktY29udGVudD5cbiAgICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgT3ZlcmxheUJvZHkgZnJvbSAnLi9PdmVybGF5Qm9keSc7XG5pbXBvcnQgT3ZlcmxheUNvbnRlbnQgZnJvbSAnLi9PdmVybGF5Q29udGVudCc7XG5pbXBvcnQgVHJpZ2dlcmFibGUgZnJvbSAnLi4vLi4vTWl4aW5zL1RyaWdnZXJhYmxlJztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ292ZXJsYXknLFxuXG4gICAgY29tcG9uZW50czoge1xuICAgICAgICBPdmVybGF5Qm9keSxcbiAgICAgICAgT3ZlcmxheUNvbnRlbnRcbiAgICB9LFxuXG4gICAgbWl4aW5zOiBbXG4gICAgICAgIFRyaWdnZXJhYmxlXG4gICAgXSxcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBvdmVybGF5IGJhY2tncm91bmQgY29sb3IuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGJhY2tncm91bmQ6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIC45MjUpJ1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJcyB0aGUgb3ZlcmxheSBjb250ZW50IGZpeGVkIHBvc2l0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBCb29sZWFuXG4gICAgICAgICAqL1xuICAgICAgICBjbG9zZWFibGU6IHtcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgICBkZWZhdWx0OiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENlbnRlciB0aGUgb3ZlcmxheSBjb250ZW50IG9uIHRoZSBzY3JlZW4gdXNpbmcgZmxleCBib3guXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgY2VudGVyOiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJcyB0aGUgb3ZlcmxheSBjb250ZW50IGZpeGVkIHBvc2l0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBCb29sZWFuXG4gICAgICAgICAqL1xuICAgICAgICBmaXhlZENvbnRlbnQ6IEJvb2xlYW4sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElzIHRoZSBvdmVybGF5IGNsb3NlIGJ1dHRvbiBoaWRkZW4gYnV0IHN0aWxsIGNsb3NlYWJsZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IEJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIGhpZGVDbG9zZUJ1dHRvbjogQm9vbGVhbixcblxuICAgICAgICAvKipcbiAgICAgICAgICogSXMgdGhlIG92ZXJsYXkgY29udGVudCBtaW5pbXVtIGhlaWdodC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IEJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIG1pbkhlaWdodDogW1N0cmluZywgTnVtYmVyXVxuXG4gICAgfSxcblxuICAgIG1ldGhvZHM6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNhbGxiYWNrIGZvciB0aGUgYGNsaWNrYCBldmVudCBvbiB0aGUgY2xvc2UgYnV0dG9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgICAgICovXG4gICAgICAgIG9uQ2xpY2tDbG9zZShldmVudCkge1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgnY2xpY2s6Y2xvc2UnLCBldmVudCk7XG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25Fc2MoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VhYmxlICYmIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG59XG5cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cInNjc3NcIj5cbkBpbXBvcnQgJy4vbm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC9zY3NzL2Z1bmN0aW9ucy5zY3NzJztcbkBpbXBvcnQgJy4vbm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC9zY3NzL3ZhcmlhYmxlcy5zY3NzJztcblxuLm92ZXJsYXkge1xuICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIG1pbi1oZWlnaHQ6IDA7XG4gICAgdG9wOiAwO1xuICAgIGxlZnQ6IDA7XG4gICAgei1pbmRleDogLTE7XG4gICAgb3BhY2l0eTogMDtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBoZWlnaHQ6IDEwMCU7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBhbGlnbi1jb250ZW50OiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcblxuICAgICYuZmFkZSB7XG4gICAgICAgIHRyYW5zaXRpb246IG9wYWNpdHkgMzMzbXMgZWFzZS1vdXQ7XG4gICAgfVxuXG4gICAgJi5zaG93IHtcbiAgICAgICAgei1pbmRleDogMTAzMDtcbiAgICAgICAgb3BhY2l0eTogMTtcbiAgICB9XG5cbiAgICAub3ZlcmxheS1jb250ZW50IHtcbiAgICAgICAgZmxleDogMTtcbiAgICB9XG5cbiAgICAub3ZlcmxheS1oZWFkZXIge1xuICAgICAgICBtYXJnaW4tdG9wOiAkZm9udC1zaXplLWJhc2UgKiAxLjU7XG4gICAgfVxuXG4gICAgLm92ZXJsYXktY2xvc2Uge1xuICAgICAgICBmb250LXNpemU6ICRmb250LXNpemUtYmFzZSAqIDEuMjU7XG4gICAgICAgIGNvbG9yOiAkZ3JheS03MDA7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgdG9wOiAkZm9udC1zaXplLWJhc2U7XG4gICAgICAgIHJpZ2h0OiAkZm9udC1zaXplLWJhc2U7XG4gICAgICAgIHotaW5kZXg6IDE7XG4gICAgfVxufVxuPC9zdHlsZT5cbiIsImltcG9ydCBPdmVybGF5IGZyb20gJy4vT3ZlcmxheSc7XG5pbXBvcnQgVnVlSW5zdGFsbGVyIGZyb20gJy4uLy4uL0hlbHBlcnMvVnVlSW5zdGFsbGVyL1Z1ZUluc3RhbGxlcic7XG5cbmNvbnN0IHBsdWdpbiA9IFZ1ZUluc3RhbGxlci51c2Uoe1xuXG4gICAgaW5zdGFsbChWdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgVnVlSW5zdGFsbGVyLmNvbXBvbmVudHMoe1xuICAgICAgICAgICAgT3ZlcmxheVxuICAgICAgICB9KTtcbiAgICB9XG5cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBPdmVybGF5O1xuIiwiaW1wb3J0IHsgaXNPYmplY3QgfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IHsgZGVmYXVsdHNEZWVwIH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCBpbnN0YW50aWF0ZSBmcm9tICcuLi8uLi9IZWxwZXJzL0luc3RhbnRpYXRlJztcbmltcG9ydCBPdmVybGF5IGZyb20gJy4uLy4uL0NvbXBvbmVudHMvT3ZlcmxheSc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKFZ1ZSwgb3B0aW9ucykge1xuICAgIFZ1ZS5wcm90b3R5cGUuJG92ZXJsYXkgPSBmdW5jdGlvbih0YXJnZXQsIENvbXBvbmVudCwgb3B0aW9ucykge1xuICAgICAgICBpZighaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCF0YXJnZXQuJG92ZXJsYXkpIHtcbiAgICAgICAgICAgIHRhcmdldC4kb3ZlcmxheSA9IGluc3RhbnRpYXRlKFZ1ZSwgT3ZlcmxheSwgZGVmYXVsdHNEZWVwKG9wdGlvbnMub3ZlcmxheSwge1xuICAgICAgICAgICAgICAgIHByb3BzRGF0YToge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHRhcmdldFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgdGFyZ2V0LiRvdmVybGF5LiRtb3VudChcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgdGFyZ2V0LiRvdmVybGF5LiRjb250ZW50ID0gaW5zdGFudGlhdGUoVnVlLCBDb21wb25lbnQsIG9wdGlvbnMuY29udGVudCk7XG4gICAgICAgICAgICB0YXJnZXQuJG92ZXJsYXkuJHNsb3RzLmRlZmF1bHQgPSBbdGFyZ2V0LiRvdmVybGF5LiRjb250ZW50LiRtb3VudCgpLl92bm9kZV07XG4gICAgICAgICAgICB0YXJnZXQuJG92ZXJsYXkuJG5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0YXJnZXQuJG92ZXJsYXkub3BlbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0LiRvdmVybGF5O1xuICAgIH07XG59XG4iLCIvKiohXG4gKiBAZmlsZU92ZXJ2aWV3IEtpY2thc3MgbGlicmFyeSB0byBjcmVhdGUgYW5kIHBsYWNlIHBvcHBlcnMgbmVhciB0aGVpciByZWZlcmVuY2UgZWxlbWVudHMuXG4gKiBAdmVyc2lvbiAxLjE0LjNcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYgRmVkZXJpY28gWml2b2xvIGFuZCBjb250cmlidXRvcnNcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqIFNPRlRXQVJFLlxuICovXG52YXIgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcblxudmFyIGxvbmdlclRpbWVvdXRCcm93c2VycyA9IFsnRWRnZScsICdUcmlkZW50JywgJ0ZpcmVmb3gnXTtcbnZhciB0aW1lb3V0RHVyYXRpb24gPSAwO1xuZm9yICh2YXIgaSA9IDA7IGkgPCBsb25nZXJUaW1lb3V0QnJvd3NlcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgaWYgKGlzQnJvd3NlciAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YobG9uZ2VyVGltZW91dEJyb3dzZXJzW2ldKSA+PSAwKSB7XG4gICAgdGltZW91dER1cmF0aW9uID0gMTtcbiAgICBicmVhaztcbiAgfVxufVxuXG5mdW5jdGlvbiBtaWNyb3Rhc2tEZWJvdW5jZShmbikge1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNhbGxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsZWQgPSB0cnVlO1xuICAgIHdpbmRvdy5Qcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxlZCA9IGZhbHNlO1xuICAgICAgZm4oKTtcbiAgICB9KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdGFza0RlYm91bmNlKGZuKSB7XG4gIHZhciBzY2hlZHVsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXNjaGVkdWxlZCkge1xuICAgICAgc2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBzY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgZm4oKTtcbiAgICAgIH0sIHRpbWVvdXREdXJhdGlvbik7XG4gICAgfVxuICB9O1xufVxuXG52YXIgc3VwcG9ydHNNaWNyb1Rhc2tzID0gaXNCcm93c2VyICYmIHdpbmRvdy5Qcm9taXNlO1xuXG4vKipcbiogQ3JlYXRlIGEgZGVib3VuY2VkIHZlcnNpb24gb2YgYSBtZXRob2QsIHRoYXQncyBhc3luY2hyb25vdXNseSBkZWZlcnJlZFxuKiBidXQgY2FsbGVkIGluIHRoZSBtaW5pbXVtIHRpbWUgcG9zc2libGUuXG4qXG4qIEBtZXRob2RcbiogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuKiBAYXJndW1lbnQge0Z1bmN0aW9ufSBmblxuKiBAcmV0dXJucyB7RnVuY3Rpb259XG4qL1xudmFyIGRlYm91bmNlID0gc3VwcG9ydHNNaWNyb1Rhc2tzID8gbWljcm90YXNrRGVib3VuY2UgOiB0YXNrRGVib3VuY2U7XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGEgZnVuY3Rpb25cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7QW55fSBmdW5jdGlvblRvQ2hlY2sgLSB2YXJpYWJsZSB0byBjaGVja1xuICogQHJldHVybnMge0Jvb2xlYW59IGFuc3dlciB0bzogaXMgYSBmdW5jdGlvbj9cbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbihmdW5jdGlvblRvQ2hlY2spIHtcbiAgdmFyIGdldFR5cGUgPSB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uVG9DaGVjayAmJiBnZXRUeXBlLnRvU3RyaW5nLmNhbGwoZnVuY3Rpb25Ub0NoZWNrKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn1cblxuLyoqXG4gKiBHZXQgQ1NTIGNvbXB1dGVkIHByb3BlcnR5IG9mIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VlbWVudH0gZWxlbWVudFxuICogQGFyZ3VtZW50IHtTdHJpbmd9IHByb3BlcnR5XG4gKi9cbmZ1bmN0aW9uIGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbGVtZW50LCBwcm9wZXJ0eSkge1xuICBpZiAoZWxlbWVudC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICAvLyBOT1RFOiAxIERPTSBhY2Nlc3MgaGVyZVxuICB2YXIgY3NzID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBudWxsKTtcbiAgcmV0dXJuIHByb3BlcnR5ID8gY3NzW3Byb3BlcnR5XSA6IGNzcztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwYXJlbnROb2RlIG9yIHRoZSBob3N0IG9mIHRoZSBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBwYXJlbnRcbiAqL1xuZnVuY3Rpb24gZ2V0UGFyZW50Tm9kZShlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50Lm5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuICByZXR1cm4gZWxlbWVudC5wYXJlbnROb2RlIHx8IGVsZW1lbnQuaG9zdDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzY3JvbGxpbmcgcGFyZW50IG9mIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBzY3JvbGwgcGFyZW50XG4gKi9cbmZ1bmN0aW9uIGdldFNjcm9sbFBhcmVudChlbGVtZW50KSB7XG4gIC8vIFJldHVybiBib2R5LCBgZ2V0U2Nyb2xsYCB3aWxsIHRha2UgY2FyZSB0byBnZXQgdGhlIGNvcnJlY3QgYHNjcm9sbFRvcGAgZnJvbSBpdFxuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuYm9keTtcbiAgfVxuXG4gIHN3aXRjaCAoZWxlbWVudC5ub2RlTmFtZSkge1xuICAgIGNhc2UgJ0hUTUwnOlxuICAgIGNhc2UgJ0JPRFknOlxuICAgICAgcmV0dXJuIGVsZW1lbnQub3duZXJEb2N1bWVudC5ib2R5O1xuICAgIGNhc2UgJyNkb2N1bWVudCc6XG4gICAgICByZXR1cm4gZWxlbWVudC5ib2R5O1xuICB9XG5cbiAgLy8gRmlyZWZveCB3YW50IHVzIHRvIGNoZWNrIGAteGAgYW5kIGAteWAgdmFyaWF0aW9ucyBhcyB3ZWxsXG5cbiAgdmFyIF9nZXRTdHlsZUNvbXB1dGVkUHJvcCA9IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbGVtZW50KSxcbiAgICAgIG92ZXJmbG93ID0gX2dldFN0eWxlQ29tcHV0ZWRQcm9wLm92ZXJmbG93LFxuICAgICAgb3ZlcmZsb3dYID0gX2dldFN0eWxlQ29tcHV0ZWRQcm9wLm92ZXJmbG93WCxcbiAgICAgIG92ZXJmbG93WSA9IF9nZXRTdHlsZUNvbXB1dGVkUHJvcC5vdmVyZmxvd1k7XG5cbiAgaWYgKC8oYXV0b3xzY3JvbGx8b3ZlcmxheSkvLnRlc3Qob3ZlcmZsb3cgKyBvdmVyZmxvd1kgKyBvdmVyZmxvd1gpKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICByZXR1cm4gZ2V0U2Nyb2xsUGFyZW50KGdldFBhcmVudE5vZGUoZWxlbWVudCkpO1xufVxuXG52YXIgaXNJRTExID0gaXNCcm93c2VyICYmICEhKHdpbmRvdy5NU0lucHV0TWV0aG9kQ29udGV4dCAmJiBkb2N1bWVudC5kb2N1bWVudE1vZGUpO1xudmFyIGlzSUUxMCA9IGlzQnJvd3NlciAmJiAvTVNJRSAxMC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBicm93c2VyIGlzIEludGVybmV0IEV4cGxvcmVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge051bWJlcn0gdmVyc2lvbiB0byBjaGVja1xuICogQHJldHVybnMge0Jvb2xlYW59IGlzSUVcbiAqL1xuZnVuY3Rpb24gaXNJRSh2ZXJzaW9uKSB7XG4gIGlmICh2ZXJzaW9uID09PSAxMSkge1xuICAgIHJldHVybiBpc0lFMTE7XG4gIH1cbiAgaWYgKHZlcnNpb24gPT09IDEwKSB7XG4gICAgcmV0dXJuIGlzSUUxMDtcbiAgfVxuICByZXR1cm4gaXNJRTExIHx8IGlzSUUxMDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBvZmZzZXQgcGFyZW50IG9mIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBvZmZzZXQgcGFyZW50XG4gKi9cbmZ1bmN0aW9uIGdldE9mZnNldFBhcmVudChlbGVtZW50KSB7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIH1cblxuICB2YXIgbm9PZmZzZXRQYXJlbnQgPSBpc0lFKDEwKSA/IGRvY3VtZW50LmJvZHkgOiBudWxsO1xuXG4gIC8vIE5PVEU6IDEgRE9NIGFjY2VzcyBoZXJlXG4gIHZhciBvZmZzZXRQYXJlbnQgPSBlbGVtZW50Lm9mZnNldFBhcmVudDtcbiAgLy8gU2tpcCBoaWRkZW4gZWxlbWVudHMgd2hpY2ggZG9uJ3QgaGF2ZSBhbiBvZmZzZXRQYXJlbnRcbiAgd2hpbGUgKG9mZnNldFBhcmVudCA9PT0gbm9PZmZzZXRQYXJlbnQgJiYgZWxlbWVudC5uZXh0RWxlbWVudFNpYmxpbmcpIHtcbiAgICBvZmZzZXRQYXJlbnQgPSAoZWxlbWVudCA9IGVsZW1lbnQubmV4dEVsZW1lbnRTaWJsaW5nKS5vZmZzZXRQYXJlbnQ7XG4gIH1cblxuICB2YXIgbm9kZU5hbWUgPSBvZmZzZXRQYXJlbnQgJiYgb2Zmc2V0UGFyZW50Lm5vZGVOYW1lO1xuXG4gIGlmICghbm9kZU5hbWUgfHwgbm9kZU5hbWUgPT09ICdCT0RZJyB8fCBub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQgPyBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IDogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB9XG5cbiAgLy8gLm9mZnNldFBhcmVudCB3aWxsIHJldHVybiB0aGUgY2xvc2VzdCBURCBvciBUQUJMRSBpbiBjYXNlXG4gIC8vIG5vIG9mZnNldFBhcmVudCBpcyBwcmVzZW50LCBJIGhhdGUgdGhpcyBqb2IuLi5cbiAgaWYgKFsnVEQnLCAnVEFCTEUnXS5pbmRleE9mKG9mZnNldFBhcmVudC5ub2RlTmFtZSkgIT09IC0xICYmIGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShvZmZzZXRQYXJlbnQsICdwb3NpdGlvbicpID09PSAnc3RhdGljJykge1xuICAgIHJldHVybiBnZXRPZmZzZXRQYXJlbnQob2Zmc2V0UGFyZW50KTtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXRQYXJlbnQ7XG59XG5cbmZ1bmN0aW9uIGlzT2Zmc2V0Q29udGFpbmVyKGVsZW1lbnQpIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZTtcblxuICBpZiAobm9kZU5hbWUgPT09ICdCT0RZJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gbm9kZU5hbWUgPT09ICdIVE1MJyB8fCBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZCkgPT09IGVsZW1lbnQ7XG59XG5cbi8qKlxuICogRmluZHMgdGhlIHJvb3Qgbm9kZSAoZG9jdW1lbnQsIHNoYWRvd0RPTSByb290KSBvZiB0aGUgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBub2RlXG4gKiBAcmV0dXJucyB7RWxlbWVudH0gcm9vdCBub2RlXG4gKi9cbmZ1bmN0aW9uIGdldFJvb3Qobm9kZSkge1xuICBpZiAobm9kZS5wYXJlbnROb2RlICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIGdldFJvb3Qobm9kZS5wYXJlbnROb2RlKTtcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufVxuXG4vKipcbiAqIEZpbmRzIHRoZSBvZmZzZXQgcGFyZW50IGNvbW1vbiB0byB0aGUgdHdvIHByb3ZpZGVkIG5vZGVzXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnQxXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnQyXG4gKiBAcmV0dXJucyB7RWxlbWVudH0gY29tbW9uIG9mZnNldCBwYXJlbnRcbiAqL1xuZnVuY3Rpb24gZmluZENvbW1vbk9mZnNldFBhcmVudChlbGVtZW50MSwgZWxlbWVudDIpIHtcbiAgLy8gVGhpcyBjaGVjayBpcyBuZWVkZWQgdG8gYXZvaWQgZXJyb3JzIGluIGNhc2Ugb25lIG9mIHRoZSBlbGVtZW50cyBpc24ndCBkZWZpbmVkIGZvciBhbnkgcmVhc29uXG4gIGlmICghZWxlbWVudDEgfHwgIWVsZW1lbnQxLm5vZGVUeXBlIHx8ICFlbGVtZW50MiB8fCAhZWxlbWVudDIubm9kZVR5cGUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB9XG5cbiAgLy8gSGVyZSB3ZSBtYWtlIHN1cmUgdG8gZ2l2ZSBhcyBcInN0YXJ0XCIgdGhlIGVsZW1lbnQgdGhhdCBjb21lcyBmaXJzdCBpbiB0aGUgRE9NXG4gIHZhciBvcmRlciA9IGVsZW1lbnQxLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGVsZW1lbnQyKSAmIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fRk9MTE9XSU5HO1xuICB2YXIgc3RhcnQgPSBvcmRlciA/IGVsZW1lbnQxIDogZWxlbWVudDI7XG4gIHZhciBlbmQgPSBvcmRlciA/IGVsZW1lbnQyIDogZWxlbWVudDE7XG5cbiAgLy8gR2V0IGNvbW1vbiBhbmNlc3RvciBjb250YWluZXJcbiAgdmFyIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgcmFuZ2Uuc2V0U3RhcnQoc3RhcnQsIDApO1xuICByYW5nZS5zZXRFbmQoZW5kLCAwKTtcbiAgdmFyIGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyID0gcmFuZ2UuY29tbW9uQW5jZXN0b3JDb250YWluZXI7XG5cbiAgLy8gQm90aCBub2RlcyBhcmUgaW5zaWRlICNkb2N1bWVudFxuXG4gIGlmIChlbGVtZW50MSAhPT0gY29tbW9uQW5jZXN0b3JDb250YWluZXIgJiYgZWxlbWVudDIgIT09IGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyIHx8IHN0YXJ0LmNvbnRhaW5zKGVuZCkpIHtcbiAgICBpZiAoaXNPZmZzZXRDb250YWluZXIoY29tbW9uQW5jZXN0b3JDb250YWluZXIpKSB7XG4gICAgICByZXR1cm4gY29tbW9uQW5jZXN0b3JDb250YWluZXI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdldE9mZnNldFBhcmVudChjb21tb25BbmNlc3RvckNvbnRhaW5lcik7XG4gIH1cblxuICAvLyBvbmUgb2YgdGhlIG5vZGVzIGlzIGluc2lkZSBzaGFkb3dET00sIGZpbmQgd2hpY2ggb25lXG4gIHZhciBlbGVtZW50MXJvb3QgPSBnZXRSb290KGVsZW1lbnQxKTtcbiAgaWYgKGVsZW1lbnQxcm9vdC5ob3N0KSB7XG4gICAgcmV0dXJuIGZpbmRDb21tb25PZmZzZXRQYXJlbnQoZWxlbWVudDFyb290Lmhvc3QsIGVsZW1lbnQyKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmluZENvbW1vbk9mZnNldFBhcmVudChlbGVtZW50MSwgZ2V0Um9vdChlbGVtZW50MikuaG9zdCk7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBzY3JvbGwgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQgaW4gdGhlIGdpdmVuIHNpZGUgKHRvcCBhbmQgbGVmdClcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQGFyZ3VtZW50IHtTdHJpbmd9IHNpZGUgYHRvcGAgb3IgYGxlZnRgXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBhbW91bnQgb2Ygc2Nyb2xsZWQgcGl4ZWxzXG4gKi9cbmZ1bmN0aW9uIGdldFNjcm9sbChlbGVtZW50KSB7XG4gIHZhciBzaWRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAndG9wJztcblxuICB2YXIgdXBwZXJTaWRlID0gc2lkZSA9PT0gJ3RvcCcgPyAnc2Nyb2xsVG9wJyA6ICdzY3JvbGxMZWZ0JztcbiAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZTtcblxuICBpZiAobm9kZU5hbWUgPT09ICdCT0RZJyB8fCBub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgdmFyIGh0bWwgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIHZhciBzY3JvbGxpbmdFbGVtZW50ID0gZWxlbWVudC5vd25lckRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQgfHwgaHRtbDtcbiAgICByZXR1cm4gc2Nyb2xsaW5nRWxlbWVudFt1cHBlclNpZGVdO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnRbdXBwZXJTaWRlXTtcbn1cblxuLypcbiAqIFN1bSBvciBzdWJ0cmFjdCB0aGUgZWxlbWVudCBzY3JvbGwgdmFsdWVzIChsZWZ0IGFuZCB0b3ApIGZyb20gYSBnaXZlbiByZWN0IG9iamVjdFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtPYmplY3R9IHJlY3QgLSBSZWN0IG9iamVjdCB5b3Ugd2FudCB0byBjaGFuZ2VcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBUaGUgZWxlbWVudCBmcm9tIHRoZSBmdW5jdGlvbiByZWFkcyB0aGUgc2Nyb2xsIHZhbHVlc1xuICogQHBhcmFtIHtCb29sZWFufSBzdWJ0cmFjdCAtIHNldCB0byB0cnVlIGlmIHlvdSB3YW50IHRvIHN1YnRyYWN0IHRoZSBzY3JvbGwgdmFsdWVzXG4gKiBAcmV0dXJuIHtPYmplY3R9IHJlY3QgLSBUaGUgbW9kaWZpZXIgcmVjdCBvYmplY3RcbiAqL1xuZnVuY3Rpb24gaW5jbHVkZVNjcm9sbChyZWN0LCBlbGVtZW50KSB7XG4gIHZhciBzdWJ0cmFjdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG5cbiAgdmFyIHNjcm9sbFRvcCA9IGdldFNjcm9sbChlbGVtZW50LCAndG9wJyk7XG4gIHZhciBzY3JvbGxMZWZ0ID0gZ2V0U2Nyb2xsKGVsZW1lbnQsICdsZWZ0Jyk7XG4gIHZhciBtb2RpZmllciA9IHN1YnRyYWN0ID8gLTEgOiAxO1xuICByZWN0LnRvcCArPSBzY3JvbGxUb3AgKiBtb2RpZmllcjtcbiAgcmVjdC5ib3R0b20gKz0gc2Nyb2xsVG9wICogbW9kaWZpZXI7XG4gIHJlY3QubGVmdCArPSBzY3JvbGxMZWZ0ICogbW9kaWZpZXI7XG4gIHJlY3QucmlnaHQgKz0gc2Nyb2xsTGVmdCAqIG1vZGlmaWVyO1xuICByZXR1cm4gcmVjdDtcbn1cblxuLypcbiAqIEhlbHBlciB0byBkZXRlY3QgYm9yZGVycyBvZiBhIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7Q1NTU3R5bGVEZWNsYXJhdGlvbn0gc3R5bGVzXG4gKiBSZXN1bHQgb2YgYGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eWAgb24gdGhlIGdpdmVuIGVsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBheGlzIC0gYHhgIG9yIGB5YFxuICogQHJldHVybiB7bnVtYmVyfSBib3JkZXJzIC0gVGhlIGJvcmRlcnMgc2l6ZSBvZiB0aGUgZ2l2ZW4gYXhpc1xuICovXG5cbmZ1bmN0aW9uIGdldEJvcmRlcnNTaXplKHN0eWxlcywgYXhpcykge1xuICB2YXIgc2lkZUEgPSBheGlzID09PSAneCcgPyAnTGVmdCcgOiAnVG9wJztcbiAgdmFyIHNpZGVCID0gc2lkZUEgPT09ICdMZWZ0JyA/ICdSaWdodCcgOiAnQm90dG9tJztcblxuICByZXR1cm4gcGFyc2VGbG9hdChzdHlsZXNbJ2JvcmRlcicgKyBzaWRlQSArICdXaWR0aCddLCAxMCkgKyBwYXJzZUZsb2F0KHN0eWxlc1snYm9yZGVyJyArIHNpZGVCICsgJ1dpZHRoJ10sIDEwKTtcbn1cblxuZnVuY3Rpb24gZ2V0U2l6ZShheGlzLCBib2R5LCBodG1sLCBjb21wdXRlZFN0eWxlKSB7XG4gIHJldHVybiBNYXRoLm1heChib2R5WydvZmZzZXQnICsgYXhpc10sIGJvZHlbJ3Njcm9sbCcgKyBheGlzXSwgaHRtbFsnY2xpZW50JyArIGF4aXNdLCBodG1sWydvZmZzZXQnICsgYXhpc10sIGh0bWxbJ3Njcm9sbCcgKyBheGlzXSwgaXNJRSgxMCkgPyBodG1sWydvZmZzZXQnICsgYXhpc10gKyBjb21wdXRlZFN0eWxlWydtYXJnaW4nICsgKGF4aXMgPT09ICdIZWlnaHQnID8gJ1RvcCcgOiAnTGVmdCcpXSArIGNvbXB1dGVkU3R5bGVbJ21hcmdpbicgKyAoYXhpcyA9PT0gJ0hlaWdodCcgPyAnQm90dG9tJyA6ICdSaWdodCcpXSA6IDApO1xufVxuXG5mdW5jdGlvbiBnZXRXaW5kb3dTaXplcygpIHtcbiAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuICB2YXIgaHRtbCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgdmFyIGNvbXB1dGVkU3R5bGUgPSBpc0lFKDEwKSAmJiBnZXRDb21wdXRlZFN0eWxlKGh0bWwpO1xuXG4gIHJldHVybiB7XG4gICAgaGVpZ2h0OiBnZXRTaXplKCdIZWlnaHQnLCBib2R5LCBodG1sLCBjb21wdXRlZFN0eWxlKSxcbiAgICB3aWR0aDogZ2V0U2l6ZSgnV2lkdGgnLCBib2R5LCBodG1sLCBjb21wdXRlZFN0eWxlKVxuICB9O1xufVxuXG52YXIgY2xhc3NDYWxsQ2hlY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufTtcblxudmFyIGNyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9O1xufSgpO1xuXG5cblxuXG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbi8qKlxuICogR2l2ZW4gZWxlbWVudCBvZmZzZXRzLCBnZW5lcmF0ZSBhbiBvdXRwdXQgc2ltaWxhciB0byBnZXRCb3VuZGluZ0NsaWVudFJlY3RcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvZmZzZXRzXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBDbGllbnRSZWN0IGxpa2Ugb3V0cHV0XG4gKi9cbmZ1bmN0aW9uIGdldENsaWVudFJlY3Qob2Zmc2V0cykge1xuICByZXR1cm4gX2V4dGVuZHMoe30sIG9mZnNldHMsIHtcbiAgICByaWdodDogb2Zmc2V0cy5sZWZ0ICsgb2Zmc2V0cy53aWR0aCxcbiAgICBib3R0b206IG9mZnNldHMudG9wICsgb2Zmc2V0cy5oZWlnaHRcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0IGJvdW5kaW5nIGNsaWVudCByZWN0IG9mIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm4ge09iamVjdH0gY2xpZW50IHJlY3RcbiAqL1xuZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQpIHtcbiAgdmFyIHJlY3QgPSB7fTtcblxuICAvLyBJRTEwIDEwIEZJWDogUGxlYXNlLCBkb24ndCBhc2ssIHRoZSBlbGVtZW50IGlzbid0XG4gIC8vIGNvbnNpZGVyZWQgaW4gRE9NIGluIHNvbWUgY2lyY3Vtc3RhbmNlcy4uLlxuICAvLyBUaGlzIGlzbid0IHJlcHJvZHVjaWJsZSBpbiBJRTEwIGNvbXBhdGliaWxpdHkgbW9kZSBvZiBJRTExXG4gIHRyeSB7XG4gICAgaWYgKGlzSUUoMTApKSB7XG4gICAgICByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciBzY3JvbGxUb3AgPSBnZXRTY3JvbGwoZWxlbWVudCwgJ3RvcCcpO1xuICAgICAgdmFyIHNjcm9sbExlZnQgPSBnZXRTY3JvbGwoZWxlbWVudCwgJ2xlZnQnKTtcbiAgICAgIHJlY3QudG9wICs9IHNjcm9sbFRvcDtcbiAgICAgIHJlY3QubGVmdCArPSBzY3JvbGxMZWZ0O1xuICAgICAgcmVjdC5ib3R0b20gKz0gc2Nyb2xsVG9wO1xuICAgICAgcmVjdC5yaWdodCArPSBzY3JvbGxMZWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IHtcbiAgICBsZWZ0OiByZWN0LmxlZnQsXG4gICAgdG9wOiByZWN0LnRvcCxcbiAgICB3aWR0aDogcmVjdC5yaWdodCAtIHJlY3QubGVmdCxcbiAgICBoZWlnaHQ6IHJlY3QuYm90dG9tIC0gcmVjdC50b3BcbiAgfTtcblxuICAvLyBzdWJ0cmFjdCBzY3JvbGxiYXIgc2l6ZSBmcm9tIHNpemVzXG4gIHZhciBzaXplcyA9IGVsZW1lbnQubm9kZU5hbWUgPT09ICdIVE1MJyA/IGdldFdpbmRvd1NpemVzKCkgOiB7fTtcbiAgdmFyIHdpZHRoID0gc2l6ZXMud2lkdGggfHwgZWxlbWVudC5jbGllbnRXaWR0aCB8fCByZXN1bHQucmlnaHQgLSByZXN1bHQubGVmdDtcbiAgdmFyIGhlaWdodCA9IHNpemVzLmhlaWdodCB8fCBlbGVtZW50LmNsaWVudEhlaWdodCB8fCByZXN1bHQuYm90dG9tIC0gcmVzdWx0LnRvcDtcblxuICB2YXIgaG9yaXpTY3JvbGxiYXIgPSBlbGVtZW50Lm9mZnNldFdpZHRoIC0gd2lkdGg7XG4gIHZhciB2ZXJ0U2Nyb2xsYmFyID0gZWxlbWVudC5vZmZzZXRIZWlnaHQgLSBoZWlnaHQ7XG5cbiAgLy8gaWYgYW4gaHlwb3RoZXRpY2FsIHNjcm9sbGJhciBpcyBkZXRlY3RlZCwgd2UgbXVzdCBiZSBzdXJlIGl0J3Mgbm90IGEgYGJvcmRlcmBcbiAgLy8gd2UgbWFrZSB0aGlzIGNoZWNrIGNvbmRpdGlvbmFsIGZvciBwZXJmb3JtYW5jZSByZWFzb25zXG4gIGlmIChob3JpelNjcm9sbGJhciB8fCB2ZXJ0U2Nyb2xsYmFyKSB7XG4gICAgdmFyIHN0eWxlcyA9IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbGVtZW50KTtcbiAgICBob3JpelNjcm9sbGJhciAtPSBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsICd4Jyk7XG4gICAgdmVydFNjcm9sbGJhciAtPSBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsICd5Jyk7XG5cbiAgICByZXN1bHQud2lkdGggLT0gaG9yaXpTY3JvbGxiYXI7XG4gICAgcmVzdWx0LmhlaWdodCAtPSB2ZXJ0U2Nyb2xsYmFyO1xuICB9XG5cbiAgcmV0dXJuIGdldENsaWVudFJlY3QocmVzdWx0KTtcbn1cblxuZnVuY3Rpb24gZ2V0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcmJpdHJhcnlOb2RlKGNoaWxkcmVuLCBwYXJlbnQpIHtcbiAgdmFyIGZpeGVkUG9zaXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gIHZhciBpc0lFMTAgPSBpc0lFKDEwKTtcbiAgdmFyIGlzSFRNTCA9IHBhcmVudC5ub2RlTmFtZSA9PT0gJ0hUTUwnO1xuICB2YXIgY2hpbGRyZW5SZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGNoaWxkcmVuKTtcbiAgdmFyIHBhcmVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QocGFyZW50KTtcbiAgdmFyIHNjcm9sbFBhcmVudCA9IGdldFNjcm9sbFBhcmVudChjaGlsZHJlbik7XG5cbiAgdmFyIHN0eWxlcyA9IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShwYXJlbnQpO1xuICB2YXIgYm9yZGVyVG9wV2lkdGggPSBwYXJzZUZsb2F0KHN0eWxlcy5ib3JkZXJUb3BXaWR0aCwgMTApO1xuICB2YXIgYm9yZGVyTGVmdFdpZHRoID0gcGFyc2VGbG9hdChzdHlsZXMuYm9yZGVyTGVmdFdpZHRoLCAxMCk7XG5cbiAgLy8gSW4gY2FzZXMgd2hlcmUgdGhlIHBhcmVudCBpcyBmaXhlZCwgd2UgbXVzdCBpZ25vcmUgbmVnYXRpdmUgc2Nyb2xsIGluIG9mZnNldCBjYWxjXG4gIGlmIChmaXhlZFBvc2l0aW9uICYmIHBhcmVudC5ub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgcGFyZW50UmVjdC50b3AgPSBNYXRoLm1heChwYXJlbnRSZWN0LnRvcCwgMCk7XG4gICAgcGFyZW50UmVjdC5sZWZ0ID0gTWF0aC5tYXgocGFyZW50UmVjdC5sZWZ0LCAwKTtcbiAgfVxuICB2YXIgb2Zmc2V0cyA9IGdldENsaWVudFJlY3Qoe1xuICAgIHRvcDogY2hpbGRyZW5SZWN0LnRvcCAtIHBhcmVudFJlY3QudG9wIC0gYm9yZGVyVG9wV2lkdGgsXG4gICAgbGVmdDogY2hpbGRyZW5SZWN0LmxlZnQgLSBwYXJlbnRSZWN0LmxlZnQgLSBib3JkZXJMZWZ0V2lkdGgsXG4gICAgd2lkdGg6IGNoaWxkcmVuUmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IGNoaWxkcmVuUmVjdC5oZWlnaHRcbiAgfSk7XG4gIG9mZnNldHMubWFyZ2luVG9wID0gMDtcbiAgb2Zmc2V0cy5tYXJnaW5MZWZ0ID0gMDtcblxuICAvLyBTdWJ0cmFjdCBtYXJnaW5zIG9mIGRvY3VtZW50RWxlbWVudCBpbiBjYXNlIGl0J3MgYmVpbmcgdXNlZCBhcyBwYXJlbnRcbiAgLy8gd2UgZG8gdGhpcyBvbmx5IG9uIEhUTUwgYmVjYXVzZSBpdCdzIHRoZSBvbmx5IGVsZW1lbnQgdGhhdCBiZWhhdmVzXG4gIC8vIGRpZmZlcmVudGx5IHdoZW4gbWFyZ2lucyBhcmUgYXBwbGllZCB0byBpdC4gVGhlIG1hcmdpbnMgYXJlIGluY2x1ZGVkIGluXG4gIC8vIHRoZSBib3ggb2YgdGhlIGRvY3VtZW50RWxlbWVudCwgaW4gdGhlIG90aGVyIGNhc2VzIG5vdC5cbiAgaWYgKCFpc0lFMTAgJiYgaXNIVE1MKSB7XG4gICAgdmFyIG1hcmdpblRvcCA9IHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpblRvcCwgMTApO1xuICAgIHZhciBtYXJnaW5MZWZ0ID0gcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luTGVmdCwgMTApO1xuXG4gICAgb2Zmc2V0cy50b3AgLT0gYm9yZGVyVG9wV2lkdGggLSBtYXJnaW5Ub3A7XG4gICAgb2Zmc2V0cy5ib3R0b20gLT0gYm9yZGVyVG9wV2lkdGggLSBtYXJnaW5Ub3A7XG4gICAgb2Zmc2V0cy5sZWZ0IC09IGJvcmRlckxlZnRXaWR0aCAtIG1hcmdpbkxlZnQ7XG4gICAgb2Zmc2V0cy5yaWdodCAtPSBib3JkZXJMZWZ0V2lkdGggLSBtYXJnaW5MZWZ0O1xuXG4gICAgLy8gQXR0YWNoIG1hcmdpblRvcCBhbmQgbWFyZ2luTGVmdCBiZWNhdXNlIGluIHNvbWUgY2lyY3Vtc3RhbmNlcyB3ZSBtYXkgbmVlZCB0aGVtXG4gICAgb2Zmc2V0cy5tYXJnaW5Ub3AgPSBtYXJnaW5Ub3A7XG4gICAgb2Zmc2V0cy5tYXJnaW5MZWZ0ID0gbWFyZ2luTGVmdDtcbiAgfVxuXG4gIGlmIChpc0lFMTAgJiYgIWZpeGVkUG9zaXRpb24gPyBwYXJlbnQuY29udGFpbnMoc2Nyb2xsUGFyZW50KSA6IHBhcmVudCA9PT0gc2Nyb2xsUGFyZW50ICYmIHNjcm9sbFBhcmVudC5ub2RlTmFtZSAhPT0gJ0JPRFknKSB7XG4gICAgb2Zmc2V0cyA9IGluY2x1ZGVTY3JvbGwob2Zmc2V0cywgcGFyZW50KTtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXRzO1xufVxuXG5mdW5jdGlvbiBnZXRWaWV3cG9ydE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJ0Yml0cmFyeU5vZGUoZWxlbWVudCkge1xuICB2YXIgZXhjbHVkZVNjcm9sbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cbiAgdmFyIGh0bWwgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB2YXIgcmVsYXRpdmVPZmZzZXQgPSBnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUoZWxlbWVudCwgaHRtbCk7XG4gIHZhciB3aWR0aCA9IE1hdGgubWF4KGh0bWwuY2xpZW50V2lkdGgsIHdpbmRvdy5pbm5lcldpZHRoIHx8IDApO1xuICB2YXIgaGVpZ2h0ID0gTWF0aC5tYXgoaHRtbC5jbGllbnRIZWlnaHQsIHdpbmRvdy5pbm5lckhlaWdodCB8fCAwKTtcblxuICB2YXIgc2Nyb2xsVG9wID0gIWV4Y2x1ZGVTY3JvbGwgPyBnZXRTY3JvbGwoaHRtbCkgOiAwO1xuICB2YXIgc2Nyb2xsTGVmdCA9ICFleGNsdWRlU2Nyb2xsID8gZ2V0U2Nyb2xsKGh0bWwsICdsZWZ0JykgOiAwO1xuXG4gIHZhciBvZmZzZXQgPSB7XG4gICAgdG9wOiBzY3JvbGxUb3AgLSByZWxhdGl2ZU9mZnNldC50b3AgKyByZWxhdGl2ZU9mZnNldC5tYXJnaW5Ub3AsXG4gICAgbGVmdDogc2Nyb2xsTGVmdCAtIHJlbGF0aXZlT2Zmc2V0LmxlZnQgKyByZWxhdGl2ZU9mZnNldC5tYXJnaW5MZWZ0LFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodFxuICB9O1xuXG4gIHJldHVybiBnZXRDbGllbnRSZWN0KG9mZnNldCk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIGVsZW1lbnQgaXMgZml4ZWQgb3IgaXMgaW5zaWRlIGEgZml4ZWQgcGFyZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gY3VzdG9tQ29udGFpbmVyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gYW5zd2VyIHRvIFwiaXNGaXhlZD9cIlxuICovXG5mdW5jdGlvbiBpc0ZpeGVkKGVsZW1lbnQpIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZTtcbiAgaWYgKG5vZGVOYW1lID09PSAnQk9EWScgfHwgbm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsZW1lbnQsICdwb3NpdGlvbicpID09PSAnZml4ZWQnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGlzRml4ZWQoZ2V0UGFyZW50Tm9kZShlbGVtZW50KSk7XG59XG5cbi8qKlxuICogRmluZHMgdGhlIGZpcnN0IHBhcmVudCBvZiBhbiBlbGVtZW50IHRoYXQgaGFzIGEgdHJhbnNmb3JtZWQgcHJvcGVydHkgZGVmaW5lZFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7RWxlbWVudH0gZmlyc3QgdHJhbnNmb3JtZWQgcGFyZW50IG9yIGRvY3VtZW50RWxlbWVudFxuICovXG5cbmZ1bmN0aW9uIGdldEZpeGVkUG9zaXRpb25PZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICAvLyBUaGlzIGNoZWNrIGlzIG5lZWRlZCB0byBhdm9pZCBlcnJvcnMgaW4gY2FzZSBvbmUgb2YgdGhlIGVsZW1lbnRzIGlzbid0IGRlZmluZWQgZm9yIGFueSByZWFzb25cbiAgaWYgKCFlbGVtZW50IHx8ICFlbGVtZW50LnBhcmVudEVsZW1lbnQgfHwgaXNJRSgpKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgfVxuICB2YXIgZWwgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gIHdoaWxlIChlbCAmJiBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZWwsICd0cmFuc2Zvcm0nKSA9PT0gJ25vbmUnKSB7XG4gICAgZWwgPSBlbC5wYXJlbnRFbGVtZW50O1xuICB9XG4gIHJldHVybiBlbCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG59XG5cbi8qKlxuICogQ29tcHV0ZWQgdGhlIGJvdW5kYXJpZXMgbGltaXRzIGFuZCByZXR1cm4gdGhlbVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcG9wcGVyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSByZWZlcmVuY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYWRkaW5nXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBib3VuZGFyaWVzRWxlbWVudCAtIEVsZW1lbnQgdXNlZCB0byBkZWZpbmUgdGhlIGJvdW5kYXJpZXNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZml4ZWRQb3NpdGlvbiAtIElzIGluIGZpeGVkIHBvc2l0aW9uIG1vZGVcbiAqIEByZXR1cm5zIHtPYmplY3R9IENvb3JkaW5hdGVzIG9mIHRoZSBib3VuZGFyaWVzXG4gKi9cbmZ1bmN0aW9uIGdldEJvdW5kYXJpZXMocG9wcGVyLCByZWZlcmVuY2UsIHBhZGRpbmcsIGJvdW5kYXJpZXNFbGVtZW50KSB7XG4gIHZhciBmaXhlZFBvc2l0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiBmYWxzZTtcblxuICAvLyBOT1RFOiAxIERPTSBhY2Nlc3MgaGVyZVxuXG4gIHZhciBib3VuZGFyaWVzID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcbiAgdmFyIG9mZnNldFBhcmVudCA9IGZpeGVkUG9zaXRpb24gPyBnZXRGaXhlZFBvc2l0aW9uT2Zmc2V0UGFyZW50KHBvcHBlcikgOiBmaW5kQ29tbW9uT2Zmc2V0UGFyZW50KHBvcHBlciwgcmVmZXJlbmNlKTtcblxuICAvLyBIYW5kbGUgdmlld3BvcnQgY2FzZVxuICBpZiAoYm91bmRhcmllc0VsZW1lbnQgPT09ICd2aWV3cG9ydCcpIHtcbiAgICBib3VuZGFyaWVzID0gZ2V0Vmlld3BvcnRPZmZzZXRSZWN0UmVsYXRpdmVUb0FydGJpdHJhcnlOb2RlKG9mZnNldFBhcmVudCwgZml4ZWRQb3NpdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgLy8gSGFuZGxlIG90aGVyIGNhc2VzIGJhc2VkIG9uIERPTSBlbGVtZW50IHVzZWQgYXMgYm91bmRhcmllc1xuICAgIHZhciBib3VuZGFyaWVzTm9kZSA9IHZvaWQgMDtcbiAgICBpZiAoYm91bmRhcmllc0VsZW1lbnQgPT09ICdzY3JvbGxQYXJlbnQnKSB7XG4gICAgICBib3VuZGFyaWVzTm9kZSA9IGdldFNjcm9sbFBhcmVudChnZXRQYXJlbnROb2RlKHJlZmVyZW5jZSkpO1xuICAgICAgaWYgKGJvdW5kYXJpZXNOb2RlLm5vZGVOYW1lID09PSAnQk9EWScpIHtcbiAgICAgICAgYm91bmRhcmllc05vZGUgPSBwb3BwZXIub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChib3VuZGFyaWVzRWxlbWVudCA9PT0gJ3dpbmRvdycpIHtcbiAgICAgIGJvdW5kYXJpZXNOb2RlID0gcG9wcGVyLm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBib3VuZGFyaWVzTm9kZSA9IGJvdW5kYXJpZXNFbGVtZW50O1xuICAgIH1cblxuICAgIHZhciBvZmZzZXRzID0gZ2V0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcmJpdHJhcnlOb2RlKGJvdW5kYXJpZXNOb2RlLCBvZmZzZXRQYXJlbnQsIGZpeGVkUG9zaXRpb24pO1xuXG4gICAgLy8gSW4gY2FzZSBvZiBIVE1MLCB3ZSBuZWVkIGEgZGlmZmVyZW50IGNvbXB1dGF0aW9uXG4gICAgaWYgKGJvdW5kYXJpZXNOb2RlLm5vZGVOYW1lID09PSAnSFRNTCcgJiYgIWlzRml4ZWQob2Zmc2V0UGFyZW50KSkge1xuICAgICAgdmFyIF9nZXRXaW5kb3dTaXplcyA9IGdldFdpbmRvd1NpemVzKCksXG4gICAgICAgICAgaGVpZ2h0ID0gX2dldFdpbmRvd1NpemVzLmhlaWdodCxcbiAgICAgICAgICB3aWR0aCA9IF9nZXRXaW5kb3dTaXplcy53aWR0aDtcblxuICAgICAgYm91bmRhcmllcy50b3AgKz0gb2Zmc2V0cy50b3AgLSBvZmZzZXRzLm1hcmdpblRvcDtcbiAgICAgIGJvdW5kYXJpZXMuYm90dG9tID0gaGVpZ2h0ICsgb2Zmc2V0cy50b3A7XG4gICAgICBib3VuZGFyaWVzLmxlZnQgKz0gb2Zmc2V0cy5sZWZ0IC0gb2Zmc2V0cy5tYXJnaW5MZWZ0O1xuICAgICAgYm91bmRhcmllcy5yaWdodCA9IHdpZHRoICsgb2Zmc2V0cy5sZWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBmb3IgYWxsIHRoZSBvdGhlciBET00gZWxlbWVudHMsIHRoaXMgb25lIGlzIGdvb2RcbiAgICAgIGJvdW5kYXJpZXMgPSBvZmZzZXRzO1xuICAgIH1cbiAgfVxuXG4gIC8vIEFkZCBwYWRkaW5nc1xuICBib3VuZGFyaWVzLmxlZnQgKz0gcGFkZGluZztcbiAgYm91bmRhcmllcy50b3AgKz0gcGFkZGluZztcbiAgYm91bmRhcmllcy5yaWdodCAtPSBwYWRkaW5nO1xuICBib3VuZGFyaWVzLmJvdHRvbSAtPSBwYWRkaW5nO1xuXG4gIHJldHVybiBib3VuZGFyaWVzO1xufVxuXG5mdW5jdGlvbiBnZXRBcmVhKF9yZWYpIHtcbiAgdmFyIHdpZHRoID0gX3JlZi53aWR0aCxcbiAgICAgIGhlaWdodCA9IF9yZWYuaGVpZ2h0O1xuXG4gIHJldHVybiB3aWR0aCAqIGhlaWdodDtcbn1cblxuLyoqXG4gKiBVdGlsaXR5IHVzZWQgdG8gdHJhbnNmb3JtIHRoZSBgYXV0b2AgcGxhY2VtZW50IHRvIHRoZSBwbGFjZW1lbnQgd2l0aCBtb3JlXG4gKiBhdmFpbGFibGUgc3BhY2UuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBjb21wdXRlQXV0b1BsYWNlbWVudChwbGFjZW1lbnQsIHJlZlJlY3QsIHBvcHBlciwgcmVmZXJlbmNlLCBib3VuZGFyaWVzRWxlbWVudCkge1xuICB2YXIgcGFkZGluZyA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogMDtcblxuICBpZiAocGxhY2VtZW50LmluZGV4T2YoJ2F1dG8nKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gcGxhY2VtZW50O1xuICB9XG5cbiAgdmFyIGJvdW5kYXJpZXMgPSBnZXRCb3VuZGFyaWVzKHBvcHBlciwgcmVmZXJlbmNlLCBwYWRkaW5nLCBib3VuZGFyaWVzRWxlbWVudCk7XG5cbiAgdmFyIHJlY3RzID0ge1xuICAgIHRvcDoge1xuICAgICAgd2lkdGg6IGJvdW5kYXJpZXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IHJlZlJlY3QudG9wIC0gYm91bmRhcmllcy50b3BcbiAgICB9LFxuICAgIHJpZ2h0OiB7XG4gICAgICB3aWR0aDogYm91bmRhcmllcy5yaWdodCAtIHJlZlJlY3QucmlnaHQsXG4gICAgICBoZWlnaHQ6IGJvdW5kYXJpZXMuaGVpZ2h0XG4gICAgfSxcbiAgICBib3R0b206IHtcbiAgICAgIHdpZHRoOiBib3VuZGFyaWVzLndpZHRoLFxuICAgICAgaGVpZ2h0OiBib3VuZGFyaWVzLmJvdHRvbSAtIHJlZlJlY3QuYm90dG9tXG4gICAgfSxcbiAgICBsZWZ0OiB7XG4gICAgICB3aWR0aDogcmVmUmVjdC5sZWZ0IC0gYm91bmRhcmllcy5sZWZ0LFxuICAgICAgaGVpZ2h0OiBib3VuZGFyaWVzLmhlaWdodFxuICAgIH1cbiAgfTtcblxuICB2YXIgc29ydGVkQXJlYXMgPSBPYmplY3Qua2V5cyhyZWN0cykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAga2V5OiBrZXlcbiAgICB9LCByZWN0c1trZXldLCB7XG4gICAgICBhcmVhOiBnZXRBcmVhKHJlY3RzW2tleV0pXG4gICAgfSk7XG4gIH0pLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYi5hcmVhIC0gYS5hcmVhO1xuICB9KTtcblxuICB2YXIgZmlsdGVyZWRBcmVhcyA9IHNvcnRlZEFyZWFzLmZpbHRlcihmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICB2YXIgd2lkdGggPSBfcmVmMi53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gX3JlZjIuaGVpZ2h0O1xuICAgIHJldHVybiB3aWR0aCA+PSBwb3BwZXIuY2xpZW50V2lkdGggJiYgaGVpZ2h0ID49IHBvcHBlci5jbGllbnRIZWlnaHQ7XG4gIH0pO1xuXG4gIHZhciBjb21wdXRlZFBsYWNlbWVudCA9IGZpbHRlcmVkQXJlYXMubGVuZ3RoID4gMCA/IGZpbHRlcmVkQXJlYXNbMF0ua2V5IDogc29ydGVkQXJlYXNbMF0ua2V5O1xuXG4gIHZhciB2YXJpYXRpb24gPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVsxXTtcblxuICByZXR1cm4gY29tcHV0ZWRQbGFjZW1lbnQgKyAodmFyaWF0aW9uID8gJy0nICsgdmFyaWF0aW9uIDogJycpO1xufVxuXG4vKipcbiAqIEdldCBvZmZzZXRzIHRvIHRoZSByZWZlcmVuY2UgZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHBvcHBlciAtIHRoZSBwb3BwZXIgZWxlbWVudFxuICogQHBhcmFtIHtFbGVtZW50fSByZWZlcmVuY2UgLSB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgKHRoZSBwb3BwZXIgd2lsbCBiZSByZWxhdGl2ZSB0byB0aGlzKVxuICogQHBhcmFtIHtFbGVtZW50fSBmaXhlZFBvc2l0aW9uIC0gaXMgaW4gZml4ZWQgcG9zaXRpb24gbW9kZVxuICogQHJldHVybnMge09iamVjdH0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9mZnNldHMgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXJcbiAqL1xuZnVuY3Rpb24gZ2V0UmVmZXJlbmNlT2Zmc2V0cyhzdGF0ZSwgcG9wcGVyLCByZWZlcmVuY2UpIHtcbiAgdmFyIGZpeGVkUG9zaXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IG51bGw7XG5cbiAgdmFyIGNvbW1vbk9mZnNldFBhcmVudCA9IGZpeGVkUG9zaXRpb24gPyBnZXRGaXhlZFBvc2l0aW9uT2Zmc2V0UGFyZW50KHBvcHBlcikgOiBmaW5kQ29tbW9uT2Zmc2V0UGFyZW50KHBvcHBlciwgcmVmZXJlbmNlKTtcbiAgcmV0dXJuIGdldE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJiaXRyYXJ5Tm9kZShyZWZlcmVuY2UsIGNvbW1vbk9mZnNldFBhcmVudCwgZml4ZWRQb3NpdGlvbik7XG59XG5cbi8qKlxuICogR2V0IHRoZSBvdXRlciBzaXplcyBvZiB0aGUgZ2l2ZW4gZWxlbWVudCAob2Zmc2V0IHNpemUgKyBtYXJnaW5zKVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBvYmplY3QgY29udGFpbmluZyB3aWR0aCBhbmQgaGVpZ2h0IHByb3BlcnRpZXNcbiAqL1xuZnVuY3Rpb24gZ2V0T3V0ZXJTaXplcyhlbGVtZW50KSB7XG4gIHZhciBzdHlsZXMgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICB2YXIgeCA9IHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpblRvcCkgKyBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5Cb3R0b20pO1xuICB2YXIgeSA9IHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpbkxlZnQpICsgcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luUmlnaHQpO1xuICB2YXIgcmVzdWx0ID0ge1xuICAgIHdpZHRoOiBlbGVtZW50Lm9mZnNldFdpZHRoICsgeSxcbiAgICBoZWlnaHQ6IGVsZW1lbnQub2Zmc2V0SGVpZ2h0ICsgeFxuICB9O1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldCB0aGUgb3Bwb3NpdGUgcGxhY2VtZW50IG9mIHRoZSBnaXZlbiBvbmVcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBwbGFjZW1lbnRcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGZsaXBwZWQgcGxhY2VtZW50XG4gKi9cbmZ1bmN0aW9uIGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICB2YXIgaGFzaCA9IHsgbGVmdDogJ3JpZ2h0JywgcmlnaHQ6ICdsZWZ0JywgYm90dG9tOiAndG9wJywgdG9wOiAnYm90dG9tJyB9O1xuICByZXR1cm4gcGxhY2VtZW50LnJlcGxhY2UoL2xlZnR8cmlnaHR8Ym90dG9tfHRvcC9nLCBmdW5jdGlvbiAobWF0Y2hlZCkge1xuICAgIHJldHVybiBoYXNoW21hdGNoZWRdO1xuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgb2Zmc2V0cyB0byB0aGUgcG9wcGVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge09iamVjdH0gcG9zaXRpb24gLSBDU1MgcG9zaXRpb24gdGhlIFBvcHBlciB3aWxsIGdldCBhcHBsaWVkXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwb3BwZXIgLSB0aGUgcG9wcGVyIGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWZlcmVuY2VPZmZzZXRzIC0gdGhlIHJlZmVyZW5jZSBvZmZzZXRzICh0aGUgcG9wcGVyIHdpbGwgYmUgcmVsYXRpdmUgdG8gdGhpcylcbiAqIEBwYXJhbSB7U3RyaW5nfSBwbGFjZW1lbnQgLSBvbmUgb2YgdGhlIHZhbGlkIHBsYWNlbWVudCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBwb3BwZXJPZmZzZXRzIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9mZnNldHMgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXJcbiAqL1xuZnVuY3Rpb24gZ2V0UG9wcGVyT2Zmc2V0cyhwb3BwZXIsIHJlZmVyZW5jZU9mZnNldHMsIHBsYWNlbWVudCkge1xuICBwbGFjZW1lbnQgPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcblxuICAvLyBHZXQgcG9wcGVyIG5vZGUgc2l6ZXNcbiAgdmFyIHBvcHBlclJlY3QgPSBnZXRPdXRlclNpemVzKHBvcHBlcik7XG5cbiAgLy8gQWRkIHBvc2l0aW9uLCB3aWR0aCBhbmQgaGVpZ2h0IHRvIG91ciBvZmZzZXRzIG9iamVjdFxuICB2YXIgcG9wcGVyT2Zmc2V0cyA9IHtcbiAgICB3aWR0aDogcG9wcGVyUmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IHBvcHBlclJlY3QuaGVpZ2h0XG4gIH07XG5cbiAgLy8gZGVwZW5kaW5nIGJ5IHRoZSBwb3BwZXIgcGxhY2VtZW50IHdlIGhhdmUgdG8gY29tcHV0ZSBpdHMgb2Zmc2V0cyBzbGlnaHRseSBkaWZmZXJlbnRseVxuICB2YXIgaXNIb3JpeiA9IFsncmlnaHQnLCAnbGVmdCddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTE7XG4gIHZhciBtYWluU2lkZSA9IGlzSG9yaXogPyAndG9wJyA6ICdsZWZ0JztcbiAgdmFyIHNlY29uZGFyeVNpZGUgPSBpc0hvcml6ID8gJ2xlZnQnIDogJ3RvcCc7XG4gIHZhciBtZWFzdXJlbWVudCA9IGlzSG9yaXogPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gIHZhciBzZWNvbmRhcnlNZWFzdXJlbWVudCA9ICFpc0hvcml6ID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuXG4gIHBvcHBlck9mZnNldHNbbWFpblNpZGVdID0gcmVmZXJlbmNlT2Zmc2V0c1ttYWluU2lkZV0gKyByZWZlcmVuY2VPZmZzZXRzW21lYXN1cmVtZW50XSAvIDIgLSBwb3BwZXJSZWN0W21lYXN1cmVtZW50XSAvIDI7XG4gIGlmIChwbGFjZW1lbnQgPT09IHNlY29uZGFyeVNpZGUpIHtcbiAgICBwb3BwZXJPZmZzZXRzW3NlY29uZGFyeVNpZGVdID0gcmVmZXJlbmNlT2Zmc2V0c1tzZWNvbmRhcnlTaWRlXSAtIHBvcHBlclJlY3Rbc2Vjb25kYXJ5TWVhc3VyZW1lbnRdO1xuICB9IGVsc2Uge1xuICAgIHBvcHBlck9mZnNldHNbc2Vjb25kYXJ5U2lkZV0gPSByZWZlcmVuY2VPZmZzZXRzW2dldE9wcG9zaXRlUGxhY2VtZW50KHNlY29uZGFyeVNpZGUpXTtcbiAgfVxuXG4gIHJldHVybiBwb3BwZXJPZmZzZXRzO1xufVxuXG4vKipcbiAqIE1pbWljcyB0aGUgYGZpbmRgIG1ldGhvZCBvZiBBcnJheVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtBcnJheX0gYXJyXG4gKiBAYXJndW1lbnQgcHJvcFxuICogQGFyZ3VtZW50IHZhbHVlXG4gKiBAcmV0dXJucyBpbmRleCBvciAtMVxuICovXG5mdW5jdGlvbiBmaW5kKGFyciwgY2hlY2spIHtcbiAgLy8gdXNlIG5hdGl2ZSBmaW5kIGlmIHN1cHBvcnRlZFxuICBpZiAoQXJyYXkucHJvdG90eXBlLmZpbmQpIHtcbiAgICByZXR1cm4gYXJyLmZpbmQoY2hlY2spO1xuICB9XG5cbiAgLy8gdXNlIGBmaWx0ZXJgIHRvIG9idGFpbiB0aGUgc2FtZSBiZWhhdmlvciBvZiBgZmluZGBcbiAgcmV0dXJuIGFyci5maWx0ZXIoY2hlY2spWzBdO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgaW5kZXggb2YgdGhlIG1hdGNoaW5nIG9iamVjdFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtBcnJheX0gYXJyXG4gKiBAYXJndW1lbnQgcHJvcFxuICogQGFyZ3VtZW50IHZhbHVlXG4gKiBAcmV0dXJucyBpbmRleCBvciAtMVxuICovXG5mdW5jdGlvbiBmaW5kSW5kZXgoYXJyLCBwcm9wLCB2YWx1ZSkge1xuICAvLyB1c2UgbmF0aXZlIGZpbmRJbmRleCBpZiBzdXBwb3J0ZWRcbiAgaWYgKEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXgpIHtcbiAgICByZXR1cm4gYXJyLmZpbmRJbmRleChmdW5jdGlvbiAoY3VyKSB7XG4gICAgICByZXR1cm4gY3VyW3Byb3BdID09PSB2YWx1ZTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIHVzZSBgZmluZGAgKyBgaW5kZXhPZmAgaWYgYGZpbmRJbmRleGAgaXNuJ3Qgc3VwcG9ydGVkXG4gIHZhciBtYXRjaCA9IGZpbmQoYXJyLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIG9ialtwcm9wXSA9PT0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gYXJyLmluZGV4T2YobWF0Y2gpO1xufVxuXG4vKipcbiAqIExvb3AgdHJvdWdoIHRoZSBsaXN0IG9mIG1vZGlmaWVycyBhbmQgcnVuIHRoZW0gaW4gb3JkZXIsXG4gKiBlYWNoIG9mIHRoZW0gd2lsbCB0aGVuIGVkaXQgdGhlIGRhdGEgb2JqZWN0LlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtkYXRhT2JqZWN0fSBkYXRhXG4gKiBAcGFyYW0ge0FycmF5fSBtb2RpZmllcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBlbmRzIC0gT3B0aW9uYWwgbW9kaWZpZXIgbmFtZSB1c2VkIGFzIHN0b3BwZXJcbiAqIEByZXR1cm5zIHtkYXRhT2JqZWN0fVxuICovXG5mdW5jdGlvbiBydW5Nb2RpZmllcnMobW9kaWZpZXJzLCBkYXRhLCBlbmRzKSB7XG4gIHZhciBtb2RpZmllcnNUb1J1biA9IGVuZHMgPT09IHVuZGVmaW5lZCA/IG1vZGlmaWVycyA6IG1vZGlmaWVycy5zbGljZSgwLCBmaW5kSW5kZXgobW9kaWZpZXJzLCAnbmFtZScsIGVuZHMpKTtcblxuICBtb2RpZmllcnNUb1J1bi5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIGlmIChtb2RpZmllclsnZnVuY3Rpb24nXSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICAgIGNvbnNvbGUud2FybignYG1vZGlmaWVyLmZ1bmN0aW9uYCBpcyBkZXByZWNhdGVkLCB1c2UgYG1vZGlmaWVyLmZuYCEnKTtcbiAgICB9XG4gICAgdmFyIGZuID0gbW9kaWZpZXJbJ2Z1bmN0aW9uJ10gfHwgbW9kaWZpZXIuZm47IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgaWYgKG1vZGlmaWVyLmVuYWJsZWQgJiYgaXNGdW5jdGlvbihmbikpIHtcbiAgICAgIC8vIEFkZCBwcm9wZXJ0aWVzIHRvIG9mZnNldHMgdG8gbWFrZSB0aGVtIGEgY29tcGxldGUgY2xpZW50UmVjdCBvYmplY3RcbiAgICAgIC8vIHdlIGRvIHRoaXMgYmVmb3JlIGVhY2ggbW9kaWZpZXIgdG8gbWFrZSBzdXJlIHRoZSBwcmV2aW91cyBvbmUgZG9lc24ndFxuICAgICAgLy8gbWVzcyB3aXRoIHRoZXNlIHZhbHVlc1xuICAgICAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IGdldENsaWVudFJlY3QoZGF0YS5vZmZzZXRzLnBvcHBlcik7XG4gICAgICBkYXRhLm9mZnNldHMucmVmZXJlbmNlID0gZ2V0Q2xpZW50UmVjdChkYXRhLm9mZnNldHMucmVmZXJlbmNlKTtcblxuICAgICAgZGF0YSA9IGZuKGRhdGEsIG1vZGlmaWVyKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBwb3BwZXIsIGNvbXB1dGluZyB0aGUgbmV3IG9mZnNldHMgYW5kIGFwcGx5aW5nXG4gKiB0aGUgbmV3IHN0eWxlLjxiciAvPlxuICogUHJlZmVyIGBzY2hlZHVsZVVwZGF0ZWAgb3ZlciBgdXBkYXRlYCBiZWNhdXNlIG9mIHBlcmZvcm1hbmNlIHJlYXNvbnMuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgLy8gaWYgcG9wcGVyIGlzIGRlc3Ryb3llZCwgZG9uJ3QgcGVyZm9ybSBhbnkgZnVydGhlciB1cGRhdGVcbiAgaWYgKHRoaXMuc3RhdGUuaXNEZXN0cm95ZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZGF0YSA9IHtcbiAgICBpbnN0YW5jZTogdGhpcyxcbiAgICBzdHlsZXM6IHt9LFxuICAgIGFycm93U3R5bGVzOiB7fSxcbiAgICBhdHRyaWJ1dGVzOiB7fSxcbiAgICBmbGlwcGVkOiBmYWxzZSxcbiAgICBvZmZzZXRzOiB7fVxuICB9O1xuXG4gIC8vIGNvbXB1dGUgcmVmZXJlbmNlIGVsZW1lbnQgb2Zmc2V0c1xuICBkYXRhLm9mZnNldHMucmVmZXJlbmNlID0gZ2V0UmVmZXJlbmNlT2Zmc2V0cyh0aGlzLnN0YXRlLCB0aGlzLnBvcHBlciwgdGhpcy5yZWZlcmVuY2UsIHRoaXMub3B0aW9ucy5wb3NpdGlvbkZpeGVkKTtcblxuICAvLyBjb21wdXRlIGF1dG8gcGxhY2VtZW50LCBzdG9yZSBwbGFjZW1lbnQgaW5zaWRlIHRoZSBkYXRhIG9iamVjdCxcbiAgLy8gbW9kaWZpZXJzIHdpbGwgYmUgYWJsZSB0byBlZGl0IGBwbGFjZW1lbnRgIGlmIG5lZWRlZFxuICAvLyBhbmQgcmVmZXIgdG8gb3JpZ2luYWxQbGFjZW1lbnQgdG8ga25vdyB0aGUgb3JpZ2luYWwgdmFsdWVcbiAgZGF0YS5wbGFjZW1lbnQgPSBjb21wdXRlQXV0b1BsYWNlbWVudCh0aGlzLm9wdGlvbnMucGxhY2VtZW50LCBkYXRhLm9mZnNldHMucmVmZXJlbmNlLCB0aGlzLnBvcHBlciwgdGhpcy5yZWZlcmVuY2UsIHRoaXMub3B0aW9ucy5tb2RpZmllcnMuZmxpcC5ib3VuZGFyaWVzRWxlbWVudCwgdGhpcy5vcHRpb25zLm1vZGlmaWVycy5mbGlwLnBhZGRpbmcpO1xuXG4gIC8vIHN0b3JlIHRoZSBjb21wdXRlZCBwbGFjZW1lbnQgaW5zaWRlIGBvcmlnaW5hbFBsYWNlbWVudGBcbiAgZGF0YS5vcmlnaW5hbFBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50O1xuXG4gIGRhdGEucG9zaXRpb25GaXhlZCA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbkZpeGVkO1xuXG4gIC8vIGNvbXB1dGUgdGhlIHBvcHBlciBvZmZzZXRzXG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBnZXRQb3BwZXJPZmZzZXRzKHRoaXMucG9wcGVyLCBkYXRhLm9mZnNldHMucmVmZXJlbmNlLCBkYXRhLnBsYWNlbWVudCk7XG5cbiAgZGF0YS5vZmZzZXRzLnBvcHBlci5wb3NpdGlvbiA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbkZpeGVkID8gJ2ZpeGVkJyA6ICdhYnNvbHV0ZSc7XG5cbiAgLy8gcnVuIHRoZSBtb2RpZmllcnNcbiAgZGF0YSA9IHJ1bk1vZGlmaWVycyh0aGlzLm1vZGlmaWVycywgZGF0YSk7XG5cbiAgLy8gdGhlIGZpcnN0IGB1cGRhdGVgIHdpbGwgY2FsbCBgb25DcmVhdGVgIGNhbGxiYWNrXG4gIC8vIHRoZSBvdGhlciBvbmVzIHdpbGwgY2FsbCBgb25VcGRhdGVgIGNhbGxiYWNrXG4gIGlmICghdGhpcy5zdGF0ZS5pc0NyZWF0ZWQpIHtcbiAgICB0aGlzLnN0YXRlLmlzQ3JlYXRlZCA9IHRydWU7XG4gICAgdGhpcy5vcHRpb25zLm9uQ3JlYXRlKGRhdGEpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMub3B0aW9ucy5vblVwZGF0ZShkYXRhKTtcbiAgfVxufVxuXG4vKipcbiAqIEhlbHBlciB1c2VkIHRvIGtub3cgaWYgdGhlIGdpdmVuIG1vZGlmaWVyIGlzIGVuYWJsZWQuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNNb2RpZmllckVuYWJsZWQobW9kaWZpZXJzLCBtb2RpZmllck5hbWUpIHtcbiAgcmV0dXJuIG1vZGlmaWVycy5zb21lKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmLm5hbWUsXG4gICAgICAgIGVuYWJsZWQgPSBfcmVmLmVuYWJsZWQ7XG4gICAgcmV0dXJuIGVuYWJsZWQgJiYgbmFtZSA9PT0gbW9kaWZpZXJOYW1lO1xuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHByZWZpeGVkIHN1cHBvcnRlZCBwcm9wZXJ0eSBuYW1lXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gcHJvcGVydHkgKGNhbWVsQ2FzZSlcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHByZWZpeGVkIHByb3BlcnR5IChjYW1lbENhc2Ugb3IgUGFzY2FsQ2FzZSwgZGVwZW5kaW5nIG9uIHRoZSB2ZW5kb3IgcHJlZml4KVxuICovXG5mdW5jdGlvbiBnZXRTdXBwb3J0ZWRQcm9wZXJ0eU5hbWUocHJvcGVydHkpIHtcbiAgdmFyIHByZWZpeGVzID0gW2ZhbHNlLCAnbXMnLCAnV2Via2l0JywgJ01veicsICdPJ107XG4gIHZhciB1cHBlclByb3AgPSBwcm9wZXJ0eS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3BlcnR5LnNsaWNlKDEpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJlZml4ID0gcHJlZml4ZXNbaV07XG4gICAgdmFyIHRvQ2hlY2sgPSBwcmVmaXggPyAnJyArIHByZWZpeCArIHVwcGVyUHJvcCA6IHByb3BlcnR5O1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQuYm9keS5zdHlsZVt0b0NoZWNrXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB0b0NoZWNrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBEZXN0cm95IHRoZSBwb3BwZXJcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xuZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgdGhpcy5zdGF0ZS5pc0Rlc3Ryb3llZCA9IHRydWU7XG5cbiAgLy8gdG91Y2ggRE9NIG9ubHkgaWYgYGFwcGx5U3R5bGVgIG1vZGlmaWVyIGlzIGVuYWJsZWRcbiAgaWYgKGlzTW9kaWZpZXJFbmFibGVkKHRoaXMubW9kaWZpZXJzLCAnYXBwbHlTdHlsZScpKSB7XG4gICAgdGhpcy5wb3BwZXIucmVtb3ZlQXR0cmlidXRlKCd4LXBsYWNlbWVudCcpO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlLnBvc2l0aW9uID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUudG9wID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUubGVmdCA9ICcnO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlLnJpZ2h0ID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUuYm90dG9tID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUud2lsbENoYW5nZSA9ICcnO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlW2dldFN1cHBvcnRlZFByb3BlcnR5TmFtZSgndHJhbnNmb3JtJyldID0gJyc7XG4gIH1cblxuICB0aGlzLmRpc2FibGVFdmVudExpc3RlbmVycygpO1xuXG4gIC8vIHJlbW92ZSB0aGUgcG9wcGVyIGlmIHVzZXIgZXhwbGljaXR5IGFza2VkIGZvciB0aGUgZGVsZXRpb24gb24gZGVzdHJveVxuICAvLyBkbyBub3QgdXNlIGByZW1vdmVgIGJlY2F1c2UgSUUxMSBkb2Vzbid0IHN1cHBvcnQgaXRcbiAgaWYgKHRoaXMub3B0aW9ucy5yZW1vdmVPbkRlc3Ryb3kpIHtcbiAgICB0aGlzLnBvcHBlci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMucG9wcGVyKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHdpbmRvdyBhc3NvY2lhdGVkIHdpdGggdGhlIGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge1dpbmRvd31cbiAqL1xuZnVuY3Rpb24gZ2V0V2luZG93KGVsZW1lbnQpIHtcbiAgdmFyIG93bmVyRG9jdW1lbnQgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG4gIHJldHVybiBvd25lckRvY3VtZW50ID8gb3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyA6IHdpbmRvdztcbn1cblxuZnVuY3Rpb24gYXR0YWNoVG9TY3JvbGxQYXJlbnRzKHNjcm9sbFBhcmVudCwgZXZlbnQsIGNhbGxiYWNrLCBzY3JvbGxQYXJlbnRzKSB7XG4gIHZhciBpc0JvZHkgPSBzY3JvbGxQYXJlbnQubm9kZU5hbWUgPT09ICdCT0RZJztcbiAgdmFyIHRhcmdldCA9IGlzQm9keSA/IHNjcm9sbFBhcmVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IDogc2Nyb2xsUGFyZW50O1xuICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgY2FsbGJhY2ssIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcblxuICBpZiAoIWlzQm9keSkge1xuICAgIGF0dGFjaFRvU2Nyb2xsUGFyZW50cyhnZXRTY3JvbGxQYXJlbnQodGFyZ2V0LnBhcmVudE5vZGUpLCBldmVudCwgY2FsbGJhY2ssIHNjcm9sbFBhcmVudHMpO1xuICB9XG4gIHNjcm9sbFBhcmVudHMucHVzaCh0YXJnZXQpO1xufVxuXG4vKipcbiAqIFNldHVwIG5lZWRlZCBldmVudCBsaXN0ZW5lcnMgdXNlZCB0byB1cGRhdGUgdGhlIHBvcHBlciBwb3NpdGlvblxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2V0dXBFdmVudExpc3RlbmVycyhyZWZlcmVuY2UsIG9wdGlvbnMsIHN0YXRlLCB1cGRhdGVCb3VuZCkge1xuICAvLyBSZXNpemUgZXZlbnQgbGlzdGVuZXIgb24gd2luZG93XG4gIHN0YXRlLnVwZGF0ZUJvdW5kID0gdXBkYXRlQm91bmQ7XG4gIGdldFdpbmRvdyhyZWZlcmVuY2UpLmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHN0YXRlLnVwZGF0ZUJvdW5kLCB7IHBhc3NpdmU6IHRydWUgfSk7XG5cbiAgLy8gU2Nyb2xsIGV2ZW50IGxpc3RlbmVyIG9uIHNjcm9sbCBwYXJlbnRzXG4gIHZhciBzY3JvbGxFbGVtZW50ID0gZ2V0U2Nyb2xsUGFyZW50KHJlZmVyZW5jZSk7XG4gIGF0dGFjaFRvU2Nyb2xsUGFyZW50cyhzY3JvbGxFbGVtZW50LCAnc2Nyb2xsJywgc3RhdGUudXBkYXRlQm91bmQsIHN0YXRlLnNjcm9sbFBhcmVudHMpO1xuICBzdGF0ZS5zY3JvbGxFbGVtZW50ID0gc2Nyb2xsRWxlbWVudDtcbiAgc3RhdGUuZXZlbnRzRW5hYmxlZCA9IHRydWU7XG5cbiAgcmV0dXJuIHN0YXRlO1xufVxuXG4vKipcbiAqIEl0IHdpbGwgYWRkIHJlc2l6ZS9zY3JvbGwgZXZlbnRzIGFuZCBzdGFydCByZWNhbGN1bGF0aW5nXG4gKiBwb3NpdGlvbiBvZiB0aGUgcG9wcGVyIGVsZW1lbnQgd2hlbiB0aGV5IGFyZSB0cmlnZ2VyZWQuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbmZ1bmN0aW9uIGVuYWJsZUV2ZW50TGlzdGVuZXJzKCkge1xuICBpZiAoIXRoaXMuc3RhdGUuZXZlbnRzRW5hYmxlZCkge1xuICAgIHRoaXMuc3RhdGUgPSBzZXR1cEV2ZW50TGlzdGVuZXJzKHRoaXMucmVmZXJlbmNlLCB0aGlzLm9wdGlvbnMsIHRoaXMuc3RhdGUsIHRoaXMuc2NoZWR1bGVVcGRhdGUpO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGV2ZW50IGxpc3RlbmVycyB1c2VkIHRvIHVwZGF0ZSB0aGUgcG9wcGVyIHBvc2l0aW9uXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVycyhyZWZlcmVuY2UsIHN0YXRlKSB7XG4gIC8vIFJlbW92ZSByZXNpemUgZXZlbnQgbGlzdGVuZXIgb24gd2luZG93XG4gIGdldFdpbmRvdyhyZWZlcmVuY2UpLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHN0YXRlLnVwZGF0ZUJvdW5kKTtcblxuICAvLyBSZW1vdmUgc2Nyb2xsIGV2ZW50IGxpc3RlbmVyIG9uIHNjcm9sbCBwYXJlbnRzXG4gIHN0YXRlLnNjcm9sbFBhcmVudHMuZm9yRWFjaChmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHN0YXRlLnVwZGF0ZUJvdW5kKTtcbiAgfSk7XG5cbiAgLy8gUmVzZXQgc3RhdGVcbiAgc3RhdGUudXBkYXRlQm91bmQgPSBudWxsO1xuICBzdGF0ZS5zY3JvbGxQYXJlbnRzID0gW107XG4gIHN0YXRlLnNjcm9sbEVsZW1lbnQgPSBudWxsO1xuICBzdGF0ZS5ldmVudHNFbmFibGVkID0gZmFsc2U7XG4gIHJldHVybiBzdGF0ZTtcbn1cblxuLyoqXG4gKiBJdCB3aWxsIHJlbW92ZSByZXNpemUvc2Nyb2xsIGV2ZW50cyBhbmQgd29uJ3QgcmVjYWxjdWxhdGUgcG9wcGVyIHBvc2l0aW9uXG4gKiB3aGVuIHRoZXkgYXJlIHRyaWdnZXJlZC4gSXQgYWxzbyB3b24ndCB0cmlnZ2VyIG9uVXBkYXRlIGNhbGxiYWNrIGFueW1vcmUsXG4gKiB1bmxlc3MgeW91IGNhbGwgYHVwZGF0ZWAgbWV0aG9kIG1hbnVhbGx5LlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG5mdW5jdGlvbiBkaXNhYmxlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gIGlmICh0aGlzLnN0YXRlLmV2ZW50c0VuYWJsZWQpIHtcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnNjaGVkdWxlVXBkYXRlKTtcbiAgICB0aGlzLnN0YXRlID0gcmVtb3ZlRXZlbnRMaXN0ZW5lcnModGhpcy5yZWZlcmVuY2UsIHRoaXMuc3RhdGUpO1xuICB9XG59XG5cbi8qKlxuICogVGVsbHMgaWYgYSBnaXZlbiBpbnB1dCBpcyBhIG51bWJlclxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHsqfSBpbnB1dCB0byBjaGVja1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNOdW1lcmljKG4pIHtcbiAgcmV0dXJuIG4gIT09ICcnICYmICFpc05hTihwYXJzZUZsb2F0KG4pKSAmJiBpc0Zpbml0ZShuKTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIHN0eWxlIHRvIHRoZSBnaXZlbiBwb3BwZXJcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudCAtIEVsZW1lbnQgdG8gYXBwbHkgdGhlIHN0eWxlIHRvXG4gKiBAYXJndW1lbnQge09iamVjdH0gc3R5bGVzXG4gKiBPYmplY3Qgd2l0aCBhIGxpc3Qgb2YgcHJvcGVydGllcyBhbmQgdmFsdWVzIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgZWxlbWVudFxuICovXG5mdW5jdGlvbiBzZXRTdHlsZXMoZWxlbWVudCwgc3R5bGVzKSB7XG4gIE9iamVjdC5rZXlzKHN0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgIHZhciB1bml0ID0gJyc7XG4gICAgLy8gYWRkIHVuaXQgaWYgdGhlIHZhbHVlIGlzIG51bWVyaWMgYW5kIGlzIG9uZSBvZiB0aGUgZm9sbG93aW5nXG4gICAgaWYgKFsnd2lkdGgnLCAnaGVpZ2h0JywgJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddLmluZGV4T2YocHJvcCkgIT09IC0xICYmIGlzTnVtZXJpYyhzdHlsZXNbcHJvcF0pKSB7XG4gICAgICB1bml0ID0gJ3B4JztcbiAgICB9XG4gICAgZWxlbWVudC5zdHlsZVtwcm9wXSA9IHN0eWxlc1twcm9wXSArIHVuaXQ7XG4gIH0pO1xufVxuXG4vKipcbiAqIFNldCB0aGUgYXR0cmlidXRlcyB0byB0aGUgZ2l2ZW4gcG9wcGVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnQgLSBFbGVtZW50IHRvIGFwcGx5IHRoZSBhdHRyaWJ1dGVzIHRvXG4gKiBAYXJndW1lbnQge09iamVjdH0gc3R5bGVzXG4gKiBPYmplY3Qgd2l0aCBhIGxpc3Qgb2YgcHJvcGVydGllcyBhbmQgdmFsdWVzIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgZWxlbWVudFxuICovXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGVzKGVsZW1lbnQsIGF0dHJpYnV0ZXMpIHtcbiAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgIHZhciB2YWx1ZSA9IGF0dHJpYnV0ZXNbcHJvcF07XG4gICAgaWYgKHZhbHVlICE9PSBmYWxzZSkge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUocHJvcCwgYXR0cmlidXRlc1twcm9wXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKHByb3ApO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YS5zdHlsZXMgLSBMaXN0IG9mIHN0eWxlIHByb3BlcnRpZXMgLSB2YWx1ZXMgdG8gYXBwbHkgdG8gcG9wcGVyIGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhLmF0dHJpYnV0ZXMgLSBMaXN0IG9mIGF0dHJpYnV0ZSBwcm9wZXJ0aWVzIC0gdmFsdWVzIHRvIGFwcGx5IHRvIHBvcHBlciBlbGVtZW50XG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgc2FtZSBkYXRhIG9iamVjdFxuICovXG5mdW5jdGlvbiBhcHBseVN0eWxlKGRhdGEpIHtcbiAgLy8gYW55IHByb3BlcnR5IHByZXNlbnQgaW4gYGRhdGEuc3R5bGVzYCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlcixcbiAgLy8gaW4gdGhpcyB3YXkgd2UgY2FuIG1ha2UgdGhlIDNyZCBwYXJ0eSBtb2RpZmllcnMgYWRkIGN1c3RvbSBzdHlsZXMgdG8gaXRcbiAgLy8gQmUgYXdhcmUsIG1vZGlmaWVycyBjb3VsZCBvdmVycmlkZSB0aGUgcHJvcGVydGllcyBkZWZpbmVkIGluIHRoZSBwcmV2aW91c1xuICAvLyBsaW5lcyBvZiB0aGlzIG1vZGlmaWVyIVxuICBzZXRTdHlsZXMoZGF0YS5pbnN0YW5jZS5wb3BwZXIsIGRhdGEuc3R5bGVzKTtcblxuICAvLyBhbnkgcHJvcGVydHkgcHJlc2VudCBpbiBgZGF0YS5hdHRyaWJ1dGVzYCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlcixcbiAgLy8gdGhleSB3aWxsIGJlIHNldCBhcyBIVE1MIGF0dHJpYnV0ZXMgb2YgdGhlIGVsZW1lbnRcbiAgc2V0QXR0cmlidXRlcyhkYXRhLmluc3RhbmNlLnBvcHBlciwgZGF0YS5hdHRyaWJ1dGVzKTtcblxuICAvLyBpZiBhcnJvd0VsZW1lbnQgaXMgZGVmaW5lZCBhbmQgYXJyb3dTdHlsZXMgaGFzIHNvbWUgcHJvcGVydGllc1xuICBpZiAoZGF0YS5hcnJvd0VsZW1lbnQgJiYgT2JqZWN0LmtleXMoZGF0YS5hcnJvd1N0eWxlcykubGVuZ3RoKSB7XG4gICAgc2V0U3R5bGVzKGRhdGEuYXJyb3dFbGVtZW50LCBkYXRhLmFycm93U3R5bGVzKTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIFNldCB0aGUgeC1wbGFjZW1lbnQgYXR0cmlidXRlIGJlZm9yZSBldmVyeXRoaW5nIGVsc2UgYmVjYXVzZSBpdCBjb3VsZCBiZSB1c2VkXG4gKiB0byBhZGQgbWFyZ2lucyB0byB0aGUgcG9wcGVyIG1hcmdpbnMgbmVlZHMgdG8gYmUgY2FsY3VsYXRlZCB0byBnZXQgdGhlXG4gKiBjb3JyZWN0IHBvcHBlciBvZmZzZXRzLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5tb2RpZmllcnNcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHJlZmVyZW5jZSAtIFRoZSByZWZlcmVuY2UgZWxlbWVudCB1c2VkIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBvcHBlciAtIFRoZSBIVE1MIGVsZW1lbnQgdXNlZCBhcyBwb3BwZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gUG9wcGVyLmpzIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gYXBwbHlTdHlsZU9uTG9hZChyZWZlcmVuY2UsIHBvcHBlciwgb3B0aW9ucywgbW9kaWZpZXJPcHRpb25zLCBzdGF0ZSkge1xuICAvLyBjb21wdXRlIHJlZmVyZW5jZSBlbGVtZW50IG9mZnNldHNcbiAgdmFyIHJlZmVyZW5jZU9mZnNldHMgPSBnZXRSZWZlcmVuY2VPZmZzZXRzKHN0YXRlLCBwb3BwZXIsIHJlZmVyZW5jZSwgb3B0aW9ucy5wb3NpdGlvbkZpeGVkKTtcblxuICAvLyBjb21wdXRlIGF1dG8gcGxhY2VtZW50LCBzdG9yZSBwbGFjZW1lbnQgaW5zaWRlIHRoZSBkYXRhIG9iamVjdCxcbiAgLy8gbW9kaWZpZXJzIHdpbGwgYmUgYWJsZSB0byBlZGl0IGBwbGFjZW1lbnRgIGlmIG5lZWRlZFxuICAvLyBhbmQgcmVmZXIgdG8gb3JpZ2luYWxQbGFjZW1lbnQgdG8ga25vdyB0aGUgb3JpZ2luYWwgdmFsdWVcbiAgdmFyIHBsYWNlbWVudCA9IGNvbXB1dGVBdXRvUGxhY2VtZW50KG9wdGlvbnMucGxhY2VtZW50LCByZWZlcmVuY2VPZmZzZXRzLCBwb3BwZXIsIHJlZmVyZW5jZSwgb3B0aW9ucy5tb2RpZmllcnMuZmxpcC5ib3VuZGFyaWVzRWxlbWVudCwgb3B0aW9ucy5tb2RpZmllcnMuZmxpcC5wYWRkaW5nKTtcblxuICBwb3BwZXIuc2V0QXR0cmlidXRlKCd4LXBsYWNlbWVudCcsIHBsYWNlbWVudCk7XG5cbiAgLy8gQXBwbHkgYHBvc2l0aW9uYCB0byBwb3BwZXIgYmVmb3JlIGFueXRoaW5nIGVsc2UgYmVjYXVzZVxuICAvLyB3aXRob3V0IHRoZSBwb3NpdGlvbiBhcHBsaWVkIHdlIGNhbid0IGd1YXJhbnRlZSBjb3JyZWN0IGNvbXB1dGF0aW9uc1xuICBzZXRTdHlsZXMocG9wcGVyLCB7IHBvc2l0aW9uOiBvcHRpb25zLnBvc2l0aW9uRml4ZWQgPyAnZml4ZWQnIDogJ2Fic29sdXRlJyB9KTtcblxuICByZXR1cm4gb3B0aW9ucztcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZVN0eWxlKGRhdGEsIG9wdGlvbnMpIHtcbiAgdmFyIHggPSBvcHRpb25zLngsXG4gICAgICB5ID0gb3B0aW9ucy55O1xuICB2YXIgcG9wcGVyID0gZGF0YS5vZmZzZXRzLnBvcHBlcjtcblxuICAvLyBSZW1vdmUgdGhpcyBsZWdhY3kgc3VwcG9ydCBpbiBQb3BwZXIuanMgdjJcblxuICB2YXIgbGVnYWN5R3B1QWNjZWxlcmF0aW9uT3B0aW9uID0gZmluZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgcmV0dXJuIG1vZGlmaWVyLm5hbWUgPT09ICdhcHBseVN0eWxlJztcbiAgfSkuZ3B1QWNjZWxlcmF0aW9uO1xuICBpZiAobGVnYWN5R3B1QWNjZWxlcmF0aW9uT3B0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zb2xlLndhcm4oJ1dBUk5JTkc6IGBncHVBY2NlbGVyYXRpb25gIG9wdGlvbiBtb3ZlZCB0byBgY29tcHV0ZVN0eWxlYCBtb2RpZmllciBhbmQgd2lsbCBub3QgYmUgc3VwcG9ydGVkIGluIGZ1dHVyZSB2ZXJzaW9ucyBvZiBQb3BwZXIuanMhJyk7XG4gIH1cbiAgdmFyIGdwdUFjY2VsZXJhdGlvbiA9IGxlZ2FjeUdwdUFjY2VsZXJhdGlvbk9wdGlvbiAhPT0gdW5kZWZpbmVkID8gbGVnYWN5R3B1QWNjZWxlcmF0aW9uT3B0aW9uIDogb3B0aW9ucy5ncHVBY2NlbGVyYXRpb247XG5cbiAgdmFyIG9mZnNldFBhcmVudCA9IGdldE9mZnNldFBhcmVudChkYXRhLmluc3RhbmNlLnBvcHBlcik7XG4gIHZhciBvZmZzZXRQYXJlbnRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KG9mZnNldFBhcmVudCk7XG5cbiAgLy8gU3R5bGVzXG4gIHZhciBzdHlsZXMgPSB7XG4gICAgcG9zaXRpb246IHBvcHBlci5wb3NpdGlvblxuICB9O1xuXG4gIC8vIEF2b2lkIGJsdXJyeSB0ZXh0IGJ5IHVzaW5nIGZ1bGwgcGl4ZWwgaW50ZWdlcnMuXG4gIC8vIEZvciBwaXhlbC1wZXJmZWN0IHBvc2l0aW9uaW5nLCB0b3AvYm90dG9tIHByZWZlcnMgcm91bmRlZFxuICAvLyB2YWx1ZXMsIHdoaWxlIGxlZnQvcmlnaHQgcHJlZmVycyBmbG9vcmVkIHZhbHVlcy5cbiAgdmFyIG9mZnNldHMgPSB7XG4gICAgbGVmdDogTWF0aC5mbG9vcihwb3BwZXIubGVmdCksXG4gICAgdG9wOiBNYXRoLnJvdW5kKHBvcHBlci50b3ApLFxuICAgIGJvdHRvbTogTWF0aC5yb3VuZChwb3BwZXIuYm90dG9tKSxcbiAgICByaWdodDogTWF0aC5mbG9vcihwb3BwZXIucmlnaHQpXG4gIH07XG5cbiAgdmFyIHNpZGVBID0geCA9PT0gJ2JvdHRvbScgPyAndG9wJyA6ICdib3R0b20nO1xuICB2YXIgc2lkZUIgPSB5ID09PSAncmlnaHQnID8gJ2xlZnQnIDogJ3JpZ2h0JztcblxuICAvLyBpZiBncHVBY2NlbGVyYXRpb24gaXMgc2V0IHRvIGB0cnVlYCBhbmQgdHJhbnNmb3JtIGlzIHN1cHBvcnRlZCxcbiAgLy8gIHdlIHVzZSBgdHJhbnNsYXRlM2RgIHRvIGFwcGx5IHRoZSBwb3NpdGlvbiB0byB0aGUgcG9wcGVyIHdlXG4gIC8vIGF1dG9tYXRpY2FsbHkgdXNlIHRoZSBzdXBwb3J0ZWQgcHJlZml4ZWQgdmVyc2lvbiBpZiBuZWVkZWRcbiAgdmFyIHByZWZpeGVkUHJvcGVydHkgPSBnZXRTdXBwb3J0ZWRQcm9wZXJ0eU5hbWUoJ3RyYW5zZm9ybScpO1xuXG4gIC8vIG5vdywgbGV0J3MgbWFrZSBhIHN0ZXAgYmFjayBhbmQgbG9vayBhdCB0aGlzIGNvZGUgY2xvc2VseSAod3RmPylcbiAgLy8gSWYgdGhlIGNvbnRlbnQgb2YgdGhlIHBvcHBlciBncm93cyBvbmNlIGl0J3MgYmVlbiBwb3NpdGlvbmVkLCBpdFxuICAvLyBtYXkgaGFwcGVuIHRoYXQgdGhlIHBvcHBlciBnZXRzIG1pc3BsYWNlZCBiZWNhdXNlIG9mIHRoZSBuZXcgY29udGVudFxuICAvLyBvdmVyZmxvd2luZyBpdHMgcmVmZXJlbmNlIGVsZW1lbnRcbiAgLy8gVG8gYXZvaWQgdGhpcyBwcm9ibGVtLCB3ZSBwcm92aWRlIHR3byBvcHRpb25zICh4IGFuZCB5KSwgd2hpY2ggYWxsb3dcbiAgLy8gdGhlIGNvbnN1bWVyIHRvIGRlZmluZSB0aGUgb2Zmc2V0IG9yaWdpbi5cbiAgLy8gSWYgd2UgcG9zaXRpb24gYSBwb3BwZXIgb24gdG9wIG9mIGEgcmVmZXJlbmNlIGVsZW1lbnQsIHdlIGNhbiBzZXRcbiAgLy8gYHhgIHRvIGB0b3BgIHRvIG1ha2UgdGhlIHBvcHBlciBncm93IHRvd2FyZHMgaXRzIHRvcCBpbnN0ZWFkIG9mXG4gIC8vIGl0cyBib3R0b20uXG4gIHZhciBsZWZ0ID0gdm9pZCAwLFxuICAgICAgdG9wID0gdm9pZCAwO1xuICBpZiAoc2lkZUEgPT09ICdib3R0b20nKSB7XG4gICAgdG9wID0gLW9mZnNldFBhcmVudFJlY3QuaGVpZ2h0ICsgb2Zmc2V0cy5ib3R0b207XG4gIH0gZWxzZSB7XG4gICAgdG9wID0gb2Zmc2V0cy50b3A7XG4gIH1cbiAgaWYgKHNpZGVCID09PSAncmlnaHQnKSB7XG4gICAgbGVmdCA9IC1vZmZzZXRQYXJlbnRSZWN0LndpZHRoICsgb2Zmc2V0cy5yaWdodDtcbiAgfSBlbHNlIHtcbiAgICBsZWZ0ID0gb2Zmc2V0cy5sZWZ0O1xuICB9XG4gIGlmIChncHVBY2NlbGVyYXRpb24gJiYgcHJlZml4ZWRQcm9wZXJ0eSkge1xuICAgIHN0eWxlc1twcmVmaXhlZFByb3BlcnR5XSA9ICd0cmFuc2xhdGUzZCgnICsgbGVmdCArICdweCwgJyArIHRvcCArICdweCwgMCknO1xuICAgIHN0eWxlc1tzaWRlQV0gPSAwO1xuICAgIHN0eWxlc1tzaWRlQl0gPSAwO1xuICAgIHN0eWxlcy53aWxsQ2hhbmdlID0gJ3RyYW5zZm9ybSc7XG4gIH0gZWxzZSB7XG4gICAgLy8gb3Rod2VyaXNlLCB3ZSB1c2UgdGhlIHN0YW5kYXJkIGB0b3BgLCBgbGVmdGAsIGBib3R0b21gIGFuZCBgcmlnaHRgIHByb3BlcnRpZXNcbiAgICB2YXIgaW52ZXJ0VG9wID0gc2lkZUEgPT09ICdib3R0b20nID8gLTEgOiAxO1xuICAgIHZhciBpbnZlcnRMZWZ0ID0gc2lkZUIgPT09ICdyaWdodCcgPyAtMSA6IDE7XG4gICAgc3R5bGVzW3NpZGVBXSA9IHRvcCAqIGludmVydFRvcDtcbiAgICBzdHlsZXNbc2lkZUJdID0gbGVmdCAqIGludmVydExlZnQ7XG4gICAgc3R5bGVzLndpbGxDaGFuZ2UgPSBzaWRlQSArICcsICcgKyBzaWRlQjtcbiAgfVxuXG4gIC8vIEF0dHJpYnV0ZXNcbiAgdmFyIGF0dHJpYnV0ZXMgPSB7XG4gICAgJ3gtcGxhY2VtZW50JzogZGF0YS5wbGFjZW1lbnRcbiAgfTtcblxuICAvLyBVcGRhdGUgYGRhdGFgIGF0dHJpYnV0ZXMsIHN0eWxlcyBhbmQgYXJyb3dTdHlsZXNcbiAgZGF0YS5hdHRyaWJ1dGVzID0gX2V4dGVuZHMoe30sIGF0dHJpYnV0ZXMsIGRhdGEuYXR0cmlidXRlcyk7XG4gIGRhdGEuc3R5bGVzID0gX2V4dGVuZHMoe30sIHN0eWxlcywgZGF0YS5zdHlsZXMpO1xuICBkYXRhLmFycm93U3R5bGVzID0gX2V4dGVuZHMoe30sIGRhdGEub2Zmc2V0cy5hcnJvdywgZGF0YS5hcnJvd1N0eWxlcyk7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogSGVscGVyIHVzZWQgdG8ga25vdyBpZiB0aGUgZ2l2ZW4gbW9kaWZpZXIgZGVwZW5kcyBmcm9tIGFub3RoZXIgb25lLjxiciAvPlxuICogSXQgY2hlY2tzIGlmIHRoZSBuZWVkZWQgbW9kaWZpZXIgaXMgbGlzdGVkIGFuZCBlbmFibGVkLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtBcnJheX0gbW9kaWZpZXJzIC0gbGlzdCBvZiBtb2RpZmllcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0aW5nTmFtZSAtIG5hbWUgb2YgcmVxdWVzdGluZyBtb2RpZmllclxuICogQHBhcmFtIHtTdHJpbmd9IHJlcXVlc3RlZE5hbWUgLSBuYW1lIG9mIHJlcXVlc3RlZCBtb2RpZmllclxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzTW9kaWZpZXJSZXF1aXJlZChtb2RpZmllcnMsIHJlcXVlc3RpbmdOYW1lLCByZXF1ZXN0ZWROYW1lKSB7XG4gIHZhciByZXF1ZXN0aW5nID0gZmluZChtb2RpZmllcnMsIGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmLm5hbWU7XG4gICAgcmV0dXJuIG5hbWUgPT09IHJlcXVlc3RpbmdOYW1lO1xuICB9KTtcblxuICB2YXIgaXNSZXF1aXJlZCA9ICEhcmVxdWVzdGluZyAmJiBtb2RpZmllcnMuc29tZShmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICByZXR1cm4gbW9kaWZpZXIubmFtZSA9PT0gcmVxdWVzdGVkTmFtZSAmJiBtb2RpZmllci5lbmFibGVkICYmIG1vZGlmaWVyLm9yZGVyIDwgcmVxdWVzdGluZy5vcmRlcjtcbiAgfSk7XG5cbiAgaWYgKCFpc1JlcXVpcmVkKSB7XG4gICAgdmFyIF9yZXF1ZXN0aW5nID0gJ2AnICsgcmVxdWVzdGluZ05hbWUgKyAnYCc7XG4gICAgdmFyIHJlcXVlc3RlZCA9ICdgJyArIHJlcXVlc3RlZE5hbWUgKyAnYCc7XG4gICAgY29uc29sZS53YXJuKHJlcXVlc3RlZCArICcgbW9kaWZpZXIgaXMgcmVxdWlyZWQgYnkgJyArIF9yZXF1ZXN0aW5nICsgJyBtb2RpZmllciBpbiBvcmRlciB0byB3b3JrLCBiZSBzdXJlIHRvIGluY2x1ZGUgaXQgYmVmb3JlICcgKyBfcmVxdWVzdGluZyArICchJyk7XG4gIH1cbiAgcmV0dXJuIGlzUmVxdWlyZWQ7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBhcnJvdyhkYXRhLCBvcHRpb25zKSB7XG4gIHZhciBfZGF0YSRvZmZzZXRzJGFycm93O1xuXG4gIC8vIGFycm93IGRlcGVuZHMgb24ga2VlcFRvZ2V0aGVyIGluIG9yZGVyIHRvIHdvcmtcbiAgaWYgKCFpc01vZGlmaWVyUmVxdWlyZWQoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsICdhcnJvdycsICdrZWVwVG9nZXRoZXInKSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgdmFyIGFycm93RWxlbWVudCA9IG9wdGlvbnMuZWxlbWVudDtcblxuICAvLyBpZiBhcnJvd0VsZW1lbnQgaXMgYSBzdHJpbmcsIHN1cHBvc2UgaXQncyBhIENTUyBzZWxlY3RvclxuICBpZiAodHlwZW9mIGFycm93RWxlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICBhcnJvd0VsZW1lbnQgPSBkYXRhLmluc3RhbmNlLnBvcHBlci5xdWVyeVNlbGVjdG9yKGFycm93RWxlbWVudCk7XG5cbiAgICAvLyBpZiBhcnJvd0VsZW1lbnQgaXMgbm90IGZvdW5kLCBkb24ndCBydW4gdGhlIG1vZGlmaWVyXG4gICAgaWYgKCFhcnJvd0VsZW1lbnQpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBpZiB0aGUgYXJyb3dFbGVtZW50IGlzbid0IGEgcXVlcnkgc2VsZWN0b3Igd2UgbXVzdCBjaGVjayB0aGF0IHRoZVxuICAgIC8vIHByb3ZpZGVkIERPTSBub2RlIGlzIGNoaWxkIG9mIGl0cyBwb3BwZXIgbm9kZVxuICAgIGlmICghZGF0YS5pbnN0YW5jZS5wb3BwZXIuY29udGFpbnMoYXJyb3dFbGVtZW50KSkge1xuICAgICAgY29uc29sZS53YXJuKCdXQVJOSU5HOiBgYXJyb3cuZWxlbWVudGAgbXVzdCBiZSBjaGlsZCBvZiBpdHMgcG9wcGVyIGVsZW1lbnQhJyk7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gIH1cblxuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgdmFyIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlO1xuXG4gIHZhciBpc1ZlcnRpY2FsID0gWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMTtcblxuICB2YXIgbGVuID0gaXNWZXJ0aWNhbCA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgdmFyIHNpZGVDYXBpdGFsaXplZCA9IGlzVmVydGljYWwgPyAnVG9wJyA6ICdMZWZ0JztcbiAgdmFyIHNpZGUgPSBzaWRlQ2FwaXRhbGl6ZWQudG9Mb3dlckNhc2UoKTtcbiAgdmFyIGFsdFNpZGUgPSBpc1ZlcnRpY2FsID8gJ2xlZnQnIDogJ3RvcCc7XG4gIHZhciBvcFNpZGUgPSBpc1ZlcnRpY2FsID8gJ2JvdHRvbScgOiAncmlnaHQnO1xuICB2YXIgYXJyb3dFbGVtZW50U2l6ZSA9IGdldE91dGVyU2l6ZXMoYXJyb3dFbGVtZW50KVtsZW5dO1xuXG4gIC8vXG4gIC8vIGV4dGVuZHMga2VlcFRvZ2V0aGVyIGJlaGF2aW9yIG1ha2luZyBzdXJlIHRoZSBwb3BwZXIgYW5kIGl0c1xuICAvLyByZWZlcmVuY2UgaGF2ZSBlbm91Z2ggcGl4ZWxzIGluIGNvbmp1Y3Rpb25cbiAgLy9cblxuICAvLyB0b3AvbGVmdCBzaWRlXG4gIGlmIChyZWZlcmVuY2Vbb3BTaWRlXSAtIGFycm93RWxlbWVudFNpemUgPCBwb3BwZXJbc2lkZV0pIHtcbiAgICBkYXRhLm9mZnNldHMucG9wcGVyW3NpZGVdIC09IHBvcHBlcltzaWRlXSAtIChyZWZlcmVuY2Vbb3BTaWRlXSAtIGFycm93RWxlbWVudFNpemUpO1xuICB9XG4gIC8vIGJvdHRvbS9yaWdodCBzaWRlXG4gIGlmIChyZWZlcmVuY2Vbc2lkZV0gKyBhcnJvd0VsZW1lbnRTaXplID4gcG9wcGVyW29wU2lkZV0pIHtcbiAgICBkYXRhLm9mZnNldHMucG9wcGVyW3NpZGVdICs9IHJlZmVyZW5jZVtzaWRlXSArIGFycm93RWxlbWVudFNpemUgLSBwb3BwZXJbb3BTaWRlXTtcbiAgfVxuICBkYXRhLm9mZnNldHMucG9wcGVyID0gZ2V0Q2xpZW50UmVjdChkYXRhLm9mZnNldHMucG9wcGVyKTtcblxuICAvLyBjb21wdXRlIGNlbnRlciBvZiB0aGUgcG9wcGVyXG4gIHZhciBjZW50ZXIgPSByZWZlcmVuY2Vbc2lkZV0gKyByZWZlcmVuY2VbbGVuXSAvIDIgLSBhcnJvd0VsZW1lbnRTaXplIC8gMjtcblxuICAvLyBDb21wdXRlIHRoZSBzaWRlVmFsdWUgdXNpbmcgdGhlIHVwZGF0ZWQgcG9wcGVyIG9mZnNldHNcbiAgLy8gdGFrZSBwb3BwZXIgbWFyZ2luIGluIGFjY291bnQgYmVjYXVzZSB3ZSBkb24ndCBoYXZlIHRoaXMgaW5mbyBhdmFpbGFibGVcbiAgdmFyIGNzcyA9IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShkYXRhLmluc3RhbmNlLnBvcHBlcik7XG4gIHZhciBwb3BwZXJNYXJnaW5TaWRlID0gcGFyc2VGbG9hdChjc3NbJ21hcmdpbicgKyBzaWRlQ2FwaXRhbGl6ZWRdLCAxMCk7XG4gIHZhciBwb3BwZXJCb3JkZXJTaWRlID0gcGFyc2VGbG9hdChjc3NbJ2JvcmRlcicgKyBzaWRlQ2FwaXRhbGl6ZWQgKyAnV2lkdGgnXSwgMTApO1xuICB2YXIgc2lkZVZhbHVlID0gY2VudGVyIC0gZGF0YS5vZmZzZXRzLnBvcHBlcltzaWRlXSAtIHBvcHBlck1hcmdpblNpZGUgLSBwb3BwZXJCb3JkZXJTaWRlO1xuXG4gIC8vIHByZXZlbnQgYXJyb3dFbGVtZW50IGZyb20gYmVpbmcgcGxhY2VkIG5vdCBjb250aWd1b3VzbHkgdG8gaXRzIHBvcHBlclxuICBzaWRlVmFsdWUgPSBNYXRoLm1heChNYXRoLm1pbihwb3BwZXJbbGVuXSAtIGFycm93RWxlbWVudFNpemUsIHNpZGVWYWx1ZSksIDApO1xuXG4gIGRhdGEuYXJyb3dFbGVtZW50ID0gYXJyb3dFbGVtZW50O1xuICBkYXRhLm9mZnNldHMuYXJyb3cgPSAoX2RhdGEkb2Zmc2V0cyRhcnJvdyA9IHt9LCBkZWZpbmVQcm9wZXJ0eShfZGF0YSRvZmZzZXRzJGFycm93LCBzaWRlLCBNYXRoLnJvdW5kKHNpZGVWYWx1ZSkpLCBkZWZpbmVQcm9wZXJ0eShfZGF0YSRvZmZzZXRzJGFycm93LCBhbHRTaWRlLCAnJyksIF9kYXRhJG9mZnNldHMkYXJyb3cpO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEdldCB0aGUgb3Bwb3NpdGUgcGxhY2VtZW50IHZhcmlhdGlvbiBvZiB0aGUgZ2l2ZW4gb25lXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gcGxhY2VtZW50IHZhcmlhdGlvblxuICogQHJldHVybnMge1N0cmluZ30gZmxpcHBlZCBwbGFjZW1lbnQgdmFyaWF0aW9uXG4gKi9cbmZ1bmN0aW9uIGdldE9wcG9zaXRlVmFyaWF0aW9uKHZhcmlhdGlvbikge1xuICBpZiAodmFyaWF0aW9uID09PSAnZW5kJykge1xuICAgIHJldHVybiAnc3RhcnQnO1xuICB9IGVsc2UgaWYgKHZhcmlhdGlvbiA9PT0gJ3N0YXJ0Jykge1xuICAgIHJldHVybiAnZW5kJztcbiAgfVxuICByZXR1cm4gdmFyaWF0aW9uO1xufVxuXG4vKipcbiAqIExpc3Qgb2YgYWNjZXB0ZWQgcGxhY2VtZW50cyB0byB1c2UgYXMgdmFsdWVzIG9mIHRoZSBgcGxhY2VtZW50YCBvcHRpb24uPGJyIC8+XG4gKiBWYWxpZCBwbGFjZW1lbnRzIGFyZTpcbiAqIC0gYGF1dG9gXG4gKiAtIGB0b3BgXG4gKiAtIGByaWdodGBcbiAqIC0gYGJvdHRvbWBcbiAqIC0gYGxlZnRgXG4gKlxuICogRWFjaCBwbGFjZW1lbnQgY2FuIGhhdmUgYSB2YXJpYXRpb24gZnJvbSB0aGlzIGxpc3Q6XG4gKiAtIGAtc3RhcnRgXG4gKiAtIGAtZW5kYFxuICpcbiAqIFZhcmlhdGlvbnMgYXJlIGludGVycHJldGVkIGVhc2lseSBpZiB5b3UgdGhpbmsgb2YgdGhlbSBhcyB0aGUgbGVmdCB0byByaWdodFxuICogd3JpdHRlbiBsYW5ndWFnZXMuIEhvcml6b250YWxseSAoYHRvcGAgYW5kIGBib3R0b21gKSwgYHN0YXJ0YCBpcyBsZWZ0IGFuZCBgZW5kYFxuICogaXMgcmlnaHQuPGJyIC8+XG4gKiBWZXJ0aWNhbGx5IChgbGVmdGAgYW5kIGByaWdodGApLCBgc3RhcnRgIGlzIHRvcCBhbmQgYGVuZGAgaXMgYm90dG9tLlxuICpcbiAqIFNvbWUgdmFsaWQgZXhhbXBsZXMgYXJlOlxuICogLSBgdG9wLWVuZGAgKG9uIHRvcCBvZiByZWZlcmVuY2UsIHJpZ2h0IGFsaWduZWQpXG4gKiAtIGByaWdodC1zdGFydGAgKG9uIHJpZ2h0IG9mIHJlZmVyZW5jZSwgdG9wIGFsaWduZWQpXG4gKiAtIGBib3R0b21gIChvbiBib3R0b20sIGNlbnRlcmVkKVxuICogLSBgYXV0by1yaWdodGAgKG9uIHRoZSBzaWRlIHdpdGggbW9yZSBzcGFjZSBhdmFpbGFibGUsIGFsaWdubWVudCBkZXBlbmRzIGJ5IHBsYWNlbWVudClcbiAqXG4gKiBAc3RhdGljXG4gKiBAdHlwZSB7QXJyYXl9XG4gKiBAZW51bSB7U3RyaW5nfVxuICogQHJlYWRvbmx5XG4gKiBAbWV0aG9kIHBsYWNlbWVudHNcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xudmFyIHBsYWNlbWVudHMgPSBbJ2F1dG8tc3RhcnQnLCAnYXV0bycsICdhdXRvLWVuZCcsICd0b3Atc3RhcnQnLCAndG9wJywgJ3RvcC1lbmQnLCAncmlnaHQtc3RhcnQnLCAncmlnaHQnLCAncmlnaHQtZW5kJywgJ2JvdHRvbS1lbmQnLCAnYm90dG9tJywgJ2JvdHRvbS1zdGFydCcsICdsZWZ0LWVuZCcsICdsZWZ0JywgJ2xlZnQtc3RhcnQnXTtcblxuLy8gR2V0IHJpZCBvZiBgYXV0b2AgYGF1dG8tc3RhcnRgIGFuZCBgYXV0by1lbmRgXG52YXIgdmFsaWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cy5zbGljZSgzKTtcblxuLyoqXG4gKiBHaXZlbiBhbiBpbml0aWFsIHBsYWNlbWVudCwgcmV0dXJucyBhbGwgdGhlIHN1YnNlcXVlbnQgcGxhY2VtZW50c1xuICogY2xvY2t3aXNlIChvciBjb3VudGVyLWNsb2Nrd2lzZSkuXG4gKlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IHBsYWNlbWVudCAtIEEgdmFsaWQgcGxhY2VtZW50IChpdCBhY2NlcHRzIHZhcmlhdGlvbnMpXG4gKiBAYXJndW1lbnQge0Jvb2xlYW59IGNvdW50ZXIgLSBTZXQgdG8gdHJ1ZSB0byB3YWxrIHRoZSBwbGFjZW1lbnRzIGNvdW50ZXJjbG9ja3dpc2VcbiAqIEByZXR1cm5zIHtBcnJheX0gcGxhY2VtZW50cyBpbmNsdWRpbmcgdGhlaXIgdmFyaWF0aW9uc1xuICovXG5mdW5jdGlvbiBjbG9ja3dpc2UocGxhY2VtZW50KSB7XG4gIHZhciBjb3VudGVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICB2YXIgaW5kZXggPSB2YWxpZFBsYWNlbWVudHMuaW5kZXhPZihwbGFjZW1lbnQpO1xuICB2YXIgYXJyID0gdmFsaWRQbGFjZW1lbnRzLnNsaWNlKGluZGV4ICsgMSkuY29uY2F0KHZhbGlkUGxhY2VtZW50cy5zbGljZSgwLCBpbmRleCkpO1xuICByZXR1cm4gY291bnRlciA/IGFyci5yZXZlcnNlKCkgOiBhcnI7XG59XG5cbnZhciBCRUhBVklPUlMgPSB7XG4gIEZMSVA6ICdmbGlwJyxcbiAgQ0xPQ0tXSVNFOiAnY2xvY2t3aXNlJyxcbiAgQ09VTlRFUkNMT0NLV0lTRTogJ2NvdW50ZXJjbG9ja3dpc2UnXG59O1xuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gZmxpcChkYXRhLCBvcHRpb25zKSB7XG4gIC8vIGlmIGBpbm5lcmAgbW9kaWZpZXIgaXMgZW5hYmxlZCwgd2UgY2FuJ3QgdXNlIHRoZSBgZmxpcGAgbW9kaWZpZXJcbiAgaWYgKGlzTW9kaWZpZXJFbmFibGVkKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCAnaW5uZXInKSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgaWYgKGRhdGEuZmxpcHBlZCAmJiBkYXRhLnBsYWNlbWVudCA9PT0gZGF0YS5vcmlnaW5hbFBsYWNlbWVudCkge1xuICAgIC8vIHNlZW1zIGxpa2UgZmxpcCBpcyB0cnlpbmcgdG8gbG9vcCwgcHJvYmFibHkgdGhlcmUncyBub3QgZW5vdWdoIHNwYWNlIG9uIGFueSBvZiB0aGUgZmxpcHBhYmxlIHNpZGVzXG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICB2YXIgYm91bmRhcmllcyA9IGdldEJvdW5kYXJpZXMoZGF0YS5pbnN0YW5jZS5wb3BwZXIsIGRhdGEuaW5zdGFuY2UucmVmZXJlbmNlLCBvcHRpb25zLnBhZGRpbmcsIG9wdGlvbnMuYm91bmRhcmllc0VsZW1lbnQsIGRhdGEucG9zaXRpb25GaXhlZCk7XG5cbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIHZhciBwbGFjZW1lbnRPcHBvc2l0ZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIHZhciB2YXJpYXRpb24gPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzFdIHx8ICcnO1xuXG4gIHZhciBmbGlwT3JkZXIgPSBbXTtcblxuICBzd2l0Y2ggKG9wdGlvbnMuYmVoYXZpb3IpIHtcbiAgICBjYXNlIEJFSEFWSU9SUy5GTElQOlxuICAgICAgZmxpcE9yZGVyID0gW3BsYWNlbWVudCwgcGxhY2VtZW50T3Bwb3NpdGVdO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBCRUhBVklPUlMuQ0xPQ0tXSVNFOlxuICAgICAgZmxpcE9yZGVyID0gY2xvY2t3aXNlKHBsYWNlbWVudCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIEJFSEFWSU9SUy5DT1VOVEVSQ0xPQ0tXSVNFOlxuICAgICAgZmxpcE9yZGVyID0gY2xvY2t3aXNlKHBsYWNlbWVudCwgdHJ1ZSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgZmxpcE9yZGVyID0gb3B0aW9ucy5iZWhhdmlvcjtcbiAgfVxuXG4gIGZsaXBPcmRlci5mb3JFYWNoKGZ1bmN0aW9uIChzdGVwLCBpbmRleCkge1xuICAgIGlmIChwbGFjZW1lbnQgIT09IHN0ZXAgfHwgZmxpcE9yZGVyLmxlbmd0aCA9PT0gaW5kZXggKyAxKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICAgIHBsYWNlbWVudE9wcG9zaXRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcblxuICAgIHZhciBwb3BwZXJPZmZzZXRzID0gZGF0YS5vZmZzZXRzLnBvcHBlcjtcbiAgICB2YXIgcmVmT2Zmc2V0cyA9IGRhdGEub2Zmc2V0cy5yZWZlcmVuY2U7XG5cbiAgICAvLyB1c2luZyBmbG9vciBiZWNhdXNlIHRoZSByZWZlcmVuY2Ugb2Zmc2V0cyBtYXkgY29udGFpbiBkZWNpbWFscyB3ZSBhcmUgbm90IGdvaW5nIHRvIGNvbnNpZGVyIGhlcmVcbiAgICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuICAgIHZhciBvdmVybGFwc1JlZiA9IHBsYWNlbWVudCA9PT0gJ2xlZnQnICYmIGZsb29yKHBvcHBlck9mZnNldHMucmlnaHQpID4gZmxvb3IocmVmT2Zmc2V0cy5sZWZ0KSB8fCBwbGFjZW1lbnQgPT09ICdyaWdodCcgJiYgZmxvb3IocG9wcGVyT2Zmc2V0cy5sZWZ0KSA8IGZsb29yKHJlZk9mZnNldHMucmlnaHQpIHx8IHBsYWNlbWVudCA9PT0gJ3RvcCcgJiYgZmxvb3IocG9wcGVyT2Zmc2V0cy5ib3R0b20pID4gZmxvb3IocmVmT2Zmc2V0cy50b3ApIHx8IHBsYWNlbWVudCA9PT0gJ2JvdHRvbScgJiYgZmxvb3IocG9wcGVyT2Zmc2V0cy50b3ApIDwgZmxvb3IocmVmT2Zmc2V0cy5ib3R0b20pO1xuXG4gICAgdmFyIG92ZXJmbG93c0xlZnQgPSBmbG9vcihwb3BwZXJPZmZzZXRzLmxlZnQpIDwgZmxvb3IoYm91bmRhcmllcy5sZWZ0KTtcbiAgICB2YXIgb3ZlcmZsb3dzUmlnaHQgPSBmbG9vcihwb3BwZXJPZmZzZXRzLnJpZ2h0KSA+IGZsb29yKGJvdW5kYXJpZXMucmlnaHQpO1xuICAgIHZhciBvdmVyZmxvd3NUb3AgPSBmbG9vcihwb3BwZXJPZmZzZXRzLnRvcCkgPCBmbG9vcihib3VuZGFyaWVzLnRvcCk7XG4gICAgdmFyIG92ZXJmbG93c0JvdHRvbSA9IGZsb29yKHBvcHBlck9mZnNldHMuYm90dG9tKSA+IGZsb29yKGJvdW5kYXJpZXMuYm90dG9tKTtcblxuICAgIHZhciBvdmVyZmxvd3NCb3VuZGFyaWVzID0gcGxhY2VtZW50ID09PSAnbGVmdCcgJiYgb3ZlcmZsb3dzTGVmdCB8fCBwbGFjZW1lbnQgPT09ICdyaWdodCcgJiYgb3ZlcmZsb3dzUmlnaHQgfHwgcGxhY2VtZW50ID09PSAndG9wJyAmJiBvdmVyZmxvd3NUb3AgfHwgcGxhY2VtZW50ID09PSAnYm90dG9tJyAmJiBvdmVyZmxvd3NCb3R0b207XG5cbiAgICAvLyBmbGlwIHRoZSB2YXJpYXRpb24gaWYgcmVxdWlyZWRcbiAgICB2YXIgaXNWZXJ0aWNhbCA9IFsndG9wJywgJ2JvdHRvbSddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTE7XG4gICAgdmFyIGZsaXBwZWRWYXJpYXRpb24gPSAhIW9wdGlvbnMuZmxpcFZhcmlhdGlvbnMgJiYgKGlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnc3RhcnQnICYmIG92ZXJmbG93c0xlZnQgfHwgaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdlbmQnICYmIG92ZXJmbG93c1JpZ2h0IHx8ICFpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ3N0YXJ0JyAmJiBvdmVyZmxvd3NUb3AgfHwgIWlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnZW5kJyAmJiBvdmVyZmxvd3NCb3R0b20pO1xuXG4gICAgaWYgKG92ZXJsYXBzUmVmIHx8IG92ZXJmbG93c0JvdW5kYXJpZXMgfHwgZmxpcHBlZFZhcmlhdGlvbikge1xuICAgICAgLy8gdGhpcyBib29sZWFuIHRvIGRldGVjdCBhbnkgZmxpcCBsb29wXG4gICAgICBkYXRhLmZsaXBwZWQgPSB0cnVlO1xuXG4gICAgICBpZiAob3ZlcmxhcHNSZWYgfHwgb3ZlcmZsb3dzQm91bmRhcmllcykge1xuICAgICAgICBwbGFjZW1lbnQgPSBmbGlwT3JkZXJbaW5kZXggKyAxXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZsaXBwZWRWYXJpYXRpb24pIHtcbiAgICAgICAgdmFyaWF0aW9uID0gZ2V0T3Bwb3NpdGVWYXJpYXRpb24odmFyaWF0aW9uKTtcbiAgICAgIH1cblxuICAgICAgZGF0YS5wbGFjZW1lbnQgPSBwbGFjZW1lbnQgKyAodmFyaWF0aW9uID8gJy0nICsgdmFyaWF0aW9uIDogJycpO1xuXG4gICAgICAvLyB0aGlzIG9iamVjdCBjb250YWlucyBgcG9zaXRpb25gLCB3ZSB3YW50IHRvIHByZXNlcnZlIGl0IGFsb25nIHdpdGhcbiAgICAgIC8vIGFueSBhZGRpdGlvbmFsIHByb3BlcnR5IHdlIG1heSBhZGQgaW4gdGhlIGZ1dHVyZVxuICAgICAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IF9leHRlbmRzKHt9LCBkYXRhLm9mZnNldHMucG9wcGVyLCBnZXRQb3BwZXJPZmZzZXRzKGRhdGEuaW5zdGFuY2UucG9wcGVyLCBkYXRhLm9mZnNldHMucmVmZXJlbmNlLCBkYXRhLnBsYWNlbWVudCkpO1xuXG4gICAgICBkYXRhID0gcnVuTW9kaWZpZXJzKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCBkYXRhLCAnZmxpcCcpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24ga2VlcFRvZ2V0aGVyKGRhdGEpIHtcbiAgdmFyIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlO1xuXG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuICB2YXIgaXNWZXJ0aWNhbCA9IFsndG9wJywgJ2JvdHRvbSddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTE7XG4gIHZhciBzaWRlID0gaXNWZXJ0aWNhbCA/ICdyaWdodCcgOiAnYm90dG9tJztcbiAgdmFyIG9wU2lkZSA9IGlzVmVydGljYWwgPyAnbGVmdCcgOiAndG9wJztcbiAgdmFyIG1lYXN1cmVtZW50ID0gaXNWZXJ0aWNhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcblxuICBpZiAocG9wcGVyW3NpZGVdIDwgZmxvb3IocmVmZXJlbmNlW29wU2lkZV0pKSB7XG4gICAgZGF0YS5vZmZzZXRzLnBvcHBlcltvcFNpZGVdID0gZmxvb3IocmVmZXJlbmNlW29wU2lkZV0pIC0gcG9wcGVyW21lYXN1cmVtZW50XTtcbiAgfVxuICBpZiAocG9wcGVyW29wU2lkZV0gPiBmbG9vcihyZWZlcmVuY2Vbc2lkZV0pKSB7XG4gICAgZGF0YS5vZmZzZXRzLnBvcHBlcltvcFNpZGVdID0gZmxvb3IocmVmZXJlbmNlW3NpZGVdKTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgc3RyaW5nIGNvbnRhaW5pbmcgdmFsdWUgKyB1bml0IGludG8gYSBweCB2YWx1ZSBudW1iZXJcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIHttb2RpZmllcnN+b2Zmc2V0fVxuICogQHByaXZhdGVcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBzdHIgLSBWYWx1ZSArIHVuaXQgc3RyaW5nXG4gKiBAYXJndW1lbnQge1N0cmluZ30gbWVhc3VyZW1lbnQgLSBgaGVpZ2h0YCBvciBgd2lkdGhgXG4gKiBAYXJndW1lbnQge09iamVjdH0gcG9wcGVyT2Zmc2V0c1xuICogQGFyZ3VtZW50IHtPYmplY3R9IHJlZmVyZW5jZU9mZnNldHNcbiAqIEByZXR1cm5zIHtOdW1iZXJ8U3RyaW5nfVxuICogVmFsdWUgaW4gcGl4ZWxzLCBvciBvcmlnaW5hbCBzdHJpbmcgaWYgbm8gdmFsdWVzIHdlcmUgZXh0cmFjdGVkXG4gKi9cbmZ1bmN0aW9uIHRvVmFsdWUoc3RyLCBtZWFzdXJlbWVudCwgcG9wcGVyT2Zmc2V0cywgcmVmZXJlbmNlT2Zmc2V0cykge1xuICAvLyBzZXBhcmF0ZSB2YWx1ZSBmcm9tIHVuaXRcbiAgdmFyIHNwbGl0ID0gc3RyLm1hdGNoKC8oKD86XFwtfFxcKyk/XFxkKlxcLj9cXGQqKSguKikvKTtcbiAgdmFyIHZhbHVlID0gK3NwbGl0WzFdO1xuICB2YXIgdW5pdCA9IHNwbGl0WzJdO1xuXG4gIC8vIElmIGl0J3Mgbm90IGEgbnVtYmVyIGl0J3MgYW4gb3BlcmF0b3IsIEkgZ3Vlc3NcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICBpZiAodW5pdC5pbmRleE9mKCclJykgPT09IDApIHtcbiAgICB2YXIgZWxlbWVudCA9IHZvaWQgMDtcbiAgICBzd2l0Y2ggKHVuaXQpIHtcbiAgICAgIGNhc2UgJyVwJzpcbiAgICAgICAgZWxlbWVudCA9IHBvcHBlck9mZnNldHM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnJSc6XG4gICAgICBjYXNlICclcic6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBlbGVtZW50ID0gcmVmZXJlbmNlT2Zmc2V0cztcbiAgICB9XG5cbiAgICB2YXIgcmVjdCA9IGdldENsaWVudFJlY3QoZWxlbWVudCk7XG4gICAgcmV0dXJuIHJlY3RbbWVhc3VyZW1lbnRdIC8gMTAwICogdmFsdWU7XG4gIH0gZWxzZSBpZiAodW5pdCA9PT0gJ3ZoJyB8fCB1bml0ID09PSAndncnKSB7XG4gICAgLy8gaWYgaXMgYSB2aCBvciB2dywgd2UgY2FsY3VsYXRlIHRoZSBzaXplIGJhc2VkIG9uIHRoZSB2aWV3cG9ydFxuICAgIHZhciBzaXplID0gdm9pZCAwO1xuICAgIGlmICh1bml0ID09PSAndmgnKSB7XG4gICAgICBzaXplID0gTWF0aC5tYXgoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCwgd2luZG93LmlubmVySGVpZ2h0IHx8IDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaXplID0gTWF0aC5tYXgoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoLCB3aW5kb3cuaW5uZXJXaWR0aCB8fCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIHNpemUgLyAxMDAgKiB2YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBpZiBpcyBhbiBleHBsaWNpdCBwaXhlbCB1bml0LCB3ZSBnZXQgcmlkIG9mIHRoZSB1bml0IGFuZCBrZWVwIHRoZSB2YWx1ZVxuICAgIC8vIGlmIGlzIGFuIGltcGxpY2l0IHVuaXQsIGl0J3MgcHgsIGFuZCB3ZSByZXR1cm4ganVzdCB0aGUgdmFsdWVcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZSBhbiBgb2Zmc2V0YCBzdHJpbmcgdG8gZXh0cmFwb2xhdGUgYHhgIGFuZCBgeWAgbnVtZXJpYyBvZmZzZXRzLlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2Yge21vZGlmaWVyc35vZmZzZXR9XG4gKiBAcHJpdmF0ZVxuICogQGFyZ3VtZW50IHtTdHJpbmd9IG9mZnNldFxuICogQGFyZ3VtZW50IHtPYmplY3R9IHBvcHBlck9mZnNldHNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSByZWZlcmVuY2VPZmZzZXRzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gYmFzZVBsYWNlbWVudFxuICogQHJldHVybnMge0FycmF5fSBhIHR3byBjZWxscyBhcnJheSB3aXRoIHggYW5kIHkgb2Zmc2V0cyBpbiBudW1iZXJzXG4gKi9cbmZ1bmN0aW9uIHBhcnNlT2Zmc2V0KG9mZnNldCwgcG9wcGVyT2Zmc2V0cywgcmVmZXJlbmNlT2Zmc2V0cywgYmFzZVBsYWNlbWVudCkge1xuICB2YXIgb2Zmc2V0cyA9IFswLCAwXTtcblxuICAvLyBVc2UgaGVpZ2h0IGlmIHBsYWNlbWVudCBpcyBsZWZ0IG9yIHJpZ2h0IGFuZCBpbmRleCBpcyAwIG90aGVyd2lzZSB1c2Ugd2lkdGhcbiAgLy8gaW4gdGhpcyB3YXkgdGhlIGZpcnN0IG9mZnNldCB3aWxsIHVzZSBhbiBheGlzIGFuZCB0aGUgc2Vjb25kIG9uZVxuICAvLyB3aWxsIHVzZSB0aGUgb3RoZXIgb25lXG4gIHZhciB1c2VIZWlnaHQgPSBbJ3JpZ2h0JywgJ2xlZnQnXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpICE9PSAtMTtcblxuICAvLyBTcGxpdCB0aGUgb2Zmc2V0IHN0cmluZyB0byBvYnRhaW4gYSBsaXN0IG9mIHZhbHVlcyBhbmQgb3BlcmFuZHNcbiAgLy8gVGhlIHJlZ2V4IGFkZHJlc3NlcyB2YWx1ZXMgd2l0aCB0aGUgcGx1cyBvciBtaW51cyBzaWduIGluIGZyb250ICgrMTAsIC0yMCwgZXRjKVxuICB2YXIgZnJhZ21lbnRzID0gb2Zmc2V0LnNwbGl0KC8oXFwrfFxcLSkvKS5tYXAoZnVuY3Rpb24gKGZyYWcpIHtcbiAgICByZXR1cm4gZnJhZy50cmltKCk7XG4gIH0pO1xuXG4gIC8vIERldGVjdCBpZiB0aGUgb2Zmc2V0IHN0cmluZyBjb250YWlucyBhIHBhaXIgb2YgdmFsdWVzIG9yIGEgc2luZ2xlIG9uZVxuICAvLyB0aGV5IGNvdWxkIGJlIHNlcGFyYXRlZCBieSBjb21tYSBvciBzcGFjZVxuICB2YXIgZGl2aWRlciA9IGZyYWdtZW50cy5pbmRleE9mKGZpbmQoZnJhZ21lbnRzLCBmdW5jdGlvbiAoZnJhZykge1xuICAgIHJldHVybiBmcmFnLnNlYXJjaCgvLHxcXHMvKSAhPT0gLTE7XG4gIH0pKTtcblxuICBpZiAoZnJhZ21lbnRzW2RpdmlkZXJdICYmIGZyYWdtZW50c1tkaXZpZGVyXS5pbmRleE9mKCcsJykgPT09IC0xKSB7XG4gICAgY29uc29sZS53YXJuKCdPZmZzZXRzIHNlcGFyYXRlZCBieSB3aGl0ZSBzcGFjZShzKSBhcmUgZGVwcmVjYXRlZCwgdXNlIGEgY29tbWEgKCwpIGluc3RlYWQuJyk7XG4gIH1cblxuICAvLyBJZiBkaXZpZGVyIGlzIGZvdW5kLCB3ZSBkaXZpZGUgdGhlIGxpc3Qgb2YgdmFsdWVzIGFuZCBvcGVyYW5kcyB0byBkaXZpZGVcbiAgLy8gdGhlbSBieSBvZnNldCBYIGFuZCBZLlxuICB2YXIgc3BsaXRSZWdleCA9IC9cXHMqLFxccyp8XFxzKy87XG4gIHZhciBvcHMgPSBkaXZpZGVyICE9PSAtMSA/IFtmcmFnbWVudHMuc2xpY2UoMCwgZGl2aWRlcikuY29uY2F0KFtmcmFnbWVudHNbZGl2aWRlcl0uc3BsaXQoc3BsaXRSZWdleClbMF1dKSwgW2ZyYWdtZW50c1tkaXZpZGVyXS5zcGxpdChzcGxpdFJlZ2V4KVsxXV0uY29uY2F0KGZyYWdtZW50cy5zbGljZShkaXZpZGVyICsgMSkpXSA6IFtmcmFnbWVudHNdO1xuXG4gIC8vIENvbnZlcnQgdGhlIHZhbHVlcyB3aXRoIHVuaXRzIHRvIGFic29sdXRlIHBpeGVscyB0byBhbGxvdyBvdXIgY29tcHV0YXRpb25zXG4gIG9wcyA9IG9wcy5tYXAoZnVuY3Rpb24gKG9wLCBpbmRleCkge1xuICAgIC8vIE1vc3Qgb2YgdGhlIHVuaXRzIHJlbHkgb24gdGhlIG9yaWVudGF0aW9uIG9mIHRoZSBwb3BwZXJcbiAgICB2YXIgbWVhc3VyZW1lbnQgPSAoaW5kZXggPT09IDEgPyAhdXNlSGVpZ2h0IDogdXNlSGVpZ2h0KSA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgICB2YXIgbWVyZ2VXaXRoUHJldmlvdXMgPSBmYWxzZTtcbiAgICByZXR1cm4gb3BcbiAgICAvLyBUaGlzIGFnZ3JlZ2F0ZXMgYW55IGArYCBvciBgLWAgc2lnbiB0aGF0IGFyZW4ndCBjb25zaWRlcmVkIG9wZXJhdG9yc1xuICAgIC8vIGUuZy46IDEwICsgKzUgPT4gWzEwLCArLCArNV1cbiAgICAucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICBpZiAoYVthLmxlbmd0aCAtIDFdID09PSAnJyAmJiBbJysnLCAnLSddLmluZGV4T2YoYikgIT09IC0xKSB7XG4gICAgICAgIGFbYS5sZW5ndGggLSAxXSA9IGI7XG4gICAgICAgIG1lcmdlV2l0aFByZXZpb3VzID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9IGVsc2UgaWYgKG1lcmdlV2l0aFByZXZpb3VzKSB7XG4gICAgICAgIGFbYS5sZW5ndGggLSAxXSArPSBiO1xuICAgICAgICBtZXJnZVdpdGhQcmV2aW91cyA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBhLmNvbmNhdChiKTtcbiAgICAgIH1cbiAgICB9LCBbXSlcbiAgICAvLyBIZXJlIHdlIGNvbnZlcnQgdGhlIHN0cmluZyB2YWx1ZXMgaW50byBudW1iZXIgdmFsdWVzIChpbiBweClcbiAgICAubWFwKGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgIHJldHVybiB0b1ZhbHVlKHN0ciwgbWVhc3VyZW1lbnQsIHBvcHBlck9mZnNldHMsIHJlZmVyZW5jZU9mZnNldHMpO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBMb29wIHRyb3VnaCB0aGUgb2Zmc2V0cyBhcnJheXMgYW5kIGV4ZWN1dGUgdGhlIG9wZXJhdGlvbnNcbiAgb3BzLmZvckVhY2goZnVuY3Rpb24gKG9wLCBpbmRleCkge1xuICAgIG9wLmZvckVhY2goZnVuY3Rpb24gKGZyYWcsIGluZGV4Mikge1xuICAgICAgaWYgKGlzTnVtZXJpYyhmcmFnKSkge1xuICAgICAgICBvZmZzZXRzW2luZGV4XSArPSBmcmFnICogKG9wW2luZGV4MiAtIDFdID09PSAnLScgPyAtMSA6IDEpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIG9mZnNldHM7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQGFyZ3VtZW50IHtOdW1iZXJ8U3RyaW5nfSBvcHRpb25zLm9mZnNldD0wXG4gKiBUaGUgb2Zmc2V0IHZhbHVlIGFzIGRlc2NyaWJlZCBpbiB0aGUgbW9kaWZpZXIgZGVzY3JpcHRpb25cbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gb2Zmc2V0KGRhdGEsIF9yZWYpIHtcbiAgdmFyIG9mZnNldCA9IF9yZWYub2Zmc2V0O1xuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQsXG4gICAgICBfZGF0YSRvZmZzZXRzID0gZGF0YS5vZmZzZXRzLFxuICAgICAgcG9wcGVyID0gX2RhdGEkb2Zmc2V0cy5wb3BwZXIsXG4gICAgICByZWZlcmVuY2UgPSBfZGF0YSRvZmZzZXRzLnJlZmVyZW5jZTtcblxuICB2YXIgYmFzZVBsYWNlbWVudCA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuXG4gIHZhciBvZmZzZXRzID0gdm9pZCAwO1xuICBpZiAoaXNOdW1lcmljKCtvZmZzZXQpKSB7XG4gICAgb2Zmc2V0cyA9IFsrb2Zmc2V0LCAwXTtcbiAgfSBlbHNlIHtcbiAgICBvZmZzZXRzID0gcGFyc2VPZmZzZXQob2Zmc2V0LCBwb3BwZXIsIHJlZmVyZW5jZSwgYmFzZVBsYWNlbWVudCk7XG4gIH1cblxuICBpZiAoYmFzZVBsYWNlbWVudCA9PT0gJ2xlZnQnKSB7XG4gICAgcG9wcGVyLnRvcCArPSBvZmZzZXRzWzBdO1xuICAgIHBvcHBlci5sZWZ0IC09IG9mZnNldHNbMV07XG4gIH0gZWxzZSBpZiAoYmFzZVBsYWNlbWVudCA9PT0gJ3JpZ2h0Jykge1xuICAgIHBvcHBlci50b3AgKz0gb2Zmc2V0c1swXTtcbiAgICBwb3BwZXIubGVmdCArPSBvZmZzZXRzWzFdO1xuICB9IGVsc2UgaWYgKGJhc2VQbGFjZW1lbnQgPT09ICd0b3AnKSB7XG4gICAgcG9wcGVyLmxlZnQgKz0gb2Zmc2V0c1swXTtcbiAgICBwb3BwZXIudG9wIC09IG9mZnNldHNbMV07XG4gIH0gZWxzZSBpZiAoYmFzZVBsYWNlbWVudCA9PT0gJ2JvdHRvbScpIHtcbiAgICBwb3BwZXIubGVmdCArPSBvZmZzZXRzWzBdO1xuICAgIHBvcHBlci50b3AgKz0gb2Zmc2V0c1sxXTtcbiAgfVxuXG4gIGRhdGEucG9wcGVyID0gcG9wcGVyO1xuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gcHJldmVudE92ZXJmbG93KGRhdGEsIG9wdGlvbnMpIHtcbiAgdmFyIGJvdW5kYXJpZXNFbGVtZW50ID0gb3B0aW9ucy5ib3VuZGFyaWVzRWxlbWVudCB8fCBnZXRPZmZzZXRQYXJlbnQoZGF0YS5pbnN0YW5jZS5wb3BwZXIpO1xuXG4gIC8vIElmIG9mZnNldFBhcmVudCBpcyB0aGUgcmVmZXJlbmNlIGVsZW1lbnQsIHdlIHJlYWxseSB3YW50IHRvXG4gIC8vIGdvIG9uZSBzdGVwIHVwIGFuZCB1c2UgdGhlIG5leHQgb2Zmc2V0UGFyZW50IGFzIHJlZmVyZW5jZSB0b1xuICAvLyBhdm9pZCB0byBtYWtlIHRoaXMgbW9kaWZpZXIgY29tcGxldGVseSB1c2VsZXNzIGFuZCBsb29rIGxpa2UgYnJva2VuXG4gIGlmIChkYXRhLmluc3RhbmNlLnJlZmVyZW5jZSA9PT0gYm91bmRhcmllc0VsZW1lbnQpIHtcbiAgICBib3VuZGFyaWVzRWxlbWVudCA9IGdldE9mZnNldFBhcmVudChib3VuZGFyaWVzRWxlbWVudCk7XG4gIH1cblxuICAvLyBOT1RFOiBET00gYWNjZXNzIGhlcmVcbiAgLy8gcmVzZXRzIHRoZSBwb3BwZXIncyBwb3NpdGlvbiBzbyB0aGF0IHRoZSBkb2N1bWVudCBzaXplIGNhbiBiZSBjYWxjdWxhdGVkIGV4Y2x1ZGluZ1xuICAvLyB0aGUgc2l6ZSBvZiB0aGUgcG9wcGVyIGVsZW1lbnQgaXRzZWxmXG4gIHZhciB0cmFuc2Zvcm1Qcm9wID0gZ2V0U3VwcG9ydGVkUHJvcGVydHlOYW1lKCd0cmFuc2Zvcm0nKTtcbiAgdmFyIHBvcHBlclN0eWxlcyA9IGRhdGEuaW5zdGFuY2UucG9wcGVyLnN0eWxlOyAvLyBhc3NpZ25tZW50IHRvIGhlbHAgbWluaWZpY2F0aW9uXG4gIHZhciB0b3AgPSBwb3BwZXJTdHlsZXMudG9wLFxuICAgICAgbGVmdCA9IHBvcHBlclN0eWxlcy5sZWZ0LFxuICAgICAgdHJhbnNmb3JtID0gcG9wcGVyU3R5bGVzW3RyYW5zZm9ybVByb3BdO1xuXG4gIHBvcHBlclN0eWxlcy50b3AgPSAnJztcbiAgcG9wcGVyU3R5bGVzLmxlZnQgPSAnJztcbiAgcG9wcGVyU3R5bGVzW3RyYW5zZm9ybVByb3BdID0gJyc7XG5cbiAgdmFyIGJvdW5kYXJpZXMgPSBnZXRCb3VuZGFyaWVzKGRhdGEuaW5zdGFuY2UucG9wcGVyLCBkYXRhLmluc3RhbmNlLnJlZmVyZW5jZSwgb3B0aW9ucy5wYWRkaW5nLCBib3VuZGFyaWVzRWxlbWVudCwgZGF0YS5wb3NpdGlvbkZpeGVkKTtcblxuICAvLyBOT1RFOiBET00gYWNjZXNzIGhlcmVcbiAgLy8gcmVzdG9yZXMgdGhlIG9yaWdpbmFsIHN0eWxlIHByb3BlcnRpZXMgYWZ0ZXIgdGhlIG9mZnNldHMgaGF2ZSBiZWVuIGNvbXB1dGVkXG4gIHBvcHBlclN0eWxlcy50b3AgPSB0b3A7XG4gIHBvcHBlclN0eWxlcy5sZWZ0ID0gbGVmdDtcbiAgcG9wcGVyU3R5bGVzW3RyYW5zZm9ybVByb3BdID0gdHJhbnNmb3JtO1xuXG4gIG9wdGlvbnMuYm91bmRhcmllcyA9IGJvdW5kYXJpZXM7XG5cbiAgdmFyIG9yZGVyID0gb3B0aW9ucy5wcmlvcml0eTtcbiAgdmFyIHBvcHBlciA9IGRhdGEub2Zmc2V0cy5wb3BwZXI7XG5cbiAgdmFyIGNoZWNrID0ge1xuICAgIHByaW1hcnk6IGZ1bmN0aW9uIHByaW1hcnkocGxhY2VtZW50KSB7XG4gICAgICB2YXIgdmFsdWUgPSBwb3BwZXJbcGxhY2VtZW50XTtcbiAgICAgIGlmIChwb3BwZXJbcGxhY2VtZW50XSA8IGJvdW5kYXJpZXNbcGxhY2VtZW50XSAmJiAhb3B0aW9ucy5lc2NhcGVXaXRoUmVmZXJlbmNlKSB7XG4gICAgICAgIHZhbHVlID0gTWF0aC5tYXgocG9wcGVyW3BsYWNlbWVudF0sIGJvdW5kYXJpZXNbcGxhY2VtZW50XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVmaW5lUHJvcGVydHkoe30sIHBsYWNlbWVudCwgdmFsdWUpO1xuICAgIH0sXG4gICAgc2Vjb25kYXJ5OiBmdW5jdGlvbiBzZWNvbmRhcnkocGxhY2VtZW50KSB7XG4gICAgICB2YXIgbWFpblNpZGUgPSBwbGFjZW1lbnQgPT09ICdyaWdodCcgPyAnbGVmdCcgOiAndG9wJztcbiAgICAgIHZhciB2YWx1ZSA9IHBvcHBlclttYWluU2lkZV07XG4gICAgICBpZiAocG9wcGVyW3BsYWNlbWVudF0gPiBib3VuZGFyaWVzW3BsYWNlbWVudF0gJiYgIW9wdGlvbnMuZXNjYXBlV2l0aFJlZmVyZW5jZSkge1xuICAgICAgICB2YWx1ZSA9IE1hdGgubWluKHBvcHBlclttYWluU2lkZV0sIGJvdW5kYXJpZXNbcGxhY2VtZW50XSAtIChwbGFjZW1lbnQgPT09ICdyaWdodCcgPyBwb3BwZXIud2lkdGggOiBwb3BwZXIuaGVpZ2h0KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVmaW5lUHJvcGVydHkoe30sIG1haW5TaWRlLCB2YWx1ZSk7XG4gICAgfVxuICB9O1xuXG4gIG9yZGVyLmZvckVhY2goZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgIHZhciBzaWRlID0gWydsZWZ0JywgJ3RvcCddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTEgPyAncHJpbWFyeScgOiAnc2Vjb25kYXJ5JztcbiAgICBwb3BwZXIgPSBfZXh0ZW5kcyh7fSwgcG9wcGVyLCBjaGVja1tzaWRlXShwbGFjZW1lbnQpKTtcbiAgfSk7XG5cbiAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IHBvcHBlcjtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gc2hpZnQoZGF0YSkge1xuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQ7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIHZhciBzaGlmdHZhcmlhdGlvbiA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzFdO1xuXG4gIC8vIGlmIHNoaWZ0IHNoaWZ0dmFyaWF0aW9uIGlzIHNwZWNpZmllZCwgcnVuIHRoZSBtb2RpZmllclxuICBpZiAoc2hpZnR2YXJpYXRpb24pIHtcbiAgICB2YXIgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2UsXG4gICAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyO1xuXG4gICAgdmFyIGlzVmVydGljYWwgPSBbJ2JvdHRvbScsICd0b3AnXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpICE9PSAtMTtcbiAgICB2YXIgc2lkZSA9IGlzVmVydGljYWwgPyAnbGVmdCcgOiAndG9wJztcbiAgICB2YXIgbWVhc3VyZW1lbnQgPSBpc1ZlcnRpY2FsID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuXG4gICAgdmFyIHNoaWZ0T2Zmc2V0cyA9IHtcbiAgICAgIHN0YXJ0OiBkZWZpbmVQcm9wZXJ0eSh7fSwgc2lkZSwgcmVmZXJlbmNlW3NpZGVdKSxcbiAgICAgIGVuZDogZGVmaW5lUHJvcGVydHkoe30sIHNpZGUsIHJlZmVyZW5jZVtzaWRlXSArIHJlZmVyZW5jZVttZWFzdXJlbWVudF0gLSBwb3BwZXJbbWVhc3VyZW1lbnRdKVxuICAgIH07XG5cbiAgICBkYXRhLm9mZnNldHMucG9wcGVyID0gX2V4dGVuZHMoe30sIHBvcHBlciwgc2hpZnRPZmZzZXRzW3NoaWZ0dmFyaWF0aW9uXSk7XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGhpZGUoZGF0YSkge1xuICBpZiAoIWlzTW9kaWZpZXJSZXF1aXJlZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgJ2hpZGUnLCAncHJldmVudE92ZXJmbG93JykpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHZhciByZWZSZWN0ID0gZGF0YS5vZmZzZXRzLnJlZmVyZW5jZTtcbiAgdmFyIGJvdW5kID0gZmluZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgcmV0dXJuIG1vZGlmaWVyLm5hbWUgPT09ICdwcmV2ZW50T3ZlcmZsb3cnO1xuICB9KS5ib3VuZGFyaWVzO1xuXG4gIGlmIChyZWZSZWN0LmJvdHRvbSA8IGJvdW5kLnRvcCB8fCByZWZSZWN0LmxlZnQgPiBib3VuZC5yaWdodCB8fCByZWZSZWN0LnRvcCA+IGJvdW5kLmJvdHRvbSB8fCByZWZSZWN0LnJpZ2h0IDwgYm91bmQubGVmdCkge1xuICAgIC8vIEF2b2lkIHVubmVjZXNzYXJ5IERPTSBhY2Nlc3MgaWYgdmlzaWJpbGl0eSBoYXNuJ3QgY2hhbmdlZFxuICAgIGlmIChkYXRhLmhpZGUgPT09IHRydWUpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIGRhdGEuaGlkZSA9IHRydWU7XG4gICAgZGF0YS5hdHRyaWJ1dGVzWyd4LW91dC1vZi1ib3VuZGFyaWVzJ10gPSAnJztcbiAgfSBlbHNlIHtcbiAgICAvLyBBdm9pZCB1bm5lY2Vzc2FyeSBET00gYWNjZXNzIGlmIHZpc2liaWxpdHkgaGFzbid0IGNoYW5nZWRcbiAgICBpZiAoZGF0YS5oaWRlID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgZGF0YS5oaWRlID0gZmFsc2U7XG4gICAgZGF0YS5hdHRyaWJ1dGVzWyd4LW91dC1vZi1ib3VuZGFyaWVzJ10gPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBpbm5lcihkYXRhKSB7XG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudDtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgdmFyIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlO1xuXG4gIHZhciBpc0hvcml6ID0gWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihiYXNlUGxhY2VtZW50KSAhPT0gLTE7XG5cbiAgdmFyIHN1YnRyYWN0TGVuZ3RoID0gWyd0b3AnLCAnbGVmdCddLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPT09IC0xO1xuXG4gIHBvcHBlcltpc0hvcml6ID8gJ2xlZnQnIDogJ3RvcCddID0gcmVmZXJlbmNlW2Jhc2VQbGFjZW1lbnRdIC0gKHN1YnRyYWN0TGVuZ3RoID8gcG9wcGVyW2lzSG9yaXogPyAnd2lkdGgnIDogJ2hlaWdodCddIDogMCk7XG5cbiAgZGF0YS5wbGFjZW1lbnQgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICBkYXRhLm9mZnNldHMucG9wcGVyID0gZ2V0Q2xpZW50UmVjdChwb3BwZXIpO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIE1vZGlmaWVyIGZ1bmN0aW9uLCBlYWNoIG1vZGlmaWVyIGNhbiBoYXZlIGEgZnVuY3Rpb24gb2YgdGhpcyB0eXBlIGFzc2lnbmVkXG4gKiB0byBpdHMgYGZuYCBwcm9wZXJ0eS48YnIgLz5cbiAqIFRoZXNlIGZ1bmN0aW9ucyB3aWxsIGJlIGNhbGxlZCBvbiBlYWNoIHVwZGF0ZSwgdGhpcyBtZWFucyB0aGF0IHlvdSBtdXN0XG4gKiBtYWtlIHN1cmUgdGhleSBhcmUgcGVyZm9ybWFudCBlbm91Z2ggdG8gYXZvaWQgcGVyZm9ybWFuY2UgYm90dGxlbmVja3MuXG4gKlxuICogQGZ1bmN0aW9uIE1vZGlmaWVyRm5cbiAqIEBhcmd1bWVudCB7ZGF0YU9iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7ZGF0YU9iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5cbi8qKlxuICogTW9kaWZpZXJzIGFyZSBwbHVnaW5zIHVzZWQgdG8gYWx0ZXIgdGhlIGJlaGF2aW9yIG9mIHlvdXIgcG9wcGVycy48YnIgLz5cbiAqIFBvcHBlci5qcyB1c2VzIGEgc2V0IG9mIDkgbW9kaWZpZXJzIHRvIHByb3ZpZGUgYWxsIHRoZSBiYXNpYyBmdW5jdGlvbmFsaXRpZXNcbiAqIG5lZWRlZCBieSB0aGUgbGlicmFyeS5cbiAqXG4gKiBVc3VhbGx5IHlvdSBkb24ndCB3YW50IHRvIG92ZXJyaWRlIHRoZSBgb3JkZXJgLCBgZm5gIGFuZCBgb25Mb2FkYCBwcm9wcy5cbiAqIEFsbCB0aGUgb3RoZXIgcHJvcGVydGllcyBhcmUgY29uZmlndXJhdGlvbnMgdGhhdCBjb3VsZCBiZSB0d2Vha2VkLlxuICogQG5hbWVzcGFjZSBtb2RpZmllcnNcbiAqL1xudmFyIG1vZGlmaWVycyA9IHtcbiAgLyoqXG4gICAqIE1vZGlmaWVyIHVzZWQgdG8gc2hpZnQgdGhlIHBvcHBlciBvbiB0aGUgc3RhcnQgb3IgZW5kIG9mIGl0cyByZWZlcmVuY2VcbiAgICogZWxlbWVudC48YnIgLz5cbiAgICogSXQgd2lsbCByZWFkIHRoZSB2YXJpYXRpb24gb2YgdGhlIGBwbGFjZW1lbnRgIHByb3BlcnR5LjxiciAvPlxuICAgKiBJdCBjYW4gYmUgb25lIGVpdGhlciBgLWVuZGAgb3IgYC1zdGFydGAuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBzaGlmdDoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj0xMDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDEwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IHNoaWZ0XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoZSBgb2Zmc2V0YCBtb2RpZmllciBjYW4gc2hpZnQgeW91ciBwb3BwZXIgb24gYm90aCBpdHMgYXhpcy5cbiAgICpcbiAgICogSXQgYWNjZXB0cyB0aGUgZm9sbG93aW5nIHVuaXRzOlxuICAgKiAtIGBweGAgb3IgdW5pdGxlc3MsIGludGVycHJldGVkIGFzIHBpeGVsc1xuICAgKiAtIGAlYCBvciBgJXJgLCBwZXJjZW50YWdlIHJlbGF0aXZlIHRvIHRoZSBsZW5ndGggb2YgdGhlIHJlZmVyZW5jZSBlbGVtZW50XG4gICAqIC0gYCVwYCwgcGVyY2VudGFnZSByZWxhdGl2ZSB0byB0aGUgbGVuZ3RoIG9mIHRoZSBwb3BwZXIgZWxlbWVudFxuICAgKiAtIGB2d2AsIENTUyB2aWV3cG9ydCB3aWR0aCB1bml0XG4gICAqIC0gYHZoYCwgQ1NTIHZpZXdwb3J0IGhlaWdodCB1bml0XG4gICAqXG4gICAqIEZvciBsZW5ndGggaXMgaW50ZW5kZWQgdGhlIG1haW4gYXhpcyByZWxhdGl2ZSB0byB0aGUgcGxhY2VtZW50IG9mIHRoZSBwb3BwZXIuPGJyIC8+XG4gICAqIFRoaXMgbWVhbnMgdGhhdCBpZiB0aGUgcGxhY2VtZW50IGlzIGB0b3BgIG9yIGBib3R0b21gLCB0aGUgbGVuZ3RoIHdpbGwgYmUgdGhlXG4gICAqIGB3aWR0aGAuIEluIGNhc2Ugb2YgYGxlZnRgIG9yIGByaWdodGAsIGl0IHdpbGwgYmUgdGhlIGhlaWdodC5cbiAgICpcbiAgICogWW91IGNhbiBwcm92aWRlIGEgc2luZ2xlIHZhbHVlIChhcyBgTnVtYmVyYCBvciBgU3RyaW5nYCksIG9yIGEgcGFpciBvZiB2YWx1ZXNcbiAgICogYXMgYFN0cmluZ2AgZGl2aWRlZCBieSBhIGNvbW1hIG9yIG9uZSAob3IgbW9yZSkgd2hpdGUgc3BhY2VzLjxiciAvPlxuICAgKiBUaGUgbGF0dGVyIGlzIGEgZGVwcmVjYXRlZCBtZXRob2QgYmVjYXVzZSBpdCBsZWFkcyB0byBjb25mdXNpb24gYW5kIHdpbGwgYmVcbiAgICogcmVtb3ZlZCBpbiB2Mi48YnIgLz5cbiAgICogQWRkaXRpb25hbGx5LCBpdCBhY2NlcHRzIGFkZGl0aW9ucyBhbmQgc3VidHJhY3Rpb25zIGJldHdlZW4gZGlmZmVyZW50IHVuaXRzLlxuICAgKiBOb3RlIHRoYXQgbXVsdGlwbGljYXRpb25zIGFuZCBkaXZpc2lvbnMgYXJlbid0IHN1cHBvcnRlZC5cbiAgICpcbiAgICogVmFsaWQgZXhhbXBsZXMgYXJlOlxuICAgKiBgYGBcbiAgICogMTBcbiAgICogJzEwJSdcbiAgICogJzEwLCAxMCdcbiAgICogJzEwJSwgMTAnXG4gICAqICcxMCArIDEwJSdcbiAgICogJzEwIC0gNXZoICsgMyUnXG4gICAqICctMTBweCArIDV2aCwgNXB4IC0gNiUnXG4gICAqIGBgYFxuICAgKiA+ICoqTkIqKjogSWYgeW91IGRlc2lyZSB0byBhcHBseSBvZmZzZXRzIHRvIHlvdXIgcG9wcGVycyBpbiBhIHdheSB0aGF0IG1heSBtYWtlIHRoZW0gb3ZlcmxhcFxuICAgKiA+IHdpdGggdGhlaXIgcmVmZXJlbmNlIGVsZW1lbnQsIHVuZm9ydHVuYXRlbHksIHlvdSB3aWxsIGhhdmUgdG8gZGlzYWJsZSB0aGUgYGZsaXBgIG1vZGlmaWVyLlxuICAgKiA+IE1vcmUgb24gdGhpcyBbcmVhZGluZyB0aGlzIGlzc3VlXShodHRwczovL2dpdGh1Yi5jb20vRmV6VnJhc3RhL3BvcHBlci5qcy9pc3N1ZXMvMzczKVxuICAgKlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgb2Zmc2V0OiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTIwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogMjAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogb2Zmc2V0LFxuICAgIC8qKiBAcHJvcCB7TnVtYmVyfFN0cmluZ30gb2Zmc2V0PTBcbiAgICAgKiBUaGUgb2Zmc2V0IHZhbHVlIGFzIGRlc2NyaWJlZCBpbiB0aGUgbW9kaWZpZXIgZGVzY3JpcHRpb25cbiAgICAgKi9cbiAgICBvZmZzZXQ6IDBcbiAgfSxcblxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBwcmV2ZW50IHRoZSBwb3BwZXIgZnJvbSBiZWluZyBwb3NpdGlvbmVkIG91dHNpZGUgdGhlIGJvdW5kYXJ5LlxuICAgKlxuICAgKiBBbiBzY2VuYXJpbyBleGlzdHMgd2hlcmUgdGhlIHJlZmVyZW5jZSBpdHNlbGYgaXMgbm90IHdpdGhpbiB0aGUgYm91bmRhcmllcy48YnIgLz5cbiAgICogV2UgY2FuIHNheSBpdCBoYXMgXCJlc2NhcGVkIHRoZSBib3VuZGFyaWVzXCIg4oCUIG9yIGp1c3QgXCJlc2NhcGVkXCIuPGJyIC8+XG4gICAqIEluIHRoaXMgY2FzZSB3ZSBuZWVkIHRvIGRlY2lkZSB3aGV0aGVyIHRoZSBwb3BwZXIgc2hvdWxkIGVpdGhlcjpcbiAgICpcbiAgICogLSBkZXRhY2ggZnJvbSB0aGUgcmVmZXJlbmNlIGFuZCByZW1haW4gXCJ0cmFwcGVkXCIgaW4gdGhlIGJvdW5kYXJpZXMsIG9yXG4gICAqIC0gaWYgaXQgc2hvdWxkIGlnbm9yZSB0aGUgYm91bmRhcnkgYW5kIFwiZXNjYXBlIHdpdGggaXRzIHJlZmVyZW5jZVwiXG4gICAqXG4gICAqIFdoZW4gYGVzY2FwZVdpdGhSZWZlcmVuY2VgIGlzIHNldCB0b2B0cnVlYCBhbmQgcmVmZXJlbmNlIGlzIGNvbXBsZXRlbHlcbiAgICogb3V0c2lkZSBpdHMgYm91bmRhcmllcywgdGhlIHBvcHBlciB3aWxsIG92ZXJmbG93IChvciBjb21wbGV0ZWx5IGxlYXZlKVxuICAgKiB0aGUgYm91bmRhcmllcyBpbiBvcmRlciB0byByZW1haW4gYXR0YWNoZWQgdG8gdGhlIGVkZ2Ugb2YgdGhlIHJlZmVyZW5jZS5cbiAgICpcbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIHByZXZlbnRPdmVyZmxvdzoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj0zMDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDMwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IHByZXZlbnRPdmVyZmxvdyxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7QXJyYXl9IFtwcmlvcml0eT1bJ2xlZnQnLCdyaWdodCcsJ3RvcCcsJ2JvdHRvbSddXVxuICAgICAqIFBvcHBlciB3aWxsIHRyeSB0byBwcmV2ZW50IG92ZXJmbG93IGZvbGxvd2luZyB0aGVzZSBwcmlvcml0aWVzIGJ5IGRlZmF1bHQsXG4gICAgICogdGhlbiwgaXQgY291bGQgb3ZlcmZsb3cgb24gdGhlIGxlZnQgYW5kIG9uIHRvcCBvZiB0aGUgYGJvdW5kYXJpZXNFbGVtZW50YFxuICAgICAqL1xuICAgIHByaW9yaXR5OiBbJ2xlZnQnLCAncmlnaHQnLCAndG9wJywgJ2JvdHRvbSddLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtudW1iZXJ9IHBhZGRpbmc9NVxuICAgICAqIEFtb3VudCBvZiBwaXhlbCB1c2VkIHRvIGRlZmluZSBhIG1pbmltdW0gZGlzdGFuY2UgYmV0d2VlbiB0aGUgYm91bmRhcmllc1xuICAgICAqIGFuZCB0aGUgcG9wcGVyIHRoaXMgbWFrZXMgc3VyZSB0aGUgcG9wcGVyIGhhcyBhbHdheXMgYSBsaXR0bGUgcGFkZGluZ1xuICAgICAqIGJldHdlZW4gdGhlIGVkZ2VzIG9mIGl0cyBjb250YWluZXJcbiAgICAgKi9cbiAgICBwYWRkaW5nOiA1LFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtTdHJpbmd8SFRNTEVsZW1lbnR9IGJvdW5kYXJpZXNFbGVtZW50PSdzY3JvbGxQYXJlbnQnXG4gICAgICogQm91bmRhcmllcyB1c2VkIGJ5IHRoZSBtb2RpZmllciwgY2FuIGJlIGBzY3JvbGxQYXJlbnRgLCBgd2luZG93YCxcbiAgICAgKiBgdmlld3BvcnRgIG9yIGFueSBET00gZWxlbWVudC5cbiAgICAgKi9cbiAgICBib3VuZGFyaWVzRWxlbWVudDogJ3Njcm9sbFBhcmVudCdcbiAgfSxcblxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBtYWtlIHN1cmUgdGhlIHJlZmVyZW5jZSBhbmQgaXRzIHBvcHBlciBzdGF5IG5lYXIgZWFjaG90aGVyc1xuICAgKiB3aXRob3V0IGxlYXZpbmcgYW55IGdhcCBiZXR3ZWVuIHRoZSB0d28uIEV4cGVjaWFsbHkgdXNlZnVsIHdoZW4gdGhlIGFycm93IGlzXG4gICAqIGVuYWJsZWQgYW5kIHlvdSB3YW50IHRvIGFzc3VyZSBpdCB0byBwb2ludCB0byBpdHMgcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqIEl0IGNhcmVzIG9ubHkgYWJvdXQgdGhlIGZpcnN0IGF4aXMsIHlvdSBjYW4gc3RpbGwgaGF2ZSBwb3BwZXJzIHdpdGggbWFyZ2luXG4gICAqIGJldHdlZW4gdGhlIHBvcHBlciBhbmQgaXRzIHJlZmVyZW5jZSBlbGVtZW50LlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAga2VlcFRvZ2V0aGVyOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTQwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogNDAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjoga2VlcFRvZ2V0aGVyXG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoaXMgbW9kaWZpZXIgaXMgdXNlZCB0byBtb3ZlIHRoZSBgYXJyb3dFbGVtZW50YCBvZiB0aGUgcG9wcGVyIHRvIG1ha2VcbiAgICogc3VyZSBpdCBpcyBwb3NpdGlvbmVkIGJldHdlZW4gdGhlIHJlZmVyZW5jZSBlbGVtZW50IGFuZCBpdHMgcG9wcGVyIGVsZW1lbnQuXG4gICAqIEl0IHdpbGwgcmVhZCB0aGUgb3V0ZXIgc2l6ZSBvZiB0aGUgYGFycm93RWxlbWVudGAgbm9kZSB0byBkZXRlY3QgaG93IG1hbnlcbiAgICogcGl4ZWxzIG9mIGNvbmp1Y3Rpb24gYXJlIG5lZWRlZC5cbiAgICpcbiAgICogSXQgaGFzIG5vIGVmZmVjdCBpZiBubyBgYXJyb3dFbGVtZW50YCBpcyBwcm92aWRlZC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGFycm93OiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTUwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogNTAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogYXJyb3csXG4gICAgLyoqIEBwcm9wIHtTdHJpbmd8SFRNTEVsZW1lbnR9IGVsZW1lbnQ9J1t4LWFycm93XScgLSBTZWxlY3RvciBvciBub2RlIHVzZWQgYXMgYXJyb3cgKi9cbiAgICBlbGVtZW50OiAnW3gtYXJyb3ddJ1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIGZsaXAgdGhlIHBvcHBlcidzIHBsYWNlbWVudCB3aGVuIGl0IHN0YXJ0cyB0byBvdmVybGFwIGl0c1xuICAgKiByZWZlcmVuY2UgZWxlbWVudC5cbiAgICpcbiAgICogUmVxdWlyZXMgdGhlIGBwcmV2ZW50T3ZlcmZsb3dgIG1vZGlmaWVyIGJlZm9yZSBpdCBpbiBvcmRlciB0byB3b3JrLlxuICAgKlxuICAgKiAqKk5PVEU6KiogdGhpcyBtb2RpZmllciB3aWxsIGludGVycnVwdCB0aGUgY3VycmVudCB1cGRhdGUgY3ljbGUgYW5kIHdpbGxcbiAgICogcmVzdGFydCBpdCBpZiBpdCBkZXRlY3RzIHRoZSBuZWVkIHRvIGZsaXAgdGhlIHBsYWNlbWVudC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGZsaXA6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9NjAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA2MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBmbGlwLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtTdHJpbmd8QXJyYXl9IGJlaGF2aW9yPSdmbGlwJ1xuICAgICAqIFRoZSBiZWhhdmlvciB1c2VkIHRvIGNoYW5nZSB0aGUgcG9wcGVyJ3MgcGxhY2VtZW50LiBJdCBjYW4gYmUgb25lIG9mXG4gICAgICogYGZsaXBgLCBgY2xvY2t3aXNlYCwgYGNvdW50ZXJjbG9ja3dpc2VgIG9yIGFuIGFycmF5IHdpdGggYSBsaXN0IG9mIHZhbGlkXG4gICAgICogcGxhY2VtZW50cyAod2l0aCBvcHRpb25hbCB2YXJpYXRpb25zKS5cbiAgICAgKi9cbiAgICBiZWhhdmlvcjogJ2ZsaXAnLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtudW1iZXJ9IHBhZGRpbmc9NVxuICAgICAqIFRoZSBwb3BwZXIgd2lsbCBmbGlwIGlmIGl0IGhpdHMgdGhlIGVkZ2VzIG9mIHRoZSBgYm91bmRhcmllc0VsZW1lbnRgXG4gICAgICovXG4gICAgcGFkZGluZzogNSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7U3RyaW5nfEhUTUxFbGVtZW50fSBib3VuZGFyaWVzRWxlbWVudD0ndmlld3BvcnQnXG4gICAgICogVGhlIGVsZW1lbnQgd2hpY2ggd2lsbCBkZWZpbmUgdGhlIGJvdW5kYXJpZXMgb2YgdGhlIHBvcHBlciBwb3NpdGlvbixcbiAgICAgKiB0aGUgcG9wcGVyIHdpbGwgbmV2ZXIgYmUgcGxhY2VkIG91dHNpZGUgb2YgdGhlIGRlZmluZWQgYm91bmRhcmllc1xuICAgICAqIChleGNlcHQgaWYga2VlcFRvZ2V0aGVyIGlzIGVuYWJsZWQpXG4gICAgICovXG4gICAgYm91bmRhcmllc0VsZW1lbnQ6ICd2aWV3cG9ydCdcbiAgfSxcblxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBtYWtlIHRoZSBwb3BwZXIgZmxvdyB0b3dhcmQgdGhlIGlubmVyIG9mIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAgICogQnkgZGVmYXVsdCwgd2hlbiB0aGlzIG1vZGlmaWVyIGlzIGRpc2FibGVkLCB0aGUgcG9wcGVyIHdpbGwgYmUgcGxhY2VkIG91dHNpZGVcbiAgICogdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgaW5uZXI6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9NzAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA3MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPWZhbHNlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGlubmVyXG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vZGlmaWVyIHVzZWQgdG8gaGlkZSB0aGUgcG9wcGVyIHdoZW4gaXRzIHJlZmVyZW5jZSBlbGVtZW50IGlzIG91dHNpZGUgb2YgdGhlXG4gICAqIHBvcHBlciBib3VuZGFyaWVzLiBJdCB3aWxsIHNldCBhIGB4LW91dC1vZi1ib3VuZGFyaWVzYCBhdHRyaWJ1dGUgd2hpY2ggY2FuXG4gICAqIGJlIHVzZWQgdG8gaGlkZSB3aXRoIGEgQ1NTIHNlbGVjdG9yIHRoZSBwb3BwZXIgd2hlbiBpdHMgcmVmZXJlbmNlIGlzXG4gICAqIG91dCBvZiBib3VuZGFyaWVzLlxuICAgKlxuICAgKiBSZXF1aXJlcyB0aGUgYHByZXZlbnRPdmVyZmxvd2AgbW9kaWZpZXIgYmVmb3JlIGl0IGluIG9yZGVyIHRvIHdvcmsuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBoaWRlOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTgwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogODAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogaGlkZVxuICB9LFxuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGUgc3R5bGUgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlciBlbGVtZW50IHRvIGdldHNcbiAgICogcHJvcGVybHkgcG9zaXRpb25lZC5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoaXMgbW9kaWZpZXIgd2lsbCBub3QgdG91Y2ggdGhlIERPTSwgaXQganVzdCBwcmVwYXJlcyB0aGUgc3R5bGVzXG4gICAqIHNvIHRoYXQgYGFwcGx5U3R5bGVgIG1vZGlmaWVyIGNhbiBhcHBseSBpdC4gVGhpcyBzZXBhcmF0aW9uIGlzIHVzZWZ1bFxuICAgKiBpbiBjYXNlIHlvdSBuZWVkIHRvIHJlcGxhY2UgYGFwcGx5U3R5bGVgIHdpdGggYSBjdXN0b20gaW1wbGVtZW50YXRpb24uXG4gICAqXG4gICAqIFRoaXMgbW9kaWZpZXIgaGFzIGA4NTBgIGFzIGBvcmRlcmAgdmFsdWUgdG8gbWFpbnRhaW4gYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgKiB3aXRoIHByZXZpb3VzIHZlcnNpb25zIG9mIFBvcHBlci5qcy4gRXhwZWN0IHRoZSBtb2RpZmllcnMgb3JkZXJpbmcgbWV0aG9kXG4gICAqIHRvIGNoYW5nZSBpbiBmdXR1cmUgbWFqb3IgdmVyc2lvbnMgb2YgdGhlIGxpYnJhcnkuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBjb21wdXRlU3R5bGU6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9ODUwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA4NTAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBjb21wdXRlU3R5bGUsXG4gICAgLyoqXG4gICAgICogQHByb3Age0Jvb2xlYW59IGdwdUFjY2VsZXJhdGlvbj10cnVlXG4gICAgICogSWYgdHJ1ZSwgaXQgdXNlcyB0aGUgQ1NTIDNkIHRyYW5zZm9ybWF0aW9uIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXIuXG4gICAgICogT3RoZXJ3aXNlLCBpdCB3aWxsIHVzZSB0aGUgYHRvcGAgYW5kIGBsZWZ0YCBwcm9wZXJ0aWVzLlxuICAgICAqL1xuICAgIGdwdUFjY2VsZXJhdGlvbjogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7c3RyaW5nfSBbeD0nYm90dG9tJ11cbiAgICAgKiBXaGVyZSB0byBhbmNob3IgdGhlIFggYXhpcyAoYGJvdHRvbWAgb3IgYHRvcGApLiBBS0EgWCBvZmZzZXQgb3JpZ2luLlxuICAgICAqIENoYW5nZSB0aGlzIGlmIHlvdXIgcG9wcGVyIHNob3VsZCBncm93IGluIGEgZGlyZWN0aW9uIGRpZmZlcmVudCBmcm9tIGBib3R0b21gXG4gICAgICovXG4gICAgeDogJ2JvdHRvbScsXG4gICAgLyoqXG4gICAgICogQHByb3Age3N0cmluZ30gW3g9J2xlZnQnXVxuICAgICAqIFdoZXJlIHRvIGFuY2hvciB0aGUgWSBheGlzIChgbGVmdGAgb3IgYHJpZ2h0YCkuIEFLQSBZIG9mZnNldCBvcmlnaW4uXG4gICAgICogQ2hhbmdlIHRoaXMgaWYgeW91ciBwb3BwZXIgc2hvdWxkIGdyb3cgaW4gYSBkaXJlY3Rpb24gZGlmZmVyZW50IGZyb20gYHJpZ2h0YFxuICAgICAqL1xuICAgIHk6ICdyaWdodCdcbiAgfSxcblxuICAvKipcbiAgICogQXBwbGllcyB0aGUgY29tcHV0ZWQgc3R5bGVzIHRvIHRoZSBwb3BwZXIgZWxlbWVudC5cbiAgICpcbiAgICogQWxsIHRoZSBET00gbWFuaXB1bGF0aW9ucyBhcmUgbGltaXRlZCB0byB0aGlzIG1vZGlmaWVyLiBUaGlzIGlzIHVzZWZ1bCBpbiBjYXNlXG4gICAqIHlvdSB3YW50IHRvIGludGVncmF0ZSBQb3BwZXIuanMgaW5zaWRlIGEgZnJhbWV3b3JrIG9yIHZpZXcgbGlicmFyeSBhbmQgeW91XG4gICAqIHdhbnQgdG8gZGVsZWdhdGUgYWxsIHRoZSBET00gbWFuaXB1bGF0aW9ucyB0byBpdC5cbiAgICpcbiAgICogTm90ZSB0aGF0IGlmIHlvdSBkaXNhYmxlIHRoaXMgbW9kaWZpZXIsIHlvdSBtdXN0IG1ha2Ugc3VyZSB0aGUgcG9wcGVyIGVsZW1lbnRcbiAgICogaGFzIGl0cyBwb3NpdGlvbiBzZXQgdG8gYGFic29sdXRlYCBiZWZvcmUgUG9wcGVyLmpzIGNhbiBkbyBpdHMgd29yayFcbiAgICpcbiAgICogSnVzdCBkaXNhYmxlIHRoaXMgbW9kaWZpZXIgYW5kIGRlZmluZSB5b3Ugb3duIHRvIGFjaGlldmUgdGhlIGRlc2lyZWQgZWZmZWN0LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgYXBwbHlTdHlsZToge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj05MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDkwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGFwcGx5U3R5bGUsXG4gICAgLyoqIEBwcm9wIHtGdW5jdGlvbn0gKi9cbiAgICBvbkxvYWQ6IGFwcGx5U3R5bGVPbkxvYWQsXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAxLjEwLjAsIHRoZSBwcm9wZXJ0eSBtb3ZlZCB0byBgY29tcHV0ZVN0eWxlYCBtb2RpZmllclxuICAgICAqIEBwcm9wIHtCb29sZWFufSBncHVBY2NlbGVyYXRpb249dHJ1ZVxuICAgICAqIElmIHRydWUsIGl0IHVzZXMgdGhlIENTUyAzZCB0cmFuc2Zvcm1hdGlvbiB0byBwb3NpdGlvbiB0aGUgcG9wcGVyLlxuICAgICAqIE90aGVyd2lzZSwgaXQgd2lsbCB1c2UgdGhlIGB0b3BgIGFuZCBgbGVmdGAgcHJvcGVydGllcy5cbiAgICAgKi9cbiAgICBncHVBY2NlbGVyYXRpb246IHVuZGVmaW5lZFxuICB9XG59O1xuXG4vKipcbiAqIFRoZSBgZGF0YU9iamVjdGAgaXMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBpbmZvcm1hdGlvbnMgdXNlZCBieSBQb3BwZXIuanNcbiAqIHRoaXMgb2JqZWN0IGdldCBwYXNzZWQgdG8gbW9kaWZpZXJzIGFuZCB0byB0aGUgYG9uQ3JlYXRlYCBhbmQgYG9uVXBkYXRlYCBjYWxsYmFja3MuXG4gKiBAbmFtZSBkYXRhT2JqZWN0XG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5pbnN0YW5jZSBUaGUgUG9wcGVyLmpzIGluc3RhbmNlXG4gKiBAcHJvcGVydHkge1N0cmluZ30gZGF0YS5wbGFjZW1lbnQgUGxhY2VtZW50IGFwcGxpZWQgdG8gcG9wcGVyXG4gKiBAcHJvcGVydHkge1N0cmluZ30gZGF0YS5vcmlnaW5hbFBsYWNlbWVudCBQbGFjZW1lbnQgb3JpZ2luYWxseSBkZWZpbmVkIG9uIGluaXRcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZGF0YS5mbGlwcGVkIFRydWUgaWYgcG9wcGVyIGhhcyBiZWVuIGZsaXBwZWQgYnkgZmxpcCBtb2RpZmllclxuICogQHByb3BlcnR5IHtCb29sZWFufSBkYXRhLmhpZGUgVHJ1ZSBpZiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgaXMgb3V0IG9mIGJvdW5kYXJpZXMsIHVzZWZ1bCB0byBrbm93IHdoZW4gdG8gaGlkZSB0aGUgcG9wcGVyLlxuICogQHByb3BlcnR5IHtIVE1MRWxlbWVudH0gZGF0YS5hcnJvd0VsZW1lbnQgTm9kZSB1c2VkIGFzIGFycm93IGJ5IGFycm93IG1vZGlmaWVyXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5zdHlsZXMgQW55IENTUyBwcm9wZXJ0eSBkZWZpbmVkIGhlcmUgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIsIGl0IGV4cGVjdHMgdGhlIEphdmFTY3JpcHQgbm9tZW5jbGF0dXJlIChlZy4gYG1hcmdpbkJvdHRvbWApXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5hcnJvd1N0eWxlcyBBbnkgQ1NTIHByb3BlcnR5IGRlZmluZWQgaGVyZSB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlciBhcnJvdywgaXQgZXhwZWN0cyB0aGUgSmF2YVNjcmlwdCBub21lbmNsYXR1cmUgKGVnLiBgbWFyZ2luQm90dG9tYClcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLmJvdW5kYXJpZXMgT2Zmc2V0cyBvZiB0aGUgcG9wcGVyIGJvdW5kYXJpZXNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLm9mZnNldHMgVGhlIG1lYXN1cmVtZW50cyBvZiBwb3BwZXIsIHJlZmVyZW5jZSBhbmQgYXJyb3cgZWxlbWVudHMuXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5vZmZzZXRzLnBvcHBlciBgdG9wYCwgYGxlZnRgLCBgd2lkdGhgLCBgaGVpZ2h0YCB2YWx1ZXNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLm9mZnNldHMucmVmZXJlbmNlIGB0b3BgLCBgbGVmdGAsIGB3aWR0aGAsIGBoZWlnaHRgIHZhbHVlc1xuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEub2Zmc2V0cy5hcnJvd10gYHRvcGAgYW5kIGBsZWZ0YCBvZmZzZXRzLCBvbmx5IG9uZSBvZiB0aGVtIHdpbGwgYmUgZGlmZmVyZW50IGZyb20gMFxuICovXG5cbi8qKlxuICogRGVmYXVsdCBvcHRpb25zIHByb3ZpZGVkIHRvIFBvcHBlci5qcyBjb25zdHJ1Y3Rvci48YnIgLz5cbiAqIFRoZXNlIGNhbiBiZSBvdmVycmlkZW4gdXNpbmcgdGhlIGBvcHRpb25zYCBhcmd1bWVudCBvZiBQb3BwZXIuanMuPGJyIC8+XG4gKiBUbyBvdmVycmlkZSBhbiBvcHRpb24sIHNpbXBseSBwYXNzIGFzIDNyZCBhcmd1bWVudCBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZVxuICogc3RydWN0dXJlIG9mIHRoaXMgb2JqZWN0LCBleGFtcGxlOlxuICogYGBgXG4gKiBuZXcgUG9wcGVyKHJlZiwgcG9wLCB7XG4gKiAgIG1vZGlmaWVyczoge1xuICogICAgIHByZXZlbnRPdmVyZmxvdzogeyBlbmFibGVkOiBmYWxzZSB9XG4gKiAgIH1cbiAqIH0pXG4gKiBgYGBcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbnZhciBEZWZhdWx0cyA9IHtcbiAgLyoqXG4gICAqIFBvcHBlcidzIHBsYWNlbWVudFxuICAgKiBAcHJvcCB7UG9wcGVyLnBsYWNlbWVudHN9IHBsYWNlbWVudD0nYm90dG9tJ1xuICAgKi9cbiAgcGxhY2VtZW50OiAnYm90dG9tJyxcblxuICAvKipcbiAgICogU2V0IHRoaXMgdG8gdHJ1ZSBpZiB5b3Ugd2FudCBwb3BwZXIgdG8gcG9zaXRpb24gaXQgc2VsZiBpbiAnZml4ZWQnIG1vZGVcbiAgICogQHByb3Age0Jvb2xlYW59IHBvc2l0aW9uRml4ZWQ9ZmFsc2VcbiAgICovXG4gIHBvc2l0aW9uRml4ZWQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIGV2ZW50cyAocmVzaXplLCBzY3JvbGwpIGFyZSBpbml0aWFsbHkgZW5hYmxlZFxuICAgKiBAcHJvcCB7Qm9vbGVhbn0gZXZlbnRzRW5hYmxlZD10cnVlXG4gICAqL1xuICBldmVudHNFbmFibGVkOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBTZXQgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0byBhdXRvbWF0aWNhbGx5IHJlbW92ZSB0aGUgcG9wcGVyIHdoZW5cbiAgICogeW91IGNhbGwgdGhlIGBkZXN0cm95YCBtZXRob2QuXG4gICAqIEBwcm9wIHtCb29sZWFufSByZW1vdmVPbkRlc3Ryb3k9ZmFsc2VcbiAgICovXG4gIHJlbW92ZU9uRGVzdHJveTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGNhbGxlZCB3aGVuIHRoZSBwb3BwZXIgaXMgY3JlYXRlZC48YnIgLz5cbiAgICogQnkgZGVmYXVsdCwgaXMgc2V0IHRvIG5vLW9wLjxiciAvPlxuICAgKiBBY2Nlc3MgUG9wcGVyLmpzIGluc3RhbmNlIHdpdGggYGRhdGEuaW5zdGFuY2VgLlxuICAgKiBAcHJvcCB7b25DcmVhdGV9XG4gICAqL1xuICBvbkNyZWF0ZTogZnVuY3Rpb24gb25DcmVhdGUoKSB7fSxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgY2FsbGVkIHdoZW4gdGhlIHBvcHBlciBpcyB1cGRhdGVkLCB0aGlzIGNhbGxiYWNrIGlzIG5vdCBjYWxsZWRcbiAgICogb24gdGhlIGluaXRpYWxpemF0aW9uL2NyZWF0aW9uIG9mIHRoZSBwb3BwZXIsIGJ1dCBvbmx5IG9uIHN1YnNlcXVlbnRcbiAgICogdXBkYXRlcy48YnIgLz5cbiAgICogQnkgZGVmYXVsdCwgaXMgc2V0IHRvIG5vLW9wLjxiciAvPlxuICAgKiBBY2Nlc3MgUG9wcGVyLmpzIGluc3RhbmNlIHdpdGggYGRhdGEuaW5zdGFuY2VgLlxuICAgKiBAcHJvcCB7b25VcGRhdGV9XG4gICAqL1xuICBvblVwZGF0ZTogZnVuY3Rpb24gb25VcGRhdGUoKSB7fSxcblxuICAvKipcbiAgICogTGlzdCBvZiBtb2RpZmllcnMgdXNlZCB0byBtb2RpZnkgdGhlIG9mZnNldHMgYmVmb3JlIHRoZXkgYXJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlci5cbiAgICogVGhleSBwcm92aWRlIG1vc3Qgb2YgdGhlIGZ1bmN0aW9uYWxpdGllcyBvZiBQb3BwZXIuanNcbiAgICogQHByb3Age21vZGlmaWVyc31cbiAgICovXG4gIG1vZGlmaWVyczogbW9kaWZpZXJzXG59O1xuXG4vKipcbiAqIEBjYWxsYmFjayBvbkNyZWF0ZVxuICogQHBhcmFtIHtkYXRhT2JqZWN0fSBkYXRhXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgb25VcGRhdGVcbiAqIEBwYXJhbSB7ZGF0YU9iamVjdH0gZGF0YVxuICovXG5cbi8vIFV0aWxzXG4vLyBNZXRob2RzXG52YXIgUG9wcGVyID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IFBvcHBlci5qcyBpbnN0YW5jZVxuICAgKiBAY2xhc3MgUG9wcGVyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8cmVmZXJlbmNlT2JqZWN0fSByZWZlcmVuY2UgLSBUaGUgcmVmZXJlbmNlIGVsZW1lbnQgdXNlZCB0byBwb3NpdGlvbiB0aGUgcG9wcGVyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBvcHBlciAtIFRoZSBIVE1MIGVsZW1lbnQgdXNlZCBhcyBwb3BwZXIuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gWW91ciBjdXN0b20gb3B0aW9ucyB0byBvdmVycmlkZSB0aGUgb25lcyBkZWZpbmVkIGluIFtEZWZhdWx0c10oI2RlZmF1bHRzKVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGluc3RhbmNlIC0gVGhlIGdlbmVyYXRlZCBQb3BwZXIuanMgaW5zdGFuY2VcbiAgICovXG4gIGZ1bmN0aW9uIFBvcHBlcihyZWZlcmVuY2UsIHBvcHBlcikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgUG9wcGVyKTtcblxuICAgIHRoaXMuc2NoZWR1bGVVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKF90aGlzLnVwZGF0ZSk7XG4gICAgfTtcblxuICAgIC8vIG1ha2UgdXBkYXRlKCkgZGVib3VuY2VkLCBzbyB0aGF0IGl0IG9ubHkgcnVucyBhdCBtb3N0IG9uY2UtcGVyLXRpY2tcbiAgICB0aGlzLnVwZGF0ZSA9IGRlYm91bmNlKHRoaXMudXBkYXRlLmJpbmQodGhpcykpO1xuXG4gICAgLy8gd2l0aCB7fSB3ZSBjcmVhdGUgYSBuZXcgb2JqZWN0IHdpdGggdGhlIG9wdGlvbnMgaW5zaWRlIGl0XG4gICAgdGhpcy5vcHRpb25zID0gX2V4dGVuZHMoe30sIFBvcHBlci5EZWZhdWx0cywgb3B0aW9ucyk7XG5cbiAgICAvLyBpbml0IHN0YXRlXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGlzRGVzdHJveWVkOiBmYWxzZSxcbiAgICAgIGlzQ3JlYXRlZDogZmFsc2UsXG4gICAgICBzY3JvbGxQYXJlbnRzOiBbXVxuICAgIH07XG5cbiAgICAvLyBnZXQgcmVmZXJlbmNlIGFuZCBwb3BwZXIgZWxlbWVudHMgKGFsbG93IGpRdWVyeSB3cmFwcGVycylcbiAgICB0aGlzLnJlZmVyZW5jZSA9IHJlZmVyZW5jZSAmJiByZWZlcmVuY2UuanF1ZXJ5ID8gcmVmZXJlbmNlWzBdIDogcmVmZXJlbmNlO1xuICAgIHRoaXMucG9wcGVyID0gcG9wcGVyICYmIHBvcHBlci5qcXVlcnkgPyBwb3BwZXJbMF0gOiBwb3BwZXI7XG5cbiAgICAvLyBEZWVwIG1lcmdlIG1vZGlmaWVycyBvcHRpb25zXG4gICAgdGhpcy5vcHRpb25zLm1vZGlmaWVycyA9IHt9O1xuICAgIE9iamVjdC5rZXlzKF9leHRlbmRzKHt9LCBQb3BwZXIuRGVmYXVsdHMubW9kaWZpZXJzLCBvcHRpb25zLm1vZGlmaWVycykpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIF90aGlzLm9wdGlvbnMubW9kaWZpZXJzW25hbWVdID0gX2V4dGVuZHMoe30sIFBvcHBlci5EZWZhdWx0cy5tb2RpZmllcnNbbmFtZV0gfHwge30sIG9wdGlvbnMubW9kaWZpZXJzID8gb3B0aW9ucy5tb2RpZmllcnNbbmFtZV0gOiB7fSk7XG4gICAgfSk7XG5cbiAgICAvLyBSZWZhY3RvcmluZyBtb2RpZmllcnMnIGxpc3QgKE9iamVjdCA9PiBBcnJheSlcbiAgICB0aGlzLm1vZGlmaWVycyA9IE9iamVjdC5rZXlzKHRoaXMub3B0aW9ucy5tb2RpZmllcnMpLm1hcChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgICAgbmFtZTogbmFtZVxuICAgICAgfSwgX3RoaXMub3B0aW9ucy5tb2RpZmllcnNbbmFtZV0pO1xuICAgIH0pXG4gICAgLy8gc29ydCB0aGUgbW9kaWZpZXJzIGJ5IG9yZGVyXG4gICAgLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhLm9yZGVyIC0gYi5vcmRlcjtcbiAgICB9KTtcblxuICAgIC8vIG1vZGlmaWVycyBoYXZlIHRoZSBhYmlsaXR5IHRvIGV4ZWN1dGUgYXJiaXRyYXJ5IGNvZGUgd2hlbiBQb3BwZXIuanMgZ2V0IGluaXRlZFxuICAgIC8vIHN1Y2ggY29kZSBpcyBleGVjdXRlZCBpbiB0aGUgc2FtZSBvcmRlciBvZiBpdHMgbW9kaWZpZXJcbiAgICAvLyB0aGV5IGNvdWxkIGFkZCBuZXcgcHJvcGVydGllcyB0byB0aGVpciBvcHRpb25zIGNvbmZpZ3VyYXRpb25cbiAgICAvLyBCRSBBV0FSRTogZG9uJ3QgYWRkIG9wdGlvbnMgdG8gYG9wdGlvbnMubW9kaWZpZXJzLm5hbWVgIGJ1dCB0byBgbW9kaWZpZXJPcHRpb25zYCFcbiAgICB0aGlzLm1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllck9wdGlvbnMpIHtcbiAgICAgIGlmIChtb2RpZmllck9wdGlvbnMuZW5hYmxlZCAmJiBpc0Z1bmN0aW9uKG1vZGlmaWVyT3B0aW9ucy5vbkxvYWQpKSB7XG4gICAgICAgIG1vZGlmaWVyT3B0aW9ucy5vbkxvYWQoX3RoaXMucmVmZXJlbmNlLCBfdGhpcy5wb3BwZXIsIF90aGlzLm9wdGlvbnMsIG1vZGlmaWVyT3B0aW9ucywgX3RoaXMuc3RhdGUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gZmlyZSB0aGUgZmlyc3QgdXBkYXRlIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXIgaW4gdGhlIHJpZ2h0IHBsYWNlXG4gICAgdGhpcy51cGRhdGUoKTtcblxuICAgIHZhciBldmVudHNFbmFibGVkID0gdGhpcy5vcHRpb25zLmV2ZW50c0VuYWJsZWQ7XG4gICAgaWYgKGV2ZW50c0VuYWJsZWQpIHtcbiAgICAgIC8vIHNldHVwIGV2ZW50IGxpc3RlbmVycywgdGhleSB3aWxsIHRha2UgY2FyZSBvZiB1cGRhdGUgdGhlIHBvc2l0aW9uIGluIHNwZWNpZmljIHNpdHVhdGlvbnNcbiAgICAgIHRoaXMuZW5hYmxlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlLmV2ZW50c0VuYWJsZWQgPSBldmVudHNFbmFibGVkO1xuICB9XG5cbiAgLy8gV2UgY2FuJ3QgdXNlIGNsYXNzIHByb3BlcnRpZXMgYmVjYXVzZSB0aGV5IGRvbid0IGdldCBsaXN0ZWQgaW4gdGhlXG4gIC8vIGNsYXNzIHByb3RvdHlwZSBhbmQgYnJlYWsgc3R1ZmYgbGlrZSBTaW5vbiBzdHVic1xuXG5cbiAgY3JlYXRlQ2xhc3MoUG9wcGVyLCBbe1xuICAgIGtleTogJ3VwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZSQkMSgpIHtcbiAgICAgIHJldHVybiB1cGRhdGUuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkZXN0cm95JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSQkMSgpIHtcbiAgICAgIHJldHVybiBkZXN0cm95LmNhbGwodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZW5hYmxlRXZlbnRMaXN0ZW5lcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmFibGVFdmVudExpc3RlbmVycyQkMSgpIHtcbiAgICAgIHJldHVybiBlbmFibGVFdmVudExpc3RlbmVycy5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Rpc2FibGVFdmVudExpc3RlbmVycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2FibGVFdmVudExpc3RlbmVycyQkMSgpIHtcbiAgICAgIHJldHVybiBkaXNhYmxlRXZlbnRMaXN0ZW5lcnMuY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTY2hlZHVsZSBhbiB1cGRhdGUsIGl0IHdpbGwgcnVuIG9uIHRoZSBuZXh0IFVJIHVwZGF0ZSBhdmFpbGFibGVcbiAgICAgKiBAbWV0aG9kIHNjaGVkdWxlVXBkYXRlXG4gICAgICogQG1lbWJlcm9mIFBvcHBlclxuICAgICAqL1xuXG5cbiAgICAvKipcbiAgICAgKiBDb2xsZWN0aW9uIG9mIHV0aWxpdGllcyB1c2VmdWwgd2hlbiB3cml0aW5nIGN1c3RvbSBtb2RpZmllcnMuXG4gICAgICogU3RhcnRpbmcgZnJvbSB2ZXJzaW9uIDEuNywgdGhpcyBtZXRob2QgaXMgYXZhaWxhYmxlIG9ubHkgaWYgeW91XG4gICAgICogaW5jbHVkZSBgcG9wcGVyLXV0aWxzLmpzYCBiZWZvcmUgYHBvcHBlci5qc2AuXG4gICAgICpcbiAgICAgKiAqKkRFUFJFQ0FUSU9OKio6IFRoaXMgd2F5IHRvIGFjY2VzcyBQb3BwZXJVdGlscyBpcyBkZXByZWNhdGVkXG4gICAgICogYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB2MiEgVXNlIHRoZSBQb3BwZXJVdGlscyBtb2R1bGUgZGlyZWN0bHkgaW5zdGVhZC5cbiAgICAgKiBEdWUgdG8gdGhlIGhpZ2ggaW5zdGFiaWxpdHkgb2YgdGhlIG1ldGhvZHMgY29udGFpbmVkIGluIFV0aWxzLCB3ZSBjYW4ndFxuICAgICAqIGd1YXJhbnRlZSB0aGVtIHRvIGZvbGxvdyBzZW12ZXIuIFVzZSB0aGVtIGF0IHlvdXIgb3duIHJpc2shXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDEuOFxuICAgICAqIEBtZW1iZXIgVXRpbHNcbiAgICAgKiBAbWVtYmVyb2YgUG9wcGVyXG4gICAgICovXG5cbiAgfV0pO1xuICByZXR1cm4gUG9wcGVyO1xufSgpO1xuXG4vKipcbiAqIFRoZSBgcmVmZXJlbmNlT2JqZWN0YCBpcyBhbiBvYmplY3QgdGhhdCBwcm92aWRlcyBhbiBpbnRlcmZhY2UgY29tcGF0aWJsZSB3aXRoIFBvcHBlci5qc1xuICogYW5kIGxldHMgeW91IHVzZSBpdCBhcyByZXBsYWNlbWVudCBvZiBhIHJlYWwgRE9NIG5vZGUuPGJyIC8+XG4gKiBZb3UgY2FuIHVzZSB0aGlzIG1ldGhvZCB0byBwb3NpdGlvbiBhIHBvcHBlciByZWxhdGl2ZWx5IHRvIGEgc2V0IG9mIGNvb3JkaW5hdGVzXG4gKiBpbiBjYXNlIHlvdSBkb24ndCBoYXZlIGEgRE9NIG5vZGUgdG8gdXNlIGFzIHJlZmVyZW5jZS5cbiAqXG4gKiBgYGBcbiAqIG5ldyBQb3BwZXIocmVmZXJlbmNlT2JqZWN0LCBwb3BwZXJOb2RlKTtcbiAqIGBgYFxuICpcbiAqIE5COiBUaGlzIGZlYXR1cmUgaXNuJ3Qgc3VwcG9ydGVkIGluIEludGVybmV0IEV4cGxvcmVyIDEwXG4gKiBAbmFtZSByZWZlcmVuY2VPYmplY3RcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGRhdGEuZ2V0Qm91bmRpbmdDbGllbnRSZWN0XG4gKiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHNldCBvZiBjb29yZGluYXRlcyBjb21wYXRpYmxlIHdpdGggdGhlIG5hdGl2ZSBgZ2V0Qm91bmRpbmdDbGllbnRSZWN0YCBtZXRob2QuXG4gKiBAcHJvcGVydHkge251bWJlcn0gZGF0YS5jbGllbnRXaWR0aFxuICogQW4gRVM2IGdldHRlciB0aGF0IHdpbGwgcmV0dXJuIHRoZSB3aWR0aCBvZiB0aGUgdmlydHVhbCByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkYXRhLmNsaWVudEhlaWdodFxuICogQW4gRVM2IGdldHRlciB0aGF0IHdpbGwgcmV0dXJuIHRoZSBoZWlnaHQgb2YgdGhlIHZpcnR1YWwgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKi9cblxuXG5Qb3BwZXIuVXRpbHMgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiBnbG9iYWwpLlBvcHBlclV0aWxzO1xuUG9wcGVyLnBsYWNlbWVudHMgPSBwbGFjZW1lbnRzO1xuUG9wcGVyLkRlZmF1bHRzID0gRGVmYXVsdHM7XG5cbmV4cG9ydCBkZWZhdWx0IFBvcHBlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvcHBlci5qcy5tYXBcbiIsIjx0ZW1wbGF0ZT5cbiAgICA8ZGl2IHYtc2hvdz1cImlzRGlzcGxheWluZ1wiIGNsYXNzPVwicG9wb3ZlclwiIDpjbGFzcz1cIm1lcmdlQ2xhc3Nlcyh0cmlnZ2VyYWJsZUNsYXNzZXMsIGNsYXNzZXMpXCIgcm9sZT1cInRvb2x0aXBcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImFycm93XCI+PC9kaXY+XG4gICAgICAgIDxwb3BvdmVyLWhlYWRlciB2LWlmPVwidGl0bGVcIiB2LWh0bWw9XCJ0aXRsZVwiLz5cbiAgICAgICAgPHBvcG92ZXItYm9keT5cbiAgICAgICAgICAgIDxzbG90Lz5cbiAgICAgICAgPC9wb3BvdmVyLWJvZHk+XG4gICAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuLypcbkV2ZW50c1xuRXZlbnQgVHlwZVx0RGVzY3JpcHRpb25cbmNsb3NlLmJzLnBvcG92ZXJcdFRoaXMgZXZlbnQgZmlyZXMgaW1tZWRpYXRlbHkgd2hlbiB0aGUgY2xvc2UgaW5zdGFuY2UgbWV0aG9kIGlzIGNhbGxlZC5cbmNsb3Nlbi5icy5wb3BvdmVyXHRUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIHBvcG92ZXIgaGFzIGJlZW4gbWFkZSB2aXNpYmxlIHRvIHRoZSB1c2VyICh3aWxsIHdhaXQgZm9yIENTUyB0cmFuc2l0aW9ucyB0byBjb21wbGV0ZSkuXG5vcGVuLmJzLnBvcG92ZXJcdFRoaXMgZXZlbnQgaXMgZmlyZWQgaW1tZWRpYXRlbHkgd2hlbiB0aGUgb3BlbiBpbnN0YW5jZSBtZXRob2QgaGFzIGJlZW4gY2FsbGVkLlxuaGlkZGVuLmJzLnBvcG92ZXJcdFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgcG9wb3ZlciBoYXMgZmluaXNoZWQgYmVpbmcgaGlkZGVuIGZyb20gdGhlIHVzZXIgKHdpbGwgd2FpdCBmb3IgQ1NTIHRyYW5zaXRpb25zIHRvIGNvbXBsZXRlKS5cbmluc2VydGVkLmJzLnBvcG92ZXJcdFRoaXMgZXZlbnQgaXMgZmlyZWQgYWZ0ZXIgdGhlIGNsb3NlLmJzLnBvcG92ZXIgZXZlbnQgd2hlbiB0aGUgcG9wb3ZlciB0ZW1wbGF0ZSBoYXMgYmVlbiBhZGRlZCB0byB0aGUgRE9NLlxuJCgnI215UG9wb3ZlcicpLm9uKCdoaWRkZW4uYnMucG9wb3ZlcicsIGZ1bmN0aW9uICgpIHtcbiAgLy8gZG8gc29tZXRoaW5n4oCmXG59KVxuKi9cbmltcG9ydCB7IGVhY2ggfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IHsgaXNTdHJpbmcgfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IFBvcHBlciBmcm9tICdwb3BwZXIuanMnO1xuaW1wb3J0IHByZWZpeCBmcm9tICcuLi8uLi9IZWxwZXJzL1ByZWZpeCc7XG5pbXBvcnQgVHJpZ2dlcmFibGUgZnJvbSAnLi4vLi4vTWl4aW5zL1RyaWdnZXJhYmxlJztcbmltcG9ydCBNZXJnZUNsYXNzZXMgZnJvbSAnLi4vLi4vTWl4aW5zL01lcmdlQ2xhc3Nlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdwb3BvdmVyJyxcblxuICAgIG1peGluczogW1xuICAgICAgICBUcmlnZ2VyYWJsZSxcbiAgICAgICAgTWVyZ2VDbGFzc2VzXG4gICAgXSxcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFwcGx5IGEgQ1NTIGZhZGUgdHJhbnNpdGlvbiB0byB0aGUgcG9wb3ZlclxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGFuaW1hdGlvbjoge1xuICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogT3ZlcmZsb3cgY29uc3RyYWludCBib3VuZGFyeSBvZiB0aGUgcG9wb3Zlci4gQWNjZXB0cyB0aGUgdmFsdWVzIG9mXG4gICAgICAgICAqICd2aWV3cG9ydCcsICd3aW5kb3cnLCAnc2Nyb2xsUGFyZW50Jywgb3IgYW4gSFRNTEVsZW1lbnQgcmVmZXJlbmNlXG4gICAgICAgICAqIChKYXZhU2NyaXB0IG9ubHkpLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiByZWZlciB0byBQb3BwZXIuanMnc1xuICAgICAgICAgKiBwcmV2ZW50T3ZlcmZsb3cgZG9jcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIGJvdW5kYXJ5OiB7XG4gICAgICAgICAgICB0eXBlOiBbU3RyaW5nLCBBcnJheV0sXG4gICAgICAgICAgICBkZWZhdWx0OiAnc2Nyb2xsUGFyZW50JyxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsndmlld3BvcnQnLCAnd2luZG93JywgJ3ZpZXdwb3J0J10uaW5kZXhPZih2YWx1ZSkgIT09IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcHBlbmRzIHRoZSBwb3BvdmVyIHRvIGEgc3BlY2lmaWMgZWxlbWVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogRXhhbXBsZTogY29udGFpbmVyOiAnYm9keScuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgb3B0aW9uIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgaW4gdGhhdCBpdCBhbGxvd3MgeW91IHRvIHBvc2l0aW9uXG4gICAgICAgICAqIHRoZSBwb3BvdmVyIGluIHRoZSBmbG93IG9mIHRoZSBkb2N1bWVudCBuZWFyIHRoZSB0cmlnZ2VyaW5nIGVsZW1lbnQgLVxuICAgICAgICAgKiB3aGljaCB3aWxsIHByZXZlbnQgdGhlIHBvcG92ZXIgZnJvbSBmbG9hdGluZyBhd2F5IGZyb20gdGhldHJpZ2dlcmluZ1xuICAgICAgICAgKiBlbGVtZW50IGR1cmluZyBhIHdpbmRvdyByZXNpemUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd8RWxlbWVudHxCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgY29udGFpbmVyOiB7XG4gICAgICAgICAgICB0eXBlOiBbU3RyaW5nLCBFbGVtZW50LCBCb29sZWFuXSxcbiAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlbGF5IGNsb3NlaW5nIGFuZCBoaWRpbmcgdGhlIHBvcG92ZXIgKG1zKSAtIGRvZXMgbm90IGFwcGx5IHRvIG1hbnVhbCB0cmlnZ2VyIHR5cGVcbiAgICAgICAgICpcbiAgICAgICAgICogSWYgYSBudW1iZXIgaXMgc3VwcGxpZWQsIGRlbGF5IGlzIGFwcGxpZWQgdG8gYm90aCBvcGVuL2Nsb3NlXG4gICAgICAgICAqXG4gICAgICAgICAqIE9iamVjdCBzdHJ1Y3R1cmUgaXM6IGRlbGF5OiB7IFwiY2xvc2VcIjogNTAwLCBcIm9wZW5cIjogMTAwIH1cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge051bWJlcnxPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICBkZWxheToge1xuICAgICAgICAgICAgdHlwZTogW051bWJlciwgT2JqZWN0XSxcbiAgICAgICAgICAgIGRlZmF1bHQ6IDBcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWxsb3cgdG8gc3BlY2lmeSB3aGljaCBwb3NpdGlvbiBQb3BwZXIgd2lsbCB1c2Ugb24gZmFsbGJhY2suIEZvciBtb3JlXG4gICAgICAgICAqIGluZm9ybWF0aW9uIHJlZmVyIHRvIFBvcHBlci5qcydzIGJlaGF2aW9yIGRvY3NcbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge1N0cmluZ3xBcnJheX1cbiAgICAgICAgICovXG4gICAgICAgIGZhbGxiYWNrUGxhY2VtZW50OiB7XG4gICAgICAgICAgICB0eXBlOiBbU3RyaW5nLCBBcnJheV0sXG4gICAgICAgICAgICBkZWZhdWx0OiAnZmxpcCdcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogT2Zmc2V0IG9mIHRoZSBwb3BvdmVyIHJlbGF0aXZlIHRvIGl0cyB0YXJnZXQuIEZvciBtb3JlIGluZm9ybWF0aW9uXG4gICAgICAgICAqIHJlZmVyIHRvIFBvcHBlci5qcydzIG9mZnNldCBkb2NzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfFN0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIG9mZnNldDoge1xuICAgICAgICAgICAgdHlwZTogW051bWJlciwgU3RyaW5nXSxcbiAgICAgICAgICAgIGRlZmF1bHQ6IDBcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSG93IHRvIHBvc2l0aW9uIHRoZSBwb3BvdmVyIC0gYXV0byB8IHRvcCB8IGJvdHRvbSB8IGxlZnQgfCByaWdodC5cbiAgICAgICAgICpcbiAgICAgICAgICogV2hlbiBhdXRvIGlzIHNwZWNpZmllZCwgaXQgd2lsbCBkeW5hbWljYWxseSByZW9yaWVudCB0aGUgcG9wb3Zlci5cbiAgICAgICAgICpcbiAgICAgICAgICogV2hlbiBhIGZ1bmN0aW9uIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSBwbGFjZW1lbnQsIGl0IGlzIGNhbGxlZCB3aXRoXG4gICAgICAgICAqIHRoZSBwb3BvdmVyIERPTSBub2RlIGFzIGl0cyBmaXJzdCBhcmd1bWVudCBhbmQgdGhlIHRyaWdnZXJpbmcgZWxlbWVudFxuICAgICAgICAgKiBET00gbm9kZSBhcyBpdHMgc2Vjb25kLiBUaGUgdGhpcyBjb250ZXh0IGlzIHNldCB0byB0aGUgcG9wb3ZlclxuICAgICAgICAgKiBpbnN0YW5jZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge1N0cmluZ3xGdW5jdGlvbn1cbiAgICAgICAgICovXG4gICAgICAgIHBsYWNlbWVudDoge1xuICAgICAgICAgICAgdHlwZTogW1N0cmluZywgRnVuY3Rpb25dLFxuICAgICAgICAgICAgZGVmYXVsdDogJ3RvcCcsXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbJ2F1dG8nLCAndG9wJywgJ2JvdHRvbScsICdsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZih2YWx1ZSkgIT09IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGlzIHByb3BlcnR5IGlzIHBhc3NlZCwgaXQgd2lsbCBmb3JjZSB0aGUgcG9wb3ZlciB0byBiZSB2aXNpYmxlXG4gICAgICAgICAqIGJ5IGRlZmF1bHQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgc2hvdzogQm9vbGVhbixcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgYSBzZWxlY3RvciBpcyBwcm92aWRlZCwgcG9wb3ZlciBvYmplY3RzIHdpbGwgYmUgZGVsZWdhdGVkIHRvIHRoZVxuICAgICAgICAgKiBzcGVjaWZpZWQgdGFyZ2V0cy4gSW4gcHJhY3RpY2UsIHRoaXMgaXMgdXNlZCB0byBlbmFibGUgZHluYW1pYyBIVE1MXG4gICAgICAgICAqIGNvbnRlbnQgdG8gaGF2ZSBwb3BvdmVycyBhZGRlZC4gU2VlIHRoaXMgYW5kIGFuIGluZm9ybWF0aXZlIGV4YW1wbGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufFN0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHNlbGVjdG9yOiB7XG4gICAgICAgICAgICB0eXBlOiBbQm9vbGVhbiwgU3RyaW5nXSxcbiAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0YXJnZXQgZWxlbWVudCB1c2VkIHRvIHBvc2l0aW9uIHRoZSBwb3BvdmVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfEVsZW1lbnR8Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRhcmdldDoge1xuICAgICAgICAgICAgdHlwZTogW1N0cmluZywgRWxlbWVudCwgQm9vbGVhbl0sXG4gICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcG9wb3ZlciB0aXRsZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGl0bGU6IFN0cmluZyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSG93IHBvcG92ZXIgaXMgdHJpZ2dlcmVkIC0gY2xpY2sgfCBob3ZlciB8IGZvY3VzIHwgbWFudWFsLiBZb3UgbWF5XG4gICAgICAgICAqIHBhc3MgbXVsdGlwbGUgdHJpZ2dlcnM7IHNlcGFyYXRlIHRoZW0gd2l0aCBhIHNwYWNlLiBgbWFudWFsYCBjYW5ub3RcbiAgICAgICAgICogYmUgY29tYmluZWQgd2l0aCBhbnkgb3RoZXIgdHJpZ2dlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRyaWdnZXI6IHtcbiAgICAgICAgICAgIHR5cGU6IFtTdHJpbmcsIEFycmF5XSxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdjbGljaydcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIG1ldGhvZHM6IHtcblxuICAgICAgICBhbGlnbigpIHtcbiAgICAgICAgICAgIGVhY2godGhpcy4kcG9wcGVycywgZWwgPT4ge1xuICAgICAgICAgICAgICAgIGVsLnBvcHBlci51cGRhdGUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZVBvcHBlcihlbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb3BwZXIoZWwsIHRoaXMuJGVsLCB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgICAgICBwbGFjZW1lbnQ6IHRoaXMucGxhY2VtZW50LFxuICAgICAgICAgICAgICAgIG1vZGlmaWVyczoge1xuICAgICAgICAgICAgICAgICAgICBmbGlwOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib3VuZGFyaWVzRWxlbWVudDogdGhpcy5jb250YWluZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBiZWhhdmlvcjogdGhpcy5mYWxsYmFja1BsYWNlbWVudFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuYWJsZWQ6ICEhdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGFycm93OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yKCcuYXJyb3cnKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0QXJyb3dFbGVtZW50KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3IoJy5hcnJvdycpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbml0aWFsaXplIHRoZSB0cmlnZ2VyIGV2ZW50IGZvciB0aGUgc3BlY2lmaWVkIGVsZW1lbnRzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSAge0VsZW1lbnR9IGVsXG4gICAgICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICAgICAqL1xuICAgICAgICBpbml0aWFsaXplVHJpZ2dlcihlbCkge1xuICAgICAgICAgICAgdGhpcy4kcG9wcGVyc1tlbF0gPSB7XG4gICAgICAgICAgICAgICAgdHJpZ2dlcjogaXNTdHJpbmcodGhpcy50cmlnZ2VyKSA/IHRoaXMudHJpZ2dlci5zcGxpdCgnICcpIDogdGhpcy50cmlnZ2VyLFxuICAgICAgICAgICAgICAgIHBvcHBlcjogdGhpcy5jcmVhdGVQb3BwZXIoZWwpLFxuICAgICAgICAgICAgICAgIGV2ZW50OiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b2dnbGUoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kcG9wcGVyc1tlbF0ucG9wcGVyLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGVhY2godGhpcy4kcG9wcGVyc1tlbF0udHJpZ2dlciwgdHJpZ2dlciA9PiB7XG4gICAgICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcih0cmlnZ2VyLCB0aGlzLiRwb3BwZXJzW2VsXS5ldmVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIHdhdGNoOiB7XG5cbiAgICAgICAgaXNTaG93aW5nKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLiRuZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hbGlnbigpO1xuXG4gICAgICAgICAgICAgICAgaWYodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mb2N1cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgY29tcHV0ZWQ6IHtcblxuICAgICAgICBjbGFzc2VzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHByZWZpeCh7XG4gICAgICAgICAgICAgICAgJ3RvcCc6IHRoaXMucGxhY2VtZW50ID09PSAndG9wJyxcbiAgICAgICAgICAgICAgICAnYm90dG9tJzogdGhpcy5wbGFjZW1lbnQgPT09ICdib3R0b20nLFxuICAgICAgICAgICAgICAgICdsZWZ0JzogdGhpcy5wbGFjZW1lbnQgPT09ICdsZWZ0JyxcbiAgICAgICAgICAgICAgICAncmlnaHQnOiB0aGlzLnBsYWNlbWVudCA9PT0gJ3JpZ2h0J1xuICAgICAgICAgICAgfSwgJ2JzLXBvcG92ZXInKTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGJlZm9yZUNyZWF0ZSgpIHtcbiAgICAgICAgaWYoIXRoaXMuJHBvcHBlcnMpIHtcbiAgICAgICAgICAgIHRoaXMuJHBvcHBlcnMgPSB7fTtcbiAgICAgICAgfVxuICAgIH1cblxufTtcbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICAgIDxkaXYgY2xhc3M9XCJwb3BvdmVyLWJvZHlcIj5cbiAgICAgICAgPHNsb3QvPlxuICAgIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdwb3BvdmVyLWJvZHknXG5cbn07XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgICA8Y29tcG9uZW50IDppcz1cInRhZ1wiIGNsYXNzPVwicG9wb3Zlci1oZWFkZXJcIj5cbiAgICAgICAgPHNsb3QvPlxuICAgIDwvY29tcG9uZW50PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdwb3BvdmVyLWhlYWRlcicsXG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY29tcG9uZW50IEhUTUwgZWxlbWVudFxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGFnOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAnaDMnXG4gICAgICAgIH1cblxuICAgIH1cblxufTtcbjwvc2NyaXB0PlxuIiwiaW1wb3J0IFBvcG92ZXIgZnJvbSAnLi9Qb3BvdmVyJztcbmltcG9ydCBQb3BvdmVyQm9keSBmcm9tICcuL1BvcG92ZXJCb2R5JztcbmltcG9ydCBQb3BvdmVySGVhZGVyIGZyb20gJy4vUG9wb3ZlckhlYWRlcic7XG5pbXBvcnQgVnVlSW5zdGFsbGVyIGZyb20gJy4uLy4uL0hlbHBlcnMvVnVlSW5zdGFsbGVyL1Z1ZUluc3RhbGxlcic7XG5cbmNvbnN0IHBsdWdpbiA9IFZ1ZUluc3RhbGxlci51c2Uoe1xuXG4gICAgaW5zdGFsbChWdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgVnVlSW5zdGFsbGVyLmNvbXBvbmVudHMoe1xuICAgICAgICAgICAgUG9wb3ZlcixcbiAgICAgICAgICAgIFBvcG92ZXJCb2R5LFxuICAgICAgICAgICAgUG9wb3ZlckhlYWRlclxuICAgICAgICB9KTtcbiAgICB9XG5cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBQb3BvdmVyO1xuIiwiaW1wb3J0IHsgaXNPYmplY3QgfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IHsgZGVmYXVsdHNEZWVwIH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCBpbnN0YW50aWF0ZSBmcm9tICcuLi8uLi9IZWxwZXJzL0luc3RhbnRpYXRlJztcbmltcG9ydCBQb3BvdmVyIGZyb20gJy4uLy4uL0NvbXBvbmVudHMvUG9wb3Zlcic7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKFZ1ZSwgb3B0aW9ucykge1xuICAgIFZ1ZS5wcm90b3R5cGUuJHBvcG92ZXIgPSBmdW5jdGlvbih0YXJnZXQsIENvbXBvbmVudCwgb3B0aW9ucykge1xuICAgICAgICBpZighaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCF0YXJnZXQuJHBvcG92ZXIpIHtcbiAgICAgICAgICAgIHRhcmdldC4kcG9wb3ZlciA9IGluc3RhbnRpYXRlKFZ1ZSwgUG9wb3ZlciwgZGVmYXVsdHNEZWVwKG9wdGlvbnMucG9wb3Zlciwge1xuICAgICAgICAgICAgICAgIHByb3BzRGF0YToge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHRhcmdldFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgdGFyZ2V0LiRwb3BvdmVyLiRtb3VudChcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgY29uc3QgY29udGVudCA9IGluc3RhbnRpYXRlKFZ1ZSwgQ29tcG9uZW50LCBvcHRpb25zLmNvbnRlbnQpO1xuXG4gICAgICAgICAgICB0YXJnZXQuJHBvcG92ZXIuJHNsb3RzLmRlZmF1bHQgPSBbY29udGVudC4kbW91bnQoKS5fdm5vZGVdO1xuICAgICAgICAgICAgdGFyZ2V0LiRwb3BvdmVyLiRuZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LiRwb3BvdmVyLm9wZW4oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldC4kcG9wb3ZlcjtcbiAgICB9O1xufVxuIiwiPHRlbXBsYXRlPlxuICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiY2xvc2VcIiBkYXRhLWRpc21pc3M9XCJhbGVydFwiIGFyaWEtbGFiZWw9XCJDbG9zZVwiIEBjbGljaz1cIm9uQ2xpY2tcIj5cbiAgICAgICAgPHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCI+JnRpbWVzOzwvc3Bhbj5cbiAgICA8L2J1dHRvbj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAnYWxlcnQtY2xvc2UnLFxuXG4gICAgbWV0aG9kczoge1xuXG4gICAgICAgIG9uQ2xpY2soZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2NsaWNrJywgZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgIH1cblxufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gICAgPGg0IGNsYXNzPVwiYWxlcnQtaGVhZGluZ1wiPjxzbG90Lz48L2g0PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdhbGVydC1oZWFkaW5nJ1xuXG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgICA8ZGl2IGNsYXNzPVwicHJvZ3Jlc3NcIiA6c3R5bGU9XCJ7J2hlaWdodCc6IGZvcm1hdHRlZEhlaWdodH1cIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInByb2dyZXNzLWJhclwiIHJvbGU9XCJwcm9ncmVzc2JhclwiIDpzdHlsZT1cInN0eWxlc1wiIDpjbGFzcz1cIm1lcmdlQ2xhc3Nlcyhwcm9ncmVzc0NsYXNzZXMsIHZhcmlhbnRDbGFzcylcIiA6YXJpYS12YWx1ZW5vdz1cIm9mZnNldFZhbHVlXCIgOmFyaWEtdmFsdWVtaW49XCJtaW5cIiA6YXJpYS12YWx1ZW1heD1cIm1heFwiPlxuICAgICAgICAgICAgPHNwYW4gdi1pZj1cIiEhbGFiZWxcIj48dGVtcGxhdGUgdi1pZj1cImxhYmVsICE9PSB0cnVlXCI+e3tsYWJlbH19PC90ZW1wbGF0ZT4ge3tvZmZzZXRWYWx1ZX19JTwvc3Bhbj5cbiAgICAgICAgICAgIDxzcGFuIHYtZWxzZT48c2xvdC8+PC9zcGFuPlxuICAgICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgeyBpc051bWJlciB9IGZyb20gJ2xvZGFzaC1lcydcbmltcG9ydCB1bml0IGZyb20gJy4uLy4uL0hlbHBlcnMvVW5pdCc7XG5pbXBvcnQgVmFyaWFudCBmcm9tICcuLi8uLi9NaXhpbnMvVmFyaWFudCc7XG5pbXBvcnQgTWVyZ2VDbGFzc2VzIGZyb20gJy4uLy4uL01peGlucy9NZXJnZUNsYXNzZXMnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAncHJvZ3Jlc3MtYmFyJyxcblxuICAgIG1peGluczogW1xuICAgICAgICBWYXJpYW50LFxuICAgICAgICBNZXJnZUNsYXNzZXNcbiAgICBdLFxuXG4gICAgcHJvcHM6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBjdXN0b20gY29sb3IgdG8gYmUgYXBwbGllZCBpbmxpbmUgaW4gdGhlIHN0eWxlcyB2cyBhIGNvbnRleHR1YWxcbiAgICAgICAgICogdmFyaWFudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgY29sb3I6IFN0cmluZyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHByb2dyZXNzIGJhciBwZXJjZW50YWdlIHZhbHVlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBwcm9ncmVzcyBiYXJcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgaGVpZ2h0OiBbTnVtYmVyLCBTdHJpbmddLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG93IHRoZSBwcm9ncmVzcyBiYXIgdmFsdWUgYXMgYSBsYWJlbCBpbnNpZGUgdGhlIGJhclxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBsYWJlbDogW1N0cmluZywgQm9vbGVhbl0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3VsZCB0aGUgcHJvZ3Jlc3MgYmFyIGFwcGVhciB3aXRoIHN0cmlwZXNcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgc3RyaXBlZDogQm9vbGVhbixcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvdWxkIHRoZSBwcm9ncmVzcyBiYXIgYXBwZWFyIHdpdGggYW5pbWF0ZWQgc3RyaXBlc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBhbmltYXRlZDogQm9vbGVhbixcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1pbmltdW0gdmFsdWVcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgbWluOiB7XG4gICAgICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgICAgICBkZWZhdWx0OiAwXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtYXggdmFsdWVcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgbWF4OiB7XG4gICAgICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgICAgICBkZWZhdWx0OiAxMDBcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGNvbXB1dGVkOiB7XG5cbiAgICAgICAgdmFyaWFudENsYXNzUHJlZml4KCkge1xuICAgICAgICAgICAgcmV0dXJuICdiZyc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb2Zmc2V0VmFsdWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSAvIHRoaXMubWF4ICogMTAwO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZvcm1hdHRlZEhlaWdodCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhlaWdodCA/IHVuaXQodGhpcy5oZWlnaHQpIDogbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICBwcm9ncmVzc0NsYXNzZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICdwcm9ncmVzcy1iYXItc3RyaXBlZCc6IHRoaXMuc3RyaXBlZCxcbiAgICAgICAgICAgICAgICAncHJvZ3Jlc3MtYmFyLWFuaW1hdGVkJzogdGhpcy5hbmltYXRlZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBzdHlsZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiBgJHt0aGlzLm9mZnNldFZhbHVlfSVgLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6IGAke3RoaXMuY29sb3J9ICFpbXBvcnRhbnRgXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICB9XG5cbn1cblxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgUHJvZ3Jlc3NCYXIgZnJvbSAnLi9Qcm9ncmVzc0Jhcic7XG5pbXBvcnQgVnVlSW5zdGFsbGVyIGZyb20gJy4uLy4uL0hlbHBlcnMvVnVlSW5zdGFsbGVyL1Z1ZUluc3RhbGxlcic7XG5cbmNvbnN0IHBsdWdpbiA9IFZ1ZUluc3RhbGxlci51c2Uoe1xuXG4gICAgaW5zdGFsbChWdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgVnVlSW5zdGFsbGVyLmNvbXBvbmVudHMoe1xuICAgICAgICAgICAgUHJvZ3Jlc3NCYXJcbiAgICAgICAgfSk7XG4gICAgfVxuXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgUHJvZ3Jlc3NCYXI7XG4iLCI8dGVtcGxhdGU+XG4gICAgPGRpdiBjbGFzcz1cImFsZXJ0XCIgOmNsYXNzPVwibWVyZ2VDbGFzc2VzKHZhcmlhbnRDbGFzcywge3Nob3c6IGlzVmlzaWJsZSwgZmFkZTogZmFkZX0pXCIgcm9sZT1cImFsZXJ0XCI+XG4gICAgICAgIDxhbGVydC1oZWFkaW5nIHYtaWY9XCJ0aXRsZSB8fCBoZWFkaW5nXCI+e3sgdGl0bGUgfHwgaGVhZGluZyB9fTwvYWxlcnQtaGVhZGluZz5cbiAgICAgICAgPHNsb3QvPlxuICAgICAgICA8YWxlcnQtY2xvc2Ugdi1pZj1cImRpc21pc3NpYmxlXCIgQGNsaWNrPVwiZGlzbWlzcygpXCIvPlxuICAgICAgICA8cHJvZ3Jlc3MtYmFyIHYtaWY9XCJ0eXBlb2Ygc2hvdyA9PT0gJ251bWJlcidcIiA6dmFyaWFudD1cInZhcmlhbnRcIiA6aGVpZ2h0PVwiNVwiIDp2YWx1ZT1cImRpc21pc3NDb3VudFwiIDptYXg9XCJzaG93XCIgY2xhc3M9XCJteS0zXCIvPlxuICAgIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBBbGVydENsb3NlIGZyb20gJy4vQWxlcnRDbG9zZSc7XG5pbXBvcnQgQWxlcnRIZWFkaW5nIGZyb20gJy4vQWxlcnRIZWFkaW5nJztcbmltcG9ydCBQcm9ncmVzc0JhciBmcm9tICcuLi9Qcm9ncmVzc0Jhcic7XG5pbXBvcnQgVmFyaWFudCBmcm9tICcuLi8uLi9NaXhpbnMvVmFyaWFudCc7XG5pbXBvcnQgdHJhbnNpdGlvbiBmcm9tICcuLi8uLi9IZWxwZXJzL1RyYW5zaXRpb24nO1xuaW1wb3J0IE1lcmdlQ2xhc3NlcyBmcm9tICcuLi8uLi9NaXhpbnMvTWVyZ2VDbGFzc2VzJztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ2FsZXJ0JyxcblxuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgICAgQWxlcnRDbG9zZSxcbiAgICAgICAgQWxlcnRIZWFkaW5nLFxuICAgICAgICBQcm9ncmVzc0JhclxuICAgIH0sXG5cbiAgICBtaXhpbnM6IFtcbiAgICAgICAgVmFyaWFudCxcbiAgICAgICAgTWVyZ2VDbGFzc2VzXG4gICAgXSxcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElzIHRoZSBhbGVydCBkaXNtaXNzaWJsZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgQm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgZGlzbWlzc2libGU6IEJvb2xlYW4sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhbGVydCdzIHRpdGxlL2hlYWRpbmdcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IEJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIGhlYWRpbmc6IFN0cmluZyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGFsZXJ0J3MgdGl0bGUvaGVhZGluZ1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgQm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgdGl0bGU6IFN0cmluZyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvdWxkIHRoZSBhbGVydCBmYWRlIHdoZW4gaGlkZGVuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBCb29sZWFuXG4gICAgICAgICAqL1xuICAgICAgICBmYWRlOiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG91bGQgdGhlIGFsZXJ0IGJlIHZpc2libGUgYnkgZGVmYXVsdC4gSWYgcGFzc2VkIGEgbnVtYmVyLCBhbGVydFxuICAgICAgICAgKiB3aWxsIGJlIHNob3duIGZvciB0aGUgbnVtYmVyIG9mIHNlY29uZHMgdGhhdCBhcmUgcGFzc2VkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgQm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgc2hvdzoge1xuICAgICAgICAgICAgdHlwZTogW051bWJlciwgQm9vbGVhbl0sXG4gICAgICAgICAgICBkZWZhdWx0OiB0cnVlXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBtZXRob2RzOiB7XG5cbiAgICAgICAgZGlzbWlzcygpIHtcbiAgICAgICAgICAgIHRyYW5zaXRpb24odGhpcy4kZWwpLnRoZW4oZGVsYXkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2Rpc21pc3NlZCcpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ3VwZGF0ZTp2aXNpYmxlJywgdGhpcy5pc1Zpc2libGUgPSBmYWxzZSk7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBtb3VudGVkKCkge1xuICAgICAgICBpZih0eXBlb2YgdGhpcy5zaG93ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgY29uc3QgZWwgPSB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yKCcucHJvZ3Jlc3MtYmFyJyk7XG5cbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2Rpc21pc3MtY291bnRkb3duJywgdGhpcy5kaXNtaXNzQ291bnQgPSB0aGlzLnNob3cpO1xuXG4gICAgICAgICAgICBjb25zdCBpbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdkaXNtaXNzLWNvdW50ZG93bicsIHRoaXMuZGlzbWlzc0NvdW50IC09IDEpO1xuXG4gICAgICAgICAgICAgICAgaWYoIXRoaXMuZGlzbWlzc0NvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uKGVsKS50aGVuKGRlbGF5ID0+IHRoaXMuZGlzbWlzcygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAxMDAwKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGlzbWlzc0NvdW50OiB0aGlzLnNob3csXG4gICAgICAgICAgICBpc1Zpc2libGU6IHRoaXMuc2hvd1xuICAgICAgICB9XG4gICAgfVxuXG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgICA8YSBjbGFzcz1cImFsZXJ0LWxpbmtcIj48c2xvdC8+PC9hPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdhbGVydC1saW5rJ1xuXG59XG48L3NjcmlwdD5cbiIsImltcG9ydCBBbGVydCBmcm9tICcuL0FsZXJ0JztcbmltcG9ydCBBbGVydExpbmsgZnJvbSAnLi9BbGVydExpbmsnO1xuaW1wb3J0IEFsZXJ0Q2xvc2UgZnJvbSAnLi9BbGVydENsb3NlJztcbmltcG9ydCBBbGVydEhlYWRpbmcgZnJvbSAnLi9BbGVydEhlYWRpbmcnO1xuaW1wb3J0IFZ1ZUluc3RhbGxlciBmcm9tICcuLi8uLi9IZWxwZXJzL1Z1ZUluc3RhbGxlci9WdWVJbnN0YWxsZXInO1xuXG5jb25zdCBwbHVnaW4gPSBWdWVJbnN0YWxsZXIudXNlKHtcblxuICAgIGluc3RhbGwoVnVlLCBvcHRpb25zKSB7XG4gICAgICAgIFZ1ZUluc3RhbGxlci5jb21wb25lbnRzKHtcbiAgICAgICAgICAgIEFsZXJ0LFxuICAgICAgICAgICAgQWxlcnRMaW5rLFxuICAgICAgICAgICAgQWxlcnRDbG9zZSxcbiAgICAgICAgICAgIEFsZXJ0SGVhZGluZ1xuICAgICAgICB9KTtcbiAgICB9XG5cbn0pO1xuXG5leHBvcnQgKiBmcm9tICcuL0FsZXJ0TGluayc7XG5leHBvcnQgKiBmcm9tICcuL0FsZXJ0Q2xvc2UnO1xuZXhwb3J0ICogZnJvbSAnLi9BbGVydEhlYWRpbmcnO1xuZXhwb3J0IGRlZmF1bHQgQWxlcnQ7XG4iLCI8dGVtcGxhdGU+XG4gICAgPGEgdi1pZj1cImhyZWZcIiA6aHJlZj1cImhyZWZcIiBjbGFzcz1cImJhZGdlXCIgOmNsYXNzPVwibWVyZ2VDbGFzc2VzKGNsYXNzZXMsIHZhcmlhbnRDbGFzcylcIj5cbiAgICAgICAgPHNsb3Q+e3tsYWJlbH19PC9zbG90PlxuICAgICAgICA8c3BhbiBjbGFzcz1cInNyLW9ubHlcIiB2LWh0bWw9XCJhY2Nlc3NpYmlsaXR5XCIvPlxuICAgIDwvYT5cbiAgICA8c3BhbiB2LWVsc2UgY2xhc3M9XCJiYWRnZVwiIDpjbGFzcz1cIm1lcmdlQ2xhc3NlcyhjbGFzc2VzLCB2YXJpYW50Q2xhc3MpXCI+XG4gICAgICAgIDxzbG90Pnt7bGFiZWx9fTwvc2xvdD5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJzci1vbmx5XCIgdi1odG1sPVwiYWNjZXNzaWJpbGl0eVwiLz5cbiAgICA8L3NwYW4+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuXG5pbXBvcnQgcHJlZml4IGZyb20gJy4uLy4uL0hlbHBlcnMvUHJlZml4JztcbmltcG9ydCBWYXJpYW50IGZyb20gJy4uLy4uL01peGlucy9WYXJpYW50JztcbmltcG9ydCBNZXJnZUNsYXNzZXMgZnJvbSAnLi4vLi4vTWl4aW5zL01lcmdlQ2xhc3Nlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdiYWRnZScsXG5cbiAgICBtaXhpbnM6IFtcbiAgICAgICAgVmFyaWFudCxcbiAgICAgICAgTWVyZ2VDbGFzc2VzXG4gICAgXSxcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzY3JlZW4gcmVhZGVyIGFjY2Vzc2liaWxpdHkgbGFiZWwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGFjY2Vzc2liaWxpdHk6IFN0cmluZyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgYW4gaHJlZiBhdHRyaWJ1dGUgaXMgcGFzc2VkLCB0aGUgYmFkZ2UgYmVjb21lcyBhbiBhbmNob3IuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGhyZWY6IFN0cmluZyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGJhZGdlIGFwcGVhciBhcyBwaWxsIHNoYXBlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgcGlsbDogQm9vbGVhbixcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGJhZGdlIGxhYmVsLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBsYWJlbDogW051bWJlciwgU3RyaW5nXSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGJhZGdlIGFwcGVhciBhcyBzZWNvbmRhcnkgaW4gc2l6ZSB0byB0aGUgcGFyZW50IGVsZW1lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHNlY29uZGFyeTogQm9vbGVhblxuXG4gICAgfSxcblxuICAgIGNvbXB1dGVkOiB7XG5cbiAgICAgICAgY2xhc3NlcygpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmVmaXgoe1xuICAgICAgICAgICAgICAgICdwaWxsJzogdGhpcy5waWxsLFxuICAgICAgICAgICAgICAgICdzZWNvbmRhcnknOiB0aGlzLnNlY29uZGFyeVxuICAgICAgICAgICAgfSwgdGhpcy4kb3B0aW9ucy5uYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgQmFkZ2UgZnJvbSAnLi9CYWRnZSc7XG5pbXBvcnQgVnVlSW5zdGFsbGVyIGZyb20gJy4uLy4uL0hlbHBlcnMvVnVlSW5zdGFsbGVyL1Z1ZUluc3RhbGxlcic7XG5cbmNvbnN0IHBsdWdpbiA9IFZ1ZUluc3RhbGxlci51c2Uoe1xuXG4gICAgaW5zdGFsbChWdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgVnVlSW5zdGFsbGVyLmNvbXBvbmVudHMoe1xuICAgICAgICAgICAgQmFkZ2VcbiAgICAgICAgfSk7XG4gICAgfVxuXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgQmFkZ2U7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlZHVjZWAgYW5kIGBfLnJlZHVjZVJpZ2h0YCwgd2l0aG91dCBzdXBwb3J0XG4gKiBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcywgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgY29sbGVjdGlvbmAgdXNpbmcgYGVhY2hGdW5jYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7Kn0gYWNjdW11bGF0b3IgVGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaXRBY2N1bSBTcGVjaWZ5IHVzaW5nIHRoZSBmaXJzdCBvciBsYXN0IGVsZW1lbnQgb2ZcbiAqICBgY29sbGVjdGlvbmAgYXMgdGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGBjb2xsZWN0aW9uYC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZVJlZHVjZShjb2xsZWN0aW9uLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSwgZWFjaEZ1bmMpIHtcbiAgZWFjaEZ1bmMoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgYWNjdW11bGF0b3IgPSBpbml0QWNjdW1cbiAgICAgID8gKGluaXRBY2N1bSA9IGZhbHNlLCB2YWx1ZSlcbiAgICAgIDogaXRlcmF0ZWUoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gIH0pO1xuICByZXR1cm4gYWNjdW11bGF0b3I7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VSZWR1Y2U7XG4iLCJpbXBvcnQgYXJyYXlSZWR1Y2UgZnJvbSAnLi9fYXJyYXlSZWR1Y2UuanMnO1xuaW1wb3J0IGJhc2VFYWNoIGZyb20gJy4vX2Jhc2VFYWNoLmpzJztcbmltcG9ydCBiYXNlSXRlcmF0ZWUgZnJvbSAnLi9fYmFzZUl0ZXJhdGVlLmpzJztcbmltcG9ydCBiYXNlUmVkdWNlIGZyb20gJy4vX2Jhc2VSZWR1Y2UuanMnO1xuaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5LmpzJztcblxuLyoqXG4gKiBSZWR1Y2VzIGBjb2xsZWN0aW9uYCB0byBhIHZhbHVlIHdoaWNoIGlzIHRoZSBhY2N1bXVsYXRlZCByZXN1bHQgb2YgcnVubmluZ1xuICogZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCB0aHJ1IGBpdGVyYXRlZWAsIHdoZXJlIGVhY2ggc3VjY2Vzc2l2ZVxuICogaW52b2NhdGlvbiBpcyBzdXBwbGllZCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBwcmV2aW91cy4gSWYgYGFjY3VtdWxhdG9yYFxuICogaXMgbm90IGdpdmVuLCB0aGUgZmlyc3QgZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgaXMgdXNlZCBhcyB0aGUgaW5pdGlhbFxuICogdmFsdWUuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggZm91ciBhcmd1bWVudHM6XG4gKiAoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICpcbiAqIE1hbnkgbG9kYXNoIG1ldGhvZHMgYXJlIGd1YXJkZWQgdG8gd29yayBhcyBpdGVyYXRlZXMgZm9yIG1ldGhvZHMgbGlrZVxuICogYF8ucmVkdWNlYCwgYF8ucmVkdWNlUmlnaHRgLCBhbmQgYF8udHJhbnNmb3JtYC5cbiAqXG4gKiBUaGUgZ3VhcmRlZCBtZXRob2RzIGFyZTpcbiAqIGBhc3NpZ25gLCBgZGVmYXVsdHNgLCBgZGVmYXVsdHNEZWVwYCwgYGluY2x1ZGVzYCwgYG1lcmdlYCwgYG9yZGVyQnlgLFxuICogYW5kIGBzb3J0QnlgXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICogQHNlZSBfLnJlZHVjZVJpZ2h0XG4gKiBAZXhhbXBsZVxuICpcbiAqIF8ucmVkdWNlKFsxLCAyXSwgZnVuY3Rpb24oc3VtLCBuKSB7XG4gKiAgIHJldHVybiBzdW0gKyBuO1xuICogfSwgMCk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5yZWR1Y2UoeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAxIH0sIGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICogICAocmVzdWx0W3ZhbHVlXSB8fCAocmVzdWx0W3ZhbHVlXSA9IFtdKSkucHVzaChrZXkpO1xuICogICByZXR1cm4gcmVzdWx0O1xuICogfSwge30pO1xuICogLy8gPT4geyAnMSc6IFsnYScsICdjJ10sICcyJzogWydiJ10gfSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICovXG5mdW5jdGlvbiByZWR1Y2UoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5UmVkdWNlIDogYmFzZVJlZHVjZSxcbiAgICAgIGluaXRBY2N1bSA9IGFyZ3VtZW50cy5sZW5ndGggPCAzO1xuXG4gIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGJhc2VJdGVyYXRlZShpdGVyYXRlZSwgNCksIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0sIGJhc2VFYWNoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgcmVkdWNlO1xuIiwiaW1wb3J0IGJhc2VQcm9wZXJ0eSBmcm9tICcuL19iYXNlUHJvcGVydHkuanMnO1xuXG4vKipcbiAqIEdldHMgdGhlIHNpemUgb2YgYW4gQVNDSUkgYHN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyBpbnNwZWN0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3RyaW5nIHNpemUuXG4gKi9cbnZhciBhc2NpaVNpemUgPSBiYXNlUHJvcGVydHkoJ2xlbmd0aCcpO1xuXG5leHBvcnQgZGVmYXVsdCBhc2NpaVNpemU7XG4iLCIvKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2hhcmFjdGVyIGNsYXNzZXMuICovXG52YXIgcnNBc3RyYWxSYW5nZSA9ICdcXFxcdWQ4MDAtXFxcXHVkZmZmJyxcbiAgICByc0NvbWJvTWFya3NSYW5nZSA9ICdcXFxcdTAzMDAtXFxcXHUwMzZmJyxcbiAgICByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgPSAnXFxcXHVmZTIwLVxcXFx1ZmUyZicsXG4gICAgcnNDb21ib1N5bWJvbHNSYW5nZSA9ICdcXFxcdTIwZDAtXFxcXHUyMGZmJyxcbiAgICByc0NvbWJvUmFuZ2UgPSByc0NvbWJvTWFya3NSYW5nZSArIHJlQ29tYm9IYWxmTWFya3NSYW5nZSArIHJzQ29tYm9TeW1ib2xzUmFuZ2UsXG4gICAgcnNWYXJSYW5nZSA9ICdcXFxcdWZlMGVcXFxcdWZlMGYnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2FwdHVyZSBncm91cHMuICovXG52YXIgcnNBc3RyYWwgPSAnWycgKyByc0FzdHJhbFJhbmdlICsgJ10nLFxuICAgIHJzQ29tYm8gPSAnWycgKyByc0NvbWJvUmFuZ2UgKyAnXScsXG4gICAgcnNGaXR6ID0gJ1xcXFx1ZDgzY1tcXFxcdWRmZmItXFxcXHVkZmZmXScsXG4gICAgcnNNb2RpZmllciA9ICcoPzonICsgcnNDb21ibyArICd8JyArIHJzRml0eiArICcpJyxcbiAgICByc05vbkFzdHJhbCA9ICdbXicgKyByc0FzdHJhbFJhbmdlICsgJ10nLFxuICAgIHJzUmVnaW9uYWwgPSAnKD86XFxcXHVkODNjW1xcXFx1ZGRlNi1cXFxcdWRkZmZdKXsyfScsXG4gICAgcnNTdXJyUGFpciA9ICdbXFxcXHVkODAwLVxcXFx1ZGJmZl1bXFxcXHVkYzAwLVxcXFx1ZGZmZl0nLFxuICAgIHJzWldKID0gJ1xcXFx1MjAwZCc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSByZWdleGVzLiAqL1xudmFyIHJlT3B0TW9kID0gcnNNb2RpZmllciArICc/JyxcbiAgICByc09wdFZhciA9ICdbJyArIHJzVmFyUmFuZ2UgKyAnXT8nLFxuICAgIHJzT3B0Sm9pbiA9ICcoPzonICsgcnNaV0ogKyAnKD86JyArIFtyc05vbkFzdHJhbCwgcnNSZWdpb25hbCwgcnNTdXJyUGFpcl0uam9pbignfCcpICsgJyknICsgcnNPcHRWYXIgKyByZU9wdE1vZCArICcpKicsXG4gICAgcnNTZXEgPSByc09wdFZhciArIHJlT3B0TW9kICsgcnNPcHRKb2luLFxuICAgIHJzU3ltYm9sID0gJyg/OicgKyBbcnNOb25Bc3RyYWwgKyByc0NvbWJvICsgJz8nLCByc0NvbWJvLCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyLCByc0FzdHJhbF0uam9pbignfCcpICsgJyknO1xuXG4vKiogVXNlZCB0byBtYXRjaCBbc3RyaW5nIHN5bWJvbHNdKGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LXVuaWNvZGUpLiAqL1xudmFyIHJlVW5pY29kZSA9IFJlZ0V4cChyc0ZpdHogKyAnKD89JyArIHJzRml0eiArICcpfCcgKyByc1N5bWJvbCArIHJzU2VxLCAnZycpO1xuXG4vKipcbiAqIEdldHMgdGhlIHNpemUgb2YgYSBVbmljb2RlIGBzdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN0cmluZyBzaXplLlxuICovXG5mdW5jdGlvbiB1bmljb2RlU2l6ZShzdHJpbmcpIHtcbiAgdmFyIHJlc3VsdCA9IHJlVW5pY29kZS5sYXN0SW5kZXggPSAwO1xuICB3aGlsZSAocmVVbmljb2RlLnRlc3Qoc3RyaW5nKSkge1xuICAgICsrcmVzdWx0O1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHVuaWNvZGVTaXplO1xuIiwiaW1wb3J0IGFzY2lpU2l6ZSBmcm9tICcuL19hc2NpaVNpemUuanMnO1xuaW1wb3J0IGhhc1VuaWNvZGUgZnJvbSAnLi9faGFzVW5pY29kZS5qcyc7XG5pbXBvcnQgdW5pY29kZVNpemUgZnJvbSAnLi9fdW5pY29kZVNpemUuanMnO1xuXG4vKipcbiAqIEdldHMgdGhlIG51bWJlciBvZiBzeW1ib2xzIGluIGBzdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN0cmluZyBzaXplLlxuICovXG5mdW5jdGlvbiBzdHJpbmdTaXplKHN0cmluZykge1xuICByZXR1cm4gaGFzVW5pY29kZShzdHJpbmcpXG4gICAgPyB1bmljb2RlU2l6ZShzdHJpbmcpXG4gICAgOiBhc2NpaVNpemUoc3RyaW5nKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3RyaW5nU2l6ZTtcbiIsImltcG9ydCBiYXNlS2V5cyBmcm9tICcuL19iYXNlS2V5cy5qcyc7XG5pbXBvcnQgZ2V0VGFnIGZyb20gJy4vX2dldFRhZy5qcyc7XG5pbXBvcnQgaXNBcnJheUxpa2UgZnJvbSAnLi9pc0FycmF5TGlrZS5qcyc7XG5pbXBvcnQgaXNTdHJpbmcgZnJvbSAnLi9pc1N0cmluZy5qcyc7XG5pbXBvcnQgc3RyaW5nU2l6ZSBmcm9tICcuL19zdHJpbmdTaXplLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nO1xuXG4vKipcbiAqIEdldHMgdGhlIHNpemUgb2YgYGNvbGxlY3Rpb25gIGJ5IHJldHVybmluZyBpdHMgbGVuZ3RoIGZvciBhcnJheS1saWtlXG4gKiB2YWx1ZXMgb3IgdGhlIG51bWJlciBvZiBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBmb3Igb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb2xsZWN0aW9uIHNpemUuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uc2l6ZShbMSwgMiwgM10pO1xuICogLy8gPT4gM1xuICpcbiAqIF8uc2l6ZSh7ICdhJzogMSwgJ2InOiAyIH0pO1xuICogLy8gPT4gMlxuICpcbiAqIF8uc2l6ZSgncGViYmxlcycpO1xuICogLy8gPT4gN1xuICovXG5mdW5jdGlvbiBzaXplKGNvbGxlY3Rpb24pIHtcbiAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGlmIChpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgIHJldHVybiBpc1N0cmluZyhjb2xsZWN0aW9uKSA/IHN0cmluZ1NpemUoY29sbGVjdGlvbikgOiBjb2xsZWN0aW9uLmxlbmd0aDtcbiAgfVxuICB2YXIgdGFnID0gZ2V0VGFnKGNvbGxlY3Rpb24pO1xuICBpZiAodGFnID09IG1hcFRhZyB8fCB0YWcgPT0gc2V0VGFnKSB7XG4gICAgcmV0dXJuIGNvbGxlY3Rpb24uc2l6ZTtcbiAgfVxuICByZXR1cm4gYmFzZUtleXMoY29sbGVjdGlvbikubGVuZ3RoO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzaXplO1xuIiwiaW1wb3J0IGNvcHlPYmplY3QgZnJvbSAnLi9fY29weU9iamVjdC5qcyc7XG5pbXBvcnQga2V5cyBmcm9tICcuL2tleXMuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbmAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzXG4gKiBvciBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnbihvYmplY3QsIHNvdXJjZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VBc3NpZ247XG4iLCJpbXBvcnQgY29weU9iamVjdCBmcm9tICcuL19jb3B5T2JqZWN0LmpzJztcbmltcG9ydCBrZXlzSW4gZnJvbSAnLi9rZXlzSW4uanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbkluYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXNcbiAqIG9yIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduSW4ob2JqZWN0LCBzb3VyY2UpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBjb3B5T2JqZWN0KHNvdXJjZSwga2V5c0luKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VBc3NpZ25JbjtcbiIsImltcG9ydCBjb3B5T2JqZWN0IGZyb20gJy4vX2NvcHlPYmplY3QuanMnO1xuaW1wb3J0IGdldFN5bWJvbHMgZnJvbSAnLi9fZ2V0U3ltYm9scy5qcyc7XG5cbi8qKlxuICogQ29waWVzIG93biBzeW1ib2xzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIGZyb20uXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgdG8uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5U3ltYm9scyhzb3VyY2UsIG9iamVjdCkge1xuICByZXR1cm4gY29weU9iamVjdChzb3VyY2UsIGdldFN5bWJvbHMoc291cmNlKSwgb2JqZWN0KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY29weVN5bWJvbHM7XG4iLCJpbXBvcnQgY29weU9iamVjdCBmcm9tICcuL19jb3B5T2JqZWN0LmpzJztcbmltcG9ydCBnZXRTeW1ib2xzSW4gZnJvbSAnLi9fZ2V0U3ltYm9sc0luLmpzJztcblxuLyoqXG4gKiBDb3BpZXMgb3duIGFuZCBpbmhlcml0ZWQgc3ltYm9scyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyBmcm9tLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIHRvLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weVN5bWJvbHNJbihzb3VyY2UsIG9iamVjdCkge1xuICByZXR1cm4gY29weU9iamVjdChzb3VyY2UsIGdldFN5bWJvbHNJbihzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjb3B5U3ltYm9sc0luO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBhcnJheSBjbG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNsb25lLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lQXJyYXkoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IG5ldyBhcnJheS5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gIC8vIEFkZCBwcm9wZXJ0aWVzIGFzc2lnbmVkIGJ5IGBSZWdFeHAjZXhlY2AuXG4gIGlmIChsZW5ndGggJiYgdHlwZW9mIGFycmF5WzBdID09ICdzdHJpbmcnICYmIGhhc093blByb3BlcnR5LmNhbGwoYXJyYXksICdpbmRleCcpKSB7XG4gICAgcmVzdWx0LmluZGV4ID0gYXJyYXkuaW5kZXg7XG4gICAgcmVzdWx0LmlucHV0ID0gYXJyYXkuaW5wdXQ7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaW5pdENsb25lQXJyYXk7XG4iLCJpbXBvcnQgY2xvbmVBcnJheUJ1ZmZlciBmcm9tICcuL19jbG9uZUFycmF5QnVmZmVyLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGRhdGFWaWV3YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFWaWV3IFRoZSBkYXRhIHZpZXcgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIGRhdGEgdmlldy5cbiAqL1xuZnVuY3Rpb24gY2xvbmVEYXRhVmlldyhkYXRhVmlldywgaXNEZWVwKSB7XG4gIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKGRhdGFWaWV3LmJ1ZmZlcikgOiBkYXRhVmlldy5idWZmZXI7XG4gIHJldHVybiBuZXcgZGF0YVZpZXcuY29uc3RydWN0b3IoYnVmZmVyLCBkYXRhVmlldy5ieXRlT2Zmc2V0LCBkYXRhVmlldy5ieXRlTGVuZ3RoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xvbmVEYXRhVmlldztcbiIsIi8qKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgIGZsYWdzIGZyb20gdGhlaXIgY29lcmNlZCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlRmxhZ3MgPSAvXFx3KiQvO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgcmVnZXhwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHJlZ2V4cCBUaGUgcmVnZXhwIHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHJlZ2V4cC5cbiAqL1xuZnVuY3Rpb24gY2xvbmVSZWdFeHAocmVnZXhwKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgcmVnZXhwLmNvbnN0cnVjdG9yKHJlZ2V4cC5zb3VyY2UsIHJlRmxhZ3MuZXhlYyhyZWdleHApKTtcbiAgcmVzdWx0Lmxhc3RJbmRleCA9IHJlZ2V4cC5sYXN0SW5kZXg7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsb25lUmVnRXhwO1xuIiwiaW1wb3J0IFN5bWJvbCBmcm9tICcuL19TeW1ib2wuanMnO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIGBzeW1ib2xgIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHN5bWJvbCBUaGUgc3ltYm9sIG9iamVjdCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBzeW1ib2wgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBjbG9uZVN5bWJvbChzeW1ib2wpIHtcbiAgcmV0dXJuIHN5bWJvbFZhbHVlT2YgPyBPYmplY3Qoc3ltYm9sVmFsdWVPZi5jYWxsKHN5bWJvbCkpIDoge307XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsb25lU3ltYm9sO1xuIiwiaW1wb3J0IGNsb25lQXJyYXlCdWZmZXIgZnJvbSAnLi9fY2xvbmVBcnJheUJ1ZmZlci5qcyc7XG5pbXBvcnQgY2xvbmVEYXRhVmlldyBmcm9tICcuL19jbG9uZURhdGFWaWV3LmpzJztcbmltcG9ydCBjbG9uZVJlZ0V4cCBmcm9tICcuL19jbG9uZVJlZ0V4cC5qcyc7XG5pbXBvcnQgY2xvbmVTeW1ib2wgZnJvbSAnLi9fY2xvbmVTeW1ib2wuanMnO1xuaW1wb3J0IGNsb25lVHlwZWRBcnJheSBmcm9tICcuL19jbG9uZVR5cGVkQXJyYXkuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUgYmFzZWQgb24gaXRzIGB0b1N0cmluZ1RhZ2AuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjbG9uaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTWFwYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBgU2V0YCwgb3IgYFN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lQnlUYWcob2JqZWN0LCB0YWcsIGlzRGVlcCkge1xuICB2YXIgQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgcmV0dXJuIGNsb25lQXJyYXlCdWZmZXIob2JqZWN0KTtcblxuICAgIGNhc2UgYm9vbFRhZzpcbiAgICBjYXNlIGRhdGVUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3IoK29iamVjdCk7XG5cbiAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgcmV0dXJuIGNsb25lRGF0YVZpZXcob2JqZWN0LCBpc0RlZXApO1xuXG4gICAgY2FzZSBmbG9hdDMyVGFnOiBjYXNlIGZsb2F0NjRUYWc6XG4gICAgY2FzZSBpbnQ4VGFnOiBjYXNlIGludDE2VGFnOiBjYXNlIGludDMyVGFnOlxuICAgIGNhc2UgdWludDhUYWc6IGNhc2UgdWludDhDbGFtcGVkVGFnOiBjYXNlIHVpbnQxNlRhZzogY2FzZSB1aW50MzJUYWc6XG4gICAgICByZXR1cm4gY2xvbmVUeXBlZEFycmF5KG9iamVjdCwgaXNEZWVwKTtcblxuICAgIGNhc2UgbWFwVGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yO1xuXG4gICAgY2FzZSBudW1iZXJUYWc6XG4gICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3Iob2JqZWN0KTtcblxuICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgICAgcmV0dXJuIGNsb25lUmVnRXhwKG9iamVjdCk7XG5cbiAgICBjYXNlIHNldFRhZzpcbiAgICAgIHJldHVybiBuZXcgQ3RvcjtcblxuICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgcmV0dXJuIGNsb25lU3ltYm9sKG9iamVjdCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgaW5pdENsb25lQnlUYWc7XG4iLCJpbXBvcnQgZ2V0VGFnIGZyb20gJy4vX2dldFRhZy5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWFwYCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG1hcCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNNYXAodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgZ2V0VGFnKHZhbHVlKSA9PSBtYXBUYWc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VJc01hcDtcbiIsImltcG9ydCBiYXNlSXNNYXAgZnJvbSAnLi9fYmFzZUlzTWFwLmpzJztcbmltcG9ydCBiYXNlVW5hcnkgZnJvbSAnLi9fYmFzZVVuYXJ5LmpzJztcbmltcG9ydCBub2RlVXRpbCBmcm9tICcuL19ub2RlVXRpbC5qcyc7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzTWFwID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNNYXA7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBNYXBgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG1hcCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTWFwKG5ldyBNYXApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNNYXAobmV3IFdlYWtNYXApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzTWFwID0gbm9kZUlzTWFwID8gYmFzZVVuYXJ5KG5vZGVJc01hcCkgOiBiYXNlSXNNYXA7XG5cbmV4cG9ydCBkZWZhdWx0IGlzTWFwO1xuIiwiaW1wb3J0IGdldFRhZyBmcm9tICcuL19nZXRUYWcuanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzZXRUYWcgPSAnW29iamVjdCBTZXRdJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1NldGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzZXQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzU2V0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gc2V0VGFnO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlSXNTZXQ7XG4iLCJpbXBvcnQgYmFzZUlzU2V0IGZyb20gJy4vX2Jhc2VJc1NldC5qcyc7XG5pbXBvcnQgYmFzZVVuYXJ5IGZyb20gJy4vX2Jhc2VVbmFyeS5qcyc7XG5pbXBvcnQgbm9kZVV0aWwgZnJvbSAnLi9fbm9kZVV0aWwuanMnO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1NldCA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzU2V0O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU2V0YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzZXQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1NldChuZXcgU2V0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU2V0KG5ldyBXZWFrU2V0KTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1NldCA9IG5vZGVJc1NldCA/IGJhc2VVbmFyeShub2RlSXNTZXQpIDogYmFzZUlzU2V0O1xuXG5leHBvcnQgZGVmYXVsdCBpc1NldDtcbiIsImltcG9ydCBTdGFjayBmcm9tICcuL19TdGFjay5qcyc7XG5pbXBvcnQgYXJyYXlFYWNoIGZyb20gJy4vX2FycmF5RWFjaC5qcyc7XG5pbXBvcnQgYXNzaWduVmFsdWUgZnJvbSAnLi9fYXNzaWduVmFsdWUuanMnO1xuaW1wb3J0IGJhc2VBc3NpZ24gZnJvbSAnLi9fYmFzZUFzc2lnbi5qcyc7XG5pbXBvcnQgYmFzZUFzc2lnbkluIGZyb20gJy4vX2Jhc2VBc3NpZ25Jbi5qcyc7XG5pbXBvcnQgY2xvbmVCdWZmZXIgZnJvbSAnLi9fY2xvbmVCdWZmZXIuanMnO1xuaW1wb3J0IGNvcHlBcnJheSBmcm9tICcuL19jb3B5QXJyYXkuanMnO1xuaW1wb3J0IGNvcHlTeW1ib2xzIGZyb20gJy4vX2NvcHlTeW1ib2xzLmpzJztcbmltcG9ydCBjb3B5U3ltYm9sc0luIGZyb20gJy4vX2NvcHlTeW1ib2xzSW4uanMnO1xuaW1wb3J0IGdldEFsbEtleXMgZnJvbSAnLi9fZ2V0QWxsS2V5cy5qcyc7XG5pbXBvcnQgZ2V0QWxsS2V5c0luIGZyb20gJy4vX2dldEFsbEtleXNJbi5qcyc7XG5pbXBvcnQgZ2V0VGFnIGZyb20gJy4vX2dldFRhZy5qcyc7XG5pbXBvcnQgaW5pdENsb25lQXJyYXkgZnJvbSAnLi9faW5pdENsb25lQXJyYXkuanMnO1xuaW1wb3J0IGluaXRDbG9uZUJ5VGFnIGZyb20gJy4vX2luaXRDbG9uZUJ5VGFnLmpzJztcbmltcG9ydCBpbml0Q2xvbmVPYmplY3QgZnJvbSAnLi9faW5pdENsb25lT2JqZWN0LmpzJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5pbXBvcnQgaXNCdWZmZXIgZnJvbSAnLi9pc0J1ZmZlci5qcyc7XG5pbXBvcnQgaXNNYXAgZnJvbSAnLi9pc01hcC5qcyc7XG5pbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdC5qcyc7XG5pbXBvcnQgaXNTZXQgZnJvbSAnLi9pc1NldC5qcyc7XG5pbXBvcnQga2V5cyBmcm9tICcuL2tleXMuanMnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xudmFyIENMT05FX0RFRVBfRkxBRyA9IDEsXG4gICAgQ0xPTkVfRkxBVF9GTEFHID0gMixcbiAgICBDTE9ORV9TWU1CT0xTX0ZMQUcgPSA0O1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIHN1cHBvcnRlZCBieSBgXy5jbG9uZWAuICovXG52YXIgY2xvbmVhYmxlVGFncyA9IHt9O1xuY2xvbmVhYmxlVGFnc1thcmdzVGFnXSA9IGNsb25lYWJsZVRhZ3NbYXJyYXlUYWddID1cbmNsb25lYWJsZVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gY2xvbmVhYmxlVGFnc1tkYXRhVmlld1RhZ10gPVxuY2xvbmVhYmxlVGFnc1tib29sVGFnXSA9IGNsb25lYWJsZVRhZ3NbZGF0ZVRhZ10gPVxuY2xvbmVhYmxlVGFnc1tmbG9hdDMyVGFnXSA9IGNsb25lYWJsZVRhZ3NbZmxvYXQ2NFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbaW50MTZUYWddID1cbmNsb25lYWJsZVRhZ3NbaW50MzJUYWddID0gY2xvbmVhYmxlVGFnc1ttYXBUYWddID1cbmNsb25lYWJsZVRhZ3NbbnVtYmVyVGFnXSA9IGNsb25lYWJsZVRhZ3Nbb2JqZWN0VGFnXSA9XG5jbG9uZWFibGVUYWdzW3JlZ2V4cFRhZ10gPSBjbG9uZWFibGVUYWdzW3NldFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tzdHJpbmdUYWddID0gY2xvbmVhYmxlVGFnc1tzeW1ib2xUYWddID1cbmNsb25lYWJsZVRhZ3NbdWludDhUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50OENsYW1wZWRUYWddID1cbmNsb25lYWJsZVRhZ3NbdWludDE2VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG5jbG9uZWFibGVUYWdzW2Vycm9yVGFnXSA9IGNsb25lYWJsZVRhZ3NbZnVuY1RhZ10gPVxuY2xvbmVhYmxlVGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNsb25lYCBhbmQgYF8uY2xvbmVEZWVwYCB3aGljaCB0cmFja3NcbiAqIHRyYXZlcnNlZCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAqICAxIC0gRGVlcCBjbG9uZVxuICogIDIgLSBGbGF0dGVuIGluaGVyaXRlZCBwcm9wZXJ0aWVzXG4gKiAgNCAtIENsb25lIHN5bWJvbHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2tleV0gVGhlIGtleSBvZiBgdmFsdWVgLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBwYXJlbnQgb2JqZWN0IG9mIGB2YWx1ZWAuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIG9iamVjdHMgYW5kIHRoZWlyIGNsb25lIGNvdW50ZXJwYXJ0cy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VDbG9uZSh2YWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCBvYmplY3QsIHN0YWNrKSB7XG4gIHZhciByZXN1bHQsXG4gICAgICBpc0RlZXAgPSBiaXRtYXNrICYgQ0xPTkVfREVFUF9GTEFHLFxuICAgICAgaXNGbGF0ID0gYml0bWFzayAmIENMT05FX0ZMQVRfRkxBRyxcbiAgICAgIGlzRnVsbCA9IGJpdG1hc2sgJiBDTE9ORV9TWU1CT0xTX0ZMQUc7XG5cbiAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICByZXN1bHQgPSBvYmplY3QgPyBjdXN0b21pemVyKHZhbHVlLCBrZXksIG9iamVjdCwgc3RhY2spIDogY3VzdG9taXplcih2YWx1ZSk7XG4gIH1cbiAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKTtcbiAgaWYgKGlzQXJyKSB7XG4gICAgcmVzdWx0ID0gaW5pdENsb25lQXJyYXkodmFsdWUpO1xuICAgIGlmICghaXNEZWVwKSB7XG4gICAgICByZXR1cm4gY29weUFycmF5KHZhbHVlLCByZXN1bHQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKSxcbiAgICAgICAgaXNGdW5jID0gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZztcblxuICAgIGlmIChpc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjbG9uZUJ1ZmZlcih2YWx1ZSwgaXNEZWVwKTtcbiAgICB9XG4gICAgaWYgKHRhZyA9PSBvYmplY3RUYWcgfHwgdGFnID09IGFyZ3NUYWcgfHwgKGlzRnVuYyAmJiAhb2JqZWN0KSkge1xuICAgICAgcmVzdWx0ID0gKGlzRmxhdCB8fCBpc0Z1bmMpID8ge30gOiBpbml0Q2xvbmVPYmplY3QodmFsdWUpO1xuICAgICAgaWYgKCFpc0RlZXApIHtcbiAgICAgICAgcmV0dXJuIGlzRmxhdFxuICAgICAgICAgID8gY29weVN5bWJvbHNJbih2YWx1ZSwgYmFzZUFzc2lnbkluKHJlc3VsdCwgdmFsdWUpKVxuICAgICAgICAgIDogY29weVN5bWJvbHModmFsdWUsIGJhc2VBc3NpZ24ocmVzdWx0LCB2YWx1ZSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWNsb25lYWJsZVRhZ3NbdGFnXSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0ID8gdmFsdWUgOiB7fTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGluaXRDbG9uZUJ5VGFnKHZhbHVlLCB0YWcsIGlzRGVlcCk7XG4gICAgfVxuICB9XG4gIC8vIENoZWNrIGZvciBjaXJjdWxhciByZWZlcmVuY2VzIGFuZCByZXR1cm4gaXRzIGNvcnJlc3BvbmRpbmcgY2xvbmUuXG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KHZhbHVlKTtcbiAgaWYgKHN0YWNrZWQpIHtcbiAgICByZXR1cm4gc3RhY2tlZDtcbiAgfVxuICBzdGFjay5zZXQodmFsdWUsIHJlc3VsdCk7XG5cbiAgaWYgKGlzU2V0KHZhbHVlKSkge1xuICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24oc3ViVmFsdWUpIHtcbiAgICAgIHJlc3VsdC5hZGQoYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdWJWYWx1ZSwgdmFsdWUsIHN0YWNrKSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKGlzTWFwKHZhbHVlKSkge1xuICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24oc3ViVmFsdWUsIGtleSkge1xuICAgICAgcmVzdWx0LnNldChrZXksIGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCB2YWx1ZSwgc3RhY2spKTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIga2V5c0Z1bmMgPSBpc0Z1bGxcbiAgICA/IChpc0ZsYXQgPyBnZXRBbGxLZXlzSW4gOiBnZXRBbGxLZXlzKVxuICAgIDogKGlzRmxhdCA/IGtleXNJbiA6IGtleXMpO1xuXG4gIHZhciBwcm9wcyA9IGlzQXJyID8gdW5kZWZpbmVkIDoga2V5c0Z1bmModmFsdWUpO1xuICBhcnJheUVhY2gocHJvcHMgfHwgdmFsdWUsIGZ1bmN0aW9uKHN1YlZhbHVlLCBrZXkpIHtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgIGtleSA9IHN1YlZhbHVlO1xuICAgICAgc3ViVmFsdWUgPSB2YWx1ZVtrZXldO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBwb3B1bGF0ZSBjbG9uZSAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCBiYXNlQ2xvbmUoc3ViVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGtleSwgdmFsdWUsIHN0YWNrKSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlQ2xvbmU7XG4iLCJpbXBvcnQgYmFzZUNsb25lIGZyb20gJy4vX2Jhc2VDbG9uZS5qcyc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGNsb25pbmcuICovXG52YXIgQ0xPTkVfREVFUF9GTEFHID0gMSxcbiAgICBDTE9ORV9TWU1CT0xTX0ZMQUcgPSA0O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uY2xvbmVgIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IGNsb25lcyBgdmFsdWVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMS4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZWN1cnNpdmVseSBjbG9uZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBkZWVwIGNsb25lZCB2YWx1ZS5cbiAqIEBzZWUgXy5jbG9uZVxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IFt7ICdhJzogMSB9LCB7ICdiJzogMiB9XTtcbiAqXG4gKiB2YXIgZGVlcCA9IF8uY2xvbmVEZWVwKG9iamVjdHMpO1xuICogY29uc29sZS5sb2coZGVlcFswXSA9PT0gb2JqZWN0c1swXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBjbG9uZURlZXAodmFsdWUpIHtcbiAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfREVFUF9GTEFHIHwgQ0xPTkVfU1lNQk9MU19GTEFHKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xvbmVEZWVwO1xuIiwiLyoqXG4gKiBHZXRzIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGFsaWFzIGZpcnN0XG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaGVhZChbMSwgMiwgM10pO1xuICogLy8gPT4gMVxuICpcbiAqIF8uaGVhZChbXSk7XG4gKiAvLyA9PiB1bmRlZmluZWRcbiAqL1xuZnVuY3Rpb24gaGVhZChhcnJheSkge1xuICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkgPyBhcnJheVswXSA6IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaGVhZDtcbiIsImltcG9ydCBXZWFrTWFwIGZyb20gJy4vX1dlYWtNYXAuanMnO1xuXG4vKiogVXNlZCB0byBzdG9yZSBmdW5jdGlvbiBtZXRhZGF0YS4gKi9cbnZhciBtZXRhTWFwID0gV2Vha01hcCAmJiBuZXcgV2Vha01hcDtcblxuZXhwb3J0IGRlZmF1bHQgbWV0YU1hcDtcbiIsImltcG9ydCBpZGVudGl0eSBmcm9tICcuL2lkZW50aXR5LmpzJztcbmltcG9ydCBtZXRhTWFwIGZyb20gJy4vX21ldGFNYXAuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBzZXREYXRhYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIHNob3J0aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhc3NvY2lhdGUgbWV0YWRhdGEgd2l0aC5cbiAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWV0YWRhdGEuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovXG52YXIgYmFzZVNldERhdGEgPSAhbWV0YU1hcCA/IGlkZW50aXR5IDogZnVuY3Rpb24oZnVuYywgZGF0YSkge1xuICBtZXRhTWFwLnNldChmdW5jLCBkYXRhKTtcbiAgcmV0dXJuIGZ1bmM7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBiYXNlU2V0RGF0YTtcbiIsImltcG9ydCBiYXNlQ3JlYXRlIGZyb20gJy4vX2Jhc2VDcmVhdGUuanMnO1xuaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHByb2R1Y2VzIGFuIGluc3RhbmNlIG9mIGBDdG9yYCByZWdhcmRsZXNzIG9mXG4gKiB3aGV0aGVyIGl0IHdhcyBpbnZva2VkIGFzIHBhcnQgb2YgYSBgbmV3YCBleHByZXNzaW9uIG9yIGJ5IGBjYWxsYCBvciBgYXBwbHlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBDdG9yIFRoZSBjb25zdHJ1Y3RvciB0byB3cmFwLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ3RvcihDdG9yKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAvLyBVc2UgYSBgc3dpdGNoYCBzdGF0ZW1lbnQgdG8gd29yayB3aXRoIGNsYXNzIGNvbnN0cnVjdG9ycy4gU2VlXG4gICAgLy8gaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1mdW5jdGlvbi1vYmplY3RzLWNhbGwtdGhpc2FyZ3VtZW50LWFyZ3VtZW50c2xpc3RcbiAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyBDdG9yO1xuICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSk7XG4gICAgICBjYXNlIDI6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgIGNhc2UgMzogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgY2FzZSA0OiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gICAgICBjYXNlIDU6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdKTtcbiAgICAgIGNhc2UgNjogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10sIGFyZ3NbNF0sIGFyZ3NbNV0pO1xuICAgICAgY2FzZSA3OiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSwgYXJnc1s0XSwgYXJnc1s1XSwgYXJnc1s2XSk7XG4gICAgfVxuICAgIHZhciB0aGlzQmluZGluZyA9IGJhc2VDcmVhdGUoQ3Rvci5wcm90b3R5cGUpLFxuICAgICAgICByZXN1bHQgPSBDdG9yLmFwcGx5KHRoaXNCaW5kaW5nLCBhcmdzKTtcblxuICAgIC8vIE1pbWljIHRoZSBjb25zdHJ1Y3RvcidzIGByZXR1cm5gIGJlaGF2aW9yLlxuICAgIC8vIFNlZSBodHRwczovL2VzNS5naXRodWIuaW8vI3gxMy4yLjIgZm9yIG1vcmUgZGV0YWlscy5cbiAgICByZXR1cm4gaXNPYmplY3QocmVzdWx0KSA/IHJlc3VsdCA6IHRoaXNCaW5kaW5nO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVDdG9yO1xuIiwiaW1wb3J0IGNyZWF0ZUN0b3IgZnJvbSAnLi9fY3JlYXRlQ3Rvci5qcyc7XG5pbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgZnVuY3Rpb24gbWV0YWRhdGEuICovXG52YXIgV1JBUF9CSU5EX0ZMQUcgPSAxO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCB0byBpbnZva2UgaXQgd2l0aCB0aGUgb3B0aW9uYWwgYHRoaXNgXG4gKiBiaW5kaW5nIG9mIGB0aGlzQXJnYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmluZChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnKSB7XG4gIHZhciBpc0JpbmQgPSBiaXRtYXNrICYgV1JBUF9CSU5EX0ZMQUcsXG4gICAgICBDdG9yID0gY3JlYXRlQ3RvcihmdW5jKTtcblxuICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgIHZhciBmbiA9ICh0aGlzICYmIHRoaXMgIT09IHJvb3QgJiYgdGhpcyBpbnN0YW5jZW9mIHdyYXBwZXIpID8gQ3RvciA6IGZ1bmM7XG4gICAgcmV0dXJuIGZuLmFwcGx5KGlzQmluZCA/IHRoaXNBcmcgOiB0aGlzLCBhcmd1bWVudHMpO1xuICB9XG4gIHJldHVybiB3cmFwcGVyO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVCaW5kO1xuIiwiLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgdGhhdCBpcyB0aGUgY29tcG9zaXRpb24gb2YgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLFxuICogcGxhY2Vob2xkZXJzLCBhbmQgcHJvdmlkZWQgYXJndW1lbnRzIGludG8gYSBzaW5nbGUgYXJyYXkgb2YgYXJndW1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBwcm92aWRlZCBhcmd1bWVudHMuXG4gKiBAcGFyYW0ge0FycmF5fSBwYXJ0aWFscyBUaGUgYXJndW1lbnRzIHRvIHByZXBlbmQgdG8gdGhvc2UgcHJvdmlkZWQuXG4gKiBAcGFyYW0ge0FycmF5fSBob2xkZXJzIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gKiBAcGFyYW1zIHtib29sZWFufSBbaXNDdXJyaWVkXSBTcGVjaWZ5IGNvbXBvc2luZyBmb3IgYSBjdXJyaWVkIGZ1bmN0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tcG9zZWQgYXJndW1lbnRzLlxuICovXG5mdW5jdGlvbiBjb21wb3NlQXJncyhhcmdzLCBwYXJ0aWFscywgaG9sZGVycywgaXNDdXJyaWVkKSB7XG4gIHZhciBhcmdzSW5kZXggPSAtMSxcbiAgICAgIGFyZ3NMZW5ndGggPSBhcmdzLmxlbmd0aCxcbiAgICAgIGhvbGRlcnNMZW5ndGggPSBob2xkZXJzLmxlbmd0aCxcbiAgICAgIGxlZnRJbmRleCA9IC0xLFxuICAgICAgbGVmdExlbmd0aCA9IHBhcnRpYWxzLmxlbmd0aCxcbiAgICAgIHJhbmdlTGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3NMZW5ndGggLSBob2xkZXJzTGVuZ3RoLCAwKSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlZnRMZW5ndGggKyByYW5nZUxlbmd0aCksXG4gICAgICBpc1VuY3VycmllZCA9ICFpc0N1cnJpZWQ7XG5cbiAgd2hpbGUgKCsrbGVmdEluZGV4IDwgbGVmdExlbmd0aCkge1xuICAgIHJlc3VsdFtsZWZ0SW5kZXhdID0gcGFydGlhbHNbbGVmdEluZGV4XTtcbiAgfVxuICB3aGlsZSAoKythcmdzSW5kZXggPCBob2xkZXJzTGVuZ3RoKSB7XG4gICAgaWYgKGlzVW5jdXJyaWVkIHx8IGFyZ3NJbmRleCA8IGFyZ3NMZW5ndGgpIHtcbiAgICAgIHJlc3VsdFtob2xkZXJzW2FyZ3NJbmRleF1dID0gYXJnc1thcmdzSW5kZXhdO1xuICAgIH1cbiAgfVxuICB3aGlsZSAocmFuZ2VMZW5ndGgtLSkge1xuICAgIHJlc3VsdFtsZWZ0SW5kZXgrK10gPSBhcmdzW2FyZ3NJbmRleCsrXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjb21wb3NlQXJncztcbiIsIi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGNvbXBvc2VBcmdzYCBleGNlcHQgdGhhdCB0aGUgYXJndW1lbnRzIGNvbXBvc2l0aW9uXG4gKiBpcyB0YWlsb3JlZCBmb3IgYF8ucGFydGlhbFJpZ2h0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgcHJvdmlkZWQgYXJndW1lbnRzLlxuICogQHBhcmFtIHtBcnJheX0gcGFydGlhbHMgVGhlIGFyZ3VtZW50cyB0byBhcHBlbmQgdG8gdGhvc2UgcHJvdmlkZWQuXG4gKiBAcGFyYW0ge0FycmF5fSBob2xkZXJzIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gKiBAcGFyYW1zIHtib29sZWFufSBbaXNDdXJyaWVkXSBTcGVjaWZ5IGNvbXBvc2luZyBmb3IgYSBjdXJyaWVkIGZ1bmN0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tcG9zZWQgYXJndW1lbnRzLlxuICovXG5mdW5jdGlvbiBjb21wb3NlQXJnc1JpZ2h0KGFyZ3MsIHBhcnRpYWxzLCBob2xkZXJzLCBpc0N1cnJpZWQpIHtcbiAgdmFyIGFyZ3NJbmRleCA9IC0xLFxuICAgICAgYXJnc0xlbmd0aCA9IGFyZ3MubGVuZ3RoLFxuICAgICAgaG9sZGVyc0luZGV4ID0gLTEsXG4gICAgICBob2xkZXJzTGVuZ3RoID0gaG9sZGVycy5sZW5ndGgsXG4gICAgICByaWdodEluZGV4ID0gLTEsXG4gICAgICByaWdodExlbmd0aCA9IHBhcnRpYWxzLmxlbmd0aCxcbiAgICAgIHJhbmdlTGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3NMZW5ndGggLSBob2xkZXJzTGVuZ3RoLCAwKSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KHJhbmdlTGVuZ3RoICsgcmlnaHRMZW5ndGgpLFxuICAgICAgaXNVbmN1cnJpZWQgPSAhaXNDdXJyaWVkO1xuXG4gIHdoaWxlICgrK2FyZ3NJbmRleCA8IHJhbmdlTGVuZ3RoKSB7XG4gICAgcmVzdWx0W2FyZ3NJbmRleF0gPSBhcmdzW2FyZ3NJbmRleF07XG4gIH1cbiAgdmFyIG9mZnNldCA9IGFyZ3NJbmRleDtcbiAgd2hpbGUgKCsrcmlnaHRJbmRleCA8IHJpZ2h0TGVuZ3RoKSB7XG4gICAgcmVzdWx0W29mZnNldCArIHJpZ2h0SW5kZXhdID0gcGFydGlhbHNbcmlnaHRJbmRleF07XG4gIH1cbiAgd2hpbGUgKCsraG9sZGVyc0luZGV4IDwgaG9sZGVyc0xlbmd0aCkge1xuICAgIGlmIChpc1VuY3VycmllZCB8fCBhcmdzSW5kZXggPCBhcmdzTGVuZ3RoKSB7XG4gICAgICByZXN1bHRbb2Zmc2V0ICsgaG9sZGVyc1tob2xkZXJzSW5kZXhdXSA9IGFyZ3NbYXJnc0luZGV4KytdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjb21wb3NlQXJnc1JpZ2h0O1xuIiwiLyoqXG4gKiBHZXRzIHRoZSBudW1iZXIgb2YgYHBsYWNlaG9sZGVyYCBvY2N1cnJlbmNlcyBpbiBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0gcGxhY2Vob2xkZXIgVGhlIHBsYWNlaG9sZGVyIHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBwbGFjZWhvbGRlciBjb3VudC5cbiAqL1xuZnVuY3Rpb24gY291bnRIb2xkZXJzKGFycmF5LCBwbGFjZWhvbGRlcikge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gMDtcblxuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoYXJyYXlbbGVuZ3RoXSA9PT0gcGxhY2Vob2xkZXIpIHtcbiAgICAgICsrcmVzdWx0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjb3VudEhvbGRlcnM7XG4iLCIvKipcbiAqIFRoZSBmdW5jdGlvbiB3aG9zZSBwcm90b3R5cGUgY2hhaW4gc2VxdWVuY2Ugd3JhcHBlcnMgaW5oZXJpdCBmcm9tLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGJhc2VMb2Rhc2goKSB7XG4gIC8vIE5vIG9wZXJhdGlvbiBwZXJmb3JtZWQuXG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VMb2Rhc2g7XG4iLCJpbXBvcnQgYmFzZUNyZWF0ZSBmcm9tICcuL19iYXNlQ3JlYXRlLmpzJztcbmltcG9ydCBiYXNlTG9kYXNoIGZyb20gJy4vX2Jhc2VMb2Rhc2guanMnO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB0aGUgbWF4aW11bSBsZW5ndGggYW5kIGluZGV4IG9mIGFuIGFycmF5LiAqL1xudmFyIE1BWF9BUlJBWV9MRU5HVEggPSA0Mjk0OTY3Mjk1O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBsYXp5IHdyYXBwZXIgb2JqZWN0IHdoaWNoIHdyYXBzIGB2YWx1ZWAgdG8gZW5hYmxlIGxhenkgZXZhbHVhdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICovXG5mdW5jdGlvbiBMYXp5V3JhcHBlcih2YWx1ZSkge1xuICB0aGlzLl9fd3JhcHBlZF9fID0gdmFsdWU7XG4gIHRoaXMuX19hY3Rpb25zX18gPSBbXTtcbiAgdGhpcy5fX2Rpcl9fID0gMTtcbiAgdGhpcy5fX2ZpbHRlcmVkX18gPSBmYWxzZTtcbiAgdGhpcy5fX2l0ZXJhdGVlc19fID0gW107XG4gIHRoaXMuX190YWtlQ291bnRfXyA9IE1BWF9BUlJBWV9MRU5HVEg7XG4gIHRoaXMuX192aWV3c19fID0gW107XG59XG5cbi8vIEVuc3VyZSBgTGF6eVdyYXBwZXJgIGlzIGFuIGluc3RhbmNlIG9mIGBiYXNlTG9kYXNoYC5cbkxhenlXcmFwcGVyLnByb3RvdHlwZSA9IGJhc2VDcmVhdGUoYmFzZUxvZGFzaC5wcm90b3R5cGUpO1xuTGF6eVdyYXBwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGF6eVdyYXBwZXI7XG5cbmV4cG9ydCBkZWZhdWx0IExhenlXcmFwcGVyO1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGB1bmRlZmluZWRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi4zLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5ub29wKTtcbiAqIC8vID0+IFt1bmRlZmluZWQsIHVuZGVmaW5lZF1cbiAqL1xuZnVuY3Rpb24gbm9vcCgpIHtcbiAgLy8gTm8gb3BlcmF0aW9uIHBlcmZvcm1lZC5cbn1cblxuZXhwb3J0IGRlZmF1bHQgbm9vcDtcbiIsImltcG9ydCBtZXRhTWFwIGZyb20gJy4vX21ldGFNYXAuanMnO1xuaW1wb3J0IG5vb3AgZnJvbSAnLi9ub29wLmpzJztcblxuLyoqXG4gKiBHZXRzIG1ldGFkYXRhIGZvciBgZnVuY2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHF1ZXJ5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1ldGFkYXRhIGZvciBgZnVuY2AuXG4gKi9cbnZhciBnZXREYXRhID0gIW1ldGFNYXAgPyBub29wIDogZnVuY3Rpb24oZnVuYykge1xuICByZXR1cm4gbWV0YU1hcC5nZXQoZnVuYyk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBnZXREYXRhO1xuIiwiLyoqIFVzZWQgdG8gbG9va3VwIHVubWluaWZpZWQgZnVuY3Rpb24gbmFtZXMuICovXG52YXIgcmVhbE5hbWVzID0ge307XG5cbmV4cG9ydCBkZWZhdWx0IHJlYWxOYW1lcztcbiIsImltcG9ydCByZWFsTmFtZXMgZnJvbSAnLi9fcmVhbE5hbWVzLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBHZXRzIHRoZSBuYW1lIG9mIGBmdW5jYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBuYW1lLlxuICovXG5mdW5jdGlvbiBnZXRGdW5jTmFtZShmdW5jKSB7XG4gIHZhciByZXN1bHQgPSAoZnVuYy5uYW1lICsgJycpLFxuICAgICAgYXJyYXkgPSByZWFsTmFtZXNbcmVzdWx0XSxcbiAgICAgIGxlbmd0aCA9IGhhc093blByb3BlcnR5LmNhbGwocmVhbE5hbWVzLCByZXN1bHQpID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICB2YXIgZGF0YSA9IGFycmF5W2xlbmd0aF0sXG4gICAgICAgIG90aGVyRnVuYyA9IGRhdGEuZnVuYztcbiAgICBpZiAob3RoZXJGdW5jID09IG51bGwgfHwgb3RoZXJGdW5jID09IGZ1bmMpIHtcbiAgICAgIHJldHVybiBkYXRhLm5hbWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldEZ1bmNOYW1lO1xuIiwiaW1wb3J0IGJhc2VDcmVhdGUgZnJvbSAnLi9fYmFzZUNyZWF0ZS5qcyc7XG5pbXBvcnQgYmFzZUxvZGFzaCBmcm9tICcuL19iYXNlTG9kYXNoLmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBjb25zdHJ1Y3RvciBmb3IgY3JlYXRpbmcgYGxvZGFzaGAgd3JhcHBlciBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICogQHBhcmFtIHtib29sZWFufSBbY2hhaW5BbGxdIEVuYWJsZSBleHBsaWNpdCBtZXRob2QgY2hhaW4gc2VxdWVuY2VzLlxuICovXG5mdW5jdGlvbiBMb2Rhc2hXcmFwcGVyKHZhbHVlLCBjaGFpbkFsbCkge1xuICB0aGlzLl9fd3JhcHBlZF9fID0gdmFsdWU7XG4gIHRoaXMuX19hY3Rpb25zX18gPSBbXTtcbiAgdGhpcy5fX2NoYWluX18gPSAhIWNoYWluQWxsO1xuICB0aGlzLl9faW5kZXhfXyA9IDA7XG4gIHRoaXMuX192YWx1ZXNfXyA9IHVuZGVmaW5lZDtcbn1cblxuTG9kYXNoV3JhcHBlci5wcm90b3R5cGUgPSBiYXNlQ3JlYXRlKGJhc2VMb2Rhc2gucHJvdG90eXBlKTtcbkxvZGFzaFdyYXBwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTG9kYXNoV3JhcHBlcjtcblxuZXhwb3J0IGRlZmF1bHQgTG9kYXNoV3JhcHBlcjtcbiIsImltcG9ydCBMYXp5V3JhcHBlciBmcm9tICcuL19MYXp5V3JhcHBlci5qcyc7XG5pbXBvcnQgTG9kYXNoV3JhcHBlciBmcm9tICcuL19Mb2Rhc2hXcmFwcGVyLmpzJztcbmltcG9ydCBjb3B5QXJyYXkgZnJvbSAnLi9fY29weUFycmF5LmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHdyYXBwZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gd3JhcHBlciBUaGUgd3JhcHBlciB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCB3cmFwcGVyLlxuICovXG5mdW5jdGlvbiB3cmFwcGVyQ2xvbmUod3JhcHBlcikge1xuICBpZiAod3JhcHBlciBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSB7XG4gICAgcmV0dXJuIHdyYXBwZXIuY2xvbmUoKTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gbmV3IExvZGFzaFdyYXBwZXIod3JhcHBlci5fX3dyYXBwZWRfXywgd3JhcHBlci5fX2NoYWluX18pO1xuICByZXN1bHQuX19hY3Rpb25zX18gPSBjb3B5QXJyYXkod3JhcHBlci5fX2FjdGlvbnNfXyk7XG4gIHJlc3VsdC5fX2luZGV4X18gID0gd3JhcHBlci5fX2luZGV4X187XG4gIHJlc3VsdC5fX3ZhbHVlc19fID0gd3JhcHBlci5fX3ZhbHVlc19fO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCB3cmFwcGVyQ2xvbmU7XG4iLCJpbXBvcnQgTGF6eVdyYXBwZXIgZnJvbSAnLi9fTGF6eVdyYXBwZXIuanMnO1xuaW1wb3J0IExvZGFzaFdyYXBwZXIgZnJvbSAnLi9fTG9kYXNoV3JhcHBlci5qcyc7XG5pbXBvcnQgYmFzZUxvZGFzaCBmcm9tICcuL19iYXNlTG9kYXNoLmpzJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcbmltcG9ydCB3cmFwcGVyQ2xvbmUgZnJvbSAnLi9fd3JhcHBlckNsb25lLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgYGxvZGFzaGAgb2JqZWN0IHdoaWNoIHdyYXBzIGB2YWx1ZWAgdG8gZW5hYmxlIGltcGxpY2l0IG1ldGhvZFxuICogY2hhaW4gc2VxdWVuY2VzLiBNZXRob2RzIHRoYXQgb3BlcmF0ZSBvbiBhbmQgcmV0dXJuIGFycmF5cywgY29sbGVjdGlvbnMsXG4gKiBhbmQgZnVuY3Rpb25zIGNhbiBiZSBjaGFpbmVkIHRvZ2V0aGVyLiBNZXRob2RzIHRoYXQgcmV0cmlldmUgYSBzaW5nbGUgdmFsdWVcbiAqIG9yIG1heSByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUgd2lsbCBhdXRvbWF0aWNhbGx5IGVuZCB0aGUgY2hhaW4gc2VxdWVuY2VcbiAqIGFuZCByZXR1cm4gdGhlIHVud3JhcHBlZCB2YWx1ZS4gT3RoZXJ3aXNlLCB0aGUgdmFsdWUgbXVzdCBiZSB1bndyYXBwZWRcbiAqIHdpdGggYF8jdmFsdWVgLlxuICpcbiAqIEV4cGxpY2l0IGNoYWluIHNlcXVlbmNlcywgd2hpY2ggbXVzdCBiZSB1bndyYXBwZWQgd2l0aCBgXyN2YWx1ZWAsIG1heSBiZVxuICogZW5hYmxlZCB1c2luZyBgXy5jaGFpbmAuXG4gKlxuICogVGhlIGV4ZWN1dGlvbiBvZiBjaGFpbmVkIG1ldGhvZHMgaXMgbGF6eSwgdGhhdCBpcywgaXQncyBkZWZlcnJlZCB1bnRpbFxuICogYF8jdmFsdWVgIGlzIGltcGxpY2l0bHkgb3IgZXhwbGljaXRseSBjYWxsZWQuXG4gKlxuICogTGF6eSBldmFsdWF0aW9uIGFsbG93cyBzZXZlcmFsIG1ldGhvZHMgdG8gc3VwcG9ydCBzaG9ydGN1dCBmdXNpb24uXG4gKiBTaG9ydGN1dCBmdXNpb24gaXMgYW4gb3B0aW1pemF0aW9uIHRvIG1lcmdlIGl0ZXJhdGVlIGNhbGxzOyB0aGlzIGF2b2lkc1xuICogdGhlIGNyZWF0aW9uIG9mIGludGVybWVkaWF0ZSBhcnJheXMgYW5kIGNhbiBncmVhdGx5IHJlZHVjZSB0aGUgbnVtYmVyIG9mXG4gKiBpdGVyYXRlZSBleGVjdXRpb25zLiBTZWN0aW9ucyBvZiBhIGNoYWluIHNlcXVlbmNlIHF1YWxpZnkgZm9yIHNob3J0Y3V0XG4gKiBmdXNpb24gaWYgdGhlIHNlY3Rpb24gaXMgYXBwbGllZCB0byBhbiBhcnJheSBhbmQgaXRlcmF0ZWVzIGFjY2VwdCBvbmx5XG4gKiBvbmUgYXJndW1lbnQuIFRoZSBoZXVyaXN0aWMgZm9yIHdoZXRoZXIgYSBzZWN0aW9uIHF1YWxpZmllcyBmb3Igc2hvcnRjdXRcbiAqIGZ1c2lvbiBpcyBzdWJqZWN0IHRvIGNoYW5nZS5cbiAqXG4gKiBDaGFpbmluZyBpcyBzdXBwb3J0ZWQgaW4gY3VzdG9tIGJ1aWxkcyBhcyBsb25nIGFzIHRoZSBgXyN2YWx1ZWAgbWV0aG9kIGlzXG4gKiBkaXJlY3RseSBvciBpbmRpcmVjdGx5IGluY2x1ZGVkIGluIHRoZSBidWlsZC5cbiAqXG4gKiBJbiBhZGRpdGlvbiB0byBsb2Rhc2ggbWV0aG9kcywgd3JhcHBlcnMgaGF2ZSBgQXJyYXlgIGFuZCBgU3RyaW5nYCBtZXRob2RzLlxuICpcbiAqIFRoZSB3cmFwcGVyIGBBcnJheWAgbWV0aG9kcyBhcmU6XG4gKiBgY29uY2F0YCwgYGpvaW5gLCBgcG9wYCwgYHB1c2hgLCBgc2hpZnRgLCBgc29ydGAsIGBzcGxpY2VgLCBhbmQgYHVuc2hpZnRgXG4gKlxuICogVGhlIHdyYXBwZXIgYFN0cmluZ2AgbWV0aG9kcyBhcmU6XG4gKiBgcmVwbGFjZWAgYW5kIGBzcGxpdGBcbiAqXG4gKiBUaGUgd3JhcHBlciBtZXRob2RzIHRoYXQgc3VwcG9ydCBzaG9ydGN1dCBmdXNpb24gYXJlOlxuICogYGF0YCwgYGNvbXBhY3RgLCBgZHJvcGAsIGBkcm9wUmlnaHRgLCBgZHJvcFdoaWxlYCwgYGZpbHRlcmAsIGBmaW5kYCxcbiAqIGBmaW5kTGFzdGAsIGBoZWFkYCwgYGluaXRpYWxgLCBgbGFzdGAsIGBtYXBgLCBgcmVqZWN0YCwgYHJldmVyc2VgLCBgc2xpY2VgLFxuICogYHRhaWxgLCBgdGFrZWAsIGB0YWtlUmlnaHRgLCBgdGFrZVJpZ2h0V2hpbGVgLCBgdGFrZVdoaWxlYCwgYW5kIGB0b0FycmF5YFxuICpcbiAqIFRoZSBjaGFpbmFibGUgd3JhcHBlciBtZXRob2RzIGFyZTpcbiAqIGBhZnRlcmAsIGBhcnlgLCBgYXNzaWduYCwgYGFzc2lnbkluYCwgYGFzc2lnbkluV2l0aGAsIGBhc3NpZ25XaXRoYCwgYGF0YCxcbiAqIGBiZWZvcmVgLCBgYmluZGAsIGBiaW5kQWxsYCwgYGJpbmRLZXlgLCBgY2FzdEFycmF5YCwgYGNoYWluYCwgYGNodW5rYCxcbiAqIGBjb21taXRgLCBgY29tcGFjdGAsIGBjb25jYXRgLCBgY29uZm9ybXNgLCBgY29uc3RhbnRgLCBgY291bnRCeWAsIGBjcmVhdGVgLFxuICogYGN1cnJ5YCwgYGRlYm91bmNlYCwgYGRlZmF1bHRzYCwgYGRlZmF1bHRzRGVlcGAsIGBkZWZlcmAsIGBkZWxheWAsXG4gKiBgZGlmZmVyZW5jZWAsIGBkaWZmZXJlbmNlQnlgLCBgZGlmZmVyZW5jZVdpdGhgLCBgZHJvcGAsIGBkcm9wUmlnaHRgLFxuICogYGRyb3BSaWdodFdoaWxlYCwgYGRyb3BXaGlsZWAsIGBleHRlbmRgLCBgZXh0ZW5kV2l0aGAsIGBmaWxsYCwgYGZpbHRlcmAsXG4gKiBgZmxhdE1hcGAsIGBmbGF0TWFwRGVlcGAsIGBmbGF0TWFwRGVwdGhgLCBgZmxhdHRlbmAsIGBmbGF0dGVuRGVlcGAsXG4gKiBgZmxhdHRlbkRlcHRoYCwgYGZsaXBgLCBgZmxvd2AsIGBmbG93UmlnaHRgLCBgZnJvbVBhaXJzYCwgYGZ1bmN0aW9uc2AsXG4gKiBgZnVuY3Rpb25zSW5gLCBgZ3JvdXBCeWAsIGBpbml0aWFsYCwgYGludGVyc2VjdGlvbmAsIGBpbnRlcnNlY3Rpb25CeWAsXG4gKiBgaW50ZXJzZWN0aW9uV2l0aGAsIGBpbnZlcnRgLCBgaW52ZXJ0QnlgLCBgaW52b2tlTWFwYCwgYGl0ZXJhdGVlYCwgYGtleUJ5YCxcbiAqIGBrZXlzYCwgYGtleXNJbmAsIGBtYXBgLCBgbWFwS2V5c2AsIGBtYXBWYWx1ZXNgLCBgbWF0Y2hlc2AsIGBtYXRjaGVzUHJvcGVydHlgLFxuICogYG1lbW9pemVgLCBgbWVyZ2VgLCBgbWVyZ2VXaXRoYCwgYG1ldGhvZGAsIGBtZXRob2RPZmAsIGBtaXhpbmAsIGBuZWdhdGVgLFxuICogYG50aEFyZ2AsIGBvbWl0YCwgYG9taXRCeWAsIGBvbmNlYCwgYG9yZGVyQnlgLCBgb3ZlcmAsIGBvdmVyQXJnc2AsXG4gKiBgb3ZlckV2ZXJ5YCwgYG92ZXJTb21lYCwgYHBhcnRpYWxgLCBgcGFydGlhbFJpZ2h0YCwgYHBhcnRpdGlvbmAsIGBwaWNrYCxcbiAqIGBwaWNrQnlgLCBgcGxhbnRgLCBgcHJvcGVydHlgLCBgcHJvcGVydHlPZmAsIGBwdWxsYCwgYHB1bGxBbGxgLCBgcHVsbEFsbEJ5YCxcbiAqIGBwdWxsQWxsV2l0aGAsIGBwdWxsQXRgLCBgcHVzaGAsIGByYW5nZWAsIGByYW5nZVJpZ2h0YCwgYHJlYXJnYCwgYHJlamVjdGAsXG4gKiBgcmVtb3ZlYCwgYHJlc3RgLCBgcmV2ZXJzZWAsIGBzYW1wbGVTaXplYCwgYHNldGAsIGBzZXRXaXRoYCwgYHNodWZmbGVgLFxuICogYHNsaWNlYCwgYHNvcnRgLCBgc29ydEJ5YCwgYHNwbGljZWAsIGBzcHJlYWRgLCBgdGFpbGAsIGB0YWtlYCwgYHRha2VSaWdodGAsXG4gKiBgdGFrZVJpZ2h0V2hpbGVgLCBgdGFrZVdoaWxlYCwgYHRhcGAsIGB0aHJvdHRsZWAsIGB0aHJ1YCwgYHRvQXJyYXlgLFxuICogYHRvUGFpcnNgLCBgdG9QYWlyc0luYCwgYHRvUGF0aGAsIGB0b1BsYWluT2JqZWN0YCwgYHRyYW5zZm9ybWAsIGB1bmFyeWAsXG4gKiBgdW5pb25gLCBgdW5pb25CeWAsIGB1bmlvbldpdGhgLCBgdW5pcWAsIGB1bmlxQnlgLCBgdW5pcVdpdGhgLCBgdW5zZXRgLFxuICogYHVuc2hpZnRgLCBgdW56aXBgLCBgdW56aXBXaXRoYCwgYHVwZGF0ZWAsIGB1cGRhdGVXaXRoYCwgYHZhbHVlc2AsXG4gKiBgdmFsdWVzSW5gLCBgd2l0aG91dGAsIGB3cmFwYCwgYHhvcmAsIGB4b3JCeWAsIGB4b3JXaXRoYCwgYHppcGAsXG4gKiBgemlwT2JqZWN0YCwgYHppcE9iamVjdERlZXBgLCBhbmQgYHppcFdpdGhgXG4gKlxuICogVGhlIHdyYXBwZXIgbWV0aG9kcyB0aGF0IGFyZSAqKm5vdCoqIGNoYWluYWJsZSBieSBkZWZhdWx0IGFyZTpcbiAqIGBhZGRgLCBgYXR0ZW1wdGAsIGBjYW1lbENhc2VgLCBgY2FwaXRhbGl6ZWAsIGBjZWlsYCwgYGNsYW1wYCwgYGNsb25lYCxcbiAqIGBjbG9uZURlZXBgLCBgY2xvbmVEZWVwV2l0aGAsIGBjbG9uZVdpdGhgLCBgY29uZm9ybXNUb2AsIGBkZWJ1cnJgLFxuICogYGRlZmF1bHRUb2AsIGBkaXZpZGVgLCBgZWFjaGAsIGBlYWNoUmlnaHRgLCBgZW5kc1dpdGhgLCBgZXFgLCBgZXNjYXBlYCxcbiAqIGBlc2NhcGVSZWdFeHBgLCBgZXZlcnlgLCBgZmluZGAsIGBmaW5kSW5kZXhgLCBgZmluZEtleWAsIGBmaW5kTGFzdGAsXG4gKiBgZmluZExhc3RJbmRleGAsIGBmaW5kTGFzdEtleWAsIGBmaXJzdGAsIGBmbG9vcmAsIGBmb3JFYWNoYCwgYGZvckVhY2hSaWdodGAsXG4gKiBgZm9ySW5gLCBgZm9ySW5SaWdodGAsIGBmb3JPd25gLCBgZm9yT3duUmlnaHRgLCBgZ2V0YCwgYGd0YCwgYGd0ZWAsIGBoYXNgLFxuICogYGhhc0luYCwgYGhlYWRgLCBgaWRlbnRpdHlgLCBgaW5jbHVkZXNgLCBgaW5kZXhPZmAsIGBpblJhbmdlYCwgYGludm9rZWAsXG4gKiBgaXNBcmd1bWVudHNgLCBgaXNBcnJheWAsIGBpc0FycmF5QnVmZmVyYCwgYGlzQXJyYXlMaWtlYCwgYGlzQXJyYXlMaWtlT2JqZWN0YCxcbiAqIGBpc0Jvb2xlYW5gLCBgaXNCdWZmZXJgLCBgaXNEYXRlYCwgYGlzRWxlbWVudGAsIGBpc0VtcHR5YCwgYGlzRXF1YWxgLFxuICogYGlzRXF1YWxXaXRoYCwgYGlzRXJyb3JgLCBgaXNGaW5pdGVgLCBgaXNGdW5jdGlvbmAsIGBpc0ludGVnZXJgLCBgaXNMZW5ndGhgLFxuICogYGlzTWFwYCwgYGlzTWF0Y2hgLCBgaXNNYXRjaFdpdGhgLCBgaXNOYU5gLCBgaXNOYXRpdmVgLCBgaXNOaWxgLCBgaXNOdWxsYCxcbiAqIGBpc051bWJlcmAsIGBpc09iamVjdGAsIGBpc09iamVjdExpa2VgLCBgaXNQbGFpbk9iamVjdGAsIGBpc1JlZ0V4cGAsXG4gKiBgaXNTYWZlSW50ZWdlcmAsIGBpc1NldGAsIGBpc1N0cmluZ2AsIGBpc1VuZGVmaW5lZGAsIGBpc1R5cGVkQXJyYXlgLFxuICogYGlzV2Vha01hcGAsIGBpc1dlYWtTZXRgLCBgam9pbmAsIGBrZWJhYkNhc2VgLCBgbGFzdGAsIGBsYXN0SW5kZXhPZmAsXG4gKiBgbG93ZXJDYXNlYCwgYGxvd2VyRmlyc3RgLCBgbHRgLCBgbHRlYCwgYG1heGAsIGBtYXhCeWAsIGBtZWFuYCwgYG1lYW5CeWAsXG4gKiBgbWluYCwgYG1pbkJ5YCwgYG11bHRpcGx5YCwgYG5vQ29uZmxpY3RgLCBgbm9vcGAsIGBub3dgLCBgbnRoYCwgYHBhZGAsXG4gKiBgcGFkRW5kYCwgYHBhZFN0YXJ0YCwgYHBhcnNlSW50YCwgYHBvcGAsIGByYW5kb21gLCBgcmVkdWNlYCwgYHJlZHVjZVJpZ2h0YCxcbiAqIGByZXBlYXRgLCBgcmVzdWx0YCwgYHJvdW5kYCwgYHJ1bkluQ29udGV4dGAsIGBzYW1wbGVgLCBgc2hpZnRgLCBgc2l6ZWAsXG4gKiBgc25ha2VDYXNlYCwgYHNvbWVgLCBgc29ydGVkSW5kZXhgLCBgc29ydGVkSW5kZXhCeWAsIGBzb3J0ZWRMYXN0SW5kZXhgLFxuICogYHNvcnRlZExhc3RJbmRleEJ5YCwgYHN0YXJ0Q2FzZWAsIGBzdGFydHNXaXRoYCwgYHN0dWJBcnJheWAsIGBzdHViRmFsc2VgLFxuICogYHN0dWJPYmplY3RgLCBgc3R1YlN0cmluZ2AsIGBzdHViVHJ1ZWAsIGBzdWJ0cmFjdGAsIGBzdW1gLCBgc3VtQnlgLFxuICogYHRlbXBsYXRlYCwgYHRpbWVzYCwgYHRvRmluaXRlYCwgYHRvSW50ZWdlcmAsIGB0b0pTT05gLCBgdG9MZW5ndGhgLFxuICogYHRvTG93ZXJgLCBgdG9OdW1iZXJgLCBgdG9TYWZlSW50ZWdlcmAsIGB0b1N0cmluZ2AsIGB0b1VwcGVyYCwgYHRyaW1gLFxuICogYHRyaW1FbmRgLCBgdHJpbVN0YXJ0YCwgYHRydW5jYXRlYCwgYHVuZXNjYXBlYCwgYHVuaXF1ZUlkYCwgYHVwcGVyQ2FzZWAsXG4gKiBgdXBwZXJGaXJzdGAsIGB2YWx1ZWAsIGFuZCBgd29yZHNgXG4gKlxuICogQG5hbWUgX1xuICogQGNvbnN0cnVjdG9yXG4gKiBAY2F0ZWdvcnkgU2VxXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwIGluIGEgYGxvZGFzaGAgaW5zdGFuY2UuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAqICAgcmV0dXJuIG4gKiBuO1xuICogfVxuICpcbiAqIHZhciB3cmFwcGVkID0gXyhbMSwgMiwgM10pO1xuICpcbiAqIC8vIFJldHVybnMgYW4gdW53cmFwcGVkIHZhbHVlLlxuICogd3JhcHBlZC5yZWR1Y2UoXy5hZGQpO1xuICogLy8gPT4gNlxuICpcbiAqIC8vIFJldHVybnMgYSB3cmFwcGVkIHZhbHVlLlxuICogdmFyIHNxdWFyZXMgPSB3cmFwcGVkLm1hcChzcXVhcmUpO1xuICpcbiAqIF8uaXNBcnJheShzcXVhcmVzKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KHNxdWFyZXMudmFsdWUoKSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGxvZGFzaCh2YWx1ZSkge1xuICBpZiAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiAhaXNBcnJheSh2YWx1ZSkgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExvZGFzaFdyYXBwZXIpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdfX3dyYXBwZWRfXycpKSB7XG4gICAgICByZXR1cm4gd3JhcHBlckNsb25lKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHZhbHVlKTtcbn1cblxuLy8gRW5zdXJlIHdyYXBwZXJzIGFyZSBpbnN0YW5jZXMgb2YgYGJhc2VMb2Rhc2hgLlxubG9kYXNoLnByb3RvdHlwZSA9IGJhc2VMb2Rhc2gucHJvdG90eXBlO1xubG9kYXNoLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGxvZGFzaDtcblxuZXhwb3J0IGRlZmF1bHQgbG9kYXNoO1xuIiwiaW1wb3J0IExhenlXcmFwcGVyIGZyb20gJy4vX0xhenlXcmFwcGVyLmpzJztcbmltcG9ydCBnZXREYXRhIGZyb20gJy4vX2dldERhdGEuanMnO1xuaW1wb3J0IGdldEZ1bmNOYW1lIGZyb20gJy4vX2dldEZ1bmNOYW1lLmpzJztcbmltcG9ydCBsb2Rhc2ggZnJvbSAnLi93cmFwcGVyTG9kYXNoLmpzJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBhIGxhenkgY291bnRlcnBhcnQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBoYXMgYSBsYXp5IGNvdW50ZXJwYXJ0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNMYXppYWJsZShmdW5jKSB7XG4gIHZhciBmdW5jTmFtZSA9IGdldEZ1bmNOYW1lKGZ1bmMpLFxuICAgICAgb3RoZXIgPSBsb2Rhc2hbZnVuY05hbWVdO1xuXG4gIGlmICh0eXBlb2Ygb3RoZXIgIT0gJ2Z1bmN0aW9uJyB8fCAhKGZ1bmNOYW1lIGluIExhenlXcmFwcGVyLnByb3RvdHlwZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGZ1bmMgPT09IG90aGVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIGRhdGEgPSBnZXREYXRhKG90aGVyKTtcbiAgcmV0dXJuICEhZGF0YSAmJiBmdW5jID09PSBkYXRhWzBdO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0xhemlhYmxlO1xuIiwiaW1wb3J0IGJhc2VTZXREYXRhIGZyb20gJy4vX2Jhc2VTZXREYXRhLmpzJztcbmltcG9ydCBzaG9ydE91dCBmcm9tICcuL19zaG9ydE91dC5qcyc7XG5cbi8qKlxuICogU2V0cyBtZXRhZGF0YSBmb3IgYGZ1bmNgLlxuICpcbiAqICoqTm90ZToqKiBJZiB0aGlzIGZ1bmN0aW9uIGJlY29tZXMgaG90LCBpLmUuIGlzIGludm9rZWQgYSBsb3QgaW4gYSBzaG9ydFxuICogcGVyaW9kIG9mIHRpbWUsIGl0IHdpbGwgdHJpcCBpdHMgYnJlYWtlciBhbmQgdHJhbnNpdGlvbiB0byBhbiBpZGVudGl0eVxuICogZnVuY3Rpb24gdG8gYXZvaWQgZ2FyYmFnZSBjb2xsZWN0aW9uIHBhdXNlcyBpbiBWOC4gU2VlXG4gKiBbVjggaXNzdWUgMjA3MF0oaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MjA3MClcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFzc29jaWF0ZSBtZXRhZGF0YSB3aXRoLlxuICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXRhZGF0YS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gKi9cbnZhciBzZXREYXRhID0gc2hvcnRPdXQoYmFzZVNldERhdGEpO1xuXG5leHBvcnQgZGVmYXVsdCBzZXREYXRhO1xuIiwiLyoqIFVzZWQgdG8gbWF0Y2ggd3JhcCBkZXRhaWwgY29tbWVudHMuICovXG52YXIgcmVXcmFwRGV0YWlscyA9IC9cXHtcXG5cXC9cXCogXFxbd3JhcHBlZCB3aXRoICguKylcXF0gXFwqLyxcbiAgICByZVNwbGl0RGV0YWlscyA9IC8sPyAmIC87XG5cbi8qKlxuICogRXh0cmFjdHMgd3JhcHBlciBkZXRhaWxzIGZyb20gdGhlIGBzb3VyY2VgIGJvZHkgY29tbWVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSBUaGUgc291cmNlIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdyYXBwZXIgZGV0YWlscy5cbiAqL1xuZnVuY3Rpb24gZ2V0V3JhcERldGFpbHMoc291cmNlKSB7XG4gIHZhciBtYXRjaCA9IHNvdXJjZS5tYXRjaChyZVdyYXBEZXRhaWxzKTtcbiAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0uc3BsaXQocmVTcGxpdERldGFpbHMpIDogW107XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldFdyYXBEZXRhaWxzO1xuIiwiLyoqIFVzZWQgdG8gbWF0Y2ggd3JhcCBkZXRhaWwgY29tbWVudHMuICovXG52YXIgcmVXcmFwQ29tbWVudCA9IC9cXHsoPzpcXG5cXC9cXCogXFxbd3JhcHBlZCB3aXRoIC4rXFxdIFxcKlxcLyk/XFxuPy87XG5cbi8qKlxuICogSW5zZXJ0cyB3cmFwcGVyIGBkZXRhaWxzYCBpbiBhIGNvbW1lbnQgYXQgdGhlIHRvcCBvZiB0aGUgYHNvdXJjZWAgYm9keS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSBUaGUgc291cmNlIHRvIG1vZGlmeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gZGV0YWlscyBUaGUgZGV0YWlscyB0byBpbnNlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBtb2RpZmllZCBzb3VyY2UuXG4gKi9cbmZ1bmN0aW9uIGluc2VydFdyYXBEZXRhaWxzKHNvdXJjZSwgZGV0YWlscykge1xuICB2YXIgbGVuZ3RoID0gZGV0YWlscy5sZW5ndGg7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTtcbiAgZGV0YWlsc1tsYXN0SW5kZXhdID0gKGxlbmd0aCA+IDEgPyAnJiAnIDogJycpICsgZGV0YWlsc1tsYXN0SW5kZXhdO1xuICBkZXRhaWxzID0gZGV0YWlscy5qb2luKGxlbmd0aCA+IDIgPyAnLCAnIDogJyAnKTtcbiAgcmV0dXJuIHNvdXJjZS5yZXBsYWNlKHJlV3JhcENvbW1lbnQsICd7XFxuLyogW3dyYXBwZWQgd2l0aCAnICsgZGV0YWlscyArICddICovXFxuJyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGluc2VydFdyYXBEZXRhaWxzO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maW5kSW5kZXhgIGFuZCBgXy5maW5kTGFzdEluZGV4YCB3aXRob3V0XG4gKiBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4LCBmcm9tUmlnaHQpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIGluZGV4ID0gZnJvbUluZGV4ICsgKGZyb21SaWdodCA/IDEgOiAtMSk7XG5cbiAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VGaW5kSW5kZXg7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmFOYCB3aXRob3V0IHN1cHBvcnQgZm9yIG51bWJlciBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGBOYU5gLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hTih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlSXNOYU47XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5pbmRleE9mYCB3aGljaCBwZXJmb3JtcyBzdHJpY3QgZXF1YWxpdHlcbiAqIGNvbXBhcmlzb25zIG9mIHZhbHVlcywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBzdHJpY3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gIHZhciBpbmRleCA9IGZyb21JbmRleCAtIDEsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoYXJyYXlbaW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0cmljdEluZGV4T2Y7XG4iLCJpbXBvcnQgYmFzZUZpbmRJbmRleCBmcm9tICcuL19iYXNlRmluZEluZGV4LmpzJztcbmltcG9ydCBiYXNlSXNOYU4gZnJvbSAnLi9fYmFzZUlzTmFOLmpzJztcbmltcG9ydCBzdHJpY3RJbmRleE9mIGZyb20gJy4vX3N0cmljdEluZGV4T2YuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmluZGV4T2ZgIHdpdGhvdXQgYGZyb21JbmRleGAgYm91bmRzIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlXG4gICAgPyBzdHJpY3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KVxuICAgIDogYmFzZUZpbmRJbmRleChhcnJheSwgYmFzZUlzTmFOLCBmcm9tSW5kZXgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlSW5kZXhPZjtcbiIsImltcG9ydCBiYXNlSW5kZXhPZiBmcm9tICcuL19iYXNlSW5kZXhPZi5qcyc7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmluY2x1ZGVzYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIHNwZWNpZnlpbmcgYW4gaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHRhcmdldCBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdGFyZ2V0YCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheUluY2x1ZGVzKGFycmF5LCB2YWx1ZSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gIHJldHVybiAhIWxlbmd0aCAmJiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIDApID4gLTE7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFycmF5SW5jbHVkZXM7XG4iLCJpbXBvcnQgYXJyYXlFYWNoIGZyb20gJy4vX2FycmF5RWFjaC5qcyc7XG5pbXBvcnQgYXJyYXlJbmNsdWRlcyBmcm9tICcuL19hcnJheUluY2x1ZGVzLmpzJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgZnVuY3Rpb24gbWV0YWRhdGEuICovXG52YXIgV1JBUF9CSU5EX0ZMQUcgPSAxLFxuICAgIFdSQVBfQklORF9LRVlfRkxBRyA9IDIsXG4gICAgV1JBUF9DVVJSWV9GTEFHID0gOCxcbiAgICBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcgPSAxNixcbiAgICBXUkFQX1BBUlRJQUxfRkxBRyA9IDMyLFxuICAgIFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHID0gNjQsXG4gICAgV1JBUF9BUllfRkxBRyA9IDEyOCxcbiAgICBXUkFQX1JFQVJHX0ZMQUcgPSAyNTYsXG4gICAgV1JBUF9GTElQX0ZMQUcgPSA1MTI7XG5cbi8qKiBVc2VkIHRvIGFzc29jaWF0ZSB3cmFwIG1ldGhvZHMgd2l0aCB0aGVpciBiaXQgZmxhZ3MuICovXG52YXIgd3JhcEZsYWdzID0gW1xuICBbJ2FyeScsIFdSQVBfQVJZX0ZMQUddLFxuICBbJ2JpbmQnLCBXUkFQX0JJTkRfRkxBR10sXG4gIFsnYmluZEtleScsIFdSQVBfQklORF9LRVlfRkxBR10sXG4gIFsnY3VycnknLCBXUkFQX0NVUlJZX0ZMQUddLFxuICBbJ2N1cnJ5UmlnaHQnLCBXUkFQX0NVUlJZX1JJR0hUX0ZMQUddLFxuICBbJ2ZsaXAnLCBXUkFQX0ZMSVBfRkxBR10sXG4gIFsncGFydGlhbCcsIFdSQVBfUEFSVElBTF9GTEFHXSxcbiAgWydwYXJ0aWFsUmlnaHQnLCBXUkFQX1BBUlRJQUxfUklHSFRfRkxBR10sXG4gIFsncmVhcmcnLCBXUkFQX1JFQVJHX0ZMQUddXG5dO1xuXG4vKipcbiAqIFVwZGF0ZXMgd3JhcHBlciBgZGV0YWlsc2AgYmFzZWQgb24gYGJpdG1hc2tgIGZsYWdzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcmV0dXJucyB7QXJyYXl9IGRldGFpbHMgVGhlIGRldGFpbHMgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgZGV0YWlsc2AuXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZVdyYXBEZXRhaWxzKGRldGFpbHMsIGJpdG1hc2spIHtcbiAgYXJyYXlFYWNoKHdyYXBGbGFncywgZnVuY3Rpb24ocGFpcikge1xuICAgIHZhciB2YWx1ZSA9ICdfLicgKyBwYWlyWzBdO1xuICAgIGlmICgoYml0bWFzayAmIHBhaXJbMV0pICYmICFhcnJheUluY2x1ZGVzKGRldGFpbHMsIHZhbHVlKSkge1xuICAgICAgZGV0YWlscy5wdXNoKHZhbHVlKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZGV0YWlscy5zb3J0KCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHVwZGF0ZVdyYXBEZXRhaWxzO1xuIiwiaW1wb3J0IGdldFdyYXBEZXRhaWxzIGZyb20gJy4vX2dldFdyYXBEZXRhaWxzLmpzJztcbmltcG9ydCBpbnNlcnRXcmFwRGV0YWlscyBmcm9tICcuL19pbnNlcnRXcmFwRGV0YWlscy5qcyc7XG5pbXBvcnQgc2V0VG9TdHJpbmcgZnJvbSAnLi9fc2V0VG9TdHJpbmcuanMnO1xuaW1wb3J0IHVwZGF0ZVdyYXBEZXRhaWxzIGZyb20gJy4vX3VwZGF0ZVdyYXBEZXRhaWxzLmpzJztcblxuLyoqXG4gKiBTZXRzIHRoZSBgdG9TdHJpbmdgIG1ldGhvZCBvZiBgd3JhcHBlcmAgdG8gbWltaWMgdGhlIHNvdXJjZSBvZiBgcmVmZXJlbmNlYFxuICogd2l0aCB3cmFwcGVyIGRldGFpbHMgaW4gYSBjb21tZW50IGF0IHRoZSB0b3Agb2YgdGhlIHNvdXJjZSBib2R5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB3cmFwcGVyIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWZlcmVuY2UgVGhlIHJlZmVyZW5jZSBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYHdyYXBwZXJgLlxuICovXG5mdW5jdGlvbiBzZXRXcmFwVG9TdHJpbmcod3JhcHBlciwgcmVmZXJlbmNlLCBiaXRtYXNrKSB7XG4gIHZhciBzb3VyY2UgPSAocmVmZXJlbmNlICsgJycpO1xuICByZXR1cm4gc2V0VG9TdHJpbmcod3JhcHBlciwgaW5zZXJ0V3JhcERldGFpbHMoc291cmNlLCB1cGRhdGVXcmFwRGV0YWlscyhnZXRXcmFwRGV0YWlscyhzb3VyY2UpLCBiaXRtYXNrKSkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzZXRXcmFwVG9TdHJpbmc7XG4iLCJpbXBvcnQgaXNMYXppYWJsZSBmcm9tICcuL19pc0xhemlhYmxlLmpzJztcbmltcG9ydCBzZXREYXRhIGZyb20gJy4vX3NldERhdGEuanMnO1xuaW1wb3J0IHNldFdyYXBUb1N0cmluZyBmcm9tICcuL19zZXRXcmFwVG9TdHJpbmcuanMnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBmdW5jdGlvbiBtZXRhZGF0YS4gKi9cbnZhciBXUkFQX0JJTkRfRkxBRyA9IDEsXG4gICAgV1JBUF9CSU5EX0tFWV9GTEFHID0gMixcbiAgICBXUkFQX0NVUlJZX0JPVU5EX0ZMQUcgPSA0LFxuICAgIFdSQVBfQ1VSUllfRkxBRyA9IDgsXG4gICAgV1JBUF9QQVJUSUFMX0ZMQUcgPSAzMixcbiAgICBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRyA9IDY0O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCB0byBjb250aW51ZSBjdXJyeWluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB3cmFwRnVuYyBUaGUgZnVuY3Rpb24gdG8gY3JlYXRlIHRoZSBgZnVuY2Agd3JhcHBlci5cbiAqIEBwYXJhbSB7Kn0gcGxhY2Vob2xkZXIgVGhlIHBsYWNlaG9sZGVyIHZhbHVlLlxuICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBwcmVwZW5kIHRvIHRob3NlIHByb3ZpZGVkIHRvXG4gKiAgdGhlIG5ldyBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7QXJyYXl9IFtob2xkZXJzXSBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICogQHBhcmFtIHtBcnJheX0gW2FyZ1Bvc10gVGhlIGFyZ3VtZW50IHBvc2l0aW9ucyBvZiB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFthcnldIFRoZSBhcml0eSBjYXAgb2YgYGZ1bmNgLlxuICogQHBhcmFtIHtudW1iZXJ9IFthcml0eV0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJlY3VycnkoZnVuYywgYml0bWFzaywgd3JhcEZ1bmMsIHBsYWNlaG9sZGVyLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycywgYXJnUG9zLCBhcnksIGFyaXR5KSB7XG4gIHZhciBpc0N1cnJ5ID0gYml0bWFzayAmIFdSQVBfQ1VSUllfRkxBRyxcbiAgICAgIG5ld0hvbGRlcnMgPSBpc0N1cnJ5ID8gaG9sZGVycyA6IHVuZGVmaW5lZCxcbiAgICAgIG5ld0hvbGRlcnNSaWdodCA9IGlzQ3VycnkgPyB1bmRlZmluZWQgOiBob2xkZXJzLFxuICAgICAgbmV3UGFydGlhbHMgPSBpc0N1cnJ5ID8gcGFydGlhbHMgOiB1bmRlZmluZWQsXG4gICAgICBuZXdQYXJ0aWFsc1JpZ2h0ID0gaXNDdXJyeSA/IHVuZGVmaW5lZCA6IHBhcnRpYWxzO1xuXG4gIGJpdG1hc2sgfD0gKGlzQ3VycnkgPyBXUkFQX1BBUlRJQUxfRkxBRyA6IFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHKTtcbiAgYml0bWFzayAmPSB+KGlzQ3VycnkgPyBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRyA6IFdSQVBfUEFSVElBTF9GTEFHKTtcblxuICBpZiAoIShiaXRtYXNrICYgV1JBUF9DVVJSWV9CT1VORF9GTEFHKSkge1xuICAgIGJpdG1hc2sgJj0gfihXUkFQX0JJTkRfRkxBRyB8IFdSQVBfQklORF9LRVlfRkxBRyk7XG4gIH1cbiAgdmFyIG5ld0RhdGEgPSBbXG4gICAgZnVuYywgYml0bWFzaywgdGhpc0FyZywgbmV3UGFydGlhbHMsIG5ld0hvbGRlcnMsIG5ld1BhcnRpYWxzUmlnaHQsXG4gICAgbmV3SG9sZGVyc1JpZ2h0LCBhcmdQb3MsIGFyeSwgYXJpdHlcbiAgXTtcblxuICB2YXIgcmVzdWx0ID0gd3JhcEZ1bmMuYXBwbHkodW5kZWZpbmVkLCBuZXdEYXRhKTtcbiAgaWYgKGlzTGF6aWFibGUoZnVuYykpIHtcbiAgICBzZXREYXRhKHJlc3VsdCwgbmV3RGF0YSk7XG4gIH1cbiAgcmVzdWx0LnBsYWNlaG9sZGVyID0gcGxhY2Vob2xkZXI7XG4gIHJldHVybiBzZXRXcmFwVG9TdHJpbmcocmVzdWx0LCBmdW5jLCBiaXRtYXNrKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlUmVjdXJyeTtcbiIsIi8qKlxuICogR2V0cyB0aGUgYXJndW1lbnQgcGxhY2Vob2xkZXIgdmFsdWUgZm9yIGBmdW5jYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwbGFjZWhvbGRlciB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0SG9sZGVyKGZ1bmMpIHtcbiAgdmFyIG9iamVjdCA9IGZ1bmM7XG4gIHJldHVybiBvYmplY3QucGxhY2Vob2xkZXI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldEhvbGRlcjtcbiIsImltcG9ydCBjb3B5QXJyYXkgZnJvbSAnLi9fY29weUFycmF5LmpzJztcbmltcG9ydCBpc0luZGV4IGZyb20gJy4vX2lzSW5kZXguanMnO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWluID0gTWF0aC5taW47XG5cbi8qKlxuICogUmVvcmRlciBgYXJyYXlgIGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWVkIGluZGV4ZXMgd2hlcmUgdGhlIGVsZW1lbnQgYXRcbiAqIHRoZSBmaXJzdCBpbmRleCBpcyBhc3NpZ25lZCBhcyB0aGUgZmlyc3QgZWxlbWVudCwgdGhlIGVsZW1lbnQgYXRcbiAqIHRoZSBzZWNvbmQgaW5kZXggaXMgYXNzaWduZWQgYXMgdGhlIHNlY29uZCBlbGVtZW50LCBhbmQgc28gb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byByZW9yZGVyLlxuICogQHBhcmFtIHtBcnJheX0gaW5kZXhlcyBUaGUgYXJyYW5nZWQgYXJyYXkgaW5kZXhlcy5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiByZW9yZGVyKGFycmF5LCBpbmRleGVzKSB7XG4gIHZhciBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBsZW5ndGggPSBuYXRpdmVNaW4oaW5kZXhlcy5sZW5ndGgsIGFyckxlbmd0aCksXG4gICAgICBvbGRBcnJheSA9IGNvcHlBcnJheShhcnJheSk7XG5cbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgdmFyIGluZGV4ID0gaW5kZXhlc1tsZW5ndGhdO1xuICAgIGFycmF5W2xlbmd0aF0gPSBpc0luZGV4KGluZGV4LCBhcnJMZW5ndGgpID8gb2xkQXJyYXlbaW5kZXhdIDogdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgcmVvcmRlcjtcbiIsIi8qKiBVc2VkIGFzIHRoZSBpbnRlcm5hbCBhcmd1bWVudCBwbGFjZWhvbGRlci4gKi9cbnZhciBQTEFDRUhPTERFUiA9ICdfX2xvZGFzaF9wbGFjZWhvbGRlcl9fJztcblxuLyoqXG4gKiBSZXBsYWNlcyBhbGwgYHBsYWNlaG9sZGVyYCBlbGVtZW50cyBpbiBgYXJyYXlgIHdpdGggYW4gaW50ZXJuYWwgcGxhY2Vob2xkZXJcbiAqIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIHRoZWlyIGluZGV4ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0geyp9IHBsYWNlaG9sZGVyIFRoZSBwbGFjZWhvbGRlciB0byByZXBsYWNlLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAqL1xuZnVuY3Rpb24gcmVwbGFjZUhvbGRlcnMoYXJyYXksIHBsYWNlaG9sZGVyKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgaWYgKHZhbHVlID09PSBwbGFjZWhvbGRlciB8fCB2YWx1ZSA9PT0gUExBQ0VIT0xERVIpIHtcbiAgICAgIGFycmF5W2luZGV4XSA9IFBMQUNFSE9MREVSO1xuICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gaW5kZXg7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHJlcGxhY2VIb2xkZXJzO1xuIiwiaW1wb3J0IGNvbXBvc2VBcmdzIGZyb20gJy4vX2NvbXBvc2VBcmdzLmpzJztcbmltcG9ydCBjb21wb3NlQXJnc1JpZ2h0IGZyb20gJy4vX2NvbXBvc2VBcmdzUmlnaHQuanMnO1xuaW1wb3J0IGNvdW50SG9sZGVycyBmcm9tICcuL19jb3VudEhvbGRlcnMuanMnO1xuaW1wb3J0IGNyZWF0ZUN0b3IgZnJvbSAnLi9fY3JlYXRlQ3Rvci5qcyc7XG5pbXBvcnQgY3JlYXRlUmVjdXJyeSBmcm9tICcuL19jcmVhdGVSZWN1cnJ5LmpzJztcbmltcG9ydCBnZXRIb2xkZXIgZnJvbSAnLi9fZ2V0SG9sZGVyLmpzJztcbmltcG9ydCByZW9yZGVyIGZyb20gJy4vX3Jlb3JkZXIuanMnO1xuaW1wb3J0IHJlcGxhY2VIb2xkZXJzIGZyb20gJy4vX3JlcGxhY2VIb2xkZXJzLmpzJztcbmltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBmdW5jdGlvbiBtZXRhZGF0YS4gKi9cbnZhciBXUkFQX0JJTkRfRkxBRyA9IDEsXG4gICAgV1JBUF9CSU5EX0tFWV9GTEFHID0gMixcbiAgICBXUkFQX0NVUlJZX0ZMQUcgPSA4LFxuICAgIFdSQVBfQ1VSUllfUklHSFRfRkxBRyA9IDE2LFxuICAgIFdSQVBfQVJZX0ZMQUcgPSAxMjgsXG4gICAgV1JBUF9GTElQX0ZMQUcgPSA1MTI7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIHRvIGludm9rZSBpdCB3aXRoIG9wdGlvbmFsIGB0aGlzYFxuICogYmluZGluZyBvZiBgdGhpc0FyZ2AsIHBhcnRpYWwgYXBwbGljYXRpb24sIGFuZCBjdXJyeWluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbnxzdHJpbmd9IGZ1bmMgVGhlIGZ1bmN0aW9uIG9yIG1ldGhvZCBuYW1lIHRvIHdyYXAuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBwcmVwZW5kIHRvIHRob3NlIHByb3ZpZGVkIHRvXG4gKiAgdGhlIG5ldyBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7QXJyYXl9IFtob2xkZXJzXSBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxzUmlnaHRdIFRoZSBhcmd1bWVudHMgdG8gYXBwZW5kIHRvIHRob3NlIHByb3ZpZGVkXG4gKiAgdG8gdGhlIG5ldyBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7QXJyYXl9IFtob2xkZXJzUmlnaHRdIFRoZSBgcGFydGlhbHNSaWdodGAgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAqIEBwYXJhbSB7QXJyYXl9IFthcmdQb3NdIFRoZSBhcmd1bWVudCBwb3NpdGlvbnMgb2YgdGhlIG5ldyBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbYXJ5XSBUaGUgYXJpdHkgY2FwIG9mIGBmdW5jYC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHldIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVIeWJyaWQoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMsIHBhcnRpYWxzUmlnaHQsIGhvbGRlcnNSaWdodCwgYXJnUG9zLCBhcnksIGFyaXR5KSB7XG4gIHZhciBpc0FyeSA9IGJpdG1hc2sgJiBXUkFQX0FSWV9GTEFHLFxuICAgICAgaXNCaW5kID0gYml0bWFzayAmIFdSQVBfQklORF9GTEFHLFxuICAgICAgaXNCaW5kS2V5ID0gYml0bWFzayAmIFdSQVBfQklORF9LRVlfRkxBRyxcbiAgICAgIGlzQ3VycmllZCA9IGJpdG1hc2sgJiAoV1JBUF9DVVJSWV9GTEFHIHwgV1JBUF9DVVJSWV9SSUdIVF9GTEFHKSxcbiAgICAgIGlzRmxpcCA9IGJpdG1hc2sgJiBXUkFQX0ZMSVBfRkxBRyxcbiAgICAgIEN0b3IgPSBpc0JpbmRLZXkgPyB1bmRlZmluZWQgOiBjcmVhdGVDdG9yKGZ1bmMpO1xuXG4gIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgIGFyZ3MgPSBBcnJheShsZW5ndGgpLFxuICAgICAgICBpbmRleCA9IGxlbmd0aDtcblxuICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICBhcmdzW2luZGV4XSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgfVxuICAgIGlmIChpc0N1cnJpZWQpIHtcbiAgICAgIHZhciBwbGFjZWhvbGRlciA9IGdldEhvbGRlcih3cmFwcGVyKSxcbiAgICAgICAgICBob2xkZXJzQ291bnQgPSBjb3VudEhvbGRlcnMoYXJncywgcGxhY2Vob2xkZXIpO1xuICAgIH1cbiAgICBpZiAocGFydGlhbHMpIHtcbiAgICAgIGFyZ3MgPSBjb21wb3NlQXJncyhhcmdzLCBwYXJ0aWFscywgaG9sZGVycywgaXNDdXJyaWVkKTtcbiAgICB9XG4gICAgaWYgKHBhcnRpYWxzUmlnaHQpIHtcbiAgICAgIGFyZ3MgPSBjb21wb3NlQXJnc1JpZ2h0KGFyZ3MsIHBhcnRpYWxzUmlnaHQsIGhvbGRlcnNSaWdodCwgaXNDdXJyaWVkKTtcbiAgICB9XG4gICAgbGVuZ3RoIC09IGhvbGRlcnNDb3VudDtcbiAgICBpZiAoaXNDdXJyaWVkICYmIGxlbmd0aCA8IGFyaXR5KSB7XG4gICAgICB2YXIgbmV3SG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKGFyZ3MsIHBsYWNlaG9sZGVyKTtcbiAgICAgIHJldHVybiBjcmVhdGVSZWN1cnJ5KFxuICAgICAgICBmdW5jLCBiaXRtYXNrLCBjcmVhdGVIeWJyaWQsIHdyYXBwZXIucGxhY2Vob2xkZXIsIHRoaXNBcmcsXG4gICAgICAgIGFyZ3MsIG5ld0hvbGRlcnMsIGFyZ1BvcywgYXJ5LCBhcml0eSAtIGxlbmd0aFxuICAgICAgKTtcbiAgICB9XG4gICAgdmFyIHRoaXNCaW5kaW5nID0gaXNCaW5kID8gdGhpc0FyZyA6IHRoaXMsXG4gICAgICAgIGZuID0gaXNCaW5kS2V5ID8gdGhpc0JpbmRpbmdbZnVuY10gOiBmdW5jO1xuXG4gICAgbGVuZ3RoID0gYXJncy5sZW5ndGg7XG4gICAgaWYgKGFyZ1Bvcykge1xuICAgICAgYXJncyA9IHJlb3JkZXIoYXJncywgYXJnUG9zKTtcbiAgICB9IGVsc2UgaWYgKGlzRmxpcCAmJiBsZW5ndGggPiAxKSB7XG4gICAgICBhcmdzLnJldmVyc2UoKTtcbiAgICB9XG4gICAgaWYgKGlzQXJ5ICYmIGFyeSA8IGxlbmd0aCkge1xuICAgICAgYXJncy5sZW5ndGggPSBhcnk7XG4gICAgfVxuICAgIGlmICh0aGlzICYmIHRoaXMgIT09IHJvb3QgJiYgdGhpcyBpbnN0YW5jZW9mIHdyYXBwZXIpIHtcbiAgICAgIGZuID0gQ3RvciB8fCBjcmVhdGVDdG9yKGZuKTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNCaW5kaW5nLCBhcmdzKTtcbiAgfVxuICByZXR1cm4gd3JhcHBlcjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlSHlicmlkO1xuIiwiaW1wb3J0IGFwcGx5IGZyb20gJy4vX2FwcGx5LmpzJztcbmltcG9ydCBjcmVhdGVDdG9yIGZyb20gJy4vX2NyZWF0ZUN0b3IuanMnO1xuaW1wb3J0IGNyZWF0ZUh5YnJpZCBmcm9tICcuL19jcmVhdGVIeWJyaWQuanMnO1xuaW1wb3J0IGNyZWF0ZVJlY3VycnkgZnJvbSAnLi9fY3JlYXRlUmVjdXJyeS5qcyc7XG5pbXBvcnQgZ2V0SG9sZGVyIGZyb20gJy4vX2dldEhvbGRlci5qcyc7XG5pbXBvcnQgcmVwbGFjZUhvbGRlcnMgZnJvbSAnLi9fcmVwbGFjZUhvbGRlcnMuanMnO1xuaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIHRvIGVuYWJsZSBjdXJyeWluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge251bWJlcn0gYXJpdHkgVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUN1cnJ5KGZ1bmMsIGJpdG1hc2ssIGFyaXR5KSB7XG4gIHZhciBDdG9yID0gY3JlYXRlQ3RvcihmdW5jKTtcblxuICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICBhcmdzID0gQXJyYXkobGVuZ3RoKSxcbiAgICAgICAgaW5kZXggPSBsZW5ndGgsXG4gICAgICAgIHBsYWNlaG9sZGVyID0gZ2V0SG9sZGVyKHdyYXBwZXIpO1xuXG4gICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgIGFyZ3NbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICB9XG4gICAgdmFyIGhvbGRlcnMgPSAobGVuZ3RoIDwgMyAmJiBhcmdzWzBdICE9PSBwbGFjZWhvbGRlciAmJiBhcmdzW2xlbmd0aCAtIDFdICE9PSBwbGFjZWhvbGRlcilcbiAgICAgID8gW11cbiAgICAgIDogcmVwbGFjZUhvbGRlcnMoYXJncywgcGxhY2Vob2xkZXIpO1xuXG4gICAgbGVuZ3RoIC09IGhvbGRlcnMubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPCBhcml0eSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVJlY3VycnkoXG4gICAgICAgIGZ1bmMsIGJpdG1hc2ssIGNyZWF0ZUh5YnJpZCwgd3JhcHBlci5wbGFjZWhvbGRlciwgdW5kZWZpbmVkLFxuICAgICAgICBhcmdzLCBob2xkZXJzLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgYXJpdHkgLSBsZW5ndGgpO1xuICAgIH1cbiAgICB2YXIgZm4gPSAodGhpcyAmJiB0aGlzICE9PSByb290ICYmIHRoaXMgaW5zdGFuY2VvZiB3cmFwcGVyKSA/IEN0b3IgOiBmdW5jO1xuICAgIHJldHVybiBhcHBseShmbiwgdGhpcywgYXJncyk7XG4gIH1cbiAgcmV0dXJuIHdyYXBwZXI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZUN1cnJ5O1xuIiwiaW1wb3J0IGFwcGx5IGZyb20gJy4vX2FwcGx5LmpzJztcbmltcG9ydCBjcmVhdGVDdG9yIGZyb20gJy4vX2NyZWF0ZUN0b3IuanMnO1xuaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGZ1bmN0aW9uIG1ldGFkYXRhLiAqL1xudmFyIFdSQVBfQklORF9GTEFHID0gMTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgdG8gaW52b2tlIGl0IHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nXG4gKiBvZiBgdGhpc0FyZ2AgYW5kIGBwYXJ0aWFsc2AgcHJlcGVuZGVkIHRvIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge0FycmF5fSBwYXJ0aWFscyBUaGUgYXJndW1lbnRzIHRvIHByZXBlbmQgdG8gdGhvc2UgcHJvdmlkZWQgdG9cbiAqICB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUGFydGlhbChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscykge1xuICB2YXIgaXNCaW5kID0gYml0bWFzayAmIFdSQVBfQklORF9GTEFHLFxuICAgICAgQ3RvciA9IGNyZWF0ZUN0b3IoZnVuYyk7XG5cbiAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICB2YXIgYXJnc0luZGV4ID0gLTEsXG4gICAgICAgIGFyZ3NMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICBsZWZ0SW5kZXggPSAtMSxcbiAgICAgICAgbGVmdExlbmd0aCA9IHBhcnRpYWxzLmxlbmd0aCxcbiAgICAgICAgYXJncyA9IEFycmF5KGxlZnRMZW5ndGggKyBhcmdzTGVuZ3RoKSxcbiAgICAgICAgZm4gPSAodGhpcyAmJiB0aGlzICE9PSByb290ICYmIHRoaXMgaW5zdGFuY2VvZiB3cmFwcGVyKSA/IEN0b3IgOiBmdW5jO1xuXG4gICAgd2hpbGUgKCsrbGVmdEluZGV4IDwgbGVmdExlbmd0aCkge1xuICAgICAgYXJnc1tsZWZ0SW5kZXhdID0gcGFydGlhbHNbbGVmdEluZGV4XTtcbiAgICB9XG4gICAgd2hpbGUgKGFyZ3NMZW5ndGgtLSkge1xuICAgICAgYXJnc1tsZWZ0SW5kZXgrK10gPSBhcmd1bWVudHNbKythcmdzSW5kZXhdO1xuICAgIH1cbiAgICByZXR1cm4gYXBwbHkoZm4sIGlzQmluZCA/IHRoaXNBcmcgOiB0aGlzLCBhcmdzKTtcbiAgfVxuICByZXR1cm4gd3JhcHBlcjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlUGFydGlhbDtcbiIsImltcG9ydCBjb21wb3NlQXJncyBmcm9tICcuL19jb21wb3NlQXJncy5qcyc7XG5pbXBvcnQgY29tcG9zZUFyZ3NSaWdodCBmcm9tICcuL19jb21wb3NlQXJnc1JpZ2h0LmpzJztcbmltcG9ydCByZXBsYWNlSG9sZGVycyBmcm9tICcuL19yZXBsYWNlSG9sZGVycy5qcyc7XG5cbi8qKiBVc2VkIGFzIHRoZSBpbnRlcm5hbCBhcmd1bWVudCBwbGFjZWhvbGRlci4gKi9cbnZhciBQTEFDRUhPTERFUiA9ICdfX2xvZGFzaF9wbGFjZWhvbGRlcl9fJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgZnVuY3Rpb24gbWV0YWRhdGEuICovXG52YXIgV1JBUF9CSU5EX0ZMQUcgPSAxLFxuICAgIFdSQVBfQklORF9LRVlfRkxBRyA9IDIsXG4gICAgV1JBUF9DVVJSWV9CT1VORF9GTEFHID0gNCxcbiAgICBXUkFQX0NVUlJZX0ZMQUcgPSA4LFxuICAgIFdSQVBfQVJZX0ZMQUcgPSAxMjgsXG4gICAgV1JBUF9SRUFSR19GTEFHID0gMjU2O1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWluID0gTWF0aC5taW47XG5cbi8qKlxuICogTWVyZ2VzIHRoZSBmdW5jdGlvbiBtZXRhZGF0YSBvZiBgc291cmNlYCBpbnRvIGBkYXRhYC5cbiAqXG4gKiBNZXJnaW5nIG1ldGFkYXRhIHJlZHVjZXMgdGhlIG51bWJlciBvZiB3cmFwcGVycyB1c2VkIHRvIGludm9rZSBhIGZ1bmN0aW9uLlxuICogVGhpcyBpcyBwb3NzaWJsZSBiZWNhdXNlIG1ldGhvZHMgbGlrZSBgXy5iaW5kYCwgYF8uY3VycnlgLCBhbmQgYF8ucGFydGlhbGBcbiAqIG1heSBiZSBhcHBsaWVkIHJlZ2FyZGxlc3Mgb2YgZXhlY3V0aW9uIG9yZGVyLiBNZXRob2RzIGxpa2UgYF8uYXJ5YCBhbmRcbiAqIGBfLnJlYXJnYCBtb2RpZnkgZnVuY3Rpb24gYXJndW1lbnRzLCBtYWtpbmcgdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgYXJlXG4gKiBleGVjdXRlZCBpbXBvcnRhbnQsIHByZXZlbnRpbmcgdGhlIG1lcmdpbmcgb2YgbWV0YWRhdGEuIEhvd2V2ZXIsIHdlIG1ha2VcbiAqIGFuIGV4Y2VwdGlvbiBmb3IgYSBzYWZlIGNvbWJpbmVkIGNhc2Ugd2hlcmUgY3VycmllZCBmdW5jdGlvbnMgaGF2ZSBgXy5hcnlgXG4gKiBhbmQgb3IgYF8ucmVhcmdgIGFwcGxpZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgVGhlIGRlc3RpbmF0aW9uIG1ldGFkYXRhLlxuICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBzb3VyY2UgbWV0YWRhdGEuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGRhdGFgLlxuICovXG5mdW5jdGlvbiBtZXJnZURhdGEoZGF0YSwgc291cmNlKSB7XG4gIHZhciBiaXRtYXNrID0gZGF0YVsxXSxcbiAgICAgIHNyY0JpdG1hc2sgPSBzb3VyY2VbMV0sXG4gICAgICBuZXdCaXRtYXNrID0gYml0bWFzayB8IHNyY0JpdG1hc2ssXG4gICAgICBpc0NvbW1vbiA9IG5ld0JpdG1hc2sgPCAoV1JBUF9CSU5EX0ZMQUcgfCBXUkFQX0JJTkRfS0VZX0ZMQUcgfCBXUkFQX0FSWV9GTEFHKTtcblxuICB2YXIgaXNDb21ibyA9XG4gICAgKChzcmNCaXRtYXNrID09IFdSQVBfQVJZX0ZMQUcpICYmIChiaXRtYXNrID09IFdSQVBfQ1VSUllfRkxBRykpIHx8XG4gICAgKChzcmNCaXRtYXNrID09IFdSQVBfQVJZX0ZMQUcpICYmIChiaXRtYXNrID09IFdSQVBfUkVBUkdfRkxBRykgJiYgKGRhdGFbN10ubGVuZ3RoIDw9IHNvdXJjZVs4XSkpIHx8XG4gICAgKChzcmNCaXRtYXNrID09IChXUkFQX0FSWV9GTEFHIHwgV1JBUF9SRUFSR19GTEFHKSkgJiYgKHNvdXJjZVs3XS5sZW5ndGggPD0gc291cmNlWzhdKSAmJiAoYml0bWFzayA9PSBXUkFQX0NVUlJZX0ZMQUcpKTtcblxuICAvLyBFeGl0IGVhcmx5IGlmIG1ldGFkYXRhIGNhbid0IGJlIG1lcmdlZC5cbiAgaWYgKCEoaXNDb21tb24gfHwgaXNDb21ibykpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICAvLyBVc2Ugc291cmNlIGB0aGlzQXJnYCBpZiBhdmFpbGFibGUuXG4gIGlmIChzcmNCaXRtYXNrICYgV1JBUF9CSU5EX0ZMQUcpIHtcbiAgICBkYXRhWzJdID0gc291cmNlWzJdO1xuICAgIC8vIFNldCB3aGVuIGN1cnJ5aW5nIGEgYm91bmQgZnVuY3Rpb24uXG4gICAgbmV3Qml0bWFzayB8PSBiaXRtYXNrICYgV1JBUF9CSU5EX0ZMQUcgPyAwIDogV1JBUF9DVVJSWV9CT1VORF9GTEFHO1xuICB9XG4gIC8vIENvbXBvc2UgcGFydGlhbCBhcmd1bWVudHMuXG4gIHZhciB2YWx1ZSA9IHNvdXJjZVszXTtcbiAgaWYgKHZhbHVlKSB7XG4gICAgdmFyIHBhcnRpYWxzID0gZGF0YVszXTtcbiAgICBkYXRhWzNdID0gcGFydGlhbHMgPyBjb21wb3NlQXJncyhwYXJ0aWFscywgdmFsdWUsIHNvdXJjZVs0XSkgOiB2YWx1ZTtcbiAgICBkYXRhWzRdID0gcGFydGlhbHMgPyByZXBsYWNlSG9sZGVycyhkYXRhWzNdLCBQTEFDRUhPTERFUikgOiBzb3VyY2VbNF07XG4gIH1cbiAgLy8gQ29tcG9zZSBwYXJ0aWFsIHJpZ2h0IGFyZ3VtZW50cy5cbiAgdmFsdWUgPSBzb3VyY2VbNV07XG4gIGlmICh2YWx1ZSkge1xuICAgIHBhcnRpYWxzID0gZGF0YVs1XTtcbiAgICBkYXRhWzVdID0gcGFydGlhbHMgPyBjb21wb3NlQXJnc1JpZ2h0KHBhcnRpYWxzLCB2YWx1ZSwgc291cmNlWzZdKSA6IHZhbHVlO1xuICAgIGRhdGFbNl0gPSBwYXJ0aWFscyA/IHJlcGxhY2VIb2xkZXJzKGRhdGFbNV0sIFBMQUNFSE9MREVSKSA6IHNvdXJjZVs2XTtcbiAgfVxuICAvLyBVc2Ugc291cmNlIGBhcmdQb3NgIGlmIGF2YWlsYWJsZS5cbiAgdmFsdWUgPSBzb3VyY2VbN107XG4gIGlmICh2YWx1ZSkge1xuICAgIGRhdGFbN10gPSB2YWx1ZTtcbiAgfVxuICAvLyBVc2Ugc291cmNlIGBhcnlgIGlmIGl0J3Mgc21hbGxlci5cbiAgaWYgKHNyY0JpdG1hc2sgJiBXUkFQX0FSWV9GTEFHKSB7XG4gICAgZGF0YVs4XSA9IGRhdGFbOF0gPT0gbnVsbCA/IHNvdXJjZVs4XSA6IG5hdGl2ZU1pbihkYXRhWzhdLCBzb3VyY2VbOF0pO1xuICB9XG4gIC8vIFVzZSBzb3VyY2UgYGFyaXR5YCBpZiBvbmUgaXMgbm90IHByb3ZpZGVkLlxuICBpZiAoZGF0YVs5XSA9PSBudWxsKSB7XG4gICAgZGF0YVs5XSA9IHNvdXJjZVs5XTtcbiAgfVxuICAvLyBVc2Ugc291cmNlIGBmdW5jYCBhbmQgbWVyZ2UgYml0bWFza3MuXG4gIGRhdGFbMF0gPSBzb3VyY2VbMF07XG4gIGRhdGFbMV0gPSBuZXdCaXRtYXNrO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG5leHBvcnQgZGVmYXVsdCBtZXJnZURhdGE7XG4iLCJpbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdC5qcyc7XG5pbXBvcnQgaXNTeW1ib2wgZnJvbSAnLi9pc1N5bWJvbC5qcyc7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE5BTiA9IDAgLyAwO1xuXG4vKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlLiAqL1xudmFyIHJlVHJpbSA9IC9eXFxzK3xcXHMrJC9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmFkIHNpZ25lZCBoZXhhZGVjaW1hbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCYWRIZXggPSAvXlstK10weFswLTlhLWZdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJpbmFyeSBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCaW5hcnkgPSAvXjBiWzAxXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvY3RhbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNPY3RhbCA9IC9eMG9bMC03XSskL2k7XG5cbi8qKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB3aXRob3V0IGEgZGVwZW5kZW5jeSBvbiBgcm9vdGAuICovXG52YXIgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b051bWJlcigzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xuICogLy8gPT4gSW5maW5pdHlcbiAqXG4gKiBfLnRvTnVtYmVyKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gTkFOO1xuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgdmFsdWUgPSBpc09iamVjdChvdGhlcikgPyAob3RoZXIgKyAnJykgOiBvdGhlcjtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiArdmFsdWU7XG4gIH1cbiAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHJlVHJpbSwgJycpO1xuICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpO1xuICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcbiAgICA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOClcbiAgICA6IChyZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdG9OdW1iZXI7XG4iLCJpbXBvcnQgdG9OdW1iZXIgZnJvbSAnLi90b051bWJlci5qcyc7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDAsXG4gICAgTUFYX0lOVEVHRVIgPSAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwODtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgZmluaXRlIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTIuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgbnVtYmVyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvRmluaXRlKDMuMik7XG4gKiAvLyA9PiAzLjJcbiAqXG4gKiBfLnRvRmluaXRlKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gNWUtMzI0XG4gKlxuICogXy50b0Zpbml0ZShJbmZpbml0eSk7XG4gKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICpcbiAqIF8udG9GaW5pdGUoJzMuMicpO1xuICogLy8gPT4gMy4yXG4gKi9cbmZ1bmN0aW9uIHRvRmluaXRlKHZhbHVlKSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6IDA7XG4gIH1cbiAgdmFsdWUgPSB0b051bWJlcih2YWx1ZSk7XG4gIGlmICh2YWx1ZSA9PT0gSU5GSU5JVFkgfHwgdmFsdWUgPT09IC1JTkZJTklUWSkge1xuICAgIHZhciBzaWduID0gKHZhbHVlIDwgMCA/IC0xIDogMSk7XG4gICAgcmV0dXJuIHNpZ24gKiBNQVhfSU5URUdFUjtcbiAgfVxuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlID8gdmFsdWUgOiAwO1xufVxuXG5leHBvcnQgZGVmYXVsdCB0b0Zpbml0ZTtcbiIsImltcG9ydCB0b0Zpbml0ZSBmcm9tICcuL3RvRmluaXRlLmpzJztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGludGVnZXIuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9JbnRlZ2VyYF0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvaW50ZWdlcikuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b0ludGVnZXIoMy4yKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLnRvSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDBcbiAqXG4gKiBfLnRvSW50ZWdlcihJbmZpbml0eSk7XG4gKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICpcbiAqIF8udG9JbnRlZ2VyKCczLjInKTtcbiAqIC8vID0+IDNcbiAqL1xuZnVuY3Rpb24gdG9JbnRlZ2VyKHZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSB0b0Zpbml0ZSh2YWx1ZSksXG4gICAgICByZW1haW5kZXIgPSByZXN1bHQgJSAxO1xuXG4gIHJldHVybiByZXN1bHQgPT09IHJlc3VsdCA/IChyZW1haW5kZXIgPyByZXN1bHQgLSByZW1haW5kZXIgOiByZXN1bHQpIDogMDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdG9JbnRlZ2VyO1xuIiwiaW1wb3J0IGJhc2VTZXREYXRhIGZyb20gJy4vX2Jhc2VTZXREYXRhLmpzJztcbmltcG9ydCBjcmVhdGVCaW5kIGZyb20gJy4vX2NyZWF0ZUJpbmQuanMnO1xuaW1wb3J0IGNyZWF0ZUN1cnJ5IGZyb20gJy4vX2NyZWF0ZUN1cnJ5LmpzJztcbmltcG9ydCBjcmVhdGVIeWJyaWQgZnJvbSAnLi9fY3JlYXRlSHlicmlkLmpzJztcbmltcG9ydCBjcmVhdGVQYXJ0aWFsIGZyb20gJy4vX2NyZWF0ZVBhcnRpYWwuanMnO1xuaW1wb3J0IGdldERhdGEgZnJvbSAnLi9fZ2V0RGF0YS5qcyc7XG5pbXBvcnQgbWVyZ2VEYXRhIGZyb20gJy4vX21lcmdlRGF0YS5qcyc7XG5pbXBvcnQgc2V0RGF0YSBmcm9tICcuL19zZXREYXRhLmpzJztcbmltcG9ydCBzZXRXcmFwVG9TdHJpbmcgZnJvbSAnLi9fc2V0V3JhcFRvU3RyaW5nLmpzJztcbmltcG9ydCB0b0ludGVnZXIgZnJvbSAnLi90b0ludGVnZXIuanMnO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBmdW5jdGlvbiBtZXRhZGF0YS4gKi9cbnZhciBXUkFQX0JJTkRfRkxBRyA9IDEsXG4gICAgV1JBUF9CSU5EX0tFWV9GTEFHID0gMixcbiAgICBXUkFQX0NVUlJZX0ZMQUcgPSA4LFxuICAgIFdSQVBfQ1VSUllfUklHSFRfRkxBRyA9IDE2LFxuICAgIFdSQVBfUEFSVElBTF9GTEFHID0gMzIsXG4gICAgV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcgPSA2NDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGVpdGhlciBjdXJyaWVzIG9yIGludm9rZXMgYGZ1bmNgIHdpdGggb3B0aW9uYWxcbiAqIGB0aGlzYCBiaW5kaW5nIGFuZCBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb258c3RyaW5nfSBmdW5jIFRoZSBmdW5jdGlvbiBvciBtZXRob2QgbmFtZSB0byB3cmFwLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gKiAgICAxIC0gYF8uYmluZGBcbiAqICAgIDIgLSBgXy5iaW5kS2V5YFxuICogICAgNCAtIGBfLmN1cnJ5YCBvciBgXy5jdXJyeVJpZ2h0YCBvZiBhIGJvdW5kIGZ1bmN0aW9uXG4gKiAgICA4IC0gYF8uY3VycnlgXG4gKiAgIDE2IC0gYF8uY3VycnlSaWdodGBcbiAqICAgMzIgLSBgXy5wYXJ0aWFsYFxuICogICA2NCAtIGBfLnBhcnRpYWxSaWdodGBcbiAqICAxMjggLSBgXy5yZWFyZ2BcbiAqICAyNTYgLSBgXy5hcnlgXG4gKiAgNTEyIC0gYF8uZmxpcGBcbiAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gKiBAcGFyYW0ge0FycmF5fSBbaG9sZGVyc10gVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAqIEBwYXJhbSB7QXJyYXl9IFthcmdQb3NdIFRoZSBhcmd1bWVudCBwb3NpdGlvbnMgb2YgdGhlIG5ldyBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbYXJ5XSBUaGUgYXJpdHkgY2FwIG9mIGBmdW5jYC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHldIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVXcmFwKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzLCBhcmdQb3MsIGFyeSwgYXJpdHkpIHtcbiAgdmFyIGlzQmluZEtleSA9IGJpdG1hc2sgJiBXUkFQX0JJTkRfS0VZX0ZMQUc7XG4gIGlmICghaXNCaW5kS2V5ICYmIHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgdmFyIGxlbmd0aCA9IHBhcnRpYWxzID8gcGFydGlhbHMubGVuZ3RoIDogMDtcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBiaXRtYXNrICY9IH4oV1JBUF9QQVJUSUFMX0ZMQUcgfCBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRyk7XG4gICAgcGFydGlhbHMgPSBob2xkZXJzID0gdW5kZWZpbmVkO1xuICB9XG4gIGFyeSA9IGFyeSA9PT0gdW5kZWZpbmVkID8gYXJ5IDogbmF0aXZlTWF4KHRvSW50ZWdlcihhcnkpLCAwKTtcbiAgYXJpdHkgPSBhcml0eSA9PT0gdW5kZWZpbmVkID8gYXJpdHkgOiB0b0ludGVnZXIoYXJpdHkpO1xuICBsZW5ndGggLT0gaG9sZGVycyA/IGhvbGRlcnMubGVuZ3RoIDogMDtcblxuICBpZiAoYml0bWFzayAmIFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHKSB7XG4gICAgdmFyIHBhcnRpYWxzUmlnaHQgPSBwYXJ0aWFscyxcbiAgICAgICAgaG9sZGVyc1JpZ2h0ID0gaG9sZGVycztcblxuICAgIHBhcnRpYWxzID0gaG9sZGVycyA9IHVuZGVmaW5lZDtcbiAgfVxuICB2YXIgZGF0YSA9IGlzQmluZEtleSA/IHVuZGVmaW5lZCA6IGdldERhdGEoZnVuYyk7XG5cbiAgdmFyIG5ld0RhdGEgPSBbXG4gICAgZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMsIHBhcnRpYWxzUmlnaHQsIGhvbGRlcnNSaWdodCxcbiAgICBhcmdQb3MsIGFyeSwgYXJpdHlcbiAgXTtcblxuICBpZiAoZGF0YSkge1xuICAgIG1lcmdlRGF0YShuZXdEYXRhLCBkYXRhKTtcbiAgfVxuICBmdW5jID0gbmV3RGF0YVswXTtcbiAgYml0bWFzayA9IG5ld0RhdGFbMV07XG4gIHRoaXNBcmcgPSBuZXdEYXRhWzJdO1xuICBwYXJ0aWFscyA9IG5ld0RhdGFbM107XG4gIGhvbGRlcnMgPSBuZXdEYXRhWzRdO1xuICBhcml0eSA9IG5ld0RhdGFbOV0gPSBuZXdEYXRhWzldID09PSB1bmRlZmluZWRcbiAgICA/IChpc0JpbmRLZXkgPyAwIDogZnVuYy5sZW5ndGgpXG4gICAgOiBuYXRpdmVNYXgobmV3RGF0YVs5XSAtIGxlbmd0aCwgMCk7XG5cbiAgaWYgKCFhcml0eSAmJiBiaXRtYXNrICYgKFdSQVBfQ1VSUllfRkxBRyB8IFdSQVBfQ1VSUllfUklHSFRfRkxBRykpIHtcbiAgICBiaXRtYXNrICY9IH4oV1JBUF9DVVJSWV9GTEFHIHwgV1JBUF9DVVJSWV9SSUdIVF9GTEFHKTtcbiAgfVxuICBpZiAoIWJpdG1hc2sgfHwgYml0bWFzayA9PSBXUkFQX0JJTkRfRkxBRykge1xuICAgIHZhciByZXN1bHQgPSBjcmVhdGVCaW5kKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcpO1xuICB9IGVsc2UgaWYgKGJpdG1hc2sgPT0gV1JBUF9DVVJSWV9GTEFHIHx8IGJpdG1hc2sgPT0gV1JBUF9DVVJSWV9SSUdIVF9GTEFHKSB7XG4gICAgcmVzdWx0ID0gY3JlYXRlQ3VycnkoZnVuYywgYml0bWFzaywgYXJpdHkpO1xuICB9IGVsc2UgaWYgKChiaXRtYXNrID09IFdSQVBfUEFSVElBTF9GTEFHIHx8IGJpdG1hc2sgPT0gKFdSQVBfQklORF9GTEFHIHwgV1JBUF9QQVJUSUFMX0ZMQUcpKSAmJiAhaG9sZGVycy5sZW5ndGgpIHtcbiAgICByZXN1bHQgPSBjcmVhdGVQYXJ0aWFsKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSBjcmVhdGVIeWJyaWQuYXBwbHkodW5kZWZpbmVkLCBuZXdEYXRhKTtcbiAgfVxuICB2YXIgc2V0dGVyID0gZGF0YSA/IGJhc2VTZXREYXRhIDogc2V0RGF0YTtcbiAgcmV0dXJuIHNldFdyYXBUb1N0cmluZyhzZXR0ZXIocmVzdWx0LCBuZXdEYXRhKSwgZnVuYywgYml0bWFzayk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZVdyYXA7XG4iLCJpbXBvcnQgYmFzZVJlc3QgZnJvbSAnLi9fYmFzZVJlc3QuanMnO1xuaW1wb3J0IGNyZWF0ZVdyYXAgZnJvbSAnLi9fY3JlYXRlV3JhcC5qcyc7XG5pbXBvcnQgZ2V0SG9sZGVyIGZyb20gJy4vX2dldEhvbGRlci5qcyc7XG5pbXBvcnQgcmVwbGFjZUhvbGRlcnMgZnJvbSAnLi9fcmVwbGFjZUhvbGRlcnMuanMnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBmdW5jdGlvbiBtZXRhZGF0YS4gKi9cbnZhciBXUkFQX0JJTkRfRkxBRyA9IDEsXG4gICAgV1JBUF9QQVJUSUFMX0ZMQUcgPSAzMjtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2BcbiAqIGFuZCBgcGFydGlhbHNgIHByZXBlbmRlZCB0byB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxuICpcbiAqIFRoZSBgXy5iaW5kLnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWMgYnVpbGRzLFxuICogbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICpcbiAqICoqTm90ZToqKiBVbmxpa2UgbmF0aXZlIGBGdW5jdGlvbiNiaW5kYCwgdGhpcyBtZXRob2QgZG9lc24ndCBzZXQgdGhlIFwibGVuZ3RoXCJcbiAqIHByb3BlcnR5IG9mIGJvdW5kIGZ1bmN0aW9ucy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGJpbmQuXG4gKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAqIEBwYXJhbSB7Li4uKn0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYm91bmQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIGdyZWV0KGdyZWV0aW5nLCBwdW5jdHVhdGlvbikge1xuICogICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyB0aGlzLnVzZXIgKyBwdW5jdHVhdGlvbjtcbiAqIH1cbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAndXNlcic6ICdmcmVkJyB9O1xuICpcbiAqIHZhciBib3VuZCA9IF8uYmluZChncmVldCwgb2JqZWN0LCAnaGknKTtcbiAqIGJvdW5kKCchJyk7XG4gKiAvLyA9PiAnaGkgZnJlZCEnXG4gKlxuICogLy8gQm91bmQgd2l0aCBwbGFjZWhvbGRlcnMuXG4gKiB2YXIgYm91bmQgPSBfLmJpbmQoZ3JlZXQsIG9iamVjdCwgXywgJyEnKTtcbiAqIGJvdW5kKCdoaScpO1xuICogLy8gPT4gJ2hpIGZyZWQhJ1xuICovXG52YXIgYmluZCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIHRoaXNBcmcsIHBhcnRpYWxzKSB7XG4gIHZhciBiaXRtYXNrID0gV1JBUF9CSU5EX0ZMQUc7XG4gIGlmIChwYXJ0aWFscy5sZW5ndGgpIHtcbiAgICB2YXIgaG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKHBhcnRpYWxzLCBnZXRIb2xkZXIoYmluZCkpO1xuICAgIGJpdG1hc2sgfD0gV1JBUF9QQVJUSUFMX0ZMQUc7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMpO1xufSk7XG5cbi8vIEFzc2lnbiBkZWZhdWx0IHBsYWNlaG9sZGVycy5cbmJpbmQucGxhY2Vob2xkZXIgPSB7fTtcblxuZXhwb3J0IGRlZmF1bHQgYmluZDtcbiIsImV4cG9ydCBkZWZhdWx0IHtcblxuICAgIC8vIGByZXNwb25zZVR5cGVgIGluZGljYXRlcyB0aGUgdHlwZSBvZiBkYXRhIHRoYXQgdGhlIHNlcnZlciB3aWxsIHJlc3BvbmQgd2l0aFxuICAgIC8vIG9wdGlvbnMgYXJlICdhcnJheWJ1ZmZlcicsICdibG9iJywgJ2RvY3VtZW50JywgJ2pzb24nLCAndGV4dCcsICdzdHJlYW0nXG4gICAgcmVzcG9uc2VUeXBlOiAnanNvbicsIC8vIGRlZmF1bHRcblxuICAgIC8vIGB0cmFuc2Zvcm1SZXF1ZXN0YCBhbGxvd3MgY2hhbmdlcyB0byB0aGUgcmVxdWVzdCBkYXRhIGJlZm9yZSBpdCBpcyBzZW50IHRvIHRoZSBzZXJ2ZXJcbiAgICAvLyBUaGlzIGlzIG9ubHkgYXBwbGljYWJsZSBmb3IgcmVxdWVzdCBtZXRob2RzICdQVVQnLCAnUE9TVCcsIGFuZCAnUEFUQ0gnXG4gICAgLy8gVGhlIGxhc3QgZnVuY3Rpb24gaW4gdGhlIGFycmF5IG11c3QgcmV0dXJuIGEgc3RyaW5nIG9yIGFuIGluc3RhbmNlIG9mIEJ1ZmZlciwgQXJyYXlCdWZmZXIsXG4gICAgLy8gRm9ybURhdGEgb3IgU3RyZWFtXG4gICAgLy8gWW91IG1heSBtb2RpZnkgdGhlIGhlYWRlcnMgb2JqZWN0LlxuICAgIHRyYW5zZm9ybVJlcXVlc3Q6IFtdLFxuXG4gICAgLy8gYHRyYW5zZm9ybVJlc3BvbnNlYCBhbGxvd3MgY2hhbmdlcyB0byB0aGUgcmVzcG9uc2UgZGF0YSB0byBiZSBtYWRlIGJlZm9yZVxuICAgIC8vIGl0IGlzIHBhc3NlZCB0byB0aGVuL2NhdGNoXG4gICAgdHJhbnNmb3JtUmVzcG9uc2U6IFtdXG5cbiAgICAvKlxuICAgIC8vIGB1cmxgIGlzIHRoZSBzZXJ2ZXIgVVJMIHRoYXQgd2lsbCBiZSB1c2VkIGZvciB0aGUgcmVxdWVzdFxuXG4gICAgLy8gYG1ldGhvZGAgaXMgdGhlIHJlcXVlc3QgbWV0aG9kIHRvIGJlIHVzZWQgd2hlbiBtYWtpbmcgdGhlIHJlcXVlc3RcbiAgICBtZXRob2Q6ICdnZXQnLCAvLyBkZWZhdWx0XG5cbiAgICAvLyBgYmFzZVVSTGAgd2lsbCBiZSBwcmVwZW5kZWQgdG8gYHVybGAgdW5sZXNzIGB1cmxgIGlzIGFic29sdXRlLlxuICAgIC8vIEl0IGNhbiBiZSBjb252ZW5pZW50IHRvIHNldCBgYmFzZVVSTGAgZm9yIGFuIGluc3RhbmNlIG9mIGF4aW9zIHRvIHBhc3MgcmVsYXRpdmUgVVJMc1xuICAgIC8vIHRvIG1ldGhvZHMgb2YgdGhhdCBpbnN0YW5jZS5cbiAgICBiYXNlVVJMOiAnaHR0cHM6Ly9zb21lLWRvbWFpbi5jb20vYXBpLycsXG5cbiAgICAvLyBgaGVhZGVyc2AgYXJlIGN1c3RvbSBoZWFkZXJzIHRvIGJlIHNlbnRcbiAgICBoZWFkZXJzOiB7J1gtUmVxdWVzdGVkLVdpdGgnOiAnWE1MSHR0cFJlcXVlc3QnfSxcblxuICAgIC8vIGBwYXJhbXNgIGFyZSB0aGUgVVJMIHBhcmFtZXRlcnMgdG8gYmUgc2VudCB3aXRoIHRoZSByZXF1ZXN0XG4gICAgLy8gTXVzdCBiZSBhIHBsYWluIG9iamVjdCBvciBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3RcbiAgICBwYXJhbXM6IHtcbiAgICAgICAgSUQ6IDEyMzQ1XG4gICAgfSxcblxuICAgIC8vIGBwYXJhbXNTZXJpYWxpemVyYCBpcyBhbiBvcHRpb25hbCBmdW5jdGlvbiBpbiBjaGFyZ2Ugb2Ygc2VyaWFsaXppbmcgYHBhcmFtc2BcbiAgICAvLyAoZS5nLiBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9xcywgaHR0cDovL2FwaS5qcXVlcnkuY29tL2pxdWVyeS5wYXJhbS8pXG4gICAgcGFyYW1zU2VyaWFsaXplcjogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBRcy5zdHJpbmdpZnkocGFyYW1zLCB7YXJyYXlGb3JtYXQ6ICdicmFja2V0cyd9KVxuICAgIH0sXG5cbiAgICAvLyBgZGF0YWAgaXMgdGhlIGRhdGEgdG8gYmUgc2VudCBhcyB0aGUgcmVxdWVzdCBib2R5XG4gICAgLy8gT25seSBhcHBsaWNhYmxlIGZvciByZXF1ZXN0IG1ldGhvZHMgJ1BVVCcsICdQT1NUJywgYW5kICdQQVRDSCdcbiAgICAvLyBXaGVuIG5vIGB0cmFuc2Zvcm1SZXF1ZXN0YCBpcyBzZXQsIG11c3QgYmUgb2Ygb25lIG9mIHRoZSBmb2xsb3dpbmcgdHlwZXM6XG4gICAgLy8gLSBzdHJpbmcsIHBsYWluIG9iamVjdCwgQXJyYXlCdWZmZXIsIEFycmF5QnVmZmVyVmlldywgVVJMU2VhcmNoUGFyYW1zXG4gICAgLy8gLSBCcm93c2VyIG9ubHk6IEZvcm1EYXRhLCBGaWxlLCBCbG9iXG4gICAgLy8gLSBOb2RlIG9ubHk6IFN0cmVhbSwgQnVmZmVyXG4gICAgZGF0YToge1xuICAgICAgICBmaXJzdE5hbWU6ICdGcmVkJ1xuICAgIH0sXG5cbiAgICAvLyBgdGltZW91dGAgc3BlY2lmaWVzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGJlZm9yZSB0aGUgcmVxdWVzdCB0aW1lcyBvdXQuXG4gICAgLy8gSWYgdGhlIHJlcXVlc3QgdGFrZXMgbG9uZ2VyIHRoYW4gYHRpbWVvdXRgLCB0aGUgcmVxdWVzdCB3aWxsIGJlIGFib3J0ZWQuXG4gICAgdGltZW91dDogMTAwMCxcblxuICAgIC8vIGB3aXRoQ3JlZGVudGlhbHNgIGluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCBjcm9zcy1zaXRlIEFjY2Vzcy1Db250cm9sIHJlcXVlc3RzXG4gICAgLy8gc2hvdWxkIGJlIG1hZGUgdXNpbmcgY3JlZGVudGlhbHNcbiAgICB3aXRoQ3JlZGVudGlhbHM6IGZhbHNlLCAvLyBkZWZhdWx0XG5cbiAgICAvLyBgYWRhcHRlcmAgYWxsb3dzIGN1c3RvbSBoYW5kbGluZyBvZiByZXF1ZXN0cyB3aGljaCBtYWtlcyB0ZXN0aW5nIGVhc2llci5cbiAgICAvLyBSZXR1cm4gYSBwcm9taXNlIGFuZCBzdXBwbHkgYSB2YWxpZCByZXNwb25zZSAoc2VlIGxpYi9hZGFwdGVycy9SRUFETUUubWQpLlxuICAgIGFkYXB0ZXI6IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgLy9cbiAgICB9LFxuXG4gICAgLy8gYGF1dGhgIGluZGljYXRlcyB0aGF0IEhUVFAgQmFzaWMgYXV0aCBzaG91bGQgYmUgdXNlZCwgYW5kIHN1cHBsaWVzIGNyZWRlbnRpYWxzLlxuICAgIC8vIFRoaXMgd2lsbCBzZXQgYW4gYEF1dGhvcml6YXRpb25gIGhlYWRlciwgb3ZlcndyaXRpbmcgYW55IGV4aXN0aW5nXG4gICAgLy8gYEF1dGhvcml6YXRpb25gIGN1c3RvbSBoZWFkZXJzIHlvdSBoYXZlIHNldCB1c2luZyBgaGVhZGVyc2AuXG4gICAgYXV0aDoge1xuICAgICAgICB1c2VybmFtZTogJ2phbmVkb2UnLFxuICAgICAgICBwYXNzd29yZDogJ3MwMHBlcnMzY3JldCdcbiAgICB9LFxuXG4gICAgLy8gYHJlc3BvbnNlRW5jb2RpbmdgIGluZGljYXRlcyBlbmNvZGluZyB0byB1c2UgZm9yIGRlY29kaW5nIHJlc3BvbnNlc1xuICAgIC8vIE5vdGU6IElnbm9yZWQgZm9yIGByZXNwb25zZVR5cGVgIG9mICdzdHJlYW0nIG9yIGNsaWVudC1zaWRlIHJlcXVlc3RzXG4gICAgcmVzcG9uc2VFbmNvZGluZzogJ3V0ZjgnLCAvLyBkZWZhdWx0XG5cbiAgICAvLyBgeHNyZkNvb2tpZU5hbWVgIGlzIHRoZSBuYW1lIG9mIHRoZSBjb29raWUgdG8gdXNlIGFzIGEgdmFsdWUgZm9yIHhzcmYgdG9rZW5cbiAgICB4c3JmQ29va2llTmFtZTogJ1hTUkYtVE9LRU4nLCAvLyBkZWZhdWx0XG5cbiAgICAvLyBgeHNyZkhlYWRlck5hbWVgIGlzIHRoZSBuYW1lIG9mIHRoZSBodHRwIGhlYWRlciB0aGF0IGNhcnJpZXMgdGhlIHhzcmYgdG9rZW4gdmFsdWVcbiAgICB4c3JmSGVhZGVyTmFtZTogJ1gtWFNSRi1UT0tFTicsIC8vIGRlZmF1bHRcblxuICAgIC8vIGBvblVwbG9hZFByb2dyZXNzYCBhbGxvd3MgaGFuZGxpbmcgb2YgcHJvZ3Jlc3MgZXZlbnRzIGZvciB1cGxvYWRzXG4gICAgb25VcGxvYWRQcm9ncmVzczogZnVuY3Rpb24gKHByb2dyZXNzRXZlbnQpIHtcbiAgICAgICAgLy8gRG8gd2hhdGV2ZXIgeW91IHdhbnQgd2l0aCB0aGUgbmF0aXZlIHByb2dyZXNzIGV2ZW50XG4gICAgfSxcblxuICAgIC8vIGBvbkRvd25sb2FkUHJvZ3Jlc3NgIGFsbG93cyBoYW5kbGluZyBvZiBwcm9ncmVzcyBldmVudHMgZm9yIGRvd25sb2Fkc1xuICAgIG9uRG93bmxvYWRQcm9ncmVzczogZnVuY3Rpb24gKHByb2dyZXNzRXZlbnQpIHtcbiAgICAgICAgLy8gRG8gd2hhdGV2ZXIgeW91IHdhbnQgd2l0aCB0aGUgbmF0aXZlIHByb2dyZXNzIGV2ZW50XG4gICAgfSxcblxuICAgIC8vIGBtYXhDb250ZW50TGVuZ3RoYCBkZWZpbmVzIHRoZSBtYXggc2l6ZSBvZiB0aGUgaHR0cCByZXNwb25zZSBjb250ZW50IGluIGJ5dGVzIGFsbG93ZWRcbiAgICBtYXhDb250ZW50TGVuZ3RoOiAyMDAwLFxuXG4gICAgLy8gYHZhbGlkYXRlU3RhdHVzYCBkZWZpbmVzIHdoZXRoZXIgdG8gcmVzb2x2ZSBvciByZWplY3QgdGhlIHByb21pc2UgZm9yIGEgZ2l2ZW5cbiAgICAvLyBIVFRQIHJlc3BvbnNlIHN0YXR1cyBjb2RlLiBJZiBgdmFsaWRhdGVTdGF0dXNgIHJldHVybnMgYHRydWVgIChvciBpcyBzZXQgdG8gYG51bGxgXG4gICAgLy8gb3IgYHVuZGVmaW5lZGApLCB0aGUgcHJvbWlzZSB3aWxsIGJlIHJlc29sdmVkOyBvdGhlcndpc2UsIHRoZSBwcm9taXNlIHdpbGwgYmVcbiAgICAvLyByZWplY3RlZC5cbiAgICB2YWxpZGF0ZVN0YXR1czogZnVuY3Rpb24gKHN0YXR1cykge1xuICAgICAgICByZXR1cm4gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDA7IC8vIGRlZmF1bHRcbiAgICB9LFxuXG4gICAgLy8gYG1heFJlZGlyZWN0c2AgZGVmaW5lcyB0aGUgbWF4aW11bSBudW1iZXIgb2YgcmVkaXJlY3RzIHRvIGZvbGxvdyBpbiBub2RlLmpzLlxuICAgIC8vIElmIHNldCB0byAwLCBubyByZWRpcmVjdHMgd2lsbCBiZSBmb2xsb3dlZC5cbiAgICBtYXhSZWRpcmVjdHM6IDUsIC8vIGRlZmF1bHRcblxuICAgIC8vIGBzb2NrZXRQYXRoYCBkZWZpbmVzIGEgVU5JWCBTb2NrZXQgdG8gYmUgdXNlZCBpbiBub2RlLmpzLlxuICAgIC8vIGUuZy4gJy92YXIvcnVuL2RvY2tlci5zb2NrJyB0byBzZW5kIHJlcXVlc3RzIHRvIHRoZSBkb2NrZXIgZGFlbW9uLlxuICAgIC8vIE9ubHkgZWl0aGVyIGBzb2NrZXRQYXRoYCBvciBgcHJveHlgIGNhbiBiZSBzcGVjaWZpZWQuXG4gICAgLy8gSWYgYm90aCBhcmUgc3BlY2lmaWVkLCBgc29ja2V0UGF0aGAgaXMgdXNlZC5cbiAgICBzb2NrZXRQYXRoOiBudWxsLCAvLyBkZWZhdWx0XG5cbiAgICAvLyBgaHR0cEFnZW50YCBhbmQgYGh0dHBzQWdlbnRgIGRlZmluZSBhIGN1c3RvbSBhZ2VudCB0byBiZSB1c2VkIHdoZW4gcGVyZm9ybWluZyBodHRwXG4gICAgLy8gYW5kIGh0dHBzIHJlcXVlc3RzLCByZXNwZWN0aXZlbHksIGluIG5vZGUuanMuIFRoaXMgYWxsb3dzIG9wdGlvbnMgdG8gYmUgYWRkZWQgbGlrZVxuICAgIC8vIGBrZWVwQWxpdmVgIHRoYXQgYXJlIG5vdCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gICAgaHR0cEFnZW50OiBuZXcgaHR0cC5BZ2VudCh7IGtlZXBBbGl2ZTogdHJ1ZSB9KSxcbiAgICBodHRwc0FnZW50OiBuZXcgaHR0cHMuQWdlbnQoeyBrZWVwQWxpdmU6IHRydWUgfSksXG5cbiAgICAvLyAncHJveHknIGRlZmluZXMgdGhlIGhvc3RuYW1lIGFuZCBwb3J0IG9mIHRoZSBwcm94eSBzZXJ2ZXJcbiAgICAvLyBVc2UgYGZhbHNlYCB0byBkaXNhYmxlIHByb3hpZXMsIGlnbm9yaW5nIGVudmlyb25tZW50IHZhcmlhYmxlcy5cbiAgICAvLyBgYXV0aGAgaW5kaWNhdGVzIHRoYXQgSFRUUCBCYXNpYyBhdXRoIHNob3VsZCBiZSB1c2VkIHRvIGNvbm5lY3QgdG8gdGhlIHByb3h5LCBhbmRcbiAgICAvLyBzdXBwbGllcyBjcmVkZW50aWFscy5cbiAgICAvLyBUaGlzIHdpbGwgc2V0IGFuIGBQcm94eS1BdXRob3JpemF0aW9uYCBoZWFkZXIsIG92ZXJ3cml0aW5nIGFueSBleGlzdGluZ1xuICAgIC8vIGBQcm94eS1BdXRob3JpemF0aW9uYCBjdXN0b20gaGVhZGVycyB5b3UgaGF2ZSBzZXQgdXNpbmcgYGhlYWRlcnNgLlxuICAgIHByb3h5OiB7XG4gICAgICAgIGhvc3Q6ICcxMjcuMC4wLjEnLFxuICAgICAgICBwb3J0OiA5MDAwLFxuICAgICAgICBhdXRoOiB7XG4gICAgICAgICAgICB1c2VybmFtZTogJ21pa2V5bWlrZScsXG4gICAgICAgICAgICBwYXNzd29yZDogJ3JhcHVuejNsJ1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIGBjYW5jZWxUb2tlbmAgc3BlY2lmaWVzIGEgY2FuY2VsIHRva2VuIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2FuY2VsIHRoZSByZXF1ZXN0XG4gICAgLy8gKHNlZSBDYW5jZWxsYXRpb24gc2VjdGlvbiBiZWxvdyBmb3IgZGV0YWlscylcbiAgICBjYW5jZWxUb2tlbjogbmV3IENhbmNlbFRva2VuKGZ1bmN0aW9uIChjYW5jZWwpIHtcblxuICAgIH0pXG4gICAgKi9cblxufTtcbiIsImltcG9ydCB7IGlzRnVuY3Rpb24gfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IFJlcXVlc3RPcHRpb25zIGZyb20gJy4vUmVxdWVzdE9wdGlvbnMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0cmFuc2Zvcm1SZXF1ZXN0KHRyYW5zZm9ybWVyLCBjb250ZXh0KSB7XG4gICAgaWYoIWlzRnVuY3Rpb24odHJhbnNmb3JtZXIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHRyYW5zZm9ybWVyIG11c3QgYmUgZGVmaW5lZCBhcyBhIGZ1bmN0aW9uIHdpdGggdHdvIGFyZ3VtZW50cyAoZGF0YSwgaGVhZGVycykuJyk7XG4gICAgfVxuXG4gICAgKGNvbnRleHQgfHwgUmVxdWVzdE9wdGlvbnMudHJhbnNmb3JtUmVxdWVzdCkucHVzaCh0cmFuc2Zvcm1lcik7XG59XG4iLCJpbXBvcnQgeyBpc0Z1bmN0aW9uIH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCBSZXF1ZXN0T3B0aW9ucyBmcm9tICcuL1JlcXVlc3RPcHRpb25zJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdHJhbnNmb3JtUmVzcG9uc2UodHJhbnNmb3JtZXIsIGNvbnRleHQpIHtcbiAgICBpZighaXNGdW5jdGlvbih0cmFuc2Zvcm1lcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgdHJhbnNmb3JtZXIgbXVzdCBiZSBkZWZpbmVkIGFzIGEgZnVuY3Rpb24gKGRhdGEpLicpO1xuICAgIH1cblxuICAgIChjb250ZXh0IHx8IFJlcXVlc3RPcHRpb25zLnRyYW5zZm9ybVJlc3BvbnNlKS5wdXNoKHRyYW5zZm9ybWVyKTtcbn1cbiIsImltcG9ydCBheGlvcyBmcm9tICdheGlvcyc7XG5pbXBvcnQgbW9tZW50IGZyb20gJ21vbWVudCc7XG5pbXBvcnQgeyBiaW5kIH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCB7IGVhY2ggfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IHsgZmlyc3QgfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IHsgZXh0ZW5kIH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCB7IGlzQXJyYXkgfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IHsgaXNPYmplY3QgfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCB7IGNhbWVsQ2FzZSB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgeyBtZXJnZVdpdGggfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IFJlcXVlc3RPcHRpb25zIGZyb20gJy4vUmVxdWVzdE9wdGlvbnMnO1xuaW1wb3J0IHRyYW5zZm9ybVJlcXVlc3QgZnJvbSAnLi9UcmFuc2Zvcm1SZXF1ZXN0JztcbmltcG9ydCB0cmFuc2Zvcm1SZXNwb25zZSBmcm9tICcuL1RyYW5zZm9ybVJlc3BvbnNlJztcblxuY29uc3QgUFJPWFlfT1BUSU9OX1BST1BFUlRJRVMgPSBbXG4gICAgJ2hlYWRlcnMnLFxuICAgICdwYXJhbXMnLFxuICAgICdkYXRhJ1xuXTtcblxuY29uc3QgUFJPWFlfT1BUSU9OX01FVEhPRFMgPSB7XG4gICAgZ2V0KHByb3AsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0W3Byb3BdO1xuICAgICAgICB9O1xuICAgIH0sXG4gICAgc2V0KHByb3AsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgY29udGV4dFtwcm9wXSA9IHZhbHVlO1xuICAgICAgICB9O1xuICAgIH0sXG4gICAgYWRkKHByb3AsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBjb250ZXh0W3Byb3BdW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHJlbW92ZShwcm9wLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiAoa2V5KSA9PiB7XG4gICAgICAgICAgICBkZWxldGUgY29udGV4dFtwcm9wXVtrZXldO1xuICAgICAgICB9O1xuICAgIH0sXG4gICAgbWVyZ2UocHJvcCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gKGtleSwgdmFsdWVzKSA9PiB7XG4gICAgICAgICAgICBleHRlbmQoY29udGV4dFtwcm9wXSwga2V5KTtcbiAgICAgICAgfTtcbiAgICB9XG59O1xuXG5jb25zdCBtZXRob2QgPSBmdW5jdGlvbihhY3Rpb24sIHByb3ApIHtcbiAgICByZXR1cm4gY2FtZWxDYXNlKFthY3Rpb24sIHByb3BdLmpvaW4oJyAnKSk7XG59O1xuXG5jb25zdCBjaGFpbmFibGUgPSBmdW5jdGlvbihwcm9wKSB7XG4gICAgcmV0dXJuIChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgIGlmKGtleSBpbnN0YW5jZW9mIEZvcm1EYXRhKSB7XG4gICAgICAgICAgICB0aGlzW21ldGhvZCgnc2V0JywgcHJvcCldKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihpc09iamVjdChrZXkpKSB7XG4gICAgICAgICAgICB0aGlzW21ldGhvZCgnbWVyZ2UnLCBwcm9wKV0oa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXNbbWV0aG9kKCdhZGQnLCBwcm9wKV0oa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xufTtcblxuZnVuY3Rpb24gbWVyZ2UoKSB7XG4gICAgY29uc3QgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICBjb25zdCBpdGVtcyA9IGFyZ3Muc3BsaWNlKDEpO1xuICAgIGxldCBzdWJqZWN0ID0gZmlyc3QoYXJncyk7XG5cbiAgICBmb3IobGV0IGkgaW4gaXRlbXMpIHtcbiAgICAgICAgc3ViamVjdCA9IG1lcmdlV2l0aChzdWJqZWN0LCBpdGVtc1tpXSwgKHN1YmplY3QsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZihpc0FycmF5KHN1YmplY3QpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1YmplY3QuY29uY2F0KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYoaXNPYmplY3Qoc3ViamVjdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXh0ZW5kKHN1YmplY3QsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3ViamVjdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVxdWVzdCB7XG5cbiAgICBjb25zdHJ1Y3Rvcih1cmwsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0aGlzLiRvcHRpb25zID0gbWVyZ2Uoe1xuICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICBkYXRhOiB7fSxcbiAgICAgICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgICAgICAgcGFyYW1zOiB7fSxcbiAgICAgICAgfSwgY2xvbmVEZWVwKFJlcXVlc3RPcHRpb25zKSwgb3B0aW9ucywge1xuICAgICAgICAgICAgY2FuY2VsVG9rZW46IG5ldyBheGlvcy5DYW5jZWxUb2tlbihjYW5jZWwgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuJGNhbmNlbCA9IGNhbmNlbDtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGVhY2goUFJPWFlfT1BUSU9OX01FVEhPRFMsIChjYWxsYmFjaywga2V5KSA9PiB7XG4gICAgICAgICAgICB0aGlzW21ldGhvZChrZXksICdvcHRpb24nKV0gPSBiaW5kKGNhbGxiYWNrKSgnJG9wdGlvbnMnLCB0aGlzKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZWFjaChQUk9YWV9PUFRJT05fUFJPUEVSVElFUywgKHByb3ApID0+IHtcbiAgICAgICAgICAgIGVhY2goUFJPWFlfT1BUSU9OX01FVEhPRFMsIChjYWxsYmFjaywga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpc1ttZXRob2Qoa2V5LCBwcm9wKV0gPSBiaW5kKGNhbGxiYWNrKShwcm9wLCB0aGlzLiRvcHRpb25zKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzW3Byb3BdID0gYmluZChjaGFpbmFibGUsIHRoaXMpKHByb3ApO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgfVxuXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuJGVycm9yID0gbnVsbDtcbiAgICAgICAgdGhpcy4kc3RhdHVzID0gbnVsbDtcbiAgICAgICAgdGhpcy4kc3RhdHVzVGV4dCA9IG51bGw7XG4gICAgICAgIHRoaXMuJHJlc3BvbnNlID0gbnVsbDtcbiAgICAgICAgdGhpcy4kcmVxdWVzdFNlbnRBdCA9IG51bGw7XG4gICAgICAgIHRoaXMuJHJlc3BvbnNlUmVjZWl2ZWRBdCA9IG51bGw7XG4gICAgfVxuXG4gICAgaGFzU2VudCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy4kcmVxdWVzdFNlbnRBdDtcbiAgICB9XG5cbiAgICBoYXNSZXNwb25zZSgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy4kcmVzcG9uc2VSZWNlaXZlZEF0O1xuICAgIH1cblxuICAgIHBhc3NlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzUmVzcG9uc2UoKSAmJiAhdGhpcy4kZXJyb3I7XG4gICAgfVxuXG4gICAgZmFpbGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNSZXNwb25zZSgpICYmICEhdGhpcy4kZXJyb3I7XG4gICAgfVxuXG4gICAgY2FuY2VsKCkge1xuICAgICAgICAhdGhpcy4kcmVzcG9uc2UgJiYgdGhpcy4kY2FuY2VsKCk7XG4gICAgfVxuXG4gICAgZ2V0KHBhcmFtcyA9IHt9LCBoZWFkZXJzID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyYW1zKHBhcmFtcykuaGVhZGVycyhoZWFkZXJzKS5zZW5kKCdnZXQnKTtcbiAgICB9XG5cbiAgICBwb3N0KGRhdGEgPSB7fSwgaGVhZGVycyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEoZGF0YSkuaGVhZGVycyhoZWFkZXJzKS5zZW5kKCdwb3N0Jyk7XG4gICAgfVxuXG4gICAgcHV0KGRhdGEgPSB7fSwgaGVhZGVycyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEoZGF0YSkuaGVhZGVycyhoZWFkZXJzKS5zZW5kKCdwdXQnKTtcbiAgICB9XG5cbiAgICBkZWxldGUoaGVhZGVycyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhlYWRlcnMoaGVhZGVycykuc2VuZCgnZGVsZXRlJyk7XG4gICAgfVxuXG4gICAgc2VuZChtZXRob2QpIHtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICB0aGlzLiRyZXF1ZXN0U2VudEF0ID0gbW9tZW50KCk7XG4gICAgICAgIHRoaXMuYWRkT3B0aW9uKCdtZXRob2QnLCBtZXRob2QpO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBheGlvcyh0aGlzLiRvcHRpb25zKS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLiRyZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIHRoaXMuJHJlc3BvbnNlUmVjZWl2ZWRBdCA9IG1vbWVudCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuJHN0YXR1cyA9IHJlc3BvbnNlLnN0YXR1cztcbiAgICAgICAgICAgICAgICB0aGlzLiRzdGF0dXNUZXh0ID0gcmVzcG9uc2Uuc3RhdHVzVGV4dDtcblxuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzcG9uc2UuZGF0YSk7XG4gICAgICAgICAgICB9LCBlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy4kZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICB0aGlzLiRyZXNwb25zZSA9IGVycm9yLnJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIHRoaXMuJHJlc3BvbnNlUmVjZWl2ZWRBdCA9IG1vbWVudCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuJHN0YXR1cyA9IGVycm9yLnJlc3BvbnNlID8gZXJyb3IucmVzcG9uc2Uuc3RhdHVzIDogbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLiRzdGF0dXNUZXh0ID0gZXJyb3IucmVzcG9uc2UgPyBlcnJvci5yZXNwb25zZS5zdGF0dXNUZXh0IDogbnVsbDtcblxuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvci5yZXNwb25zZSB8fCBlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdHJhbnNmb3JtUmVxdWVzdCh0cmFuc2Zvcm1lcikge1xuICAgICAgICBpZighdGhpcy4kb3B0aW9ucy50cmFuc2Zvcm1SZXF1ZXN0KSB7XG4gICAgICAgICAgICB0aGlzLiRvcHRpb25zLnRyYW5zZm9ybVJlcXVlc3QgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyYW5zZm9ybVJlcXVlc3QodHJhbnNmb3JtZXIsIHRoaXMuJG9wdGlvbnMudHJhbnNmb3JtUmVxdWVzdCk7XG4gICAgfVxuXG4gICAgdHJhbnNmb3JtUmVzcG9uc2UodHJhbnNmb3JtZXIpIHtcbiAgICAgICAgaWYodGhpcy4kb3B0aW9ucy50cmFuc2Zvcm1SZXNwb25zZSkge1xuICAgICAgICAgICAgdGhpcy4kb3B0aW9ucy50cmFuc2Zvcm1SZXNwb25zZSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJhbnNmb3JtUmVzcG9uc2UodHJhbnNmb3JtZXIsIHRoaXMuJG9wdGlvbnMudHJhbnNmb3JtUmVzcG9uc2UpO1xuICAgIH1cblxuICAgIHN0YXRpYyBpbnRlcmNlcHRSZXF1ZXN0KHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgIHRoaXMuaW50ZXJjZXB0b3JzKCkucmVxdWVzdC51c2Uoc3VjY2VzcywgZXJyb3IpO1xuICAgIH1cblxuICAgIHN0YXRpYyBpbnRlcmNlcHRSZXNwb25zZShzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICB0aGlzLmludGVyY2VwdG9ycygpLnJlc3BvbnNlLnVzZShzdWNjZXNzLCBlcnJvcik7XG4gICAgfVxuXG4gICAgc3RhdGljIGludGVyY2VwdG9ycygpIHtcbiAgICAgICAgcmV0dXJuIGF4aW9zLmludGVyY2VwdG9ycztcbiAgICB9XG5cbiAgICBzdGF0aWMgb3B0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYoaXNPYmplY3Qoa2V5KSkge1xuICAgICAgICAgICAgbWVyZ2UoUmVxdWVzdE9wdGlvbnMsIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBvcHRpb24gPSB7fTtcbiAgICAgICAgICAgIG9wdGlvbltrZXldID0gdmFsdWU7XG4gICAgICAgICAgICBtZXJnZShSZXF1ZXN0T3B0aW9ucywgb3B0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBtYWtlKHVybCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzKHVybCwgcGFyYW1zKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBlYWNoIH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCB7IGtleXMgfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IHsgc2l6ZSB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgeyBmaWx0ZXIgfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IHsgaXNOdWxsIH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCB7IHBpY2tCeSB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgeyByZWR1Y2UgfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IHsgaXNBcnJheSB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgeyBpc09iamVjdCB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgeyBpc1VuZGVmaW5lZCB9IGZyb20gJ2xvZGFzaC1lcydcbmltcG9ydCBSZXF1ZXN0IGZyb20gJy4uL1JlcXVlc3QnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNb2RlbCB7XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgdGhlIG1vZGVsIGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGF0YSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihkYXRhID0ge30sIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIHRoaXMuJHJlcXVlc3QgPSBudWxsO1xuICAgICAgICB0aGlzLiRrZXkgPSB0aGlzLmtleSgpO1xuICAgICAgICB0aGlzLiRmaWxlcyA9IHRoaXMuZmlsZXMoKTtcbiAgICAgICAgdGhpcy4kcHJvcGVydGllcyA9IHRoaXMucHJvcGVydGllcygpO1xuXG4gICAgICAgIGVhY2gocGFyYW1zLCAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgdGhpc1trZXldID0gdmFsdWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZShkYXRhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIHRoZSBtb2RlbCB3aXRoIHRoZSBnaXZlbiBkYXRhIHdpdGhvdXQgY29uc2lkZXJpbmcgdGhlIGRhdGFcbiAgICAgKiBhcyBcImNoYW5nZWRcIi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRhIG9iamVjdFxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIGluaXRpYWxpemUoZGF0YSkge1xuICAgICAgICB0aGlzLiRleGlzdHMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4kY2hhbmdlZCA9IHt9O1xuICAgICAgICB0aGlzLiRhdHRyaWJ1dGVzID0ge307XG4gICAgICAgIHRoaXMuZmlsbChkYXRhKTtcbiAgICAgICAgdGhpcy4kaW5pdGlhbGl6ZWQgPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlZmluZSB0aGUgY29ycmVzcG9uZGluZyBBUEkgZW5kcG9pbnQgc2x1Z1xuICAgICAqXG4gICAgICogQHJldHVybiBzdHJpbmdcbiAgICAgKi9cbiAgICBlbmRwb2ludCgpIHtcbiAgICAgICAgLy9cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWZpbmUgdGhlIGNvcnJlc3BvbmRpbmcgdXJpIHNjaGVtYS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gc3RyaW5nXG4gICAgICovXG4gICAgdXJpKCkge1xuICAgICAgICByZXR1cm4gZmlsdGVyKFtcbiAgICAgICAgICAgICh0aGlzLmVuZHBvaW50KCkgfHwgJycpLFxuICAgICAgICAgICAgKHRoaXMuZXhpc3RzKCkgPyB0aGlzLmlkKCkgOiBudWxsKVxuICAgICAgICBdLmNvbmNhdChbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpKVxuICAgICAgICAuam9pbignLycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgcHJpbWFyeSBrZXkgdmFsdWUgZm9yIHRoZSBtb2RlbFxuICAgICAqXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIGlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXQodGhpcy5rZXkoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVmaW5lIGEgcHJpbWFyeSBrZXkuIFRoaXMgaXMgdXNlZCB0byBkZXRlcm1pbmUgaWYgdGhlIG1vZGVsIGV4aXN0cyBhbmRcbiAgICAgKiB3aGljaCBlbmRwb2ludCB0byB1c2UuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHN0cmluZ1xuICAgICAqL1xuICAgIGtleSgpIHtcbiAgICAgICAgcmV0dXJuICdpZCc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGFuIGFycmF5IG9mIHByb3BlcnRpZXMgdGhhdCBhcmUgc2VudCB0byB0aGUgQVBJLiBJZiBubyBwcm9wZXJ0aWVzXG4gICAgICogYXJlIGRlZmluZWQsIHRoZW4gYWxsIHRoZSBhdHRyaWJ1dGVzIHdpbGwgYmUgaW5jbHVkZWQgaW4gdGhlIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIGFycmF5XG4gICAgICovXG4gICAgcHJvcGVydGllcygpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhbiBhcnJheSBvZiBmaWxlIHByb3BlcnRpZXMgdGhhdCBhcmUgc2VudCB0byB0aGUgQVBJLiBJZiBubyBmaWVzXG4gICAgICogYXJlIGRlZmluZWQsIHRoZW4gcmVxdWVzdCB3aWxsIGFsd2F5cyBiZSBzZW50IHdpdGggSlNPTiB2cy4gbXVsdGlwYXJ0LlxuICAgICAqXG4gICAgICogQHJldHVybiBhcnJheVxuICAgICAqL1xuICAgIGZpbGVzKCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBhdHRyaWJ1dGVzIGluIHRoZSBtb2RlbCB3aXRoIHRoZSBkYXRhIGdpdmVuLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGEgb2JqZWN0XG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgZmlsbChkYXRhKSB7XG4gICAgICAgIHRoaXMuc2V0QXR0cmlidXRlcyhkYXRhKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgb25lIG9yIG1vcmUgYXR0cmlidXRlcyBmcm9tIHRoZSBtb2RlbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRhIHN0cmluZ3xhcnJheVxuICAgICAqIEByZXR1cm4gYXJyYXl8bWl4ZWRcbiAgICAgKi9cbiAgICBnZXQoa2V5KSB7XG4gICAgICAgIGlmKGlzQXJyYXkoa2V5KSB8fCBpc09iamVjdChrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGVzKCkuZmlsdGVyKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLmluZGV4T2YodmFsdWUpICE9PSAtMTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKGtleSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbGlhcyBmb3Igc2V0QXR0cmlidXRlcygpIGV4Y2VwdCB0aGlzIG1ldGhvZCByZXR1cm5zIGB0aGlzYC4gVGhpcyBtZXRob2RcbiAgICAgKiBhbHNvIGFjY2VwdHMgYW4gYXJyYXkgb2YgdmFsdWVzIG9yIGtleS92YWx1ZSBwYWlyLlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgc2V0KGtleSwgdmFsdWUgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYoaXNBcnJheShrZXkpIHx8IGlzT2JqZWN0KGtleSkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlcyhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIHRoZSBkZWZpbmVkIGF0dHJpYnV0ZXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIGFycmF5XG4gICAgICovXG4gICAgZ2V0QXR0cmlidXRlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGF0dHJpYnV0ZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjaGFuZ2VkIGF0dHJpYnV0ZXNcbiAgICAgKlxuICAgICAqIEByZXR1cm4gYXJyYXlcbiAgICAgKi9cbiAgICBnZXRDaGFuZ2VkQXR0cmlidXRlcygpIHtcbiAgICAgICAgcmV0dXJuIGtleXModGhpcy4kY2hhbmdlZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjaGFuZ2VkIGF0dHJpYnV0ZXNcbiAgICAgKlxuICAgICAqIEByZXR1cm4gYXJyYXlcbiAgICAgKi9cbiAgICBnZXRPcmlnaW5hbFZhbHVlKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy4kY2hhbmdlZFtrZXldIHx8IHRoaXMuJGF0dHJpYnV0ZXNba2V5XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIFJlcXVlc3Qgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHJldHVybiB7bWl4ZWR9XG4gICAgICovXG4gICAgZ2V0UmVxdWVzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHJlcXVlc3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB1bmNoYW5nZWQgYXR0cmlidXRlc1xuICAgICAqXG4gICAgICogQHJldHVybiBhcnJheVxuICAgICAqL1xuICAgIGdldFVuY2hhbmdlZEF0dHJpYnV0ZXMoKSB7XG4gICAgICAgIHJldHVybiBmaWx0ZXIoa2V5cyh0aGlzLiRhdHRyaWJ1dGVzKSwga2V5ID0+ICEoa2V5IGluIHRoaXMuJGNoYW5nZWQpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYW4gYXR0cmlidXRlIHdpdGggYSBnaXZlbiBrZXkuIElmIG5vIGtleSBpcyBkZWZpbmVkXG4gICAgICpcbiAgICAgKiBAcGFyYW0ga2V5IHN0cmluZ1xuICAgICAqIEBwYXJhbSBkZWZhdWx0IHVuZGVmaW5lZHxtaXhlZFxuICAgICAqIEByZXR1cm4gYXJyYXlcbiAgICAgKi9cbiAgICBnZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSA9IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kYXR0cmlidXRlc1trZXldIHx8IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCBhbiBhcnJheSBvciBvYmplY3Qgb2YgZGF0YSBhcyBhdHRyaWJ1dGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGF0dHJpYnV0ZXMgYXJyYXl8b2JqZWN0XG4gICAgICogQHJldHVybiB2b2lkXG4gICAgICovXG4gICAgc2V0QXR0cmlidXRlcyhkYXRhKSB7XG4gICAgICAgIGlmKGlzQXJyYXkoZGF0YSkgfHwgaXNPYmplY3QoZGF0YSkpIHtcbiAgICAgICAgICAgIGVhY2goZGF0YSwgKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IGFuIGF0dHJpYnV0ZSB3aXRoIGEgZ2l2ZW4ga2V5L3ZhbHVlIHBhaXIuIFRoaXMgd2lsbCB0cmFjayB0aGUgY2hhbmdlc1xuICAgICAqIGluIHRoZSBtb2RlbCB3aXRoaW4gdGhlIGB0aGlzLiRjaGFuZ2VkYCBwcm9wZXJ0eS4gSWYgdGhlIHByaW1hcnkga2V5XG4gICAgICogaXMgc2V0LCBpdCB3aWxsIGFsc28gY2hhbmdlIHRoZSBgdGhpcy4kZXhpc3RzYCBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBrZXkgc3RyaW5nXG4gICAgICogQHBhcmFtIHZhbHVlIG1peGVkXG4gICAgICogQHJldHVybiB2b2lkXG4gICAgICovXG4gICAgc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYodGhpcy5nZXRBdHRyaWJ1dGUoa2V5KSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlQXR0cmlidXRlQ2hhbmdlKGtleSwgdmFsdWUpO1xuXG4gICAgICAgICAgICBpZihpc1VuZGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy4kYXR0cmlidXRlc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kYXR0cmlidXRlc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXZlcnQgdGhlIG1vZGVsIHRvIGl0cyBvcmlnaW5hbCBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gYm9vbFxuICAgICAqL1xuICAgIHJldmVydCgpIHtcbiAgICAgICAgZWFjaCh0aGlzLiRjaGFuZ2VkLCAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgaWYoIWlzVW5kZWZpbmVkKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuJGF0dHJpYnV0ZXNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuJGF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy4kY2hhbmdlZCA9IHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaWYgdGhlIG1vZGVsIGhhcyBhIHByaW1hcnkga2V5IHNldC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gYm9vbFxuICAgICAqL1xuICAgIGV4aXN0cygpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy4kZXhpc3RzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1vZGVsIGJlZW4gY2hhbmdlZCBvciBub3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIGJvb2xcbiAgICAgKi9cbiAgICBoYXNDaGFuZ2VkKGtleSkge1xuICAgICAgICByZXR1cm4gIWtleSA/IHNpemUodGhpcy4kY2hhbmdlZCkgPiAwIDogIWlzVW5kZWZpbmVkKHRoaXMuJGNoYW5nZWRba2V5XSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRG9lcyB0aGUgbW9kZWwgaGF2ZSBhbnkgRmlsZSBvYmplY3RzLiBJZiBzbywgbmVlZCB0byBzZW5kIGFzIG11bHRpcGFydC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gYm9vbFxuICAgICAqL1xuICAgIGhhc0ZpbGVzKCkge1xuICAgICAgICBmdW5jdGlvbiBjb3VudChmaWxlcywgdG90YWwgPSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVkdWNlKGZpbGVzLCAoY2FycnksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhcnJ5ICsgY291bnQodmFsdWUsIHRvdGFsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZih2YWx1ZSBpbnN0YW5jZW9mIEZpbGUgfHwgdmFsdWUgaW5zdGFuY2VvZiBGaWxlTGlzdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FycnkgKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhcnJ5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRvdGFsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb3VudCh0aGlzLnRvSlNPTigpKSAhPT0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgc2V0dGluZ3MgdGhlICRjaGFuZ2VkIGF0dHJpYnV0ZXMgd2hlbiBhbiBhdHRyaWJ1dGUgdmFsdWUgaXMgc2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGtleSBzdHJpbmdcbiAgICAgKiBAcGFyYW0gdmFsdWUgbWl4ZWRcbiAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgKi9cbiAgICBoYW5kbGVBdHRyaWJ1dGVDaGFuZ2Uoa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZih0aGlzLiRpbml0aWFsaXplZCkge1xuICAgICAgICAgICAgaWYodGhpcy4kY2hhbmdlZFtrZXldID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLiRjaGFuZ2VkW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKCEoa2V5IGluIHRoaXMuJGNoYW5nZWQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kY2hhbmdlZFtrZXldID0gdGhpcy5nZXRBdHRyaWJ1dGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaGFuZGxlUHJpbWFyeUtleUNoYW5nZShrZXksIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgYW4gYXJyYXkgb3Igb2JqZWN0IG9mIGRhdGEgYXMgYXR0cmlidXRlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBrZXkgc3RyaW5nXG4gICAgICogQHBhcmFtIHZhbHVlIG1peGVkXG4gICAgICogQHJldHVybiB2b2lkXG4gICAgICovXG4gICAgaGFuZGxlUHJpbWFyeUtleUNoYW5nZShrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmKHRoaXMuJGtleSA9PT0ga2V5KSB7XG4gICAgICAgICAgICB0aGlzLiRleGlzdHMgPSAhaXNVbmRlZmluZWQodmFsdWUpICYmICFpc051bGwodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FuY2VsIHRoZSBjdXJyZW50IHJlcXVlc3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRhIG9iamVjdFxuICAgICAqIEByZXR1cm4gYm9vbFxuICAgICAqL1xuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgdGhpcy4kcmVxdWVzdCAmJiB0aGlzLiRyZXF1ZXN0LmNhbmNlbCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNhdmUgdGhlIG1vZGVsIHRvIHRoZSBkYXRhYmFzZVxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGEgb2JqZWN0XG4gICAgICogQHJldHVybiBib29sXG4gICAgICovXG4gICAgc2F2ZShkYXRhID0ge30sIGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5leGlzdHMoKSA/IHRoaXMuY3JlYXRlKGRhdGEsIGNvbmZpZykgOiB0aGlzLnVwZGF0ZShkYXRhLCBjb25maWcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBtb2RlbFxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGEgb2JqZWN0XG4gICAgICogQHJldHVybiBib29sXG4gICAgICovXG4gICAgY3JlYXRlKGRhdGEgPSB7fSwgY29uZmlnID0ge30pIHtcbiAgICAgICAgdGhpcy5maWxsKGRhdGEpO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gIXRoaXMuaGFzRmlsZXMoKSA/IHRoaXMudG9Kc29uKCkgOiB0aGlzLnRvRm9ybURhdGEoKTtcblxuICAgICAgICAgICAgdGhpcy4kcmVxdWVzdCA9IHRoaXMuY29uc3RydWN0b3IucmVxdWVzdCh0aGlzLnVyaSgpLCBPYmplY3QuYXNzaWduKHt9LCBjb25maWcpKTtcbiAgICAgICAgICAgIHRoaXMuJHJlcXVlc3QucG9zdChkYXRhKS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMuZmlsbChyZXNwb25zZSkpO1xuICAgICAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIGFuIGV4aXN0aW5nIG1vZGVsXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGF0YSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIGJvb2xcbiAgICAgKi9cbiAgICB1cGRhdGUoZGF0YSA9IHt9LCBjb25maWcgPSB7fSkge1xuICAgICAgICB0aGlzLmZpbGwoZGF0YSk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSAhdGhpcy5oYXNGaWxlcygpID8gdGhpcy50b0pzb24oKSA6IHRoaXMudG9Gb3JtRGF0YSgpO1xuXG4gICAgICAgICAgICB0aGlzLiRyZXF1ZXN0ID0gdGhpcy5jb25zdHJ1Y3Rvci5yZXF1ZXN0KHRoaXMudXJpKCksIGNvbmZpZyk7XG4gICAgICAgICAgICB0aGlzLiRyZXF1ZXN0Wyh0aGlzLmhhc0ZpbGVzKCkgPyAncG9zdCcgOiAncHV0JyldKGRhdGEpLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICAgICAgICAgIHJlc29sdmUodGhpcy5maWxsKHJlc3BvbnNlKSk7XG4gICAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYW4gZXhpc3RpbmcgbW9kZWxcbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gY29uZmlnXG4gICAgICogQHJldHVybiB7Ym9vbH1cbiAgICAgKi9cbiAgICBkZWxldGUoY29uZmlnID0ge30pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGlmKCF0aGlzLmV4aXN0cygpKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignVGhlIG1vZGVsIG11c3QgaGF2ZSBhIHByaW1hcnkga2V5IGJlZm9yZSBpdCBjYW4gYmUgZGVsZXRlLicpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy4kcmVxdWVzdCA9IHRoaXMuY29uc3RydWN0b3IucmVxdWVzdCh0aGlzLnVyaSgpLCBjb25maWcpO1xuICAgICAgICAgICAgdGhpcy4kcmVxdWVzdC5kZWxldGUoKS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH0sIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbmNlbCB0aGUgY3VycmVudCBIVFRQIHJlcXVlc3QgaWYgb25lIGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge3NlbGZ9XG4gICAgICovXG4gICAgY2FuY2VsKCkge1xuICAgICAgICBpZih0aGlzLiRyZXF1ZXN0KSB7XG4gICAgICAgICAgICB0aGlzLiRyZXF1ZXN0LmNhbmNlbCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydCB0aGUgTW9kZWwgaW5zdGFuY2UgdG8gYSBGb3JtRGF0YSBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQHJldHVybiBvYmplY3RcbiAgICAgKi9cbiAgICB0b0Zvcm1EYXRhKCkge1xuICAgICAgICBjb25zdCBmb3JtID0gbmV3IEZvcm1EYXRhKCk7XG5cbiAgICAgICAgZWFjaCh0aGlzLnRvSlNPTigpLCAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgaWYoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBlYWNoKHZhbHVlLCBpdGVtID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYoIShpdGVtIGluc3RhbmNlb2YgRmlsZSkgJiYgKGlzT2JqZWN0KGl0ZW0pIHx8IGlzQXJyYXkoaXRlbSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtID0gSlNPTi5zdHJpbmdpZnkoaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmb3JtLmFwcGVuZChrZXkucmVwbGFjZSgvKC4rKShcXFsuK1xcXT8pJC8sICckMScpKydbXScsIGl0ZW0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZighKHZhbHVlIGluc3RhbmNlb2YgRmlsZSkgJiYgaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZm9ybS5hcHBlbmQoa2V5LCBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZighaXNOdWxsKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGZvcm0uYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZm9ybTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRoZSBpbnN0YW5jZSB0byBKU09OIHBheWxvYWRcbiAgICAgKlxuICAgICAqIEByZXR1cm4gb2JqZWN0XG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gcGlja0J5KHRoaXMuJGF0dHJpYnV0ZXMsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gIXRoaXMuJHByb3BlcnRpZXMubGVuZ3RoIHx8IChcbiAgICAgICAgICAgICAgICBrZXkgPT09IHRoaXMua2V5KCkgfHwgdGhpcy4kcHJvcGVydGllcy5pbmRleE9mKGtleSkgIT09IC0xXG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbGlhcyBmb3IgdG9KU09OXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIG9iamVjdFxuICAgICAqL1xuICAgIHRvSnNvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9KU09OKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VhcmNoIGZvciBhIGNvbGxlY3Rpb24gb2YgbW9kZWxzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGF0YSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIGJvb2xcbiAgICAgKi9cbiAgICBzdGF0aWMgc2VhcmNoKHBhcmFtcyA9IHt9LCBjb25maWcgPSB7fSkge1xuICAgICAgICBjb25zdCBtb2RlbCA9IG5ldyB0aGlzO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBtb2RlbC4kcmVxdWVzdCA9IHRoaXMucmVxdWVzdChjb25maWcudXJpIHx8IG1vZGVsLnVyaSgpLCBjb25maWcpO1xuICAgICAgICAgICAgbW9kZWwuJHJlcXVlc3QuZ2V0KHBhcmFtcykudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UuZGF0YSA9IHJlc3BvbnNlLmRhdGEubWFwKGRhdGEgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHRoaXMoZGF0YSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH0sIGVycm9ycyA9PiB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9ycyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZCBhbiBleGlzdGluZyBtb2RlbCBieSBpZFxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGEgb2JqZWN0XG4gICAgICogQHJldHVybiBib29sXG4gICAgICovXG4gICAgc3RhdGljIGZpbmQoaWQsIGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtb2RlbCA9IG5ldyB0aGlzO1xuICAgICAgICAgICAgbW9kZWwuJHJlcXVlc3QgPSB0aGlzLnJlcXVlc3QobW9kZWwudXJpKGlkKSwgY29uZmlnKTtcbiAgICAgICAgICAgIG1vZGVsLiRyZXF1ZXN0LmdldCgpLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICAgICAgICAgIHJlc29sdmUobW9kZWwuaW5pdGlhbGl6ZShyZXNwb25zZSkpO1xuICAgICAgICAgICAgfSwgZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgcmVxdWVzdCBmcm9tIHRoZSBtb2RlbCBkYXRhXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGF0YSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIGJvb2xcbiAgICAgKi9cbiAgICBzdGF0aWMgcmVxdWVzdCh1cmwsIGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVxdWVzdCh1cmwsIGNvbmZpZyk7XG4gICAgfVxuXG59XG4iLCI8dGVtcGxhdGU+XG4gICAgPGZvcm0gQHN1Ym1pdC5wcmV2ZW50PVwib25TdWJtaXRcIiA6Y2xhc3M9XCJ7J2Zvcm0taW5saW5lJzogaW5saW5lfVwiIDpub3ZhbGlkYXRlPVwibm92YWxpZGF0ZVwiPlxuICAgICAgICA8c2xvdD48L3Nsb3Q+XG4gICAgPC9mb3JtPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBNb2RlbCBmcm9tICcuLi8uLi9IdHRwL01vZGVsL01vZGVsJztcbmltcG9ydCB7IGlzRnVuY3Rpb24gfSBmcm9tICdsb2Rhc2gtZXMnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgTW9kZWwgbWV0aG9kIHVzZWQgdG8gc2VuZCB0aGUgcmVxdWVzdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IEJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIG1ldGhvZDoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJ3NhdmUnLFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tb2RlbCAmJiBpc0Z1bmN0aW9uKHRoaXMubW9kZWxbdmFsdWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gb2JqZWN0IG9mIGZvcm0gZGF0YVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgT2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgICAgICBkZWZhdWx0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIEpTT04gb2JqZWN0IG9mIHJlcXVlc3QgaGVhZGVyc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgT2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBoZWFkZXJzOiBPYmplY3QsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc3BsYXkgdGhlIGZvcm0gZmllbGRzIGlubGluZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgT2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBtb2RlbDoge1xuICAgICAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBNb2RlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwbGF5IHRoZSBmb3JtIGZpZWxkcyBpbmxpbmVcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IEJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIGlubGluZTogQm9vbGVhbixcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBjYWxsYmFjayBmdW5jdGlvbiBmb3IgdGhlIGBzdWJtaXRgIGV2ZW50XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBCb29sZWFuXG4gICAgICAgICAqL1xuICAgICAgICBub3ZhbGlkYXRlOiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIEpTT04gb2JqZWN0IG9mIGtleS92YWx1ZSBwYWlycyB0byBidWlsZCB0aGUgcXVlcnkgc3RyaW5nLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgT2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBxdWVyeTogT2JqZWN0LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIFVSSSBvciBVUkwgdXNlZCB0byByZWRpcmVjdCB1c2VyIGFmdGVyIGZvcm0gc3VibWl0cyBzdWNjZXNzZnVsbHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBGdW5jdGlvbnxTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHJlZGlyZWN0OiBbT2JqZWN0LCBTdHJpbmcsIEZ1bmN0aW9uXSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBjYWxsYmFjayBmdW5jdGlvbiBmb3IgdGhlIGBzdWJtaXRgIGV2ZW50XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBGdW5jdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgb25TdWJtaXQ6IHtcbiAgICAgICAgICAgIHR5cGU6IEZ1bmN0aW9uLFxuICAgICAgICAgICAgZGVmYXVsdChldmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMubW9kZWwgJiYgdGhpcy5zdWJtaXQoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGNhbGxiYWNrIGZ1bmN0aW9uIGZvciB0aGUgYHN1Ym1pdDpzdWNjZXNzYCBldmVudFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgRnVuY3Rpb25cbiAgICAgICAgICovXG4gICAgICAgIG9uU3VibWl0U3VjY2Vzczoge1xuICAgICAgICAgICAgdHlwZTogRnVuY3Rpb24sXG4gICAgICAgICAgICBkZWZhdWx0KGV2ZW50LCBkYXRhKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kZW1pdCgnc3VibWl0OnN1Y2Nlc3MnLCBldmVudCwgZGF0YSk7XG4gICAgICAgICAgICAgICAgdGhpcy4kZW1pdCgnc3VibWl0OmNvbXBsZXRlJywgZXZlbnQsIHRydWUsIGRhdGEpO1xuXG4gICAgICAgICAgICAgICAgaWYodGhpcy5yZWRpcmVjdCAmJiBpc0Z1bmN0aW9uKHRoaXMucmVkaXJlY3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVkaXJlY3QodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYodGhpcy5yZWRpcmVjdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRyb3V0ZXIucHVzaCh0aGlzLnJlZGlyZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIHRoZSBgc3VibWl0OnN1Y2Nlc3NgIGV2ZW50XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBGdW5jdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgb25TdWJtaXRGYWlsZWQ6IHtcbiAgICAgICAgICAgIHR5cGU6IEZ1bmN0aW9uLFxuICAgICAgICAgICAgZGVmYXVsdChldmVudCwgZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kZW1pdCgnc3VibWl0OmZhaWxlZCcsIGV2ZW50LCBlcnJvcnMpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ3N1Ym1pdDpjb21wbGV0ZScsIGV2ZW50LCBmYWxzZSwgZXJyb3JzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIG1ldGhvZHM6IHtcblxuICAgICAgICBzdWJtaXQoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ3N1Ym1pdCcsIGV2ZW50KTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubW9kZWxbdGhpcy5tZXRob2RdKHRoaXMuZGF0YSwge1xuICAgICAgICAgICAgICAgIHF1ZXJ5OiB0aGlzLnF1ZXJ5LFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBvblVwbG9hZFByb2dyZXNzOiBldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ3N1Ym1pdDpwcm9ncmVzcycsIGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KS50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5vblN1Ym1pdFN1Y2Nlc3MoZXZlbnQsIGRhdGEpO1xuICAgICAgICAgICAgfSwgKGVycm9ycykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMub25TdWJtaXRGYWlsZWQoZXZlbnQsIGVycm9ycyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlcnJvcnM6IHt9XG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgQmFzZUZvcm0gZnJvbSAnLi9CYXNlRm9ybSc7XG5pbXBvcnQgVnVlSW5zdGFsbGVyIGZyb20gJy4uLy4uL0hlbHBlcnMvVnVlSW5zdGFsbGVyL1Z1ZUluc3RhbGxlcic7XG5cbmNvbnN0IHBsdWdpbiA9IFZ1ZUluc3RhbGxlci51c2Uoe1xuXG4gICAgaW5zdGFsbChWdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgVnVlSW5zdGFsbGVyLmNvbXBvbmVudHMoe1xuICAgICAgICAgICAgQmFzZUZvcm1cbiAgICAgICAgfSk7XG4gICAgfVxuXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgQmFzZUZvcm07XG4iLCI8dGVtcGxhdGU+XG4gICAgPGxpIGNsYXNzPVwiYnJlYWRjcnVtYi1pdGVtXCIgOmNsYXNzPVwieydhY3RpdmUnOiBhY3RpdmV9XCIgOmFyaWEtY3VycmVudD1cImFjdGl2ZSA/ICdwYWdlJyA6IGZhbHNlXCI+XG4gICAgICAgIDxhIHYtaWY9XCIhYWN0aXZlICYmIGhyZWZcIiA6aHJlZj1cImhyZWZcIj5cbiAgICAgICAgICAgIDxzbG90Pnt7bGFiZWx9fTwvc2xvdD5cbiAgICAgICAgPC9hPlxuICAgICAgICA8cm91dGVyLWxpbmsgdi1lbHNlLWlmPVwiIWFjdGl2ZSAmJiB0b1wiIDp0bz1cInRvXCI+XG4gICAgICAgICAgICA8c2xvdD57e2xhYmVsfX08L3Nsb3Q+XG4gICAgICAgIDwvcm91dGVyLWxpbms+XG4gICAgICAgIDx0ZW1wbGF0ZSB2LWVsc2U+XG4gICAgICAgICAgICA8c2xvdD57e2xhYmVsfX08L3Nsb3Q+XG4gICAgICAgIDwvdGVtcGxhdGU+XG4gICAgPC9saT5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAnYnJlYWRjcnVtYi1pdGVtJyxcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElzIHRoZSBpdGVtIGFjdGl2ZT9cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3Age0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBhY3RpdmU6IEJvb2xlYW4sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGhyZWYgYXR0cmlidXRlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wIHtTdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBocmVmOiBTdHJpbmcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGJyZWFkY3J1bWIgbGFiZWxcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3Age1N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIGxhYmVsOiBTdHJpbmcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0byBhdHRyaWJ1dGUgd2hpY2ggaXMgcGFzc2VkIHRvIHRoZSA8cm91dGVyLWxpbms+IGNvbXBvbmVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3Age09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRvOiBbU3RyaW5nLCBPYmplY3RdXG5cbiAgICB9XG5cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICAgIDxuYXYgYXJpYS1sYWJlbD1cImJyZWFkY3J1bWJcIj5cbiAgICAgICAgPG9sIGNsYXNzPVwiYnJlYWRjcnVtYlwiPlxuICAgICAgICAgICAgPGJyZWFkY3J1bWItaXRlbVxuICAgICAgICAgICAgICAgIHYtaWY9XCJpdGVtcy5sZW5ndGhcIlxuICAgICAgICAgICAgICAgIHYtZm9yPVwiKGl0ZW0sIGkpIGluIGl0ZW1zXCJcbiAgICAgICAgICAgICAgICB2LWJpbmQ9XCJpdGVtXCJcbiAgICAgICAgICAgICAgICA6a2V5PVwiaVwiXG4gICAgICAgICAgICAgICAgOmN1cnJlbnQ9XCJpID09PSBpdGVtLmxlbmd0aCAtIDFcIlxuICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDxzbG90Lz5cbiAgICAgICAgPC9vbD5cbiAgICA8L25hdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgQnJlYWRjcnVtYkl0ZW0gZnJvbSAnLi9CcmVhZGNydW1iSXRlbSc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdicmVhZGNydW1iJyxcblxuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgICAgQnJlYWRjcnVtYkl0ZW1cbiAgICB9LFxuXG4gICAgcHJvcHM6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gYXJyYXkgb2YgYnJlYWRjcnVtYnNcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3Age0FycmF5fVxuICAgICAgICAgKi9cbiAgICAgICAgaXRlbXM6IEFycmF5XG5cbiAgICB9XG5cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IEJyZWFkY3J1bWIgZnJvbSAnLi9CcmVhZGNydW1iJztcbmltcG9ydCBCcmVhZGNydW1iSXRlbSBmcm9tICcuL0JyZWFkY3J1bWJJdGVtJztcbmltcG9ydCBWdWVJbnN0YWxsZXIgZnJvbSAnLi4vLi4vSGVscGVycy9WdWVJbnN0YWxsZXIvVnVlSW5zdGFsbGVyJztcblxuY29uc3QgcGx1Z2luID0gVnVlSW5zdGFsbGVyLnVzZSh7XG5cbiAgICBpbnN0YWxsKFZ1ZSwgb3B0aW9ucykge1xuICAgICAgICBWdWVJbnN0YWxsZXIuY29tcG9uZW50cyh7XG4gICAgICAgICAgICBCcmVhZGNydW1iLFxuICAgICAgICAgICAgQnJlYWRjcnVtYkl0ZW1cbiAgICAgICAgfSk7XG4gICAgfVxuXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgQnJlYWRjcnVtYjtcbiIsImV4cG9ydCBkZWZhdWx0IHtcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3VsZCBzaG93IG9ubHkgZm9yIHNjcmVlbnJlYWRlcnNcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IEJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIHNyT25seTogQm9vbGVhbixcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvdWxkIGJlIGZvY3VzYWJsZSBmb3Igc2NyZWVucmVhZGVyc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgQm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgc3JPbmx5Rm9jdXNhYmxlOiBCb29sZWFuXG5cbiAgICB9LFxuXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgc2NyZWVucmVhZGVyQ2xhc3NlcygpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgJ3NyLW9ubHknOiB0aGlzLnNyT25seSxcbiAgICAgICAgICAgICAgICAnc3Itb25seS1mb2N1c2FibGUnOiB0aGlzLnNyT25seUZvY3VzYWJsZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbn1cbiIsIjx0ZW1wbGF0ZT5cblxuICAgIDxzbWFsbCBjbGFzcz1cImZvcm0tdGV4dFwiIDpjbGFzcz1cImNsYXNzZXNcIj48c2xvdCAvPjwvc21hbGw+XG5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5cbmltcG9ydCB7IGV4dGVuZCB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgQ29sb3JhYmxlIGZyb20gJy4uLy4uL01peGlucy9Db2xvcmFibGUvQ29sb3JhYmxlJztcbmltcG9ydCBTY3JlZW5yZWFkZXJzIGZyb20gJy4uLy4uL01peGlucy9TY3JlZW5yZWFkZXJzL1NjcmVlbnJlYWRlcnMnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAnaGVscC10ZXh0JyxcblxuICAgIG1peGluczogW1xuICAgICAgICBDb2xvcmFibGUsXG4gICAgICAgIFNjcmVlbnJlYWRlcnNcbiAgICBdLFxuXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgY2xhc3NlcygpIHtcbiAgICAgICAgICAgIHJldHVybiBleHRlbmQoe30sIHRoaXMuc2NyZWVucmVhZGVyQ2xhc3NlcywgdGhpcy5jb2xvcmFibGVDbGFzc2VzKTtcbiAgICAgICAgfVxuICAgIH1cblxufVxuXG48L3NjcmlwdD5cbiIsImltcG9ydCBIZWxwVGV4dCBmcm9tICcuL0hlbHBUZXh0JztcbmltcG9ydCBWdWVJbnN0YWxsZXIgZnJvbSAnLi4vLi4vSGVscGVycy9WdWVJbnN0YWxsZXIvVnVlSW5zdGFsbGVyJztcblxuY29uc3QgcGx1Z2luID0gVnVlSW5zdGFsbGVyLnVzZSh7XG5cbiAgICBpbnN0YWxsKFZ1ZSwgb3B0aW9ucykge1xuICAgICAgICBWdWVJbnN0YWxsZXIuY29tcG9uZW50cyh7XG4gICAgICAgICAgICBIZWxwVGV4dFxuICAgICAgICB9KTtcbiAgICB9XG5cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBIZWxwVGV4dDtcbiIsIjx0ZW1wbGF0ZT5cblxuICAgIDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwXCI+PHNsb3QvPjwvZGl2PlxuXG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuXG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdmb3JtLWdyb3VwJ1xuICAgIFxufVxuXG48L3NjcmlwdD5cbiIsImltcG9ydCBGb3JtR3JvdXAgZnJvbSAnLi9Gb3JtR3JvdXAnO1xuaW1wb3J0IFZ1ZUluc3RhbGxlciBmcm9tICcuLi8uLi9IZWxwZXJzL1Z1ZUluc3RhbGxlci9WdWVJbnN0YWxsZXInO1xuXG5jb25zdCBwbHVnaW4gPSBWdWVJbnN0YWxsZXIudXNlKHtcblxuICAgIGluc3RhbGwoVnVlLCBvcHRpb25zKSB7XG4gICAgICAgIFZ1ZUluc3RhbGxlci5jb21wb25lbnRzKHtcbiAgICAgICAgICAgIEZvcm1Hcm91cFxuICAgICAgICB9KTtcbiAgICB9XG5cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBGb3JtR3JvdXA7XG4iLCI8dGVtcGxhdGU+XG5cbiAgICA8bGFiZWwgOmNsYXNzPVwiY2xhc3Nlc1wiPjxzbG90Lz48L2xhYmVsPlxuXG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuXG5pbXBvcnQgeyBleHRlbmQgfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IENvbG9yYWJsZSBmcm9tICcuLi8uLi9NaXhpbnMvQ29sb3JhYmxlL0NvbG9yYWJsZSc7XG5pbXBvcnQgU2NyZWVucmVhZGVycyBmcm9tICcuLi8uLi9NaXhpbnMvU2NyZWVucmVhZGVycy9TY3JlZW5yZWFkZXJzJztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ2Zvcm0tbGFiZWwnLFxuXG4gICAgbWl4aW5zOiBbXG4gICAgICAgIENvbG9yYWJsZSxcbiAgICAgICAgU2NyZWVucmVhZGVyc1xuICAgIF0sXG5cbiAgICBjb21wdXRlZDoge1xuICAgICAgICBjbGFzc2VzKCkge1xuICAgICAgICAgICAgcmV0dXJuIGV4dGVuZCh7fSwgdGhpcy5zY3JlZW5yZWFkZXJDbGFzc2VzLCB0aGlzLmNvbG9yYWJsZUNsYXNzZXMpO1xuICAgICAgICB9XG4gICAgfVxuXG59XG5cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IEZvcm1MYWJlbCBmcm9tICcuL0Zvcm1MYWJlbCc7XG5pbXBvcnQgVnVlSW5zdGFsbGVyIGZyb20gJy4uLy4uL0hlbHBlcnMvVnVlSW5zdGFsbGVyL1Z1ZUluc3RhbGxlcic7XG5cbmNvbnN0IHBsdWdpbiA9IFZ1ZUluc3RhbGxlci51c2Uoe1xuXG4gICAgaW5zdGFsbChWdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgVnVlSW5zdGFsbGVyLmNvbXBvbmVudHMoe1xuICAgICAgICAgICAgRm9ybUxhYmVsXG4gICAgICAgIH0pO1xuICAgIH1cblxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IEZvcm1MYWJlbDtcbiIsIjx0ZW1wbGF0ZT5cblxuICAgIDxkaXYgOmNsYXNzPVwieydpbnZhbGlkLWZlZWRiYWNrJzogaW52YWxpZCwgJ3ZhbGlkLWZlZWRiYWNrJzogdmFsaWQgJiYgIWludmFsaWR9XCI+XG4gICAgICAgIDxzbG90Pnt7bGFiZWx9fTwvc2xvdD5cbiAgICA8L2Rpdj5cblxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cblxuaW1wb3J0IENvbG9yYWJsZSBmcm9tICcuLi8uLi9NaXhpbnMvQ29sb3JhYmxlL0NvbG9yYWJsZSc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdmb3JtLWZlZWRiYWNrJyxcblxuICAgIG1peGluczogW1xuICAgICAgICBDb2xvcmFibGVcbiAgICBdLFxuXG4gICAgcHJvcHM6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHZhbHVlIG9mIGxhYmVsIGVsZW1lbnQuIElmIG5vIHZhbHVlLCBubyBsYWJlbCB3aWxsIGFwcGVhci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgbGFiZWw6IFN0cmluZyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvdWxkIHRoZSBmZWVkYmFjayBtYXJrZWQgYXMgaW52YWxpZFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBpbnZhbGlkOiBCb29sZWFuLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG91bGQgdGhlIGZlZWRiYWNrIG1hcmtlZCBhcyBpbnZhbGlkXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHZhbGlkOiBCb29sZWFuXG5cbiAgICB9XG5cbn1cblxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgRm9ybUZlZWRiYWNrIGZyb20gJy4vRm9ybUZlZWRiYWNrJztcbmltcG9ydCBWdWVJbnN0YWxsZXIgZnJvbSAnLi4vLi4vSGVscGVycy9WdWVJbnN0YWxsZXIvVnVlSW5zdGFsbGVyJztcblxuY29uc3QgcGx1Z2luID0gVnVlSW5zdGFsbGVyLnVzZSh7XG5cbiAgICBpbnN0YWxsKFZ1ZSwgb3B0aW9ucykge1xuICAgICAgICBWdWVJbnN0YWxsZXIuY29tcG9uZW50cyh7XG4gICAgICAgICAgICBGb3JtRmVlZGJhY2tcbiAgICAgICAgfSk7XG4gICAgfVxuXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgRm9ybUZlZWRiYWNrO1xuIiwiaW1wb3J0IHsgZWFjaCB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgeyBpc0FycmF5IH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCB7IGlzT2JqZWN0IH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCB7IGNhbWVsQ2FzZSB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgeyBpc1VuZGVmaW5lZCB9IGZyb20gJ2xvZGFzaC1lcydcbmltcG9ydCBwcmVmaXggZnJvbSAnLi4vLi4vSGVscGVycy9QcmVmaXgvUHJlZml4JztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgcHJvcHM6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGF1dG9jb21wbGV0ZSBhdHRyaWJ1dGUgdmFsdWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGF1dG9jb21wbGV0ZTogU3RyaW5nLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZmllbGQgaWQgYXR0cmlidXRlIHZhbHVlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBpZDogW051bWJlciwgU3RyaW5nXSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHZhbHVlIG9mIGxhYmVsIGVsZW1lbnQuIElmIG5vIHZhbHVlLCBubyBsYWJlbCB3aWxsIGFwcGVhci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgbGFiZWw6IFtOdW1iZXIsIFN0cmluZ10sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBmaWVsZCBuYW1lIGF0dHJpYnV0ZSB2YWx1ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgbmFtZTogU3RyaW5nLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZmllbGQgaWQgYXR0cmlidXRlIHZhbHVlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgZGVmYXVsdDogbnVsbFxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcGxhY2Vob2xkZXIgYXR0cmlidXRlIHZhbHVlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBwbGFjZWhvbGRlcjogU3RyaW5nLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJcyB0aGUgZmllbGQgcmVxdWlyZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHJlcXVpcmVkOiBCb29sZWFuLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgZm9ybS1ncm91cCB3cmFwcGVyIHRvIGlucHV0XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGdyb3VwOiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHJlZ2V4IHBhdHRlcm4gZm9yIHZhbGlkYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHBhdHRlcm46IFN0cmluZyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gaW5saW5lIGZpZWxkIHZhbGlkYXRpb24gZXJyb3IuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmd8Qm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgZXJyb3I6IFN0cmluZyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gaW5saW5lIGZpZWxkIHZhbGlkYXRpb24gZXJyb3JzIHBhc3NlZCBhcyBvYmplY3Qgd2l0aCBrZXkvdmFsdWVcbiAgICAgICAgICogcGFpcnMuIElmIGVycm9ycyBwYXNzZWQgYXMgYW4gb2JqZWN0LCB0aGUgZm9ybSBuYW1lIHdpbGwgYmUgdXNlZCBmb3JcbiAgICAgICAgICogdGhlIGtleS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IE9iamVjdHxCb29sZWFuXG4gICAgICAgICAqL1xuICAgICAgICBlcnJvcnM6IHtcbiAgICAgICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgICAgIGRlZmF1bHQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHt9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNvbWUgZmVlZGJhY2sgdG8gYWRkIHRvIHRoZSBmaWVsZCBvbmNlIHRoZSBmaWVsZCBpcyBzdWNjZXNzZnVsbHlcbiAgICAgICAgICogdmFsaWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGZlZWRiYWNrOiBbU3RyaW5nLCBBcnJheV0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGFycmF5IG9mIGV2ZW50IG5hbWVzIHRoYXQgY29ycmVsYXRlIHdpdGggY2FsbGJhY2sgZnVuY3Rpb25zXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBGdW5jdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgYmluZEV2ZW50czoge1xuICAgICAgICAgICAgdHlwZTogQXJyYXksXG4gICAgICAgICAgICBkZWZhdWx0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbJ2ZvY3VzJywgJ2JsdXInLCAnY2hhbmdlJywgJ2NsaWNrJywgJ2tleXVwJywgJ2tleWRvd24nLCAncHJvZ3Jlc3MnLCAncGFzdGUnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRlZmF1bHQgY2xhc3MgbmFtZSBhc3NpZ25lZCB0byB0aGUgY29udHJvbCBlbGVtZW50XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGRlZmF1bHRDb250cm9sQ2xhc3M6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdmb3JtLWNvbnRyb2wnXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhpZGUgdGhlIGxhYmVsIGZvciBicm93c2VycywgYnV0IGxlYXZlIGl0IGZvciBzY3JlZW4gcmVhZGVycy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgaGlkZUxhYmVsOiBCb29sZWFuLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRpdGlvbmFsIG1hcmdpbi9wYWRkaW5nIGNsYXNzZXMgZm9yIGZpbmUgY29udHJvbCBvZiBzcGFjaW5nXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHNwYWNpbmc6IFN0cmluZyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNpemUgb2YgdGhlIGZvcm0gY29udHJvbFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBzaXplOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAnbWQnLFxuICAgICAgICAgICAgdmFsaWRhdGU6IHZhbHVlID0+IFsnc20nLCAnbWQnLCAnbGcnXS5pbmRleE9mKHZhbHVlKSAhPT0gLTFcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzcGxheSB0aGUgZm9ybSBmaWVsZCBpbmxpbmVcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgaW5saW5lOiBCb29sZWFuLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGUgZm9ybSBjb250cm9sIGlzIHJlYWRvbmx5LCBkaXNwbGF5IG9ubHkgYXMgdGV4dD9cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgcGxhaW50ZXh0OiBCb29sZWFuLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJcyB0aGUgZm9ybSBjb250cm9sIHJlYWRvbmx5P1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICByZWFkb25seTogQm9vbGVhbixcblxuICAgICAgICAvKipcbiAgICAgICAgICogSXMgdGhlIGZvcm0gY29udHJvbCBkaXNhYmxlZD9cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgZGlzYWJsZWQ6IEJvb2xlYW4sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNvbWUgaW5zdHJ1Y3Rpb25zIHRvIGFwcGVhciB1bmRlciB0aGUgZmllbGQgbGFiZWxcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgaGVscFRleHQ6IFtOdW1iZXIsIFN0cmluZ10sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtYXhsZW5ndGggYXR0cmlidXRlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIG1heGxlbmd0aDogW051bWJlciwgU3RyaW5nXVxuXG4gICAgfSxcblxuICAgIGRpcmVjdGl2ZXM6IHtcbiAgICAgICAgYmluZEV2ZW50czoge1xuICAgICAgICAgICAgYmluZChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBldmVudHMgPSBiaW5kaW5nLnZhbHVlIHx8IHZub2RlLmNvbnRleHQuYmluZEV2ZW50cztcblxuICAgICAgICAgICAgICAgIGVhY2goZXZlbnRzLCBuYW1lID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2bm9kZS5jb250ZXh0LiRlbWl0KG5hbWUsIGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWV0aG9kczoge1xuXG4gICAgICAgIGJsdXIoKSB7XG4gICAgICAgICAgICBpZih0aGlzLmdldElucHV0RmllbGQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0SW5wdXRGaWVsZCgpLmJsdXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBmb2N1cygpIHtcbiAgICAgICAgICAgIGlmKHRoaXMuZ2V0SW5wdXRGaWVsZCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRJbnB1dEZpZWxkKCkuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBnZXRJbnB1dEZpZWxkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3IoJy5mb3JtLWNvbnRyb2wsIGlucHV0LCBzZWxlY3QsIHRleHRhcmVhJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0RmllbGRFcnJvcnMoKSB7XG4gICAgICAgICAgICBsZXQgZXJyb3JzID0gdGhpcy5lcnJvciB8fCB0aGlzLmVycm9ycztcblxuICAgICAgICAgICAgaWYoaXNPYmplY3QodGhpcy5lcnJvcnMpKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzID0gdGhpcy5lcnJvcnNbdGhpcy5uYW1lIHx8IHRoaXMuaWRdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gIWVycm9ycyB8fCBpc0FycmF5KGVycm9ycykgfHwgaXNPYmplY3QoZXJyb3JzKSA/IGVycm9ycyA6IFtlcnJvcnNdO1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgY29tcHV0ZWQ6IHtcblxuICAgICAgICBjYWxsYmFja3MoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iaW5kRXZlbnRzLm1hcChldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiB0aGlzW2NhbWVsQ2FzZShbJ29uJywgZXZlbnRdLmpvaW4oJyAnKSldXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkuZmlsdGVyKGV2ZW50ID0+ICFpc1VuZGVmaW5lZChldmVudC5jYWxsYmFjaykpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGludmFsaWRGZWVkYmFjaygpIHtcbiAgICAgICAgICAgIGlmKHRoaXMuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgZXJyb3JzID0gdGhpcy5nZXRGaWVsZEVycm9ycygpO1xuXG4gICAgICAgICAgICByZXR1cm4gaXNBcnJheShlcnJvcnMpID8gZXJyb3JzLmpvaW4oJzxicj4nKSA6IGVycm9ycztcbiAgICAgICAgfSxcblxuICAgICAgICB2YWxpZEZlZWRiYWNrKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5mZWVkYmFjaykgPyB0aGlzLmZlZWRiYWNrLmpvaW4oJzxicj4nKSA6IHRoaXMuZmVlZGJhY2s7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29udHJvbENsYXNzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdENvbnRyb2xDbGFzcyArICh0aGlzLnBsYWludGV4dCA/ICctcGxhaW50ZXh0JyA6ICcnKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjb250cm9sU2l6ZUNsYXNzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHByZWZpeCh0aGlzLnNpemUsIHRoaXMuY29udHJvbENsYXNzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjb250cm9sQ2xhc3NlcygpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgdGhpcy5jb250cm9sQ2xhc3MsXG4gICAgICAgICAgICAgICAgdGhpcy5jb250cm9sU2l6ZUNsYXNzLFxuICAgICAgICAgICAgICAgICh0aGlzLnNwYWNpbmcgfHwgJycpLFxuICAgICAgICAgICAgICAgICh0aGlzLmludmFsaWRGZWVkYmFjayA/ICdpcy1pbnZhbGlkJyA6ICcnKVxuICAgICAgICAgICAgXS5qb2luKCcgJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFzRGVmYXVsdFNsb3QgKCkge1xuICAgICAgICAgICAgcmV0dXJuICEhdGhpcy4kc2xvdHMuZGVmYXVsdFxuICAgICAgICB9XG5cbiAgICB9XG5cbn1cbiIsIjx0ZW1wbGF0ZT5cblxuICAgIDxmb3JtLWdyb3VwIGNsYXNzPVwiaW5wdXQtZmllbGRcIiA6Y2xhc3M9XCJ7J2hhcy1hY3Rpdml0eSc6IGFjdGl2aXR5fVwiPlxuXG4gICAgICAgIDxzbG90IG5hbWU9XCJsYWJlbFwiPlxuICAgICAgICAgICAgPGZvcm0tbGFiZWwgcmVmPVwibGFiZWxcIiB2LWlmPVwibGFiZWwgfHwgaGFzRGVmYXVsdFNsb3RcIiA6Zm9yPVwiaWRcIiB2LWh0bWw9XCJsYWJlbFwiLz5cbiAgICAgICAgPC9zbG90PlxuXG4gICAgICAgIDxkaXYgY2xhc3M9XCJwb3NpdGlvbi1yZWxhdGl2ZVwiPlxuICAgICAgICAgICAgPHNsb3QgbmFtZT1cImNvbnRyb2xcIj5cbiAgICAgICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICAgICAgcmVmPVwiY29udHJvbFwiXG4gICAgICAgICAgICAgICAgICAgIDppZD1cImlkXCJcbiAgICAgICAgICAgICAgICAgICAgOnR5cGU9XCJ0eXBlXCJcbiAgICAgICAgICAgICAgICAgICAgOm5hbWU9XCJuYW1lXCJcbiAgICAgICAgICAgICAgICAgICAgOnZhbHVlPVwidmFsdWVcIlxuICAgICAgICAgICAgICAgICAgICA6cGF0dGVybj1cInBhdHRlcm5cIlxuICAgICAgICAgICAgICAgICAgICA6cmVhZG9ubHk9XCJyZWFkb25seVwiXG4gICAgICAgICAgICAgICAgICAgIDpyZXF1aXJlZD1cInJlcXVpcmVkXCJcbiAgICAgICAgICAgICAgICAgICAgOm1heGxlbmd0aD1cIm1heGxlbmd0aFwiXG4gICAgICAgICAgICAgICAgICAgIDpwbGFjZWhvbGRlcj1cInBsYWNlaG9sZGVyXCJcbiAgICAgICAgICAgICAgICAgICAgOmRpc2FibGVkPVwiZGlzYWJsZWQgfHwgcmVhZG9ubHlcIlxuICAgICAgICAgICAgICAgICAgICA6Y2xhc3M9XCJtZXJnZUNsYXNzZXMoY29udHJvbENsYXNzZXMsIGNvbG9yYWJsZUNsYXNzZXMpXCJcbiAgICAgICAgICAgICAgICAgICAgOmFyaWEtbGFiZWw9XCJsYWJlbFwiXG4gICAgICAgICAgICAgICAgICAgIDphcmlhLWRlc2NyaWJlZGJ5PVwiaWRcIlxuICAgICAgICAgICAgICAgICAgICA6YXV0b2NvbXBsZXRlPVwiYXV0b2NvbXBsZXRlXCJcbiAgICAgICAgICAgICAgICAgICAgdi1iaW5kLWV2ZW50cz1cImJpbmRFdmVudHNcIlxuICAgICAgICAgICAgICAgICAgICBAaW5wdXQ9XCIkZW1pdCgnaW5wdXQnLCAkZXZlbnQudGFyZ2V0LnZhbHVlKVwiXG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDwvc2xvdD5cblxuICAgICAgICAgICAgPHNsb3QgbmFtZT1cImFjdGl2aXR5XCI+XG4gICAgICAgICAgICAgICAgPHRyYW5zaXRpb24gbmFtZT1cInNsaWRlLWZhZGVcIj5cbiAgICAgICAgICAgICAgICAgICAgPGFjdGl2aXR5LWluZGljYXRvciBrZXk9XCJ0ZXN0XCIgdi1pZj1cImFjdGl2aXR5XCIgcmVmPVwiYWN0aXZpdHlcIiB0eXBlPVwiZG90c1wiIDpzaXplPVwic2l6ZVwiLz5cbiAgICAgICAgICAgICAgICA8L3RyYW5zaXRpb24+XG4gICAgICAgICAgICA8L3Nsb3Q+XG5cbiAgICAgICAgICAgIDxzbG90IG5hbWU9XCJmZWVkYmFja1wiPlxuICAgICAgICAgICAgICAgIDxmb3JtLWZlZWRiYWNrIHYtaWY9XCJ2YWxpZEZlZWRiYWNrXCIgcmVmPVwiZmVlZGJhY2tcIiB2LWh0bWw9XCJ2YWxpZEZlZWRiYWNrXCIgdmFsaWQgLz5cbiAgICAgICAgICAgICAgICA8Zm9ybS1mZWVkYmFjayB2LWVsc2UtaWY9XCJpbnZhbGlkRmVlZGJhY2tcIiByZWY9XCJmZWVkYmFja1wiIHYtaHRtbD1cImludmFsaWRGZWVkYmFja1wiIGludmFsaWQgLz5cbiAgICAgICAgICAgIDwvc2xvdD5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPHNsb3QgbmFtZT1cImhlbHBcIj5cbiAgICAgICAgICAgIDxoZWxwLXRleHQgdi1pZj1cImhlbHBUZXh0XCIgcmVmPVwiaGVscFwiIHYtaHRtbD1cImhlbHBUZXh0XCIgLz5cbiAgICAgICAgPC9zbG90PlxuICAgICAgICBcbiAgICA8L2Zvcm0tZ3JvdXA+XG5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5cbmltcG9ydCBIZWxwVGV4dCBmcm9tICcuLi9IZWxwVGV4dCc7XG5pbXBvcnQgRm9ybUdyb3VwIGZyb20gJy4uL0Zvcm1Hcm91cCc7XG5pbXBvcnQgRm9ybUxhYmVsIGZyb20gJy4uL0Zvcm1MYWJlbCc7XG5pbXBvcnQgRm9ybUZlZWRiYWNrIGZyb20gJy4uL0Zvcm1GZWVkYmFjayc7XG5pbXBvcnQgQ29sb3JhYmxlIGZyb20gJy4uLy4uL01peGlucy9Db2xvcmFibGUnO1xuaW1wb3J0IEZvcm1Db250cm9sIGZyb20gJy4uLy4uL01peGlucy9Gb3JtQ29udHJvbCc7XG5pbXBvcnQgTWVyZ2VDbGFzc2VzIGZyb20gJy4uLy4uL01peGlucy9NZXJnZUNsYXNzZXMnO1xuaW1wb3J0IEFjdGl2aXR5SW5kaWNhdG9yIGZyb20gJy4uL0FjdGl2aXR5SW5kaWNhdG9yJztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ2lucHV0LWZpZWxkJyxcblxuICAgIG1peGluczogW1xuICAgICAgICBDb2xvcmFibGUsXG4gICAgICAgIEZvcm1Db250cm9sLFxuICAgICAgICBNZXJnZUNsYXNzZXNcbiAgICBdLFxuXG4gICAgY29tcG9uZW50czoge1xuICAgICAgICBIZWxwVGV4dCxcbiAgICAgICAgRm9ybUdyb3VwLFxuICAgICAgICBGb3JtTGFiZWwsXG4gICAgICAgIEZvcm1GZWVkYmFjayxcbiAgICAgICAgQWN0aXZpdHlJbmRpY2F0b3JcbiAgICB9LFxuXG4gICAgcHJvcHM6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvdyB0eXBlIGFjdGl2aXR5IGluZGljYXRvci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IEJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIGFjdGl2aXR5OiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHR5cGUgYXR0cmlidXRlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICd0ZXh0J1xuICAgICAgICB9XG5cbiAgICB9XG5cbn1cblxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwic2Nzc1wiPlxuLmlucHV0LWZpZWxkIHtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG5cbiAgICAuYWN0aXZpdHktaW5kaWNhdG9yIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICByaWdodDogMDtcbiAgICAgICAgdG9wOiA1MCU7XG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKC0xcmVtLCAtNTAlKTtcbiAgICAgICAgdHJhbnNpdGlvbjogYWxsIC4yNXMgZWFzZS1pbjtcbiAgICB9XG5cbiAgICAuYWN0aXZpdHktaW5kaWNhdG9yIHtcbiAgICB9XG5cbiAgICAuc2xpZGUtZmFkZS1lbnRlciB7XG4gICAgfVxuXG4gICAgLnNsaWRlLWZhZGUtZW50ZXItYWN0aXZlIHtcbiAgICB9XG5cbiAgICAuc2xpZGUtZmFkZS1sZWF2ZS1hY3RpdmUge1xuXG4gICAgfVxuXG4gICAgLnNsaWRlLWZhZGUtZW50ZXIsXG4gICAgLnNsaWRlLWZhZGUtbGVhdmUtdG8ge1xuICAgICAgICBvcGFjaXR5OiAwO1xuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgyNSUsIC01MCUpO1xuICAgIH1cbn1cbjwvc3R5bGU+XG4iLCJpbXBvcnQgSW5wdXRGaWVsZCBmcm9tICcuL0lucHV0RmllbGQnO1xuaW1wb3J0IFZ1ZUluc3RhbGxlciBmcm9tICcuLi8uLi9IZWxwZXJzL1Z1ZUluc3RhbGxlci9WdWVJbnN0YWxsZXInO1xuXG5jb25zdCBwbHVnaW4gPSBWdWVJbnN0YWxsZXIudXNlKHtcblxuICAgIGluc3RhbGwoVnVlLCBvcHRpb25zKSB7XG4gICAgICAgIFZ1ZUluc3RhbGxlci5jb21wb25lbnRzKHtcbiAgICAgICAgICAgIElucHV0RmllbGRcbiAgICAgICAgfSk7XG4gICAgfVxuXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgSW5wdXRGaWVsZDtcbiIsIjx0ZW1wbGF0ZT5cblxuICAgIDxmb3JtLWdyb3VwPlxuXG4gICAgICAgIDxzbG90IG5hbWU9XCJsYWJlbFwiPlxuICAgICAgICAgICAgPGZvcm0tbGFiZWwgdi1pZj1cImxhYmVsIHx8IGhhc0RlZmF1bHRTbG90XCIgOmZvcj1cImlkXCI+XG4gICAgICAgICAgICAgICAgPHNsb3Q+e3tsYWJlbH19PC9zbG90PlxuICAgICAgICAgICAgPC9mb3JtLWxhYmVsPlxuICAgICAgICA8L3Nsb3Q+XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cImN1c3RvbS1maWxlXCI+XG5cbiAgICAgICAgICAgIDxzbG90IG5hbWU9XCJwbGFjZWhvbGRlclwiPlxuICAgICAgICAgICAgICAgIDxmb3JtLWxhYmVsIDpjbGFzcz1cIm1lcmdlQ2xhc3Nlcyhjb2xvcmFibGVDbGFzc2VzLCAnY3VzdG9tLWZpbGUtbGFiZWwnKVwiIDpmb3I9XCJpZFwiIHYtaHRtbD1cInBsYWNlaG9sZGVyIHx8ICdDaG9vc2UgZmlsZSdcIiAvPlxuICAgICAgICAgICAgPC9zbG90PlxuXG4gICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICB2LWJpbmQtZXZlbnRzXG4gICAgICAgICAgICAgICAgdHlwZT1cImZpbGVcIlxuICAgICAgICAgICAgICAgIDpjbGFzcz1cImNvbnRyb2xDbGFzc2VzXCJcbiAgICAgICAgICAgICAgICA6aWQ9XCJpZFwiXG4gICAgICAgICAgICAgICAgOndpZHRoPVwid2lkdGhcIlxuICAgICAgICAgICAgICAgIDpoZWlnaHQ9XCJoZWlnaHRcIlxuICAgICAgICAgICAgICAgIDpyZXF1aXJlZD1cInJlcXVpcmVkXCJcbiAgICAgICAgICAgICAgICA6bXVsdGlwbGU9XCJtdWx0aXBsZVwiXG4gICAgICAgICAgICAgICAgOnJlYWRvbmx5PVwicmVhZG9ubHlcIlxuICAgICAgICAgICAgICAgIEBjaGFuZ2U9XCIkZW1pdCgnY2hhbmdlJywgJGV2ZW50LnRhcmdldC5maWxlcylcIj5cblxuICAgICAgICAgICAgPHNsb3QgbmFtZT1cImhlbHBcIj5cbiAgICAgICAgICAgICAgICA8aGVscC10ZXh0IHYtaWY9XCJoZWxwVGV4dFwiIHYtaHRtbD1cImhlbHBUZXh0XCIgLz5cbiAgICAgICAgICAgIDwvc2xvdD5cblxuICAgICAgICAgICAgPHNsb3QgbmFtZT1cImZlZWRiYWNrXCI+XG4gICAgICAgICAgICAgICAgPGZvcm0tZmVlZGJhY2sgdi1pZj1cInZhbGlkRmVlZGJhY2tcIiB2LWh0bWw9XCJ2YWxpZEZlZWRiYWNrXCIgdmFsaWQgLz5cbiAgICAgICAgICAgICAgICA8Zm9ybS1mZWVkYmFjayB2LWlmPVwiaW52YWxpZEZlZWRiYWNrXCIgdi1odG1sPVwiaW52YWxpZEZlZWRiYWNrXCIgaW52YWxpZCAvPlxuICAgICAgICAgICAgPC9zbG90PlxuXG4gICAgICAgIDwvZGl2PlxuXG4gICAgPC9mb3JtLWdyb3VwPlxuXG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IEhlbHBUZXh0IGZyb20gJy4uL0hlbHBUZXh0JztcbmltcG9ydCBGb3JtR3JvdXAgZnJvbSAnLi4vRm9ybUdyb3VwJztcbmltcG9ydCBGb3JtTGFiZWwgZnJvbSAnLi4vRm9ybUxhYmVsJztcbmltcG9ydCBGb3JtRmVlZGJhY2sgZnJvbSAnLi4vRm9ybUZlZWRiYWNrJztcbmltcG9ydCBJbnB1dEZpZWxkIGZyb20gJy4uL0lucHV0RmllbGQnO1xuaW1wb3J0IE1lcmdlQ2xhc3NlcyBmcm9tICcuLi8uLi9NaXhpbnMvTWVyZ2VDbGFzc2VzJztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ2ZpbGUtZmllbGQnLFxuXG4gICAgZXh0ZW5kczogSW5wdXRGaWVsZCxcblxuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgICAgSGVscFRleHQsXG4gICAgICAgIEZvcm1Hcm91cCxcbiAgICAgICAgRm9ybUxhYmVsLFxuICAgICAgICBGb3JtRmVlZGJhY2ssXG4gICAgICAgIE1lcmdlQ2xhc3Nlc1xuICAgIH0sXG5cbiAgICBtb2RlbDoge1xuICAgICAgICBldmVudDogJ2NoYW5nZSdcbiAgICB9LFxuXG4gICAgcHJvcHM6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gYXJyYXkgb2YgZXZlbnQgbmFtZXMgdGhhdCBjb3JyZWxhdGUgd2l0aCBjYWxsYmFjayBmdW5jdGlvbnNcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IEZ1bmN0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBiaW5kRXZlbnRzOiB7XG4gICAgICAgICAgICB0eXBlOiBBcnJheSxcbiAgICAgICAgICAgIGRlZmF1bHQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsnZm9jdXMnLCAnYmx1cicsICdpbnB1dCcsICdjbGljaycsICdrZXl1cCcsICdrZXlkb3duJywgJ3Byb2dyZXNzJ107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjbGFzcyBuYW1lIGFzc2lnbmVkIHRvIHRoZSBjb250cm9sIGVsZW1lbnRcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgZGVmYXVsdENvbnRyb2xDbGFzczoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJ2N1c3RvbS1maWxlLWlucHV0J1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBhcnJheSBvZiB2YWxpZCBleHRlbnNpb25zXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGV4dGVuc2lvbnM6IEFycmF5LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdHlwZSBhdHRyaWJ1dGVcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGlwbGU6IEJvb2xlYW4sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBoZWlnaHQgYXR0cmlidXRlIGZvciB0aGUgY29udHJvbCBlbGVtZW50XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGhlaWdodDogW051bWJlciwgU3RyaW5nXSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHdpZHRoIGF0dHJpYnV0ZSBmb3IgdGhlIGNvbnRyb2wgZWxlbWVudFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICB3aWR0aDogW051bWJlciwgU3RyaW5nXVxuXG4gICAgfVxuXG59XG5cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IEZpbGVGaWVsZCBmcm9tICcuL0ZpbGVGaWVsZCc7XG5pbXBvcnQgVnVlSW5zdGFsbGVyIGZyb20gJy4uLy4uL0hlbHBlcnMvVnVlSW5zdGFsbGVyL1Z1ZUluc3RhbGxlcic7XG5cbmNvbnN0IHBsdWdpbiA9IFZ1ZUluc3RhbGxlci51c2Uoe1xuXG4gICAgaW5zdGFsbChWdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgVnVlSW5zdGFsbGVyLmNvbXBvbmVudHMoe1xuICAgICAgICAgICAgRmlsZUZpZWxkXG4gICAgICAgIH0pO1xuICAgIH1cblxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IEZpbGVGaWVsZDtcbiIsIjx0ZW1wbGF0ZT5cblxuICAgIDxidG4gY2xhc3M9XCJidG4tZmlsZVwiIDp0eXBlPVwidHlwZVwiIDp2YXJpYW50PVwidmFyaWFudFwiIDpibG9jaz1cImJsb2NrXCIgOnNpemU9XCJzaXplXCIgOmRpc2FibGVkPVwiZGlzYWJsZWRcIiA6YWN0aXZlPVwiYWN0aXZlXCI+XG4gICAgICAgIDxzbG90Lz5cblxuICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgIHYtYmluZC1ldmVudHNcbiAgICAgICAgICAgIHR5cGU9XCJmaWxlXCJcbiAgICAgICAgICAgIDpjbGFzcz1cImNvbnRyb2xDbGFzc2VzXCJcbiAgICAgICAgICAgIDppZD1cImlkXCJcbiAgICAgICAgICAgIDp3aWR0aD1cIndpZHRoXCJcbiAgICAgICAgICAgIDpoZWlnaHQ9XCJoZWlnaHRcIlxuICAgICAgICAgICAgOnJlcXVpcmVkPVwicmVxdWlyZWRcIlxuICAgICAgICAgICAgOm11bHRpcGxlPVwibXVsdGlwbGVcIlxuICAgICAgICAgICAgOnJlYWRvbmx5PVwicmVhZG9ubHlcIlxuICAgICAgICAgICAgdi1vbjpjaGFuZ2U9XCIkZW1pdCgnY2hhbmdlJywgbXVsdGlwbGUgPyAkZXZlbnQudGFyZ2V0LmZpbGVzIDogJGV2ZW50LnRhcmdldC5maWxlc1swXSlcIj5cbiAgICA8L2J0bj5cblxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBCdG4gZnJvbSAnLi4vQnRuJztcbmltcG9ydCBGaWxlRmllbGQgZnJvbSAnLi4vRmlsZUZpZWxkJztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ2J0bi1maWxlJyxcblxuICAgIG1peGluczogW1xuICAgICAgICBGaWxlRmllbGRcbiAgICBdLFxuXG4gICAgY29tcG9uZW50czoge1xuICAgICAgICBCdG4sXG4gICAgICAgIEZpbGVGaWVsZFxuICAgIH0sXG5cbiAgICBtb2RlbDoge1xuICAgICAgICBldmVudDogJ2NoYW5nZSdcbiAgICB9LFxuXG4gICAgcHJvcHM6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHR5cGUgYXR0cmlidXRlIGZvciB0aGUgYnV0dG9uLiBOb3QgYXBwbGllZCBpZiBhbiBhbmNob3JcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJ2J1dHRvbidcbiAgICAgICAgfVxuXG4gICAgfVxuXG59XG5cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cInNjc3NcIj5cbi5idG4tZmlsZSB7XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcblxuICAgIGlucHV0IHtcbiAgICAgICAgei1pbmRleDogMTtcbiAgICAgICAgb3BhY2l0eTogMDtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IDA7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgfVxufVxuPC9zdHlsZT5cbiIsImltcG9ydCBCdG5GaWxlIGZyb20gJy4vQnRuRmlsZSc7XG5pbXBvcnQgVnVlSW5zdGFsbGVyIGZyb20gJy4uLy4uL0hlbHBlcnMvVnVlSW5zdGFsbGVyL1Z1ZUluc3RhbGxlcic7XG5cbmNvbnN0IHBsdWdpbiA9IFZ1ZUluc3RhbGxlci51c2Uoe1xuXG4gICAgaW5zdGFsbChWdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgVnVlSW5zdGFsbGVyLmNvbXBvbmVudHMoe1xuICAgICAgICAgICAgQnRuRmlsZVxuICAgICAgICB9KTtcbiAgICB9XG5cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBCdG5GaWxlO1xuIiwiPHRlbXBsYXRlPlxuICAgIDxkaXYgOmNsYXNzPVwiY2xhc3Nlc1wiIDpkYXRhLXRvZ2dsZT1cInRvZ2dsZSA/ICdidXR0b25zJyA6IGZhbHNlXCIgcm9sZT1cImdyb3VwXCI+XG4gICAgICAgIDxidG4gdi1pZj1cImJ1dHRvbnNcIiB2LWZvcj1cIihidXR0b24sIGkpIGluIGJ1dHRvbnNcIiA6a2V5PVwiaVwiIHYtYmluZD1cImJ1dHRvblwiIC8+XG4gICAgICAgIDxzbG90Lz5cbiAgICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgQnRuIGZyb20gJy4uL0J0bic7XG5pbXBvcnQgQ29sb3JhYmxlIGZyb20gJy4uLy4uL01peGlucy9Db2xvcmFibGUnO1xuaW1wb3J0IE1lcmdlQ2xhc3NlcyBmcm9tICcuLi8uLi9NaXhpbnMvTWVyZ2VDbGFzc2VzJztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ2J0bi1ncm91cCcsXG5cbiAgICBjb21wb25lbnRzOiB7XG4gICAgICAgIEJ0blxuICAgIH0sXG5cbiAgICBtaXhpbnM6IFtcbiAgICAgICAgQ29sb3JhYmxlLFxuICAgICAgICBNZXJnZUNsYXNzZXNcbiAgICBdLFxuXG4gICAgcHJvcHM6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gYXJyYXkgb2YgYnV0dG9uc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICAgICAqL1xuICAgICAgICBidXR0b25zOiBBcnJheSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVub3RlIHRoZSBidXR0b24gZ3JvdXAgYXMgdG9nZ2xlIGJ1dHRvbnNcbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0b2dnbGU6IEJvb2xlYW4sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc3BsYXkgdGhlIGJ1dHRvbnMgdmVydGljYWxseVxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHZlcnRpY2FsOiBCb29sZWFuXG5cbiAgICB9LFxuXG4gICAgY29tcHV0ZWQ6IHtcblxuICAgICAgICBjbGFzc2VzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVyZ2VDbGFzc2VzKFxuICAgICAgICAgICAgICAgIHRoaXMuY29sb3JhYmxlQ2xhc3Nlcywge1xuICAgICAgICAgICAgICAgICAgICAnYnRuLWdyb3VwJzogIXRoaXMudmVydGljYWwsXG4gICAgICAgICAgICAgICAgICAgICdidG4tZ3JvdXAtdG9nZ2xlJzogdGhpcy50b2dnbGUsXG4gICAgICAgICAgICAgICAgICAgICdidG4tZ3JvdXAtdmVydGljYWwnOiB0aGlzLnZlcnRpY2FsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgICA8ZGl2IGNsYXNzPVwiYnRuLWdyb3VwLXRvZ2dsZVwiIGRhdGEtdG9nZ2xlPVwiYnV0dG9uc1wiPlxuICAgICAgICA8c2xvdC8+XG4gICAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ2J0bi1ncm91cC10b2dnbGUnXG5cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICAgIDxkaXYgY2xhc3M9XCJidG4tdG9vbGJhclwiIHJvbGU9XCJ0b29sYmFyXCI+XG4gICAgICAgIDxzbG90Lz5cbiAgICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAnYnRuLXRvb2xiYXInXG5cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IEJ0bkdyb3VwIGZyb20gJy4vQnRuR3JvdXAudnVlJztcbmltcG9ydCBCdG5Hcm91cFRvZ2dsZSBmcm9tICcuL0J0bkdyb3VwVG9nZ2xlJztcbmltcG9ydCBCdG5Ub29sYmFyIGZyb20gJy4vQnRuVG9vbGJhcic7XG5pbXBvcnQgVnVlSW5zdGFsbGVyIGZyb20gJy4uLy4uL0hlbHBlcnMvVnVlSW5zdGFsbGVyL1Z1ZUluc3RhbGxlcic7XG5cbmNvbnN0IHBsdWdpbiA9IFZ1ZUluc3RhbGxlci51c2Uoe1xuXG4gICAgaW5zdGFsbChWdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgVnVlSW5zdGFsbGVyLmNvbXBvbmVudHMoe1xuICAgICAgICAgICAgQnRuR3JvdXAsXG4gICAgICAgICAgICBCdG5Hcm91cFRvZ2dsZSxcbiAgICAgICAgICAgIEJ0blRvb2xiYXJcbiAgICAgICAgfSk7XG4gICAgfVxuXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgQnRuR3JvdXA7XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1dWlkKCkge1xuICAgIHJldHVybiAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIGMgPT4ge1xuICAgICAgICB2YXIgciA9IE1hdGgucmFuZG9tKCkgKiAxNiB8IDAsIHYgPSBjID09ICd4JyA/IHIgOiAociAmIDB4MyB8IDB4OCk7XG4gICAgICAgIHJldHVybiB2LnRvU3RyaW5nKDE2KTtcbiAgICB9KTtcbn1cbiIsImltcG9ydCB7IGlzRnVuY3Rpb24gfSBmcm9tICdsb2Rhc2gtZXMnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBtZXRob2RzOiB7XG4gICAgICAgIHByb3h5KGNhbGxiYWNrLCBldmVudCkge1xuICAgICAgICAgICAgaWYoaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykuc3BsaWNlKDEpKTtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG59XG4iLCI8dGVtcGxhdGU+XG4gICAgPGNvbXBvbmVudFxuICAgICAgICA6aXM9XCJjb21wb25lbnRcIlxuICAgICAgICA6aHJlZj1cImhyZWYgfHwgKGNvbXBvbmVudCA9PT0gJ2EnID8gJyMnIDogZmFsc2UpXCJcbiAgICAgICAgY2xhc3M9XCJkcm9wZG93bi1pdGVtXCJcbiAgICAgICAgOmNsYXNzPVwieydhY3RpdmUnOiBhY3RpdmV9XCJcbiAgICAgICAgOnR5cGU9XCJjb21wb25lbnQgPT09ICdidXR0b24nID8gJ2J1dHRvbicgOiBmYWxzZVwiXG4gICAgICAgIEBjbGljaz1cIm9uQ2xpY2tcIj5cbiAgICAgICAgPGkgdi1pZj1cImljb25cIiA6Y2xhc3M9XCJpY29uXCIvPlxuICAgICAgICA8c2xvdD57e2xhYmVsfX08L3Nsb3Q+XG4gICAgPC9jb21wb25lbnQ+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IHsgaXNGdW5jdGlvbiB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgUHJveHkgZnJvbSAnLi4vLi4vTWl4aW5zL1Byb3h5L1Byb3h5JztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbWl4aW5zOiBbXG4gICAgICAgIFByb3h5XG4gICAgXSxcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElzIHRoZSBtZW51IGl0ZW0gYWN0aXZlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgT2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBhY3RpdmU6IEJvb2xlYW4sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElzIHRoZSBtZW51IGl0ZW0gYSBidXR0b25cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IE9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgYnV0dG9uOiBCb29sZWFuLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYGVsZW1lbnRgIGF0dHJpYnV0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IE9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgZWxlbWVudDogU3RyaW5nLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYGhyZWZgIGF0dHJpYnV0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IE9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgaHJlZjogU3RyaW5nLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaWNvbiBvZiB0aGUgZHJvcGRvd24gbWVudSBpdGVtLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgT2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBpY29uOiBTdHJpbmcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsYWJlbCBvZiB0aGUgZHJvcGRvd24gbWVudSBpdGVtLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgT2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBsYWJlbDogU3RyaW5nXG5cbiAgICB9LFxuXG4gICAgY29tcHV0ZWQ6IHtcblxuICAgICAgICBjb21wb25lbnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50IHx8ICh0aGlzLmJ1dHRvbiA/ICdidXR0b24nIDogJ2EnKTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIG1ldGhvZHM6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBjYWxsYmFjayBmdW5jdGlvbiBmb3IgdGhlIGBjbGlja2AgZXZlbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBPYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIG9uQ2xpY2soZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2NsaWNrJywgZXZlbnQpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbn1cblxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gICAgPGg1IGNsYXNzPVwiZHJvcGRvd24taGVhZGVyXCI+XG4gICAgICAgIDxzbG90Pnt7aGVhZGVyfX08L3Nsb3Q+XG4gICAgPC9oNT5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdkcm9wZG93bi1tZW51LWhlYWRlcicsXG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdmFsdWUgb2YgdGhlIGhlYWRlclxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgT2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBoZWFkZXI6IFN0cmluZ1xuXG4gICAgfVxuXG59XG5cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICAgIDxkaXYgY2xhc3M9XCJkcm9wZG93bi1kaXZpZGVyXCI+PC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAnZHJvcGRvd24tbWVudS1kaXZpZGVyJ1xuXG59XG5cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICAgIDxkaXYgY2xhc3M9XCJkcm9wZG93bi1tZW51XCIgOmNsYXNzPVwieydkcm9wZG93bi1tZW51LXJpZ2h0JzogYWxpZ24gPT09ICdyaWdodCcsICdzaG93Jzogc2hvd31cIiA6YXJpYS1sYWJlbGxlZGJ5PVwiaWRcIiB0YWJpbmRleD1cIi0xXCIgQGNsaWNrPVwib25DbGlja1wiPlxuICAgICAgICA8dGVtcGxhdGUgdi1mb3I9XCJpdGVtIGluIGl0ZW1zXCI+XG4gICAgICAgICAgICA8Y29tcG9uZW50IDppcz1cInByZWZpeChpdGVtLnR5cGUgfHwgJ2l0ZW0nLCAnZHJvcGRvd24tbWVudScpXCIgdi1iaW5kPVwiaXRlbVwiLz5cbiAgICAgICAgPC90ZW1wbGF0ZT5cbiAgICAgICAgPHNsb3QvPlxuICAgIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCB7IGVhY2ggfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IHV1aWQgZnJvbSAnLi4vLi4vSGVscGVycy9VdWlkL1V1aWQnO1xuaW1wb3J0IHByZWZpeCBmcm9tICcuLi8uLi9IZWxwZXJzL1ByZWZpeC9QcmVmaXgnO1xuaW1wb3J0IERyb3Bkb3duTWVudUl0ZW0gZnJvbSAnLi9Ecm9wZG93bk1lbnVJdGVtJztcbmltcG9ydCBEcm9wZG93bk1lbnVIZWFkZXIgZnJvbSAnLi9Ecm9wZG93bk1lbnVIZWFkZXInO1xuaW1wb3J0IERyb3Bkb3duTWVudURpdmlkZXIgZnJvbSAnLi9Ecm9wZG93bk1lbnVEaXZpZGVyJztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgY29tcG9uZW50czoge1xuICAgICAgICBEcm9wZG93bk1lbnVJdGVtLFxuICAgICAgICBEcm9wZG93bk1lbnVIZWFkZXIsXG4gICAgICAgIERyb3Bkb3duTWVudURpdmlkZXJcbiAgICB9LFxuXG4gICAgcHJvcHM6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGBpZGAgYXR0cmlidXRlIG9uIHRoZSB0b2dnbGUgYnV0dG9uIGFuZCBhcmlhIGxhYmVsLiBJZiBubyBgaWRgIGlzXG4gICAgICAgICAqIGRlZmluZWQsIHRoZW4gYSBVVUlEIHdpbGwgYmUgZ2VuZXJhdGVkIGluc3RlYWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBPYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIGlkOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiB1dWlkXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc3BsYXkgdGhlIGRyb3Bkb3duIG1lbnUgYWxpZ25lZCBsZWZ0IG9yIHJpZ2h0XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGFsaWduOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAnbGVmdCcsXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbJ2xlZnQnLCAncmlnaHQnXS5pbmRleE9mKHZhbHVlLnRvTG93ZXJDYXNlKCkpICE9PSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRlZmF1bHQgdmlzaWJpbGl0eSBvZiB0aGUgZHJvcGRvd24gbWVudS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IE9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgc2hvdzogQm9vbGVhbixcblxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gYXJyYXkgb2YgZHJvcGRvd24gaXRlbXMuIElmIGFuIGtleS92YWx1ZSBwYWlyIGlzbid0IGRlZmluZWQsIHRoZVxuICAgICAgICAgKiBkZWZhdWx0IHZhbHVlIHdpbGwgYmUgdXNlZC4gSWYgbm8gaXRlbXMgYXJlIGRlZmluZWQsIHRoZW4gdGhlIHNsb3RcbiAgICAgICAgICogbmFtZWQgXCJpdGVtc1wiIGNhbiBiZSB1c2VkIHRvIGRlZmluZSB0aGUgb3B0aW9ucyB3aXRoIEhUTUwuXG4gICAgICAgICAqXG4gICAgICAgICAqIFt7XG4gICAgICAgICAqICAgICAgdHlwZTogJ2l0ZW0nLCAvLyBTdHJpbmcgW2l0ZW18aGVhZGVyfGRpdmlkZXJdXG4gICAgICAgICAqICAgICAgaHJlZjogJyMnLCAvLyBTdHJpbmdcbiAgICAgICAgICogICAgICBsYWJlbDogJ1NvbWUgbGFiZWwnLCAvLyBTdHJpbmdcbiAgICAgICAgICogICAgICBvbkNsaWNrOiAoZXZlbnQpID0+IHt9IC8vIEZ1bmN0aW9uXG4gICAgICAgICAqIH1dXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBBcnJheVxuICAgICAgICAgKi9cbiAgICAgICAgaXRlbXM6IEFycmF5XG5cbiAgICB9LFxuXG4gICAgbWV0aG9kczoge1xuXG4gICAgICAgIHByZWZpeDogcHJlZml4LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGNhbGxiYWNrIGZ1bmN0aW9uIGZvciB0aGUgYGNsaWNrYCBldmVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIE9iamVjdCBldmVudFxuICAgICAgICAgKiBAcGFyYW0gT2JqZWN0IGl0ZW1cbiAgICAgICAgICogQHJldHVybiB2b2lkXG4gICAgICAgICAqL1xuICAgICAgICBvbkNsaWNrKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCdjbGljaycsIGV2ZW50KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBjYWxsYmFjayBmdW5jdGlvbiBmb3IgdGhlIGBjbGlja2AgZXZlbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBPYmplY3QgZXZlbnRcbiAgICAgICAgICogQHBhcmFtIE9iamVjdCBpdGVtXG4gICAgICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAgICAgKi9cbiAgICAgICAgb25JdGVtQ2xpY2soZXZlbnQsIGl0ZW0pIHtcbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2l0ZW06Y2xpY2snLCBldmVudCwgaXRlbSk7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBtb3VudGVkKCkge1xuICAgICAgICBlYWNoKHRoaXMuJGNoaWxkcmVuLCBjaGlsZCA9PiB7XG4gICAgICAgICAgICBjaGlsZC4kb24oJ2NsaWNrJywgZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMub25JdGVtQ2xpY2soZXZlbnQsIGNoaWxkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbn1cblxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgRHJvcGRvd25NZW51IGZyb20gJy4vRHJvcGRvd25NZW51JztcbmltcG9ydCBEcm9wZG93bk1lbnVEaXZpZGVyIGZyb20gJy4vRHJvcGRvd25NZW51RGl2aWRlcic7XG5pbXBvcnQgRHJvcGRvd25NZW51SGVhZGVyIGZyb20gJy4vRHJvcGRvd25NZW51SGVhZGVyJztcbmltcG9ydCBEcm9wZG93bk1lbnVJdGVtIGZyb20gJy4vRHJvcGRvd25NZW51SXRlbSc7XG5pbXBvcnQgVnVlSW5zdGFsbGVyIGZyb20gJy4uLy4uL0hlbHBlcnMvVnVlSW5zdGFsbGVyL1Z1ZUluc3RhbGxlcic7XG5cbmNvbnN0IHBsdWdpbiA9IFZ1ZUluc3RhbGxlci51c2Uoe1xuXG4gICAgaW5zdGFsbChWdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgVnVlSW5zdGFsbGVyLmNvbXBvbmVudHMoe1xuICAgICAgICAgICAgRHJvcGRvd25NZW51LFxuICAgICAgICAgICAgRHJvcGRvd25NZW51RGl2aWRlcixcbiAgICAgICAgICAgIERyb3Bkb3duTWVudUhlYWRlcixcbiAgICAgICAgICAgIERyb3Bkb3duTWVudUl0ZW1cbiAgICAgICAgfSk7XG4gICAgfVxuXG59KTtcblxuZXhwb3J0ICogZnJvbSAnLi9Ecm9wZG93bk1lbnVEaXZpZGVyJztcbmV4cG9ydCAqIGZyb20gJy4vRHJvcGRvd25NZW51SGVhZGVyJztcbmV4cG9ydCAqIGZyb20gJy4vRHJvcGRvd25NZW51SXRlbSc7XG5leHBvcnQgZGVmYXVsdCBEcm9wZG93bk1lbnU7XG4iLCI8dGVtcGxhdGU+XG5cbiAgICA8YnRuLWdyb3VwIHYtaWY9XCJzcGxpdFwiPlxuICAgICAgICA8dGVtcGxhdGUgdi1pZj1cIiFkcm9wbGVmdFwiPlxuICAgICAgICAgICAgPGEgdi1pZj1cImhyZWZcIiA6aHJlZj1cImhyZWZcIiA6Y2xhc3M9XCJhY3Rpb25DbGFzc2VzXCIgQGNsaWNrPVwib25DbGlja1wiPlxuICAgICAgICAgICAgICAgIDxzbG90IG5hbWU9XCJsYWJlbFwiPjxpIHYtaWY9XCJpY29uXCIgOmNsYXNzPVwiaWNvblwiPjwvaT4ge3tsYWJlbH19PC9zbG90PlxuICAgICAgICAgICAgPC9hPlxuICAgICAgICAgICAgPGJ1dHRvbiB2LWVsc2UgOnR5cGU9XCJ0eXBlXCIgOmNsYXNzPVwiYWN0aW9uQ2xhc3Nlc1wiIEBjbGljaz1cIm9uQ2xpY2tcIj5cbiAgICAgICAgICAgICAgICA8c2xvdCBuYW1lPVwibGFiZWwtd3JhcHBlclwiPjxpIHYtaWY9XCJpY29uXCIgOmNsYXNzPVwiaWNvblwiPjwvaT4gPHNsb3QgbmFtZT1cImxhYmVsXCI+e3tsYWJlbH19PC9zbG90Pjwvc2xvdD5cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICA8L3RlbXBsYXRlPlxuICAgICAgICA8YnRuLWdyb3VwIDpjbGFzcz1cInsnZHJvcHVwJzogZHJvcHVwLCAnZHJvcHJpZ2h0JzogZHJvcHJpZ2h0LCAnZHJvcGxlZnQnOiBkcm9wbGVmdH1cIj5cbiAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGFyaWEtaGFzcG9wdXA9XCJ0cnVlXCIgOmFyaWEtZXhwYW5kZWQ9XCJpc0Ryb3Bkb3duU2hvd2luZ1wiIDppZD1cImlkXCIgOmNsYXNzPVwidG9nZ2xlQ2xhc3Nlc1wiIEBjbGljay5wcmV2ZW50PVwiIWlzRHJvcGRvd25TaG93aW5nID8gc2hvdygpIDogaGlkZSgpXCIgQGJsdXI9XCJvbkJsdXJcIj48L2J1dHRvbj5cbiAgICAgICAgICAgIDxkcm9wZG93bi1tZW51XG4gICAgICAgICAgICAgICAgOmlkPVwiaWRcIlxuICAgICAgICAgICAgICAgIDphbGlnbj1cImFsaWduXCJcbiAgICAgICAgICAgICAgICA6c2hvdy5zeW5jPVwiaXNEcm9wZG93blNob3dpbmdcIlxuICAgICAgICAgICAgICAgIEBjbGljaz1cIm9uTWVudUNsaWNrXCJcbiAgICAgICAgICAgICAgICBAaXRlbTpjbGljaz1cIm9uSXRlbUNsaWNrXCI+XG4gICAgICAgICAgICAgICAgPHNsb3QvPlxuICAgICAgICAgICAgPC9kcm9wZG93bi1tZW51PlxuICAgICAgICA8L2J0bi1ncm91cD5cbiAgICAgICAgPHRlbXBsYXRlIHYtaWY9XCJkcm9wbGVmdFwiPlxuICAgICAgICAgICAgPGEgdi1pZj1cImhyZWZcIiA6aHJlZj1cImhyZWZcIiA6Y2xhc3M9XCJhY3Rpb25DbGFzc2VzXCIgQGNsaWNrPVwib25DbGlja1wiPlxuICAgICAgICAgICAgICAgIDxzbG90IG5hbWU9XCJsYWJlbFwiPjxpIHYtaWY9XCJpY29uXCIgOmNsYXNzPVwiaWNvblwiPjwvaT4ge3tsYWJlbH19PC9zbG90PlxuICAgICAgICAgICAgPC9hPlxuICAgICAgICAgICAgPGJ1dHRvbiB2LWVsc2UgOnR5cGU9XCJ0eXBlXCIgOmNsYXNzPVwiYWN0aW9uQ2xhc3Nlc1wiIEBjbGljaz1cIm9uQ2xpY2tcIj5cbiAgICAgICAgICAgICAgICA8c2xvdCBuYW1lPVwibGFiZWwtd3JhcHBlclwiPjxpIHYtaWY9XCJpY29uXCIgOmNsYXNzPVwiaWNvblwiPjwvaT4gPHNsb3QgbmFtZT1cImxhYmVsXCI+e3tsYWJlbH19PC9zbG90Pjwvc2xvdD5cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICA8L3RlbXBsYXRlPlxuICAgIDwvYnRuLWdyb3VwPlxuXG4gICAgPGJ0bi1ncm91cCB2LWVsc2UgOmNsYXNzPVwieydkcm9wdXAnOiBkcm9wdXAsICdkcm9wcmlnaHQnOiBkcm9wcmlnaHQsICdkcm9wbGVmdCc6IGRyb3BsZWZ0fVwiIEBjbGljaz1cIm9uQ2xpY2tcIj5cbiAgICAgICAgPGJ1dHRvbiBhcmlhLWhhc3BvcHVwPVwidHJ1ZVwiIDphcmlhLWV4cGFuZGVkPVwiaXNEcm9wZG93blNob3dpbmdcIiA6dHlwZT1cInR5cGVcIiA6aWQ9XCJpZFwiIDpjbGFzcz1cInRvZ2dsZUNsYXNzZXNcIiBAY2xpY2sucHJldmVudD1cIiFpc0Ryb3Bkb3duU2hvd2luZyA/IHNob3coKSA6IGhpZGUoKVwiIEBibHVyPVwib25CbHVyXCI+XG4gICAgICAgICAgICA8c2xvdCBuYW1lPVwibGFiZWxcIj48aSB2LWlmPVwiaWNvblwiIDpjbGFzcz1cImljb25cIj48L2k+IHt7bGFiZWx9fTwvc2xvdD5cbiAgICAgICAgPC9idXR0b24+XG5cbiAgICAgICAgPGRyb3Bkb3duLW1lbnVcbiAgICAgICAgICAgIDppZD1cImlkXCJcbiAgICAgICAgICAgIDphbGlnbj1cImFsaWduXCJcbiAgICAgICAgICAgIDpzaG93LnN5bmM9XCJpc0Ryb3Bkb3duU2hvd2luZ1wiXG4gICAgICAgICAgICBAY2xpY2s9XCJvbk1lbnVDbGlja1wiXG4gICAgICAgICAgICBAaXRlbTpjbGljaz1cIm9uSXRlbUNsaWNrXCI+XG4gICAgICAgICAgICA8c2xvdC8+XG4gICAgICAgIDwvZHJvcGRvd24tbWVudT5cbiAgICA8L2J0bi1ncm91cD5cblxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cblxuaW1wb3J0IHsgZWFjaCB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgdXVpZCBmcm9tICcuLi8uLi9IZWxwZXJzL1V1aWQvVXVpZCc7XG5pbXBvcnQgcHJlZml4IGZyb20gJy4uLy4uL0hlbHBlcnMvUHJlZml4L1ByZWZpeCc7XG5pbXBvcnQgQnRuIGZyb20gJy4uL0J0bic7XG5pbXBvcnQgQnRuR3JvdXAgZnJvbSAnLi4vQnRuR3JvdXAnO1xuaW1wb3J0IERyb3Bkb3duTWVudSBmcm9tICcuLi9Ecm9wZG93bk1lbnUnO1xuaW1wb3J0IFBvcHBlciBmcm9tICdwb3BwZXIuanMnO1xuXG5jb25zdCBUQUJfS0VZQ09ERSA9IDk7XG5jb25zdCBMRUZUX0FSUk9XX0tFWUNPREUgPSAzNztcbmNvbnN0IFJJR0hUX0FSUk9XX0tFWUNPREUgPSAzOTtcbmNvbnN0IFVQX0FSUk9XX0tFWUNPREUgPSAzODtcbmNvbnN0IERPV05fQVJST1dfS0VZQ09ERSA9IDQwO1xuXG5sZXQgaWdub3JlQmx1ckV2ZW50ID0gZmFsc2U7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdidG4tZHJvcGRvd24nLFxuXG4gICAgZXh0ZW5kczogQnRuLFxuXG4gICAgY29tcG9uZW50czoge1xuICAgICAgICBCdG5Hcm91cCxcbiAgICAgICAgRHJvcGRvd25NZW51XG4gICAgfSxcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBidXR0b24gaWNvbiB0aGF0IGFwcGVhcnMgYmVmb3JlIHRoZSBsYWJlbC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgYXV0b2Nsb3NlOiBCb29sZWFuLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYnV0dG9uIGljb24gdGhhdCBhcHBlYXJzIGJlZm9yZSB0aGUgbGFiZWwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGljb246IFN0cmluZyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRvZ2dsZSBidXR0b24ncyBsYWJlbC4gSWYgbm90IGRlZmluZWQgYXMgYW4gYXR0cmlidXRlLFxuICAgICAgICAgKiB5b3UgY2FuIG92ZXJyaWRlIHdpdGggdGhlIGNvbXBvbmVudCdzIHNsb3QgKGlubmVyIGh0bWwpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBsYWJlbDogU3RyaW5nLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYGlkYCBhdHRyaWJ1dGUgb24gdGhlIHRvZ2dsZSBidXR0b24gYW5kIGFyaWEgbGFiZWwuIElmIG5vIGBpZGAgaXNcbiAgICAgICAgICogZGVmaW5lZCwgdGhlbiBhIFVVSUQgd2lsbCBiZSBnZW5lcmF0ZWQgaW5zdGVhZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgaWQ6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6IHV1aWRcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGJ1dHRvbiB0eXBlIGF0dHJpYnV0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJ2J1dHRvbidcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzcGxheSB0aGUgZHJvcGRvd24gbWVudSBhbGlnbmVkIGxlZnQgb3IgcmlnaHRcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgYWxpZ246IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdsZWZ0JyxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsnbGVmdCcsICdyaWdodCddLmluZGV4T2YodmFsdWUudG9Mb3dlckNhc2UoKSkgIT09IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwbGF5IHRoZSBkcm9wZG93biBidXR0b24gd2l0aCBhIHNwbGl0IHRvZ2dsZSBidXR0b24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBCb29sZWFuXG4gICAgICAgICAqL1xuICAgICAgICBzcGxpdDoge1xuICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc3BsYXkgYXMgYSBkcm9wdXAgaW5zdGVhZCBvZiBhIGRyb3Bkb3duLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgQm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgZHJvcHVwOiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzcGxheSBhcyBhIGRyb3ByaWdodCBpbnN0ZWFkIG9mIGEgZHJvcGRvd24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBCb29sZWFuXG4gICAgICAgICAqL1xuICAgICAgICBkcm9wcmlnaHQ6IHtcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwbGF5IGFzIGEgZHJvcGxlZnQgaW5zdGVhZCBvZiBhIGRyb3Bkb3duLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgQm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgZHJvcGxlZnQ6IHtcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgbWV0aG9kczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb2N1cyBvbiB0aGUgdGhlIGRyb3Bkb3duIHRvZ2dsZSBidXR0b25cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB2b2lkXG4gICAgICAgICAqL1xuICAgICAgICBmb2N1cygpIHtcbiAgICAgICAgICAgIHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3IoJy5kcm9wZG93bi10b2dnbGUnKS5mb2N1cygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb2N1cyBvbiB0aGUgdGhlIGRyb3Bkb3duIHRvZ2dsZSBidXR0b25cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB2b2lkXG4gICAgICAgICAqL1xuICAgICAgICBxdWVyeUZvY3VzYWJsZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yKCcuZHJvcGRvd24tbWVudScpLnF1ZXJ5U2VsZWN0b3JBbGwoJ2xhYmVsLCBpbnB1dCwgc2VsZWN0LCB0ZXh0YXJlYSwgW3RhYmluZGV4XTpub3QoW3RhYmluZGV4PVwiLTFcIl0pJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ldGhvZCB0byBjaGVjayBpZiB0aGUgZ2l2ZW4gZWxlbWVudCBpcyBmb2N1c2FibGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAgICAgKi9cbiAgICAgICAgaXNGb2N1c2FibGUoZWxlbWVudCkge1xuICAgICAgICAgICAgY29uc3Qgbm9kZXMgPSB0aGlzLnF1ZXJ5Rm9jdXNhYmxlKCk7XG5cbiAgICAgICAgICAgIGZvcihsZXQgaSBpbiBub2Rlcykge1xuICAgICAgICAgICAgICAgIGlmKGVsZW1lbnQgPT09IG5vZGVzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUb2dnbGUgdGhlIGRyb3Bkb3duIG1lbnVcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB2b2lkXG4gICAgICAgICAqL1xuICAgICAgICB0b2dnbGUoKSB7XG4gICAgICAgICAgICAhdGhpcy5pc0Ryb3Bkb3duU2hvd2luZyA/IHRoaXMuc2hvdygpIDogdGhpcy5oaWRlKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3cgdGhlIGRyb3Bkb3duIG1lbnVcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB2b2lkXG4gICAgICAgICAqL1xuICAgICAgICBzaG93KCkge1xuICAgICAgICAgICAgdGhpcy5pc0Ryb3Bkb3duU2hvd2luZyA9IHRydWU7XG5cbiAgICAgICAgICAgIHRoaXMuJG5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgc2lkZSA9ICdib3R0b20nO1xuXG4gICAgICAgICAgICAgICAgaWYodGhpcy5kcm9wdXApIHtcbiAgICAgICAgICAgICAgICAgICAgc2lkZSA9ICd0b3AnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYodGhpcy5kcm9wbGVmdCkge1xuICAgICAgICAgICAgICAgICAgICBzaWRlID0gJ2xlZnQnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYodGhpcy5kcm9wcmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2lkZSA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgbWVudSA9IHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3IoJy5kcm9wZG93bi1tZW51Jyk7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9nZ2xlID0gdGhpcy4kZWwucXVlcnlTZWxlY3RvcignLmRyb3Bkb3duLXRvZ2dsZScpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0gW3NpZGUsIHRoaXMuYWxpZ24gPT09ICdsZWZ0JyA/ICdzdGFydCcgOiAnZW5kJ107XG5cbiAgICAgICAgICAgICAgICBuZXcgUG9wcGVyKHRvZ2dsZSwgbWVudSwge1xuICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQ6IHBvc2l0aW9uLmpvaW4oJy0nKVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYodGhpcy5xdWVyeUZvY3VzYWJsZSgpLml0ZW0oMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZWwucXVlcnlTZWxlY3RvcignaW5wdXQsIHNlbGVjdCwgdGV4dGFyZWEnKS5mb2N1cygpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ3Nob3cnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIaWRlIHRoZSBkcm9wZG93biBtZW51XG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAgICAgKi9cbiAgICAgICAgaGlkZSgpIHtcbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ3RvZ2dsZScsIHRoaXMuaXNEcm9wZG93blNob3dpbmcgPSBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCdoaWRlJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIHRoZSBgY2xpY2tgIGV2ZW50IGZvciB0aGUgYWN0aW9uIGJ1dHRvblxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgICAgICovXG4gICAgICAgIG9uQ2xpY2soZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgnY2xpY2snLCBldmVudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIHRoZSBgYmx1cmAgZXZlbnQgZm9yIHRoZSBhY3Rpb24gYnV0dG9uXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAgICAgKi9cbiAgICAgICAgb25CbHVyKGV2ZW50KSB7XG4gICAgICAgICAgICBpZighdGhpcy4kZWwuY29udGFpbnMoZXZlbnQucmVsYXRlZFRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBjYWxsYmFjayBmdW5jdGlvbiBmb3IgdGhlIGBpdGVtOmNsaWNrYCBldmVudCBmb3IgdGhlIGFjdGlvbiBidXR0b25cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB2b2lkXG4gICAgICAgICAqL1xuICAgICAgICBvbk1lbnVDbGljayhldmVudCwgaXRlbSkge1xuICAgICAgICAgICAgaWYoZXZlbnQudGFyZ2V0ID09PSB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yKCcuZHJvcGRvd24tbWVudScpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGNhbGxiYWNrIGZ1bmN0aW9uIGZvciB0aGUgYGl0ZW06Y2xpY2tgIGV2ZW50IGZvciB0aGUgYWN0aW9uIGJ1dHRvblxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgICAgICovXG4gICAgICAgIG9uSXRlbUNsaWNrKGV2ZW50LCBpdGVtKSB7XG4gICAgICAgICAgICBpZighdGhpcy5pc0ZvY3VzYWJsZShldmVudC50YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2l0ZW06Y2xpY2snLCBldmVudCwgaXRlbSk7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBjb21wdXRlZDoge1xuXG4gICAgICAgIHZhcmlhbnRDbGFzc1ByZWZpeCgpIHtcbiAgICAgICAgICAgIHJldHVybiAnYnRuJyArICh0aGlzLm91dGxpbmUgPyAnLW91dGxpbmUnIDogJycpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNpemVhYmxlQ2xhc3NQcmVmaXgoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2J0bic7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWN0aW9uQ2xhc3NlcygpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgJ2J0bicsXG4gICAgICAgICAgICAgICAgcHJlZml4KHRoaXMuc2l6ZSwgJ2J0bicpLFxuICAgICAgICAgICAgICAgIHByZWZpeCh0aGlzLnZhcmlhbnQsICdidG4nKVxuICAgICAgICAgICAgXS5qb2luKCcgJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdG9nZ2xlQ2xhc3NlcygpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgJ2J0bicsXG4gICAgICAgICAgICAgICAgJ2Ryb3Bkb3duLXRvZ2dsZScsXG4gICAgICAgICAgICAgICAgdGhpcy52YXJpYW50Q2xhc3MsXG4gICAgICAgICAgICAgICAgdGhpcy5zaXplYWJsZUNsYXNzLFxuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlID8gJ2FjdGl2ZScgOiAnJyxcbiAgICAgICAgICAgICAgICB0aGlzLmJsb2NrID8gJ2J0bi1ibG9jaycgOiAnJyxcbiAgICAgICAgICAgICAgICAodGhpcy5zcGxpdCA/ICdkcm9wZG93bi10b2dnbGUtc3BsaXQnIDogJycpLFxuICAgICAgICAgICAgXS5qb2luKCcgJyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlzRHJvcGRvd25TaG93aW5nOiBmYWxzZVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBtb3VudGVkKCkge1xuICAgICAgICBlYWNoKHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ1t0eXBlPXN1Ym1pdF0sIGlucHV0LCBzZWxlY3QsIHRleHRhcmVhLCBbdGFiaW5kZXhdOm5vdChbdGFiaW5kZXg9XCItMVwiXScpLCBlbCA9PiB7XG4gICAgICAgICAgICBjb25zdCBrZXlkb3duID0gZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlnbm9yZSA9IFtcbiAgICAgICAgICAgICAgICAgICAgTEVGVF9BUlJPV19LRVlDT0RFLFxuICAgICAgICAgICAgICAgICAgICBSSUdIVF9BUlJPV19LRVlDT0RFLFxuICAgICAgICAgICAgICAgICAgICBVUF9BUlJPV19LRVlDT0RFLFxuICAgICAgICAgICAgICAgICAgICBET1dOX0FSUk9XX0tFWUNPREUsXG4gICAgICAgICAgICAgICAgICAgIFRBQl9LRVlDT0RFXG4gICAgICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgICAgIGlmKGlnbm9yZS5pbmRleE9mKGV2ZW50LmtleUNvZGUpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBpZ25vcmVCbHVyRXZlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGNvbnN0IGJsdXIgPSBldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgaWYoIWlnbm9yZUJsdXJFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWdub3JlQmx1ckV2ZW50ID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBjb25zdCBmb2N1cyA9IGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICBpZ25vcmVCbHVyRXZlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGNvbnN0IG1vdXNlZG93biA9IGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICBpZ25vcmVCbHVyRXZlbnQgPSB0cnVlO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIGJsdXIpO1xuICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCBmb2N1cyk7XG4gICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywga2V5ZG93bik7XG4gICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBtb3VzZWRvd24pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbn1cblxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgQnRuRHJvcGRvd24gZnJvbSAnLi9CdG5Ecm9wZG93bic7XG5pbXBvcnQgVnVlSW5zdGFsbGVyIGZyb20gJy4uLy4uL0hlbHBlcnMvVnVlSW5zdGFsbGVyL1Z1ZUluc3RhbGxlcic7XG5cbmNvbnN0IHBsdWdpbiA9IFZ1ZUluc3RhbGxlci51c2Uoe1xuXG4gICAgaW5zdGFsbChWdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgVnVlSW5zdGFsbGVyLmNvbXBvbmVudHMoe1xuICAgICAgICAgICAgQnRuRHJvcGRvd25cbiAgICAgICAgfSk7XG4gICAgfVxuXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgQnRuRHJvcGRvd247XG4iLCJleHBvcnQgZGVmYXVsdCB7XG5cbiAgICBtZXRob2RzOiB7XG5cbiAgICAgICAgZ2V0U2xvdChzbG90KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kc2xvdHNbc2xvdF07XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFzU2xvdChzbG90KSB7XG4gICAgICAgICAgICByZXR1cm4gISF0aGlzLiRzbG90c1tzbG90XTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYXNTbG90cyhzbG90cykge1xuICAgICAgICAgICAgZm9yKGxldCBpIGluIHNsb3RzKSB7XG4gICAgICAgICAgICAgICAgaWYoIXRoaXMuaGFzU2xvdChzbG90c1tpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGNvbXB1dGVkOiB7XG5cbiAgICAgICAgaGFzRGVmYXVsdFNsb3QoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYXNTbG90KCdkZWZhdWx0Jyk7XG4gICAgICAgIH1cblxuICAgIH1cblxufVxuIiwiPHRlbXBsYXRlPlxuXG4gICAgPGRpdiA6Y2xhc3M9XCJtZXJnZUNsYXNzZXMoY2xhc3NOYW1lLCBjb2xvcmFibGVDbGFzc2VzKVwiPlxuICAgICAgICA8c2xvdC8+XG4gICAgPC9kaXY+XG5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgSGFzU2xvdHMgZnJvbSAnLi4vLi4vTWl4aW5zL0hhc1Nsb3RzJztcbmltcG9ydCBDb2xvcmFibGUgZnJvbSAnLi4vLi4vTWl4aW5zL0NvbG9yYWJsZSc7XG5pbXBvcnQgTWVyZ2VDbGFzc2VzIGZyb20gJy4uLy4uL01peGlucy9NZXJnZUNsYXNzZXMnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAnY2FyZCcsXG5cbiAgICBtaXhpbnM6IFtcbiAgICAgICAgSGFzU2xvdHMsXG4gICAgICAgIENvbG9yYWJsZSxcbiAgICAgICAgTWVyZ2VDbGFzc2VzXG4gICAgXSxcblxuICAgIGNvbXB1dGVkOiB7XG5cbiAgICAgICAgY2xhc3NOYW1lKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJG9wdGlvbnMubmFtZVxuICAgICAgICB9XG5cbiAgICB9XG5cbn1cblxuPC9zY3JpcHQ+XG4iLCI8c2NyaXB0PlxuaW1wb3J0IENhcmQgZnJvbSAnLi9DYXJkJztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ2NhcmQtYm9keScsXG5cbiAgICBleHRlbmRzOiBDYXJkXG5cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuXG4gICAgPGJ0bi1ncm91cCBjbGFzcz1cImNhcmQtYnRuLWdyb3VwXCI+XG4gICAgICAgIDxzbG90Lz5cbiAgICA8L2J0bi1ncm91cD5cblxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBDYXJkIGZyb20gJy4vQ2FyZCc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdjYXJkLWJ0bi1ncm91cCcsXG5cbiAgICBleHRlbmRzOiBDYXJkXG5cbn1cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cInNjc3NcIj5cbkBpbXBvcnQgJy4vbm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC9zY3NzL2Z1bmN0aW9ucy5zY3NzJztcbkBpbXBvcnQgJy4vbm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC9zY3NzL3ZhcmlhYmxlcy5zY3NzJztcblxuLmNhcmQge1xuICAgIC5jYXJkLWJ0bi1ncm91cCxcbiAgICAuYnRuLWdyb3VwLmNhcmQtYnRuLWdyb3VwIHtcbiAgICAgICAgZmxleDogMTtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuXG4gICAgICAgICYgPiAuYnRuIHtcbiAgICAgICAgICAgIGZsZXg6IDE7XG4gICAgICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDA7XG5cbiAgICAgICAgICAgICY6bm90KDpsYXN0LWNoaWxkKTo6YWZ0ZXIge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICcnO1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgICAgICAgICB0b3A6IDUwJTtcbiAgICAgICAgICAgICAgICByaWdodDogMDtcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiAkZm9udC1zaXplLWJhc2U7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC01MCUpO1xuICAgICAgICAgICAgICAgIGJvcmRlci1yaWdodDogMXB4IHNvbGlkICRjYXJkLWJvcmRlci1jb2xvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbjwvc3R5bGU+XG4iLCI8dGVtcGxhdGU+XG5cbiAgICA8ZGl2IGNsYXNzPVwiY2FyZC1kZWNrXCI+XG4gICAgICAgIDxzbG90Lz5cbiAgICA8L2Rpdj5cblxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdjYXJkLWRlY2snXG5cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuXG4gICAgPGNvbXBvbmVudCA6aXM9XCJ0YWdcIiA6Y2xhc3M9XCJtZXJnZUNsYXNzZXMoY2xhc3NOYW1lLCBjb2xvcmFibGVDbGFzc2VzKVwiPlxuICAgICAgICA8c2xvdC8+XG4gICAgPC9jb21wb25lbnQ+XG5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgQ2FyZCBmcm9tICcuL0NhcmQnO1xuaW1wb3J0IE1lcmdlQ2xhc3NlcyBmcm9tICcuLi8uLi9NaXhpbnMvTWVyZ2VDbGFzc2VzJztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ2NhcmQtaGVhZGVyJyxcblxuICAgIGV4dGVuZHM6IENhcmQsXG5cbiAgICBtaXhpbnM6IFtcbiAgICAgICAgTWVyZ2VDbGFzc2VzXG4gICAgXSxcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjb21wb25lbnQncyBIVE1MIHRhZyBuYW1lXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHRhZzoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJ2g1J1xuICAgICAgICB9XG5cbiAgICB9XG5cbn1cblxuPC9zY3JpcHQ+XG4iLCI8c2NyaXB0PlxuaW1wb3J0IENhcmRIZWFkZXIgZnJvbSAnLi9DYXJkSGVhZGVyJztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ2NhcmQtZm9vdGVyJyxcblxuICAgIGV4dGVuZHM6IENhcmRIZWFkZXIsXG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY29tcG9uZW50J3MgSFRNTCB0YWcgbmFtZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICB0YWc6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdkaXYnXG4gICAgICAgIH1cblxuICAgIH1cblxufVxuXG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cblxuICAgIDxkaXYgOmNsYXNzPVwibWVyZ2VDbGFzc2VzKGNsYXNzTmFtZSlcIiBjbGFzcz1cImQtZmxleCBqdXN0aWZ5LWNvbnRlbnQtY2VudGVyIGFsaWduLWl0ZW1zLWNlbnRlclwiIDpzdHlsZT1cIntoZWlnaHQ6IHVuaXQoaGVpZ2h0KX1cIj5cbiAgICAgICAgPGRpdiB2LWlmPVwiYmFja2dyb3VuZFwiIGNsYXNzPVwiY2FyZC1pbWctYmdcIiA6c3R5bGU9XCJ7YmFja2dyb3VuZDogYmFja2dyb3VuZCA/IGB1cmwoJHt0aGlzLnNyY30pYCA6IG51bGwsIG92ZXJmbG93OiBibHVyID8gJ2hpZGRlbicgOiAnaW5oZXJpdCcsIGZpbHRlcjogYmx1ciA/IGBibHVyKCR7dW5pdChibHVyKX0pYCA6IG51bGx9XCIvPlxuICAgICAgICA8aW1nIHYtaWY9XCIhYmFja2dyb3VuZCAmJiBzcmNcIiA6c3JjPVwic3JjXCIgOmFsdD1cImFsdFwiIGNsYXNzPVwiaW1nLWZsdWlkXCIvPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiY2FyZC1pbWctY29udGVudFwiIDpjbGFzcz1cInsndGV4dC10cnVuY2F0ZSc6IHRleHRUcnVuY2F0ZX1cIj5cbiAgICAgICAgICAgIDxzbG90Lz5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgQ2FyZCBmcm9tICcuL0NhcmQnO1xuaW1wb3J0IHVuaXQgZnJvbSAnLi4vLi4vSGVscGVycy9Vbml0JztcbmltcG9ydCBNZXJnZUNsYXNzZXMgZnJvbSAnLi4vLi4vTWl4aW5zL01lcmdlQ2xhc3Nlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdjYXJkLWltZycsXG5cbiAgICBleHRlbmRzOiBDYXJkLFxuXG4gICAgbWl4aW5zOiBbXG4gICAgICAgIE1lcmdlQ2xhc3Nlc1xuICAgIF0sXG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYWx0IGF0dHJpYnV0ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBhbHQ6IFN0cmluZyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzcGxheSB0aGUgaW1hZ2UgYXMgYSBiYWNrZ3JvdW5kIGltYWdlIGZpdCB3aXRoIENTUyBjb3Zlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgYmFja2dyb3VuZDogQm9vbGVhbixcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGFtb3VudCB0byBibHVyIHRoZSBiYWNrZ3JvdW5kIGltYWdlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBibHVyOiBbTnVtYmVyLCBTdHJpbmddLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaGVpZ2h0IGF0dHJpYnV0ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBoZWlnaHQ6IFtOdW1iZXIsIFN0cmluZ10sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRydW5jYXRlIHRoZSB0ZXh0IGluIHRoZSBjb250ZW50XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHRleHRUcnVuY2F0ZTogQm9vbGVhbixcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNyYyBhdHRyaWJ1dGVcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgc3JjOiBTdHJpbmdcblxuICAgIH0sXG5cbiAgICBtZXRob2RzOiB7XG5cbiAgICAgICAgdW5pdCh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuaXQodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbn1cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cInNjc3NcIj5cbi5jYXJkLWltZyxcbi5jYXJkLWltZy10b3AsXG4uY2FyZC1pbWctYm90dG9tIHtcbiAgICBjb2xvcjogd2hpdGU7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIHRleHQtc2hhZG93OiAwIDAgMjBweCByZ2JhKDAsIDAsIDAsIC41KTtcblxuICAgIC5jYXJkLWltZy1iZyB7XG4gICAgICAgIHotaW5kZXg6IDA7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgdG9wOiAwO1xuICAgICAgICBsZWZ0OiAwO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICBiYWNrZ3JvdW5kLXNpemU6IGNvdmVyICFpbXBvcnRhbnQ7XG4gICAgICAgIGJhY2tncm91bmQtcG9zaXRpb246IGNlbnRlciAhaW1wb3J0YW50O1xuICAgICAgICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0ICFpbXBvcnRhbnQ7XG5cbiAgICAgICAgJiA+IGltZzpmaXJzdC1jaGlsZCB7XG4gICAgICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAuY2FyZC1pbWctY29udGVudCB7XG4gICAgICAgIGZsZXg6IDE7XG4gICAgICAgIHotaW5kZXg6IDE7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICB9XG5cbiAgICAvKlxuICAgICYgPiA6bm90KGltZykge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgfVxuICAgICovXG59XG48L3N0eWxlPlxuIiwiPHNjcmlwdD5cbmltcG9ydCBDYXJkSW1nIGZyb20gJy4vQ2FyZEltZyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdjYXJkLWltZy10b3AnLFxuXG4gICAgZXh0ZW5kczogQ2FyZEltZ1xufVxuXG48L3NjcmlwdD5cbiIsIjxzY3JpcHQ+XG5pbXBvcnQgQ2FyZEltZyBmcm9tICcuL0NhcmRJbWcnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAnY2FyZC1pbWctYm90dG9tJyxcblxuICAgIGV4dGVuZHM6IENhcmRJbWdcblxufVxuPC9zY3JpcHQ+XG4iLCI8c2NyaXB0PlxuaW1wb3J0IENhcmQgZnJvbSAnLi9DYXJkJztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ2NhcmQtaW1nLW92ZXJsYXknLFxuXG4gICAgZXh0ZW5kczogQ2FyZFxuXG59XG5cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuXG4gICAgPHJvdXRlci1saW5rIDp0bz1cImhyZWZcIiA6Y2xhc3M9XCJtZXJnZUNsYXNzZXMoY2xhc3NOYW1lLCBjb2xvcmFibGVDbGFzc2VzKVwiIEBjbGljaz1cIm9uQ2xpY2tcIj5cbiAgICAgICAgPHNsb3QvPlxuICAgIDwvcm91dGVyLWxpbms+XG5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgQ2FyZCBmcm9tICcuL0NhcmQnO1xuaW1wb3J0IE1lcmdlQ2xhc3NlcyBmcm9tICcuLi8uLi9NaXhpbnMvTWVyZ2VDbGFzc2VzJztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ2NhcmQtbGluaycsXG5cbiAgICBleHRlbmRzOiBDYXJkLFxuXG4gICAgbWl4aW5zOiBbXG4gICAgICAgIE1lcmdlQ2xhc3Nlc1xuICAgIF0sXG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYWx0IGF0dHJpYnV0ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBhbHQ6IFN0cmluZyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGhyZWYgYXR0cmlidXRlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGhyZWY6IFN0cmluZyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRvIGF0dHJpYnV0ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICB0bzogW09iamVjdCwgU3RyaW5nXVxuXG4gICAgfSxcblxuICAgIG1ldGhvZHM6IHtcblxuICAgICAgICBvbkNsaWNrKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCdjbGljaycsIGV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG59XG5cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuXG4gICAgPGg2IDpjbGFzcz1cIm1lcmdlQ2xhc3NlcyhjbGFzc05hbWUsIGNvbG9yYWJsZUNsYXNzZXMpXCI+XG4gICAgICAgIDxzbG90Lz5cbiAgICA8L2g2PlxuXG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IENhcmQgZnJvbSAnLi9DYXJkJztcbmltcG9ydCBNZXJnZUNsYXNzZXMgZnJvbSAnLi4vLi4vTWl4aW5zL01lcmdlQ2xhc3Nlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdjYXJkLXN1YnRpdGxlJyxcblxuICAgIGV4dGVuZHM6IENhcmQsXG5cbiAgICBtaXhpbnM6IFtcbiAgICAgICAgTWVyZ2VDbGFzc2VzXG4gICAgXVxuXG59XG5cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuXG4gICAgPGg1IDpjbGFzcz1cIm1lcmdlQ2xhc3NlcyhjbGFzc05hbWUsIGNvbG9yYWJsZUNsYXNzZXMpXCI+XG4gICAgICAgIDxzbG90Lz5cbiAgICA8L2g1PlxuXG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IENhcmQgZnJvbSAnLi9DYXJkJztcbmltcG9ydCBNZXJnZUNsYXNzZXMgZnJvbSAnLi4vLi4vTWl4aW5zL01lcmdlQ2xhc3Nlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdjYXJkLXRpdGxlJyxcblxuICAgIG1peGluczogW1xuICAgICAgICBDYXJkLFxuICAgICAgICBNZXJnZUNsYXNzZXNcbiAgICBdXG5cbn1cblxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgQ2FyZCBmcm9tICcuL0NhcmQnO1xuaW1wb3J0IENhcmRCb2R5IGZyb20gJy4vQ2FyZEJvZHknO1xuaW1wb3J0IENhcmRCdG5Hcm91cCBmcm9tICcuL0NhcmRCdG5Hcm91cCc7XG5pbXBvcnQgQ2FyZERlY2sgZnJvbSAnLi9DYXJkRGVjayc7XG5pbXBvcnQgQ2FyZEZvb3RlciBmcm9tICcuL0NhcmRGb290ZXInO1xuaW1wb3J0IENhcmRIZWFkZXIgZnJvbSAnLi9DYXJkSGVhZGVyJztcbmltcG9ydCBDYXJkSW1nIGZyb20gJy4vQ2FyZEltZyc7XG5pbXBvcnQgQ2FyZEltZ1RvcCBmcm9tICcuL0NhcmRJbWdUb3AnO1xuaW1wb3J0IENhcmRJbWdCb3R0b20gZnJvbSAnLi9DYXJkSW1nQm90dG9tJztcbmltcG9ydCBDYXJkSW1nT3ZlcmxheSBmcm9tICcuL0NhcmRJbWdPdmVybGF5JztcbmltcG9ydCBDYXJkTGluayBmcm9tICcuL0NhcmRMaW5rJztcbmltcG9ydCBDYXJkU3VidGl0bGUgZnJvbSAnLi9DYXJkU3VidGl0bGUnO1xuaW1wb3J0IENhcmRUaXRsZSBmcm9tICcuL0NhcmRUaXRsZSc7XG5pbXBvcnQgVnVlSW5zdGFsbGVyIGZyb20gJy4uLy4uL0hlbHBlcnMvVnVlSW5zdGFsbGVyL1Z1ZUluc3RhbGxlcic7XG5cbmNvbnN0IHBsdWdpbiA9IFZ1ZUluc3RhbGxlci51c2Uoe1xuXG4gICAgaW5zdGFsbChWdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgVnVlSW5zdGFsbGVyLmNvbXBvbmVudHMoe1xuICAgICAgICAgICAgQ2FyZCxcbiAgICAgICAgICAgIENhcmRCb2R5LFxuICAgICAgICAgICAgQ2FyZEJ0bkdyb3VwLFxuICAgICAgICAgICAgQ2FyZERlY2ssXG4gICAgICAgICAgICBDYXJkRm9vdGVyLFxuICAgICAgICAgICAgQ2FyZEhlYWRlcixcbiAgICAgICAgICAgIENhcmRJbWcsXG4gICAgICAgICAgICBDYXJkSW1nVG9wLFxuICAgICAgICAgICAgQ2FyZEltZ0JvdHRvbSxcbiAgICAgICAgICAgIENhcmRJbWdPdmVybGF5LFxuICAgICAgICAgICAgQ2FyZExpbmssXG4gICAgICAgICAgICBDYXJkU3VidGl0bGUsXG4gICAgICAgICAgICBDYXJkVGl0bGVcbiAgICAgICAgfSk7XG4gICAgfVxuXG59KTtcblxuZXhwb3J0ICogZnJvbSAnLi9DYXJkQm9keSc7XG5leHBvcnQgKiBmcm9tICcuL0NhcmRCdG5Hcm91cCc7XG5leHBvcnQgKiBmcm9tICcuL0NhcmREZWNrJztcbmV4cG9ydCAqIGZyb20gJy4vQ2FyZEZvb3Rlcic7XG5leHBvcnQgKiBmcm9tICcuL0NhcmRIZWFkZXInO1xuZXhwb3J0ICogZnJvbSAnLi9DYXJkSW1nJztcbmV4cG9ydCAqIGZyb20gJy4vQ2FyZEltZ1RvcCc7XG5leHBvcnQgKiBmcm9tICcuL0NhcmRJbWdCb3R0b20nO1xuZXhwb3J0ICogZnJvbSAnLi9DYXJkSW1nT3ZlcmxheSc7XG5leHBvcnQgKiBmcm9tICcuL0NhcmRMaW5rJztcbmV4cG9ydCAqIGZyb20gJy4vQ2FyZFN1YnRpdGxlJztcbmV4cG9ydCAqIGZyb20gJy4vQ2FyZFRpdGxlJztcbmV4cG9ydCBkZWZhdWx0IENhcmQ7XG4iLCI8dGVtcGxhdGU+XG5cbiAgICA8ZGl2IDpjbGFzcz1cIm1lcmdlQ2xhc3Nlcyhjb250cm9sQ2xhc3MsIGN1c3RvbUNvbnRyb2xDbGFzcywgc2l6ZWFibGVDbGFzcywgaW5saW5lID8gaW5saW5lQ2xhc3MgOiAnJylcIj5cblxuICAgICAgICA8dGVtcGxhdGUgdi1pZj1cImN1c3RvbSAmJiBpZFwiPlxuICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgdi1iaW5kLWV2ZW50c1xuICAgICAgICAgICAgICAgIHR5cGU9XCJyYWRpb1wiXG4gICAgICAgICAgICAgICAgOm5hbWU9XCJuYW1lXCJcbiAgICAgICAgICAgICAgICA6aWQ9XCJpZFwiXG4gICAgICAgICAgICAgICAgOnZhbHVlPVwidmFsdWVcIlxuICAgICAgICAgICAgICAgIDpyZXF1aXJlZD1cInJlcXVpcmVkXCJcbiAgICAgICAgICAgICAgICA6ZGlzYWJsZWQ9XCJkaXNhYmxlZCB8fCByZWFkb25seVwiXG4gICAgICAgICAgICAgICAgOnJlYWRvbmx5PVwicmVhZG9ubHlcIlxuICAgICAgICAgICAgICAgIDpwYXR0ZXJuPVwicGF0dGVyblwiXG4gICAgICAgICAgICAgICAgOmNoZWNrZWQ9XCJjaGVja2VkVmFsdWUgPT09IHZhbHVlIHx8IGNoZWNrZWRcIlxuICAgICAgICAgICAgICAgIDpjbGFzcz1cIm1lcmdlQ2xhc3NlcyhpbnB1dENsYXNzLCAoaW52YWxpZEZlZWRiYWNrID8gJ2lzLWludmFsaWQnIDogJycpKVwiXG4gICAgICAgICAgICAgICAgQGNoYW5nZT1cIiRlbWl0KCdjaGFuZ2UnLCAkZXZlbnQudGFyZ2V0LnZhbHVlKVwiPlxuXG4gICAgICAgICAgICA8bGFiZWwgOmZvcj1cImlkXCIgOmNsYXNzPVwibWVyZ2VDbGFzc2VzKGxhYmVsQ2xhc3MsIGNvbG9yYWJsZUNsYXNzZXMpXCI+XG4gICAgICAgICAgICAgICAgPHNsb3Q+e3tsYWJlbH19PC9zbG90PlxuICAgICAgICAgICAgICAgIDxzbG90IG5hbWU9XCJmZWVkYmFja1wiPlxuICAgICAgICAgICAgICAgICAgICA8Zm9ybS1mZWVkYmFjayB2LWlmPVwidmFsaWRGZWVkYmFja1wiIHYtaHRtbD1cInZhbGlkRmVlZGJhY2tcIiB2YWxpZCAvPlxuICAgICAgICAgICAgICAgICAgICA8Zm9ybS1mZWVkYmFjayB2LWlmPVwiaW52YWxpZEZlZWRiYWNrXCIgdi1odG1sPVwiaW52YWxpZEZlZWRiYWNrXCIgaW52YWxpZCAvPlxuICAgICAgICAgICAgICAgIDwvc2xvdD5cbiAgICAgICAgICAgIDwvbGFiZWw+XG5cbiAgICAgICAgPC90ZW1wbGF0ZT5cbiAgICAgICAgPHRlbXBsYXRlIHYtZWxzZT5cbiAgICAgICAgICAgIDxsYWJlbCA6Zm9yPVwiaWRcIiA6Y2xhc3M9XCJtZXJnZUNsYXNzZXMobGFiZWxDbGFzcywgY29sb3JhYmxlQ2xhc3NlcylcIj5cbiAgICAgICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICAgICAgdi1iaW5kLWV2ZW50c1xuICAgICAgICAgICAgICAgICAgICB0eXBlPVwicmFkaW9cIlxuICAgICAgICAgICAgICAgICAgICA6bmFtZT1cIm5hbWVcIlxuICAgICAgICAgICAgICAgICAgICA6aWQ9XCJpZFwiXG4gICAgICAgICAgICAgICAgICAgIDp2YWx1ZT1cInZhbHVlXCJcbiAgICAgICAgICAgICAgICAgICAgOnJlcXVpcmVkPVwicmVxdWlyZWRcIlxuICAgICAgICAgICAgICAgICAgICA6ZGlzYWJsZWQ9XCJkaXNhYmxlZCB8fCByZWFkb25seVwiXG4gICAgICAgICAgICAgICAgICAgIDpyZWFkb25seT1cInJlYWRvbmx5XCJcbiAgICAgICAgICAgICAgICAgICAgOnBhdHRlcm49XCJwYXR0ZXJuXCJcbiAgICAgICAgICAgICAgICAgICAgOmNoZWNrZWQ9XCJjaGVja2VkVmFsdWUgPT09IHZhbHVlIHx8IGNoZWNrZWRcIlxuICAgICAgICAgICAgICAgICAgICA6Y2xhc3M9XCJtZXJnZUNsYXNzZXMoaW5wdXRDbGFzcywgKGludmFsaWRGZWVkYmFjayA/ICdpcy1pbnZhbGlkJyA6ICcnKSlcIlxuICAgICAgICAgICAgICAgICAgICBAY2hhbmdlPVwiJGVtaXQoJ2NoYW5nZScsICRldmVudC50YXJnZXQudmFsdWUpXCI+XG5cbiAgICAgICAgICAgICAgICA8c2xvdD57e2xhYmVsfX08L3Nsb3Q+XG5cbiAgICAgICAgICAgICAgICA8c2xvdCBuYW1lPVwiZmVlZGJhY2tcIj5cbiAgICAgICAgICAgICAgICAgICAgPGZvcm0tZmVlZGJhY2sgdi1pZj1cInZhbGlkRmVlZGJhY2tcIiB2LWh0bWw9XCJ2YWxpZEZlZWRiYWNrXCIgdmFsaWQgLz5cbiAgICAgICAgICAgICAgICAgICAgPGZvcm0tZmVlZGJhY2sgdi1pZj1cImludmFsaWRGZWVkYmFja1wiIHYtaHRtbD1cImludmFsaWRGZWVkYmFja1wiIGludmFsaWQgLz5cbiAgICAgICAgICAgICAgICA8L3Nsb3Q+XG4gICAgICAgICAgICA8L2xhYmVsPlxuICAgICAgICA8L3RlbXBsYXRlPlxuXG4gICAgICAgIDxzbG90IG5hbWU9XCJoZWxwXCI+XG4gICAgICAgICAgICA8aGVscC10ZXh0IHYtaWY9XCJoZWxwVGV4dFwiIHYtaHRtbD1cImhlbHBUZXh0XCIgLz5cbiAgICAgICAgPC9zbG90PlxuICAgIDwvZGl2PlxuXG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IEhlbHBUZXh0IGZyb20gJy4uL0hlbHBUZXh0JztcbmltcG9ydCBGb3JtRmVlZGJhY2sgZnJvbSAnLi4vRm9ybUZlZWRiYWNrJztcbmltcG9ydCBwcmVmaXggZnJvbSAnLi4vLi4vSGVscGVycy9QcmVmaXgnO1xuaW1wb3J0IENvbG9yYWJsZSBmcm9tICcuLi8uLi9NaXhpbnMvQ29sb3JhYmxlJztcbmltcG9ydCBGb3JtQ29udHJvbCBmcm9tICcuLi8uLi9NaXhpbnMvRm9ybUNvbnRyb2wnO1xuaW1wb3J0IE1lcmdlQ2xhc3NlcyBmcm9tICcuLi8uLi9NaXhpbnMvTWVyZ2VDbGFzc2VzJztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ3JhZGlvLWZpZWxkJyxcblxuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgICAgSGVscFRleHQsXG4gICAgICAgIEZvcm1GZWVkYmFja1xuICAgIH0sXG5cbiAgICBtaXhpbnM6IFtcbiAgICAgICAgQ29sb3JhYmxlLFxuICAgICAgICBGb3JtQ29udHJvbCxcbiAgICAgICAgTWVyZ2VDbGFzc2VzXG4gICAgXSxcblxuICAgIG1vZGVsOiB7XG4gICAgICAgIGV2ZW50OiAnY2hhbmdlJyxcbiAgICAgICAgcHJvcDogJ2NoZWNrZWRWYWx1ZSdcbiAgICB9LFxuXG4gICAgcHJvcHM6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gYXJyYXkgb2YgZXZlbnQgbmFtZXMgdGhhdCBjb3JyZWxhdGUgd2l0aCBjYWxsYmFjayBmdW5jdGlvbnNcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IEZ1bmN0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBiaW5kRXZlbnRzOiB7XG4gICAgICAgICAgICB0eXBlOiBBcnJheSxcbiAgICAgICAgICAgIGRlZmF1bHQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsnZm9jdXMnLCAnYmx1cicsICdpbnB1dCcsICdjbGljaycsICdrZXl1cCcsICdrZXlkb3duJywgJ3Byb2dyZXNzJ107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElzIHRoaXMgYSBjdXN0b20gZWxlbWVudFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBjdXN0b206IEJvb2xlYW4sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc3BsYXkgdGhlIGZvcm0gZmllbGQgYW5kIGxhYmVsIGlubGluZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgRnVuY3Rpb25cbiAgICAgICAgICovXG4gICAgICAgIGlubGluZTogQm9vbGVhbixcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNoZWNrZWQgdmFsdWVzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGNoZWNrZWQ6IEJvb2xlYW4sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjaGVja2VkIHZhbHVlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGNoZWNrZWRWYWx1ZTogW0Jvb2xlYW4sIE51bWJlciwgU3RyaW5nLCBPYmplY3RdLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY2xhc3MgbmFtZSBhc3NpZ25lZCB0byB0aGUgY29udHJvbCBlbGVtZW50XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGRlZmF1bHRDb250cm9sQ2xhc3M6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdmb3JtLWNoZWNrJ1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgY29tcHV0ZWQ6IHtcblxuICAgICAgICBsYWJlbENsYXNzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHByZWZpeCgnbGFiZWwnLCB0aGlzLmNvbnRyb2xDbGFzcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaW5wdXRDbGFzcygpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmVmaXgoJ2lucHV0JywgdGhpcy5jb250cm9sQ2xhc3MpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGlubGluZUNsYXNzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHByZWZpeCgnaW5saW5lJywgdGhpcy5jb250cm9sQ2xhc3MpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNvbnRyb2xDbGFzcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmN1c3RvbSA/ICdjdXN0b20tY29udHJvbCcgOiB0aGlzLmRlZmF1bHRDb250cm9sQ2xhc3M7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3VzdG9tQ29udHJvbENsYXNzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3VzdG9tID8gcHJlZml4KHRoaXMuJG9wdGlvbnMubmFtZS5yZXBsYWNlKCctZmllbGQnLCAnJyksICdjdXN0b20nKSA6ICcnO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNpemVhYmxlQ2xhc3MoKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJlZml4KHRoaXMuc2l6ZSwgJ2Zvcm0tY29udHJvbCcpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbn1cblxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgUmFkaW9GaWVsZCBmcm9tICcuL1JhZGlvRmllbGQnO1xuaW1wb3J0IFZ1ZUluc3RhbGxlciBmcm9tICcuLi8uLi9IZWxwZXJzL1Z1ZUluc3RhbGxlci9WdWVJbnN0YWxsZXInO1xuXG5jb25zdCBwbHVnaW4gPSBWdWVJbnN0YWxsZXIudXNlKHtcblxuICAgIGluc3RhbGwoVnVlLCBvcHRpb25zKSB7XG4gICAgICAgIFZ1ZUluc3RhbGxlci5jb21wb25lbnRzKHtcbiAgICAgICAgICAgIFJhZGlvRmllbGRcbiAgICAgICAgfSk7XG4gICAgfVxuXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgUmFkaW9GaWVsZDtcbiIsIjx0ZW1wbGF0ZT5cblxuICAgIDxkaXYgOmNsYXNzPVwibWVyZ2VDbGFzc2VzKGNvbnRyb2xDbGFzcywgY3VzdG9tQ29udHJvbENsYXNzLCBzaXplYWJsZUNsYXNzLCBpbmxpbmUgPyBpbmxpbmVDbGFzcyA6ICcnKVwiPlxuXG4gICAgICAgIDx0ZW1wbGF0ZSB2LWlmPVwiY3VzdG9tICYmIGlkXCI+XG4gICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICB2LWJpbmQtZXZlbnRzXG4gICAgICAgICAgICAgICAgdHlwZT1cImNoZWNrYm94XCJcbiAgICAgICAgICAgICAgICA6bmFtZT1cIm5hbWVcIlxuICAgICAgICAgICAgICAgIDppZD1cImlkXCJcbiAgICAgICAgICAgICAgICA6dmFsdWU9XCJ2YWx1ZVwiXG4gICAgICAgICAgICAgICAgOnJlcXVpcmVkPVwicmVxdWlyZWRcIlxuICAgICAgICAgICAgICAgIDpkaXNhYmxlZD1cImRpc2FibGVkIHx8IHJlYWRvbmx5XCJcbiAgICAgICAgICAgICAgICA6cmVhZG9ubHk9XCJyZWFkb25seVwiXG4gICAgICAgICAgICAgICAgOnBhdHRlcm49XCJwYXR0ZXJuXCJcbiAgICAgICAgICAgICAgICA6Y2hlY2tlZD1cImNoZWNrZWRWYWx1ZXMuaW5kZXhPZih2YWx1ZSkgIT09IC0xIHx8IGNoZWNrZWRcIlxuICAgICAgICAgICAgICAgIDpjbGFzcz1cIm1lcmdlQ2xhc3NlcyhpbnB1dENsYXNzLCAoaW52YWxpZEZlZWRiYWNrID8gJ2lzLWludmFsaWQnIDogJycpKVwiXG4gICAgICAgICAgICAgICAgQGNoYW5nZT1cInVwZGF0ZSgkZXZlbnQudGFyZ2V0LnZhbHVlKVwiPlxuXG4gICAgICAgICAgICA8bGFiZWwgOmZvcj1cImlkXCIgOmNsYXNzPVwibWVyZ2VDbGFzc2VzKGxhYmVsQ2xhc3MsIGNvbG9yYWJsZUNsYXNzZXMpXCI+XG4gICAgICAgICAgICAgICAgPHNsb3Q+e3tsYWJlbH19PC9zbG90PlxuICAgICAgICAgICAgICAgIDxzbG90IG5hbWU9XCJmZWVkYmFja1wiPlxuICAgICAgICAgICAgICAgICAgICA8Zm9ybS1mZWVkYmFjayB2LWlmPVwidmFsaWRGZWVkYmFja1wiIHYtaHRtbD1cInZhbGlkRmVlZGJhY2tcIiB2YWxpZCAvPlxuICAgICAgICAgICAgICAgICAgICA8Zm9ybS1mZWVkYmFjayB2LWlmPVwiaW52YWxpZEZlZWRiYWNrXCIgdi1odG1sPVwiaW52YWxpZEZlZWRiYWNrXCIgaW52YWxpZCAvPlxuICAgICAgICAgICAgICAgIDwvc2xvdD5cbiAgICAgICAgICAgIDwvbGFiZWw+XG5cbiAgICAgICAgPC90ZW1wbGF0ZT5cblxuICAgICAgICA8dGVtcGxhdGUgdi1lbHNlPlxuICAgICAgICAgICAgPGxhYmVsIDpmb3I9XCJpZFwiIDpjbGFzcz1cIm1lcmdlQ2xhc3NlcyhsYWJlbENsYXNzLCBjb2xvcmFibGVDbGFzc2VzKVwiPlxuICAgICAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgICAgICB2LWJpbmQtZXZlbnRzXG4gICAgICAgICAgICAgICAgICAgIHR5cGU9XCJjaGVja2JveFwiXG4gICAgICAgICAgICAgICAgICAgIDpuYW1lPVwibmFtZVwiXG4gICAgICAgICAgICAgICAgICAgIDppZD1cImlkXCJcbiAgICAgICAgICAgICAgICAgICAgOnZhbHVlPVwidmFsdWVcIlxuICAgICAgICAgICAgICAgICAgICA6cmVxdWlyZWQ9XCJyZXF1aXJlZFwiXG4gICAgICAgICAgICAgICAgICAgIDpkaXNhYmxlZD1cImRpc2FibGVkIHx8IHJlYWRvbmx5XCJcbiAgICAgICAgICAgICAgICAgICAgOnJlYWRvbmx5PVwicmVhZG9ubHlcIlxuICAgICAgICAgICAgICAgICAgICA6cGF0dGVybj1cInBhdHRlcm5cIlxuICAgICAgICAgICAgICAgICAgICA6Y2hlY2tlZD1cImNoZWNrZWRWYWx1ZXMuaW5kZXhPZih2YWx1ZSkgIT09IC0xIHx8IGNoZWNrZWRcIlxuICAgICAgICAgICAgICAgICAgICA6Y2xhc3M9XCJtZXJnZUNsYXNzZXMoaW5wdXRDbGFzcywgKGludmFsaWRGZWVkYmFjayA/ICdpcy1pbnZhbGlkJyA6ICcnKSlcIlxuICAgICAgICAgICAgICAgICAgICBAY2hhbmdlPVwidXBkYXRlKCRldmVudC50YXJnZXQudmFsdWUpXCI+XG5cbiAgICAgICAgICAgICAgICA8c2xvdD57e2xhYmVsfX08L3Nsb3Q+XG5cbiAgICAgICAgICAgICAgICA8c2xvdCBuYW1lPVwiZmVlZGJhY2tcIj5cbiAgICAgICAgICAgICAgICAgICAgPGZvcm0tZmVlZGJhY2sgdi1pZj1cInZhbGlkRmVlZGJhY2tcIiB2LWh0bWw9XCJ2YWxpZEZlZWRiYWNrXCIgdmFsaWQgLz5cbiAgICAgICAgICAgICAgICAgICAgPGZvcm0tZmVlZGJhY2sgdi1pZj1cImludmFsaWRGZWVkYmFja1wiIHYtaHRtbD1cImludmFsaWRGZWVkYmFja1wiIGludmFsaWQgLz5cbiAgICAgICAgICAgICAgICA8L3Nsb3Q+XG4gICAgICAgICAgICA8L2xhYmVsPlxuICAgICAgICA8L3RlbXBsYXRlPlxuXG4gICAgICAgIDxzbG90IG5hbWU9XCJoZWxwXCI+XG4gICAgICAgICAgICA8aGVscC10ZXh0IHYtaWY9XCJoZWxwVGV4dFwiIHYtaHRtbD1cImhlbHBUZXh0XCIgLz5cbiAgICAgICAgPC9zbG90PlxuICAgIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cblxuaW1wb3J0IFJhZGlvRmllbGQgZnJvbSAnLi4vUmFkaW9GaWVsZCc7XG5pbXBvcnQgTWVyZ2VDbGFzc2VzIGZyb20gJy4uLy4uL01peGlucy9NZXJnZUNsYXNzZXMnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAnY2hlY2tib3gtZmllbGQnLFxuXG4gICAgZXh0ZW5kczogUmFkaW9GaWVsZCxcblxuICAgIG1peGluczogW1xuICAgICAgICBNZXJnZUNsYXNzZXNcbiAgICBdLFxuXG4gICAgbW9kZWw6IHtcbiAgICAgICAgZXZlbnQ6ICdjaGFuZ2UnLFxuICAgICAgICBwcm9wOiAnY2hlY2tlZFZhbHVlcydcbiAgICB9LFxuXG4gICAgcHJvcHM6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNoZWNrZWQgdmFsdWVzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGNoZWNrZWRWYWx1ZXM6IHtcbiAgICAgICAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgICAgICAgZGVmYXVsdCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBtZXRob2RzOiB7XG5cbiAgICAgICAgdXBkYXRlKHZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCBjaGVja2VkID0gdGhpcy5jaGVja2VkVmFsdWVzLnNsaWNlKDApO1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmNoZWNrZWRWYWx1ZXMuaW5kZXhPZih2YWx1ZSk7XG5cbiAgICAgICAgICAgIGlmKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGNoZWNrZWQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaGVja2VkLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScsIGNoZWNrZWQpO1xuICAgICAgICB9XG5cbiAgICB9XG59XG5cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IENoZWNrYm94RmllbGQgZnJvbSAnLi9DaGVja2JveEZpZWxkJztcbmltcG9ydCBWdWVJbnN0YWxsZXIgZnJvbSAnLi4vLi4vSGVscGVycy9WdWVJbnN0YWxsZXIvVnVlSW5zdGFsbGVyJztcblxuY29uc3QgcGx1Z2luID0gVnVlSW5zdGFsbGVyLnVzZSh7XG5cbiAgICBpbnN0YWxsKFZ1ZSwgb3B0aW9ucykge1xuICAgICAgICBWdWVJbnN0YWxsZXIuY29tcG9uZW50cyh7XG4gICAgICAgICAgICBDaGVja2JveEZpZWxkXG4gICAgICAgIH0pO1xuICAgIH1cblxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IENoZWNrYm94RmllbGQ7XG4iLCI8dGVtcGxhdGU+XG5cbiAgICA8ZGl2IGNsYXNzPVwiZHJvcHpvbmVcIiA6Y2xhc3M9XCJ7J2lzLWRyYWdnaW5nJzogaXNEcmFnZ2luZ31cIiBAZHJvcC5wcmV2ZW50PVwib25Ecm9wXCIgQGRyYWdvdmVyLnByZXZlbnQ9XCJvbkRyYWdvdmVyXCIgQGRyYWdlbnRlci5wcmV2ZW50PVwib25EcmFnZW50ZXJcIiBAZHJhZ2xlYXZlLnByZXZlbnQ9XCJvbkRyYWdsZWF2ZVwiPlxuICAgICAgICA8c2xvdCBuYW1lPVwicGxhY2Vob2xkZXJcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJkcm9wem9uZS1wbGFjZWhvbGRlciB0ZXh0LWNlbnRlclwiPlxuICAgICAgICAgICAgICAgIDxjYXJkPlxuICAgICAgICAgICAgICAgICAgICA8Y2FyZC1ib2R5PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGgxIGNsYXNzPVwibXQtNFwiPkRyYWcgJiBEcm9wPC9oMT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxwPkRyYWcgYW5kIGRyb3AgeW91ciBmaWxlcyBoZXJlIHRvIHVwbG9hZCB0aGVtITwvcD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtdC0zXCI+PGkgY2xhc3M9XCJmYSBmYS1pbWFnZVwiLz48L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC9jYXJkLWJvZHk+XG4gICAgICAgICAgICAgICAgPC9jYXJkPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvc2xvdD5cbiAgICAgICAgPHNsb3QvPlxuICAgIDwvZGl2PlxuXG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IENhcmQgZnJvbSAnLi4vQ2FyZCc7XG5pbXBvcnQgQ2FyZEJvZHkgZnJvbSAnLi4vQ2FyZC9DYXJkQm9keSc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdkcm9wem9uZScsXG5cbiAgICBjb21wb25lbnRzOiB7XG4gICAgICAgIENhcmQsXG4gICAgICAgIENhcmRCb2R5XG4gICAgfSxcblxuICAgIG1ldGhvZHM6IHtcblxuICAgICAgICBvbkRyb3AoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgnZHJvcCcsIGV2ZW50KTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbkRyYWdvdmVyKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgnZHJhZ292ZXInLCBldmVudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25EcmFnZW50ZXIoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCdkcmFnZW50ZXInLCBldmVudCk7XG4gICAgICAgICAgICB0aGlzLm9uRHJhZ292ZXIoZXZlbnQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uRHJhZ2xlYXZlKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2RyYWdsZWF2ZScsIGV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmaWxlczogbnVsbCxcbiAgICAgICAgICAgIGlzRHJhZ2dpbmc6IGZhbHNlXG4gICAgICAgIH1cbiAgICB9XG5cbn1cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cInNjc3NcIj5cbi5kcm9wem9uZSB7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuXG4gICAgcCB7XG4gICAgICAgIGZvbnQtc2l6ZTogMThweDtcbiAgICB9XG5cbiAgICAuZmEtaW1hZ2Uge1xuICAgICAgICBmb250LXNpemU6IDEwMHB4O1xuICAgIH1cblxuICAgIC5kcm9wem9uZS1wbGFjZWhvbGRlciB7XG4gICAgICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgdG9wOiAwO1xuICAgICAgICBsZWZ0OiAwO1xuICAgICAgICB6LWluZGV4OiAyO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICBiYWNrZ3JvdW5kOiB3aGl0ZTtcbiAgICB9XG5cbiAgICAmLmlzLWRyYWdnaW5nIC5kcm9wem9uZS1wbGFjZWhvbGRlciB7XG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgIH1cbn1cbjwvc3R5bGU+XG4iLCJpbXBvcnQgRHJvcHpvbmUgZnJvbSAnLi9Ecm9wem9uZSc7XG5pbXBvcnQgVnVlSW5zdGFsbGVyIGZyb20gJy4uLy4uL0hlbHBlcnMvVnVlSW5zdGFsbGVyL1Z1ZUluc3RhbGxlcic7XG5cbmNvbnN0IHBsdWdpbiA9IFZ1ZUluc3RhbGxlci51c2Uoe1xuXG4gICAgaW5zdGFsbChWdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgVnVlSW5zdGFsbGVyLmNvbXBvbmVudHMoe1xuICAgICAgICAgICAgRHJvcHpvbmVcbiAgICAgICAgfSk7XG4gICAgfVxuXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgRHJvcHpvbmU7XG4iLCJpbXBvcnQgeyBpc0Z1bmN0aW9uIH0gZnJvbSAnbG9kYXNoLWVzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmVhZEZpbGUoZmlsZSwgcHJvZ3Jlc3MpIHtcbiAgICBpZighKGZpbGUgaW5zdGFuY2VvZiBGaWxlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBmaXJzdCBhcmd1bWVudCBiZSBhbiBpbnN0YW5jZSBvZiBGaWxlIG9iamVjdC4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcjtcblxuICAgICAgICBpZihpc0Z1bmN0aW9uKHByb2dyZXNzKSkge1xuICAgICAgICAgICAgcmVhZGVyLm9ucHJvZ3Jlc3MgPSBlID0+IHByb2dyZXNzKGUsIHJlYWRlcik7XG4gICAgICAgIH1cblxuICAgICAgICByZWFkZXIub25sb2FkID0gZSA9PiByZXNvbHZlKGUpO1xuICAgICAgICByZWFkZXIub25lcnJvciA9IGUgPT4gcmVqZWN0KGUpO1xuICAgICAgICByZWFkZXIub25hYm9ydCA9IGUgPT4gcmVqZWN0KGUpO1xuICAgICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChmaWxlKTtcbiAgICB9KTtcbn1cbiIsIjx0ZW1wbGF0ZT5cblxuICAgIDxkaXYgY2xhc3M9XCJmaWxlLXByZXZpZXdcIiA6Y2xhc3M9XCJ7J2hhcy1pbWFnZSc6ICEhaW1hZ2V9XCI+XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cImZpbGUtcHJldmlldy1pbm5lclwiPlxuXG4gICAgICAgICAgICA8YSB2LWlmPVwiIWhpZGVDbG9zZVwiIGhyZWY9XCIjXCIgY2xhc3M9XCJmaWxlLXByZXZpZXctY2xvc2VcIiBAY2xpY2sucHJldmVudD1cIiRlbWl0KCdjbG9zZScsIGZpbGUpXCI+XG4gICAgICAgICAgICAgICAgPGkgY2xhc3M9XCJmYSBmYS10aW1lcy1jaXJjbGVcIj48L2k+XG4gICAgICAgICAgICA8L2E+XG5cbiAgICAgICAgICAgIDxkaXYgdi1pZj1cIiEhcG9zdGVyIHx8IGlzSW1hZ2VcIiBjbGFzcz1cImZpbGUtcHJldmlldy1pbWFnZVwiPlxuICAgICAgICAgICAgICAgIDxpbWcgdi1pZj1cIiEhcG9zdGVyIHx8ICEhaW1hZ2VcIiA6c3JjPVwicG9zdGVyIHx8IGltYWdlXCIgY2xhc3M9XCJmaWxlLXByZXZpZXctdGh1bWJuYWlsXCIgQGxvYWQ9XCJvbkxvYWRcIi8+XG4gICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgPGRpdiB2LWVsc2Ugdi1yZWFkeT1cIigpID0+IHRoaXMuJGVtaXQoJ2xvYWRlZCcpXCIgY2xhc3M9XCJmaWxlLXByZXZpZXctaWNvblwiPlxuICAgICAgICAgICAgICAgIDxpIGNsYXNzPVwiZmFcIiA6Y2xhc3M9XCJ7J2ZhLWZpbGUtdmlkZW8tbyc6IGlzVmlkZW8sICdmYS1maWxlLW8nOiAhaXNWaWRlb31cIj48L2k+XG4gICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgPHByb2dyZXNzLWJhclxuICAgICAgICAgICAgICAgIHYtaWY9XCJwcm9ncmVzcyB8fCBpc0ltYWdlICYmIGxvYWRlZCAhPT0gZmFsc2VcIlxuICAgICAgICAgICAgICAgIHYtcmVhZHk9XCJyZWFkRmlsZVwiXG4gICAgICAgICAgICAgICAgOnZhbHVlPVwicHJvZ3Jlc3MgfHwgbG9hZGVkIHx8IDBcIlxuICAgICAgICAgICAgICAgIDpoZWlnaHQ9XCIxMFwiXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJtdC0zXCIvPlxuXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZmlsZS1wcmV2aWV3LWZpbGVuYW1lXCIgdi1odG1sPVwibmFtZVwiPjwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZpbGUtcHJldmlldy1maWxlc2l6ZVwiPih7e3NpemV9fSk8L2Rpdj5cbiAgICAgICAgPGRpdj5cblxuICAgIDwvZGl2PlxuXG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IG1vbWVudCBmcm9tICdtb21lbnQnO1xuaW1wb3J0IHsgaXNGdW5jdGlvbiB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgcmVhZEZpbGUgZnJvbSAnLi4vLi4vSGVscGVycy9SZWFkRmlsZS9SZWFkRmlsZSc7XG5pbXBvcnQgUHJvZ3Jlc3NCYXIgZnJvbSAnLi4vUHJvZ3Jlc3NCYXInO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAnZmlsZS1wcmV2aWV3JyxcblxuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgICAgUHJvZ3Jlc3NCYXJcbiAgICB9LFxuXG4gICAgZGlyZWN0aXZlczoge1xuICAgICAgICByZWFkeToge1xuICAgICAgICAgICAgaW5zZXJ0ZWQoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgICAgICAgICAgICAgaWYoaXNGdW5jdGlvbihiaW5kaW5nLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB2bm9kZS5jb250ZXh0LiRuZXh0VGljayhiaW5kaW5nLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcHJvcHM6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSGlkZSB0aGUgY2xvc2UgYnV0dG9uIGZvciB0aGUgcHJldmlld1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgT2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBoaWRlQ2xvc2U6IEJvb2xlYW4sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB1cGxvYWRlZCBGaWxlIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgT2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBmaWxlOiB7XG4gICAgICAgICAgICB0eXBlOiBbT2JqZWN0LCBGaWxlXSxcbiAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGltYWdlIFVSTCB0byBpbnN0ZWFkIG9mIHVzaW5nIHRoZSBmaWxlIHJlYWRlci5cbiAgICAgICAgICogQHByb3BlcnR5IHtTdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBwb3N0ZXI6IFN0cmluZyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZ3Jlc3MgdGhhdCBjYW4gYmUgcGFzc2VkIGZyb20gYSBwYXJlbnQgY29tcGFyZW50LCBmb3IgaW5zdGFuY2VcbiAgICAgICAgICogdXNlIHRvIHNob3cgYW4gYWpheCByZXF1ZXN0IHdpdGggYSBzaW5nbGUgcHJvZ3Jlc3MgYmFyLiBJZiBhIHByb2dyZXNzXG4gICAgICAgICAqIHZhbHVlIGlzIHBhc3NlZCwgZXZlbiBhIDAsIHRoZSBwcm9ncmVzcyBiYXIgd2lsbCBub3QgYmUgdXNlZCB0byBzaG93XG4gICAgICAgICAqIHRoZSBwcm9ncmVzcyBvZiB0aGUgZmlsZSByZWFkZXIuXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgcHJvZ3Jlc3M6IHtcbiAgICAgICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZFxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgY29tcHV0ZWQ6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBmaWxlIG5hbWVcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgbmFtZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbGUgaW5zdGFuY2VvZiBGaWxlID8gdGhpcy5maWxlLm5hbWUgOiB0aGlzLmZpbGUub3JpZ19maWxlbmFtZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBmaWxlIGV4dGVuc2lvblxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBleHRlbnNpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maWxlIGluc3RhbmNlb2YgRmlsZSA/IHRoaXMuZmlsZS5uYW1lLnNwbGl0KCcuJykucG9wKCkudG9Mb3dlckNhc2UoKSA6IHRoaXMuZmlsZS5leHRlbnNpb247XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgZmlsZSBmb3JtYXR0ZWQgc2l6ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBzaXplKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnl0ZXNUb1NpemUodGhpcy5maWxlLnNpemUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGZpbGUgdHlwZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICB0eXBlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsZSBpbnN0YW5jZW9mIEZpbGUgPyB0aGlzLmZpbGUudHlwZSA6IHRoaXMuZmlsZS5taW1lO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVjayB0byBzZWUgaWYgdGhlIGZpbGUgaXMgYW4gaW1hZ2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGlzSW1hZ2UoKSB7XG4gICAgICAgICAgICByZXR1cm4gISF0aGlzLnR5cGUubWF0Y2goL15pbWFnZS8pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVjayB0byBzZWUgaWYgdGhlIGZpbGUgaXMgYSB2aWRlby5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgaXNWaWRlbygpIHtcbiAgICAgICAgICAgIHJldHVybiAhIXRoaXMudHlwZS5tYXRjaCgvXnZpZGVvLyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgbGFzdCB0aW1lIHRoZSBmaWxlIHdhcyBtb2RpZmllZCAoYXMgdGltZXN0YW1wKVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBsYXN0TW9kaWZpZWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maWxlIGluc3RhbmNlb2YgRmlsZSA/IHRoaXMuZmlsZS5sYXN0TW9kaWZpZWQgOiBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGxhc3QgdGltZSB0aGUgZmlsZSB3YXMgbW9kaWZpZWQgKGFzIERhdGUpXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGxhc3RNb2RpZmllZERhdGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maWxlIGluc3RhbmNlb2YgRmlsZSA/IHRoaXMuZmlsZS5sYXN0TW9kaWZpZWREYXRlIDogbnVsbDtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIG1ldGhvZHM6IHtcblxuICAgICAgICByZWFkRmlsZSgpIHtcbiAgICAgICAgICAgIGlmKHRoaXMuZmlsZSBpbnN0YW5jZW9mIEZpbGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydCA9IG1vbWVudCgpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkZWQgPSAwO1xuXG4gICAgICAgICAgICAgICAgdGhpcy4kbmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZWFkRmlsZSh0aGlzLmZpbGUsIGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZS5sZW5ndGhDb21wdXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kZW1pdCgncHJvZ3Jlc3MnLCB0aGlzLmxvYWRlZCA9IHBhcnNlSW50KChlLmxvYWRlZCAvIGUudG90YWwpICogMTAwLCAxMCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ3JlYWQnLCBldmVudCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW1hZ2UgPSBldmVudC50YXJnZXQucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJG5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIDUwMCAtIG1vbWVudCgpLmRpZmYoc3RhcnQpKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgXHRieXRlc1RvU2l6ZTogZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICBcdFx0dmFyIHNpemVzID0gWydCeXRlcycsICdLQicsICdNQicsICdHQicsICdUQiddO1xuICAgIFx0XHRpZiAoYnl0ZXMgPT0gMCkgcmV0dXJuICcwIEJ5dGUnO1xuICAgIFx0XHR2YXIgaSA9IHBhcnNlSW50KE1hdGguZmxvb3IoTWF0aC5sb2coYnl0ZXMpIC8gTWF0aC5sb2coMTAyNCkpKTtcbiAgICBcdFx0cmV0dXJuIE1hdGgucm91bmQoYnl0ZXMgLyBNYXRoLnBvdygxMDI0LCBpKSwgMikgKyAnICcgKyBzaXplc1tpXTtcbiAgICBcdH0sXG5cbiAgICAgICAgb25Mb2FkKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCdsb2FkZWQnKTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbWFnZTogdGhpcy5maWxlLnVybCxcbiAgICAgICAgICAgIGxvYWRlZDogdGhpcy5maWxlIGluc3RhbmNlb2YgRmlsZSA/IDAgOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICB9XG5cbn1cblxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwic2Nzc1wiPlxuJGZpbGUtcHJldmlldy1jbG9zZS13aWR0aDogMXJlbSAqIDI7XG4kZmlsZS1wcmV2aWV3LWNsb3NlLWhlaWdodDogMXJlbSAqIDI7XG5cbi5maWxlLXByZXZpZXcge1xuICAgIHdpZHRoOiAxMDAlO1xuXG4gICAgLmZpbGUtcHJldmlldy1pbm5lciB7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICB9XG5cbiAgICAuZmlsZS1wcmV2aWV3LWNsb3NlIHtcbiAgICAgICAgdG9wOiAwO1xuICAgICAgICByaWdodDogMDtcbiAgICAgICAgcGFkZGluZzogMDtcbiAgICAgICAgd2lkdGg6IDI0cHg7XG4gICAgICAgIGhlaWdodDogMjRweDtcbiAgICAgICAgYmFja2dyb3VuZDogd2hpdGU7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogMTAwJTtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoMzMlLCAtMzMlKTtcblxuICAgICAgICBpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgICAgIHRvcDogMDtcbiAgICAgICAgICAgIGxlZnQ6IDA7XG4gICAgICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMjRweDtcbiAgICAgICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC5maWxlLXByZXZpZXctaWNvbiB7XG4gICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgZm9udC1zaXplOiA2MHB4O1xuICAgICAgICBwYWRkaW5nOiAxcmVtO1xuICAgIH1cblxuICAgIC5maWxlLXByZXZpZXctdGh1bWJuYWlsIHtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIG1heC13aWR0aDogMTAwJTtcbiAgICB9XG5cbiAgICAuZmlsZS1wcmV2aWV3LWZpbGVuYW1lIHtcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgICAgICB3aGl0ZS1zcGFjZTogbm93cmFwO1xuICAgICAgICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcbiAgICB9XG5cbiAgICAuZmlsZS1wcmV2aWV3LWZpbGVuYW1lLFxuICAgIC5maWxlLXByZXZpZXctZmlsZXNpemUge1xuICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgfVxuXG59XG5cbjwvc3R5bGU+XG4iLCJpbXBvcnQgRmlsZVByZXZpZXcgZnJvbSAnLi9GaWxlUHJldmlldyc7XG5pbXBvcnQgVnVlSW5zdGFsbGVyIGZyb20gJy4uLy4uL0hlbHBlcnMvVnVlSW5zdGFsbGVyL1Z1ZUluc3RhbGxlcic7XG5cbmNvbnN0IHBsdWdpbiA9IFZ1ZUluc3RhbGxlci51c2Uoe1xuXG4gICAgaW5zdGFsbChWdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgVnVlSW5zdGFsbGVyLmNvbXBvbmVudHMoe1xuICAgICAgICAgICAgRmlsZVByZXZpZXdcbiAgICAgICAgfSk7XG4gICAgfVxuXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgRmlsZVByZXZpZXc7XG4iLCI8dGVtcGxhdGU+XG5cbiAgICA8Y29tcG9uZW50XG4gICAgICAgIDpuYW1lPVwibmFtZVwiXG4gICAgICAgIDppZD1cImlkXCJcbiAgICAgICAgOmlzPVwiIXNlbGVjdCA/ICdpbnB1dCcgOiAnc2VsZWN0J1wiXG4gICAgICAgIDp0eXBlPVwiIXNlbGVjdCA/IHR5cGUgOiBmYWxzZVwiXG4gICAgICAgIDp2YWx1ZT1cInZhbHVlXCJcbiAgICAgICAgOnBhdHRlcm49XCJwYXR0ZXJuXCJcbiAgICAgICAgOnJlcXVpcmVkPVwicmVxdWlyZWRcIlxuICAgICAgICA6cmVhZG9ubHk9XCJyZWFkb25seVwiXG4gICAgICAgIDpwbGFjZWhvbGRlcj1cInBsYWNlaG9sZGVyXCJcbiAgICAgICAgOmRpc2FibGVkPVwiZGlzYWJsZWQgfHwgcmVhZG9ubHlcIlxuICAgICAgICA6Y2xhc3M9XCJtZXJnZUNsYXNzZXMoY29udHJvbENsYXNzZXMsIGNvbG9yYWJsZUNsYXNzZXMpXCJcbiAgICAgICAgOmFyaWEtbGFiZWw9XCJsYWJlbFwiXG4gICAgICAgIDphcmlhLWRlc2NyaWJlZGJ5PVwiaWRcIlxuICAgICAgICB2LWJpbmQtZXZlbnRzPVwiYmluZEV2ZW50c1wiLz5cblxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cblxuaW1wb3J0IENvbG9yYWJsZSBmcm9tICcuLi8uLi9NaXhpbnMvQ29sb3JhYmxlJztcbmltcG9ydCBGb3JtQ29udHJvbCBmcm9tICcuLi8uLi9NaXhpbnMvRm9ybUNvbnRyb2wnO1xuaW1wb3J0IE1lcmdlQ2xhc3NlcyBmcm9tICcuLi8uLi9NaXhpbnMvTWVyZ2VDbGFzc2VzJztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ2Zvcm0tY29udHJvbCcsXG5cbiAgICBtaXhpbnM6IFtcbiAgICAgICAgQ29sb3JhYmxlLFxuICAgICAgICBGb3JtQ29udHJvbCxcbiAgICAgICAgTWVyZ2VDbGFzc2VzXG4gICAgXSxcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElzIHRoZSBlbGVtZW50IGEgc2VsZWN0P1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBzZWxlY3Q6IEJvb2xlYW4sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0eXBlIGF0dHJpYnV0ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAndGV4dCdcbiAgICAgICAgfVxuXG4gICAgfVxuXG59XG5cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IEZvcm1Db250cm9sIGZyb20gJy4vRm9ybUNvbnRyb2wnO1xuaW1wb3J0IFZ1ZUluc3RhbGxlciBmcm9tICcuLi8uLi9IZWxwZXJzL1Z1ZUluc3RhbGxlci9WdWVJbnN0YWxsZXInO1xuXG5jb25zdCBwbHVnaW4gPSBWdWVJbnN0YWxsZXIudXNlKHtcblxuICAgIGluc3RhbGwoVnVlLCBvcHRpb25zKSB7XG4gICAgICAgIFZ1ZUluc3RhbGxlci5jb21wb25lbnRzKHtcbiAgICAgICAgICAgIEZvcm1Db250cm9sXG4gICAgICAgIH0pO1xuICAgIH1cblxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IEZvcm1Db250cm9sO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBXM0MgU09GVFdBUkUgQU5EIERPQ1VNRU5UIE5PVElDRSBBTkQgTElDRU5TRS5cbiAqXG4gKiAgaHR0cHM6Ly93d3cudzMub3JnL0NvbnNvcnRpdW0vTGVnYWwvMjAxNS9jb3B5cmlnaHQtc29mdHdhcmUtYW5kLWRvY3VtZW50XG4gKlxuICovXG5cbihmdW5jdGlvbih3aW5kb3csIGRvY3VtZW50KSB7XG4ndXNlIHN0cmljdCc7XG5cblxuLy8gRXhpdHMgZWFybHkgaWYgYWxsIEludGVyc2VjdGlvbk9ic2VydmVyIGFuZCBJbnRlcnNlY3Rpb25PYnNlcnZlckVudHJ5XG4vLyBmZWF0dXJlcyBhcmUgbmF0aXZlbHkgc3VwcG9ydGVkLlxuaWYgKCdJbnRlcnNlY3Rpb25PYnNlcnZlcicgaW4gd2luZG93ICYmXG4gICAgJ0ludGVyc2VjdGlvbk9ic2VydmVyRW50cnknIGluIHdpbmRvdyAmJlxuICAgICdpbnRlcnNlY3Rpb25SYXRpbycgaW4gd2luZG93LkludGVyc2VjdGlvbk9ic2VydmVyRW50cnkucHJvdG90eXBlKSB7XG5cbiAgLy8gTWluaW1hbCBwb2x5ZmlsbCBmb3IgRWRnZSAxNSdzIGxhY2sgb2YgYGlzSW50ZXJzZWN0aW5nYFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS93M2MvSW50ZXJzZWN0aW9uT2JzZXJ2ZXIvaXNzdWVzLzIxMVxuICBpZiAoISgnaXNJbnRlcnNlY3RpbmcnIGluIHdpbmRvdy5JbnRlcnNlY3Rpb25PYnNlcnZlckVudHJ5LnByb3RvdHlwZSkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LkludGVyc2VjdGlvbk9ic2VydmVyRW50cnkucHJvdG90eXBlLFxuICAgICAgJ2lzSW50ZXJzZWN0aW5nJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVyc2VjdGlvblJhdGlvID4gMDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm47XG59XG5cblxuLyoqXG4gKiBBbiBJbnRlcnNlY3Rpb25PYnNlcnZlciByZWdpc3RyeS4gVGhpcyByZWdpc3RyeSBleGlzdHMgdG8gaG9sZCBhIHN0cm9uZ1xuICogcmVmZXJlbmNlIHRvIEludGVyc2VjdGlvbk9ic2VydmVyIGluc3RhbmNlcyBjdXJyZW50bHkgb2JzZXJ2ZXJpbmcgYSB0YXJnZXRcbiAqIGVsZW1lbnQuIFdpdGhvdXQgdGhpcyByZWdpc3RyeSwgaW5zdGFuY2VzIHdpdGhvdXQgYW5vdGhlciByZWZlcmVuY2UgbWF5IGJlXG4gKiBnYXJiYWdlIGNvbGxlY3RlZC5cbiAqL1xudmFyIHJlZ2lzdHJ5ID0gW107XG5cblxuLyoqXG4gKiBDcmVhdGVzIHRoZSBnbG9iYWwgSW50ZXJzZWN0aW9uT2JzZXJ2ZXJFbnRyeSBjb25zdHJ1Y3Rvci5cbiAqIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9JbnRlcnNlY3Rpb25PYnNlcnZlci8jaW50ZXJzZWN0aW9uLW9ic2VydmVyLWVudHJ5XG4gKiBAcGFyYW0ge09iamVjdH0gZW50cnkgQSBkaWN0aW9uYXJ5IG9mIGluc3RhbmNlIHByb3BlcnRpZXMuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gSW50ZXJzZWN0aW9uT2JzZXJ2ZXJFbnRyeShlbnRyeSkge1xuICB0aGlzLnRpbWUgPSBlbnRyeS50aW1lO1xuICB0aGlzLnRhcmdldCA9IGVudHJ5LnRhcmdldDtcbiAgdGhpcy5yb290Qm91bmRzID0gZW50cnkucm9vdEJvdW5kcztcbiAgdGhpcy5ib3VuZGluZ0NsaWVudFJlY3QgPSBlbnRyeS5ib3VuZGluZ0NsaWVudFJlY3Q7XG4gIHRoaXMuaW50ZXJzZWN0aW9uUmVjdCA9IGVudHJ5LmludGVyc2VjdGlvblJlY3QgfHwgZ2V0RW1wdHlSZWN0KCk7XG4gIHRoaXMuaXNJbnRlcnNlY3RpbmcgPSAhIWVudHJ5LmludGVyc2VjdGlvblJlY3Q7XG5cbiAgLy8gQ2FsY3VsYXRlcyB0aGUgaW50ZXJzZWN0aW9uIHJhdGlvLlxuICB2YXIgdGFyZ2V0UmVjdCA9IHRoaXMuYm91bmRpbmdDbGllbnRSZWN0O1xuICB2YXIgdGFyZ2V0QXJlYSA9IHRhcmdldFJlY3Qud2lkdGggKiB0YXJnZXRSZWN0LmhlaWdodDtcbiAgdmFyIGludGVyc2VjdGlvblJlY3QgPSB0aGlzLmludGVyc2VjdGlvblJlY3Q7XG4gIHZhciBpbnRlcnNlY3Rpb25BcmVhID0gaW50ZXJzZWN0aW9uUmVjdC53aWR0aCAqIGludGVyc2VjdGlvblJlY3QuaGVpZ2h0O1xuXG4gIC8vIFNldHMgaW50ZXJzZWN0aW9uIHJhdGlvLlxuICBpZiAodGFyZ2V0QXJlYSkge1xuICAgIHRoaXMuaW50ZXJzZWN0aW9uUmF0aW8gPSBpbnRlcnNlY3Rpb25BcmVhIC8gdGFyZ2V0QXJlYTtcbiAgfSBlbHNlIHtcbiAgICAvLyBJZiBhcmVhIGlzIHplcm8gYW5kIGlzIGludGVyc2VjdGluZywgc2V0cyB0byAxLCBvdGhlcndpc2UgdG8gMFxuICAgIHRoaXMuaW50ZXJzZWN0aW9uUmF0aW8gPSB0aGlzLmlzSW50ZXJzZWN0aW5nID8gMSA6IDA7XG4gIH1cbn1cblxuXG4vKipcbiAqIENyZWF0ZXMgdGhlIGdsb2JhbCBJbnRlcnNlY3Rpb25PYnNlcnZlciBjb25zdHJ1Y3Rvci5cbiAqIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9JbnRlcnNlY3Rpb25PYnNlcnZlci8jaW50ZXJzZWN0aW9uLW9ic2VydmVyLWludGVyZmFjZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgYWZ0ZXIgaW50ZXJzZWN0aW9uXG4gKiAgICAgY2hhbmdlcyBoYXZlIHF1ZXVlZC4gVGhlIGZ1bmN0aW9uIGlzIG5vdCBpbnZva2VkIGlmIHRoZSBxdWV1ZSBoYXNcbiAqICAgICBiZWVuIGVtcHRpZWQgYnkgY2FsbGluZyB0aGUgYHRha2VSZWNvcmRzYCBtZXRob2QuXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdF9vcHRpb25zIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBJbnRlcnNlY3Rpb25PYnNlcnZlcihjYWxsYmFjaywgb3B0X29wdGlvbnMpIHtcblxuICB2YXIgb3B0aW9ucyA9IG9wdF9vcHRpb25zIHx8IHt9O1xuXG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcignY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICBpZiAob3B0aW9ucy5yb290ICYmIG9wdGlvbnMucm9vdC5ub2RlVHlwZSAhPSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdyb290IG11c3QgYmUgYW4gRWxlbWVudCcpO1xuICB9XG5cbiAgLy8gQmluZHMgYW5kIHRocm90dGxlcyBgdGhpcy5fY2hlY2tGb3JJbnRlcnNlY3Rpb25zYC5cbiAgdGhpcy5fY2hlY2tGb3JJbnRlcnNlY3Rpb25zID0gdGhyb3R0bGUoXG4gICAgICB0aGlzLl9jaGVja0ZvckludGVyc2VjdGlvbnMuYmluZCh0aGlzKSwgdGhpcy5USFJPVFRMRV9USU1FT1VUKTtcblxuICAvLyBQcml2YXRlIHByb3BlcnRpZXMuXG4gIHRoaXMuX2NhbGxiYWNrID0gY2FsbGJhY2s7XG4gIHRoaXMuX29ic2VydmF0aW9uVGFyZ2V0cyA9IFtdO1xuICB0aGlzLl9xdWV1ZWRFbnRyaWVzID0gW107XG4gIHRoaXMuX3Jvb3RNYXJnaW5WYWx1ZXMgPSB0aGlzLl9wYXJzZVJvb3RNYXJnaW4ob3B0aW9ucy5yb290TWFyZ2luKTtcblxuICAvLyBQdWJsaWMgcHJvcGVydGllcy5cbiAgdGhpcy50aHJlc2hvbGRzID0gdGhpcy5faW5pdFRocmVzaG9sZHMob3B0aW9ucy50aHJlc2hvbGQpO1xuICB0aGlzLnJvb3QgPSBvcHRpb25zLnJvb3QgfHwgbnVsbDtcbiAgdGhpcy5yb290TWFyZ2luID0gdGhpcy5fcm9vdE1hcmdpblZhbHVlcy5tYXAoZnVuY3Rpb24obWFyZ2luKSB7XG4gICAgcmV0dXJuIG1hcmdpbi52YWx1ZSArIG1hcmdpbi51bml0O1xuICB9KS5qb2luKCcgJyk7XG59XG5cblxuLyoqXG4gKiBUaGUgbWluaW11bSBpbnRlcnZhbCB3aXRoaW4gd2hpY2ggdGhlIGRvY3VtZW50IHdpbGwgYmUgY2hlY2tlZCBmb3JcbiAqIGludGVyc2VjdGlvbiBjaGFuZ2VzLlxuICovXG5JbnRlcnNlY3Rpb25PYnNlcnZlci5wcm90b3R5cGUuVEhST1RUTEVfVElNRU9VVCA9IDEwMDtcblxuXG4vKipcbiAqIFRoZSBmcmVxdWVuY3kgaW4gd2hpY2ggdGhlIHBvbHlmaWxsIHBvbGxzIGZvciBpbnRlcnNlY3Rpb24gY2hhbmdlcy5cbiAqIHRoaXMgY2FuIGJlIHVwZGF0ZWQgb24gYSBwZXIgaW5zdGFuY2UgYmFzaXMgYW5kIG11c3QgYmUgc2V0IHByaW9yIHRvXG4gKiBjYWxsaW5nIGBvYnNlcnZlYCBvbiB0aGUgZmlyc3QgdGFyZ2V0LlxuICovXG5JbnRlcnNlY3Rpb25PYnNlcnZlci5wcm90b3R5cGUuUE9MTF9JTlRFUlZBTCA9IG51bGw7XG5cbi8qKlxuICogVXNlIGEgbXV0YXRpb24gb2JzZXJ2ZXIgb24gdGhlIHJvb3QgZWxlbWVudFxuICogdG8gZGV0ZWN0IGludGVyc2VjdGlvbiBjaGFuZ2VzLlxuICovXG5JbnRlcnNlY3Rpb25PYnNlcnZlci5wcm90b3R5cGUuVVNFX01VVEFUSU9OX09CU0VSVkVSID0gdHJ1ZTtcblxuXG4vKipcbiAqIFN0YXJ0cyBvYnNlcnZpbmcgYSB0YXJnZXQgZWxlbWVudCBmb3IgaW50ZXJzZWN0aW9uIGNoYW5nZXMgYmFzZWQgb25cbiAqIHRoZSB0aHJlc2hvbGRzIHZhbHVlcy5cbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IFRoZSBET00gZWxlbWVudCB0byBvYnNlcnZlLlxuICovXG5JbnRlcnNlY3Rpb25PYnNlcnZlci5wcm90b3R5cGUub2JzZXJ2ZSA9IGZ1bmN0aW9uKHRhcmdldCkge1xuICB2YXIgaXNUYXJnZXRBbHJlYWR5T2JzZXJ2ZWQgPSB0aGlzLl9vYnNlcnZhdGlvblRhcmdldHMuc29tZShmdW5jdGlvbihpdGVtKSB7XG4gICAgcmV0dXJuIGl0ZW0uZWxlbWVudCA9PSB0YXJnZXQ7XG4gIH0pO1xuXG4gIGlmIChpc1RhcmdldEFscmVhZHlPYnNlcnZlZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICghKHRhcmdldCAmJiB0YXJnZXQubm9kZVR5cGUgPT0gMSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3RhcmdldCBtdXN0IGJlIGFuIEVsZW1lbnQnKTtcbiAgfVxuXG4gIHRoaXMuX3JlZ2lzdGVySW5zdGFuY2UoKTtcbiAgdGhpcy5fb2JzZXJ2YXRpb25UYXJnZXRzLnB1c2goe2VsZW1lbnQ6IHRhcmdldCwgZW50cnk6IG51bGx9KTtcbiAgdGhpcy5fbW9uaXRvckludGVyc2VjdGlvbnMoKTtcbiAgdGhpcy5fY2hlY2tGb3JJbnRlcnNlY3Rpb25zKCk7XG59O1xuXG5cbi8qKlxuICogU3RvcHMgb2JzZXJ2aW5nIGEgdGFyZ2V0IGVsZW1lbnQgZm9yIGludGVyc2VjdGlvbiBjaGFuZ2VzLlxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgVGhlIERPTSBlbGVtZW50IHRvIG9ic2VydmUuXG4gKi9cbkludGVyc2VjdGlvbk9ic2VydmVyLnByb3RvdHlwZS51bm9ic2VydmUgPSBmdW5jdGlvbih0YXJnZXQpIHtcbiAgdGhpcy5fb2JzZXJ2YXRpb25UYXJnZXRzID1cbiAgICAgIHRoaXMuX29ic2VydmF0aW9uVGFyZ2V0cy5maWx0ZXIoZnVuY3Rpb24oaXRlbSkge1xuXG4gICAgcmV0dXJuIGl0ZW0uZWxlbWVudCAhPSB0YXJnZXQ7XG4gIH0pO1xuICBpZiAoIXRoaXMuX29ic2VydmF0aW9uVGFyZ2V0cy5sZW5ndGgpIHtcbiAgICB0aGlzLl91bm1vbml0b3JJbnRlcnNlY3Rpb25zKCk7XG4gICAgdGhpcy5fdW5yZWdpc3Rlckluc3RhbmNlKCk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBTdG9wcyBvYnNlcnZpbmcgYWxsIHRhcmdldCBlbGVtZW50cyBmb3IgaW50ZXJzZWN0aW9uIGNoYW5nZXMuXG4gKi9cbkludGVyc2VjdGlvbk9ic2VydmVyLnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX29ic2VydmF0aW9uVGFyZ2V0cyA9IFtdO1xuICB0aGlzLl91bm1vbml0b3JJbnRlcnNlY3Rpb25zKCk7XG4gIHRoaXMuX3VucmVnaXN0ZXJJbnN0YW5jZSgpO1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgYW55IHF1ZXVlIGVudHJpZXMgdGhhdCBoYXZlIG5vdCB5ZXQgYmVlbiByZXBvcnRlZCB0byB0aGVcbiAqIGNhbGxiYWNrIGFuZCBjbGVhcnMgdGhlIHF1ZXVlLiBUaGlzIGNhbiBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlXG4gKiBjYWxsYmFjayB0byBvYnRhaW4gdGhlIGFic29sdXRlIG1vc3QgdXAtdG8tZGF0ZSBpbnRlcnNlY3Rpb24gaW5mb3JtYXRpb24uXG4gKiBAcmV0dXJuIHtBcnJheX0gVGhlIGN1cnJlbnRseSBxdWV1ZWQgZW50cmllcy5cbiAqL1xuSW50ZXJzZWN0aW9uT2JzZXJ2ZXIucHJvdG90eXBlLnRha2VSZWNvcmRzID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZWNvcmRzID0gdGhpcy5fcXVldWVkRW50cmllcy5zbGljZSgpO1xuICB0aGlzLl9xdWV1ZWRFbnRyaWVzID0gW107XG4gIHJldHVybiByZWNvcmRzO1xufTtcblxuXG4vKipcbiAqIEFjY2VwdHMgdGhlIHRocmVzaG9sZCB2YWx1ZSBmcm9tIHRoZSB1c2VyIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGFuZFxuICogcmV0dXJucyBhIHNvcnRlZCBhcnJheSBvZiB1bmlxdWUgdGhyZXNob2xkIHZhbHVlcy4gSWYgYSB2YWx1ZSBpcyBub3RcbiAqIGJldHdlZW4gMCBhbmQgMSBhbmQgZXJyb3IgaXMgdGhyb3duLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8bnVtYmVyPX0gb3B0X3RocmVzaG9sZCBBbiBvcHRpb25hbCB0aHJlc2hvbGQgdmFsdWUgb3JcbiAqICAgICBhIGxpc3Qgb2YgdGhyZXNob2xkIHZhbHVlcywgZGVmYXVsdGluZyB0byBbMF0uXG4gKiBAcmV0dXJuIHtBcnJheX0gQSBzb3J0ZWQgbGlzdCBvZiB1bmlxdWUgYW5kIHZhbGlkIHRocmVzaG9sZCB2YWx1ZXMuXG4gKi9cbkludGVyc2VjdGlvbk9ic2VydmVyLnByb3RvdHlwZS5faW5pdFRocmVzaG9sZHMgPSBmdW5jdGlvbihvcHRfdGhyZXNob2xkKSB7XG4gIHZhciB0aHJlc2hvbGQgPSBvcHRfdGhyZXNob2xkIHx8IFswXTtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHRocmVzaG9sZCkpIHRocmVzaG9sZCA9IFt0aHJlc2hvbGRdO1xuXG4gIHJldHVybiB0aHJlc2hvbGQuc29ydCgpLmZpbHRlcihmdW5jdGlvbih0LCBpLCBhKSB7XG4gICAgaWYgKHR5cGVvZiB0ICE9ICdudW1iZXInIHx8IGlzTmFOKHQpIHx8IHQgPCAwIHx8IHQgPiAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RocmVzaG9sZCBtdXN0IGJlIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMSBpbmNsdXNpdmVseScpO1xuICAgIH1cbiAgICByZXR1cm4gdCAhPT0gYVtpIC0gMV07XG4gIH0pO1xufTtcblxuXG4vKipcbiAqIEFjY2VwdHMgdGhlIHJvb3RNYXJnaW4gdmFsdWUgZnJvbSB0aGUgdXNlciBjb25maWd1cmF0aW9uIG9iamVjdFxuICogYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgdGhlIGZvdXIgbWFyZ2luIHZhbHVlcyBhcyBhbiBvYmplY3QgY29udGFpbmluZ1xuICogdGhlIHZhbHVlIGFuZCB1bml0IHByb3BlcnRpZXMuIElmIGFueSBvZiB0aGUgdmFsdWVzIGFyZSBub3QgcHJvcGVybHlcbiAqIGZvcm1hdHRlZCBvciB1c2UgYSB1bml0IG90aGVyIHRoYW4gcHggb3IgJSwgYW5kIGVycm9yIGlzIHRocm93bi5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZz19IG9wdF9yb290TWFyZ2luIEFuIG9wdGlvbmFsIHJvb3RNYXJnaW4gdmFsdWUsXG4gKiAgICAgZGVmYXVsdGluZyB0byAnMHB4Jy5cbiAqIEByZXR1cm4ge0FycmF5PE9iamVjdD59IEFuIGFycmF5IG9mIG1hcmdpbiBvYmplY3RzIHdpdGggdGhlIGtleXNcbiAqICAgICB2YWx1ZSBhbmQgdW5pdC5cbiAqL1xuSW50ZXJzZWN0aW9uT2JzZXJ2ZXIucHJvdG90eXBlLl9wYXJzZVJvb3RNYXJnaW4gPSBmdW5jdGlvbihvcHRfcm9vdE1hcmdpbikge1xuICB2YXIgbWFyZ2luU3RyaW5nID0gb3B0X3Jvb3RNYXJnaW4gfHwgJzBweCc7XG4gIHZhciBtYXJnaW5zID0gbWFyZ2luU3RyaW5nLnNwbGl0KC9cXHMrLykubWFwKGZ1bmN0aW9uKG1hcmdpbikge1xuICAgIHZhciBwYXJ0cyA9IC9eKC0/XFxkKlxcLj9cXGQrKShweHwlKSQvLmV4ZWMobWFyZ2luKTtcbiAgICBpZiAoIXBhcnRzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Jvb3RNYXJnaW4gbXVzdCBiZSBzcGVjaWZpZWQgaW4gcGl4ZWxzIG9yIHBlcmNlbnQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHt2YWx1ZTogcGFyc2VGbG9hdChwYXJ0c1sxXSksIHVuaXQ6IHBhcnRzWzJdfTtcbiAgfSk7XG5cbiAgLy8gSGFuZGxlcyBzaG9ydGhhbmQuXG4gIG1hcmdpbnNbMV0gPSBtYXJnaW5zWzFdIHx8IG1hcmdpbnNbMF07XG4gIG1hcmdpbnNbMl0gPSBtYXJnaW5zWzJdIHx8IG1hcmdpbnNbMF07XG4gIG1hcmdpbnNbM10gPSBtYXJnaW5zWzNdIHx8IG1hcmdpbnNbMV07XG5cbiAgcmV0dXJuIG1hcmdpbnM7XG59O1xuXG5cbi8qKlxuICogU3RhcnRzIHBvbGxpbmcgZm9yIGludGVyc2VjdGlvbiBjaGFuZ2VzIGlmIHRoZSBwb2xsaW5nIGlzIG5vdCBhbHJlYWR5XG4gKiBoYXBwZW5pbmcsIGFuZCBpZiB0aGUgcGFnZSdzIHZpc2liaWx0eSBzdGF0ZSBpcyB2aXNpYmxlLlxuICogQHByaXZhdGVcbiAqL1xuSW50ZXJzZWN0aW9uT2JzZXJ2ZXIucHJvdG90eXBlLl9tb25pdG9ySW50ZXJzZWN0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuX21vbml0b3JpbmdJbnRlcnNlY3Rpb25zKSB7XG4gICAgdGhpcy5fbW9uaXRvcmluZ0ludGVyc2VjdGlvbnMgPSB0cnVlO1xuXG4gICAgLy8gSWYgYSBwb2xsIGludGVydmFsIGlzIHNldCwgdXNlIHBvbGxpbmcgaW5zdGVhZCBvZiBsaXN0ZW5pbmcgdG9cbiAgICAvLyByZXNpemUgYW5kIHNjcm9sbCBldmVudHMgb3IgRE9NIG11dGF0aW9ucy5cbiAgICBpZiAodGhpcy5QT0xMX0lOVEVSVkFMKSB7XG4gICAgICB0aGlzLl9tb25pdG9yaW5nSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChcbiAgICAgICAgICB0aGlzLl9jaGVja0ZvckludGVyc2VjdGlvbnMsIHRoaXMuUE9MTF9JTlRFUlZBTCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgYWRkRXZlbnQod2luZG93LCAncmVzaXplJywgdGhpcy5fY2hlY2tGb3JJbnRlcnNlY3Rpb25zLCB0cnVlKTtcbiAgICAgIGFkZEV2ZW50KGRvY3VtZW50LCAnc2Nyb2xsJywgdGhpcy5fY2hlY2tGb3JJbnRlcnNlY3Rpb25zLCB0cnVlKTtcblxuICAgICAgaWYgKHRoaXMuVVNFX01VVEFUSU9OX09CU0VSVkVSICYmICdNdXRhdGlvbk9ic2VydmVyJyBpbiB3aW5kb3cpIHtcbiAgICAgICAgdGhpcy5fZG9tT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcih0aGlzLl9jaGVja0ZvckludGVyc2VjdGlvbnMpO1xuICAgICAgICB0aGlzLl9kb21PYnNlcnZlci5vYnNlcnZlKGRvY3VtZW50LCB7XG4gICAgICAgICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICAgICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZSxcbiAgICAgICAgICBzdWJ0cmVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuXG4vKipcbiAqIFN0b3BzIHBvbGxpbmcgZm9yIGludGVyc2VjdGlvbiBjaGFuZ2VzLlxuICogQHByaXZhdGVcbiAqL1xuSW50ZXJzZWN0aW9uT2JzZXJ2ZXIucHJvdG90eXBlLl91bm1vbml0b3JJbnRlcnNlY3Rpb25zID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9tb25pdG9yaW5nSW50ZXJzZWN0aW9ucykge1xuICAgIHRoaXMuX21vbml0b3JpbmdJbnRlcnNlY3Rpb25zID0gZmFsc2U7XG5cbiAgICBjbGVhckludGVydmFsKHRoaXMuX21vbml0b3JpbmdJbnRlcnZhbCk7XG4gICAgdGhpcy5fbW9uaXRvcmluZ0ludGVydmFsID0gbnVsbDtcblxuICAgIHJlbW92ZUV2ZW50KHdpbmRvdywgJ3Jlc2l6ZScsIHRoaXMuX2NoZWNrRm9ySW50ZXJzZWN0aW9ucywgdHJ1ZSk7XG4gICAgcmVtb3ZlRXZlbnQoZG9jdW1lbnQsICdzY3JvbGwnLCB0aGlzLl9jaGVja0ZvckludGVyc2VjdGlvbnMsIHRydWUpO1xuXG4gICAgaWYgKHRoaXMuX2RvbU9ic2VydmVyKSB7XG4gICAgICB0aGlzLl9kb21PYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICB0aGlzLl9kb21PYnNlcnZlciA9IG51bGw7XG4gICAgfVxuICB9XG59O1xuXG5cbi8qKlxuICogU2NhbnMgZWFjaCBvYnNlcnZhdGlvbiB0YXJnZXQgZm9yIGludGVyc2VjdGlvbiBjaGFuZ2VzIGFuZCBhZGRzIHRoZW1cbiAqIHRvIHRoZSBpbnRlcm5hbCBlbnRyaWVzIHF1ZXVlLiBJZiBuZXcgZW50cmllcyBhcmUgZm91bmQsIGl0XG4gKiBzY2hlZHVsZXMgdGhlIGNhbGxiYWNrIHRvIGJlIGludm9rZWQuXG4gKiBAcHJpdmF0ZVxuICovXG5JbnRlcnNlY3Rpb25PYnNlcnZlci5wcm90b3R5cGUuX2NoZWNrRm9ySW50ZXJzZWN0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcm9vdElzSW5Eb20gPSB0aGlzLl9yb290SXNJbkRvbSgpO1xuICB2YXIgcm9vdFJlY3QgPSByb290SXNJbkRvbSA/IHRoaXMuX2dldFJvb3RSZWN0KCkgOiBnZXRFbXB0eVJlY3QoKTtcblxuICB0aGlzLl9vYnNlcnZhdGlvblRhcmdldHMuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgdmFyIHRhcmdldCA9IGl0ZW0uZWxlbWVudDtcbiAgICB2YXIgdGFyZ2V0UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdCh0YXJnZXQpO1xuICAgIHZhciByb290Q29udGFpbnNUYXJnZXQgPSB0aGlzLl9yb290Q29udGFpbnNUYXJnZXQodGFyZ2V0KTtcbiAgICB2YXIgb2xkRW50cnkgPSBpdGVtLmVudHJ5O1xuICAgIHZhciBpbnRlcnNlY3Rpb25SZWN0ID0gcm9vdElzSW5Eb20gJiYgcm9vdENvbnRhaW5zVGFyZ2V0ICYmXG4gICAgICAgIHRoaXMuX2NvbXB1dGVUYXJnZXRBbmRSb290SW50ZXJzZWN0aW9uKHRhcmdldCwgcm9vdFJlY3QpO1xuXG4gICAgdmFyIG5ld0VudHJ5ID0gaXRlbS5lbnRyeSA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlckVudHJ5KHtcbiAgICAgIHRpbWU6IG5vdygpLFxuICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICBib3VuZGluZ0NsaWVudFJlY3Q6IHRhcmdldFJlY3QsXG4gICAgICByb290Qm91bmRzOiByb290UmVjdCxcbiAgICAgIGludGVyc2VjdGlvblJlY3Q6IGludGVyc2VjdGlvblJlY3RcbiAgICB9KTtcblxuICAgIGlmICghb2xkRW50cnkpIHtcbiAgICAgIHRoaXMuX3F1ZXVlZEVudHJpZXMucHVzaChuZXdFbnRyeSk7XG4gICAgfSBlbHNlIGlmIChyb290SXNJbkRvbSAmJiByb290Q29udGFpbnNUYXJnZXQpIHtcbiAgICAgIC8vIElmIHRoZSBuZXcgZW50cnkgaW50ZXJzZWN0aW9uIHJhdGlvIGhhcyBjcm9zc2VkIGFueSBvZiB0aGVcbiAgICAgIC8vIHRocmVzaG9sZHMsIGFkZCBhIG5ldyBlbnRyeS5cbiAgICAgIGlmICh0aGlzLl9oYXNDcm9zc2VkVGhyZXNob2xkKG9sZEVudHJ5LCBuZXdFbnRyeSkpIHtcbiAgICAgICAgdGhpcy5fcXVldWVkRW50cmllcy5wdXNoKG5ld0VudHJ5KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgdGhlIHJvb3QgaXMgbm90IGluIHRoZSBET00gb3IgdGFyZ2V0IGlzIG5vdCBjb250YWluZWQgd2l0aGluXG4gICAgICAvLyByb290IGJ1dCB0aGUgcHJldmlvdXMgZW50cnkgZm9yIHRoaXMgdGFyZ2V0IGhhZCBhbiBpbnRlcnNlY3Rpb24sXG4gICAgICAvLyBhZGQgYSBuZXcgcmVjb3JkIGluZGljYXRpbmcgcmVtb3ZhbC5cbiAgICAgIGlmIChvbGRFbnRyeSAmJiBvbGRFbnRyeS5pc0ludGVyc2VjdGluZykge1xuICAgICAgICB0aGlzLl9xdWV1ZWRFbnRyaWVzLnB1c2gobmV3RW50cnkpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgdGhpcyk7XG5cbiAgaWYgKHRoaXMuX3F1ZXVlZEVudHJpZXMubGVuZ3RoKSB7XG4gICAgdGhpcy5fY2FsbGJhY2sodGhpcy50YWtlUmVjb3JkcygpLCB0aGlzKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIEFjY2VwdHMgYSB0YXJnZXQgYW5kIHJvb3QgcmVjdCBjb21wdXRlcyB0aGUgaW50ZXJzZWN0aW9uIGJldHdlZW4gdGhlblxuICogZm9sbG93aW5nIHRoZSBhbGdvcml0aG0gaW4gdGhlIHNwZWMuXG4gKiBUT0RPKHBoaWxpcHdhbHRvbik6IGF0IHRoaXMgdGltZSBjbGlwLXBhdGggaXMgbm90IGNvbnNpZGVyZWQuXG4gKiBodHRwczovL3czYy5naXRodWIuaW8vSW50ZXJzZWN0aW9uT2JzZXJ2ZXIvI2NhbGN1bGF0ZS1pbnRlcnNlY3Rpb24tcmVjdC1hbGdvXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCBUaGUgdGFyZ2V0IERPTSBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gcm9vdFJlY3QgVGhlIGJvdW5kaW5nIHJlY3Qgb2YgdGhlIHJvb3QgYWZ0ZXIgYmVpbmdcbiAqICAgICBleHBhbmRlZCBieSB0aGUgcm9vdE1hcmdpbiB2YWx1ZS5cbiAqIEByZXR1cm4gez9PYmplY3R9IFRoZSBmaW5hbCBpbnRlcnNlY3Rpb24gcmVjdCBvYmplY3Qgb3IgdW5kZWZpbmVkIGlmIG5vXG4gKiAgICAgaW50ZXJzZWN0aW9uIGlzIGZvdW5kLlxuICogQHByaXZhdGVcbiAqL1xuSW50ZXJzZWN0aW9uT2JzZXJ2ZXIucHJvdG90eXBlLl9jb21wdXRlVGFyZ2V0QW5kUm9vdEludGVyc2VjdGlvbiA9XG4gICAgZnVuY3Rpb24odGFyZ2V0LCByb290UmVjdCkge1xuXG4gIC8vIElmIHRoZSBlbGVtZW50IGlzbid0IGRpc3BsYXllZCwgYW4gaW50ZXJzZWN0aW9uIGNhbid0IGhhcHBlbi5cbiAgaWYgKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRhcmdldCkuZGlzcGxheSA9PSAnbm9uZScpIHJldHVybjtcblxuICB2YXIgdGFyZ2V0UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdCh0YXJnZXQpO1xuICB2YXIgaW50ZXJzZWN0aW9uUmVjdCA9IHRhcmdldFJlY3Q7XG4gIHZhciBwYXJlbnQgPSBnZXRQYXJlbnROb2RlKHRhcmdldCk7XG4gIHZhciBhdFJvb3QgPSBmYWxzZTtcblxuICB3aGlsZSAoIWF0Um9vdCkge1xuICAgIHZhciBwYXJlbnRSZWN0ID0gbnVsbDtcbiAgICB2YXIgcGFyZW50Q29tcHV0ZWRTdHlsZSA9IHBhcmVudC5ub2RlVHlwZSA9PSAxID9cbiAgICAgICAgd2luZG93LmdldENvbXB1dGVkU3R5bGUocGFyZW50KSA6IHt9O1xuXG4gICAgLy8gSWYgdGhlIHBhcmVudCBpc24ndCBkaXNwbGF5ZWQsIGFuIGludGVyc2VjdGlvbiBjYW4ndCBoYXBwZW4uXG4gICAgaWYgKHBhcmVudENvbXB1dGVkU3R5bGUuZGlzcGxheSA9PSAnbm9uZScpIHJldHVybjtcblxuICAgIGlmIChwYXJlbnQgPT0gdGhpcy5yb290IHx8IHBhcmVudCA9PSBkb2N1bWVudCkge1xuICAgICAgYXRSb290ID0gdHJ1ZTtcbiAgICAgIHBhcmVudFJlY3QgPSByb290UmVjdDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgdGhlIGVsZW1lbnQgaGFzIGEgbm9uLXZpc2libGUgb3ZlcmZsb3csIGFuZCBpdCdzIG5vdCB0aGUgPGJvZHk+XG4gICAgICAvLyBvciA8aHRtbD4gZWxlbWVudCwgdXBkYXRlIHRoZSBpbnRlcnNlY3Rpb24gcmVjdC5cbiAgICAgIC8vIE5vdGU6IDxib2R5PiBhbmQgPGh0bWw+IGNhbm5vdCBiZSBjbGlwcGVkIHRvIGEgcmVjdCB0aGF0J3Mgbm90IGFsc29cbiAgICAgIC8vIHRoZSBkb2N1bWVudCByZWN0LCBzbyBubyBuZWVkIHRvIGNvbXB1dGUgYSBuZXcgaW50ZXJzZWN0aW9uLlxuICAgICAgaWYgKHBhcmVudCAhPSBkb2N1bWVudC5ib2R5ICYmXG4gICAgICAgICAgcGFyZW50ICE9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJlxuICAgICAgICAgIHBhcmVudENvbXB1dGVkU3R5bGUub3ZlcmZsb3cgIT0gJ3Zpc2libGUnKSB7XG4gICAgICAgIHBhcmVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QocGFyZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiBlaXRoZXIgb2YgdGhlIGFib3ZlIGNvbmRpdGlvbmFscyBzZXQgYSBuZXcgcGFyZW50UmVjdCxcbiAgICAvLyBjYWxjdWxhdGUgbmV3IGludGVyc2VjdGlvbiBkYXRhLlxuICAgIGlmIChwYXJlbnRSZWN0KSB7XG4gICAgICBpbnRlcnNlY3Rpb25SZWN0ID0gY29tcHV0ZVJlY3RJbnRlcnNlY3Rpb24ocGFyZW50UmVjdCwgaW50ZXJzZWN0aW9uUmVjdCk7XG5cbiAgICAgIGlmICghaW50ZXJzZWN0aW9uUmVjdCkgYnJlYWs7XG4gICAgfVxuICAgIHBhcmVudCA9IGdldFBhcmVudE5vZGUocGFyZW50KTtcbiAgfVxuICByZXR1cm4gaW50ZXJzZWN0aW9uUmVjdDtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSByb290IHJlY3QgYWZ0ZXIgYmVpbmcgZXhwYW5kZWQgYnkgdGhlIHJvb3RNYXJnaW4gdmFsdWUuXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBleHBhbmRlZCByb290IHJlY3QuXG4gKiBAcHJpdmF0ZVxuICovXG5JbnRlcnNlY3Rpb25PYnNlcnZlci5wcm90b3R5cGUuX2dldFJvb3RSZWN0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciByb290UmVjdDtcbiAgaWYgKHRoaXMucm9vdCkge1xuICAgIHJvb3RSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHRoaXMucm9vdCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gVXNlIDxodG1sPi88Ym9keT4gaW5zdGVhZCBvZiB3aW5kb3cgc2luY2Ugc2Nyb2xsIGJhcnMgYWZmZWN0IHNpemUuXG4gICAgdmFyIGh0bWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuICAgIHJvb3RSZWN0ID0ge1xuICAgICAgdG9wOiAwLFxuICAgICAgbGVmdDogMCxcbiAgICAgIHJpZ2h0OiBodG1sLmNsaWVudFdpZHRoIHx8IGJvZHkuY2xpZW50V2lkdGgsXG4gICAgICB3aWR0aDogaHRtbC5jbGllbnRXaWR0aCB8fCBib2R5LmNsaWVudFdpZHRoLFxuICAgICAgYm90dG9tOiBodG1sLmNsaWVudEhlaWdodCB8fCBib2R5LmNsaWVudEhlaWdodCxcbiAgICAgIGhlaWdodDogaHRtbC5jbGllbnRIZWlnaHQgfHwgYm9keS5jbGllbnRIZWlnaHRcbiAgICB9O1xuICB9XG4gIHJldHVybiB0aGlzLl9leHBhbmRSZWN0QnlSb290TWFyZ2luKHJvb3RSZWN0KTtcbn07XG5cblxuLyoqXG4gKiBBY2NlcHRzIGEgcmVjdCBhbmQgZXhwYW5kcyBpdCBieSB0aGUgcm9vdE1hcmdpbiB2YWx1ZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSByZWN0IFRoZSByZWN0IG9iamVjdCB0byBleHBhbmQuXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBleHBhbmRlZCByZWN0LlxuICogQHByaXZhdGVcbiAqL1xuSW50ZXJzZWN0aW9uT2JzZXJ2ZXIucHJvdG90eXBlLl9leHBhbmRSZWN0QnlSb290TWFyZ2luID0gZnVuY3Rpb24ocmVjdCkge1xuICB2YXIgbWFyZ2lucyA9IHRoaXMuX3Jvb3RNYXJnaW5WYWx1ZXMubWFwKGZ1bmN0aW9uKG1hcmdpbiwgaSkge1xuICAgIHJldHVybiBtYXJnaW4udW5pdCA9PSAncHgnID8gbWFyZ2luLnZhbHVlIDpcbiAgICAgICAgbWFyZ2luLnZhbHVlICogKGkgJSAyID8gcmVjdC53aWR0aCA6IHJlY3QuaGVpZ2h0KSAvIDEwMDtcbiAgfSk7XG4gIHZhciBuZXdSZWN0ID0ge1xuICAgIHRvcDogcmVjdC50b3AgLSBtYXJnaW5zWzBdLFxuICAgIHJpZ2h0OiByZWN0LnJpZ2h0ICsgbWFyZ2luc1sxXSxcbiAgICBib3R0b206IHJlY3QuYm90dG9tICsgbWFyZ2luc1syXSxcbiAgICBsZWZ0OiByZWN0LmxlZnQgLSBtYXJnaW5zWzNdXG4gIH07XG4gIG5ld1JlY3Qud2lkdGggPSBuZXdSZWN0LnJpZ2h0IC0gbmV3UmVjdC5sZWZ0O1xuICBuZXdSZWN0LmhlaWdodCA9IG5ld1JlY3QuYm90dG9tIC0gbmV3UmVjdC50b3A7XG5cbiAgcmV0dXJuIG5ld1JlY3Q7XG59O1xuXG5cbi8qKlxuICogQWNjZXB0cyBhbiBvbGQgYW5kIG5ldyBlbnRyeSBhbmQgcmV0dXJucyB0cnVlIGlmIGF0IGxlYXN0IG9uZSBvZiB0aGVcbiAqIHRocmVzaG9sZCB2YWx1ZXMgaGFzIGJlZW4gY3Jvc3NlZC5cbiAqIEBwYXJhbSB7P0ludGVyc2VjdGlvbk9ic2VydmVyRW50cnl9IG9sZEVudHJ5IFRoZSBwcmV2aW91cyBlbnRyeSBmb3IgYVxuICogICAgcGFydGljdWxhciB0YXJnZXQgZWxlbWVudCBvciBudWxsIGlmIG5vIHByZXZpb3VzIGVudHJ5IGV4aXN0cy5cbiAqIEBwYXJhbSB7SW50ZXJzZWN0aW9uT2JzZXJ2ZXJFbnRyeX0gbmV3RW50cnkgVGhlIGN1cnJlbnQgZW50cnkgZm9yIGFcbiAqICAgIHBhcnRpY3VsYXIgdGFyZ2V0IGVsZW1lbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgYSBhbnkgdGhyZXNob2xkIGhhcyBiZWVuIGNyb3NzZWQuXG4gKiBAcHJpdmF0ZVxuICovXG5JbnRlcnNlY3Rpb25PYnNlcnZlci5wcm90b3R5cGUuX2hhc0Nyb3NzZWRUaHJlc2hvbGQgPVxuICAgIGZ1bmN0aW9uKG9sZEVudHJ5LCBuZXdFbnRyeSkge1xuXG4gIC8vIFRvIG1ha2UgY29tcGFyaW5nIGVhc2llciwgYW4gZW50cnkgdGhhdCBoYXMgYSByYXRpbyBvZiAwXG4gIC8vIGJ1dCBkb2VzIG5vdCBhY3R1YWxseSBpbnRlcnNlY3QgaXMgZ2l2ZW4gYSB2YWx1ZSBvZiAtMVxuICB2YXIgb2xkUmF0aW8gPSBvbGRFbnRyeSAmJiBvbGRFbnRyeS5pc0ludGVyc2VjdGluZyA/XG4gICAgICBvbGRFbnRyeS5pbnRlcnNlY3Rpb25SYXRpbyB8fCAwIDogLTE7XG4gIHZhciBuZXdSYXRpbyA9IG5ld0VudHJ5LmlzSW50ZXJzZWN0aW5nID9cbiAgICAgIG5ld0VudHJ5LmludGVyc2VjdGlvblJhdGlvIHx8IDAgOiAtMTtcblxuICAvLyBJZ25vcmUgdW5jaGFuZ2VkIHJhdGlvc1xuICBpZiAob2xkUmF0aW8gPT09IG5ld1JhdGlvKSByZXR1cm47XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnRocmVzaG9sZHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdGhyZXNob2xkID0gdGhpcy50aHJlc2hvbGRzW2ldO1xuXG4gICAgLy8gUmV0dXJuIHRydWUgaWYgYW4gZW50cnkgbWF0Y2hlcyBhIHRocmVzaG9sZCBvciBpZiB0aGUgbmV3IHJhdGlvXG4gICAgLy8gYW5kIHRoZSBvbGQgcmF0aW8gYXJlIG9uIHRoZSBvcHBvc2l0ZSBzaWRlcyBvZiBhIHRocmVzaG9sZC5cbiAgICBpZiAodGhyZXNob2xkID09IG9sZFJhdGlvIHx8IHRocmVzaG9sZCA9PSBuZXdSYXRpbyB8fFxuICAgICAgICB0aHJlc2hvbGQgPCBvbGRSYXRpbyAhPT0gdGhyZXNob2xkIDwgbmV3UmF0aW8pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHJvb3QgZWxlbWVudCBpcyBhbiBlbGVtZW50IGFuZCBpcyBpbiB0aGUgRE9NLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcm9vdCBlbGVtZW50IGlzIGFuIGVsZW1lbnQgYW5kIGlzIGluIHRoZSBET00uXG4gKiBAcHJpdmF0ZVxuICovXG5JbnRlcnNlY3Rpb25PYnNlcnZlci5wcm90b3R5cGUuX3Jvb3RJc0luRG9tID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAhdGhpcy5yb290IHx8IGNvbnRhaW5zRGVlcChkb2N1bWVudCwgdGhpcy5yb290KTtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB0YXJnZXQgZWxlbWVudCBpcyBhIGNoaWxkIG9mIHJvb3QuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCBUaGUgdGFyZ2V0IGVsZW1lbnQgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSB0YXJnZXQgZWxlbWVudCBpcyBhIGNoaWxkIG9mIHJvb3QuXG4gKiBAcHJpdmF0ZVxuICovXG5JbnRlcnNlY3Rpb25PYnNlcnZlci5wcm90b3R5cGUuX3Jvb3RDb250YWluc1RhcmdldCA9IGZ1bmN0aW9uKHRhcmdldCkge1xuICByZXR1cm4gY29udGFpbnNEZWVwKHRoaXMucm9vdCB8fCBkb2N1bWVudCwgdGFyZ2V0KTtcbn07XG5cblxuLyoqXG4gKiBBZGRzIHRoZSBpbnN0YW5jZSB0byB0aGUgZ2xvYmFsIEludGVyc2VjdGlvbk9ic2VydmVyIHJlZ2lzdHJ5IGlmIGl0IGlzbid0XG4gKiBhbHJlYWR5IHByZXNlbnQuXG4gKiBAcHJpdmF0ZVxuICovXG5JbnRlcnNlY3Rpb25PYnNlcnZlci5wcm90b3R5cGUuX3JlZ2lzdGVySW5zdGFuY2UgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHJlZ2lzdHJ5LmluZGV4T2YodGhpcykgPCAwKSB7XG4gICAgcmVnaXN0cnkucHVzaCh0aGlzKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIFJlbW92ZXMgdGhlIGluc3RhbmNlIGZyb20gdGhlIGdsb2JhbCBJbnRlcnNlY3Rpb25PYnNlcnZlciByZWdpc3RyeS5cbiAqIEBwcml2YXRlXG4gKi9cbkludGVyc2VjdGlvbk9ic2VydmVyLnByb3RvdHlwZS5fdW5yZWdpc3Rlckluc3RhbmNlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpbmRleCA9IHJlZ2lzdHJ5LmluZGV4T2YodGhpcyk7XG4gIGlmIChpbmRleCAhPSAtMSkgcmVnaXN0cnkuc3BsaWNlKGluZGV4LCAxKTtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSByZXN1bHQgb2YgdGhlIHBlcmZvcm1hbmNlLm5vdygpIG1ldGhvZCBvciBudWxsIGluIGJyb3dzZXJzXG4gKiB0aGF0IGRvbid0IHN1cHBvcnQgdGhlIEFQSS5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGVsYXBzZWQgdGltZSBzaW5jZSB0aGUgcGFnZSB3YXMgcmVxdWVzdGVkLlxuICovXG5mdW5jdGlvbiBub3coKSB7XG4gIHJldHVybiB3aW5kb3cucGVyZm9ybWFuY2UgJiYgcGVyZm9ybWFuY2Uubm93ICYmIHBlcmZvcm1hbmNlLm5vdygpO1xufVxuXG5cbi8qKlxuICogVGhyb3R0bGVzIGEgZnVuY3Rpb24gYW5kIGRlbGF5cyBpdHMgZXhlY3V0aW9uZywgc28gaXQncyBvbmx5IGNhbGxlZCBhdCBtb3N0XG4gKiBvbmNlIHdpdGhpbiBhIGdpdmVuIHRpbWUgcGVyaW9kLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIHRocm90dGxlLlxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXQgVGhlIGFtb3VudCBvZiB0aW1lIHRoYXQgbXVzdCBwYXNzIGJlZm9yZSB0aGVcbiAqICAgICBmdW5jdGlvbiBjYW4gYmUgY2FsbGVkIGFnYWluLlxuICogQHJldHVybiB7RnVuY3Rpb259IFRoZSB0aHJvdHRsZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHRocm90dGxlKGZuLCB0aW1lb3V0KSB7XG4gIHZhciB0aW1lciA9IG51bGw7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aW1lcikge1xuICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBmbigpO1xuICAgICAgICB0aW1lciA9IG51bGw7XG4gICAgICB9LCB0aW1lb3V0KTtcbiAgICB9XG4gIH07XG59XG5cblxuLyoqXG4gKiBBZGRzIGFuIGV2ZW50IGhhbmRsZXIgdG8gYSBET00gbm9kZSBlbnN1cmluZyBjcm9zcy1icm93c2VyIGNvbXBhdGliaWxpdHkuXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgVGhlIERPTSBub2RlIHRvIGFkZCB0aGUgZXZlbnQgaGFuZGxlciB0by5cbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBldmVudCBoYW5kbGVyIHRvIGFkZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0X3VzZUNhcHR1cmUgT3B0aW9uYWxseSBhZGRzIHRoZSBldmVuIHRvIHRoZSBjYXB0dXJlXG4gKiAgICAgcGhhc2UuIE5vdGU6IHRoaXMgb25seSB3b3JrcyBpbiBtb2Rlcm4gYnJvd3NlcnMuXG4gKi9cbmZ1bmN0aW9uIGFkZEV2ZW50KG5vZGUsIGV2ZW50LCBmbiwgb3B0X3VzZUNhcHR1cmUpIHtcbiAgaWYgKHR5cGVvZiBub2RlLmFkZEV2ZW50TGlzdGVuZXIgPT0gJ2Z1bmN0aW9uJykge1xuICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgZm4sIG9wdF91c2VDYXB0dXJlIHx8IGZhbHNlKTtcbiAgfVxuICBlbHNlIGlmICh0eXBlb2Ygbm9kZS5hdHRhY2hFdmVudCA9PSAnZnVuY3Rpb24nKSB7XG4gICAgbm9kZS5hdHRhY2hFdmVudCgnb24nICsgZXZlbnQsIGZuKTtcbiAgfVxufVxuXG5cbi8qKlxuICogUmVtb3ZlcyBhIHByZXZpb3VzbHkgYWRkZWQgZXZlbnQgaGFuZGxlciBmcm9tIGEgRE9NIG5vZGUuXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgVGhlIERPTSBub2RlIHRvIHJlbW92ZSB0aGUgZXZlbnQgaGFuZGxlciBmcm9tLlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGV2ZW50IGhhbmRsZXIgdG8gcmVtb3ZlLlxuICogQHBhcmFtIHtib29sZWFufSBvcHRfdXNlQ2FwdHVyZSBJZiB0aGUgZXZlbnQgaGFuZGxlciB3YXMgYWRkZWQgd2l0aCB0aGlzXG4gKiAgICAgZmxhZyBzZXQgdG8gdHJ1ZSwgaXQgc2hvdWxkIGJlIHNldCB0byB0cnVlIGhlcmUgaW4gb3JkZXIgdG8gcmVtb3ZlIGl0LlxuICovXG5mdW5jdGlvbiByZW1vdmVFdmVudChub2RlLCBldmVudCwgZm4sIG9wdF91c2VDYXB0dXJlKSB7XG4gIGlmICh0eXBlb2Ygbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyID09ICdmdW5jdGlvbicpIHtcbiAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGZuLCBvcHRfdXNlQ2FwdHVyZSB8fCBmYWxzZSk7XG4gIH1cbiAgZWxzZSBpZiAodHlwZW9mIG5vZGUuZGV0YXRjaEV2ZW50ID09ICdmdW5jdGlvbicpIHtcbiAgICBub2RlLmRldGF0Y2hFdmVudCgnb24nICsgZXZlbnQsIGZuKTtcbiAgfVxufVxuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgaW50ZXJzZWN0aW9uIGJldHdlZW4gdHdvIHJlY3Qgb2JqZWN0cy5cbiAqIEBwYXJhbSB7T2JqZWN0fSByZWN0MSBUaGUgZmlyc3QgcmVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSByZWN0MiBUaGUgc2Vjb25kIHJlY3QuXG4gKiBAcmV0dXJuIHs/T2JqZWN0fSBUaGUgaW50ZXJzZWN0aW9uIHJlY3Qgb3IgdW5kZWZpbmVkIGlmIG5vIGludGVyc2VjdGlvblxuICogICAgIGlzIGZvdW5kLlxuICovXG5mdW5jdGlvbiBjb21wdXRlUmVjdEludGVyc2VjdGlvbihyZWN0MSwgcmVjdDIpIHtcbiAgdmFyIHRvcCA9IE1hdGgubWF4KHJlY3QxLnRvcCwgcmVjdDIudG9wKTtcbiAgdmFyIGJvdHRvbSA9IE1hdGgubWluKHJlY3QxLmJvdHRvbSwgcmVjdDIuYm90dG9tKTtcbiAgdmFyIGxlZnQgPSBNYXRoLm1heChyZWN0MS5sZWZ0LCByZWN0Mi5sZWZ0KTtcbiAgdmFyIHJpZ2h0ID0gTWF0aC5taW4ocmVjdDEucmlnaHQsIHJlY3QyLnJpZ2h0KTtcbiAgdmFyIHdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuICB2YXIgaGVpZ2h0ID0gYm90dG9tIC0gdG9wO1xuXG4gIHJldHVybiAod2lkdGggPj0gMCAmJiBoZWlnaHQgPj0gMCkgJiYge1xuICAgIHRvcDogdG9wLFxuICAgIGJvdHRvbTogYm90dG9tLFxuICAgIGxlZnQ6IGxlZnQsXG4gICAgcmlnaHQ6IHJpZ2h0LFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodFxuICB9O1xufVxuXG5cbi8qKlxuICogU2hpbXMgdGhlIG5hdGl2ZSBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBvbGRlciBJRS5cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWwgVGhlIGVsZW1lbnQgd2hvc2UgYm91bmRpbmcgcmVjdCB0byBnZXQuXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSAocG9zc2libHkgc2hpbW1lZCkgcmVjdCBvZiB0aGUgZWxlbWVudC5cbiAqL1xuZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsKSB7XG4gIHZhciByZWN0O1xuXG4gIHRyeSB7XG4gICAgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBJZ25vcmUgV2luZG93cyA3IElFMTEgXCJVbnNwZWNpZmllZCBlcnJvclwiXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3czYy9JbnRlcnNlY3Rpb25PYnNlcnZlci9wdWxsLzIwNVxuICB9XG5cbiAgaWYgKCFyZWN0KSByZXR1cm4gZ2V0RW1wdHlSZWN0KCk7XG5cbiAgLy8gT2xkZXIgSUVcbiAgaWYgKCEocmVjdC53aWR0aCAmJiByZWN0LmhlaWdodCkpIHtcbiAgICByZWN0ID0ge1xuICAgICAgdG9wOiByZWN0LnRvcCxcbiAgICAgIHJpZ2h0OiByZWN0LnJpZ2h0LFxuICAgICAgYm90dG9tOiByZWN0LmJvdHRvbSxcbiAgICAgIGxlZnQ6IHJlY3QubGVmdCxcbiAgICAgIHdpZHRoOiByZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0LFxuICAgICAgaGVpZ2h0OiByZWN0LmJvdHRvbSAtIHJlY3QudG9wXG4gICAgfTtcbiAgfVxuICByZXR1cm4gcmVjdDtcbn1cblxuXG4vKipcbiAqIFJldHVybnMgYW4gZW1wdHkgcmVjdCBvYmplY3QuIEFuIGVtcHR5IHJlY3QgaXMgcmV0dXJuZWQgd2hlbiBhbiBlbGVtZW50XG4gKiBpcyBub3QgaW4gdGhlIERPTS5cbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIGVtcHR5IHJlY3QuXG4gKi9cbmZ1bmN0aW9uIGdldEVtcHR5UmVjdCgpIHtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IDAsXG4gICAgYm90dG9tOiAwLFxuICAgIGxlZnQ6IDAsXG4gICAgcmlnaHQ6IDAsXG4gICAgd2lkdGg6IDAsXG4gICAgaGVpZ2h0OiAwXG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2tzIHRvIHNlZSBpZiBhIHBhcmVudCBlbGVtZW50IGNvbnRhaW5zIGEgY2hpbGQgZWxlbW50IChpbmNsdWRpbmcgaW5zaWRlXG4gKiBzaGFkb3cgRE9NKS5cbiAqIEBwYXJhbSB7Tm9kZX0gcGFyZW50IFRoZSBwYXJlbnQgZWxlbWVudC5cbiAqIEBwYXJhbSB7Tm9kZX0gY2hpbGQgVGhlIGNoaWxkIGVsZW1lbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBwYXJlbnQgbm9kZSBjb250YWlucyB0aGUgY2hpbGQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gY29udGFpbnNEZWVwKHBhcmVudCwgY2hpbGQpIHtcbiAgdmFyIG5vZGUgPSBjaGlsZDtcbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZSA9PSBwYXJlbnQpIHJldHVybiB0cnVlO1xuXG4gICAgbm9kZSA9IGdldFBhcmVudE5vZGUobm9kZSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5cbi8qKlxuICogR2V0cyB0aGUgcGFyZW50IG5vZGUgb2YgYW4gZWxlbWVudCBvciBpdHMgaG9zdCBlbGVtZW50IGlmIHRoZSBwYXJlbnQgbm9kZVxuICogaXMgYSBzaGFkb3cgcm9vdC5cbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBUaGUgbm9kZSB3aG9zZSBwYXJlbnQgdG8gZ2V0LlxuICogQHJldHVybiB7Tm9kZXxudWxsfSBUaGUgcGFyZW50IG5vZGUgb3IgbnVsbCBpZiBubyBwYXJlbnQgZXhpc3RzLlxuICovXG5mdW5jdGlvbiBnZXRQYXJlbnROb2RlKG5vZGUpIHtcbiAgdmFyIHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcblxuICBpZiAocGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSA9PSAxMSAmJiBwYXJlbnQuaG9zdCkge1xuICAgIC8vIElmIHRoZSBwYXJlbnQgaXMgYSBzaGFkb3cgcm9vdCwgcmV0dXJuIHRoZSBob3N0IGVsZW1lbnQuXG4gICAgcmV0dXJuIHBhcmVudC5ob3N0O1xuICB9XG4gIHJldHVybiBwYXJlbnQ7XG59XG5cblxuLy8gRXhwb3NlcyB0aGUgY29uc3RydWN0b3JzIGdsb2JhbGx5Llxud2luZG93LkludGVyc2VjdGlvbk9ic2VydmVyID0gSW50ZXJzZWN0aW9uT2JzZXJ2ZXI7XG53aW5kb3cuSW50ZXJzZWN0aW9uT2JzZXJ2ZXJFbnRyeSA9IEludGVyc2VjdGlvbk9ic2VydmVyRW50cnk7XG5cbn0od2luZG93LCBkb2N1bWVudCkpO1xuIiwiPHRlbXBsYXRlPlxuICAgIDxkaXYgY2xhc3M9XCJpbmZpbml0ZS1zY3JvbGxpbmdcIiA6c3R5bGU9XCJ7aGVpZ2h0OiBoZWlnaHRVbml0LCBiYWNrZ3JvdW5kOiBiYWNrZ3JvdW5kfVwiPlxuICAgICAgICA8YWN0aXZpdHktaW5kaWNhdG9yIHYtaWY9XCJhY3Rpdml0eVwiIDpzaXplPVwic2l6ZVwiIDp0eXBlPVwidHlwZVwiIGNlbnRlci8+XG4gICAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0ICdpbnRlcnNlY3Rpb24tb2JzZXJ2ZXInO1xuaW1wb3J0IHVuaXQgZnJvbSAnLi4vLi4vSGVscGVycy9Vbml0JztcbmltcG9ydCBBY3Rpdml0eUluZGljYXRvciBmcm9tICcuLi9BY3Rpdml0eUluZGljYXRvcic7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdpbmZpbml0ZS1zY3JvbGxpbmcnLFxuXG4gICAgY29tcG9uZW50czoge1xuICAgICAgICBBY3Rpdml0eUluZGljYXRvclxuICAgIH0sXG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJcyB0aGUgYWN0aXZpdHkgaW5kaWNhdG9yIHNob3dpbmdcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgYWN0aXZpdHk6IEJvb2xlYW4sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhY3Rpdml0eSBpbmRpY2F0b3IgYmFja2dyb3VuZCBzdHlsZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBiYWNrZ3JvdW5kOiBTdHJpbmcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhY3Rpdml0eSBpbmRpY2F0b3Igc2l6ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBoZWlnaHQ6IHtcbiAgICAgICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgICAgIGRlZmF1bHQ6IDEwMFxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYWN0aXZpdHkgaW5kaWNhdG9yIHNpemVcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgc2l6ZTogU3RyaW5nLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYWN0aXZpdHkgaW5kaWNhdG9yIHR5cGVcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgdHlwZTogU3RyaW5nLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc2Nyb2xsIG9ic2VydmVyIHRocmVzaG9sZCBmb3Igd2hlbiBhbiBlbGVtZW50IGlzIGNvbnNpZGVyZWRcbiAgICAgICAgICogaW50byB2aWV3LiBNdXN0IGJlIGEgdmFsaWRhdGUgYmV0d2VlbiAwIGFuZCAxLCBhbmQgaXMgYSBwZXJjZW50YWdlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgTnVtYmVyXG4gICAgICAgICAqL1xuICAgICAgICB0aHJlc2hvbGQ6IHtcbiAgICAgICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgICAgIGRlZmF1bHQ6IC43NSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlID49IDAgJiYgdmFsdWUgPD0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIG1ldGhvZHM6IHtcblxuICAgICAgICBzY3JvbGxJbnRvVmlld3BvcnQoZW50cnkpIHtcbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ3Njcm9sbDppbicsIGVudHJ5KTtcblxuICAgICAgICAgICAgaWYoIXRoaXMuYWN0aXZpdHkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdsb2FkJywgZW50cnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHNjcm9sbE91dFZpZXdwb3J0KGVudHJ5KSB7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCdzY3JvbGw6b3V0JywgZW50cnkpO1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgY29tcHV0ZWQ6IHtcblxuICAgICAgICBoZWlnaHRVbml0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuaXQodGhpcy5oZWlnaHQpO1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgbW91bnRlZCgpIHtcbiAgICAgICAgdGhpcy4kbmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKChlbnRyaWVzLCBvYnNlcnZlcikgPT4ge1xuICAgICAgICAgICAgICAgIGVudHJpZXMuZm9yRWFjaChlbnRyeSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmKGVudHJ5LmlzSW50ZXJzZWN0aW5nICYmICF0aGlzLmhhc1Njcm9sbGVkSW50b1ZpZXdwb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbEludG9WaWV3cG9ydChlbnRyeSwgb2JzZXJ2ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYXNTY3JvbGxlZEludG9WaWV3cG9ydCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZih0aGlzLmhhc1Njcm9sbGVkSW50b1ZpZXdwb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbE91dFZpZXdwb3J0KGVudHJ5LCBvYnNlcnZlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhc1Njcm9sbGVkSW50b1ZpZXdwb3J0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICB0aHJlc2hvbGQ6IHRoaXMudGhyZXNob2xkXG4gICAgICAgICAgICB9KS5vYnNlcnZlKHRoaXMuJGVsKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBoYXNTY3JvbGxlZEludG9WaWV3cG9ydDogZmFsc2VcbiAgICAgICAgfVxuICAgIH1cblxufVxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwic2Nzc1wiPlxuLmluZmluaXRlLXNjcm9sbGluZyB7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuXG59XG48L3N0eWxlPlxuIiwiPHRlbXBsYXRlPlxuXG4gICAgPHNwYW4gY2xhc3M9XCJpbnB1dC1ncm91cC10ZXh0XCIgOmlkPVwiaWRcIj5cbiAgICAgICAgPHNsb3Q+e3sgdGV4dCB9fTwvc2xvdD5cbiAgICA8L3NwYW4+XG5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdpbnB1dC1ncm91cC10ZXh0JyxcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBpZCBhdHRyaWJ1dGVcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgaWQ6IFN0cmluZyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHR5cGUgYXR0cmlidXRlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHRleHQ6IFtBcnJheSwgTnVtYmVyLCBTdHJpbmddXG5cbiAgICB9XG5cbn1cblxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG5cbiAgICA8ZGl2IGNsYXNzPVwiaW5wdXQtZ3JvdXAtYXBwZW5kXCI+XG4gICAgICAgIDxpbnB1dC1ncm91cC10ZXh0IHYtaWY9XCJ0ZXh0XCI+XG4gICAgICAgICAgICA8c2xvdC8+XG4gICAgICAgIDwvaW5wdXQtZ3JvdXAtdGV4dD5cbiAgICAgICAgPHNsb3Qgdi1lbHNlLz5cbiAgICA8L2Rpdj5cblxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ2lucHV0LWdyb3VwLWFwcGVuZCcsXG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdHlwZSBhdHRyaWJ1dGVcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgdGV4dDogQm9vbGVhblxuXG4gICAgfVxuXG59XG5cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuXG4gICAgPGRpdiBjbGFzcz1cImlucHV0LWdyb3VwLXByZXBlbmRcIj5cbiAgICAgICAgPGlucHV0LWdyb3VwLXRleHQgdi1pZj1cInRleHRcIj5cbiAgICAgICAgICAgIDxzbG90Lz5cbiAgICAgICAgPC9pbnB1dC1ncm91cC10ZXh0PlxuICAgICAgICA8c2xvdCB2LWVsc2UvPlxuICAgIDwvZGl2PlxuXG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAnaW5wdXQtZ3JvdXAtcHJlcGVuZCcsXG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdHlwZSBhdHRyaWJ1dGVcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgdGV4dDogQm9vbGVhblxuXG4gICAgfVxuXG59XG5cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuXG4gICAgPGRpdiBjbGFzcz1cImlucHV0LWdyb3VwXCIgOmNsYXNzPVwibWVyZ2VDbGFzc2VzKGNvbG9yYWJsZUNsYXNzZXMsIHNpemVhYmxlQ2xhc3MpXCI+XG5cbiAgICAgICAgPHNsb3QgbmFtZT1cInByZXBlbmRcIj5cbiAgICAgICAgICAgIDx0ZW1wbGF0ZSB2LWlmPVwicHJlcGVuZCBpbnN0YW5jZW9mIEFycmF5XCI+XG4gICAgICAgICAgICAgICAgPGlucHV0LWdyb3VwLXByZXBlbmQ+XG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dC1ncm91cC10ZXh0IHYtZm9yPVwidmFsdWUgaW4gcHJlcGVuZFwiIDp0ZXh0PVwidmFsdWVcIi8+XG4gICAgICAgICAgICAgICAgPC9pbnB1dC1ncm91cC1wcmVwZW5kPlxuICAgICAgICAgICAgPC90ZW1wbGF0ZT5cbiAgICAgICAgICAgIDx0ZW1wbGF0ZSB2LWVsc2UtaWY9XCJwcmVwZW5kXCI+XG4gICAgICAgICAgICAgICAgPGlucHV0LWdyb3VwLXByZXBlbmQgdGV4dD57e3ByZXBlbmR9fTwvaW5wdXQtZ3JvdXAtcHJlcGVuZD5cbiAgICAgICAgICAgIDwvdGVtcGxhdGU+XG4gICAgICAgIDwvc2xvdD5cblxuICAgICAgICA8c2xvdC8+XG5cbiAgICAgICAgPHNsb3QgbmFtZT1cImFwcGVuZFwiPlxuICAgICAgICAgICAgPHRlbXBsYXRlIHYtaWY9XCJhcHBlbmQgaW5zdGFuY2VvZiBBcnJheVwiPlxuICAgICAgICAgICAgICAgIDxpbnB1dC1ncm91cC1hcHBlbmQ+XG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dC1ncm91cC10ZXh0IHYtZm9yPVwidmFsdWUgaW4gYXBwZW5kXCIgOnRleHQ9XCJ2YWx1ZVwiLz5cbiAgICAgICAgICAgICAgICA8L2lucHV0LWdyb3VwLWFwcGVuZD5cbiAgICAgICAgICAgIDwvdGVtcGxhdGU+XG4gICAgICAgICAgICA8dGVtcGxhdGUgdi1lbHNlLWlmPVwiYXBwZW5kXCI+XG4gICAgICAgICAgICAgICAgPGlucHV0LWdyb3VwLWFwcGVuZCB0ZXh0Pnt7YXBwZW5kfX08L2lucHV0LWdyb3VwLWFwcGVuZD5cbiAgICAgICAgICAgIDwvdGVtcGxhdGU+XG4gICAgICAgIDwvc2xvdD5cbiAgICA8L2Rpdj5cblxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBIYXNTbG90cyBmcm9tICcuLi8uLi9NaXhpbnMvSGFzU2xvdHMnO1xuaW1wb3J0IFNpemVhYmxlIGZyb20gJy4uLy4uL01peGlucy9TaXplYWJsZSc7XG5pbXBvcnQgSW5wdXRHcm91cFRleHQgZnJvbSAnLi9JbnB1dEdyb3VwVGV4dCc7XG5pbXBvcnQgQ29sb3JhYmxlIGZyb20gJy4uLy4uL01peGlucy9Db2xvcmFibGUnO1xuaW1wb3J0IElucHV0R3JvdXBBcHBlbmQgZnJvbSAnLi9JbnB1dEdyb3VwQXBwZW5kJztcbmltcG9ydCBJbnB1dEdyb3VwUHJlcGVuZCBmcm9tICcuL0lucHV0R3JvdXBQcmVwZW5kJztcbmltcG9ydCBNZXJnZUNsYXNzZXMgZnJvbSAnLi4vLi4vTWl4aW5zL01lcmdlQ2xhc3Nlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdpbnB1dC1ncm91cCcsXG5cbiAgICBjb21wb25lbnRzOiB7XG4gICAgICAgIElucHV0R3JvdXBUZXh0LFxuICAgICAgICBJbnB1dEdyb3VwQXBwZW5kLFxuICAgICAgICBJbnB1dEdyb3VwUHJlcGVuZFxuICAgIH0sXG5cbiAgICBtaXhpbnM6IFtcbiAgICAgICAgSGFzU2xvdHMsXG4gICAgICAgIFNpemVhYmxlLFxuICAgICAgICBDb2xvcmFibGUsXG4gICAgICAgIE1lcmdlQ2xhc3Nlc1xuICAgIF0sXG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIGFwcGVuZDogW0FycmF5LCBOdW1iZXIsIFN0cmluZ10sXG5cbiAgICAgICAgcHJlcGVuZDogW0FycmF5LCBOdW1iZXIsIFN0cmluZ11cblxuICAgIH1cblxufVxuXG48L3NjcmlwdD5cbiIsImltcG9ydCBJbnB1dEdyb3VwIGZyb20gJy4vSW5wdXRHcm91cCc7XG5pbXBvcnQgSW5wdXRHcm91cEFwcGVuZCBmcm9tICcuL0lucHV0R3JvdXBBcHBlbmQnO1xuaW1wb3J0IElucHV0R3JvdXBQcmVwZW5kIGZyb20gJy4vSW5wdXRHcm91cFByZXBlbmQnO1xuaW1wb3J0IElucHV0R3JvdXBUZXh0IGZyb20gJy4vSW5wdXRHcm91cFRleHQnO1xuaW1wb3J0IFZ1ZUluc3RhbGxlciBmcm9tICcuLi8uLi9IZWxwZXJzL1Z1ZUluc3RhbGxlci9WdWVJbnN0YWxsZXInO1xuXG5jb25zdCBwbHVnaW4gPSBWdWVJbnN0YWxsZXIudXNlKHtcblxuICAgIGluc3RhbGwoVnVlLCBvcHRpb25zKSB7XG4gICAgICAgIFZ1ZUluc3RhbGxlci5jb21wb25lbnRzKHtcbiAgICAgICAgICAgIElucHV0R3JvdXAsXG4gICAgICAgICAgICBJbnB1dEdyb3VwQXBwZW5kLFxuICAgICAgICAgICAgSW5wdXRHcm91cFByZXBlbmQsXG4gICAgICAgICAgICBJbnB1dEdyb3VwVGV4dFxuICAgICAgICB9KTtcbiAgICB9XG5cbn0pO1xuXG5leHBvcnQgKiBmcm9tICcuL0lucHV0R3JvdXBBcHBlbmQnO1xuZXhwb3J0ICogZnJvbSAnLi9JbnB1dEdyb3VwUHJlcGVuZCc7XG5leHBvcnQgKiBmcm9tICcuL0lucHV0R3JvdXBUZXh0JztcbmV4cG9ydCBkZWZhdWx0IElucHV0R3JvdXA7XG4iLCI8dGVtcGxhdGU+XG5cbiAgICA8Zm9ybS1ncm91cD5cblxuICAgICAgICA8c2xvdCBuYW1lPVwibGFiZWxcIj5cbiAgICAgICAgICAgIDxmb3JtLWxhYmVsIHYtaWY9XCJsYWJlbFwiIDpmb3I9XCJpZFwiIHYtaHRtbD1cImxhYmVsXCIgLz5cbiAgICAgICAgPC9zbG90PlxuXG4gICAgICAgIDxkaXYgOmNsYXNzPVwiY29udHJvbENsYXNzZXNcIiB0YWJpbmRleD1cIjBcIiBAY2xpY2s9XCJ0b2dnbGUoKVwiIEBrZXl1cC4zMj1cInRvZ2dsZSgpXCIgQGtleXVwLjM3PVwidG9nZ2xlKG9mZlZhbHVlKVwiIEBrZXl1cC4zOT1cInRvZ2dsZShvblZhbHVlKVwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImxpZ2h0LXN3aXRjaC1oYW5kbGVcIj48L2Rpdj5cbiAgICAgICAgXHQ8ZGl2IGNsYXNzPVwibGlnaHQtc3dpdGNoLWNvbnRhaW5lclwiPlxuICAgICAgICBcdFx0PGRpdiBjbGFzcz1cImxpZ2h0LXN3aXRjaC1sYWJlbCBvbi12YWx1ZVwiPjwvZGl2PlxuICAgICAgICBcdFx0PGRpdiBjbGFzcz1cImxpZ2h0LXN3aXRjaC1sYWJlbCBvZmYtdmFsdWVcIj48L2Rpdj5cbiAgICAgICAgXHQ8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPGZvcm0tY29udHJvbCA6bmFtZT1cIm5hbWVcIiA6dmFsdWU9XCJ2YWx1ZVwiIDppZD1cImlkXCIgY2xhc3M9XCJkLW5vbmVcIi8+XG5cbiAgICAgICAgPHNsb3QgbmFtZT1cImZlZWRiYWNrXCI+XG4gICAgICAgICAgICA8Zm9ybS1mZWVkYmFjayB2LWlmPVwidmFsaWRGZWVkYmFja1wiIHYtaHRtbD1cInZhbGlkRmVlZGJhY2tcIiB2YWxpZCAvPlxuICAgICAgICAgICAgPGZvcm0tZmVlZGJhY2sgdi1pZj1cImludmFsaWRGZWVkYmFja1wiIHYtaHRtbD1cImludmFsaWRGZWVkYmFja1wiIGludmFsaWQgLz5cbiAgICAgICAgPC9zbG90PlxuXG4gICAgICAgIDxzbG90IG5hbWU9XCJoZWxwXCI+XG4gICAgICAgICAgICA8aGVscC10ZXh0IHYtaWY9XCJoZWxwVGV4dFwiIHYtaHRtbD1cImhlbHBUZXh0XCIgLz5cbiAgICAgICAgPC9zbG90PlxuXG4gICAgPC9mb3JtLWdyb3VwPlxuXG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IEhlbHBUZXh0IGZyb20gJy4uL0hlbHBUZXh0JztcbmltcG9ydCBGb3JtR3JvdXAgZnJvbSAnLi4vRm9ybUdyb3VwJztcbmltcG9ydCBGb3JtTGFiZWwgZnJvbSAnLi4vRm9ybUxhYmVsJztcbmltcG9ydCBGb3JtRmVlZGJhY2sgZnJvbSAnLi4vRm9ybUZlZWRiYWNrJztcbmltcG9ydCB7IGlzVW5kZWZpbmVkIH0gZnJvbSAnbG9kYXNoLWVzJ1xuaW1wb3J0IEZvcm1Db250cm9sIGZyb20gJy4uL0Zvcm1Db250cm9sJztcbmltcG9ydCBGb3JtQ29udHJvbE1peGluIGZyb20gJy4uLy4uL01peGlucy9Gb3JtQ29udHJvbCc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdsaWdodC1zd2l0Y2gtZmllbGQnLFxuXG4gICAgY29tcG9uZW50czoge1xuICAgICAgICBIZWxwVGV4dCxcbiAgICAgICAgRm9ybUdyb3VwLFxuICAgICAgICBGb3JtTGFiZWwsXG4gICAgICAgIEZvcm1Db250cm9sLFxuICAgICAgICBGb3JtRmVlZGJhY2tcbiAgICB9LFxuXG4gICAgbWl4aW5zOiBbXG4gICAgICAgIEZvcm1Db250cm9sTWl4aW5cbiAgICBdLFxuXG4gICAgcHJvcHM6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNsYXNzIG5hbWUgYXNzaWduZWQgdG8gdGhlIGNvbnRyb2wgZWxlbWVudFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBkZWZhdWx0Q29udHJvbENsYXNzOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAnZm9ybS1jb250cm9sIGxpZ2h0LXN3aXRjaCdcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNsYXNzIG5hbWUgYXNzaWduZWQgdG8gdGhlIGNvbnRyb2wgZWxlbWVudFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBhY3RpdmVDbGFzczoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJ29uJ1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY2xhc3MgbmFtZSBhc3NpZ25lZCB0byB0aGUgY29udHJvbCBlbGVtZW50XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIG9uVmFsdWU6IHtcbiAgICAgICAgICAgIGRlZmF1bHQ6IDFcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNsYXNzIG5hbWUgYXNzaWduZWQgdG8gdGhlIGNvbnRyb2wgZWxlbWVudFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBvZmZWYWx1ZToge1xuICAgICAgICAgICAgZGVmYXVsdDogMFxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgY29tcHV0ZWQ6IHtcblxuICAgICAgICBpc0FjdGl2ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSA9PT0gdGhpcy5vblZhbHVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNvbnRyb2xDbGFzc2VzKCkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRyb2xDbGFzcyxcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRyb2xTaXplQ2xhc3MsXG4gICAgICAgICAgICAgICAgKHRoaXMuc3BhY2luZyB8fCAnJyksXG4gICAgICAgICAgICAgICAgKHRoaXMuaW52YWxpZEZlZWRiYWNrID8gJ2lzLWludmFsaWQnIDogJycpLFxuICAgICAgICAgICAgICAgICh0aGlzLmRyYWdnaW5nID8gJ2lzLWRyYWdnaW5nJyA6ICcnKSxcbiAgICAgICAgICAgICAgICAodGhpcy5pc0FjdGl2ZSA/ICdpcy1hY3RpdmUnIDogJycpXG4gICAgICAgICAgICBdLmpvaW4oJyAnKTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIG1ldGhvZHM6IHtcblxuICAgICAgICBnZXRUcmFuc2l0aW9uSW5NaWxsaXNlY29uZHMoKSB7XG4gICAgICAgICAgICBjb25zdCBkdXJhdGlvbiA9IGdldENvbXB1dGVkU3R5bGUodGhpcy4kZWwucXVlcnlTZWxlY3RvcignLmxpZ2h0LXN3aXRjaC1oYW5kbGUnKSkudHJhbnNpdGlvbkR1cmF0aW9uO1xuICAgICAgICAgICAgY29uc3QgbnVtZXJpYyA9IHBhcnNlRmxvYXQoZHVyYXRpb24sIDEwKTtcbiAgICAgICAgICAgIGNvbnN0IHVuaXQgPSBkdXJhdGlvbi5tYXRjaCgvbT9zLyk7XG5cbiAgICAgICAgICAgIHN3aXRjaCAodW5pdFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVtZXJpYyAqIDEwMDA7XG4gICAgICAgICAgICAgICAgY2FzZSAnbXMnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVtZXJpYztcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHt1bml0WzBdfVwiIGlzIG5vdCBhIHZhbGlkIHVuaXQgb2YgbWVhc3VyZS4gVW5pdCBtdXN0IGJlIFwic1wiIChzZWNvbmRzKSBvciBcIm1zXCIgKG1pbGxpc2Vjb25kcykuYCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdG9nZ2xlKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCdpbnB1dCcsICFpc1VuZGVmaW5lZCh2YWx1ZSkgPyB2YWx1ZSA6ICh0aGlzLmlzQWN0aXZlID8gdGhpcy5vZmZWYWx1ZSA6IHRoaXMub25WYWx1ZSkpO1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgd2F0Y2g6IHtcbiAgICAgICAgdmFsdWUoKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nID0gdHJ1ZTtcblxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgfSwgdGhpcy5nZXRUcmFuc2l0aW9uSW5NaWxsaXNlY29uZHMoKSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRyYWdnaW5nOiBmYWxzZVxuICAgICAgICB9O1xuICAgIH1cblxufVxuXG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJzY3NzXCI+XG5AaW1wb3J0ICcuL25vZGVfbW9kdWxlcy9ib290c3RyYXAvc2Nzcy9mdW5jdGlvbnMuc2Nzcyc7XG5AaW1wb3J0ICcuL25vZGVfbW9kdWxlcy9ib290c3RyYXAvc2Nzcy92YXJpYWJsZXMuc2Nzcyc7XG5AaW1wb3J0ICcuL25vZGVfbW9kdWxlcy9ib290c3RyYXAvc2Nzcy9taXhpbnMuc2Nzcyc7XG5cbiRsaWdodC1zd2l0Y2gtYW5pbWF0aW9uLWVhc2luZzogZWFzZTtcbiRsaWdodC1zd2l0Y2gtYW5pbWF0aW9uLWxlbmd0aDogMXMgLyAzO1xuJGxpZ2h0LXN3aXRjaC1oYW5kbGUtd2lkdGg6ICRmb250LXNpemUtYmFzZSAqIDI7XG4kbGlnaHQtc3dpdGNoLWhhbmRsZS1oZWlnaHQ6ICRsaWdodC1zd2l0Y2gtaGFuZGxlLXdpZHRoO1xuJGxpZ2h0LXN3aXRjaC1zaXplLXdpZHRoOiAkbGlnaHQtc3dpdGNoLWhhbmRsZS13aWR0aCAqIDEuNTtcbiRsaWdodC1zd2l0Y2gtc2l6ZS1oZWlnaHQ6ICRsaWdodC1zd2l0Y2gtaGFuZGxlLWhlaWdodDtcbiRsaWdodC1zd2l0Y2gtbGFiZWwtd2lkdGg6ICRsaWdodC1zd2l0Y2gtaGFuZGxlLXdpZHRoO1xuJGxpZ2h0LXN3aXRjaC1sYWJlbC1oZWlnaHQ6ICRsaWdodC1zd2l0Y2gtaGFuZGxlLWhlaWdodDtcblxuQG1peGluIGxpZ2h0LXN3aXRjaC1zaXplKCRzaXplLCAkbW9kaWZpZXIpIHtcbiAgICAkaGFuZGxlLXdpZHRoOiAkbGlnaHQtc3dpdGNoLWhhbmRsZS13aWR0aCAqICRtb2RpZmllcjtcbiAgICAkaGFuZGxlLWhlaWdodDogJGhhbmRsZS13aWR0aDtcbiAgICAkc2l6ZS13aWR0aDogJGhhbmRsZS13aWR0aCAqIDEuNTtcbiAgICAkc2l6ZS1oZWlnaHQ6ICRoYW5kbGUtaGVpZ2h0O1xuICAgICRsYWJlbC13aWR0aDogJGhhbmRsZS13aWR0aDtcbiAgICAkbGFiZWwtaGVpZ2h0OiAkaGFuZGxlLWhlaWdodDtcblxuICAgICYubGlnaHQtc3dpdGNoLSN7JHNpemV9IHtcbiAgICAgICAgcGFkZGluZzogMDtcbiAgICBcdHdpZHRoOiAkc2l6ZS13aWR0aDtcbiAgICBcdGhlaWdodDogJGhhbmRsZS1oZWlnaHQ7XG4gICAgXHRib3JkZXItcmFkaXVzOiAkaGFuZGxlLXdpZHRoO1xuXG4gICAgICAgIC5saWdodC1zd2l0Y2gtaGFuZGxlIHtcbiAgICAgICAgICAgIHdpZHRoOiAkaGFuZGxlLXdpZHRoO1xuICAgICAgICAgICAgaGVpZ2h0OiAkaGFuZGxlLWhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIC5saWdodC1zd2l0Y2gtY29udGFpbmVyIHtcbiAgICAgICAgICAgIGxlZnQ6IC0kaGFuZGxlLXdpZHRoIC8gMjtcbiAgICAgICAgICAgIHdpZHRoOiAkbGFiZWwtd2lkdGggKiAyO1xuICAgICAgICAgICAgaGVpZ2h0OiAkbGFiZWwtaGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgJi5pcy1hY3RpdmUge1xuICAgICAgICAgICAgLmxpZ2h0LXN3aXRjaC1oYW5kbGUge1xuICAgICAgICAgICAgICAgIGxlZnQ6ICRoYW5kbGUtd2lkdGggLyAyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLmxpZ2h0LXN3aXRjaC1sYWJlbCB7XG4gICAgICAgICAgICB3aWR0aDogJGxhYmVsLXdpZHRoO1xuICAgICAgICAgICAgaGVpZ2h0OiAkbGFiZWwtaGVpZ2h0O1xuXG4gICAgICAgICAgICAmLm9uLXZhbHVlIHtcbiAgICAgICAgICAgICAgICAvL2JvcmRlci1yYWRpdXM6ICRoYW5kbGUtd2lkdGggMCAwICRoYW5kbGUtd2lkdGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICYub2ZmLXZhbHVlIHtcbiAgICAgICAgICAgICAgICAvL2JvcmRlci1yYWRpdXM6IDAgJGhhbmRsZS13aWR0aCAkaGFuZGxlLXdpZHRoIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi5saWdodC1zd2l0Y2gge1xuICAgIHBhZGRpbmc6IDA7XG5cdHBvc2l0aW9uOiByZWxhdGl2ZTtcblx0Ym9yZGVyOiBub25lO1xuXHR3aWR0aDogJGxpZ2h0LXN3aXRjaC1zaXplLXdpZHRoO1xuXHRoZWlnaHQ6ICRsaWdodC1zd2l0Y2gtaGFuZGxlLWhlaWdodDtcblx0Ym9yZGVyLXJhZGl1czogJGxpZ2h0LXN3aXRjaC1oYW5kbGUtd2lkdGg7XG5cdG92ZXJmbG93OiBoaWRkZW47XG5cdGN1cnNvcjogcG9pbnRlcjtcblx0LXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcblx0LW1vei11c2VyLXNlbGVjdDogbm9uZTtcblx0LW1zLXVzZXItc2VsZWN0OiBub25lO1xuXHRvdmVyZmxvdzogaGlkZGVuO1xuXG4gICAgQGluY2x1ZGUgbGlnaHQtc3dpdGNoLXNpemUoJ3hzJywgLjUpO1xuICAgIEBpbmNsdWRlIGxpZ2h0LXN3aXRjaC1zaXplKCdzbScsIC43NSk7XG4gICAgQGluY2x1ZGUgbGlnaHQtc3dpdGNoLXNpemUoJ21kJywgMSk7XG4gICAgQGluY2x1ZGUgbGlnaHQtc3dpdGNoLXNpemUoJ2xnJywgMS41KTtcbiAgICBAaW5jbHVkZSBsaWdodC1zd2l0Y2gtc2l6ZSgneGwnLCAyKTtcblxuICAgIEBpbmNsdWRlIGZvcm0tdmFsaWRhdGlvbi1zdGF0ZShcInZhbGlkXCIsICRmb3JtLWZlZWRiYWNrLXZhbGlkLWNvbG9yKTtcbiAgICBAaW5jbHVkZSBmb3JtLXZhbGlkYXRpb24tc3RhdGUoXCJpbnZhbGlkXCIsICRmb3JtLWZlZWRiYWNrLWludmFsaWQtY29sb3IpO1xuXG4gICAgJi5pcy1pbnZhbGlkIHtcbiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgJGZvcm0tZmVlZGJhY2staW52YWxpZC1jb2xvcjtcblxuICAgICAgICAmIC5saWdodC1zd2l0Y2gtaGFuZGxlIHtcblxuXG4gICAgICAgIH1cblxuICAgICAgICAmOm5vdCguaXMtYWN0aXZlKSAubGlnaHQtc3dpdGNoLWhhbmRsZSB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiAkZm9ybS1mZWVkYmFjay1pbnZhbGlkLWNvbG9yO1xuICAgICAgICB9XG5cbiAgICAgICAgLmxpZ2h0LXN3aXRjaC1sYWJlbCB7XG4gICAgICAgICAgICAmLm9uLXZhbHVlIHtcbiAgICAgICAgICAgICAgICBsZWZ0OiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJi5vZmYtdmFsdWUge1xuICAgICAgICAgICAgICAgIHJpZ2h0OiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLmxpZ2h0LXN3aXRjaC1oYW5kbGUge1xuICAgICAgICB0b3A6IDA7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIHotaW5kZXg6IDE7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogMTAwJTtcbiAgICAgICAgdHJhbnNpdGlvbjogbGVmdCAkbGlnaHQtc3dpdGNoLWFuaW1hdGlvbi1sZW5ndGggJGxpZ2h0LXN3aXRjaC1hbmltYXRpb24tZWFzaW5nO1xuICAgICAgICB3aWR0aDogJGxpZ2h0LXN3aXRjaC1oYW5kbGUtd2lkdGg7XG4gICAgICAgIGhlaWdodDogJGxpZ2h0LXN3aXRjaC1oYW5kbGUtaGVpZ2h0O1xuICAgICAgICBiYWNrZ3JvdW5kOiB3aGl0ZTtcbiAgICAgICAgYmFja2dyb3VuZC1pbWFnZTogcmFkaWFsLWdyYWRpZW50KHdoaXRlLCByZ2IoMjUwLCAyNTAsIDI1MCkgNTAlLCB3aGl0ZSA3NSUpO1xuICAgICAgICBib3gtc2hhZG93OiBpbnNldCAwIDAgMCAxcHggcmdiYSgwLCAwLCAwLCAwLjEpLCAwIDAgMCAxcHggcmdiYSgwLCAwLCAwLCAwLjEpO1xuICAgIH1cblxuICAgIC5saWdodC1zd2l0Y2gtY29udGFpbmVyIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBsZWZ0OiAtJGxpZ2h0LXN3aXRjaC1oYW5kbGUtd2lkdGggLyAyO1xuICAgICAgICB0b3A6ICgkbGlnaHQtc3dpdGNoLWhhbmRsZS1oZWlnaHQgLSAgJGxpZ2h0LXN3aXRjaC1sYWJlbC1oZWlnaHQpIC8gMjtcbiAgICAgICAgd2lkdGg6ICRsaWdodC1zd2l0Y2gtbGFiZWwtd2lkdGggKiAyO1xuICAgICAgICBoZWlnaHQ6ICRsaWdodC1zd2l0Y2gtbGFiZWwtaGVpZ2h0O1xuICAgICAgICB0cmFuc2l0aW9uOiBsZWZ0ICRsaWdodC1zd2l0Y2gtYW5pbWF0aW9uLWxlbmd0aCAkbGlnaHQtc3dpdGNoLWFuaW1hdGlvbi1lYXNpbmc7XG4gICAgfVxuXG4gICAgJjpub3QoLmlzLWFjdGl2ZSkge1xuICAgICAgICAmOm5vdCguaXMtZHJhZ2dpbmcpIC5vbi12YWx1ZSB7XG4gICAgICAgICAgICB2aXNpYmlsaXR5OiBoaWRkZW47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAmLmlzLWFjdGl2ZSB7XG4gICAgICAgICY6bm90KC5pcy1kcmFnZ2luZykgLm9mZi12YWx1ZSB7XG4gICAgICAgICAgICB2aXNpYmlsaXR5OiBoaWRkZW47XG4gICAgICAgIH1cblxuICAgICAgICAubGlnaHQtc3dpdGNoLWhhbmRsZSB7XG4gICAgICAgICAgICBsZWZ0OiAkbGlnaHQtc3dpdGNoLWhhbmRsZS13aWR0aCAvIDI7XG4gICAgICAgIH1cblxuICAgICAgICAubGlnaHQtc3dpdGNoLWNvbnRhaW5lciB7XG4gICAgICAgICAgICBsZWZ0OiAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLmxpZ2h0LXN3aXRjaC1sYWJlbCB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgd2lkdGg6ICRsaWdodC1zd2l0Y2gtbGFiZWwtd2lkdGg7XG4gICAgICAgIGhlaWdodDogJGxpZ2h0LXN3aXRjaC1sYWJlbC1oZWlnaHQ7XG4gICAgICAgIC8vYm94LXNoYWRvdzogaW5zZXQgMCAwIDAgMXB4IHJnYmEoMCwgMCwgMCwgMC4xKTtcblxuICAgICAgICAmLm9uLXZhbHVlIHtcbiAgICAgICAgICAgIGxlZnQ6IDA7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiAjMDBiMDA3O1xuICAgICAgICAgICAgLy9ib3JkZXItcmFkaXVzOiAkbGlnaHQtc3dpdGNoLWhhbmRsZS13aWR0aCAwIDAgJGxpZ2h0LXN3aXRjaC1oYW5kbGUtd2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICAmLm9mZi12YWx1ZSB7XG4gICAgICAgICAgICByaWdodDogMDtcbiAgICAgICAgICAgIGJhY2tncm91bmQ6ICNlYmVkZWY7XG4gICAgICAgICAgICAvL2JvcmRlci1yYWRpdXM6IDAgJGxpZ2h0LXN3aXRjaC1oYW5kbGUtd2lkdGggJGxpZ2h0LXN3aXRjaC1oYW5kbGUtd2lkdGggMDtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5cbjwvc3R5bGU+XG4iLCJpbXBvcnQgTGlnaHRTd2l0Y2hGaWVsZCBmcm9tICcuL0xpZ2h0U3dpdGNoRmllbGQnO1xuaW1wb3J0IFZ1ZUluc3RhbGxlciBmcm9tICcuLi8uLi9IZWxwZXJzL1Z1ZUluc3RhbGxlci9WdWVJbnN0YWxsZXInO1xuXG5jb25zdCBwbHVnaW4gPSBWdWVJbnN0YWxsZXIudXNlKHtcblxuICAgIGluc3RhbGwoVnVlLCBvcHRpb25zKSB7XG4gICAgICAgIFZ1ZUluc3RhbGxlci5jb21wb25lbnRzKHtcbiAgICAgICAgICAgIExpZ2h0U3dpdGNoRmllbGRcbiAgICAgICAgfSk7XG4gICAgfVxuXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgTGlnaHRTd2l0Y2hGaWVsZDtcbiIsIjx0ZW1wbGF0ZT5cbiAgICA8cm91dGVyLWxpbmsgdi1pZj1cInRvXCIgOnRvPVwidG9cIiA6Y2xhc3M9XCJjbGFzc2VzXCIgQGNsaWNrPVwiJGVtaXQoJ2NsaWNrJywgJGV2ZW50KVwiPlxuICAgICAgICA8c2xvdD57e2xhYmVsfX08L3Nsb3Q+IDxiYWRnZSB2LWlmPVwiYmFkZ2VcIiB2LWJpbmQ9XCJiYWRnZU9wdGlvbnNcIj48L2JhZGdlPlxuICAgIDwvcm91dGVyLWxpbms+XG4gICAgPGEgdi1lbHNlaWY9XCJocmVmXCIgOmhyZWY9XCJocmVmXCIgOmNsYXNzPVwiY2xhc3Nlc1wiIEBjbGljaz1cIiRlbWl0KCdjbGljaycsICRldmVudClcIj5cbiAgICAgICAgPHNsb3Q+e3tsYWJlbH19PC9zbG90PiA8YmFkZ2Ugdi1pZj1cImJhZGdlXCIgdi1iaW5kPVwiYmFkZ2VPcHRpb25zXCI+PC9iYWRnZT5cbiAgICA8L2E+XG4gICAgPGJ1dHRvbiB2LWVsc2UtaWY9XCJhY3Rpb25cIiB0eXBlPVwiYnV0dG9uXCIgOmNsYXNzPVwiY2xhc3Nlc1wiIEBjbGljay5wcmV2ZW50PVwiJGVtaXQoJ2NsaWNrJywgJGV2ZW50KVwiPlxuICAgICAgICA8c2xvdD57e2xhYmVsfX08L3Nsb3Q+IDxiYWRnZSB2LWlmPVwiYmFkZ2VcIiB2LWJpbmQ9XCJiYWRnZU9wdGlvbnNcIj48L2JhZGdlPlxuICAgIDwvYnV0dG9uPlxuICAgIDxkaXYgdi1lbHNlIDpjbGFzcz1cImNsYXNzZXNcIiBAY2xpY2s9XCIkZW1pdCgnY2xpY2snLCAkZXZlbnQpXCI+XG4gICAgICAgIDxzbG90Pnt7bGFiZWx9fTwvc2xvdD4gPGJhZGdlIHYtaWY9XCJiYWRnZVwiIHYtYmluZD1cImJhZGdlT3B0aW9uc1wiPjwvYmFkZ2U+XG4gICAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuXG5pbXBvcnQgeyBpc09iamVjdCB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgQmFkZ2UgZnJvbSAnLi4vQmFkZ2UnO1xuaW1wb3J0IHByZWZpeCBmcm9tICcuLi8uLi9IZWxwZXJzL1ByZWZpeC9QcmVmaXgnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBjb21wb25lbnRzOiB7XG4gICAgICAgIEJhZGdlXG4gICAgfSxcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBiYWRnZSBsYWJlbCAoaWYgbnVtYmVyIG9yIHN0cmluZykgb3Igb2JqZWN0IG9mIG9wdGlvbnMgdG8gcGFzcyB0b1xuICAgICAgICAgKiB0aGUgY29tcG9uZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nfE9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgYmFkZ2U6IFtOdW1iZXIsIFN0cmluZywgT2JqZWN0XSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGxpc3QgZ3JvdXAgaXRlbSBocmVmIGF0dHJpYnV0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgaHJlZjogU3RyaW5nLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbGlzdCBncm91cCBpdGVtIHZhcmlhbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHZhcmlhbnQ6IFN0cmluZyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogT3B0aW9uYWxseSBwYXNzIHRoZSBpdGVtIGFzIGEgb2JqZWN0IHRvIHVzZSBwcm9ncmFtbWF0aWNhbGx5IGxhdGVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBpdGVtOiBPYmplY3QsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsaXN0IGdyb3VwIGl0ZW0gYW4gYWN0aW9uLCBvciBjbGlja2FibGUgaXRlbS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IEJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIGFjdGlvbjoge1xuICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsaXN0IGdyb3VwIGl0ZW0gYWN0aXZlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgQm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgYWN0aXZlOiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGxpc3QgZ3JvdXAgaXRlbSBkaXNhYmxlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IEJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIGRpc2FibGVkOiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGxpc3QgaXRlbSBsYWJlbC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IE9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICAgIHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sXG4gICAgICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdG8gYXR0cmlidXRlIHRvIGJlIHBhc3NlZCB0byBhIDxyb3V0ZXItbGluaz4gY29tcG9uZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICB0bzogW1N0cmluZywgT2JqZWN0XVxuXG4gICAgfSxcblxuICAgIGNvbXB1dGVkOiB7XG5cbiAgICAgICAgY2xhc3NlcygpIHtcbiAgICAgICAgICAgIGNvbnN0IGNsYXNzZXMgPSBwcmVmaXgoe1xuICAgICAgICAgICAgICAgICdhY3Rpb24nOiB0aGlzLmFjdGlvbixcbiAgICAgICAgICAgIH0sICdsaXN0LWdyb3VwLWl0ZW0nKTtcblxuICAgICAgICAgICAgY2xhc3Nlc1snbGlzdC1ncm91cC1pdGVtJ10gPSB0cnVlO1xuICAgICAgICAgICAgY2xhc3Nlc1snYWN0aXZlJ10gPSB0aGlzLmFjdGl2ZTtcbiAgICAgICAgICAgIGNsYXNzZXNbJ2Rpc2FibGVkJ10gPSB0aGlzLmRpc2FibGVkO1xuXG4gICAgICAgICAgICBpZih0aGlzLnZhcmlhbnQpIHtcbiAgICAgICAgICAgICAgICBjbGFzc2VzW3ByZWZpeCh0aGlzLnZhcmlhbnQsICdsaXN0LWdyb3VwLWl0ZW0nKV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY2xhc3NlcztcbiAgICAgICAgfSxcblxuICAgICAgICBiYWRnZU9wdGlvbnMoKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNPYmplY3QodGhpcy5iYWRnZSkgPyB0aGlzLmJhZGdlIDoge1xuICAgICAgICAgICAgICAgIGxhYmVsOiB0aGlzLmJhZGdlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgd2F0Y2g6IHtcblxuICAgICAgICBhY3RpdmUodmFsdWUsIHByZXZWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgndG9nZ2xlJywgdmFsdWUpO1xuICAgICAgICAgICAgdGhpcy4kZW1pdCghIXZhbHVlID8gJ2FjdGl2YXRlJyA6ICdkZWFjdGl2YXRlJyk7XG4gICAgICAgIH1cblxuICAgIH0sXG5cblxufVxuXG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgICA8ZGl2IGNsYXNzPVwibGlzdC1ncm91cFwiIDpjbGFzcz1cImNsYXNzZXNcIj5cbiAgICAgICAgPHNsb3QvPlxuICAgIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cblxuaW1wb3J0IHsgZWFjaCB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgTGlzdEdyb3VwSXRlbSBmcm9tICcuL0xpc3RHcm91cEl0ZW0nO1xuaW1wb3J0IHByZWZpeCBmcm9tICcuLi8uLi9IZWxwZXJzL1ByZWZpeC9QcmVmaXgnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBjb21wb25lbnRzOiB7XG4gICAgICAgIExpc3RHcm91cEl0ZW1cbiAgICB9LFxuXG4gICAgcHJvcHM6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGxpc3QgZ3JvdXAgYXBwZWFyIGZsdXNoICh3aXRob3V0IHNvbWUgYm9yZGVycykuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBCb29sZWFuXG4gICAgICAgICAqL1xuICAgICAgICBmbHVzaDoge1xuICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbiBhY3RpdmF0ZSBtdWx0aXBsZSBsaXN0IGl0ZW1zXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBCb29sZWFuXG4gICAgICAgICAqL1xuICAgICAgICBtdWx0aXBsZToge1xuICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBjb21wdXRlZDoge1xuICAgICAgICBjbGFzc2VzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHByZWZpeCh7XG4gICAgICAgICAgICAgICAgJ2ZsdXNoJzogdGhpcy5mbHVzaFxuICAgICAgICAgICAgfSwgJ2xpc3QtZ3JvdXAnKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtZXRob2RzOiB7XG5cbiAgICAgICAgYmluZEV2ZW50c1RvQ2hpbGRyZW4oKSB7XG4gICAgICAgICAgICBlYWNoKHRoaXMuJGNoaWxkcmVuLCBjaGlsZCA9PiB7XG4gICAgICAgICAgICAgICAgY2hpbGQuJG9mZignY2xpY2snLCBldmVudCA9PiB0aGlzLm9uQ2xpY2tJdGVtKGV2ZW50LCBjaGlsZCkpO1xuICAgICAgICAgICAgICAgIGNoaWxkLiRvbignY2xpY2snLCBldmVudCA9PiB0aGlzLm9uQ2xpY2tJdGVtKGV2ZW50LCBjaGlsZCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjYWxsYmFjayBmdW5jdGlvbiBmb3IgdGhlIGBjbGlja2AgZXZlbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAgICAgKi9cbiAgICAgICAgb25DbGljayhldmVudCkge1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgnY2xpY2snLCBldmVudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjYWxsYmFjayBmdW5jdGlvbiBmb3IgdGhlIGNoaWxkIGBjbGlja2AgZXZlbnRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgICAgICovXG4gICAgICAgIG9uQ2xpY2tJdGVtKGV2ZW50LCBjaGlsZCkge1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgnaXRlbTpjbGljaycsIGV2ZW50LCBjaGlsZCk7XG4gICAgICAgIH0sXG5cbiAgICB9LFxuXG4gICAgbW91bnRlZCgpIHtcbiAgICAgICAgdGhpcy5iaW5kRXZlbnRzVG9DaGlsZHJlbigpO1xuICAgIH0sXG5cbiAgICB1cGRhdGVkKCkge1xuICAgICAgICB0aGlzLmJpbmRFdmVudHNUb0NoaWxkcmVuKCk7XG4gICAgfVxuXG59XG5cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IExpc3RHcm91cCBmcm9tICcuL0xpc3RHcm91cCc7XG5pbXBvcnQgVnVlSW5zdGFsbGVyIGZyb20gJy4uLy4uL0hlbHBlcnMvVnVlSW5zdGFsbGVyL1Z1ZUluc3RhbGxlcic7XG5cbmNvbnN0IHBsdWdpbiA9IFZ1ZUluc3RhbGxlci51c2Uoe1xuXG4gICAgaW5zdGFsbChWdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgVnVlSW5zdGFsbGVyLmNvbXBvbmVudHMoe1xuICAgICAgICAgICAgTGlzdEdyb3VwXG4gICAgICAgIH0pO1xuICAgIH1cblxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IExpc3RHcm91cDtcbiIsIjx0ZW1wbGF0ZT5cbiAgICA8Y29tcG9uZW50IGNsYXNzPVwibmF2YmFyLWJyYW5kXCIgOmNsYXNzPVwieydoMSc6IGgxfVwiIDppcz1cImNvbXBvbmVudFwiIDp0bz1cInRvXCIgOmhyZWY9XCJocmVmXCI+XG4gICAgICAgIDxpbWcgdi1pZj1cInNyY1wiIGNsYXNzPVwiZC1pbmxpbmUtYmxvY2sgYWxpZ24tY2VudGVyXCIgOnNyYz1cInNyY1wiIDp3aWR0aD1cInVuaXQod2lkdGgpXCIgOmhlaWdodD1cInVuaXQoaGVpZ2h0KVwiIDphbHQ9XCJhbHRcIi8+XG4gICAgICAgIDxzbG90Lz5cbiAgICA8L2NvbXBvbmVudD5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgdW5pdCBmcm9tICcuLi8uLi9IZWxwZXJzL1VuaXQnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaW1nIGBhbHRgIGF0dHJpYnV0ZS4gYHNyY2AgbXVzdCBiZSBkZWZpbmUgYmVmb3JlIHRoaXMgcHJvcCBoYXNcbiAgICAgICAgICogYW55IGFmZmVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IE9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgYWx0OiBTdHJpbmcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBIVE1MIHdyYXBwaW5nIHRhZy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IE9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgdGFnOiBTdHJpbmcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBpbWcgYHdpZHRoYCBhdHRyaWJ1dGUuIGBzcmNgIG11c3QgYmUgZGVmaW5lIGJlZm9yZSB0aGlzIHByb3AgaGFzXG4gICAgICAgICAqIGFueSBhZmZlY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBPYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIHdpZHRoOiBbTnVtYmVyLCBTdHJpbmddLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaW1nIGBoZWlnaHRgIGF0dHJpYnV0ZS4gYHNyY2AgbXVzdCBiZSBkZWZpbmUgYmVmb3JlIHRoaXMgcHJvcCBoYXNcbiAgICAgICAgICogYW55IGFmZmVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IE9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgaGVpZ2h0OiBbTnVtYmVyLCBTdHJpbmddLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYHRvYCBhdHRyaWJ1dGUgdGhhdCBpcyBwYXNzZWQgdG8gdGhlIGNvbXBvbmVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IE9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgdG86IFtPYmplY3QsIFN0cmluZ10sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBgaHJlZmAgYXR0cmlidXRlIHRoYXQgaXMgcGFzc2VkIHRvIHRoZSBjb21wb25lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBPYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIGhyZWY6IFN0cmluZyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQXBwZW5kIHRoZSBgaDFgIGNsYXNzIHRvIGluY3JlYXNlIHRoZSBkaXNwbGF5IHNpemVcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IE9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgaDE6IEJvb2xlYW4sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGEgYHNyY2AgYXR0cmlidXRlIGlzIHBhc3NlZCwgdGhlbiB1c2UgaXQgdG8gYWRkIGFuIGltZyB0YWdcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IE9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgc3JjOiBTdHJpbmcsXG5cbiAgICB9LFxuXG4gICAgY29tcHV0ZWQ6IHtcblxuICAgICAgICBjb21wb25lbnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50YWcgfHwgKHRoaXMudG8gPyAncm91dGVyLWxpbmsnIDogKHRoaXMuaHJlZiA/ICdhJyA6ICdzcGFuJykpO1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgbWV0aG9kczoge1xuICAgICAgICB1bml0KHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5pdCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gICAgPGRpdiBjbGFzcz1cIm5hdmJhci1jb2xsYXBzZVwiIGlkPVwibmF2YmFyQ29sbGFwc2VcIiA6Y2xhc3M9XCJ7J2NvbGxhcHNlJzogY29sbGFwc2V9XCI+XG4gICAgICAgIDxzbG90Lz5cbiAgICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAnbmF2YmFyLWNvbGxhcHNlJyxcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgY29sbGFwc2U6IHtcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgICBkZWZhdWx0OiB0cnVlXG4gICAgICAgIH1cblxuICAgIH1cblxufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gICAgPHNwYW4gY2xhc3M9XCJuYXZiYXItdGV4dFwiPlxuICAgICAgICA8c2xvdC8+XG4gICAgPC9zcGFuPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICduYXZiYXItdGV4dCdcblxufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gICAgPHNwYW4gY2xhc3M9XCJuYXZiYXItdG9nZ2xlci1pY29uXCI+XG4gICAgICAgIDxzbG90Lz5cbiAgICA8L3NwYW4+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ25hdmJhci10b2dnbGVyLWljb24nXG5cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICAgIDxidXR0b25cbiAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgIGNsYXNzPVwibmF2YmFyLXRvZ2dsZXJcIlxuICAgICAgICBkYXRhLXRvZ2dsZT1cImNvbGxhcHNlXCJcbiAgICAgICAgOmRhdGEtdGFyZ2V0PVwidGFyZ2V0XCJcbiAgICAgICAgOmFyaWEtY29udHJvbHM9XCJ0YXJnZXRcIlxuICAgICAgICA6YXJpYS1leHBhbmRlZD1cImV4cGFuZGVkXCJcbiAgICAgICAgOmFyaWEtbGFiZWw9XCJsYWJlbFwiXG4gICAgICAgIEBjbGljaz1cIm9uQ2xpY2tcIj5cbiAgICAgICAgPHNsb3Q+PG5hdmJhci10b2dnbGVyLWljb24vPjwvc2xvdD5cbiAgICA8L2J1dHRvbj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgTmF2YmFyVG9nZ2xlckljb24gZnJvbSAnLi9OYXZiYXJUb2dnbGVySWNvbic7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICduYXZiYXItdG9nZ2xlcicsXG5cbiAgICBjb21wb25lbnRzOiB7XG4gICAgICAgIE5hdmJhclRvZ2dsZXJJY29uXG4gICAgfSxcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgZXhwYW5kZWQ6IEJvb2xlYW4sXG5cbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdUb2dnbGUgbmF2aWdhdGlvbidcbiAgICAgICAgfSxcblxuICAgICAgICB0YXJnZXQ6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICcubmF2YmFyLWNvbGxhcHNlJ1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgbWV0aG9kczoge1xuXG4gICAgICAgIG9uQ2xpY2soZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2NsaWNrJywgZXZlbnQpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbn1cblxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gICAgPG5hdiA6Y2xhc3M9XCJjbGFzc2VzXCI+XG4gICAgICAgIDxzbG90Lz5cbiAgICA8L25hdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgeyBlYWNoIH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCB7IGlzQm9vbGVhbiB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgcHJlZml4IGZyb20gJy4uLy4uL0hlbHBlcnMvUHJlZml4JztcbmltcG9ydCBWYXJpYW50IGZyb20gJy4uLy4uL01peGlucy9WYXJpYW50JztcbmltcG9ydCBDb2xvcmFibGUgZnJvbSAnLi4vLi4vTWl4aW5zL0NvbG9yYWJsZSc7XG5pbXBvcnQgTmF2YmFyQnJhbmQgZnJvbSAnLi9OYXZiYXJCcmFuZCc7XG5pbXBvcnQgTmF2YmFyQ29sbGFwc2UgZnJvbSAnLi9OYXZiYXJDb2xsYXBzZSc7XG5pbXBvcnQgTmF2YmFyVGV4dCBmcm9tICcuL05hdmJhclRleHQnO1xuaW1wb3J0IE5hdmJhclRvZ2dsZXIgZnJvbSAnLi9OYXZiYXJUb2dnbGVyJztcbmltcG9ydCBOYXZiYXJUb2dnbGVySWNvbiBmcm9tICcuL05hdmJhclRvZ2dsZXJJY29uJztcbmltcG9ydCBNZXJnZUNsYXNzZXMgZnJvbSAnLi4vLi4vTWl4aW5zL01lcmdlQ2xhc3Nlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICduYXZiYXInLFxuXG4gICAgY29tcG9uZW50czoge1xuICAgICAgICBOYXZiYXJCcmFuZCxcbiAgICAgICAgTmF2YmFyQ29sbGFwc2UsXG4gICAgICAgIE5hdmJhclRleHQsXG4gICAgICAgIE5hdmJhclRvZ2dsZXIsXG4gICAgICAgIE5hdmJhclRvZ2dsZXJJY29uXG4gICAgfSxcblxuICAgIG1peGluczogW1xuICAgICAgICBWYXJpYW50LFxuICAgICAgICBDb2xvcmFibGUsXG4gICAgICAgIE1lcmdlQ2xhc3Nlc1xuICAgIF0sXG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFeHBhbmQgdGhlIG5hdmJhci4gSWYgdHJ1ZSwgYXBwbGllcyB0byBhbGwgc2l6ZSwgb3RoZXJ3aXNlIHBhc3MgYSBzdHJpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBPYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIGV4cGFuZDoge1xuICAgICAgICAgICAgdHlwZTogW0Jvb2xlYW4sIFN0cmluZ10sXG4gICAgICAgICAgICBkZWZhdWx0OiAnbGcnLFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBbJ3hzJywgJ3NtJywgJ21kJywgJ2xnJywgJ3hsJ10uaW5kZXhPZih2YWx1ZSkgIT09IC0xIHx8IGlzQm9vbGVhbih2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzaG91bGQgdGhlIG5hdmJhciBiZSBmaXhlZCBhdCB0aGUgdG9wLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBmaXhlZDoge1xuICAgICAgICAgICAgdHlwZTogW1N0cmluZywgQm9vbGVhbl0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIFsndG9wJywgJ2JvdHRvbSddLmluZGV4T2YodmFsdWUpICE9PSAtMSB8fCBpc0Jvb2xlYW4odmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc2hvdWxkIHRoZSBuYXZiYXIgYmUgc3RpY2tpZWQgYXQgdGhlIHRvcC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgc3RpY2t5OiB7XG4gICAgICAgICAgICB0eXBlOiBbU3RyaW5nLCBCb29sZWFuXSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgWyd0b3AnLCAnYm90dG9tJ10uaW5kZXhPZih2YWx1ZSkgIT09IC0xIHx8IGlzQm9vbGVhbih2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB2YXJpYW50IGF0dHJpYnV0ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICB2YXJpYW50OiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAnbGlnaHQnLFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWydsaWdodCcsICdkYXJrJ10uaW5kZXhPZih2YWx1ZSkgIT09IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgY29tcHV0ZWQ6IHtcblxuICAgICAgICBleHBhbmRlZENsYXNzKCkge1xuICAgICAgICAgICAgaWYoaXNCb29sZWFuKHRoaXMuZXhwYW5kKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmV4cGFuZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHByZWZpeChwcmVmaXgodGhpcy5leHBhbmQsICdleHBhbmQnKSwgJ25hdmJhcicpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsYXNzZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tZXJnZUNsYXNzZXMoXG4gICAgICAgICAgICAgICAgJ25hdmJhcicsXG4gICAgICAgICAgICAgICAgcHJlZml4KHRoaXMuc3RpY2t5ID09PSB0cnVlID8gJ3RvcCcgOiB0aGlzLnN0aWNreSwgJ3N0aWNreScpLFxuICAgICAgICAgICAgICAgIHByZWZpeCh0aGlzLmZpeGVkID09PSB0cnVlID8gJ3RvcCcgOiB0aGlzLmZpeGVkLCAnZml4ZWQnKSxcbiAgICAgICAgICAgICAgICB0aGlzLmV4cGFuZGVkQ2xhc3MsXG4gICAgICAgICAgICAgICAgdGhpcy52YXJpYW50Q2xhc3MsXG4gICAgICAgICAgICAgICAgdGhpcy5jb2xvcmFibGVDbGFzc2VzXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7fVxuICAgIH1cblxufVxuXG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgICA8c3BhbiBjbGFzcz1cIm5hdmlnYXRpb24tZXJyb3IgZmEtc3RhY2sgZmEtbWRcIiA6dGl0bGU9XCJlcnJvclwiPlxuICAgICAgICA8aSBjbGFzcz1cImZhIGZhLXN0YWNrLTJ4IGZhLWNlcnRpZmljYXRlXCIvPlxuICAgICAgICA8aSBjbGFzcz1cImZhIGZhLXN0YWNrLTF4IGZhLWV4Y2xhbWF0aW9uIGZhLWludmVyc2VcIi8+XG4gICAgPC9zcGFuPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICduYXZpZ2F0aW9uLWVycm9yJyxcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgICAgIH1cblxuICAgIH1cblxufVxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwic2Nzc1wiPlxuQGltcG9ydCAnLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwL3Njc3MvX2Z1bmN0aW9ucy5zY3NzJztcbkBpbXBvcnQgJy4vbm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC9zY3NzL192YXJpYWJsZXMuc2Nzcyc7XG5cbi5uYXZpZ2F0aW9uLWVycm9yIHtcbiAgICBjb2xvcjogJGRhbmdlcjtcbn1cbjwvc3R5bGU+XG4iLCI8dGVtcGxhdGU+XG4gICAgPGNvbXBvbmVudCA6aXM9XCJjb21wb25lbnRcIiA6aHJlZj1cImhyZWYgfHwgKHRvID8gJyMnIDogbnVsbClcIiA6dG89XCJ0b1wiIDpjbGFzcz1cImNsYXNzZXNcIiBAY2xpY2s9XCIkZW1pdCgnY2xpY2snLCAkZXZlbnQpXCI+XG4gICAgICAgIDxzbG90IC8+XG4gICAgICAgIDxuYXZpZ2F0aW9uLWVycm9yIHYtaWY9XCJlcnJvclwiIDplcnJvcj1cImVycm9yXCIvPlxuICAgIDwvY29tcG9uZW50PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBOYXZpZ2F0aW9uRXJyb3IgZnJvbSAnLi9OYXZpZ2F0aW9uRXJyb3InO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAnbmF2aWdhdGlvbi1saW5rJyxcblxuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgICAgTmF2aWdhdGlvbkVycm9yXG4gICAgfSxcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElzIHRoZSBuYXZpZ2F0aW9uIGl0ZW0gYWN0aXZlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wIHtCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgYWN0aXZlOiBCb29sZWFuLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJcyB0aGUgbmF2aWdhdGlvbiBpdGVtIGRpc2FibGVkXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wIHtCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgZGlzYWJsZWQ6IEJvb2xlYW4sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBlcnJvciBzdHJpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wIHtTdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBlcnJvcjogU3RyaW5nLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaHJlZiBhdHRyaWJ1dGVcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3Age1N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIGhyZWY6IFN0cmluZyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNvbXBvbmVudCBIVE1MIHRhZ1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcCB7U3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGFnOiBTdHJpbmcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0byBhdHRyaWJ1dGUsIHdpbGwgYmUgcGFzc2VkIHRvIHJvdXRlci1saW5rLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcCB7U3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdG86IFtPYmplY3QsIFN0cmluZ10sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCB0aGUgbmF2LWl0ZW0gY2xhc3MgdG8gdGhlIGxpbmtcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3Age0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBpdGVtOiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgY29tcHV0ZWQ6IHtcblxuICAgICAgICBjb21wb25lbnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50YWcgfHwgKHRoaXMudG8gPyAncm91dGVyLWxpbmsnIDogJ2EnKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjbGFzc2VzKCkge1xuICAgICAgICAgICAgdGhpcy4kbmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmKCF0aGlzLmlzSXRlbSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzSXRlbSA9ICF0aGlzLiRwYXJlbnQuJGVsLmNsYXNzTGlzdC5jb250YWlucygnbmF2LWl0ZW0nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAnbmF2LWxpbmsnOiAhIXRoaXMuaHJlZiB8fCAhIXRoaXMudG8sXG4gICAgICAgICAgICAgICAgJ25hdi1pdGVtJzogISF0aGlzLml0ZW0sXG4gICAgICAgICAgICAgICAgJ2FjdGl2ZSc6IHRoaXMuYWN0aXZlLFxuICAgICAgICAgICAgICAgICdkaXNhYmxlZCc6IHRoaXMuZGlzYWJsZWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfVxuXG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgICA8Y29tcG9uZW50IDppcz1cImNvbXBvbmVudFwiIDpjbGFzcz1cImNsYXNzZXNcIiBAY2xpY2s9XCIkZW1pdCgnY2xpY2snLCAkZXZlbnQpXCI+XG4gICAgICAgIDxzbG90IC8+XG4gICAgPC9jb21wb25lbnQ+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IE5hdmlnYXRpb25MaW5rIGZyb20gJy4vTmF2aWdhdGlvbkxpbmsnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAnbmF2aWdhdGlvbi1pdGVtJyxcblxuICAgIGV4dGVuZHM6IE5hdmlnYXRpb25MaW5rLFxuXG4gICAgcHJvcHM6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIEhUTUwgZWxlbWVudFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcCB7U3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgZWxlbWVudDogU3RyaW5nLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJcyB0aGUgY29tcG9uZW50IGEgbGlzdCBlbGVtZW50XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wIHtCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgbGlzdDogQm9vbGVhbixcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkIHRoZSBuYXYtaXRlbSBjbGFzcyB0byB0aGUgbGlua1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcCB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGl0ZW06IHtcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgICBkZWZhdWx0OiB0cnVlXG4gICAgICAgIH1cblxuICAgIH0sXG5cblxuICAgIGNvbXB1dGVkOiB7XG5cbiAgICAgICAgY29tcG9uZW50KCkge1xuICAgICAgICAgICAgaWYodGhpcy5lbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYodGhpcy5ocmVmKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdhJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYodGhpcy5saXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdsaSc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAnZGl2JztcbiAgICAgICAgfVxuXG4gICAgfVxuXG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgICA8bmF2IGNsYXNzPVwibmF2XCIgOmNsYXNzPVwiY2xhc3Nlc1wiIDpyb2xlPVwicm9sZVwiPlxuICAgICAgICA8c2xvdC8+XG4gICAgPC9uYXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IE5hdmlnYXRpb25JdGVtIGZyb20gJy4vTmF2aWdhdGlvbkl0ZW0nO1xuaW1wb3J0IHByZWZpeCBmcm9tICcuLi8uLi9IZWxwZXJzL1ByZWZpeCc7XG5pbXBvcnQgQ29sb3JhYmxlIGZyb20gJy4uLy4uL01peGlucy9Db2xvcmFibGUnO1xuaW1wb3J0IE1lcmdlQ2xhc3NlcyBmcm9tICcuLi8uLi9NaXhpbnMvTWVyZ2VDbGFzc2VzJztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ25hdmlnYXRpb24nLFxuXG4gICAgY29tcG9uZW50czoge1xuICAgICAgICBOYXZpZ2F0aW9uSXRlbVxuICAgIH0sXG5cbiAgICBtaXhpbnM6IFtcbiAgICAgICAgQ29sb3JhYmxlLFxuICAgICAgICBNZXJnZUNsYXNzZXNcbiAgICBdLFxuXG4gICAgcHJvcHM6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSGVscGVyIHRvIGFkZCB0aGUganVzdGlmeS1jb250ZW50LVggY2xhc3MuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wIHtBcnJheX1cbiAgICAgICAgICovXG4gICAgICAgIGFsaWduOiBTdHJpbmcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGFycmF5IG9mIGJ1dHRvbnNcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3Age0FycmF5fVxuICAgICAgICAgKi9cbiAgICAgICAgYnV0dG9uczogQXJyYXksXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBuYXZpZ2F0aW9uIGluc2lkZSBhIGNhcmRcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3Age0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBjYXJkOiBCb29sZWFuLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBKdXN0aWZ5IG5hdiBpdGVtcyB0byBmaWxsIHRoZSB3aWR0aCBlcXVhbGx5ICh1c2luZyBmbGV4KS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3Age0FycmF5fVxuICAgICAgICAgKi9cbiAgICAgICAgZmlsbDogQm9vbGVhbixcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkIGBuYXYtanVzdGlmaWVkYCBjbGFzcyB0byB0aGUgY29tcG9uZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcCB7QXJyYXl9XG4gICAgICAgICAqL1xuICAgICAgICBqdXN0aWZpZWQ6IEJvb2xlYW4sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc3BsYXkgaXRlbXMgYXMgcGlsbCBzaGFwZXNcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3Age0FycmF5fVxuICAgICAgICAgKi9cbiAgICAgICAgcGlsbHM6IEJvb2xlYW4sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc3BsYXkgaXRlbXMgYXMgdGFiIHNoYXBlc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcCB7QXJyYXl9XG4gICAgICAgICAqL1xuICAgICAgICB0YWJzOiBCb29sZWFuLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwbGF5IHRoZSBidXR0b25zIHZlcnRpY2FsbHlcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3Age0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB2ZXJ0aWNhbDogQm9vbGVhbixcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHJvbGUgYXR0cmlidXRlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wIHtTdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICByb2xlOiBTdHJpbmdcblxuICAgIH0sXG5cbiAgICBjb21wdXRlZDoge1xuXG4gICAgICAgIGNsYXNzZXMoKSB7XG4gICAgICAgICAgICB0aGlzLiRuZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYoIXRoaXMuaXNDYXJkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNDYXJkID0gdGhpcy4kcGFyZW50LiRlbC5jbGFzc0xpc3QuY29udGFpbnMoJ2NhcmQtaGVhZGVyJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1lcmdlQ2xhc3NlcyhcbiAgICAgICAgICAgICAgICBwcmVmaXgodGhpcy5hbGlnbiwgJ2p1c3RpZnktY29udGVudCcpLFxuICAgICAgICAgICAgICAgIHRoaXMuY29sb3JhYmxlQ2xhc3Nlcywge1xuICAgICAgICAgICAgICAgICAgICAnY2FyZC1oZWFkZXItdGFicyc6IHRoaXMuaXNDYXJkICYmIHRoaXMudGFicyxcbiAgICAgICAgICAgICAgICAgICAgJ2NhcmQtaGVhZGVyLXBpbGxzJzogdGhpcy5pc0NhcmQgJiYgdGhpcy5waWxscyxcbiAgICAgICAgICAgICAgICAgICAgJ25hdi1qdXN0aWZpZWQnOiB0aGlzLmp1c3RpZmllZCxcbiAgICAgICAgICAgICAgICAgICAgJ25hdi1maWxsJzogdGhpcy5maWxsLFxuICAgICAgICAgICAgICAgICAgICAnbmF2LXBpbGxzJzogdGhpcy5waWxscyxcbiAgICAgICAgICAgICAgICAgICAgJ25hdi10YWJzJzogdGhpcy50YWJzLFxuICAgICAgICAgICAgICAgICAgICAnZmxleC1jb2x1bW4nOiB0aGlzLnZlcnRpY2FsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpc0NhcmQ6IHRoaXMuY2FyZFxuICAgICAgICB9O1xuICAgIH1cblxufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG5cbiAgICA8bmF2aWdhdGlvbi1pdGVtIGNsYXNzPVwiZHJvcGRvd25cIj5cblxuICAgICAgICA8c2xvdCBuYW1lPVwidG9nZ2xlLWJ1dHRvblwiPlxuICAgICAgICAgICAgPG5hdmlnYXRpb24tbGlua1xuICAgICAgICAgICAgICAgIGhyZWY9XCIjXCJcbiAgICAgICAgICAgICAgICBjbGFzcz1cImRyb3Bkb3duLXRvZ2dsZVwiXG4gICAgICAgICAgICAgICAgZGF0YS10b2dnbGU9XCJkcm9wZG93blwiXG4gICAgICAgICAgICAgICAgcm9sZT1cImJ1dHRvblwiXG4gICAgICAgICAgICAgICAgYXJpYS1oYXNwb3B1cD1cInRydWVcIlxuICAgICAgICAgICAgICAgIDphcmlhLWV4cGFuZGVkPVwiaXNEcm9wZG93blNob3dpbmdcIlxuICAgICAgICAgICAgICAgIEBjbGljay5uYXRpdmUucHJldmVudD1cInRvZ2dsZSgpXCJcbiAgICAgICAgICAgICAgICBAYmx1cj1cIm9uQmx1clwiPlxuICAgICAgICAgICAgICAgIHt7bGFiZWx9fVxuICAgICAgICAgICAgPC9uYXZpZ2F0aW9uLWxpbms+XG4gICAgICAgIDwvc2xvdD5cblxuICAgICAgICA8c2xvdCBuYW1lPVwiZHJvcGRvd24tbWVudVwiPlxuICAgICAgICAgICAgPGRyb3Bkb3duLW1lbnVcbiAgICAgICAgICAgICAgICA6aWQ9XCJpZFwiXG4gICAgICAgICAgICAgICAgOml0ZW1zPVwiaXRlbXNcIlxuICAgICAgICAgICAgICAgIDphbGlnbj1cImFsaWduXCJcbiAgICAgICAgICAgICAgICA6c2hvdy5zeW5jPVwiaXNEcm9wZG93blNob3dpbmdcIlxuICAgICAgICAgICAgICAgIEBpdGVtOmNsaWNrPVwib25JdGVtQ2xpY2tcIj5cbiAgICAgICAgICAgICAgICA8c2xvdC8+XG4gICAgICAgICAgICA8L2Ryb3Bkb3duLW1lbnU+XG4gICAgICAgIDwvc2xvdD5cblxuICAgIDwvbmF2aWdhdGlvbi1pdGVtPlxuXG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IE5hdmlnYXRpb25JdGVtIGZyb20gJy4vTmF2aWdhdGlvbkl0ZW0nO1xuaW1wb3J0IE5hdmlnYXRpb25MaW5rIGZyb20gJy4vTmF2aWdhdGlvbkxpbmsnO1xuaW1wb3J0IERyb3Bkb3duTWVudSBmcm9tICcuLi9Ecm9wZG93bk1lbnUnO1xuaW1wb3J0IEJ0bkRyb3Bkb3duIGZyb20gJy4uL0J0bkRyb3Bkb3duJztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ25hdmlnYXRpb24tZHJvcGRvd24nLFxuXG4gICAgZXh0ZW5kczogQnRuRHJvcGRvd24sXG5cbiAgICBjb21wb25lbnRzOiB7XG4gICAgICAgIEJ0bkRyb3Bkb3duLFxuICAgICAgICBEcm9wZG93bk1lbnUsXG4gICAgICAgIE5hdmlnYXRpb25JdGVtLFxuICAgICAgICBOYXZpZ2F0aW9uTGlua1xuICAgIH1cblxufVxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgTmF2aWdhdGlvbiBmcm9tICcuL05hdmlnYXRpb24nO1xuaW1wb3J0IE5hdmlnYXRpb25FcnJvciBmcm9tICcuL05hdmlnYXRpb25FcnJvcic7XG5pbXBvcnQgTmF2aWdhdGlvbkl0ZW0gZnJvbSAnLi9OYXZpZ2F0aW9uSXRlbSc7XG5pbXBvcnQgTmF2aWdhdGlvbkxpbmsgZnJvbSAnLi9OYXZpZ2F0aW9uTGluayc7XG5pbXBvcnQgTmF2aWdhdGlvbkRyb3Bkb3duIGZyb20gJy4vTmF2aWdhdGlvbkRyb3Bkb3duJztcbmltcG9ydCBWdWVJbnN0YWxsZXIgZnJvbSAnLi4vLi4vSGVscGVycy9WdWVJbnN0YWxsZXIvVnVlSW5zdGFsbGVyJztcblxuY29uc3QgcGx1Z2luID0gVnVlSW5zdGFsbGVyLnVzZSh7XG5cbiAgICBpbnN0YWxsKFZ1ZSwgb3B0aW9ucykge1xuICAgICAgICBWdWVJbnN0YWxsZXIuY29tcG9uZW50cyh7XG4gICAgICAgICAgICBOYXZpZ2F0aW9uLFxuICAgICAgICAgICAgTmF2aWdhdGlvbkVycm9yLFxuICAgICAgICAgICAgTmF2aWdhdGlvbkl0ZW0sXG4gICAgICAgICAgICBOYXZpZ2F0aW9uTGluayxcbiAgICAgICAgICAgIE5hdmlnYXRpb25Ecm9wZG93blxuICAgICAgICB9KTtcbiAgICB9XG5cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBOYXZpZ2F0aW9uO1xuIiwiPHRlbXBsYXRlPlxuICAgIDx1bCBjbGFzcz1cIm5hdmJhci1uYXZcIiA6Y2xhc3M9XCJjbGFzc2VzXCIgOnJvbGU9XCJyb2xlXCI+XG4gICAgICAgIDxzbG90Lz5cbiAgICA8L3VsPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBOYXZpZ2F0aW9uIGZyb20gJy4uL05hdmlnYXRpb24nO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAnbmF2YmFyLW5hdicsXG5cbiAgICBjb21wb25lbnRzOiB7XG4gICAgICAgIE5hdmlnYXRpb25cbiAgICB9XG5cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IE5hdmJhciBmcm9tICcuL05hdmJhcic7XG5pbXBvcnQgTmF2YmFyQnJhbmQgZnJvbSAnLi9OYXZiYXJCcmFuZCc7XG5pbXBvcnQgTmF2YmFyQ29sbGFwc2UgZnJvbSAnLi9OYXZiYXJDb2xsYXBzZSc7XG5pbXBvcnQgTmF2YmFyTmF2IGZyb20gJy4vTmF2YmFyTmF2JztcbmltcG9ydCBOYXZiYXJUZXh0IGZyb20gJy4vTmF2YmFyVGV4dCc7XG5pbXBvcnQgTmF2YmFyVG9nZ2xlciBmcm9tICcuL05hdmJhclRvZ2dsZXInO1xuaW1wb3J0IE5hdmJhclRvZ2dsZXJJY29uIGZyb20gJy4vTmF2YmFyVG9nZ2xlckljb24nO1xuaW1wb3J0IFZ1ZUluc3RhbGxlciBmcm9tICcuLi8uLi9IZWxwZXJzL1Z1ZUluc3RhbGxlci9WdWVJbnN0YWxsZXInO1xuXG5jb25zdCBwbHVnaW4gPSBWdWVJbnN0YWxsZXIudXNlKHtcblxuICAgIGluc3RhbGwoVnVlLCBvcHRpb25zKSB7XG4gICAgICAgIFZ1ZUluc3RhbGxlci5jb21wb25lbnRzKHtcbiAgICAgICAgICAgIE5hdmJhcixcbiAgICAgICAgICAgIE5hdmJhckJyYW5kLFxuICAgICAgICAgICAgTmF2YmFyQ29sbGFwc2UsXG4gICAgICAgICAgICBOYXZiYXJOYXYsXG4gICAgICAgICAgICBOYXZiYXJUZXh0LFxuICAgICAgICAgICAgTmF2YmFyVG9nZ2xlcixcbiAgICAgICAgICAgIE5hdmJhclRvZ2dsZXJJY29uXG4gICAgICAgIH0pO1xuICAgIH1cblxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IE5hdmJhcjtcbiIsIjx0ZW1wbGF0ZT5cbiAgICA8bmF2IGFyaWEtbGFiZWw9XCJQYWdlIG5hdmlnYXRpb24gZXhhbXBsZVwiPlxuICAgICAgICA8dWwgY2xhc3M9XCJwYWdpbmF0aW9uXCIgOmNsYXNzPVwiY2xhc3Nlc1wiPlxuICAgICAgICBcdDxsaSBjbGFzcz1cInBhZ2UtaXRlbVwiIDpjbGFzcz1cInsnZGlzYWJsZWQnOiBjdXJyZW50UGFnZSA9PT0gMX1cIj5cbiAgICAgICAgXHRcdDxhIGhyZWY9XCIjXCIgY2xhc3M9XCJwYWdlLWxpbmtcIiBhcmlhLWxhYmVsPVwiUHJldmlvdXNcIiBAY2xpY2sucHJldmVudD1cInByZXYoJGV2ZW50KVwiPlxuICAgICAgICBcdFx0XHQ8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj4mbGFxdW87PC9zcGFuPlxuICAgICAgICBcdFx0PC9hPlxuICAgICAgICBcdDwvbGk+XG4gICAgICAgICAgICA8bGkgdi1mb3I9XCJpdGVtIGluIHBhZ2VzXCIgOmRhdGEtcGFnZT1cIml0ZW0ucGFnZVwiIGNsYXNzPVwicGFnZS1pdGVtXCIgOmNsYXNzPVwieydhY3RpdmUnOiBpdGVtLnBhZ2UgPT09IGN1cnJlbnRQYWdlLCAnZGlzYWJsZWQnOiAhIWl0ZW0uZGl2aWRlcn1cIj5cbiAgICAgICAgICAgICAgICA8c2xvdCA6aXRlbT1cIml0ZW1cIj5cbiAgICAgICAgICAgICAgICAgICAgPGEgdi1pZj1cIml0ZW0uZGl2aWRlclwiIGNsYXNzPVwicGFnZS1saW5rXCI+JmhlbGxpcDs8L2E+XG4gICAgICAgICAgICAgICAgXHQ8YSB2LWVsc2UgaHJlZj1cIiNcIiBjbGFzcz1cInBhZ2UtbGlua1wiIDpjbGFzcz1cIml0ZW0uY2xhc3NcIiA6ZGF0YS1sYWJlbD1cIml0ZW0ubGFiZWxcIiBAY2xpY2sucHJldmVudD1cInBhZ2luYXRlKGl0ZW0ucGFnZSwgJGV2ZW50KVwiPlxuICAgICAgICAgICAgICAgIFx0XHQ8c3BhbiB2LWlmPVwiaXRlbS5sYWJlbFwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIHYtaHRtbD1cIml0ZW0ubGFiZWxcIj48L3NwYW4+XG4gICAgICAgICAgICAgICAgXHRcdDxzcGFuIHYtaWY9XCJpdGVtLnBhZ2VcIiBhcmlhLWhpZGRlbj1cInRydWVcIiB2LWh0bWw9XCJpdGVtLnBhZ2VcIj48L3NwYW4+XG4gICAgICAgICAgICAgICAgXHQ8L2E+XG4gICAgICAgICAgICAgICAgPC9zbG90PlxuICAgICAgICAgICAgPC9saT5cbiAgICAgICAgXHQ8bGkgY2xhc3M9XCJwYWdlLWl0ZW1cIiA6Y2xhc3M9XCJ7J2Rpc2FibGVkJzogY3VycmVudFBhZ2UgPj0gdG90YWxQYWdlc31cIj5cbiAgICAgICAgXHRcdDxhIGhyZWY9XCIjXCIgY2xhc3M9XCJwYWdlLWxpbmtcIiBhcmlhLWxhYmVsPVwiTmV4dFwiIEBjbGljay5wcmV2ZW50PVwibmV4dCgkZXZlbnQpXCI+XG4gICAgICAgIFx0XHRcdDxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPiZyYXF1bzs8L3NwYW4+XG4gICAgICAgIFx0XHQ8L2E+XG4gICAgICAgICAgICA8L2xpPlxuICAgICAgICA8L3VsPlxuICAgIDwvbmF2PlxuXG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ3BhZ2luYXRpb24nLFxuXG4gICAgcHJvcHM6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhbGlnbm1lbnQgb2YgdGhlIHBhZ2luYXRpb24gY29tcG9uZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcCBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGFsaWduOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICB2YWxpZGF0ZTogdmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBbJ3N0YXJ0JywgJ2VuZCcsICdjZW50ZXInXS5pbmRleE9mKHZhbHVlKSAhPT0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwYWdlIG9uIHdoaWNoIHRoZSBwYWdpbmF0b3Igc2hvdWxkIHN0YXJ0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcCBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHBhZ2U6IHtcbiAgICAgICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgICAgIGRlZmF1bHQ6IDFcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRvdGFsIG51bWJlciBvZiBwYWdlcyBpbiB0aGUgcGFnaW5hdG9yLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcCBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHRvdGFsUGFnZXM6IHtcbiAgICAgICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgICAgIGRlZmF1bHQ6IDFcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG51bWJlciBvZiBwYWdlcyB0byBzaG93IHdoZW4gdGhlIHRvdGFsIG51bWJlciBvZiBwYWdlcyBpc1xuICAgICAgICAgKiBncmVhdGVyIHRoYW4gdGhlIG51bWJlciBvZiBwYWdlcyB0aGF0IHNob3VsZCBiZSBzaG93bi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3AgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBzaG93UGFnZXM6IHtcbiAgICAgICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgICAgIGRlZmF1bHQ6IDZcbiAgICAgICAgfVxuICAgICAgICBcbiAgICB9LFxuXG4gICAgbWV0aG9kczoge1xuXG4gICAgICAgIG5leHQoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMucGFnaW5hdGUodGhpcy5jdXJyZW50UGFnZSA+PSB0aGlzLnRvdGFsUGFnZXMgPyB0aGlzLmN1cnJlbnRQYWdlIDogdGhpcy5jdXJyZW50UGFnZSArIDEsIGV2ZW50KTtcbiAgICAgICAgfSxcblxuICAgICAgICBwcmV2KGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLnBhZ2luYXRlKHRoaXMuY3VycmVudFBhZ2UgPD0gMSA/IHRoaXMuY3VycmVudFBhZ2UgOiB0aGlzLmN1cnJlbnRQYWdlIC0gMSwgZXZlbnQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBhZ2luYXRlKHBhZ2UsIGV2ZW50KSB7XG4gICAgICAgICAgICBpZihldmVudC5jdXJyZW50VGFyZ2V0LnBhcmVudE5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKCdkaXNhYmxlZCcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG5cdFx0XHR0aGlzLnNldEFjdGl2ZVBhZ2UocGFnZSk7XG5cbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ3BhZ2luYXRlJywgcGFnZSwgZXZlbnQpO1xuICAgICAgICB9LFxuXG5cdFx0c2V0QWN0aXZlUGFnZShwYWdlKSB7XG5cdFx0XHRpZih0aGlzLmN1cnJlbnRQYWdlICE9PSBwYWdlKSB7XG5cdFx0XHRcdHRoaXMuY3VycmVudFBhZ2UgPSBwYWdlO1xuXHRcdFx0fVxuXHRcdH0sXG5cbiAgICAgICAgZ2VuZXJhdGUoKSB7XG4gICAgICAgICAgICBjb25zdCBwYWdlcyA9IFtdO1xuICAgICAgICAgICAgY29uc3Qgc2hvd1BhZ2VzID0gdGhpcy5zaG93UGFnZXMgJSAyID8gdGhpcy5zaG93UGFnZXMgKyAxOiB0aGlzLnNob3dQYWdlcztcblxuICAgICAgICAgICAgbGV0IHN0YXJ0UGFnZSA9ICh0aGlzLmN1cnJlbnRQYWdlID49IHNob3dQYWdlcykgPyB0aGlzLmN1cnJlbnRQYWdlIC0gKHNob3dQYWdlcyAvIDIpIDogMTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gc2hvd1BhZ2VzICsgc3RhcnRQYWdlO1xuICAgICAgICAgICAgY29uc3QgZW5kUGFnZSA9ICh0aGlzLnRvdGFsUGFnZXMgPCBzdGFydE9mZnNldCkgPyB0aGlzLnRvdGFsUGFnZXMgOiBzdGFydE9mZnNldDtcbiAgICAgICAgICAgIGNvbnN0IGRpZmYgPSBzdGFydFBhZ2UgLSBlbmRQYWdlICsgc2hvd1BhZ2VzO1xuXG4gICAgICAgICAgICBzdGFydFBhZ2UgLT0gKHN0YXJ0UGFnZSAtIGRpZmYgPiAwKSA/IGRpZmYgOiAwO1xuXG4gICAgICAgICAgICBpZiAoc3RhcnRQYWdlID4gMSkge1xuICAgICAgICAgICAgICAgIHBhZ2VzLnB1c2goe3BhZ2U6IDF9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoc3RhcnRQYWdlID4gMikge1xuICAgICAgICAgICAgICAgIHBhZ2VzLnB1c2goe2RpdmlkZXI6IHRydWV9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yKGxldCBpID0gc3RhcnRQYWdlOyBpIDwgZW5kUGFnZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcGFnZXMucHVzaCh7cGFnZTogaX0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZW5kUGFnZSA8PSB0aGlzLnRvdGFsUGFnZXMpIHtcbiAgICAgICAgICAgICAgICBpZih0aGlzLnRvdGFsUGFnZXMgLSAxID4gZW5kUGFnZSkge1xuICAgICAgICAgICAgICAgICAgICBwYWdlcy5wdXNoKHtkaXZpZGVyOiB0cnVlfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcGFnZXMucHVzaCh7cGFnZTogdGhpcy50b3RhbFBhZ2VzfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBwYWdlcztcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGNvbXB1dGVkOiB7XG5cbiAgICAgICAgcGFnZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsYXNzZXMoKSB7XG4gICAgICAgICAgICBjb25zdCBjbGFzc2VzID0ge307XG5cbiAgICAgICAgICAgIGNsYXNzZXNbJ2p1c3RpZnktY29udGVudC0nICsgdGhpcy5hbGlnbl0gPSB0cnVlO1xuXG4gICAgICAgICAgICByZXR1cm4gY2xhc3NlcztcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiAge1xuICAgICAgICAgICAgY3VycmVudFBhZ2U6IHRoaXMucGFnZVxuICAgICAgICB9O1xuICAgIH1cblxufTtcbjwvc2NyaXB0PlxuIiwiaW1wb3J0IFBhZ2luYXRpb24gZnJvbSAnLi9QYWdpbmF0aW9uJztcbmltcG9ydCBWdWVJbnN0YWxsZXIgZnJvbSAnLi4vLi4vSGVscGVycy9WdWVJbnN0YWxsZXIvVnVlSW5zdGFsbGVyJztcblxuY29uc3QgcGx1Z2luID0gVnVlSW5zdGFsbGVyLnVzZSh7XG5cbiAgICBpbnN0YWxsKFZ1ZSwgb3B0aW9ucykge1xuICAgICAgICBWdWVJbnN0YWxsZXIuY29tcG9uZW50cyh7XG4gICAgICAgICAgICBQYWdpbmF0aW9uXG4gICAgICAgIH0pO1xuICAgIH1cblxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IFBhZ2luYXRpb247XG4iLCI8dGVtcGxhdGU+XG5cbiAgICA8Zm9ybS1ncm91cD5cblxuICAgICAgICA8c2xvdCBuYW1lPVwibGFiZWxcIj5cbiAgICAgICAgICAgIDxmb3JtLWxhYmVsIHYtaWY9XCJsYWJlbFwiIDpmb3I9XCJpZFwiIHYtaHRtbD1cImxhYmVsXCIvPlxuICAgICAgICA8L3Nsb3Q+XG5cbiAgICAgICAgPHNsb3QgbmFtZT1cImNvbnRyb2xcIj5cbiAgICAgICAgICAgIDxzZWxlY3RcbiAgICAgICAgICAgICAgICA6aWQ9XCJpZFwiXG4gICAgICAgICAgICAgICAgOm5hbWU9XCJuYW1lXCJcbiAgICAgICAgICAgICAgICA6dmFsdWU9XCJ2YWx1ZVwiXG4gICAgICAgICAgICAgICAgOnJlcXVpcmVkPVwicmVxdWlyZWRcIlxuICAgICAgICAgICAgICAgIDpkaXNhYmxlZD1cImRpc2FibGVkIHx8IHJlYWRvbmx5XCJcbiAgICAgICAgICAgICAgICA6cmVhZG9ubHk9XCJyZWFkb25seVwiXG4gICAgICAgICAgICAgICAgOnBhdHRlcm49XCJwYXR0ZXJuXCJcbiAgICAgICAgICAgICAgICA6Y2xhc3M9XCJtZXJnZUNsYXNzZXMoY29udHJvbENsYXNzZXMsIGNvbG9yYWJsZUNsYXNzZXMpXCJcbiAgICAgICAgICAgICAgICBAaW5wdXQ9XCIkZW1pdCgnaW5wdXQnLCAkZXZlbnQudGFyZ2V0LnZhbHVlKVwiPlxuICAgICAgICAgICAgICAgIDxzbG90IC8+XG4gICAgICAgICAgICA8L3NlbGVjdD5cbiAgICAgICAgPC9zbG90PlxuXG4gICAgICAgIDxzbG90IG5hbWU9XCJoZWxwXCI+XG4gICAgICAgICAgICA8aGVscC10ZXh0IHYtaWY9XCJoZWxwVGV4dFwiIHYtaHRtbD1cImhlbHBUZXh0XCIgLz5cbiAgICAgICAgPC9zbG90PlxuXG4gICAgICAgIDxzbG90IG5hbWU9XCJmZWVkYmFja1wiPlxuICAgICAgICAgICAgPGZvcm0tZmVlZGJhY2sgdi1pZj1cInZhbGlkRmVlZGJhY2tcIiB2LWh0bWw9XCJ2YWxpZEZlZWRiYWNrXCIgdmFsaWQgLz5cbiAgICAgICAgICAgIDxmb3JtLWZlZWRiYWNrIHYtaWY9XCJpbnZhbGlkRmVlZGJhY2tcIiB2LWh0bWw9XCJpbnZhbGlkRmVlZGJhY2tcIiBpbnZhbGlkIC8+XG4gICAgICAgIDwvc2xvdD5cblxuICAgIDwvZm9ybS1ncm91cD5cblxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBIZWxwVGV4dCBmcm9tICcuLi9IZWxwVGV4dCc7XG5pbXBvcnQgRm9ybUdyb3VwIGZyb20gJy4uL0Zvcm1Hcm91cCc7XG5pbXBvcnQgRm9ybUxhYmVsIGZyb20gJy4uL0Zvcm1MYWJlbCc7XG5pbXBvcnQgRm9ybUZlZWRiYWNrIGZyb20gJy4uL0Zvcm1GZWVkYmFjayc7XG5pbXBvcnQgQ29sb3JhYmxlIGZyb20gJy4uLy4uL01peGlucy9Db2xvcmFibGUnO1xuaW1wb3J0IEZvcm1Db250cm9sIGZyb20gJy4uLy4uL01peGlucy9Gb3JtQ29udHJvbCc7XG5pbXBvcnQgTWVyZ2VDbGFzc2VzIGZyb20gJy4uLy4uL01peGlucy9NZXJnZUNsYXNzZXMnO1xuXG5jb25zdCBDVVNUT01fU0VMRUNUX1BSRUZJWCA9ICdjdXN0b20tc2VsZWN0LSdcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ3NlbGVjdC1maWVsZCcsXG5cbiAgICBjb21wb25lbnRzOiB7XG4gICAgICAgIEhlbHBUZXh0LFxuICAgICAgICBGb3JtR3JvdXAsXG4gICAgICAgIEZvcm1MYWJlbCxcbiAgICAgICAgRm9ybUZlZWRiYWNrXG4gICAgfSxcblxuICAgIGV4dGVuZHM6IEZvcm1Db250cm9sLFxuXG4gICAgbWl4aW5zOiBbXG4gICAgICAgIENvbG9yYWJsZSxcbiAgICAgICAgRm9ybUNvbnRyb2wsXG4gICAgICAgIE1lcmdlQ2xhc3Nlc1xuICAgIF0sXG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgYGN1c3RvbS1zZWxlY3RgIHRvIHRoZSBmb3JtIGNvbnRyb2wgaWYgdHJ1ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgY3VzdG9tOiBCb29sZWFuXG5cbiAgICB9LFxuXG4gICAgY29tcHV0ZWQ6IHtcblxuICAgICAgICBjb250cm9sQ2xhc3MoKSB7XG4gICAgICAgICAgICBjb25zdCBjb250cm9sQ2xhc3MgPSB0aGlzLmN1c3RvbSA/ICdjdXN0b20tc2VsZWN0JyA6IHRoaXMuZGVmYXVsdENvbnRyb2xDbGFzcztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBsYWludGV4dCA/IGAke2NvbnRyb2xDbGFzc30tcGxhaW50ZXh0YCA6IGNvbnRyb2xDbGFzcztcbiAgICAgICAgfSxcblxuICAgICAgICBjdXN0b21TZWxlY3RDbGFzc2VzKCkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBDVVNUT01fU0VMRUNUX1BSRUZJWC5yZXBsYWNlKC9cXC0kLywgJycpICsgKHRoaXMucGxhaW50ZXh0ID8gJy1wbGFpbnRleHQnIDogJycpLFxuICAgICAgICAgICAgICAgIHRoaXMuY3VzdG9tU2VsZWN0U2l6ZUNsYXNzLFxuICAgICAgICAgICAgICAgICh0aGlzLnNwYWNpbmcgfHwgJycpXG4gICAgICAgICAgICBdLmpvaW4oJyAnKTtcbiAgICAgICAgfVxuICAgIH1cblxufVxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgU2VsZWN0RmllbGQgZnJvbSAnLi9TZWxlY3RGaWVsZCc7XG5pbXBvcnQgVnVlSW5zdGFsbGVyIGZyb20gJy4uLy4uL0hlbHBlcnMvVnVlSW5zdGFsbGVyL1Z1ZUluc3RhbGxlcic7XG5cbmNvbnN0IHBsdWdpbiA9IFZ1ZUluc3RhbGxlci51c2Uoe1xuXG4gICAgaW5zdGFsbChWdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgVnVlSW5zdGFsbGVyLmNvbXBvbmVudHMoe1xuICAgICAgICAgICAgU2VsZWN0RmllbGRcbiAgICAgICAgfSk7XG4gICAgfVxuXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgU2VsZWN0RmllbGQ7XG4iLCJpbXBvcnQgYmFzZUZpbmRJbmRleCBmcm9tICcuL19iYXNlRmluZEluZGV4LmpzJztcbmltcG9ydCBiYXNlSXRlcmF0ZWUgZnJvbSAnLi9fYmFzZUl0ZXJhdGVlLmpzJztcbmltcG9ydCB0b0ludGVnZXIgZnJvbSAnLi90b0ludGVnZXIuanMnO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXg7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kYCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3RcbiAqIGVsZW1lbnQgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yIGluc3RlYWQgb2YgdGhlIGVsZW1lbnQgaXRzZWxmLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMS4xLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgLTFgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgdXNlcnMgPSBbXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiBmYWxzZSB9LFxuICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IHRydWUgfVxuICogXTtcbiAqXG4gKiBfLmZpbmRJbmRleCh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby51c2VyID09ICdiYXJuZXknOyB9KTtcbiAqIC8vID0+IDBcbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kSW5kZXgodXNlcnMsIHsgJ3VzZXInOiAnZnJlZCcsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAqIC8vID0+IDFcbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbmRJbmRleCh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICogLy8gPT4gMFxuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kSW5kZXgodXNlcnMsICdhY3RpdmUnKTtcbiAqIC8vID0+IDJcbiAqL1xuZnVuY3Rpb24gZmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIHZhciBpbmRleCA9IGZyb21JbmRleCA9PSBudWxsID8gMCA6IHRvSW50ZWdlcihmcm9tSW5kZXgpO1xuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgaW5kZXggPSBuYXRpdmVNYXgobGVuZ3RoICsgaW5kZXgsIDApO1xuICB9XG4gIHJldHVybiBiYXNlRmluZEluZGV4KGFycmF5LCBiYXNlSXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgaW5kZXgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmaW5kSW5kZXg7XG4iLCI8c2NyaXB0PlxuaW1wb3J0IHsgZXh0ZW5kIH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCB7IGZpbmRJbmRleCB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgeyBmaWx0ZXIgfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IHsgZmlyc3QgfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IHsgaXNPYmplY3QgfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IHsgaXNVbmRlZmluZWQgfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IHsgbWFwIH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCB0cmFuc2l0aW9uIGZyb20gJy4uLy4uL0hlbHBlcnMvVHJhbnNpdGlvbic7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdzbGlkZXMnLFxuXG4gICAgcHJvcHM6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGFjdGl2ZSBzbGlkZSBpbmRleCBvciBrZXkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd8TnVtYmVyfVxuICAgICAgICAgKi9cblxuICAgICAgICBhY3RpdmU6IHtcbiAgICAgICAgICAgIHR5cGU6IFtTdHJpbmcsIE51bWJlcl0sXG4gICAgICAgICAgICBkZWZhdWx0OiAwXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICB3YXRjaDoge1xuXG4gICAgICAgIGFjdGl2ZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdFNsaWRlID0gb2xkVmFsdWU7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTbGlkZSA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgbWV0aG9kczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIEhUTUwgbm9kZXMgZnJvbSB0aGUgZGVmYXVsdCBzbG90cyAoZXhsdWRpbmcgY2hpbGRyZW4gd2l0aG91dCB0YWdzKS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICAgICAqL1xuICAgICAgICBzbGlkZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFwKGZpbHRlcih0aGlzLiRzbG90cy5kZWZhdWx0LCAodm5vZGUsIGkpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gISF2bm9kZS50YWc7XG4gICAgICAgICAgICB9KSwgKHZub2RlLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYoIXZub2RlLmtleSB8fCAhdm5vZGUuZGF0YSAmJiAhdm5vZGUuZGF0YS5rZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdm5vZGUuZGF0YSA9IGV4dGVuZCh2bm9kZS5kYXRhLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IHZub2RlLmtleSA9IGlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZub2RlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhIHNsaWRlIGJ5IGluZGV4LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgICAgICovXG4gICAgICAgIHNsaWRlKGluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5kU2xpZGVCeUtleShpbmRleCkgfHwgdGhpcy5maW5kU2xpZGVCeUluZGV4KGluZGV4KSB8fCB0aGlzLmZpbmRTbGlkZUJ5SW5kZXgoMCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpbmQgYSBzbGlkZSBieSBhIGdpdmVuIGtleSBvciByZXR1cm4gbnVsbCBpZiBub24gZm91bmQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGtleVxuICAgICAgICAgKiBAcmV0dXJuIHtWTm9kZXxudWxsfVxuICAgICAgICAgKi9cbiAgICAgICAgZmluZFNsaWRlQnlLZXkoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gZmlyc3QoZmlsdGVyKHRoaXMuc2xpZGVzKCksICh2bm9kZSwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmKHZub2RlLmtleSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2bm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZih2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEua2V5ID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZub2RlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaW5kIGEgc2xpZGUgYnkgYSBnaXZlbiBpbmRleCBvciByZXR1cm4gbnVsbCBpZiBub24gZm91bmQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGtleVxuICAgICAgICAgKiBAcmV0dXJuIHtWTm9kZXxudWxsfVxuICAgICAgICAgKi9cbiAgICAgICAgZmluZFNsaWRlQnlJbmRleChpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2xpZGVzKClbaW5kZXhdIHx8IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgc2xpZGUgaW5kZXggZm9yIGEgZ2l2ZSBzbGlkZSBvYmplY3Qgb3Iga2V5XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IHNsaWRlXG4gICAgICAgICAqIEByZXR1cm4ge1ZOb2RlfG51bGx9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRTbGlkZUluZGV4KHNsaWRlKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSAhaXNVbmRlZmluZWQoc2xpZGUuZGF0YSkgPyBzbGlkZS5kYXRhLmtleSA6IHNsaWRlLmtleSB8fCBzbGlkZTtcblxuICAgICAgICAgICAgcmV0dXJuIGZpbmRJbmRleCh0aGlzLnNsaWRlcygpLCAodm5vZGUsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBpZihzbGlkZSA9PT0gdm5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYodm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLmtleSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmKHZub2RlLmtleSAmJiB2bm9kZS5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZihpID09PSBzbGlkZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsYXN0U2xpZGU6IG51bGwsXG4gICAgICAgICAgICBjdXJyZW50U2xpZGU6IHRoaXMuYWN0aXZlXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVuZGVyKGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2xpZGUodGhpcy5jdXJyZW50U2xpZGUpO1xuICAgIH1cblxufTtcbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICAgIDwhLS0gVE9ETzogQWRkIHRvb2x0aXAgd2l0aCBzbGlkZSBuYW1lL2tleSB0byB0aGUgY29udHJvbCBvbmNlIHRoZSB0b29sdGlwIGRpcmVjdGl2ZSBoYXMgYmVlbiB3cml0dGVuLiAtLT5cbiAgICA8ZGl2IGNsYXNzPVwic2xpZGUtZGVjay1jb250cm9sc1wiPlxuICAgICAgICA8YSB2LWZvcj1cInNsaWRlIGluIHNsaWRlc1wiIGhyZWY9XCIjXCIgQGNsaWNrLnByZXZlbnQ9XCJvbkNsaWNrKCRldmVudCwgc2xpZGUpXCIgY2xhc3M9XCJzbGlkZS1kZWNrLWNvbnRyb2wtaWNvblwiIDpjbGFzcz1cInsnaXMtYWN0aXZlJzogKHNsaWRlLmRhdGEgPyBzbGlkZS5kYXRhLmtleSA6IHNsaWRlLmtleSkgPT09IGFjdGl2ZX1cIj5cbiAgICAgICAgICAgIDxpIGNsYXNzPVwiZmEgZmEtY2lyY2xlXCIvPlxuICAgICAgICA8L2E+XG4gICAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IHsgbWFwIH0gZnJvbSAnbG9kYXNoLWVzJztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ3NsaWRlLWRlY2stY29udHJvbHMnLFxuXG4gICAgcHJvcHM6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNsaWRlIGtleSBvciBpbmRleCB0aGF0IHNob3VsZCBzaG93LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgYWN0aXZlOiB7XG4gICAgICAgICAgICB0eXBlOiBbU3RyaW5nLCBOdW1iZXJdLFxuICAgICAgICAgICAgZGVmYXVsdDogMFxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBhcnJheSBvZiBzbGlkZSB2bm9kZXNcbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHNsaWRlczoge1xuICAgICAgICAgICAgdHlwZTogQXJyYXksXG4gICAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgbWV0aG9kczoge1xuXG4gICAgICAgIG9uQ2xpY2soZXZlbnQsIHNsaWRlKSB7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCdjbGljaycsIGV2ZW50LCBzbGlkZSlcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGNvbXB1dGVkOiB7XG5cbiAgICB9LFxuXG4gICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHt9XG4gICAgfVxuXG59O1xuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwic2Nzc1wiPlxuQGltcG9ydCAnLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwL3Njc3MvZnVuY3Rpb25zLnNjc3MnO1xuQGltcG9ydCAnLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwL3Njc3MvdmFyaWFibGVzLnNjc3MnO1xuXG4uc2xpZGUtZGVjay1jb250cm9scyB7XG4gICAgLnNsaWRlLWRlY2stY29udHJvbC1pY29uIHtcbiAgICAgICAgY29sb3I6ICR3aGl0ZTtcbiAgICAgICAgZm9udC1zaXplOiAkZm9udC1zaXplLWJhc2U7XG5cbiAgICAgICAgJjpub3QoOmxhc3QtY2hpbGQpIHtcbiAgICAgICAgICAgIG1hcmdpbi1yaWdodDogJGZvbnQtc2l6ZS1iYXNlIC8gMjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC5zbGlkZS1kZWNrLWNvbnRyb2wtaWNvbi5pcy1hY3RpdmUge1xuICAgICAgICBjb2xvcjogJHByaW1hcnk7XG4gICAgfVxufVxuPC9zdHlsZT5cbiIsIjx0ZW1wbGF0ZT5cbiAgICA8ZGl2IGNsYXNzPVwic2xpZGUtZGVja1wiIDpjbGFzcz1cInsnc2xpZGUtZGVjay1mbGV4JzogY2VudGVyfVwiPlxuICAgICAgICA8ZGl2IHJlZj1cImNvbnRlbnRcIiBjbGFzcz1cInNsaWRlLWRlY2stY29udGVudFwiIDpzdHlsZT1cInt3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0fVwiPlxuICAgICAgICAgICAgPGtlZXAtYWxpdmU+XG4gICAgICAgICAgICAgICAgPHRyYW5zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgOm5hbWU9XCJgc2xpZGUtJHtkaXJlY3Rpb259YFwiXG4gICAgICAgICAgICAgICAgICAgIEBhZnRlci1lbnRlcj1cIm9uU2xpZGVBZnRlckVudGVyXCJcbiAgICAgICAgICAgICAgICAgICAgQGJlZm9yZS1lbnRlcj1cIm9uU2xpZGVCZWZvcmVFbnRlclwiXG4gICAgICAgICAgICAgICAgICAgIEBlbnRlcj1cIm9uU2xpZGVFbnRlclwiXG4gICAgICAgICAgICAgICAgICAgIEBhZnRlci1sZWF2ZT1cIm9uU2xpZGVBZnRlckxlYXZlXCJcbiAgICAgICAgICAgICAgICAgICAgQGJlZm9yZS1sZWF2ZT1cIm9uU2xpZGVCZWZvcmVMZWF2ZVwiXG4gICAgICAgICAgICAgICAgICAgIEBsZWF2ZT1cIm9uU2xpZGVMZWF2ZVwiPlxuICAgICAgICAgICAgICAgICAgICA8c2xpZGVzIHJlZj1cInNsaWRlc1wiIDprZXk9XCJjdXJyZW50U2xpZGVcIiA6YWN0aXZlPVwiY3VycmVudFNsaWRlXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8c2xvdC8+XG4gICAgICAgICAgICAgICAgICAgIDwvc2xpZGVzPlxuICAgICAgICAgICAgICAgIDwvdHJhbnNpdGlvbj5cbiAgICAgICAgICAgIDwva2VlcC1hbGl2ZT5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxzbG90IG5hbWU9XCJjb250cm9sc1wiPlxuICAgICAgICAgICAgPHNsaWRlLWRlY2stY29udHJvbHMgdi1pZj1cImNvbnRyb2xzXCIgcmVmPVwiY29udHJvbHNcIiA6c2xpZGVzPVwic2xpZGVzKClcIiA6YWN0aXZlPVwiY3VycmVudFNsaWRlXCIgQGNsaWNrPVwib25DbGlja0NvbnRyb2xcIiAvPlxuICAgICAgICA8L3Nsb3Q+XG4gICAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IHsgZXh0ZW5kIH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCB7IGlzRnVuY3Rpb24gfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IHVuaXQgZnJvbSAnLi4vLi4vSGVscGVycy9Vbml0JztcbmltcG9ydCB0cmFuc2l0aW9uIGZyb20gJy4uLy4uL0hlbHBlcnMvVHJhbnNpdGlvbic7XG5pbXBvcnQgU2xpZGVzIGZyb20gJy4vU2xpZGVzJztcbmltcG9ydCBTbGlkZURlY2tDb250cm9scyBmcm9tICcuL1NsaWRlRGVja0NvbnRyb2xzJztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ3NsaWRlLWRlY2snLFxuXG4gICAgY29tcG9uZW50czoge1xuICAgICAgICBTbGlkZXMsXG4gICAgICAgIFNsaWRlRGVja0NvbnRyb2xzXG4gICAgfSxcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzbGlkZSBrZXkgb3IgaW5kZXggdGhhdCBzaG91bGQgc2hvdy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGFjdGl2ZToge1xuICAgICAgICAgICAgdHlwZTogW1N0cmluZywgTnVtYmVyXSxcbiAgICAgICAgICAgIGRlZmF1bHQ6IDBcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2VudGVyIHRoZSBzbGlkZS1kZWNrLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICAgICAqL1xuICAgICAgICBjZW50ZXI6IHtcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgICBkZWZhdWx0OiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3cgdGhlIHNsaWRlLWRlY2sgY29udHJvbHMgdG8gY2hhbmdlIHRoZSBzbGlkZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUgQm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgY29udHJvbHM6IEJvb2xlYW4sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZsZXggdGhlIGNvbnRlbnQgd2l0aGluIHRoZSBwb3BvdmVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICAgICAqL1xuICAgICAgICBmbGV4OiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHaXZlIGEgc2VsZWN0b3Igb3IgRWxlbWVudCB0byB1c2UgYXBwbHkgYSBoaWRkZW4gb3ZlcmZsb3cuIElmIGZhbHNlLFxuICAgICAgICAgKiBubyBvdmVyZmxvdyB3aWxsIGJlIGFwcGxpZWQuIERlZmF1bHRzIHRvIHRoZSBzbGlkZSBkZWNrJ3MgY29udGFpbmVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfEVsZW1lbnR8Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIG92ZXJmbG93OiB7XG4gICAgICAgICAgICB0eXBlOiBbT2JqZWN0LCBTdHJpbmcsIEVsZW1lbnQsIEJvb2xlYW5dLFxuICAgICAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbW9kZSBkZXRlcm1pbmVzIGhvdyB0aGUgcG9wb3ZlciBjb250ZW50IHdpbGwgZmxleCBiYXNlZCBvbiB0aGVcbiAgICAgICAgICogdmFyeWluZyBoZWlnaHRzIG9mIHRoZSBzbGlkZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIHJlc2l6ZU1vZGU6IHtcbiAgICAgICAgICAgIHR5cGU6IFtGdW5jdGlvbiwgQm9vbGVhbiwgU3RyaW5nXSxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdhdXRvJyxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsnYXV0bycsICdpbml0aWFsJywgJ2luaGVyaXQnXS5pbmRleE9mKHZhbHVlKSAhPT0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIHdhdGNoOiB7XG5cbiAgICAgICAgYWN0aXZlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5sYXN0U2xpZGUgPSBvbGRWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNsaWRlID0gdmFsdWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3VycmVudFNsaWRlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSB0aGlzLiRyZWZzLnNsaWRlcy5nZXRTbGlkZUluZGV4KG9sZFZhbHVlKSA+IHRoaXMuJHJlZnMuc2xpZGVzLmdldFNsaWRlSW5kZXgodmFsdWUpID8gJ2JhY2t3YXJkJyA6ICdmb3J3YXJkJztcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIG1ldGhvZHM6IHtcblxuICAgICAgICByZXNpemUoZWwpIHtcbiAgICAgICAgICAgIGlmKGlzRnVuY3Rpb24odGhpcy5yZXNpemVNb2RlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzaXplTW9kZS5jYWxsKHRoaXMsIGVsIHx8IHRoaXMuJGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG5cbiAgICAgICAgICAgICAgICBpZighZWwuc3R5bGUud2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwud2lkdGggPSBlbC5zdHlsZS53aWR0aCA9IGBjYWxjKCR7c3R5bGUud2lkdGh9ICsgJHtzdHlsZS5tYXJnaW5MZWZ0fSArICR7c3R5bGUubWFyZ2luUmlnaHR9KWA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYoIWVsLnN0eWxlLmhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBlbC5oZWlnaHQgPSBlbC5zdHlsZS5oZWlnaHQgPSBgY2FsYygke3N0eWxlLmhlaWdodH0gKyAke3N0eWxlLm1hcmdpblRvcH0gKyAke3N0eWxlLm1hcmdpbkJvdHRvbX0pYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2xpZGUoaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRyZWZzLnNsaWRlcyA/IHRoaXMuJHJlZnMuc2xpZGVzLnNsaWRlKGluZGV4IHx8IHRoaXMuYWN0aXZlKSA6IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2xpZGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHJlZnMuc2xpZGVzID8gdGhpcy4kcmVmcy5zbGlkZXMuc2xpZGVzKCkgOiBbXTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbkNsaWNrQ29udHJvbChldmVudCwgdm5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNsaWRlID0gdm5vZGUuZGF0YSA/IHZub2RlLmRhdGEua2V5IDogdm5vZGUua2V5O1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uU2xpZGVBZnRlckVudGVyKGVsKSB7XG4gICAgICAgICAgICBpZihlbC53aWR0aCkge1xuICAgICAgICAgICAgICAgIGVsLndpZHRoID0gZWwuc3R5bGUud2lkdGggPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihlbC5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBlbC5oZWlnaHQgPSBlbC5zdHlsZS5oZWlnaHQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLndpZHRoID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuJGVtaXQoXG4gICAgICAgICAgICAgICAgJ2FmdGVyLWVudGVyJywgdGhpcy4kcmVmcy5zbGlkZXMuc2xpZGUodGhpcy5jdXJyZW50U2xpZGUpLCB0aGlzLiRyZWZzLnNsaWRlcy5zbGlkZSh0aGlzLmxhc3RTbGlkZSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25TbGlkZUJlZm9yZUVudGVyKGVsKSB7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KFxuICAgICAgICAgICAgICAgICdiZWZvcmUtZW50ZXInLCB0aGlzLiRyZWZzLnNsaWRlcy5zbGlkZSh0aGlzLmN1cnJlbnRTbGlkZSksIHRoaXMuJHJlZnMuc2xpZGVzLnNsaWRlKHRoaXMubGFzdFNsaWRlKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvblNsaWRlRW50ZXIoZWwsIGRvbmUpIHtcbiAgICAgICAgICAgIHRoaXMucmVzaXplKGVsKTtcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSBlbC5zdHlsZS53aWR0aDtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gZWwuc3R5bGUuaGVpZ2h0O1xuXG4gICAgICAgICAgICB0cmFuc2l0aW9uKGVsKS50aGVuKGRlbGF5ID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLiRuZXh0VGljayhkb25lKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLiRlbWl0KFxuICAgICAgICAgICAgICAgICdlbnRlcicsIHRoaXMuJHJlZnMuc2xpZGVzLnNsaWRlKHRoaXMuY3VycmVudFNsaWRlKSwgdGhpcy4kcmVmcy5zbGlkZXMuc2xpZGUodGhpcy5sYXN0U2xpZGUpXG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uU2xpZGVBZnRlckxlYXZlKGVsKSB7XG4gICAgICAgICAgICBpZihlbC53aWR0aCkge1xuICAgICAgICAgICAgICAgIGVsLndpZHRoID0gZWwuc3R5bGUud2lkdGggPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihlbC5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBlbC5oZWlnaHQgPSBlbC5zdHlsZS5oZWlnaHQgPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLiRuZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy4kZW1pdChcbiAgICAgICAgICAgICAgICAgICAgJ2FmdGVyLWxlYXZlJywgdGhpcy4kcmVmcy5zbGlkZXMuc2xpZGUodGhpcy5sYXN0U2xpZGUpLCB0aGlzLiRyZWZzLnNsaWRlcy5zbGlkZSh0aGlzLmN1cnJlbnRTbGlkZSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25TbGlkZUJlZm9yZUxlYXZlKGVsKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZShlbCk7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KFxuICAgICAgICAgICAgICAgICdiZWZvcmUtbGVhdmUnLCB0aGlzLiRyZWZzLnNsaWRlcy5zbGlkZSh0aGlzLmxhc3RTbGlkZSksIHRoaXMuJHJlZnMuc2xpZGVzLnNsaWRlKHRoaXMuY3VycmVudFNsaWRlKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvblNsaWRlTGVhdmUoZWwsIGRvbmUpIHtcbiAgICAgICAgICAgIHRyYW5zaXRpb24oZWwpLnRoZW4oZGVsYXkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuJG5leHRUaWNrKGRvbmUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMuJGVtaXQoXG4gICAgICAgICAgICAgICAgJ2xlYXZlJywgdGhpcy4kcmVmcy5zbGlkZXMuc2xpZGUodGhpcy5sYXN0U2xpZGUpLCB0aGlzLiRyZWZzLnNsaWRlcy5zbGlkZSh0aGlzLmN1cnJlbnRTbGlkZSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBjb21wdXRlZDoge1xuXG4gICAgICAgIG92ZXJmbG93RWxlbWVudCgpIHtcbiAgICAgICAgICAgIGlmKHRoaXMub3ZlcmZsb3cgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKHRoaXMub3ZlcmZsb3cgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3ZlcmZsb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKHRoaXMub3ZlcmZsb3cgJiYgdGhpcy5vdmVyZmxvdy5lbG0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vdmVyZmxvdy5lbG07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKHRoaXMub3ZlcmZsb3cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0aGlzLm92ZXJmbG93KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICBub2RlcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRzbG90cy5kZWZhdWx0O1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgbW91bnRlZCgpIHtcbiAgICAgICAgaWYodGhpcy5vdmVyZmxvd0VsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMub3ZlcmZsb3dFbGVtZW50LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhlaWdodDogbnVsbCxcbiAgICAgICAgICAgIHdpZHRoOiBudWxsLFxuICAgICAgICAgICAgbGFzdFNsaWRlOiBudWxsLFxuICAgICAgICAgICAgY3VycmVudFNsaWRlOiB0aGlzLmFjdGl2ZSxcbiAgICAgICAgICAgIGRpcmVjdGlvbjogJ2ZvcndhcmQnXG4gICAgICAgIH1cbiAgICB9XG5cbn07XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJzY3NzXCI+XG4uc2xpZGUtZGVjayB7XG4gICAgaGVpZ2h0OiBhdXRvO1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcblxuICAgICYuc2xpZGUtZGVjay1mbGV4IHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG5cbiAgICAgICAgLnNsaWRlLWRlY2stY29udGVudCB7XG4gICAgICAgICAgICBmbGV4OiAxO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLnNsaWRlLWRlY2stY29udGVudCB7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgdHJhbnNpdGlvbjogYWxsIC4zMzNzIGVhc2U7XG4gICAgfVxuXG4gICAgLypcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgKi9cblxuICAgIC5zbGlkZS1kZWNrLWNvbnRyb2xzIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICBsZWZ0OiA1MCU7XG4gICAgICAgIGJvdHRvbTogMXJlbTtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MCUpO1xuICAgIH1cblxuICAgIC5zbGlkZS1mb3J3YXJkLWVudGVyLWFjdGl2ZSxcbiAgICAuc2xpZGUtZm9yd2FyZC1sZWF2ZS1hY3RpdmUsXG4gICAgLnNsaWRlLWJhY2t3YXJkLWVudGVyLWFjdGl2ZSxcbiAgICAuc2xpZGUtYmFja3dhcmQtbGVhdmUtYWN0aXZlIHtcbiAgICAgICAgb3BhY2l0eTogMDtcbiAgICAgICAgdHJhbnNpdGlvbjogYWxsIC4zMzNzIGVhc2Utb3V0O1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogMDtcbiAgICB9XG5cbiAgICAuc2xpZGUtZm9yd2FyZC1lbnRlci1hY3RpdmUsXG4gICAgLnNsaWRlLWJhY2t3YXJkLWVudGVyLWFjdGl2ZSB7XG4gICAgICAgIHRyYW5zaXRpb246IGFsbCAuMzMzcyBlYXNlLW91dDtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgfVxuXG4gICAgLnNsaWRlLWZvcndhcmQtZW50ZXItYWN0aXZlIHtcbiAgICAgICAgbGVmdDogMDtcbiAgICB9XG5cbiAgICAuc2xpZGUtYmFja3dhcmQtZW50ZXItYWN0aXZlIHtcbiAgICAgICAgcmlnaHQ6IDA7XG4gICAgfVxuXG4gICAgLnNsaWRlLWZvcndhcmQtZW50ZXItYWN0aXZlLFxuICAgIC5zbGlkZS1iYWNrd2FyZC1sZWF2ZS10byB7XG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgxMTUlKTtcbiAgICB9XG5cbiAgICAuc2xpZGUtZm9yd2FyZC1sZWF2ZS10byxcbiAgICAuc2xpZGUtYmFja3dhcmQtZW50ZXItYWN0aXZlIHtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC0xMTUlKTtcbiAgICB9XG5cbiAgICAuc2xpZGUtZm9yd2FyZC1lbnRlci10byxcbiAgICAuc2xpZGUtYmFja3dhcmQtZW50ZXItdG8ge1xuICAgICAgICBvcGFjaXR5OiAxO1xuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMCk7XG4gICAgfVxuXG59XG48L3N0eWxlPlxuIiwiaW1wb3J0IFNsaWRlcyBmcm9tICcuL1NsaWRlcyc7XG5pbXBvcnQgU2xpZGVEZWNrIGZyb20gJy4vU2xpZGVEZWNrJztcbmltcG9ydCBWdWVJbnN0YWxsZXIgZnJvbSAnLi4vLi4vSGVscGVycy9WdWVJbnN0YWxsZXIvVnVlSW5zdGFsbGVyJztcblxuY29uc3QgcGx1Z2luID0gVnVlSW5zdGFsbGVyLnVzZSh7XG5cbiAgICBpbnN0YWxsKFZ1ZSwgb3B0aW9ucykge1xuICAgICAgICBWdWVJbnN0YWxsZXIuY29tcG9uZW50cyh7XG4gICAgICAgICAgICBTbGlkZXMsXG4gICAgICAgICAgICBTbGlkZURlY2tcbiAgICAgICAgfSk7XG4gICAgfVxuXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgU2xpZGVEZWNrO1xuIiwiPHRlbXBsYXRlPlxuXG5cdDx0aCBzY29wZT1cImNvbFwiPlxuXHQgICAgPHRlbXBsYXRlIHYtaWY9XCJpZCAmJiByZXF1ZXN0XCI+XG5cdFx0XHQ8YSBocmVmPVwiI1wiXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJzb3J0XCJcbiAgICAgICAgICAgICAgICA6ZGF0YS1pZD1cImlkXCJcbiAgICAgICAgICAgICAgICBAY2xpY2sucHJldmVudD1cIiRlbWl0KCdvcmRlcicsIGlkKVwiPlxuICAgICAgICAgICAgICAgIDx0ZW1wbGF0ZSB2LWlmPVwiISRzbG90cy5kZWZhdWx0XCI+XG4gICAgICAgICAgICAgICAgICAgIHt7IGxhYmVsIHx8IG5hbWUgfHwgaWQgfX1cbiAgICAgICAgICAgICAgICA8L3RlbXBsYXRlPlxuICAgICAgICAgICAgICAgIDxzbG90Lz5cbiAgICAgICAgICAgIDwvYT5cblx0XHRcdDxpIHYtaWY9XCJyZXF1ZXN0LnBhcmFtcy5vcmRlciA9PT0gaWQgJiYgcmVxdWVzdC5wYXJhbXMuc29ydCA9PT0gJ2FzYydcIiBjbGFzcz1cInNvcnQtaWNvbiBmYSBmYS1zb3J0LWFzY1wiLz5cblx0XHRcdDxpIHYtaWY9XCJyZXF1ZXN0LnBhcmFtcy5vcmRlciA9PT0gaWQgJiYgcmVxdWVzdC5wYXJhbXMuc29ydCA9PT0gJ2Rlc2MnXCIgY2xhc3M9XCJzb3J0LWljb24gZmEgZmEtc29ydC1kZXNjXCIvPlxuXHRcdDwvdGVtcGxhdGU+XG4gICAgICAgIDx0ZW1wbGF0ZSB2LWVsc2U+XG4gICAgICAgICAgICA8dGVtcGxhdGUgdi1pZj1cIiEkc2xvdHMuZGVmYXVsdFwiPlxuICAgICAgICAgICAgICAgIHt7IGxhYmVsIHx8IG5hbWUgfHwgaWQgfX1cbiAgICAgICAgICAgIDwvdGVtcGxhdGU+XG4gICAgICAgICAgICA8c2xvdC8+XG4gICAgICAgIDwvdGVtcGxhdGU+XG5cdDwvdGg+XG5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICd0YWJsZS12aWV3LWhlYWRlcicsXG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIGlkOiBbTnVtYmVyLCBTdHJpbmddLFxuXG4gICAgICAgIGxhYmVsOiBbTnVtYmVyLCBTdHJpbmddLFxuXG4gICAgICAgIG5hbWU6IFtOdW1iZXIsIFN0cmluZ10sXG5cbiAgICAgICAgcmVxdWVzdDogT2JqZWN0XG5cbiAgICB9XG5cbn1cblxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG5cbiAgICA8dGFibGUgY2xhc3M9XCJ0YWJsZVwiIDpjbGFzcz1cInsndGFibGUtaG92ZXInOiBob3ZlciAmJiAhbG9hZGluZyAmJiBkYXRhLmxlbmd0aH1cIj5cblxuICAgICAgICA8dGhlYWQgc2xvdD1cInRoZWFkXCI+XG4gICAgICAgICAgICA8dHIgdi1pZj1cImNvbHVtbnMubGVuZ3RoIHx8ICRzbG90cy5jb2x1bW5zXCIgc2xvdD1cImNvbHVtbnNcIj5cbiAgICAgICAgICAgICAgICA8dGFibGUtdmlldy1oZWFkZXJcbiAgICAgICAgICAgICAgICAgICAgdi1mb3I9XCIoY29sdW1uLCBrZXkpIGluIHRhYmxlQ29sdW1uc1wiXG4gICAgICAgICAgICAgICAgICAgIHYtYmluZD1cImNvbHVtbi5wcm9wcyB8fCBjb2x1bW5cIlxuICAgICAgICAgICAgICAgICAgICB2LW9uPVwiY29sdW1uLmV2ZW50c1wiXG4gICAgICAgICAgICAgICAgICAgIDpyZXF1ZXN0PVwicmVxdWVzdFwiXG4gICAgICAgICAgICAgICAgICAgIDprZXk9XCJrZXlcIlxuICAgICAgICAgICAgICAgICAgICBAb3JkZXI9XCJpZCA9PiAkZW1pdCgnb3JkZXInLCBpZClcIlxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8L3RyPlxuICAgICAgICA8L3RoZWFkPlxuXG4gICAgICAgIDx0Ym9keT5cbiAgICAgICAgICAgIDx0ciB2LWlmPVwibG9hZGluZ1wiPlxuICAgICAgICAgICAgICAgIDx0ZCA6Y29sc3Bhbj1cInRhYmxlQ29sdW1ucy5sZW5ndGhcIiBjbGFzcz1cInBvc2l0aW9uLXJlbGF0aXZlXCIgOnN0eWxlPVwieydoZWlnaHQnOiBoZWlnaHQobWluSGVpZ2h0KX1cIj5cbiAgICAgICAgICAgICAgICAgICAgPGFjdGl2aXR5LWluZGljYXRvciA6Y2VudGVyPVwidHJ1ZVwiPjwvYWN0aXZpdHktaW5kaWNhdG9yPlxuICAgICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICA8L3RyPlxuXG4gICAgICAgICAgICA8dHIgdi1lbHNlLWlmPVwiIWRhdGEubGVuZ3RoXCI+XG4gICAgICAgICAgICAgICAgPHRkIDpjb2xzcGFuPVwidGFibGVDb2x1bW5zLmxlbmd0aFwiIGNsYXNzPVwicG9zaXRpb24tcmVsYXRpdmVcIj5cbiAgICAgICAgICAgICAgICAgICAgPGFsZXJ0IHZhcmlhbnQ9XCJ3YXJuaW5nXCIgY2xhc3M9XCJteS0zXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cImZhIGZhLXdhcm5pbmdcIi8+IFRoZXJlIGFyZSBubyByZXN1bHRzIGZvdW5kLlxuICAgICAgICAgICAgICAgICAgICA8L2FsZXJ0PlxuICAgICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICA8L3RyPlxuXG4gICAgICAgICAgICA8c2xvdCB2LWVsc2UgOmRhdGE9XCJkYXRhXCIgOmNvbHVtbnM9XCJ0YWJsZUNvbHVtbnNcIj5cbiAgICAgICAgICAgICAgICA8dHIgdi1mb3I9XCIocm93LCBpKSBpbiBkYXRhXCI+XG4gICAgICAgICAgICAgICAgICAgIDx0ZCB2LWZvcj1cImNvbHVtbiBpbiB0YWJsZUNvbHVtbnNcIiB2LWh0bWw9XCJyb3dbY29sdW1uLmlkXSB8fCByb3dbY29sdW1uLm5hbWVdXCI+PC90ZD5cbiAgICAgICAgICAgICAgICA8L3RyPlxuICAgICAgICAgICAgPC9zbG90PlxuICAgICAgICA8L3Rib2R5PlxuXG4gICAgICAgIDxzbG90IG5hbWU9XCJ0Zm9vdFwiPlxuICAgICAgICAgICAgPHRmb290IHYtaWY9XCJwYWdpbmF0ZSAmJiByZXNwb25zZVwiPlxuICAgICAgICAgICAgICAgIDx0ZCA6Y29sc3Bhbj1cInRhYmxlQ29sdW1ucy5sZW5ndGggfHwgMVwiIGNsYXNzPVwidGFibGUtdmlldy1mb290ZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgPHNsb3QgbmFtZT1cInBhZ2luYXRpb25cIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxwYWdpbmF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ249XCJjZW50ZXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDpwYWdlPVwicmVzcG9uc2UuY3VycmVudF9wYWdlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6dG90YWwtcGFnZXM9XCJyZXNwb25zZS5sYXN0X3BhZ2VcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEBwYWdpbmF0ZT1cIiRlbWl0KCdwYWdpbmF0ZScpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgIDwvc2xvdD5cbiAgICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgPC90Zm9vdD5cbiAgICAgICAgPC9zbG90PlxuXG4gICAgPC90YWJsZT5cblxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBBbGVydCBmcm9tICcuLi9BbGVydCc7XG5pbXBvcnQgeyBrZXlzIH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCB7IGVhY2ggfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IHsgaXNPYmplY3QgfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IHVuaXQgZnJvbSAnLi4vLi4vSGVscGVycy9Vbml0JztcbmltcG9ydCBQYWdpbmF0aW9uIGZyb20gJy4uL1BhZ2luYXRpb24nO1xuaW1wb3J0IFRhYmxlVmlld0hlYWRlciBmcm9tICcuL1RhYmxlVmlld0hlYWRlcic7XG5pbXBvcnQgQWN0aXZpdHlJbmRpY2F0b3IgZnJvbSAnLi4vQWN0aXZpdHlJbmRpY2F0b3InO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBjb21wb25lbnRzOiB7XG4gICAgICAgIEFsZXJ0LFxuICAgICAgICBQYWdpbmF0aW9uLFxuICAgICAgICBUYWJsZVZpZXdIZWFkZXIsXG4gICAgICAgIEFjdGl2aXR5SW5kaWNhdG9yXG4gICAgfSxcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgLy8gKGFycmF5KSBBbiBhcnJheSBvZiB0YWJsZSBjb2x1bW5cbiAgICAgICAgLy8gW3tpZDogJ2RhdGFiYXNlX2lkJywgbmFtZTogJ0RhdGFiYXNlIGlkJywgd2lkdGg6ICcyMCUnfV1cbiAgICAgICAgY29sdW1uczoge1xuICAgICAgICAgICAgdHlwZTogQXJyYXksXG4gICAgICAgICAgICBkZWZhdWx0OiAoKSA9PiB7IHJldHVybiBbXTsgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICAvLyAoc3RyaW5nKSBBZGQgdGFibGUtaG92ZXIgdG8gdGhlIHRhYmxlIGVsZW1lbnRcbiAgICAgICAgaG92ZXI6IHtcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgICBkZWZhdWx0OiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgbG9hZGluZzogQm9vbGVhbixcblxuICAgICAgICAvLyAoaW50ZWdlcikgVGhlIG1pbmltdW0gaGVpZ2h0IG9mIHRoZSByb3cgd2hlbiBsb2FkaW5nIGRhdGFcbiAgICAgICAgbWluSGVpZ2h0OiB7XG4gICAgICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgICAgICBkZWZhdWx0OiA0MDBcbiAgICAgICAgfSxcblxuICAgICAgICAvLyAoYm9vbCkgU2hvdWxkIHNob3cgdGhlIHBhZ2luYXRpb24gZm9yIHRoaXMgdGFibGVcbiAgICAgICAgcGFnaW5hdGU6IHtcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgICBkZWZhdWx0OiB0cnVlXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBtZXRob2RzOiB7XG5cbiAgICAgICAgaGVpZ2h0KG1pbikge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudHMgPSBbXG4gICAgICAgICAgICAgICAgLy8gdGhpcy4kZWwucXVlcnlTZWxlY3RvcigndGhlYWQnKSxcbiAgICAgICAgICAgICAgICB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yKCd0Ym9keScpXG4gICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICBsZXQgaGVpZ2h0ID0gMDtcblxuICAgICAgICAgICAgZWFjaChlbGVtZW50cywgZWwgPT4ge1xuICAgICAgICAgICAgICAgIGhlaWdodCArPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHVuaXQoTWF0aC5tYXgobWluLCBoZWlnaHQpKTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIHRhYmxlQ29sdW1ucygpIHtcbiAgICAgICAgICAgIGxldCBjb2x1bW5zID0gdGhpcy5jb2x1bW5zO1xuXG4gICAgICAgICAgICBpZighY29sdW1ucyB8fCAhY29sdW1ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb2x1bW5zID0ga2V5cyh0aGlzLmRhdGFbMF0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY29sdW1ucy5tYXAoY29sdW1uID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNPYmplY3QoY29sdW1uKSA/IGNvbHVtbiA6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogY29sdW1uXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG59XG5cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHsgZWFjaCB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgeyBpc0FycmF5IH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCB7IGlzT2JqZWN0IH0gZnJvbSAnbG9kYXNoLWVzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVHJhbnNmb3JtZXIge1xuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0aGUgdHJhbnNmb3JtZXIgaW5zdGFuY2UgdXNpbmcgYW4gSFRUUCByZXNwb25zZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGF0YSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihyZXNwb25zZSkge1xuICAgICAgICBpZighaXNPYmplY3QodGhpcy4kb3JpZ2luYWxSZXNwb25zZSA9IHJlc3BvbnNlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgdHJhbnNmb3JtZXIgbXVzdCBiZSBpbnN0YW50aWF0ZWQgd2l0aCBhIHJlc3BvbnNlIG9iamVjdC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCFpc0FycmF5KHRoaXMuJHJlcXVpcmVkID0gdGhpcy5yZXF1aXJlZCgpKSB8fCAhdGhpcy4kcmVxdWlyZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgdHJhbnNmb3JtZXIgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSByZXF1aXJlZCBwcm9wZXJ0eS4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuJHRyYW5zZm9ybWVkUmVzcG9uc2UgPSB0aGlzLnRyYW5zZm9ybShyZXNwb25zZSk7XG4gICAgICAgIHRoaXMudmFsaWRhdGUoKTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBtZXRob2QgdG8gb3ZlcnJpZGUgdG8gcGVyZm9ybSBsb2dpYyB0byBmaW5pc2hlZCBpbml0aWFsaXppbmcuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgKi9cbiAgICBpbml0aWFsaXplKCkge1xuICAgICAgICAvL1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlZmluZSBhbiBhcnJheSBvZiByZXF1aXJlZCBwcm9wZXJ0aWVzIHdpdGggYXQgbGVhc3Qgb25lIHZhbHVlLlxuICAgICAqXG4gICAgICogQHJldHVybiB2b2lkXG4gICAgICovXG4gICAgcmVxdWlyZWQoKSB7XG4gICAgICAgIC8vXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJhbmZvcm0gdGhlIHJlc3BvbnNlIG9iamVjdFxuICAgICAqXG4gICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAqL1xuICAgIHRyYW5zZm9ybShyZXNwb25zZSkge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB0cmFuZm9ybWVkIHJlc3BvbnNlXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICovXG4gICAgcmVzcG9uc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiR0cmFuc2Zvcm1lZFJlc3BvbnNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlIHRoZSB0cmFuZm9ybWVkIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogQHJldHVybiB2b2lkXG4gICAgICovXG4gICAgdmFsaWRhdGUoKSB7XG4gICAgICAgIGlmKCFpc09iamVjdCh0aGlzLiR0cmFuc2Zvcm1lZFJlc3BvbnNlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgdHJhbnNmb3JtZWQgcmVzcG9uc2UgbXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBlYWNoKHRoaXMuJHJlcXVpcmVkLCBrZXkgPT4ge1xuICAgICAgICAgICAgaWYoIShrZXkgaW4gdGhpcy4kdHJhbnNmb3JtZWRSZXNwb25zZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHtrZXl9XCIgaXMgYSByZXF1aXJlZCBwcm9wZXJ0eSBhbmQgZG9lcyBub3QgZXhpc3QgaW4gdGhlIHRyYW5mb3JtZWQgcmVzcG9uc2UuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxufVxuIiwiaW1wb3J0IHsgaXNBcnJheSB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgVHJhbnNmb3JtZXIgZnJvbSAnLi4vVHJhbnNmb3JtZXInO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUYWJsZVZpZXdUcmFuc2Zvcm1lciBleHRlbmRzIFRyYW5zZm9ybWVyIHtcblxuICAgIHJlcXVpcmVkKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgLy8gVGhlIGVuZCBvZiB0aGUgY291bnQgb2YgdGhlIHBhZ2luYXRlZCBsaXN0LlxuICAgICAgICAgICAgJ3RvJyxcblxuICAgICAgICAgICAgLy8gVGhlIHN0YXJ0IG9mIHRoZSBjb3VudCBvZiB0aGUgcGFnaW5hdGVkIGxpc3QuXG4gICAgICAgICAgICAnZnJvbScsXG5cbiAgICAgICAgICAgIC8vIFRoZSB0b3RhbCBudW1iZXIgb2YgaXRlbXMgKG5vdCBqdXN0IGluY2x1ZGVkIGluIHRoZSBwYWdpbmF0aW9uKVxuICAgICAgICAgICAgJ3RvdGFsJyxcblxuICAgICAgICAgICAgLy8gVGhlIG51bWJlciBvZiBpdGVtcyBwZXIgcGFnZVxuICAgICAgICAgICAgJ3Blcl9wYWdlJyxcblxuICAgICAgICAgICAgLy8gVGhlIGxhc3QgcGFnZSBudW1iZXIgKG9yIHRvdGFsIHBhZ2VzKVxuICAgICAgICAgICAgJ2xhc3RfcGFnZScsXG5cbiAgICAgICAgICAgIC8vIFRoZSBjdXJyZW50IHBhZ2UgbnVtYmVyXG4gICAgICAgICAgICAnY3VycmVudF9wYWdlJyxcblxuICAgICAgICAgICAgLy8gVGhlIGFjdHVhbCByZXNwb25zZSBkYXRhIHRvIGFwcGVhciBpbiB0aGUgdGFibGVcbiAgICAgICAgICAgICdkYXRhJ1xuICAgICAgICBdO1xuICAgIH1cblxuICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiR0cmFuc2Zvcm1lZFJlc3BvbnNlLmRhdGE7XG4gICAgfVxuXG4gICAgaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgaWYoIWlzQXJyYXkodGhpcy5kYXRhKCkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBkYXRhIHByb3BlcnR5IG11c3QgYmUgYW4gYXJyYXkuJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbn1cbiIsIjx0ZW1wbGF0ZT5cblxuICAgIDxkaXYgY2xhc3M9XCJ0YWJsZS12aWV3XCI+XG5cbiAgICAgICAgPGRpdiB2LWlmPVwiaGVhZGluZyB8fCBkZXNjcmlwdGlvbiB8fCAkc2xvdHMuYnV0dG9uc1wiIGNsYXNzPVwiZC1mbGV4IGp1c3RpZnktY29udGVudC1iZXR3ZWVuIGFsaWduLWl0ZW1zLWNlbnRlclwiPlxuICAgICAgICAgICAgPHNsb3QgbmFtZT1cImhlYWRpbmdcIj48aDIgdi1pZj1cImhlYWRpbmdcIiB2LWh0bWw9XCJoZWFkaW5nXCIvPjwvc2xvdD5cbiAgICAgICAgICAgIDxzbG90IG5hbWU9XCJkZXNjcmlwdGlvblwiPjxwIHYtaWY9XCJkZXNjcmlwdGlvblwiIHYtaHRtbD1cImRlc2NyaXB0aW9uXCIvPjwvc2xvdD5cblxuICAgICAgICAgICAgPGRpdiB2LWlmPVwiJHNsb3RzLmJ1dHRvbnNcIiBjbGFzcz1cIm1sLWF1dG8gbXktM1wiPlxuICAgICAgICAgICAgICAgIDxzbG90IG5hbWU9XCJidXR0b25zXCIvPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIDxjYXJkIHYtaWY9XCJjYXJkXCI+XG4gICAgICAgICAgICA8ZGF0YS10YWJsZVxuICAgICAgICAgICAgICAgIDpjb2x1bW5zPVwiY29sdW1uc1wiXG4gICAgICAgICAgICAgICAgOmRhdGE9XCJkYXRhXCJcbiAgICAgICAgICAgICAgICA6aG92ZXI9XCJob3ZlclwiXG4gICAgICAgICAgICAgICAgOmxvYWRpbmc9XCJsb2FkaW5nXCJcbiAgICAgICAgICAgICAgICA6bWluLWhlaWdodD1cIm1pbkhlaWdodFwiXG4gICAgICAgICAgICAgICAgOnBhZ2luYXRlPVwicGFnaW5hdGVcIlxuICAgICAgICAgICAgICAgIEBwYWdpbmF0ZT1cIm9uUGFnaW5hdGVcIlxuICAgICAgICAgICAgICAgIEBvcmRlcj1cImlkID0+IG9yZGVyQnkoaWQpXCI+XG4gICAgICAgICAgICAgICAgPHNsb3QgOmRhdGE9XCJkYXRhXCIgOmNvbHVtbnM9XCJjb2x1bW5zXCIvPlxuICAgICAgICAgICAgPC9kYXRhLXRhYmxlLz5cbiAgICAgICAgPC9jYXJkPlxuICAgICAgICA8ZGF0YS10YWJsZVxuICAgICAgICAgICAgdi1lbHNlXG4gICAgICAgICAgICA6Y29sdW1ucz1cImNvbHVtbnNcIlxuICAgICAgICAgICAgOmRhdGE9XCJkYXRhXCJcbiAgICAgICAgICAgIDpob3Zlcj1cImhvdmVyXCJcbiAgICAgICAgICAgIDpsb2FkaW5nPVwibG9hZGluZ1wiXG4gICAgICAgICAgICA6bWluLWhlaWdodD1cIm1pbkhlaWdodFwiXG4gICAgICAgICAgICA6cGFnaW5hdGU9XCJwYWdpbmF0ZVwiXG4gICAgICAgICAgICBAcGFnaW5hdGU9XCJvblBhZ2luYXRlXCJcbiAgICAgICAgICAgIEBvcmRlcj1cImlkID0+IG9yZGVyQnkoaWQpXCI+XG4gICAgICAgICAgICA8c2xvdCA6ZGF0YT1cImRhdGFcIiA6Y29sdW1ucz1cImNvbHVtbnNcIi8+XG4gICAgICAgIDwvZGF0YS10YWJsZS8+XG5cbiAgICA8L2Rpdj5cblxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBDYXJkIGZyb20gJy4uL0NhcmQnO1xuaW1wb3J0IERhdGFUYWJsZSBmcm9tICcuL1RhYmxlJztcbmltcG9ydCB7IGV4dGVuZCB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgUHJveHkgZnJvbSAnLi4vLi4vTWl4aW5zL1Byb3h5JztcbmltcG9ydCBSZXF1ZXN0IGZyb20gJy4uLy4uL0h0dHAvUmVxdWVzdCc7XG5pbXBvcnQgVGFibGVWaWV3SGVhZGVyIGZyb20gJy4vVGFibGVWaWV3SGVhZGVyJztcbmltcG9ydCBUYWJsZVZpZXdUcmFuc2Zvcm1lciBmcm9tICcuLi8uLi9IdHRwL1RhYmxlVmlld1RyYW5zZm9ybWVyJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIG5hbWU6ICd0YWJsZS12aWV3JyxcblxuICAgIG1peGluczogW1Byb3h5XSxcblxuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgICAgQ2FyZCxcbiAgICAgICAgRGF0YVRhYmxlLFxuICAgICAgICBUYWJsZVZpZXdIZWFkZXJcbiAgICB9LFxuXG4gICAgcHJvcHM6IHtcblxuICAgICAgICAvLyAoYm9vbGVhbikgU2hvdyB0aGUgdGFibGUgaW4gYSBjYXJkLlxuICAgICAgICBjYXJkOiBCb29sZWFuLFxuXG4gICAgICAgIC8vIChzdHJpbmcpIEEgcmVsYXRpdmUgb3IgYWJzb2x1dGUgZW5kcG9pbnQgVVJMIHVzZWQgdG8gZmV0Y2ggZGF0YVxuICAgICAgICB1cmw6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gKGludGVnZXIpIFRoZSBzdGFydGluZyBwYWdlIG9mIHRoZSB0YWJsZVxuICAgICAgICBwYWdlOiB7XG4gICAgICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgICAgICBkZWZhdWx0OiAxXG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gKGludGVnZXIpIFRoZSB0b3RhbCBudW1iZXIgb2YgcmVzdWx0cyBwZXIgcGFnZVxuICAgICAgICBsaW1pdDoge1xuICAgICAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICAgICAgZGVmYXVsdDogMjBcbiAgICAgICAgfSxcblxuICAgICAgICAvLyAoc3RyaW5nKSBUaGUgY29sdW1uIHVzZWQgdG8gb3JkZXIgdGhlIGRhdGFcbiAgICAgICAgb3JkZXI6IFN0cmluZyxcblxuICAgICAgICAvLyAoc3RyaW5nKSBUaGUgc29ydCBkaXJlY3Rpb24gKGFzY3xkZXNjKVxuICAgICAgICBzb3J0OiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICB2YWxpZGF0ZTogKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsnYXNjJywgJ2Rlc2MnXS5pbmRleE9mKHZhbHVlKSAhPT0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gKGludGVnZXIpIFRoZSBtaW5pbXVtIGhlaWdodCBvZiB0aGUgcm93IHdoZW4gbG9hZGluZyBkYXRhXG4gICAgICAgIG1pbkhlaWdodDoge1xuICAgICAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICAgICAgZGVmYXVsdDogNDAwXG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gKGFycmF5KSBBbiBhcnJheSBvZiBidXR0b24gb2JqZWN0c1xuICAgICAgICAvLyBbe2hyZWY6ICd0ZXN0LTEyMycsIGxhYmVsOiAnVGVzdCAxMjMnfV1cbiAgICAgICAgYnV0dG9uczoge1xuICAgICAgICAgICAgdHlwZTogQXJyYXksXG4gICAgICAgICAgICBkZWZhdWx0OiAoKSA9PiB7IHJldHVybiBbXTsgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIChhcnJheSkgQW4gYXJyYXkgb2YgdGFibGUgY29sdW1uXG4gICAgICAgIC8vIFt7aWQ6ICdkYXRhYmFzZV9pZCcsIG5hbWU6ICdEYXRhYmFzZSBpZCcsIHdpZHRoOiAnMjAlJ31dXG4gICAgICAgIGNvbHVtbnM6IHtcbiAgICAgICAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgICAgICAgZGVmYXVsdDogKCkgPT4geyByZXR1cm4gW107IH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyAoc3RyaW5nKSBUaGUgdGFibGUgaGVhZGluZ1xuICAgICAgICBoZWFkaW5nOiBTdHJpbmcsXG5cbiAgICAgICAgLy8gKHN0cmluZykgQWRkIHRhYmxlLWhvdmVyIHRvIHRoZSB0YWJsZSBlbGVtZW50XG4gICAgICAgIGhvdmVyOiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIChzdHJpbmcpIFRoZSB0YWJsZSBkZXNjcmlwdGlvblxuICAgICAgICBkZXNjcmlwdGlvbjogU3RyaW5nLFxuXG4gICAgICAgIC8vIChib29sKSBTaG91bGQgc2hvdyB0aGUgcGFnaW5hdGlvbiBmb3IgdGhpcyB0YWJsZVxuICAgICAgICBwYWdpbmF0ZToge1xuICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICAvLyAob2JqZWN0KSBUaGUgSFRUUCByZXNwb25zZSB0cmFuc2Zvcm1lciBpbnN0YW5jZVxuICAgICAgICB0cmFuc2Zvcm1lcjoge1xuICAgICAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICAgICAgdmFsaWRhdGU6ICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFRhYmxlVmlld1RyYW5zZm9ybWVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1ldGhvZHM6IHtcblxuICAgICAgICBvcmRlckJ5KG9yZGVyKSB7XG4gICAgICAgICAgICBjb25zdCBkZWZhdWx0U29ydCA9ICdkZXNjJztcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRTb3J0ID0gdGhpcy5nZXRSZXF1ZXN0UGFyYW0oJ3NvcnQnKTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRPcmRlciA9IHRoaXMuZ2V0UmVxdWVzdFBhcmFtKCdvcmRlcicpO1xuXG4gICAgICAgICAgICB0aGlzLmFkZFJlcXVlc3RQYXJhbSgnb3JkZXInLCBvcmRlcik7XG4gICAgICAgICAgICB0aGlzLmFkZFJlcXVlc3RQYXJhbSgnc29ydCcsXG4gICAgICAgICAgICAgICAgY3VycmVudE9yZGVyICE9PSBvcmRlciB8fCAhY3VycmVudFNvcnQgPyBkZWZhdWx0U29ydCA6IChcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFNvcnQgPT09IGRlZmF1bHRTb3J0ID8gJ2FzYycgOiBudWxsXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgdGhpcy5mZXRjaCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdC5oZWFkZXJzW2tleV0gfHwgdmFsdWVcbiAgICAgICAgfSxcblxuICAgICAgICBhZGRSZXF1ZXN0SGVhZGVyKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmKCF0aGlzLnJlcXVlc3QuaGVhZGVycykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdC5oZWFkZXJzID0ge307XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucmVxdWVzdC5oZWFkZXJzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRSZXF1ZXN0UGFyYW0oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdC5wYXJhbXNba2V5XSB8fCB2YWx1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIGFkZFJlcXVlc3RQYXJhbShrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICBpZighdGhpcy5yZXF1ZXN0LnBhcmFtcykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdC5wYXJhbXMgPSB7fTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0LnBhcmFtc1trZXldID0gdmFsdWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmV0Y2goKSB7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFJlcXVlc3QodGhpcy51cmwsIHRoaXMucmVxdWVzdCk7XG5cbiAgICAgICAgICAgIHRoaXMubG9hZGluZyA9IHRydWU7XG5cbiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0LmdldCgpLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybWVyID0gdGhpcy50cmFuc2Zvcm1lciB8fCBuZXcgVGFibGVWaWV3VHJhbnNmb3JtZXIocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzcG9uc2UgPSB0cmFuc2Zvcm1lci5yZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YSA9IHRyYW5zZm9ybWVyLmRhdGEoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH0sIGVycm9ycyA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBvblBhZ2luYXRlKHBhZ2UsIGV2ZW50KSB7XG4gICAgICAgICAgICBpZighdGhpcy5yZXF1ZXN0LnBhcmFtcykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdC5wYXJhbXMgPSB7fTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0LnBhcmFtcy5wYWdlID0gcGFnZTtcbiAgICAgICAgICAgIHRoaXMuZmV0Y2goKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8gKGFycmF5KSBUaGUgZGF0YXNldCBmb3IgdGhlIHRhYmxlXG4gICAgICAgICAgICBkYXRhOiB0aGlzLiRhdHRycy5kYXRhIHx8IFtdLFxuXG4gICAgICAgICAgICAvLyAoYm9vbCkgSXMgdGhlIHRhYmxlIGN1cnJlbnRseSBsb2FkaW5nIGRhdGFcbiAgICAgICAgICAgIGxvYWRpbmc6IGZhbHNlLFxuXG4gICAgICAgICAgICAvLyAobnVsbHxvYmplY3QpIFRoZSByZXNwb25zZSBvYmplY3RcbiAgICAgICAgICAgIHJlc3BvbnNlOiBudWxsLFxuXG4gICAgICAgICAgICAvLyAob2JqZWN0KSBUaGUgSFRUUCByZXF1ZXN0IG9iamVjdFxuICAgICAgICAgICAgcmVxdWVzdDogZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7fSxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICAgICAgcGFnZTogdGhpcy5wYWdlLFxuICAgICAgICAgICAgICAgICAgICBsaW1pdDogdGhpcy5saW1pdCxcbiAgICAgICAgICAgICAgICAgICAgb3JkZXI6IHRoaXMub3JkZXIsXG4gICAgICAgICAgICAgICAgICAgIHNvcnQ6IHRoaXMuc29ydFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMuJGF0dHJzLnJlcXVlc3QpXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIG1vdW50ZWQoKSB7XG4gICAgICAgIHRoaXMuZmV0Y2goKTtcbiAgICB9LFxuXG4gICAgYmVmb3JlRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy4kb2ZmKCk7XG4gICAgfVxufVxuXG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJzY3NzXCI+XG4uY2FyZCA+IC50YWJsZSB7XG4gICAgbWFyZ2luLWJvdHRvbTogMDtcblxuICAgIHRoZWFkIHRoIHtcbiAgICAgICAgYm9yZGVyLXRvcDogMDtcbiAgICAgICAgYm9yZGVyLWJvdHRvbTogMDtcbiAgICB9XG5cbiAgICB0Zm9vdCAucGFnaW5hdGlvbiB7XG4gICAgICAgIG1hcmdpbi1ib3R0b206IDA7XG4gICAgfVxufVxuPC9zdHlsZT5cbiIsImltcG9ydCBUYWJsZVZpZXcgZnJvbSAnLi9UYWJsZVZpZXcnO1xuaW1wb3J0IFZ1ZUluc3RhbGxlciBmcm9tICcuLi8uLi9IZWxwZXJzL1Z1ZUluc3RhbGxlci9WdWVJbnN0YWxsZXInO1xuXG5jb25zdCBwbHVnaW4gPSBWdWVJbnN0YWxsZXIudXNlKHtcblxuICAgIGluc3RhbGwoVnVlLCBvcHRpb25zKSB7XG4gICAgICAgIFZ1ZUluc3RhbGxlci5jb21wb25lbnRzKHtcbiAgICAgICAgICAgIFRhYmxlVmlld1xuICAgICAgICB9KTtcbiAgICB9XG5cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBUYWJsZVZpZXc7XG4iLCI8dGVtcGxhdGU+XG5cbiAgICA8Zm9ybS1ncm91cD5cblxuICAgICAgICA8c2xvdCBuYW1lPVwibGFiZWxcIj5cbiAgICAgICAgICAgIDxmb3JtLWxhYmVsIHYtaWY9XCJsYWJlbCB8fCBoYXNEZWZhdWx0U2xvdFwiIDpmb3I9XCJpZFwiPlxuICAgICAgICAgICAgICAgIDxzbG90Pnt7bGFiZWx9fTwvc2xvdD5cbiAgICAgICAgICAgIDwvZm9ybS1sYWJlbD5cbiAgICAgICAgPC9zbG90PlxuXG4gICAgICAgIDxzbG90IG5hbWU9XCJjb250cm9sXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwicG9zaXRpb24tcmVsYXRpdmVcIj5cbiAgICAgICAgICAgICAgICA8dGV4dGFyZWFcbiAgICAgICAgICAgICAgICAgICAgOmlkPVwiaWRcIlxuICAgICAgICAgICAgICAgICAgICA6cm93cz1cInJvd3NcIlxuICAgICAgICAgICAgICAgICAgICA6dmFsdWU9XCJ2YWx1ZVwiXG4gICAgICAgICAgICAgICAgICAgIDplcnJvcnM9XCJlcnJvcnNcIlxuICAgICAgICAgICAgICAgICAgICA6cGF0dGVybj1cInBhdHRlcm5cIlxuICAgICAgICAgICAgICAgICAgICA6cmVhZG9ubHk9XCJyZWFkb25seVwiXG4gICAgICAgICAgICAgICAgICAgIDpyZXF1aXJlZD1cInJlcXVpcmVkXCJcbiAgICAgICAgICAgICAgICAgICAgOm1heGxlbmd0aD1cIm1heGxlbmd0aFwiXG4gICAgICAgICAgICAgICAgICAgIDpwbGFjZWhvbGRlcj1cInBsYWNlaG9sZGVyXCJcbiAgICAgICAgICAgICAgICAgICAgOmRpc2FibGVkPVwiZGlzYWJsZWQgfHwgcmVhZG9ubHlcIlxuICAgICAgICAgICAgICAgICAgICA6Y2xhc3M9XCJtZXJnZUNsYXNzZXMoY29udHJvbENsYXNzZXMsIGNvbG9yYWJsZUNsYXNzZXMpXCJcbiAgICAgICAgICAgICAgICAgICAgdi1iaW5kLWV2ZW50cz1cImJpbmRFdmVudHNcIlxuICAgICAgICAgICAgICAgICAgICBAaW5wdXQ9XCIkZW1pdCgnaW5wdXQnLCAkZXZlbnQudGFyZ2V0LnZhbHVlKVwiPlxuICAgICAgICAgICAgICAgIDwvdGV4dGFyZWE+XG5cbiAgICAgICAgICAgICAgICA8c2xvdCBuYW1lPVwiZmVlZGJhY2tcIj5cbiAgICAgICAgICAgICAgICAgICAgPGZvcm0tZmVlZGJhY2sgdi1pZj1cInZhbGlkRmVlZGJhY2tcIiB2LWh0bWw9XCJ2YWxpZEZlZWRiYWNrXCIgdmFsaWQgLz5cbiAgICAgICAgICAgICAgICAgICAgPGZvcm0tZmVlZGJhY2sgdi1pZj1cImludmFsaWRGZWVkYmFja1wiIHYtaHRtbD1cImludmFsaWRGZWVkYmFja1wiIGludmFsaWQgLz5cbiAgICAgICAgICAgICAgICA8L3Nsb3Q+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9zbG90PlxuXG4gICAgICAgIDxzbG90IG5hbWU9XCJoZWxwXCI+XG4gICAgICAgICAgICA8aGVscC10ZXh0IHYtaWY9XCJoZWxwVGV4dFwiIHYtaHRtbD1cImhlbHBUZXh0XCIgLz5cbiAgICAgICAgPC9zbG90PlxuXG4gICAgPC9mb3JtLWdyb3VwPlxuXG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IEhlbHBUZXh0IGZyb20gJy4uL0hlbHBUZXh0JztcbmltcG9ydCBGb3JtR3JvdXAgZnJvbSAnLi4vRm9ybUdyb3VwJztcbmltcG9ydCBGb3JtTGFiZWwgZnJvbSAnLi4vRm9ybUxhYmVsJztcbmltcG9ydCBGb3JtRmVlZGJhY2sgZnJvbSAnLi4vRm9ybUZlZWRiYWNrJztcbmltcG9ydCBDb2xvcmFibGUgZnJvbSAnLi4vLi4vTWl4aW5zL0NvbG9yYWJsZSc7XG5pbXBvcnQgRm9ybUNvbnRyb2wgZnJvbSAnLi4vLi4vTWl4aW5zL0Zvcm1Db250cm9sJztcbmltcG9ydCBNZXJnZUNsYXNzZXMgZnJvbSAnLi4vLi4vTWl4aW5zL01lcmdlQ2xhc3Nlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICd0ZXh0YXJlYS1maWVsZCcsXG5cbiAgICBjb21wb25lbnRzOiB7XG4gICAgICAgIEhlbHBUZXh0LFxuICAgICAgICBGb3JtR3JvdXAsXG4gICAgICAgIEZvcm1MYWJlbCxcbiAgICAgICAgRm9ybUZlZWRiYWNrXG4gICAgfSxcblxuICAgIG1peGluczogW1xuICAgICAgICBDb2xvcmFibGUsXG4gICAgICAgIEZvcm1Db250cm9sLFxuICAgICAgICBNZXJnZUNsYXNzZXNcbiAgICBdLFxuXG4gICAgcHJvcHM6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0eXBlIGF0dHJpYnV0ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAndGV4dCdcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHJvd3MgYXR0cmlidXRlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHJvd3M6IFtOdW1iZXIsIFN0cmluZ11cbiAgICB9XG5cbn1cblxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgVGV4dGFyZWFGaWVsZCBmcm9tICcuL1RleHRhcmVhRmllbGQnO1xuaW1wb3J0IFZ1ZUluc3RhbGxlciBmcm9tICcuLi8uLi9IZWxwZXJzL1Z1ZUluc3RhbGxlci9WdWVJbnN0YWxsZXInO1xuXG5jb25zdCBwbHVnaW4gPSBWdWVJbnN0YWxsZXIudXNlKHtcblxuICAgIGluc3RhbGwoVnVlLCBvcHRpb25zKSB7XG4gICAgICAgIFZ1ZUluc3RhbGxlci5jb21wb25lbnRzKHtcbiAgICAgICAgICAgIFRleHRhcmVhRmllbGRcbiAgICAgICAgfSk7XG4gICAgfVxuXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgVGV4dGFyZWFGaWVsZDtcbiIsIjx0ZW1wbGF0ZT5cbiAgICA8ZGl2IGNsYXNzPVwidGh1bWJuYWlsLWxpc3QtaXRlbVwiIDpzdHlsZT1cIntoZWlnaHQ6IHVuaXQoaGVpZ2h0KSwgd2lkdGg6IHVuaXQod2lkdGgpLCBtaW5IZWlnaHQ6IHVuaXQobWluSGVpZ2h0KSwgbWF4SGVpZ2h0OiB1bml0KG1heEhlaWdodCksIG1pbldpZHRoOiB1bml0KG1pbldpZHRoKSwgbWF4V2lkdGg6IHVuaXQobWF4V2lkdGgpfVwiPlxuICAgICAgICA8aW1nIHYtaWY9XCJzcmNcIiA6c3JjPVwic3JjXCIgOmFsdD1cImFsdFwiIDpjbGFzcz1cInsnaW1nLWZsdWlkJzogZmx1aWR9XCIgLz5cbiAgICAgICAgPHNsb3QvPlxuICAgIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCB1bml0IGZyb20gJy4uLy4uL0hlbHBlcnMvVW5pdCc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgYWx0OiBTdHJpbmcsXG5cbiAgICAgICAgc3JjOiBTdHJpbmcsXG5cbiAgICAgICAgd2lkdGg6IFtTdHJpbmcsIE51bWJlcl0sXG5cbiAgICAgICAgaGVpZ2h0OiBbU3RyaW5nLCBOdW1iZXJdLFxuXG4gICAgICAgIG1pbkhlaWdodDogW1N0cmluZywgTnVtYmVyXSxcblxuICAgICAgICBtYXhIZWlnaHQ6IFtTdHJpbmcsIE51bWJlcl0sXG5cbiAgICAgICAgbWluV2lkdGg6IFtTdHJpbmcsIE51bWJlcl0sXG5cbiAgICAgICAgbWF4V2lkdGg6IFtTdHJpbmcsIE51bWJlcl0sXG5cbiAgICAgICAgZmx1aWQ6IHtcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgICBkZWZhdWx0OiB0cnVlXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBtZXRob2RzOiB7XG5cbiAgICAgICAgdW5pdDogdW5pdFxuXG4gICAgfVxuXG59XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJzY3NzXCI+XG4udGh1bWJuYWlsLWxpc3QtaXRlbSB7XG4gICAgbWF4LXdpZHRoOiAxMDAlO1xuICAgIG1heC1oZWlnaHQ6IDEwMCU7XG5cbiAgICAmID4gaW1nIHtcbiAgICAgICAgbWF4LXdpZHRoOiAxMDAlO1xuXG4gICAgICAgICYuaW1nLWZsdWlkIHtcbiAgICAgICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAmOm5vdCg6b25seS1jaGlsZCkge1xuICAgICAgICBtYXJnaW4tcmlnaHQ6IDEwcHg7XG4gICAgICAgIG1hcmdpbi1ib3R0b206IDEwcHg7XG4gICAgfVxuXG4gICAgJjpudGgtY2hpbGQoMm4pIHtcbiAgICAgICAgb3BhY2l0eTogLjI1O1xuICAgIH1cbiAgICAqL1xufVxuPC9zdHlsZT5cbiIsIjx0ZW1wbGF0ZT5cbiAgICA8ZGl2IGNsYXNzPVwidGh1bWJuYWlsLWxpc3RcIiA6Y2xhc3M9XCJjbGFzc2VzXCI+XG4gICAgICAgIDx0aHVtYm5haWwtbGlzdC1pdGVtIHYtaWY9XCIhIWltYWdlc1wiIHYtZm9yPVwiaW1hZ2UgaW4gaW1hZ2VzXCIgOnNyYz1cImltYWdlXCIgOndpZHRoPVwid2lkdGhcIiAvPlxuICAgICAgICA8c2xvdC8+XG4gICAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IFRodW1ibmFpbExpc3RJdGVtIGZyb20gJy4vVGh1bWJuYWlsTGlzdEl0ZW0nO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBjb21wb25lbnRzOiB7XG4gICAgICAgIFRodW1ibmFpbExpc3RJdGVtXG4gICAgfSxcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgZmlsbDogQm9vbGVhbixcblxuICAgICAgICBmbGV4OiBCb29sZWFuLFxuXG4gICAgICAgIG5vRmxleDogQm9vbGVhbixcblxuICAgICAgICBncmlkOiBCb29sZWFuLFxuXG4gICAgICAgIHdyYXA6IEJvb2xlYW4sXG5cbiAgICAgICAgaW1hZ2VzOiBBcnJheSxcblxuICAgICAgICB3aWR0aDoge1xuICAgICAgICAgICAgdHlwZTogW1N0cmluZywgTnVtYmVyXSxcbiAgICAgICAgICAgIGRlZmF1bHQ6IDc1XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBjb21wdXRlZDoge1xuXG4gICAgICAgIGNsYXNzZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICd0aHVtYm5haWwtbGlzdC1maWxsJzogdGhpcy5maWxsLFxuICAgICAgICAgICAgICAgICd0aHVtYm5haWwtbGlzdC1mbGV4JzogdGhpcy5mbGV4LFxuICAgICAgICAgICAgICAgICd0aHVtYm5haWwtbGlzdC1ub2ZsZXgnOiB0aGlzLm5vRmxleCxcbiAgICAgICAgICAgICAgICAndGh1bWJuYWlsLWxpc3QtZ3JpZCc6IHRoaXMuZ3JpZCxcbiAgICAgICAgICAgICAgICAndGh1bWJuYWlsLWxpc3Qtd3JhcCc6IHRoaXMud3JhcFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG5cbn1cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cInNjc3NcIj5cbi50aHVtYm5haWwtbGlzdCB7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgZGlzcGxheTogZmxleDtcblxuICAgICY6bm90KC50aHVtYm5haWwtbGlzdC1ncmlkKSA+ICo6bm90IHtcbiAgICAgICAgcGFkZGluZy1yaWdodDogMTBweDtcbiAgICAgICAgcGFkZGluZy1ib3R0b206IDEwcHg7XG4gICAgfVxuXG4gICAgJjpub3QoLnRodW1ibmFpbC1saXN0LWdyaWQpID4gKjpmaXJzdC1jaGlsZDpsYXN0LWNoaWxkIHtcbiAgICAgICAgcGFkZGluZzogMDtcbiAgICB9XG5cbiAgICAmLnRodW1ibmFpbC1saXN0LWZpbGwsXG4gICAgJi50aHVtYm5haWwtbGlzdC13cmFwIHtcbiAgICAgICAgZmxleC1mbG93OiByb3cgd3JhcDtcbiAgICB9XG5cbiAgICAmLnRodW1ibmFpbC1saXN0LW5vZmxleCA+ICoge1xuICAgICAgICBmbGV4OiAwO1xuICAgIH1cblxuICAgICYudGh1bWJuYWlsLWxpc3QtZmlsbCA+ICoge1xuICAgICAgICBmbGV4OiAxIDAgYXV0bztcbiAgICB9XG5cbiAgICAmLnRodW1ibmFpbC1saXN0LXdyYXAgPiAqIHtcbiAgICAgICAgZmxleDogMCAwIGF1dG87XG4gICAgfVxuXG4gICAgJi50aHVtYm5haWwtbGlzdC1mbGV4ID4gKiB7XG4gICAgICAgIGZsZXg6IDE7XG4gICAgfVxuXG59XG48L3N0eWxlPlxuIiwiaW1wb3J0IFRodW1ibmFpbExpc3QgZnJvbSAnLi9UaHVtYm5haWxMaXN0JztcbmltcG9ydCBUaHVtYm5haWxMaXN0SXRlbSBmcm9tICcuL1RodW1ibmFpbExpc3RJdGVtJztcbmltcG9ydCBWdWVJbnN0YWxsZXIgZnJvbSAnLi4vLi4vSGVscGVycy9WdWVJbnN0YWxsZXIvVnVlSW5zdGFsbGVyJztcblxuY29uc3QgcGx1Z2luID0gVnVlSW5zdGFsbGVyLnVzZSh7XG5cbiAgICBpbnN0YWxsKFZ1ZSwgb3B0aW9ucykge1xuICAgICAgICBWdWVJbnN0YWxsZXIuY29tcG9uZW50cyh7XG4gICAgICAgICAgICBUaHVtYm5haWxMaXN0XG4gICAgICAgIH0pO1xuICAgIH1cblxufSk7XG5cbmV4cG9ydCB7XG4gICAgVGh1bWJuYWlsTGlzdEl0ZW1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IFRodW1ibmFpbExpc3Q7XG4iLCIvKipcbiAqIEdldHMgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmxhc3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IDNcbiAqL1xuZnVuY3Rpb24gbGFzdChhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gIHJldHVybiBsZW5ndGggPyBhcnJheVtsZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbGFzdDtcbiIsImltcG9ydCBiYXNlR2V0IGZyb20gJy4vX2Jhc2VHZXQuanMnO1xuaW1wb3J0IGJhc2VTbGljZSBmcm9tICcuL19iYXNlU2xpY2UuanMnO1xuXG4vKipcbiAqIEdldHMgdGhlIHBhcmVudCB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHBhdGggVGhlIHBhdGggdG8gZ2V0IHRoZSBwYXJlbnQgdmFsdWUgb2YuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcGFyZW50IHZhbHVlLlxuICovXG5mdW5jdGlvbiBwYXJlbnQob2JqZWN0LCBwYXRoKSB7XG4gIHJldHVybiBwYXRoLmxlbmd0aCA8IDIgPyBvYmplY3QgOiBiYXNlR2V0KG9iamVjdCwgYmFzZVNsaWNlKHBhdGgsIDAsIC0xKSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHBhcmVudDtcbiIsImltcG9ydCBjYXN0UGF0aCBmcm9tICcuL19jYXN0UGF0aC5qcyc7XG5pbXBvcnQgbGFzdCBmcm9tICcuL2xhc3QuanMnO1xuaW1wb3J0IHBhcmVudCBmcm9tICcuL19wYXJlbnQuanMnO1xuaW1wb3J0IHRvS2V5IGZyb20gJy4vX3RvS2V5LmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bnNldGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcHJvcGVydHkgcGF0aCB0byB1bnNldC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcHJvcGVydHkgaXMgZGVsZXRlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlVW5zZXQob2JqZWN0LCBwYXRoKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuICBvYmplY3QgPSBwYXJlbnQob2JqZWN0LCBwYXRoKTtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsIHx8IGRlbGV0ZSBvYmplY3RbdG9LZXkobGFzdChwYXRoKSldO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlVW5zZXQ7XG4iLCJpbXBvcnQgYmFzZVVuc2V0IGZyb20gJy4vX2Jhc2VVbnNldC5qcyc7XG5pbXBvcnQgaXNJbmRleCBmcm9tICcuL19pc0luZGV4LmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnB1bGxBdGAgd2l0aG91dCBzdXBwb3J0IGZvciBpbmRpdmlkdWFsXG4gKiBpbmRleGVzIG9yIGNhcHR1cmluZyB0aGUgcmVtb3ZlZCBlbGVtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7bnVtYmVyW119IGluZGV4ZXMgVGhlIGluZGV4ZXMgb2YgZWxlbWVudHMgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VQdWxsQXQoYXJyYXksIGluZGV4ZXMpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID8gaW5kZXhlcy5sZW5ndGggOiAwLFxuICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTtcblxuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICB2YXIgaW5kZXggPSBpbmRleGVzW2xlbmd0aF07XG4gICAgaWYgKGxlbmd0aCA9PSBsYXN0SW5kZXggfHwgaW5kZXggIT09IHByZXZpb3VzKSB7XG4gICAgICB2YXIgcHJldmlvdXMgPSBpbmRleDtcbiAgICAgIGlmIChpc0luZGV4KGluZGV4KSkge1xuICAgICAgICBzcGxpY2UuY2FsbChhcnJheSwgaW5kZXgsIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmFzZVVuc2V0KGFycmF5LCBpbmRleCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVB1bGxBdDtcbiIsImltcG9ydCBiYXNlSXRlcmF0ZWUgZnJvbSAnLi9fYmFzZUl0ZXJhdGVlLmpzJztcbmltcG9ydCBiYXNlUHVsbEF0IGZyb20gJy4vX2Jhc2VQdWxsQXQuanMnO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGVsZW1lbnRzIGZyb20gYGFycmF5YCB0aGF0IGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvclxuICogYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgdGhlIHJlbW92ZWQgZWxlbWVudHMuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZFxuICogd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAqXG4gKiAqKk5vdGU6KiogVW5saWtlIGBfLmZpbHRlcmAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC4gVXNlIGBfLnB1bGxgXG4gKiB0byBwdWxsIGVsZW1lbnRzIGZyb20gYW4gYXJyYXkgYnkgdmFsdWUuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjAuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcmVtb3ZlZCBlbGVtZW50cy5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGFycmF5ID0gWzEsIDIsIDMsIDRdO1xuICogdmFyIGV2ZW5zID0gXy5yZW1vdmUoYXJyYXksIGZ1bmN0aW9uKG4pIHtcbiAqICAgcmV0dXJuIG4gJSAyID09IDA7XG4gKiB9KTtcbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gKiAvLyA9PiBbMSwgM11cbiAqXG4gKiBjb25zb2xlLmxvZyhldmVucyk7XG4gKiAvLyA9PiBbMiwgNF1cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAoIShhcnJheSAmJiBhcnJheS5sZW5ndGgpKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGluZGV4ZXMgPSBbXSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBwcmVkaWNhdGUgPSBiYXNlSXRlcmF0ZWUocHJlZGljYXRlLCAzKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgaW5kZXhlcy5wdXNoKGluZGV4KTtcbiAgICB9XG4gIH1cbiAgYmFzZVB1bGxBdChhcnJheSwgaW5kZXhlcyk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHJlbW92ZTtcbiIsIjx0ZW1wbGF0ZT5cblxuICAgIDxmb3JtLWdyb3VwIGNsYXNzPVwidXBsb2FkLWZpZWxkXCIgOmNsYXNzPVwieydlbmFibGUtZHJvcHpvbmUnOiBkcm9wem9uZSwgJ2VuYWJsZS1tdWx0aXBsZSc6IG11bHRpcGxlfVwiPlxuXG4gICAgICAgIDxkcm9wem9uZSBAZHJvcD1cIm9uRHJvcFwiPlxuXG4gICAgICAgICAgICA8ZmlsZS1maWVsZFxuICAgICAgICAgICAgICAgIHYtaWY9XCJtdWx0aXBsZSAmJiAoIW1heFVwbG9hZHMgfHwgbWF4VXBsb2FkcyA+IHZhbHVlLmxlbmd0aCkgfHwgIW11bHRpcGxlICYmICF2YWx1ZVwiXG4gICAgICAgICAgICAgICAgOm5hbWU9XCJuYW1lXCJcbiAgICAgICAgICAgICAgICA6bGFiZWw9XCJsYWJlbFwiXG4gICAgICAgICAgICAgICAgOnBsYWNlaG9sZGVyPVwicGxhY2Vob2xkZXJcIlxuICAgICAgICAgICAgICAgIDpoZWxwLXRleHQ9XCJoZWxwVGV4dFwiXG4gICAgICAgICAgICAgICAgOm11bHRpcGxlPVwibXVsdGlwbGVcIlxuICAgICAgICAgICAgICAgIDplcnJvcnM9XCJlcnJvcnNcIlxuICAgICAgICAgICAgICAgIEBjaGFuZ2U9XCJvbkNoYW5nZVwiXG4gICAgICAgICAgICAvPlxuXG4gICAgICAgICAgICA8dGh1bWJuYWlsLWxpc3Qgdi1pZj1cImZpbGVzICYmIGZpbGVzLmxlbmd0aFwiIGNsYXNzPVwibXQtNFwiIHdyYXA+XG4gICAgICAgICAgICAgICAgPHRodW1ibmFpbC1saXN0LWl0ZW1cbiAgICAgICAgICAgICAgICAgICAgdi1mb3I9XCIoZmlsZSwga2V5KSBpbiBmaWxlc1wiXG4gICAgICAgICAgICAgICAgICAgIDprZXk9XCJmaWxlLmxhc3RNb2RpZmllZCArICctJyArIGZpbGUubGFzdE1vZGlmaWVkRGF0ZSArICctJyArIGZpbGUuc2l6ZSArICctJyArIGZpbGUudHlwZSArICctJyArIGZpbGUubmFtZVwiXG4gICAgICAgICAgICAgICAgICAgIDp3aWR0aD1cIndpZHRoXCJcbiAgICAgICAgICAgICAgICAgICAgOm1pbi13aWR0aD1cIm1pbldpZHRoXCJcbiAgICAgICAgICAgICAgICAgICAgOm1heC13aWR0aD1cIm1heFdpZHRoXCJcbiAgICAgICAgICAgICAgICAgICAgOmhlaWdodD1cImhlaWdodFwiXG4gICAgICAgICAgICAgICAgICAgIDptaW4taGVpZ2h0PVwibWluSGVpZ2h0XCJcbiAgICAgICAgICAgICAgICAgICAgOm1heC1oZWlnaHQ9XCJtYXhIZWlnaHRcIlxuICAgICAgICAgICAgICAgICAgICA6Y2xhc3M9XCJ7J3VwbG9hZGluZyc6ICEhcHJvZ3Jlc3NCYXJzW2tleV19XCI+XG4gICAgICAgICAgICAgICAgICAgIDxmaWxlLXByZXZpZXcgOmZpbGU9XCJmaWxlXCIgOnByb2dyZXNzPVwicHJvZ3Jlc3NCYXJzW2tleV0gfHwgMFwiIEBsb2FkZWQ9XCJvbkxvYWRlZFByZXZpZXdcIiBAY2xvc2U9XCJyZW1vdmVGaWxlKGZpbGUpXCIvPlxuICAgICAgICAgICAgICAgICAgICA8c2xvdCA6ZmlsZT1cImZpbGVcIi8+XG4gICAgICAgICAgICAgICAgPHRodW1ibmFpbC1saXN0LWl0ZW0+XG4gICAgICAgICAgICA8L3RodW1ibmFpbC1saXN0PlxuXG4gICAgICAgICAgICA8ZGl2IHYtaWY9XCJzaG93RHJvcEVsZW1lbnRcIiBjbGFzcz1cInVwbG9hZC1maWVsZC1kcm9wem9uZVwiIDpzdHlsZT1cInsnbWluLWhlaWdodCc6IGRyb3B6b25lTWluSGVpZ2h0fVwiIEBkcm9wLnByZXZlbnQ9XCJvbkRyb3BcIj5cbiAgICAgICAgICAgICAgICA8aSBjbGFzcz1cImZhIGZhLWNsb3VkLXVwbG9hZFwiPjwvaT5cbiAgICAgICAgICAgICAgICA8ZGl2PkRyYWcgYW5kIGRyb3AgZmlsZXMgdG8gdXBsb2FkPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8L2Ryb3B6b25lPlxuXG4gICAgPC9mb3JtLWdyb3VwPlxuXG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IHsgZWFjaCB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgeyBleHRlbmQgfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IHsgcmVtb3ZlIH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCB7IGlzQXJyYXkgfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IHsgZmluZEluZGV4IH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCB7IGlzVW5kZWZpbmVkIH0gZnJvbSAnbG9kYXNoLWVzJ1xuaW1wb3J0IEZvcm1Hcm91cCBmcm9tICcuLi9Gb3JtR3JvdXAnO1xuaW1wb3J0IE1vZGVsIGZyb20gJy4uLy4uL0h0dHAvTW9kZWwnO1xuaW1wb3J0IERyb3B6b25lIGZyb20gJy4uL0Ryb3B6b25lL0Ryb3B6b25lJztcbmltcG9ydCBGb3JtQ29udHJvbCBmcm9tICcuLi8uLi9NaXhpbnMvRm9ybUNvbnRyb2wvRm9ybUNvbnRyb2wnO1xuaW1wb3J0IEZpbGVGaWVsZCBmcm9tICcuLi9GaWxlRmllbGQvRmlsZUZpZWxkJztcbmltcG9ydCBGaWxlUHJldmlldyBmcm9tICcuLi9GaWxlUHJldmlldy9GaWxlUHJldmlldyc7XG5pbXBvcnQgVGh1bWJuYWlsTGlzdCBmcm9tICcuLi9UaHVtYm5haWxMaXN0L1RodW1ibmFpbExpc3QnO1xuaW1wb3J0IFRodW1ibmFpbExpc3RJdGVtIGZyb20gJy4uL1RodW1ibmFpbExpc3QvVGh1bWJuYWlsTGlzdEl0ZW0nO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAndXBsb2FkLWZpZWxkJyxcblxuICAgIG1peGluczogW0Zvcm1Db250cm9sXSxcblxuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgICAgRHJvcHpvbmUsXG4gICAgICAgIEZvcm1Hcm91cCxcbiAgICAgICAgRmlsZUZpZWxkLFxuICAgICAgICBGaWxlUHJldmlldyxcbiAgICAgICAgVGh1bWJuYWlsTGlzdCxcbiAgICAgICAgVGh1bWJuYWlsTGlzdEl0ZW1cbiAgICB9LFxuXG4gICAgbW9kZWw6IHtcbiAgICAgICAgcHJvcDogJ3ZhbHVlJyxcbiAgICAgICAgZXZlbnQ6ICdjaGFuZ2UnXG4gICAgfSxcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbiB1c2VyIHVwbG9hZCBtdWx0aXBsZSBmaWxlc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBtdWx0aXBsZTogQm9vbGVhbixcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1heGltdW0gbnVtYmVyIG9mIGZpbGVzIHRoYXQgYSB1c2VyIGNhbiB1cGxvYWRcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgbWF4VXBsb2FkczogTnVtYmVyLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaGVpZ2h0IGF0dHJpYnV0ZSBmb3IgdGhlIGNvbnRyb2wgZWxlbWVudFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBoZWlnaHQ6IFtOdW1iZXIsIFN0cmluZ10sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtaW5pbXVtIGhlaWdodCBhdHRyaWJ1dGUgZm9yIHRoZSBjb250cm9sIGVsZW1lbnRcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgbWluSGVpZ2h0OiBbTnVtYmVyLCBTdHJpbmddLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWF4aW11bSBoZWlnaHQgYXR0cmlidXRlIGZvciB0aGUgY29udHJvbCBlbGVtZW50XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIG1heEhlaWdodDogW051bWJlciwgU3RyaW5nXSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHdpZHRoIGF0dHJpYnV0ZSBmb3IgdGhlIGNvbnRyb2wgZWxlbWVudFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICB3aWR0aDogW051bWJlciwgU3RyaW5nXSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1pbmltdW0gd2lkdGggYXR0cmlidXRlIGZvciB0aGUgY29udHJvbCBlbGVtZW50XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIG1pbldpZHRoOiBbTnVtYmVyLCBTdHJpbmddLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWF4aW11bSB3aWR0aCBhdHRyaWJ1dGUgZm9yIHRoZSBjb250cm9sIGVsZW1lbnRcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgbWF4V2lkdGg6IFtOdW1iZXIsIFN0cmluZ10sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbiB1c2VyIGRyYWcvZHJvcCBmaWxlcyBpbnRvIGJyb3dzZXIgdG8gdXBsb2FkIHRoZW0uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGRyb3B6b25lTWluSGVpZ2h0OiBbTnVtYmVyLCBTdHJpbmddLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJcyB0aGUgdXNlciBkcmFnZ2luZyBhIGZpbGUgb3ZlciB0aGUgZHJvcHpvbmVcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ2dpbmc6IHtcbiAgICAgICAgICAgIHR5cGU6IFtTdHJpbmcsIEJvb2xlYW5dLFxuICAgICAgICAgICAgZGVmYXVsdCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYW4gdXNlciBkcmFnL2Ryb3AgZmlsZXMgaW50byBicm93c2VyIHRvIHVwbG9hZCB0aGVtLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBkcm9wem9uZToge1xuICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRhdGEgYXR0cmlidXRlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBGaWxlfEZpbGVMaXN0fEFycmF5XG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgdHlwZTogW09iamVjdCwgRmlsZSwgRmlsZUxpc3QsIEFycmF5XSxcbiAgICAgICAgICAgIGRlZmF1bHQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICF0aGlzLm11bHRpcGxlID8gbnVsbCA6IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBIVFRQIE1vZGVsIHVzZWQgdG8gc2VuZCB0aGUgcmVxdWVzdFxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSBNb2RlbFxuICAgICAgICAgKi9cbiAgICAgICAgbW9kZWw6IFtNb2RlbCwgRnVuY3Rpb25dLFxuXG4gICAgICAgIHJlcXVlc3Q6IE9iamVjdFxuXG4gICAgfSxcblxuICAgIG1ldGhvZHM6IHtcblxuICAgICAgICByZW1vdmVGaWxlKGRhdGEpIHtcblxuICAgICAgICAgICAgaWYodGhpcy5tdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVzID0gaXNBcnJheSh0aGlzLnZhbHVlKSA/IHRoaXMudmFsdWUuc2xpY2UoMCkgOiBbXTtcblxuICAgICAgICAgICAgICAgIGlmKGRhdGEgaW5zdGFuY2VvZiBGaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKGRhdGEucmVxdWVzdCAmJiBkYXRhLnJlcXVlc3QuY2FuY2VsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnJlcXVlc3QuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZW1vdmUoZmlsZXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGRhdGEubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IGRhdGEuc2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RNb2RpZmllZDogZGF0YS5sYXN0TW9kaWZpZWRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmUoZmlsZXMsIGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScsIGZpbGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmKGRhdGEucmVxdWVzdCAmJiBkYXRhLnJlcXVlc3QuY2FuY2VsKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEucmVxdWVzdC5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBhZGRGaWxlKGZpbGUsIHN1YmplY3QpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogZmlsZS5uYW1lLFxuICAgICAgICAgICAgICAgIGxhc3RNb2RpZmllZDogZmlsZS5sYXN0TW9kaWZpZWQsXG4gICAgICAgICAgICAgICAgbGFzdE1vZGlmaWVkRGF0ZTogZmlsZS5sYXN0TW9kaWZpZWREYXRlLFxuICAgICAgICAgICAgICAgIHNpemU6IGZpbGUuc2l6ZSxcbiAgICAgICAgICAgICAgICB0eXBlOiBmaWxlLnR5cGVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYodGhpcy5tdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVzID0gc3ViamVjdCB8fCAoaXNBcnJheSh0aGlzLnZhbHVlKSA/IHRoaXMudmFsdWUuc2xpY2UoMCkgOiBbXSk7XG5cbiAgICAgICAgICAgICAgICBpZigoIXRoaXMubWF4VXBsb2FkcyB8fCB0aGlzLm1heFVwbG9hZHMgPiBmaWxlcy5sZW5ndGgpICYmIGZpbmRJbmRleChmaWxlcywgZGF0YSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVzLnB1c2goZmlsZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgZmlsZXMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwbG9hZChmaWxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnLCBmaWxlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwbG9hZChmaWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBhZGRGaWxlcyhmaWxlcykge1xuICAgICAgICAgICAgY29uc3Qgc3ViamVjdCA9IGlzQXJyYXkodGhpcy52YWx1ZSkgPyB0aGlzLnZhbHVlLnNsaWNlKDApIDogW107XG5cbiAgICAgICAgICAgIGVhY2goZmlsZXMsIGZpbGUgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkRmlsZShmaWxlLCBzdWJqZWN0KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBldmVudC50YXJnZXQudmFsdWUgPSBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGxvYWQgZnVuY3Rpb24gdGhhdCBoYW5kbGVzIGF1dG8tdXBsb2FkaW5nIGZpZWxkcyBhc3luY2hyb25vdXNseS5cbiAgICAgICAgICogVGhpcyBpcyBkZXNpZ25lZCB0byB3b3JrIHdpdGggUkVTVCBBUEkncyBhbmQgcmVwbGFjZSB0aGUgZmlsZSBPYmplY3RcbiAgICAgICAgICogd2l0aCB0aGUgUkVTVGZ1bCByZXR1cm5lZCBieSB0aGUgc2VydmVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIHVwbG9hZChmaWxlKSB7XG4gICAgICAgICAgICAvLyBTdG9wIHVwbG9hZCBzaWxlbnRseSBpZiBubyBtb2RlbCBpcyBkZWZpbmVkLlxuICAgICAgICAgICAgaWYoIXRoaXMubW9kZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBtb2RlbCA9IHRoaXMubW9kZWw7XG5cbiAgICAgICAgICAgIGlmKCEodGhpcy5tb2RlbCBpbnN0YW5jZW9mIE1vZGVsKSkge1xuICAgICAgICAgICAgICAgIG1vZGVsID0gbmV3IHRoaXMubW9kZWw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1vZGVsLnNldCh0aGlzLm5hbWUsIGZpbGUpO1xuXG4gICAgICAgICAgICB0aGlzLiRlbWl0KCd1cGxvYWRpbmcnLCBtb2RlbCk7XG4gICAgICAgICAgICB0aGlzLiRzZXQodGhpcy5wcm9ncmVzc0JhcnMsIHRoaXMubXVsdGlwbGUgPyAodGhpcy52YWx1ZSA/IHRoaXMudmFsdWUubGVuZ3RoIDogMCkgOiAwLCAwKTtcblxuICAgICAgICAgICAgcmV0dXJuIG1vZGVsLnNhdmUobnVsbCwgZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICBvblVwbG9hZFByb2dyZXNzOiBlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYoIWZpbGUuaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUuaW5kZXggPSBmaW5kSW5kZXgodGhpcy5maWxlcywgZmlsZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZighZmlsZS5yZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlLnJlcXVlc3QgPSBtb2RlbC5nZXRSZXF1ZXN0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRzZXQodGhpcy5wcm9ncmVzc0JhcnMsIGZpbGUuaW5kZXgsIHBhcnNlSW50KChlLmxvYWRlZCAvIGUudG90YWwpICogMTAwLCAxMCkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdwcm9ncmVzcycsIG1vZGVsLCB0aGlzLnByb2dyZXNzQmFyc1tmaWxlLmluZGV4XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcy5yZXF1ZXN0KSlcbiAgICAgICAgICAgIC50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLiRuZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ3VwbG9hZCcsIG1vZGVsKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9ncmVzc0JhcnNbZmlsZS5pbmRleF0gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYGRyb3BgIGV2ZW50IGNhbGxiYWNrLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIG9uRHJvcChldmVudCkge1xuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZShldmVudC5kYXRhVHJhbnNmZXIuZmlsZXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYGNoYW5nZWAgZXZlbnQgY2FsbGJhY2suXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgb25DaGFuZ2UoZmlsZXMpIHtcbiAgICAgICAgICAgIGlmKGZpbGVzIGluc3RhbmNlb2YgRmlsZUxpc3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEZpbGVzKGZpbGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkRmlsZShmaWxlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBgZHJhZ292ZXJgIGV2ZW50IGNhbGxiYWNrLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIG9uRHJhZ092ZXIoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZ0luc2lkZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCd1cGRhdGU6ZHJhZ2dpbmcnLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2RyYWc6b3ZlcicsIGV2ZW50KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGBkcmFnb3ZlcmAgZXZlbnQgY2FsbGJhY2suXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgb25EcmFnRW50ZXIoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZ0luc2lkZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCd1cGRhdGU6ZHJhZ2dpbmcnLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2RyYWc6ZW50ZXInLCBldmVudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBgZHJhZ2xlYXZlYCBldmVudCBjYWxsYmFjay5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUgT2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBvbkRyYWdMZWF2ZShldmVudCkge1xuICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nSW5zaWRlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCd1cGRhdGU6ZHJhZ2dpbmcnLCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCdkcmFnOmxlYXZlJywgZXZlbnQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYGRyb3BgIGV2ZW50IGNhbGxiYWNrLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBvbkRyb3AoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZ0luc2lkZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5hZGRGaWxlcyhldmVudC5kYXRhVHJhbnNmZXIuZmlsZXMpO1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgndXBkYXRlOmRyYWdnaW5nJywgZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgnZHJvcCcsIGV2ZW50KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGBsb2FkZWRgIGV2ZW50IGNhbGxiYWNrLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIG9uTG9hZGVkUHJldmlldyhldmVudCkge1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgnbG9hZGVkJywgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNvbXB1dGVkOiB7XG5cbiAgICAgICAgZmlsZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBsZSA/IHRoaXMudmFsdWUgOiAodGhpcy52YWx1ZSA/IFt0aGlzLnZhbHVlXSA6IFtdKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzaG93RHJvcEVsZW1lbnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gIWlzVW5kZWZpbmVkKHRoaXMuZHJhZ2dpbmcpID8gdGhpcy5kcmFnZ2luZyA6IHRoaXMuaXNEcmFnZ2luZ0luc2lkZVxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHByb2dyZXNzQmFyczoge30sXG4gICAgICAgICAgICBpc0RyYWdnaW5nSW5zaWRlOiBmYWxzZVxuICAgICAgICB9O1xuICAgIH1cblxufVxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwic2Nzc1wiPlxuXG4udXBsb2FkLWZpZWxkIHtcbiAgICAgLmZpbGUtcHJldmlldyB7XG4gICAgICAgIG1pbi13aWR0aDogMTAwcHg7XG4gICAgICAgIG1pbi1oZWlnaHQ6IDEwMHB4O1xuXG4gICAgICAgIC51cGxvYWRpbmcgLmZpbGUtcHJldmlldyB7XG4gICAgICAgICAgICBvcGFjaXR5OiAuNTtcbiAgICAgICAgfVxuICAgIH1cbn1cbjwvc3R5bGU+XG4iLCJpbXBvcnQgVXBsb2FkRmllbGQgZnJvbSAnLi9VcGxvYWRGaWVsZCc7XG5pbXBvcnQgVnVlSW5zdGFsbGVyIGZyb20gJy4uLy4uL0hlbHBlcnMvVnVlSW5zdGFsbGVyL1Z1ZUluc3RhbGxlcic7XG5cbmNvbnN0IHBsdWdpbiA9IFZ1ZUluc3RhbGxlci51c2Uoe1xuXG4gICAgaW5zdGFsbChWdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgVnVlSW5zdGFsbGVyLmNvbXBvbmVudHMoe1xuICAgICAgICAgICAgVXBsb2FkRmllbGRcbiAgICAgICAgfSk7XG4gICAgfVxuXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgVXBsb2FkRmllbGQ7XG4iLCJpbXBvcnQgYmFzZUl0ZXJhdGVlIGZyb20gJy4vX2Jhc2VJdGVyYXRlZS5qcyc7XG5pbXBvcnQgaXNBcnJheUxpa2UgZnJvbSAnLi9pc0FycmF5TGlrZS5qcyc7XG5pbXBvcnQga2V5cyBmcm9tICcuL2tleXMuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBgXy5maW5kYCBvciBgXy5maW5kTGFzdGAgZnVuY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZpbmRJbmRleEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGZpbmQgdGhlIGNvbGxlY3Rpb24gaW5kZXguXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmaW5kIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVGaW5kKGZpbmRJbmRleEZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZnJvbUluZGV4KSB7XG4gICAgdmFyIGl0ZXJhYmxlID0gT2JqZWN0KGNvbGxlY3Rpb24pO1xuICAgIGlmICghaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgIHZhciBpdGVyYXRlZSA9IGJhc2VJdGVyYXRlZShwcmVkaWNhdGUsIDMpO1xuICAgICAgY29sbGVjdGlvbiA9IGtleXMoY29sbGVjdGlvbik7XG4gICAgICBwcmVkaWNhdGUgPSBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpOyB9O1xuICAgIH1cbiAgICB2YXIgaW5kZXggPSBmaW5kSW5kZXhGdW5jKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZnJvbUluZGV4KTtcbiAgICByZXR1cm4gaW5kZXggPiAtMSA/IGl0ZXJhYmxlW2l0ZXJhdGVlID8gY29sbGVjdGlvbltpbmRleF0gOiBpbmRleF0gOiB1bmRlZmluZWQ7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZUZpbmQ7XG4iLCJpbXBvcnQgY3JlYXRlRmluZCBmcm9tICcuL19jcmVhdGVGaW5kLmpzJztcbmltcG9ydCBmaW5kSW5kZXggZnJvbSAnLi9maW5kSW5kZXguanMnO1xuXG4vKipcbiAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gLCByZXR1cm5pbmcgdGhlIGZpcnN0IGVsZW1lbnRcbiAqIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdGhyZWVcbiAqIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hdGNoZWQgZWxlbWVudCwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIHVzZXJzID0gW1xuICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxLCAgJ2FjdGl2ZSc6IHRydWUgfVxuICogXTtcbiAqXG4gKiBfLmZpbmQodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYWdlIDwgNDA7IH0pO1xuICogLy8gPT4gb2JqZWN0IGZvciAnYmFybmV5J1xuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbmQodXNlcnMsIHsgJ2FnZSc6IDEsICdhY3RpdmUnOiB0cnVlIH0pO1xuICogLy8gPT4gb2JqZWN0IGZvciAncGViYmxlcydcbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbmQodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAqIC8vID0+IG9iamVjdCBmb3IgJ2ZyZWQnXG4gKlxuICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbmQodXNlcnMsICdhY3RpdmUnKTtcbiAqIC8vID0+IG9iamVjdCBmb3IgJ2Jhcm5leSdcbiAqL1xudmFyIGZpbmQgPSBjcmVhdGVGaW5kKGZpbmRJbmRleCk7XG5cbmV4cG9ydCBkZWZhdWx0IGZpbmQ7XG4iLCI8dGVtcGxhdGU+XG4gICAgPGRpdiBjbGFzcz1cIndpemFyZC1idXR0b25zXCI+XG4gICAgICAgIDxidG4tZ3JvdXAgcmVmPVwibGVmdFwiIGNsYXNzPVwid2l6YXJkLWJ1dHRvbnMtbGVmdFwiPlxuICAgICAgICAgICAgPHNsb3QgbmFtZT1cImJ1dHRvbnMtbGVmdFwiLz5cbiAgICAgICAgICAgIDxidG4gdHlwZT1cImJ1dHRvblwiIHZhcmlhbnQ9XCJzZWNvbmRhcnlcIiByZWY9XCJiYWNrXCIgOmRpc2FibGVkPVwiYmFja0J1dHRvbiA9PT0gZmFsc2UgfHwgKGFjdGl2ZSA9PT0gMCAmJiBiYWNrQnV0dG9uICE9PSB0cnVlKVwiIDpzaXplPVwic2l6ZWFibGVDbGFzc1wiIEBjbGljaz1cIm9uQ2xpY2tCYWNrXCI+XG4gICAgICAgICAgICAgICAgPGkgY2xhc3M9XCJmYSBmYS1sb25nLWFycm93LWxlZnRcIi8+IEJhY2tcbiAgICAgICAgICAgIDwvYnRuPlxuICAgICAgICA8L2J0bi1ncm91cD5cbiAgICAgICAgPGJ0bi1ncm91cCByZWY9XCJyaWdodFwiIGNsYXNzPVwid2l6YXJkLWJ1dHRvbnMtcmlnaHRcIj5cbiAgICAgICAgICAgIDxzbG90IG5hbWU9XCJidXR0b25zLXJpZ2h0XCIvPlxuICAgICAgICAgICAgPGJ0bi1hY3Rpdml0eSB2LWlmPVwiYWN0aXZlID09PSBzdGVwcy5sZW5ndGggLSAxXCIgcmVmPVwiZmluaXNoXCIgOmFjdGl2aXR5PVwiYWN0aXZpdHlcIiA6c2l6ZT1cInNpemVhYmxlQ2xhc3NcIiA6ZGlzYWJsZWQ9XCJmaW5pc2hCdXR0b24gPT09IGZhbHNlXCIgdHlwZT1cImJ1dHRvblwiIHZhcmlhbnQ9XCJzdWNjZXNzXCIgQGNsaWNrPVwib25DbGlja0ZpbmlzaFwiPlxuICAgICAgICAgICAgICAgIEZpbmlzaFxuICAgICAgICAgICAgPC9idG4tYWN0aXZpdHk+XG4gICAgICAgICAgICA8YnRuLWFjdGl2aXR5IHYtaWY9XCJhY3RpdmUgPCBzdGVwcy5sZW5ndGggLSAxXCIgcmVmPVwibmV4dFwiIDphY3Rpdml0eT1cImFjdGl2aXR5XCIgOnNpemU9XCJzaXplYWJsZUNsYXNzXCIgOmRpc2FibGVkPVwibmV4dEJ1dHRvbiA9PT0gZmFsc2VcIiB0eXBlPVwiYnV0dG9uXCIgdmFyaWFudD1cInByaW1hcnlcIiBAY2xpY2s9XCJvbkNsaWNrTmV4dFwiPlxuICAgICAgICAgICAgICAgIE5leHQgPGkgY2xhc3M9XCJmYSBmYS1sb25nLWFycm93LXJpZ2h0XCIvPlxuICAgICAgICAgICAgPC9idG4tYWN0aXZpdHk+XG4gICAgICAgIDwvYnRuLWdyb3VwPlxuICAgIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBCdG4gZnJvbSAnLi4vQnRuJztcbmltcG9ydCBCdG5Hcm91cCBmcm9tICcuLi9CdG5Hcm91cCc7XG5pbXBvcnQgQnRuQWN0aXZpdHkgZnJvbSAnLi4vQnRuQWN0aXZpdHknO1xuaW1wb3J0IFNpemVhYmxlIGZyb20gJy4uLy4uL01peGlucy9TaXplYWJsZSc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICd3aXphcmQtYnV0dG9ucycsXG5cbiAgICBtaXhpbnM6IFtcbiAgICAgICAgU2l6ZWFibGVcbiAgICBdLFxuXG4gICAgY29tcG9uZW50czoge1xuICAgICAgICBCdG4sXG4gICAgICAgIEJ0bkdyb3VwLFxuICAgICAgICBCdG5BY3Rpdml0eVxuICAgIH0sXG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaW5kZXggb3Iga2V5IG9mIHRoZSBhY3RpdmUgc3RlcC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge1N0cmluZ3xOdW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBhY3RpdmU6IHtcbiAgICAgICAgICAgIHR5cGU6IFtTdHJpbmcsIE51bWJlcl0sXG4gICAgICAgICAgICBkZWZhdWx0OiAwXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3cgdGhlIGFjdGl2aXR5IGluZGljYXRvciBpbiB0aGUgbmV4dCBvciBmaW5pc2ggYnV0dG9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGFjdGl2aXR5OiBCb29sZWFuLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG93IHNob3VsZCB0aGUgXCJCYWNrXCIgYnV0dG9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGJhY2tCdXR0b246IEJvb2xlYW4sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3cgc2hvdWxkIHRoZSBcIkZpbmlzaFwiIGJ1dHRvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBmaW5pc2hCdXR0b246IEJvb2xlYW4sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3cgc2hvdWxkIHRoZSBcIk5leHRcIiBidXR0b24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgbmV4dEJ1dHRvbjogQm9vbGVhbixcblxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gYXJyYXkgb2Ygc3RlcHMgcGFzc2VkIGZyb20gdGhlIHBhcmVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge0FycmF5fVxuICAgICAgICAgKi9cbiAgICAgICAgc3RlcHM6IHtcbiAgICAgICAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGNvbXB1dGVkOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE92ZXJyaWRlIHRoZSBjbGFzcyBwcmVmaXggd2l0aCBhbiBlbXB0eSBzdHJpbmcuLi5cbiAgICAgICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgc2l6ZWFibGVDbGFzc1ByZWZpeCgpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIG1ldGhvZHM6IHtcblxuICAgICAgICBvbkNsaWNrQmFjayhldmVudCkge1xuICAgICAgICAgICAgaWYodGhpcy5iYWNrQnV0dG9uICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2NsaWNrOmJhY2snLCBldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25DbGlja0ZpbmlzaChldmVudCkge1xuICAgICAgICAgICAgaWYodGhpcy5maW5pc2hCdXR0b24gIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kZW1pdCgnY2xpY2s6ZmluaXNoJywgZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG9uQ2xpY2tOZXh0KGV2ZW50KSB7XG4gICAgICAgICAgICBpZih0aGlzLm5leHRCdXR0b24gIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kZW1pdCgnY2xpY2s6bmV4dCcsIGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfVxuXG59XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJzY3NzXCI+XG4ud2l6YXJkLWJ1dHRvbnMge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xufVxuPC9zdHlsZT5cbiIsIjxzY3JpcHQ+XG5pbXBvcnQgeyBpc0Z1bmN0aW9uIH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCB7IGlzVW5kZWZpbmVkIH0gZnJvbSAnbG9kYXNoLWVzJztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ3dpemFyZC1zdGVwJyxcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwYXJlbnQgd2l6YXJkIGNvbXBvbmVudCBpbnN0YW5jZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgd2l6YXJkOiB7XG4gICAgICAgICAgICAvL3JlcXVpcmVkOiB0cnVlLFxuICAgICAgICAgICAgdHlwZTogT2JqZWN0XG4gICAgICAgIH0sXG4gICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzdGVwJ3MgbGFiZWwgaW4gdGhlIHByb2dyZXNzIGJhci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIGxhYmVsOiBTdHJpbmcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgcHJlZGljYXRlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBpZiB0aGUgYmFjayBidXR0b24gc2hvdWxkIHNob3cuXG4gICAgICAgICAqIENhbiBhbHNvIGJlIGEgYm9vbGVhbiB2YWx1ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge0Z1bmN0aW9ufEJvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBiYWNrQnV0dG9uOiB7XG4gICAgICAgICAgICB0eXBlOiBbRnVuY3Rpb24sIEJvb2xlYW5dLFxuICAgICAgICAgICAgZGVmYXVsdCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWYWxpZGF0ZSBpZiB0aGUgZGF0YSBpbnB1dCBmb3IgdGhlIHN0ZXAgaXMgdmFsaWQuIFJlcXVpcmVkIEJvb2xlYW5cbiAgICAgICAgICogb3IgYSBwcmVkaWNhdGUgZnVuY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtGdW5jdGlvbnxCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdmFsaWRhdGU6IHtcbiAgICAgICAgICAgIHR5cGU6IFtGdW5jdGlvbiwgQm9vbGVhbl0sXG4gICAgICAgICAgICBkZWZhdWx0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgbWV0aG9kczoge1xuXG4gICAgICAgIGNoZWNrVmFsaWRpdHkocHJvcCkge1xuICAgICAgICAgICAgLy8gVmFsaWRhdGUgdGhlIHByb3BlcnR5IGZvciB0aGUgc3RlcCBmaXJzdC5cbiAgICAgICAgICAgIGlmKGlzRnVuY3Rpb24odGhpc1twcm9wXSkgPyB0aGlzW3Byb3BdKHRoaXMpID09PSBmYWxzZSA6IHRoaXNbcHJvcF0gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRoZW4gdmFsaWRhdGUgdGhlIHByb3BlcnR5IG9mIHRoZSB3aXphcmQsIHRoaXMgaXMgdGhlIGdsb2JhbCB2YWxpZGF0b3JcbiAgICAgICAgICAgIGlmKHRoaXMuJHJlZnMud2l6YXJkKSB7XG4gICAgICAgICAgICAgICAgaWYoIGlzRnVuY3Rpb24odGhpcy4kcmVmcy53aXphcmRbcHJvcF0pID9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kcmVmcy53aXphcmRbcHJvcF0odGhpcykgPT09IGZhbHNlIDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kcmVmcy53aXphcmRbcHJvcF0gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBlcmZvcm1WYWxpZGl0eUNoZWNrcygpIHtcbiAgICAgICAgICAgIGlmKHRoaXMuJHJlZnMud2l6YXJkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja1ZhbGlkaXR5KCd2YWxpZGF0ZScpID8gdGhpcy5lbmFibGUoKSA6IHRoaXMuZGlzYWJsZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tWYWxpZGl0eSgnYmFja0J1dHRvbicpID8gdGhpcy4kcmVmcy53aXphcmQuZW5hYmxlQmFja0J1dHRvbigpIDogdGhpcy4kcmVmcy53aXphcmQuZGlzYWJsZUJhY2tCdXR0b24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBkaXNhYmxlKCkge1xuICAgICAgICAgICAgaWYodGhpcy4kcmVmcy53aXphcmQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRyZWZzLndpemFyZC5kaXNhYmxlTmV4dEJ1dHRvbigpO1xuICAgICAgICAgICAgICAgIHRoaXMuJHJlZnMud2l6YXJkLmRpc2FibGVGaW5pc2hCdXR0b24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBlbmFibGUoKSB7XG4gICAgICAgICAgICBpZih0aGlzLiRyZWZzLndpemFyZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuJHJlZnMud2l6YXJkLmVuYWJsZU5leHRCdXR0b24oKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRyZWZzLndpemFyZC5lbmFibGVGaW5pc2hCdXR0b24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIHVwZGF0ZWQoKSB7XG4gICAgICAgIHRoaXMucGVyZm9ybVZhbGlkaXR5Q2hlY2tzKCk7XG4gICAgfSxcblxuICAgIG1vdW50ZWQoKSB7XG4gICAgICAgIHRoaXMuJG5leHRUaWNrKHRoaXMucGVyZm9ybVZhbGlkaXR5Q2hlY2tzKTtcbiAgICB9LFxuXG4gICAgcmVuZGVyKGgpIHtcbiAgICAgICAgaWYodGhpcy4kc2xvdHMuZGVmYXVsdC5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIDx3aXphcmQtc2xvdD4gbXVzdCBjb250YWluIGEgc2luZ2xlIHBhcmVudCBET00gbm9kZS4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLiRzbG90cy5kZWZhdWx0WzBdO1xuICAgIH1cblxufTtcbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICAgIDxkaXYgY2xhc3M9XCJ3aXphcmQtZXJyb3JcIj5cbiAgICAgICAgPGRpdiB2LWlmPVwiaWNvblwiIGNsYXNzPVwid2l6YXJkLWVycm9yLWljb25cIj5cbiAgICAgICAgICAgIDxpIDpjbGFzcz1cImljb25cIi8+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIDxoMyB2LWlmPVwidGl0bGVcIiBjbGFzcz1cIndpemFyZC1lcnJvci10aXRsZVwiIHYtaHRtbD1cInRpdGxlXCIvPlxuXG4gICAgICAgIDxzbG90Lz5cblxuICAgICAgICA8ZGl2IGNsYXNzPVwicm93IGp1c3RpZnktY29udGVudC1jZW50ZXJcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tNlwiPlxuICAgICAgICAgICAgICAgIDxkaXYgdi1pZj1cImVycm9yc1wiIGNsYXNzPVwibXktNVwiPlxuICAgICAgICAgICAgICAgICAgICA8dWwgY2xhc3M9XCJtYi0wIHRleHQtbGVmdFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGxpIHYtZm9yPVwiKGVycm9yLCBpKSBpbiBlcnJvcnNcIiA6a2V5PVwiaVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt7IGVycm9yWzBdIH19XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgICAgICAgICA8L3VsPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICAgICAgPGJ0biBzaXplPVwibGdcIiB2YXJpYW50PVwiZGFuZ2VyXCIgYmxvY2sgQGNsaWNrPVwiJGVtaXQoJ2JhY2snKVwiPlxuICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cImZhIGZhLWxvbmctYXJyb3ctbGVmdFwiLz4gR28gQmFja1xuICAgICAgICAgICAgICAgIDwvYnRuPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBCdG4gZnJvbSAnLi4vQnRuJztcbmltcG9ydCBXaXphcmRTdGVwIGZyb20gJy4vV2l6YXJkU3RlcCc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICd3aXphcmQtZXJyb3InLFxuXG4gICAgZXh0ZW5kczogV2l6YXJkU3RlcCxcblxuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgICAgQnRuXG4gICAgfSxcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgaWNvbjoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJ2ZhIGZhLTN4IGZhLWNoZWNrJ1xuICAgICAgICB9LFxuXG4gICAgICAgIHRpdGxlOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAnRXJyb3IhJ1xuICAgICAgICB9LFxuXG4gICAgICAgIGVycm9yczogW0FycmF5LCBPYmplY3RdXG5cbiAgICB9XG5cbn07XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJzY3NzXCI+XG5AaW1wb3J0ICcuL25vZGVfbW9kdWxlcy9ib290c3RyYXAvc2Nzcy9mdW5jdGlvbnMuc2Nzcyc7XG5AaW1wb3J0ICcuL25vZGVfbW9kdWxlcy9ib290c3RyYXAvc2Nzcy92YXJpYWJsZXMuc2Nzcyc7XG5cbiR3aXphcmQtZXJyb3ItY29sb3I6ICNiMTA4MDU7XG5cbi53aXphcmQtZXJyb3Ige1xuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICBmb250LXNpemU6ICRmb250LXNpemUtbGc7XG4gICAgcGFkZGluZzogJGZvbnQtc2l6ZS1sZyAqIDQgJGZvbnQtc2l6ZS1sZztcblxuICAgIC53aXphcmQtZXJyb3ItdGl0bGUge1xuICAgICAgICBmb250LXNpemU6ICRmb250LXNpemUtbGcgKiAxLjU7XG4gICAgICAgIGNvbG9yOiAkd2l6YXJkLWVycm9yLWNvbG9yO1xuICAgIH1cblxuICAgIC53aXphcmQtZXJyb3ItaWNvbiB7XG4gICAgICAgIGNvbG9yOiAkd2l6YXJkLWVycm9yLWNvbG9yO1xuICAgICAgICBmb250LXNpemU6ICRmb250LXNpemUtbGc7XG4gICAgICAgIGJvcmRlcjogNXB4IHNvbGlkICR3aXphcmQtZXJyb3ItY29sb3I7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDEwMCU7XG4gICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgd2lkdGg6ICRmb250LXNpemUtbGcgKiA2O1xuICAgICAgICBoZWlnaHQ6ICRmb250LXNpemUtbGcgKiA2O1xuICAgICAgICBtYXJnaW46ICRmb250LXNpemUtbGcgYXV0bztcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuXG4gICAgICAgIGkge1xuICAgICAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgICAgICB0b3A6IDUwJTtcbiAgICAgICAgICAgIGxlZnQ6IDA7XG4gICAgICAgICAgICBsaW5lLWhlaWdodDogMDtcbiAgICAgICAgfVxuICAgIH1cbn1cbjwvc3R5bGU+XG4iLCI8dGVtcGxhdGU+XG4gICAgPGNvbXBvbmVudCA6aXM9XCJ0YWdcIiBjbGFzcz1cIndpemFyZC1oZWFkZXJcIiA6Y2xhc3M9XCJ7J3RleHQtY2VudGVyJzogY2VudGVyfVwiPlxuICAgICAgICA8c2xvdC8+XG4gICAgPC9jb21wb25lbnQ+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ3dpemFyZC1oZWFkZXInLFxuXG4gICAgcHJvcHM6IHtcblxuICAgICAgICBjZW50ZXI6IHtcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgICBkZWZhdWx0OiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBIVE1MIHRhZ1xuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGFnOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAnaDInXG4gICAgICAgIH1cblxuICAgIH1cblxufVxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwic2Nzc1wiPlxuLmNhcmQgPiAud2l6YXJkIHtcbiAgICAud2l6YXJkLWhlYWRlciB7XG4gICAgICAgIG1hcmdpbi10b3A6IDFyZW07XG4gICAgfVxufVxuPC9zdHlsZT5cbiIsIjx0ZW1wbGF0ZT5cbiAgICA8ZGl2IGNsYXNzPVwid2l6YXJkLXByb2dyZXNzXCI+XG4gICAgICAgIDxhXG4gICAgICAgICAgICBocmVmPVwiI1wiXG4gICAgICAgICAgICB2LWZvcj1cIihzdGVwLCBpKSBpbiBzdGVwc1wiXG4gICAgICAgICAgICBjbGFzcz1cIndpemFyZC1zdGVwXCJcbiAgICAgICAgICAgIDpjbGFzcz1cInsnYWN0aXZlJzogaSA9PT0gYWN0aXZlLCAnZGlzYWJsZWQnOiBpID4gaGlnaGVzdFN0ZXAsICdjb21wbGV0ZSc6IGkgKyAxIDw9IGhpZ2hlc3RTdGVwfVwiXG4gICAgICAgICAgICA6ZGF0YS1zdGVwPVwiaVwiXG4gICAgICAgICAgICA6dGl0bGU9XCJzdGVwLmxhYmVsIHx8IHN0ZXAudGl0bGVcIlxuICAgICAgICAgICAgOnN0eWxlPVwie3dpZHRoOiBgJHsxMDAgLyBzdGVwcy5sZW5ndGh9JWB9XCJcbiAgICAgICAgICAgIEBjbGljay5wcmV2ZW50PVwib25DbGljaygkZXZlbnQsIHN0ZXApXCI+XG4gICAgICAgICAgICA8c3BhbiB2LWlmPVwic3RlcC5jb21wb25lbnRPcHRpb25zICYmIHN0ZXAuY29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGEubGFiZWxcIiBjbGFzcz1cIndpemFyZC1zdGVwLWxhYmVsXCIgdi1odG1sPVwic3RlcC5jb21wb25lbnRPcHRpb25zLnByb3BzRGF0YS5sYWJlbFwiLz5cbiAgICAgICAgICAgIDxzcGFuIHYtZWxzZS1pZj1cInN0ZXAuY29tcG9uZW50T3B0aW9ucyAmJiBzdGVwLmNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhLnRpdGxlXCIgY2xhc3M9XCJ3aXphcmQtc3RlcC1sYWJlbFwiIHYtaHRtbD1cInN0ZXAuY29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGEudGl0bGVcIi8+XG4gICAgICAgIDwvYT5cbiAgICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgeyByZWR1Y2UgfSBmcm9tICdsb2Rhc2gtZXMnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAnd2l6YXJkLXByb2dyZXNzJyxcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBpbmRleCBvciBrZXkgb2YgdGhlIGFjdGl2ZSBzdGVwLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfE51bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGFjdGl2ZToge1xuICAgICAgICAgICAgdHlwZTogW1N0cmluZywgTnVtYmVyXSxcbiAgICAgICAgICAgIGRlZmF1bHQ6IDBcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHdpemFyZCBoaWdoZXN0IGF2YWlsYWJsZSB0byB0aGUgdXNlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge0FycmF5fVxuICAgICAgICAgKi9cbiAgICAgICAgaGlnaGVzdFN0ZXA6IHtcbiAgICAgICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgd2l6YXJkIHN0ZXBzXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgICAgICovXG4gICAgICAgIHN0ZXBzOiB7XG4gICAgICAgICAgICB0eXBlOiBBcnJheSxcbiAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBtZXRob2RzOiB7XG5cbiAgICAgICAgb25DbGljayhldmVudCwgc3RlcCkge1xuICAgICAgICAgICAgaWYoIWV2ZW50LnRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ2Rpc2FibGVkJykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdjbGljaycsIGV2ZW50LCBzdGVwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpc0FjdGl2ZTogZmFsc2VcbiAgICAgICAgfVxuICAgIH1cblxufVxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwic2Nzc1wiPlxuQGltcG9ydCAnLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwL3Njc3MvZnVuY3Rpb25zLnNjc3MnO1xuQGltcG9ydCAnLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwL3Njc3MvdmFyaWFibGVzLnNjc3MnO1xuXG4ud2l6YXJkLXByb2dyZXNzIHtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBwYWRkaW5nOiAzMHB4IDA7XG4gICAgY291bnRlci1yZXNldDogc3RlcDtcbn1cblxuLypcbi53aXphcmQtcHJvZ3Jlc3Mtd3JhcHBlciB7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgcGFkZGluZzogMzBweCAwO1xuXG4gICAgJjphZnRlciB7XG4gICAgICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgIGZvbnQtc2l6ZTogMDtcbiAgICAgICAgY29udGVudDogXCIgXCI7XG4gICAgICAgIGNsZWFyOiBib3RoO1xuICAgICAgICBoZWlnaHQ6IDA7XG4gICAgfVxufVxuKi9cblxuLndpemFyZC1zdGVwIHtcbiAgICBjdXJzb3I6IGRlZmF1bHQ7XG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgIGxpc3Qtc3R5bGUtdHlwZTogbm9uZTtcbiAgICBmb250LXNpemU6ICRmb250LXNpemUtYmFzZTtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgIHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7XG5cbiAgICAmOmJlZm9yZSB7XG4gICAgICAgIHdpZHRoOiA0MHB4O1xuICAgICAgICBoZWlnaHQ6IDQwcHg7XG4gICAgICAgIGNvbnRlbnQ6IGNvdW50ZXIoc3RlcCk7XG4gICAgICAgIGNvdW50ZXItaW5jcmVtZW50OiBzdGVwO1xuICAgICAgICBsaW5lLWhlaWdodDogMzZweDtcbiAgICAgICAgZm9udC1zaXplOiAxNXB4O1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgICAgICBtYXJnaW46IDAgYXV0byAxMHB4IGF1dG87XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgei1pbmRleDogMTtcbiAgICAgICAgYm9yZGVyOiAycHggc29saWQgIzAwOGNjMDtcbiAgICAgICAgY29sb3I6ICMwMDhjYzA7XG4gICAgfVxuXG4gICAgJjphZnRlciB7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBoZWlnaHQ6IDJweDtcbiAgICAgICAgY29udGVudDogJyc7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogIzdkN2Q3ZDtcbiAgICAgICAgdG9wOiAyMHB4O1xuICAgICAgICBsZWZ0OiAtNTAlO1xuICAgIH1cblxuICAgICY6Zmlyc3QtY2hpbGQ6YWZ0ZXIge1xuICAgICAgICBjb250ZW50OiBub25lO1xuICAgIH1cblxuICAgICYsICY6aG92ZXIge1xuICAgICAgICBjb2xvcjogIzdkN2Q3ZDtcbiAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xuXG4gICAgICAgICY6bm90KC5kaXNhYmxlZCkge1xuICAgICAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLndpemFyZC1zdGVwLWxhYmVsIHtcbiAgICAgICBjb2xvcjogIzAwOGNjMDtcbiAgICB9XG5cbiAgICAmLmRpc2FibGVkIHtcbiAgICAgICAgY3Vyc29yOiBkZWZhdWx0O1xuXG4gICAgICAgICY6YmVmb3JlIHtcbiAgICAgICAgICAgIGNvbG9yOiAjN2Q3ZDdkO1xuICAgICAgICAgICAgYm9yZGVyLWNvbG9yOiAjN2Q3ZDdkO1xuICAgICAgICB9XG5cbiAgICAgICAgLndpemFyZC1zdGVwLWxhYmVsIHtcbiAgICAgICAgICAgIGNvbG9yOiAjN2Q3ZDdkO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgJi5jb21wbGV0ZSB7XG4gICAgICAgICY6YmVmb3JlIHtcbiAgICAgICAgICAgIGJvcmRlci1jb2xvcjogIzU1Yjc3NjtcbiAgICAgICAgICAgIGNvbG9yOiAjNTViNzc2O1xuICAgICAgICB9XG5cbiAgICAgICAgJjpiZWZvcmUge1xuICAgICAgICAgICAgZm9udC1mYW1pbHk6IEZvbnRBd2Vzb21lO1xuICAgICAgICAgICAgY29udGVudDogXCJcXGYwMGNcIjtcbiAgICAgICAgICAgIGxpbmUtaGVpZ2h0OiA0MHB4O1xuICAgICAgICB9XG5cbiAgICAgICAgJiArIC53aXphcmQtc3RlcDphZnRlciB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjNTViNzc2O1xuICAgICAgICB9XG5cbiAgICAgICAgLndpemFyZC1zdGVwLWxhYmVsIHtcbiAgICAgICAgICAgIGNvbG9yOiAjNTViNzc2O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgJi5hY3RpdmUge1xuICAgICAgICAmOmJlZm9yZSB7XG4gICAgICAgICAgICBib3JkZXItY29sb3I6ICNiMTA4MDU7XG4gICAgICAgICAgICBjb2xvcjogI2IxMDgwNTtcbiAgICAgICAgfVxuXG4gICAgICAgIC53aXphcmQtc3RlcC1sYWJlbCB7XG4gICAgICAgICAgICBjb2xvcjogI2IxMDgwNTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC53aXphcmQ6bm90KC53aXphcmQtZmluaXNoZWQpICYuYWN0aXZlOmhvdmVyOmJlZm9yZSxcbiAgICAud2l6YXJkOm5vdCgud2l6YXJkLWZpbmlzaGVkKSAmLmNvbXBsZXRlOmhvdmVyOmJlZm9yZSB7XG4gICAgICAgIGJvcmRlci1jb2xvcjogI2IxMDgwNTtcbiAgICAgICAgY29sb3I6ICNiMTA4MDU7XG4gICAgfVxuXG4gICAgLndpemFyZDpub3QoLndpemFyZC1maW5pc2hlZCkgJi5jb21wbGV0ZTpob3ZlciArIC53aXphcmQtc3RlcDphZnRlciB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNiMTA4MDU7XG4gICAgfVxufVxuXG48L3N0eWxlPlxuIiwiPHRlbXBsYXRlPlxuICAgIDxkaXYgY2xhc3M9XCJ3aXphcmQtc3VjY2Vzc1wiPlxuICAgICAgICA8ZGl2IHYtaWY9XCJpY29uXCIgY2xhc3M9XCJ3aXphcmQtc3VjY2Vzcy1pY29uXCI+XG4gICAgICAgICAgICA8aSA6Y2xhc3M9XCJpY29uXCIvPlxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8aDMgdi1pZj1cInRpdGxlXCIgY2xhc3M9XCJ3aXphcmQtc3VjY2Vzcy10aXRsZVwiIHYtaHRtbD1cInRpdGxlXCIvPlxuXG4gICAgICAgIDxzbG90Lz5cbiAgICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgV2l6YXJkU3RlcCBmcm9tICcuL1dpemFyZFN0ZXAnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAnd2l6YXJkLXN1Y2Nlc3MnLFxuXG4gICAgZXh0ZW5kczogV2l6YXJkU3RlcCxcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgaWNvbjoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJ2ZhIGZhLWNoZWNrJ1xuICAgICAgICB9LFxuXG4gICAgICAgIHRpdGxlOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAnU3VjY2VzcyEnXG4gICAgICAgIH0sXG5cbiAgICB9XG5cbn07XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJzY3NzXCI+XG5AaW1wb3J0ICcuL25vZGVfbW9kdWxlcy9ib290c3RyYXAvc2Nzcy9mdW5jdGlvbnMuc2Nzcyc7XG5AaW1wb3J0ICcuL25vZGVfbW9kdWxlcy9ib290c3RyYXAvc2Nzcy92YXJpYWJsZXMuc2Nzcyc7XG5cbiR3aXphcmQtc3VjY2Vzcy1jb2xvcjogIzU1Yjc3NjtcblxuLndpemFyZC1zdWNjZXNzIHtcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgZm9udC1zaXplOiAkZm9udC1zaXplLWxnO1xuICAgIHBhZGRpbmc6ICRmb250LXNpemUtbGcgKiA0ICRmb250LXNpemUtbGc7XG5cbiAgICAud2l6YXJkLXN1Y2Nlc3MtdGl0bGUge1xuICAgICAgICBmb250LXNpemU6ICRmb250LXNpemUtbGcgKiAxLjU7XG4gICAgICAgIGNvbG9yOiAkd2l6YXJkLXN1Y2Nlc3MtY29sb3I7XG4gICAgfVxuXG4gICAgLndpemFyZC1zdWNjZXNzLWljb24ge1xuICAgICAgICBjb2xvcjogJHdpemFyZC1zdWNjZXNzLWNvbG9yO1xuICAgICAgICBmb250LXNpemU6ICRmb250LXNpemUtbGcgKiAyLjU7XG4gICAgICAgIGJvcmRlcjogNXB4IHNvbGlkICR3aXphcmQtc3VjY2Vzcy1jb2xvcjtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogMTAwJTtcbiAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgICAgICB3aWR0aDogJGZvbnQtc2l6ZS1sZyAqIDY7XG4gICAgICAgIGhlaWdodDogJGZvbnQtc2l6ZS1sZyAqIDY7XG4gICAgICAgIG1hcmdpbjogJGZvbnQtc2l6ZS1sZyBhdXRvO1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG5cbiAgICAgICAgaSB7XG4gICAgICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgICAgIHRvcDogNTAlO1xuICAgICAgICAgICAgbGVmdDogMDtcbiAgICAgICAgICAgIGxpbmUtaGVpZ2h0OiAwO1xuICAgICAgICB9XG4gICAgfVxufVxuPC9zdHlsZT5cbiIsIjx0ZW1wbGF0ZT5cbiAgICA8ZGl2IGNsYXNzPVwid2l6YXJkXCI+XG5cbiAgICAgICAgPHdpemFyZC1oZWFkZXIgdi1pZj1cImhlYWRlciAmJiAhaXNGaW5pc2hlZFwiIHJlZj1cImhlYWRlclwiIHYtaHRtbD1cImhlYWRlclwiLz5cblxuICAgICAgICA8d2l6YXJkLXByb2dyZXNzXG4gICAgICAgICAgICB2LWlmPVwiIWlzRmluaXNoZWRcIlxuICAgICAgICAgICAgcmVmPVwicHJvZ3Jlc3NcIlxuICAgICAgICAgICAgOmFjdGl2ZT1cImN1cnJlbnRTdGVwXCJcbiAgICAgICAgICAgIDpoaWdoZXN0LXN0ZXA9XCJoaWdoZXN0U3RlcFwiXG4gICAgICAgICAgICA6c3RlcHM9XCJzdGVwc1wiXG4gICAgICAgICAgICBAY2xpY2s9XCJvblByb2dyZXNzQ2xpY2tcIlxuICAgICAgICAvPlxuXG4gICAgICAgIDxkaXYgY2xhc3M9XCJ3aXphcmQtY29udGVudFwiIHJlZj1cImNvbnRlbnRcIj5cbiAgICAgICAgICAgIDxzbG90IHYtaWY9XCIhaXNGaW5pc2hlZFwiIG5hbWU9XCJjb250ZW50XCIvPlxuXG4gICAgICAgICAgICA8c2xpZGUtZGVja1xuICAgICAgICAgICAgICAgIHYtaWY9XCIhaXNGaW5pc2hlZFwiXG4gICAgICAgICAgICAgICAgcmVmPVwic2xpZGVEZWNrXCJcbiAgICAgICAgICAgICAgICA6YWN0aXZlPVwiY3VycmVudFN0ZXBcIlxuICAgICAgICAgICAgICAgIDpyZXNpemUtbW9kZWw9XCJyZXNpemVNb2RlXCJcbiAgICAgICAgICAgICAgICBAYmVmb3JlLWVudGVyPVwib25CZWZvcmVFbnRlclwiXG4gICAgICAgICAgICAgICAgQGVudGVyPVwib25FbnRlclwiXG4gICAgICAgICAgICAgICAgQGxlYXZlPVwib25MZWF2ZVwiPlxuICAgICAgICAgICAgICAgIDxzbG90IC8+XG4gICAgICAgICAgICA8L3NsaWRlLWRlY2s+XG5cbiAgICAgICAgICAgIDxzbG90IHYtZWxzZS1pZj1cImlzRmluaXNoZWQgJiYgIWhhc0ZhaWxlZFwiIG5hbWU9XCJzdWNjZXNzXCI+XG4gICAgICAgICAgICAgICAgPHdpemFyZC1zdWNjZXNzIHJlZj1cInN1Y2Nlc3NcIi8+XG4gICAgICAgICAgICA8L3Nsb3Q+XG5cbiAgICAgICAgICAgIDxzbG90IHYtZWxzZS1pZj1cImlzRmluaXNoZWQgJiYgaGFzRmFpbGVkXCIgbmFtZT1cImVycm9yXCI+XG4gICAgICAgICAgICAgICAgPHdpemFyZC1lcnJvciByZWY9XCJlcnJvclwiIDplcnJvcnM9XCJlcnJvcnNcIiBAYmFjaz1cIm9uQ2xpY2tUZXN0XCIvPlxuICAgICAgICAgICAgPC9zbG90PlxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8c2xvdCB2LWlmPVwiIWlzRmluaXNoZWRcIiBuYW1lPVwiYnV0dG9uc1wiPlxuICAgICAgICAgICAgPGhyPlxuXG4gICAgICAgICAgICA8d2l6YXJkLWJ1dHRvbnNcbiAgICAgICAgICAgICAgICByZWY9XCJidXR0b25zXCJcbiAgICAgICAgICAgICAgICBzaXplPVwibGdcIlxuICAgICAgICAgICAgICAgIDpzdGVwcz1cInN0ZXBzXCJcbiAgICAgICAgICAgICAgICA6YWN0aXZlPVwiY3VycmVudFN0ZXBcIlxuICAgICAgICAgICAgICAgIDphY3Rpdml0eT1cImFjdGl2aXR5XCJcbiAgICAgICAgICAgICAgICA6YmFjay1idXR0b249XCIhaXNCYWNrQnV0dG9uRGlzYWJsZWRcIlxuICAgICAgICAgICAgICAgIDpuZXh0LWJ1dHRvbj1cIiFpc05leHRCdXR0b25EaXNhYmxlZFwiXG4gICAgICAgICAgICAgICAgOmZpbmlzaC1idXR0b249XCIhaXNGaW5pc2hCdXR0b25EaXNhYmxlZFwiXG4gICAgICAgICAgICAgICAgQGNsaWNrOmJhY2s9XCJvbkNsaWNrQmFja1wiXG4gICAgICAgICAgICAgICAgQGNsaWNrOmZpbmlzaD1cIm9uQ2xpY2tGaW5pc2hcIlxuICAgICAgICAgICAgICAgIEBjbGljazpuZXh0PVwib25DbGlja05leHRcIlxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9zbG90PlxuICAgIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCB7IG1hcCB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgeyBlYWNoIH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCB7IGZpbmQgfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IHsgZXh0ZW5kIH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCB7IGZpbHRlciB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgU2xpZGVEZWNrIGZyb20gJy4uL1NsaWRlRGVjayc7XG5pbXBvcnQgV2l6YXJkQnV0dG9ucyBmcm9tICcuL1dpemFyZEJ1dHRvbnMnO1xuaW1wb3J0IFdpemFyZEVycm9yIGZyb20gJy4vV2l6YXJkRXJyb3InO1xuaW1wb3J0IFdpemFyZEhlYWRlciBmcm9tICcuL1dpemFyZEhlYWRlcic7XG5pbXBvcnQgV2l6YXJkUHJvZ3Jlc3MgZnJvbSAnLi9XaXphcmRQcm9ncmVzcyc7XG5pbXBvcnQgV2l6YXJkU3VjY2VzcyBmcm9tICcuL1dpemFyZFN1Y2Nlc3MnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAnd2l6YXJkJyxcblxuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgICAgU2xpZGVEZWNrLFxuICAgICAgICBXaXphcmRCdXR0b25zLFxuICAgICAgICBXaXphcmRFcnJvcixcbiAgICAgICAgV2l6YXJkSGVhZGVyLFxuICAgICAgICBXaXphcmRQcm9ncmVzcyxcbiAgICAgICAgV2l6YXJkU3VjY2Vzc1xuICAgIH0sXG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaW5kZXggb3Iga2V5IG9mIHRoZSBhY3RpdmUgc3RlcC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge1N0cmluZ3xOdW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBhY3RpdmU6IHtcbiAgICAgICAgICAgIHR5cGU6IFtTdHJpbmcsIE51bWJlcl0sXG4gICAgICAgICAgICBkZWZhdWx0OiAwXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0aGUgaW5kZXggb3Iga2V5IG9mIHRoZSBtYXggY29tcGxldGVkIHN0ZXAuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd8TnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgY29tcGxldGVkOiBbU3RyaW5nLCBOdW1iZXJdLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG93IHRoZSBhY3Rpdml0eSBpbmRpY2F0b3IgaW4gdGhlIG5leHQgb3IgZmluaXNoIGJ1dHRvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBhY3Rpdml0eTogQm9vbGVhbixcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvdyBzaG91bGQgdGhlIFwiQmFja1wiIGJ1dHRvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBiYWNrQnV0dG9uOiB7XG4gICAgICAgICAgICB0eXBlOiBbRnVuY3Rpb24sIEJvb2xlYW5dLFxuICAgICAgICAgICAgZGVmYXVsdCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50U3RlcCA+IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3cgc2hvdWxkIHRoZSBcIkZpbmlzaFwiIGJ1dHRvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBmaW5pc2hCdXR0b246IHtcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgICBkZWZhdWx0OiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBhc3MgYSBoZWFkZXIgYXMgYSBzdHJpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBoZWFkZXI6IFN0cmluZyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvdyBzaG91bGQgdGhlIFwiTmV4dFwiIGJ1dHRvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBuZXh0QnV0dG9uOiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbW9kZSBkZXRlcm1pbmVzIGhvdyB0aGUgcG9wb3ZlciBjb250ZW50IHdpbGwgZmxleCBiYXNlZCBvbiB0aGVcbiAgICAgICAgICogdmFyeWluZyBoZWlnaHRzIG9mIHRoZSBzbGlkZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIHJlc2l6ZU1vZGU6IHtcbiAgICAgICAgICAgIHR5cGU6IFtGdW5jdGlvbiwgQm9vbGVhbiwgU3RyaW5nXSxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdhdXRvJyxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsnYXV0bycsICdpbml0aWFsJywgJ2luaGVyaXQnXS5pbmRleE9mKHZhbHVlKSAhPT0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVmFsaWRhdGUgaWYgdGhlIGRhdGEgaW5wdXQgZm9yIHRoZSBzdGVwIGlzIHZhbGlkLiBSZXF1aXJlZCBCb29sZWFuXG4gICAgICAgICAqIG9yIGEgcHJlZGljYXRlIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7RnVuY3Rpb258Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHZhbGlkYXRlOiB7XG4gICAgICAgICAgICB0eXBlOiBbRnVuY3Rpb24sIEJvb2xlYW5dLFxuICAgICAgICAgICAgZGVmYXVsdCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIHdhdGNoOiB7XG5cbiAgICAgICAgYWN0aXZlKCkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50U3RlcCA9IHRoaXMuaW5kZXgoKTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIG1ldGhvZHM6IHtcblxuICAgICAgICBiYWNrKCkge1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgndXBkYXRlOnN0ZXAnLCB0aGlzLmN1cnJlbnRTdGVwID0gTWF0aC5tYXgodGhpcy5jdXJyZW50U3RlcCAtIDEsIDApKTtcbiAgICAgICAgfSxcblxuICAgICAgICBkaXNhYmxlQnV0dG9ucygpIHtcbiAgICAgICAgICAgIHRoaXMuaXNCYWNrQnV0dG9uRGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5pc0ZpbmlzaEJ1dHRvbkRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuaXNOZXh0QnV0dG9uRGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRpc2FibGVCYWNrQnV0dG9uKCkge1xuICAgICAgICAgICAgdGhpcy5pc0JhY2tCdXR0b25EaXNhYmxlZCA9IHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGlzYWJsZUZpbmlzaEJ1dHRvbigpIHtcbiAgICAgICAgICAgIHRoaXMuaXNGaW5pc2hCdXR0b25EaXNhYmxlZCA9IHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGlzYWJsZU5leHRCdXR0b24oKSB7XG4gICAgICAgICAgICB0aGlzLmlzTmV4dEJ1dHRvbkRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICBlbWl0QnViYmxlRXZlbnQoa2V5LCAuLi5hcmdzKSB7XG4gICAgICAgICAgICB0aGlzLiRyZWZzLnNsaWRlRGVjay5zbGlkZSh0aGlzLmN1cnJlbnRTdGVwKS5jb21wb25lbnRJbnN0YW5jZS4kZW1pdC5hcHBseShcbiAgICAgICAgICAgICAgICB0aGlzLiRyZWZzLnNsaWRlRGVjay5zbGlkZSh0aGlzLmN1cnJlbnRTdGVwKS5jb21wb25lbnRJbnN0YW5jZSwgYXJncyA9IFtrZXldLmNvbmNhdChhcmdzKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgdGhpcy4kZW1pdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBlbmFibGVCdXR0b25zKCkge1xuICAgICAgICAgICAgdGhpcy5pc0JhY2tCdXR0b25EaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5pc0ZpbmlzaEJ1dHRvbkRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmlzTmV4dEJ1dHRvbkRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZW5hYmxlQmFja0J1dHRvbigpIHtcbiAgICAgICAgICAgIHRoaXMuaXNCYWNrQnV0dG9uRGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICBlbmFibGVGaW5pc2hCdXR0b24oKSB7XG4gICAgICAgICAgICB0aGlzLmlzRmluaXNoQnV0dG9uRGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICBlbmFibGVOZXh0QnV0dG9uKCkge1xuICAgICAgICAgICAgdGhpcy5pc05leHRCdXR0b25EaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaChzdGF0dXMsIGVycm9ycyA9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgICAgICAgdGhpcy5oYXNGYWlsZWQgPSBzdGF0dXMgPT09IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5pc0ZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICBpbmRleChrZXkgPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgdGhpcy4kc2xvdHMuZGVmYXVsdC5pbmRleE9mKFxuICAgICAgICAgICAgICAgIGZpbmQodGhpcy4kc2xvdHMuZGVmYXVsdCwgWydrZXknLCBrZXkgfHwgdGhpcy5hY3RpdmVdKSB8fCB0aGlzLiRzbG90cy5kZWZhdWx0W2tleSB8fCB0aGlzLmFjdGl2ZV1cbiAgICAgICAgICAgICkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG5leHQoKSB7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCd1cGRhdGU6c3RlcCcsIHRoaXMuY3VycmVudFN0ZXAgPSBNYXRoLm1pbih0aGlzLmN1cnJlbnRTdGVwICsgMSwgdGhpcy4kcmVmcy5zbGlkZURlY2suc2xpZGVzKCkubGVuZ3RoIC0gMSkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uQmVmb3JlRW50ZXIoc2xpZGUsIHByZXYpIHtcbiAgICAgICAgICAgIHNsaWRlLmNvbnRleHQuJGVtaXQoJ2JlZm9yZS1lbnRlcicsIHNsaWRlLCBwcmV2KTtcbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2JlZm9yZS1lbnRlcicsIHNsaWRlLCBwcmV2KTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbkNsaWNrVGVzdChldmVudCkge1xuICAgICAgICAgICAgdGhpcy5pc0ZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25DbGlja0JhY2soZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdEJ1YmJsZUV2ZW50KCdiYWNrJywgZXZlbnQpO1xuXG4gICAgICAgICAgICBpZihldmVudC5kZWZhdWx0UHJldmVudGVkICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5iYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25DbGlja0ZpbmlzaChldmVudCkge1xuICAgICAgICAgICAgdGhpcy5lbWl0QnViYmxlRXZlbnQoJ2ZpbmlzaCcsIGV2ZW50KTtcblxuICAgICAgICAgICAgaWYoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmluaXNoKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG9uQ2xpY2tOZXh0KGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmVtaXRCdWJibGVFdmVudCgnbmV4dCcsIGV2ZW50KTtcblxuICAgICAgICAgICAgaWYoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG9uRW50ZXIoc2xpZGUsIHByZXYpIHtcbiAgICAgICAgICAgIHRoaXMuaGlnaGVzdFN0ZXAgPSBNYXRoLm1heCh0aGlzLmhpZ2hlc3RTdGVwLCB0aGlzLiRyZWZzLnNsaWRlRGVjay4kcmVmcy5zbGlkZXMuZ2V0U2xpZGVJbmRleChzbGlkZSkpO1xuICAgICAgICAgICAgc2xpZGUuY29tcG9uZW50SW5zdGFuY2UuJHJlZnMud2l6YXJkID0gdGhpcztcbiAgICAgICAgICAgIHNsaWRlLmNvbnRleHQuJGVtaXQoJ2VudGVyJywgc2xpZGUsIHByZXYpO1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgnZW50ZXInLCBzbGlkZSwgcHJldik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25MZWF2ZShzbGlkZSwgcHJldikge1xuICAgICAgICAgICAgc2xpZGUuY29udGV4dC4kZW1pdCgnbGVhdmUnLCBzbGlkZSwgcHJldik7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCdsZWF2ZScsIHNsaWRlLCBwcmV2KTtcbiAgICAgICAgfSxcblxuICAgICAgICBvblByb2dyZXNzQ2xpY2soZXZlbnQsIHNsaWRlKSB7XG4gICAgICAgICAgICBpZih0aGlzLiRyZWZzLnNsaWRlRGVjaykge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFN0ZXAgPSB0aGlzLiRyZWZzLnNsaWRlRGVjay4kcmVmcy5zbGlkZXMuZ2V0U2xpZGVJbmRleChzbGlkZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzRmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRTdGVwID0gdGhpcy5pbmRleChzbGlkZS5rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgbW91bnRlZCgpIHtcbiAgICAgICAgY29uc3Qgc2xpZGUgPSB0aGlzLiRyZWZzLnNsaWRlRGVjay5zbGlkZSh0aGlzLmN1cnJlbnRTdGVwKTtcblxuICAgICAgICBpZihzbGlkZSkge1xuICAgICAgICAgICAgKHNsaWRlLmNvbXBvbmVudEluc3RhbmNlIHx8IHNsaWRlLmNvbnRleHQpLiRyZWZzLndpemFyZCA9IHRoaXM7XG4gICAgICAgICAgICAoc2xpZGUuY29tcG9uZW50SW5zdGFuY2UgfHwgc2xpZGUuY29udGV4dCkuJGVtaXQoJ2VudGVyJyk7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCdlbnRlcicsIHNsaWRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3RlcHMgPSB0aGlzLiRyZWZzLnNsaWRlRGVjay5zbGlkZXMoKTtcbiAgICB9LFxuXG4gICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0ZXBzOiBbXSxcbiAgICAgICAgICAgIGVycm9yczogbnVsbCxcbiAgICAgICAgICAgIGhhc0ZhaWxlZDogZmFsc2UsXG4gICAgICAgICAgICBpc0ZpbmlzaGVkOiBmYWxzZSxcbiAgICAgICAgICAgIGN1cnJlbnRTdGVwOiB0aGlzLmluZGV4KCksXG4gICAgICAgICAgICBoaWdoZXN0U3RlcDogdGhpcy5pbmRleCh0aGlzLmNvbXBsZXRlZCksXG4gICAgICAgICAgICBpc0JhY2tCdXR0b25EaXNhYmxlZDogdGhpcy5iYWNrQnV0dG9uID09PSBmYWxzZSxcbiAgICAgICAgICAgIGlzTmV4dEJ1dHRvbkRpc2FibGVkOiB0aGlzLm5leHRCdXR0b24gPT09IGZhbHNlLFxuICAgICAgICAgICAgaXNGaW5pc2hCdXR0b25EaXNhYmxlZDogdGhpcy5maW5pc2hCdXR0b24gPT09IGZhbHNlXG4gICAgICAgIH07XG4gICAgfVxuXG59XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJzY3NzXCI+XG5AaW1wb3J0ICcuL25vZGVfbW9kdWxlcy9ib290c3RyYXAvc2Nzcy9mdW5jdGlvbnMuc2Nzcyc7XG5AaW1wb3J0ICcuL25vZGVfbW9kdWxlcy9ib290c3RyYXAvc2Nzcy92YXJpYWJsZXMuc2Nzcyc7XG5cbi53aXphcmQge1xuICAgIC5zbGlkZS1kZWNrLWNvbnRlbnQge1xuICAgICAgICBtYXJnaW46IDFyZW07XG4gICAgfVxuXG4gICAgLndpemFyZC1jb250ZW50IHtcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgcGFkZGluZzogLjVyZW07XG5cbiAgICAgICAgJiArIGhyIHtcbiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAud2l6YXJkLWJ1dHRvbnMge1xuICAgICAgICBwYWRkaW5nOiAxcmVtO1xuICAgIH1cbn1cblxuPC9zdHlsZT5cbiIsImltcG9ydCBXaXphcmQgZnJvbSAnLi9XaXphcmQnO1xuaW1wb3J0IFdpemFyZEJ1dHRvbnMgZnJvbSAnLi9XaXphcmRCdXR0b25zJztcbmltcG9ydCBXaXphcmRIZWFkZXIgZnJvbSAnLi9XaXphcmRIZWFkZXInO1xuaW1wb3J0IFdpemFyZFByb2dyZXNzIGZyb20gJy4vV2l6YXJkUHJvZ3Jlc3MnO1xuaW1wb3J0IFdpemFyZFN0ZXAgZnJvbSAnLi9XaXphcmRTdGVwJztcbmltcG9ydCBXaXphcmRTdWNjZXNzIGZyb20gJy4vV2l6YXJkU3VjY2Vzcyc7XG5pbXBvcnQgV2l6YXJkRXJyb3IgZnJvbSAnLi9XaXphcmRFcnJvcic7XG5pbXBvcnQgVnVlSW5zdGFsbGVyIGZyb20gJy4uLy4uL0hlbHBlcnMvVnVlSW5zdGFsbGVyL1Z1ZUluc3RhbGxlcic7XG5cbmNvbnN0IHBsdWdpbiA9IFZ1ZUluc3RhbGxlci51c2Uoe1xuXG4gICAgaW5zdGFsbChWdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgVnVlSW5zdGFsbGVyLmNvbXBvbmVudHMoe1xuICAgICAgICAgICAgV2l6YXJkLFxuICAgICAgICAgICAgV2l6YXJkQnV0dG9ucyxcbiAgICAgICAgICAgIFdpemFyZEhlYWRlcixcbiAgICAgICAgICAgIFdpemFyZFByb2dyZXNzLFxuICAgICAgICAgICAgV2l6YXJkU3RlcCxcbiAgICAgICAgICAgIFdpemFyZFN1Y2Nlc3MsXG4gICAgICAgICAgICBXaXphcmRFcnJvclxuICAgICAgICB9KTtcbiAgICB9XG5cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBXaXphcmQ7XG4iLCJjb25zdCBTVFlMRV9BVFRSSUJVVEVTID0gW1xuICAgICdmb250JyxcbiAgICAnZm9udEZhbWlseScsXG4gICAgJ2ZvbnRLZXJuaW5nJyxcbiAgICAnZm9udFNpemUnLFxuICAgICdmb250U3RyZXRjaCcsXG4gICAgJ2ZvbnRTdHlsZScsXG4gICAgJ2ZvbnRWYXJpYW50JyxcbiAgICAnZm9udFZhcmlhbnRMaWdhdHVyZXMnLFxuICAgICdmb250VmFyaWFudENhcHMnLFxuICAgICdmb250VmFyaWFudE51bWVyaWMnLFxuICAgICdmb250VmFyaWFudEVhc3RBc2lhbicsXG4gICAgJ2ZvbnRXZWlnaHQnLFxuICAgICdsaW5lSGVpZ2h0JyxcbiAgICAnbGV0dGVyU3BhY2luZycsXG4gICAgJ3BhZGRpbmcnLFxuICAgICdtYXJnaW4nLFxuICAgICd0ZXh0QWxpZ24nLFxuICAgICd0ZXh0QWxpZ25MYXN0JyxcbiAgICAndGV4dERlY29yYXRpb24nLFxuICAgICd0ZXh0RGVjb3JhdGlvbkxpbmUnLFxuICAgICd0ZXh0RGVjb3JhdGlvblN0eWxlJyxcbiAgICAndGV4dERlY29yYXRpb25Db2xvcicsXG4gICAgJ3RleHREZWNvcmF0aW9uU2tpcEluaycsXG4gICAgJ3RleHREZWNvcmF0aW9uUG9zaXRpb24nLFxuICAgICd0ZXh0SW5kZW50JyxcbiAgICAndGV4dFJlbmRlcmluZycsXG4gICAgJ3RleHRTaGFkb3cnLFxuICAgICd0ZXh0U2l6ZUFkanVzdCcsXG4gICAgJ3RleHRPdmVyZmxvdycsXG4gICAgJ3RleHRUcmFuc2Zvcm0nLFxuICAgICd3aWR0aCcsXG4gICAgJ3dvcmRCcmVhaycsXG4gICAgJ3dvcmRTcGFjaW5nJyxcbiAgICAnd29yZFdyYXAnXG5dO1xuXG5cbmZ1bmN0aW9uIGludChzdHIpIHtcbiAgICBpZih0eXBlb2Ygc3RyID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIGVsc2UgaWYoIXN0ciB8fCAhc3RyLnJlcGxhY2UpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlSW50KHN0ci5yZXBsYWNlKC9bXlxcZC5dKy9nLCAnJykpO1xufVxuXG5mdW5jdGlvbiBpbnB1dChkaXYsIGVsKSB7XG4gICAgZGl2LmlubmVySFRNTCA9IGVsLnZhbHVlLnJlcGxhY2UoLyg/OlxcclxcbnxcXHJ8XFxuKS9nLCAnPGJyIC8+Jyk7XG59XG5cbmZ1bmN0aW9uIGhlaWdodChlbCkge1xuICAgIHJldHVybiBpbnQoZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0KTtcbn1cblxuZnVuY3Rpb24gc3R5bGUoZWwsIGF0dHIpIHtcbiAgICByZXR1cm4gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpW2F0dHJdO1xufVxuXG5mdW5jdGlvbiByZXNpemUodGFyZ2V0LCBkaXYsIG1pbkhlaWdodCwgbWF4SGVpZ2h0KSB7XG4gICAgY29uc3QgZHluYW1pY0hlaWdodCA9IE1hdGgubWF4KGhlaWdodChkaXYpICsgaW50KHN0eWxlKGRpdiwgJ2xpbmVIZWlnaHQnKSksIG1pbkhlaWdodCk7XG4gICAgdGFyZ2V0LnN0eWxlLmhlaWdodCA9ICgoIW1heEhlaWdodCB8fCBkeW5hbWljSGVpZ2h0IDwgbWF4SGVpZ2h0KSA/IGR5bmFtaWNIZWlnaHQgOiBtYXhIZWlnaHQpICsgJ3B4Jztcbn1cblxuZnVuY3Rpb24gc2V0TWluSGVpZ2h0KGRpdiwgZWwpIHtcbiAgICBkaXYuc3R5bGUubWluSGVpZ2h0ID0gaGVpZ2h0KGVsKSArICdweCc7XG59XG5cbmZ1bmN0aW9uIG1pbWljKGVsKSB7XG4gICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29uc3Qgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuXG4gICAgZm9yKGxldCBpIGluIFNUWUxFX0FUVFJJQlVURVMpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gU1RZTEVfQVRUUklCVVRFU1tpXTtcblxuICAgICAgICBkaXYuc3R5bGVba2V5XSA9IHN0eWxlc1trZXldO1xuICAgIH1cblxuICAgIGRpdi5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgZGl2LnN0eWxlLmJvdHRvbSA9ICcxMDAlJztcbiAgICBkaXYuc3R5bGUuekluZGV4ID0gLTE7XG4gICAgZGl2LnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcblxuICAgIHJldHVybiBkaXY7XG59XG5cbmZ1bmN0aW9uIGluaXQoZWwsIG1heEhlaWdodCkge1xuICAgIGNvbnN0IGRpdiA9IG1pbWljKGVsKTtcbiAgICBjb25zdCBtaW5IZWlnaHQgPSBoZWlnaHQoZWwpO1xuXG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBldmVudCA9PiB7XG4gICAgICAgIGlucHV0KGRpdiwgZXZlbnQudGFyZ2V0KTtcbiAgICAgICAgcmVzaXplKGVsLCBkaXYsIG1pbkhlaWdodCwgbWF4SGVpZ2h0KTtcbiAgICB9KTtcblxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcblxuICAgIGlucHV0KGRpdiwgZWwpO1xuICAgIHJlc2l6ZShlbCwgZGl2LCBtaW5IZWlnaHQsIG1heEhlaWdodCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIGluc2VydGVkKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgICAgICBpZihlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgIT09ICd0ZXh0YXJlYScpIHtcbiAgICAgICAgICAgIGVsID0gZWwucXVlcnlTZWxlY3RvcigndGV4dGFyZWEnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCFlbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIHRleHRhcmVhIGlzIHJlcXVpcmVkIGZvciB0aGUgdi1hdXRvZ3JvdyBkaXJlY3RpdmUuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpbml0KGVsLCBiaW5kaW5nLnZhbHVlKTtcbiAgICB9XG5cbn1cbiIsImltcG9ydCB7IGlzVW5kZWZpbmVkIH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCB0cmFuc2l0aW9uIGZyb20gJy4uLy4uL0hlbHBlcnMvVHJhbnNpdGlvbic7XG5cbmZ1bmN0aW9uIHNob3coZWwsIHRhcmdldCwgdm5vZGUpIHtcbiAgICB0YXJnZXQuY2xhc3NMaXN0LnJlbW92ZSgnY29sbGFwc2UnKTtcbiAgICB0YXJnZXQuY2xhc3NMaXN0LmFkZCgnc2hvdycpO1xuICAgIHRhcmdldC4kY29sbGFwc2VkSGVpZ2h0ID0gZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpLmhlaWdodDtcbiAgICB0YXJnZXQuY2xhc3NMaXN0LmFkZCgnY29sbGFwc2luZycpO1xuXG4gICAgdm5vZGUuY29udGV4dC4kbmV4dFRpY2soKCkgPT4ge1xuICAgICAgICB0YXJnZXQuc3R5bGUuaGVpZ2h0ID0gdGFyZ2V0LiRjb2xsYXBzZWRIZWlnaHQ7XG4gICAgfSk7XG5cbiAgICB0cmFuc2l0aW9uKHRhcmdldCkudGhlbihkZWxheSA9PiB7XG4gICAgICAgIHRhcmdldC5zdHlsZS5oZWlnaHQgPSBudWxsO1xuICAgICAgICB0YXJnZXQuY2xhc3NMaXN0LmFkZCgnY29sbGFwc2UnKTtcbiAgICAgICAgdGFyZ2V0LmNsYXNzTGlzdC5yZW1vdmUoJ2NvbGxhcHNpbmcnKTtcbiAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSgnY29sbGFwc2VkJyk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGhpZGUoZWwsIHRhcmdldCwgdm5vZGUpIHtcbiAgICB0YXJnZXQuc3R5bGUuaGVpZ2h0ID0gdGFyZ2V0LiRjb2xsYXBzZWRIZWlnaHQ7XG4gICAgdGFyZ2V0LmNsYXNzTGlzdC5hZGQoJ2NvbGxhcHNpbmcnKTtcbiAgICB0YXJnZXQuY2xhc3NMaXN0LnJlbW92ZSgnY29sbGFwc2UnKTtcblxuICAgIHZub2RlLmNvbnRleHQuJG5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgdGFyZ2V0LnN0eWxlLmhlaWdodCA9IDA7XG4gICAgfSk7XG5cbiAgICB0cmFuc2l0aW9uKHRhcmdldCkudGhlbihkZWxheSA9PiB7XG4gICAgICAgIHRhcmdldC5zdHlsZS5oZWlnaHQgPSBudWxsO1xuICAgICAgICB0YXJnZXQuY2xhc3NMaXN0LmFkZCgnY29sbGFwc2UnKTtcbiAgICAgICAgdGFyZ2V0LmNsYXNzTGlzdC5yZW1vdmUoJ3Nob3cnLCAnY29sbGFwc2luZycpO1xuICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKCdjb2xsYXBzZWQnKTtcbiAgICB9KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgaW5zZXJ0ZWQoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgICAgIGlmKGlzVW5kZWZpbmVkKGJpbmRpbmcudmFsdWUpIHx8IGJpbmRpbmcudmFsdWUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoJ2NvbGxhcHNlZCcpO1xuICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdkYXRhLXRvZ2dsZScsICdjb2xsYXBzZScpO1xuXG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGFyZ2V0JykgfHwgZWwuZ2V0QXR0cmlidXRlKCdocmVmJyk7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwodGFyZ2V0KTtcblxuICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgZWxlbWVudHMuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYoIWVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdzaG93JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3coZWwsIGVsZW1lbnQsIHZub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpZGUoZWwsIGVsZW1lbnQsIHZub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgaWYoIWVsZW1lbnQuJGNvbGxhcHNlZEhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LiRjb2xsYXBzZWRIZWlnaHQgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLmhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICAgIGlmKCFlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnY29sbGFwc2UnKSkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2NvbGxhcHNlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbn1cbiIsImltcG9ydCB7IGdldCB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgeyBrZWJhYkNhc2UgfSBmcm9tICdsb2Rhc2gtZXMnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBpbnNlcnRlZChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSBlbC5xdWVyeVNlbGVjdG9yKCdpbnB1dCwgdGV4dGFyZWEnKSB8fCBlbDtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBnZXQodm5vZGUuY29udGV4dCwgYmluZGluZy5leHByZXNzaW9uKTtcblxuICAgICAgICBsZXQgZWRpdGFibGUgPSAhaW5wdXQudmFsdWU7XG5cbiAgICAgICAgY29uc3QgdXBkYXRlID0gdmFsdWUgPT4ge1xuICAgICAgICAgICAgaWYoZWRpdGFibGUpIHtcbiAgICAgICAgICAgICAgICBpbnB1dC52YWx1ZSA9IGtlYmFiQ2FzZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaW5wdXQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2lucHV0JykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZub2RlLmNvbnRleHQuJHdhdGNoKGJpbmRpbmcuZXhwcmVzc2lvbiwgdXBkYXRlKTtcblxuICAgICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIGV2ZW50ID0+IHtcbiAgICAgICAgICAgIGlucHV0LnZhbHVlID0ga2ViYWJDYXNlKGV2ZW50LnRhcmdldC52YWx1ZSkgKyAoXG4gICAgICAgICAgICAgICAgZXZlbnQudGFyZ2V0LnZhbHVlLm1hdGNoKC9cXHMkLykgPyAnICcgOiAnJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBldmVudCA9PiB7XG4gICAgICAgICAgICBpZihldmVudCBpbnN0YW5jZW9mIElucHV0RXZlbnQpIHtcbiAgICAgICAgICAgICAgICBlZGl0YWJsZSA9ICFldmVudC50YXJnZXQudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBldmVudCA9PiB7XG4gICAgICAgICAgICBpbnB1dC52YWx1ZSA9IGtlYmFiQ2FzZShldmVudC50YXJnZXQudmFsdWUgfHwgYmluZGluZy5leHByZXNzaW9uLnNwbGl0KCcuJykucmVkdWNlKChvLGkpPT5vW2ldLCB2bm9kZS5jb250ZXh0KSk7XG4gICAgICAgICAgICBpbnB1dC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnaW5wdXQnKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgICFpbnB1dC52YWx1ZSAmJiB1cGRhdGUodmFsdWUpO1xuICAgIH1cblxufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYmxvYih1cmwsIHByb2dyZXNzKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIHVybCwgdHJ1ZSk7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYmxvYic7XG5cbiAgICAgICAgaWYoaXNGdW5jdGlvbihwcm9ncmVzcykpIHtcbiAgICAgICAgICAgIHhoci5vbnByb2dyZXNzID0gZSA9PiBwcm9ncmVzcyhlLCB4aHIpO1xuICAgICAgICB9XG5cbiAgICAgICAgeGhyLm9uZXJyb3IgPSBlID0+IHJlamVjdChlKTtcbiAgICAgICAgeGhyLm9uYWJvcnQgPSBlID0+IHJlamVjdChlKTtcbiAgICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLnJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB4aHIuc2VuZCgpO1xuICAgIH0pO1xufVxuIiwiaW1wb3J0IGJhc2VSZXN0IGZyb20gJy4vX2Jhc2VSZXN0LmpzJztcbmltcG9ydCBjcmVhdGVXcmFwIGZyb20gJy4vX2NyZWF0ZVdyYXAuanMnO1xuaW1wb3J0IGdldEhvbGRlciBmcm9tICcuL19nZXRIb2xkZXIuanMnO1xuaW1wb3J0IHJlcGxhY2VIb2xkZXJzIGZyb20gJy4vX3JlcGxhY2VIb2xkZXJzLmpzJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgZnVuY3Rpb24gbWV0YWRhdGEuICovXG52YXIgV1JBUF9QQVJUSUFMX0ZMQUcgPSAzMjtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGBwYXJ0aWFsc2AgcHJlcGVuZGVkIHRvIHRoZVxuICogYXJndW1lbnRzIGl0IHJlY2VpdmVzLiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmJpbmRgIGV4Y2VwdCBpdCBkb2VzICoqbm90KipcbiAqIGFsdGVyIHRoZSBgdGhpc2AgYmluZGluZy5cbiAqXG4gKiBUaGUgYF8ucGFydGlhbC5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljXG4gKiBidWlsZHMsIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgZG9lc24ndCBzZXQgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgb2YgcGFydGlhbGx5XG4gKiBhcHBsaWVkIGZ1bmN0aW9ucy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMi4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHBhcnRpYWxseSBhcHBseSBhcmd1bWVudHMgdG8uXG4gKiBAcGFyYW0gey4uLip9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHBhcnRpYWxseSBhcHBsaWVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBncmVldChncmVldGluZywgbmFtZSkge1xuICogICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyBuYW1lO1xuICogfVxuICpcbiAqIHZhciBzYXlIZWxsb1RvID0gXy5wYXJ0aWFsKGdyZWV0LCAnaGVsbG8nKTtcbiAqIHNheUhlbGxvVG8oJ2ZyZWQnKTtcbiAqIC8vID0+ICdoZWxsbyBmcmVkJ1xuICpcbiAqIC8vIFBhcnRpYWxseSBhcHBsaWVkIHdpdGggcGxhY2Vob2xkZXJzLlxuICogdmFyIGdyZWV0RnJlZCA9IF8ucGFydGlhbChncmVldCwgXywgJ2ZyZWQnKTtcbiAqIGdyZWV0RnJlZCgnaGknKTtcbiAqIC8vID0+ICdoaSBmcmVkJ1xuICovXG52YXIgcGFydGlhbCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIHBhcnRpYWxzKSB7XG4gIHZhciBob2xkZXJzID0gcmVwbGFjZUhvbGRlcnMocGFydGlhbHMsIGdldEhvbGRlcihwYXJ0aWFsKSk7XG4gIHJldHVybiBjcmVhdGVXcmFwKGZ1bmMsIFdSQVBfUEFSVElBTF9GTEFHLCB1bmRlZmluZWQsIHBhcnRpYWxzLCBob2xkZXJzKTtcbn0pO1xuXG4vLyBBc3NpZ24gZGVmYXVsdCBwbGFjZWhvbGRlcnMuXG5wYXJ0aWFsLnBsYWNlaG9sZGVyID0ge307XG5cbmV4cG9ydCBkZWZhdWx0IHBhcnRpYWw7XG4iLCJpbXBvcnQgY2FzdEZ1bmN0aW9uIGZyb20gJy4vX2Nhc3RGdW5jdGlvbi5qcyc7XG5pbXBvcnQgcGFydGlhbCBmcm9tICcuL3BhcnRpYWwuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHByb3ZpZGVzIGB2YWx1ZWAgdG8gYHdyYXBwZXJgIGFzIGl0cyBmaXJzdFxuICogYXJndW1lbnQuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgZnVuY3Rpb24gYXJlIGFwcGVuZGVkXG4gKiB0byB0aG9zZSBwcm92aWRlZCB0byB0aGUgYHdyYXBwZXJgLiBUaGUgd3JhcHBlciBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYFxuICogYmluZGluZyBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbd3JhcHBlcj1pZGVudGl0eV0gVGhlIHdyYXBwZXIgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIHAgPSBfLndyYXAoXy5lc2NhcGUsIGZ1bmN0aW9uKGZ1bmMsIHRleHQpIHtcbiAqICAgcmV0dXJuICc8cD4nICsgZnVuYyh0ZXh0KSArICc8L3A+JztcbiAqIH0pO1xuICpcbiAqIHAoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJyk7XG4gKiAvLyA9PiAnPHA+ZnJlZCwgYmFybmV5LCAmYW1wOyBwZWJibGVzPC9wPidcbiAqL1xuZnVuY3Rpb24gd3JhcCh2YWx1ZSwgd3JhcHBlcikge1xuICByZXR1cm4gcGFydGlhbChjYXN0RnVuY3Rpb24od3JhcHBlciksIHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgd3JhcDtcbiIsImltcG9ydCB7IHdyYXAgfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IHsgaXNGdW5jdGlvbiB9IGZyb20gJ2xvZGFzaC1lcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGVsYXBzZWQobWlsbGlzZWNvbmRzLCBjYWxsYmFjaywgZWxhcHNlZENhbGxiYWNrKSB7XG4gICAgbGV0IGhhc0VsYXBzZWQgPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBoYXNFbGFwc2VkID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYoaXNGdW5jdGlvbihlbGFwc2VkQ2FsbGJhY2spKSB7XG4gICAgICAgICAgICAgICAgZWxhcHNlZENhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIG1pbGxpc2Vjb25kcylcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQoaW50ZXJ2YWwpO1xuICAgIH1cblxuICAgIGNvbnN0IGludGVydmFsID0gc3RhcnQoKSwgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgZnVuY3Rpb24gcmVzb2x2ZXIocmVzb2x2ZXIsIHJlc3BvbnNlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZXIocmVzcG9uc2UgfHwgaGFzRWxhcHNlZCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY2FsbGJhY2sod3JhcChyZXNvbHZlLCByZXNvbHZlciksIHdyYXAocmVqZWN0LCByZXNvbHZlcikpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHByb21pc2UuZmluYWxseShzdG9wLCBzdG9wKTtcbn1cbiIsImNvbnN0IGVhc2luZ3MgPSB7XG4gICAgbGluZWFyKHQpIHtcbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfSxcbiAgICBlYXNlSW5RdWFkKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgKiB0O1xuICAgIH0sXG4gICAgZWFzZU91dFF1YWQodCkge1xuICAgICAgICByZXR1cm4gdCAqICgyIC0gdCk7XG4gICAgfSxcbiAgICBlYXNlSW5PdXRRdWFkKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPCAwLjUgPyAyICogdCAqIHQgOiAtMSArICg0IC0gMiAqIHQpICogdDtcbiAgICB9LFxuICAgIGVhc2VJbkN1YmljKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgKiB0ICogdDtcbiAgICB9LFxuICAgIGVhc2VPdXRDdWJpYyh0KSB7XG4gICAgICAgIHJldHVybiAoLS10KSAqIHQgKiB0ICsgMTtcbiAgICB9LFxuICAgIGVhc2VJbk91dEN1YmljKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPCAwLjUgPyA0ICogdCAqIHQgKiB0IDogKHQgLSAxKSAqICgyICogdCAtIDIpICogKDIgKiB0IC0gMikgKyAxO1xuICAgIH0sXG4gICAgZWFzZUluUXVhcnQodCkge1xuICAgICAgICByZXR1cm4gdCAqIHQgKiB0ICogdDtcbiAgICB9LFxuICAgIGVhc2VPdXRRdWFydCh0KSB7XG4gICAgICAgIHJldHVybiAxIC0gKC0tdCkgKiB0ICogdCAqIHQ7XG4gICAgfSxcbiAgICBlYXNlSW5PdXRRdWFydCh0KSB7XG4gICAgICAgIHJldHVybiB0IDwgMC41ID8gOCAqIHQgKiB0ICogdCAqIHQgOiAxIC0gOCAqICgtLXQpICogdCAqIHQgKiB0O1xuICAgIH0sXG4gICAgZWFzZUluUXVpbnQodCkge1xuICAgICAgICByZXR1cm4gdCAqIHQgKiB0ICogdCAqIHQ7XG4gICAgfSxcbiAgICBlYXNlT3V0UXVpbnQodCkge1xuICAgICAgICByZXR1cm4gMSArICgtLXQpICogdCAqIHQgKiB0ICogdDtcbiAgICB9LFxuICAgIGVhc2VJbk91dFF1aW50KHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPCAwLjUgPyAxNiAqIHQgKiB0ICogdCAqIHQgKiB0IDogMSArIDE2ICogKC0tdCkgKiB0ICogdCAqIHQgKiB0O1xuICAgIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNjcm9sbFRvKGRlc3RpbmF0aW9uLCBkdXJhdGlvbiA9IDEwMDAsIGVhc2luZyA9ICdlYXNlSW5RdWFkJywgdmlld3BvcnQgPSBmYWxzZSkge1xuICAgIGlmKCF2aWV3cG9ydCkge1xuICAgICAgICB2aWV3cG9ydCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2JvZHknKTtcbiAgICB9XG5cbiAgICBjb25zdCB2aWV3cG9ydEJvdW5kcyA9IHZpZXdwb3J0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IGRlc3RpbmF0aW9uQm91bmRzID0gZGVzdGluYXRpb24uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgZGVzdGluYXRpb25PZmZzZXRUb1Njcm9sbCA9IE1hdGguY2VpbChkZXN0aW5hdGlvbkJvdW5kcy50b3AgKyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wKTtcblxuICAgIGZ1bmN0aW9uIGlzU2Nyb2xsQm90dG9tKCkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCA+PSBNYXRoLmZsb29yKHZpZXdwb3J0Qm91bmRzLmhlaWdodCkgLSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIGNvbnN0IGlzU3RhcnRpbmdCb3R0b20gPSBpc1Njcm9sbEJvdHRvbSgpO1xuXG4gICAgICAgIGZ1bmN0aW9uIHNjcm9sbCgpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcDtcbiAgICAgICAgICAgIGNvbnN0IHRpbWUgPSBNYXRoLm1pbigxLCAoKHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRUaW1lKSAvIGR1cmF0aW9uKSk7XG4gICAgICAgICAgICBjb25zdCB0aW1lRnVuY3Rpb24gPSBlYXNpbmdzW2Vhc2luZ10odGltZSk7XG5cbiAgICAgICAgICAgIHdpbmRvdy5zY3JvbGwoMCwgTWF0aC5jZWlsKCh0aW1lRnVuY3Rpb24gKiAoZGVzdGluYXRpb25PZmZzZXRUb1Njcm9sbCAtIHN0YXJ0KSkgKyBzdGFydCkpO1xuXG4gICAgICAgICAgICBpZiAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCA9PT0gZGVzdGluYXRpb25PZmZzZXRUb1Njcm9sbCB8fCBpc1Njcm9sbEJvdHRvbSgpICYmICFpc1N0YXJ0aW5nQm90dG9tKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHNjcm9sbCk7XG4gICAgICAgIH1cblxuICAgICAgICBzY3JvbGwoKTtcbiAgICB9KTtcbn1cbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLmZpbmRLZXlgIGFuZCBgXy5maW5kTGFzdEtleWAsXG4gKiB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMsIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYGNvbGxlY3Rpb25gXG4gKiB1c2luZyBgZWFjaEZ1bmNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGBjb2xsZWN0aW9uYC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmb3VuZCBlbGVtZW50IG9yIGl0cyBrZXksIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGaW5kS2V5KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZWFjaEZ1bmMpIHtcbiAgdmFyIHJlc3VsdDtcbiAgZWFjaEZ1bmMoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGtleSwgY29sbGVjdGlvbikpIHtcbiAgICAgIHJlc3VsdCA9IGtleTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlRmluZEtleTtcbiIsImltcG9ydCBiYXNlRmluZEtleSBmcm9tICcuL19iYXNlRmluZEtleS5qcyc7XG5pbXBvcnQgYmFzZUZvck93biBmcm9tICcuL19iYXNlRm9yT3duLmpzJztcbmltcG9ydCBiYXNlSXRlcmF0ZWUgZnJvbSAnLi9fYmFzZUl0ZXJhdGVlLmpzJztcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGtleSBvZiB0aGUgZmlyc3RcbiAqIGVsZW1lbnQgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yIGluc3RlYWQgb2YgdGhlIGVsZW1lbnQgaXRzZWxmLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMS4xLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IFJldHVybnMgdGhlIGtleSBvZiB0aGUgbWF0Y2hlZCBlbGVtZW50LFxuICogIGVsc2UgYHVuZGVmaW5lZGAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciB1c2VycyA9IHtcbiAqICAgJ2Jhcm5leSc6ICB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAqICAgJ2ZyZWQnOiAgICB7ICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gKiAgICdwZWJibGVzJzogeyAnYWdlJzogMSwgICdhY3RpdmUnOiB0cnVlIH1cbiAqIH07XG4gKlxuICogXy5maW5kS2V5KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFnZSA8IDQwOyB9KTtcbiAqIC8vID0+ICdiYXJuZXknIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmluZEtleSh1c2VycywgeyAnYWdlJzogMSwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gKiAvLyA9PiAncGViYmxlcydcbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbmRLZXkodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAqIC8vID0+ICdmcmVkJ1xuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kS2V5KHVzZXJzLCAnYWN0aXZlJyk7XG4gKiAvLyA9PiAnYmFybmV5J1xuICovXG5mdW5jdGlvbiBmaW5kS2V5KG9iamVjdCwgcHJlZGljYXRlKSB7XG4gIHJldHVybiBiYXNlRmluZEtleShvYmplY3QsIGJhc2VJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCBiYXNlRm9yT3duKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZmluZEtleTtcbiIsImltcG9ydCB7IHdyYXAgfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IHsgZmluZEtleSB9IGZyb20gJ2xvZGFzaC1lcyc7XG5cbmNvbnN0IENBTExCQUNLUyA9IHt9O1xuXG5mdW5jdGlvbiBpZChjYWxsYmFjaykge1xuICAgIHJldHVybiBmaW5kS2V5KENBTExCQUNLUywgY29tcGFyZSA9PiB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjay50b1N0cmluZygpID09IGNvbXBhcmUudG9TdHJpbmcoKTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gcmVzdGFydChjYWxsYmFjaywgbWlsbGlzZWNvbmRzKSB7XG4gICAgc3RvcChpZChjYWxsYmFjaykpO1xuICAgIHN0YXJ0KGNhbGxiYWNrLCBtaWxsaXNlY29uZHMpO1xufVxuXG5mdW5jdGlvbiBzdG9wKGlkKSB7XG4gICAgY2xlYXJUaW1lb3V0KGlkKTtcbiAgICBkZWxldGUgQ0FMTEJBQ0tTW2lkXTtcbn1cblxuZnVuY3Rpb24gc3RhcnQoY2FsbGJhY2ssIG1pbGxpc2Vjb25kcykge1xuICAgIHJldHVybiBDQUxMQkFDS1Nbc2V0VGltZW91dChjYWxsYmFjaywgbWlsbGlzZWNvbmRzKV0gPSBjYWxsYmFjaztcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gd2FpdChtaWxsaXNlY29uZHMsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgZnVuY3Rpb24gcmVzb2x2ZXIocmVzb2x2ZXIsIHJlc3BvbnNlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZXIocmVzcG9uc2UpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlc3RhcnQod3JhcChjYWxsYmFjaywgY2FsbGJhY2sgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHdyYXAocmVzb2x2ZSwgcmVzb2x2ZXIpLCB3cmFwKHJlamVjdCwgcmVzb2x2ZXIpKTtcbiAgICAgICAgfSksIG1pbGxpc2Vjb25kcyk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcHJvbWlzZS5maW5hbGx5KHN0b3AsIHN0b3ApO1xufVxuXG5cbi8qXG5pbXBvcnQgeyB3cmFwIH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCB7IGlzRnVuY3Rpb24gfSBmcm9tICdsb2Rhc2gtZXMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBlbGFwc2VkKGRlbGF5LCBjYWxsYmFjaywgZWxhcHNlZENhbGxiYWNrKSB7XG4gICAgbGV0IGhhc0VsYXBzZWQgPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgICByZXR1cm4gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgaGFzRWxhcHNlZCA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmKGlzRnVuY3Rpb24oZWxhcHNlZENhbGxiYWNrKSkge1xuICAgICAgICAgICAgICAgIGVsYXBzZWRDYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBkZWxheSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbnRlcnZhbCA9IHN0YXJ0KCksIHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGZ1bmN0aW9uIHJlc29sdmVyKHJlc29sdmVyLCByZXNwb25zZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVyKHJlc3BvbnNlIHx8IGhhc0VsYXBzZWQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNhbGxiYWNrKHdyYXAocmVzb2x2ZSwgcmVzb2x2ZXIpLCB3cmFwKHJlamVjdCwgcmVzb2x2ZXIpKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBwcm9taXNlLmZpbmFsbHkoc3RvcCwgc3RvcCk7XG59XG5cbiAqL1xuIiwiaW1wb3J0ICogYXMgZmlsdGVycyBmcm9tICcuL0ZpbHRlcnMnO1xuaW1wb3J0ICogYXMgcGx1Z2lucyBmcm9tICcuL1BsdWdpbnMnO1xuaW1wb3J0ICogYXMgY29tcG9uZW50cyBmcm9tICcuL0NvbXBvbmVudHMnO1xuaW1wb3J0ICogYXMgZGlyZWN0aXZlcyBmcm9tICcuL0RpcmVjdGl2ZXMnO1xuaW1wb3J0IFZ1ZUluc3RhbGxlciBmcm9tICcuL0hlbHBlcnMvVnVlSW5zdGFsbGVyJztcblxuZXhwb3J0ICogZnJvbSAnLi9IdHRwJztcbmV4cG9ydCAqIGZyb20gJy4vTWl4aW5zJztcbmV4cG9ydCAqIGZyb20gJy4vSGVscGVycyc7XG5leHBvcnQgKiBmcm9tICcuL1BsdWdpbnMnO1xuZXhwb3J0ICogZnJvbSAnLi9Db21wb25lbnRzJztcbmV4cG9ydCAqIGZyb20gJy4vRGlyZWN0aXZlcyc7XG5leHBvcnQgKiBmcm9tICcuL0ZpbHRlcnMnO1xuXG5leHBvcnQgZGVmYXVsdCBWdWVJbnN0YWxsZXIudXNlKHtcblxuICAgIGluc3RhbGwoVnVlKSB7XG4gICAgICAgIFZ1ZUluc3RhbGxlci5wbHVnaW5zKFZ1ZSwgcGx1Z2lucyk7XG4gICAgICAgIFZ1ZUluc3RhbGxlci5maWx0ZXJzKFZ1ZSwgZmlsdGVycyk7XG4gICAgICAgIFZ1ZUluc3RhbGxlci5kaXJlY3RpdmVzKFZ1ZSwgZGlyZWN0aXZlcyk7XG4gICAgICAgIFZ1ZUluc3RhbGxlci5jb21wb25lbnRzKFZ1ZSwgY29tcG9uZW50cyk7XG4gICAgfVxuXG59KTtcbiJdLCJuYW1lcyI6WyJ2YWx1ZSIsImZvcm1hdCIsIm1vbWVudCIsIlN0cmluZyIsIlZ1ZSIsIm9wdGlvbnMiLCJmaWx0ZXIiLCJEYXRlRmlsdGVyIiwiTW9tZW50RmlsdGVyIiwiZ2xvYmFsIiwiU3ltYm9sIiwib2JqZWN0UHJvdG8iLCJuYXRpdmVPYmplY3RUb1N0cmluZyIsInN5bVRvU3RyaW5nVGFnIiwiaXNGdW5jdGlvbiIsImZ1bmNQcm90byIsImZ1bmNUb1N0cmluZyIsImhhc093blByb3BlcnR5IiwiTWFwIiwiSEFTSF9VTkRFRklORUQiLCJmcmVlRXhwb3J0cyIsImZyZWVNb2R1bGUiLCJtb2R1bGVFeHBvcnRzIiwiQnVmZmVyIiwiYXJnc1RhZyIsImZ1bmNUYWciLCJvYmplY3RUYWciLCJNQVhfU0FGRV9JTlRFR0VSIiwia2V5c0luIiwiYm9vbFRhZyIsIkNPTVBBUkVfUEFSVElBTF9GTEFHIiwiQ09NUEFSRV9VTk9SREVSRURfRkxBRyIsImRhdGVUYWciLCJlcnJvclRhZyIsIm1hcFRhZyIsIm51bWJlclRhZyIsInJlZ2V4cFRhZyIsInNldFRhZyIsInN0cmluZ1RhZyIsImFycmF5QnVmZmVyVGFnIiwiZGF0YVZpZXdUYWciLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIlByb21pc2UiLCJ3ZWFrTWFwVGFnIiwiYXJyYXlUYWciLCJnZXRUYWciLCJzeW1ib2xUYWciLCJzeW1ib2xQcm90byIsIklORklOSVRZIiwicHJlZml4Iiwic3ViamVjdCIsImRlbGltZXRlciIsInByZWZpeGVyIiwia2V5Iiwic3RyaW5nIiwiX2ZpbHRlciIsInJlcGxhY2UiLCJSZWdFeHAiLCJqb2luIiwiX2lzQm9vbGVhbiIsIl9pc051bGwiLCJfaXNVbmRlZmluZWQiLCJfaXNPYmplY3QiLCJfbWFwS2V5cyIsInByb3BzIiwidmFyaWFudCIsInR5cGUiLCJkZWZhdWx0IiwiY29tcHV0ZWQiLCJ2YXJpYW50Q2xhc3NQcmVmaXgiLCIkb3B0aW9ucyIsIm5hbWUiLCJ2YXJpYW50Q2xhc3MiLCJzaXplIiwidmFsaWRhdGUiLCJpbmRleE9mIiwic2l6ZWFibGVDbGFzc1ByZWZpeCIsInNpemVhYmxlQ2xhc3MiLCJyc0FzdHJhbFJhbmdlIiwicnNDb21ib01hcmtzUmFuZ2UiLCJyZUNvbWJvSGFsZk1hcmtzUmFuZ2UiLCJyc0NvbWJvU3ltYm9sc1JhbmdlIiwicnNDb21ib1JhbmdlIiwicnNWYXJSYW5nZSIsInJzWldKIiwicnNDb21ibyIsInJzRml0eiIsInJzTW9kaWZpZXIiLCJyc05vbkFzdHJhbCIsInJzUmVnaW9uYWwiLCJyc1N1cnJQYWlyIiwicmVPcHRNb2QiLCJyc09wdFZhciIsInJzT3B0Sm9pbiIsInJzU2VxIiwicnNBcG9zIiwiRlVOQ19FUlJPUl9URVhUIiwibmF0aXZlR2V0U3ltYm9scyIsIkNPTE9SUyIsIl9lYWNoIiwiX2NhbWVsQ2FzZSIsImNvbG9yIiwibmFtZXNwYWNlIiwiQm9vbGVhbiIsImNsYXNzZXMiLCJpbnN0YW5jZSIsIl9tYXAiLCJtZXRob2RzIiwidGV4dENvbG9yIiwiYmdDb2xvciIsImJvcmRlckNvbG9yIiwiYmdHcmFkaWVudENvbG9yIiwidGV4dENvbG9yQ2xhc3NlcyIsInRyaW0iLCJib3JkZXJDb2xvckNsYXNzZXMiLCJiZ0NvbG9yQ2xhc3NlcyIsImJnR3JhZGllbnRDb2xvckNsYXNzZXMiLCJjb2xvcmFibGVDbGFzc2VzIiwiX29taXRCeSIsImR1cmF0aW9uIiwiZWwiLCJnZXRDb21wdXRlZFN0eWxlIiwidHJhbnNpdGlvbkR1cmF0aW9uIiwibnVtZXJpYyIsInBhcnNlRmxvYXQiLCJ1bml0IiwibWF0Y2giLCJ0cmFuc2l0aW9uIiwicmVzb2x2ZSIsInJlamVjdCIsImRlbGF5Iiwic2V0VGltZW91dCIsImUiLCJtZXJnZUNsYXNzZXMiLCJzbGljZSIsImNhbGwiLCJhcmd1bWVudHMiLCJhcmciLCJfaXNBcnJheSIsInJlbmRlciIsIm1peGlucyIsIlZhcmlhbnQiLCJTaXplYWJsZSIsIkNvbG9yYWJsZSIsIk1lcmdlQ2xhc3NlcyIsImFjdGl2ZSIsImJsb2NrIiwiZGlzYWJsZWQiLCJocmVmIiwibGFiZWwiLCJvdXRsaW5lIiwidG8iLCJPYmplY3QiLCJvbkNsaWNrIiwiZXZlbnQiLCIkZW1pdCIsIkxPQURFRF9TQ1JJUFRTIiwiZWxlbWVudCIsInVybCIsInNjcmlwdCIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsInNldEF0dHJpYnV0ZSIsImFwcGVuZCIsInF1ZXJ5U2VsZWN0b3IiLCJhcHBlbmRDaGlsZCIsImFkZEV2ZW50TGlzdGVuZXIiLCJWdWVJbnN0YWxsZXIiLCJ1c2UiLCJwbHVnaW4iLCJwbHVnaW5zIiwiZmlsdGVycyIsImNvbXBvbmVudCIsImNvbXBvbmVudHMiLCJkaXJlY3RpdmUiLCJkaXJlY3RpdmVzIiwiJHBsdWdpbnMiLCIkZmlsdGVycyIsIiRkaXJlY3RpdmVzIiwiJGNvbXBvbmVudHMiLCJ3aW5kb3ciLCJkZWYiLCJfaXNGdW5jdGlvbiIsImluc3RhbGwiLCJCdG4iLCJNb2RhbFRpdGxlIiwiYXJpYUxhYmVsIiwiY2xvc2VhYmxlIiwibm9kZXMiLCJOdW1iZXIiLCJleHRlbmRzIiwiQmFzZVR5cGUiLCJfZXh0ZW5kIiwiaXNGaW5pdGUiLCJoZWlnaHQiLCJfaXNGaW5pdGUiLCJjZW50ZXIiLCJmaXhlZCIsInJlbGF0aXZlIiwibWF4SGVpZ2h0IiwibWluSGVpZ2h0Iiwid2lkdGgiLCJtYXhXaWR0aCIsIm1pbldpZHRoIiwiQWN0aXZpdHlJbmRpY2F0b3JEb3RzIiwiQWN0aXZpdHlJbmRpY2F0b3JTcGlubmVyIiwic3R5bGUiLCJfa2ViYWJDYXNlIiwiQWN0aXZpdHlJbmRpY2F0b3IiLCJjb252ZXJ0QW5pbWF0aW9uRGVsYXlUb0ludCIsIm51bSIsIm1hdGNoZXMiLCJtaWxsaXNlY29uZHMiLCJhbmltYXRlZCIsImNhbGxiYWNrIiwiZGVmYXVsdFZpZXciLCJvd25lckRvY3VtZW50IiwiYXBwbHkiLCJhbmltYXRpb25EdXJhdGlvbiIsImFjdGl2aXR5IiwiaWNvbiIsImluZGljYXRvciIsIm9yaWVudGF0aW9uIiwiZGlzYWJsZSIsIiRlbCIsImVuYWJsZSIsInNob3dBY3Rpdml0eSIsImNsYXNzTGlzdCIsImFkZCIsImhpZGVBY3Rpdml0eSIsInJlbW92ZSIsIndhdGNoIiwiQnRuQWN0aXZpdHkiLCJmYWRlIiwic2hvdyIsImFuaW1hdGlvbiIsImRlZmF1dCIsInRhcmdldCIsIkVsZW1lbnQiLCJ0cmlnZ2VyIiwiQXJyYXkiLCJpbml0aWFsaXplVHJpZ2dlciIsIl9pc1N0cmluZyIsInNwbGl0IiwidG9nZ2xlIiwiaW5pdGlhbGl6ZVRyaWdnZXJzIiwicXVlcnlTZWxlY3RvckFsbCIsImZvckVhY2giLCIkbmV4dFRpY2siLCJpc1Nob3dpbmciLCJmb2N1cyIsIm9wZW4iLCJpc0Rpc3BsYXlpbmciLCJ0aGVuIiwiY2xvc2UiLCJ0cmlnZ2VyYWJsZUNsYXNzZXMiLCJtb3VudGVkIiwiZGF0YSIsIk1vZGFsQm9keSIsIk1vZGFsQmFja2Ryb3AiLCJNb2RhbENvbnRlbnQiLCJNb2RhbERpYWxvZyIsIk1vZGFsSGVhZGVyIiwiTW9kYWxGb290ZXIiLCJUcmlnZ2VyYWJsZSIsImJhY2tkcm9wIiwiZmx1c2giLCJva0xhYmVsIiwiY2FuY2VsTGFiZWwiLCJ0aXRsZSIsImNhbmNlbCIsImNvbmZpcm0iLCJvbkVzYyIsImJhY2tkcm9wQ29tcG9uZW50IiwiYmVmb3JlUm91dGVMZWF2ZSIsImZyb20iLCJuZXh0IiwibW9kYWwiLCJNb2RhbCIsImluc3RhbnRpYXRlIiwiQ29tcG9uZW50IiwiZXh0ZW5kIiwidGV4dCIsImZ1bmN0aW9uYWwiLCJoIiwiY29udGV4dCIsIl92IiwicHJvdG90eXBlIiwiJG1vZGFsIiwiJGNvbnRlbnQiLCJjb250ZW50IiwiJHNsb3RzIiwiJG1vdW50IiwiX3Zub2RlIiwiYm9keSIsIiRhbGVydCIsIl9kZWZhdWx0c0RlZXAiLCJwcm9wc0RhdGEiLCIkb24iLCIkY29uZmlybSIsIiRwcm9tcHQiLCJwcmVkaWNhdGUiLCJzdWNjZWVkIiwiZmFpbCIsInN1Y2Nlc3MiLCJDb250YWluZXIiLCJPdmVybGF5Qm9keSIsIk92ZXJsYXlDb250ZW50IiwiYmFja2dyb3VuZCIsImZpeGVkQ29udGVudCIsImhpZGVDbG9zZUJ1dHRvbiIsIm9uQ2xpY2tDbG9zZSIsIk92ZXJsYXkiLCIkb3ZlcmxheSIsIm92ZXJsYXkiLCJkZWZpbmVQcm9wZXJ0eSIsImJvdW5kYXJ5IiwiY29udGFpbmVyIiwiZmFsbGJhY2tQbGFjZW1lbnQiLCJvZmZzZXQiLCJwbGFjZW1lbnQiLCJGdW5jdGlvbiIsInNlbGVjdG9yIiwiYWxpZ24iLCIkcG9wcGVycyIsInBvcHBlciIsInVwZGF0ZSIsImNyZWF0ZVBvcHBlciIsIlBvcHBlciIsIm1vZGlmaWVycyIsImZsaXAiLCJib3VuZGFyaWVzRWxlbWVudCIsImJlaGF2aW9yIiwiZW5hYmxlZCIsImFycm93IiwiZ2V0QXJyb3dFbGVtZW50IiwiYmVmb3JlQ3JlYXRlIiwidGFnIiwiUG9wb3ZlciIsIlBvcG92ZXJCb2R5IiwiUG9wb3ZlckhlYWRlciIsIiRwb3BvdmVyIiwicG9wb3ZlciIsInJlcXVpcmVkIiwic3RyaXBlZCIsIm1pbiIsIm1heCIsIm9mZnNldFZhbHVlIiwiZm9ybWF0dGVkSGVpZ2h0IiwicHJvZ3Jlc3NDbGFzc2VzIiwic3R5bGVzIiwiUHJvZ3Jlc3NCYXIiLCJBbGVydENsb3NlIiwiQWxlcnRIZWFkaW5nIiwiZGlzbWlzc2libGUiLCJoZWFkaW5nIiwiZGlzbWlzcyIsImlzVmlzaWJsZSIsImRpc21pc3NDb3VudCIsImludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwiQWxlcnQiLCJBbGVydExpbmsiLCJhY2Nlc3NpYmlsaXR5IiwicGlsbCIsInNlY29uZGFyeSIsIkJhZGdlIiwicnNBc3RyYWwiLCJyc1N5bWJvbCIsInJlVW5pY29kZSIsInN5bWJvbFZhbHVlT2YiLCJmbG9hdDMyVGFnIiwiZmxvYXQ2NFRhZyIsImludDhUYWciLCJpbnQxNlRhZyIsImludDMyVGFnIiwidWludDhUYWciLCJ1aW50OENsYW1wZWRUYWciLCJ1aW50MTZUYWciLCJ1aW50MzJUYWciLCJnZW5UYWciLCJDTE9ORV9ERUVQX0ZMQUciLCJDTE9ORV9TWU1CT0xTX0ZMQUciLCJuYXRpdmVNYXgiLCJXUkFQX0JJTkRfRkxBRyIsIldSQVBfQklORF9LRVlfRkxBRyIsIldSQVBfQ1VSUllfRkxBRyIsIldSQVBfUEFSVElBTF9GTEFHIiwiV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUciLCJXUkFQX0NVUlJZX1JJR0hUX0ZMQUciLCJXUkFQX0FSWV9GTEFHIiwiV1JBUF9GTElQX0ZMQUciLCJQTEFDRUhPTERFUiIsIldSQVBfQ1VSUllfQk9VTkRfRkxBRyIsIldSQVBfUkVBUkdfRkxBRyIsIm5hdGl2ZU1pbiIsInJlc3BvbnNlVHlwZSIsInRyYW5zZm9ybVJlcXVlc3QiLCJ0cmFuc2Zvcm1SZXNwb25zZSIsInRyYW5zZm9ybWVyIiwiRXJyb3IiLCJSZXF1ZXN0T3B0aW9ucyIsInB1c2giLCJQUk9YWV9PUFRJT05fUFJPUEVSVElFUyIsIlBST1hZX09QVElPTl9NRVRIT0RTIiwiZ2V0IiwicHJvcCIsInNldCIsIm1lcmdlIiwidmFsdWVzIiwibWV0aG9kIiwiYWN0aW9uIiwiY2hhaW5hYmxlIiwiRm9ybURhdGEiLCJhcmdzIiwiaXRlbXMiLCJzcGxpY2UiLCJfZmlyc3QiLCJpIiwiX21lcmdlV2l0aCIsImNvbmNhdCIsIlJlcXVlc3QiLCJoZWFkZXJzIiwicGFyYW1zIiwiX2Nsb25lRGVlcCIsImNhbmNlbFRva2VuIiwiYXhpb3MiLCJDYW5jZWxUb2tlbiIsIiRjYW5jZWwiLCJfYmluZCIsInJlc2V0IiwiJGVycm9yIiwiJHN0YXR1cyIsIiRzdGF0dXNUZXh0IiwiJHJlc3BvbnNlIiwiJHJlcXVlc3RTZW50QXQiLCIkcmVzcG9uc2VSZWNlaXZlZEF0IiwiaGFzUmVzcG9uc2UiLCJzZW5kIiwiYWRkT3B0aW9uIiwicmVzcG9uc2UiLCJzdGF0dXMiLCJzdGF0dXNUZXh0IiwiZXJyb3IiLCJpbnRlcmNlcHRvcnMiLCJyZXF1ZXN0Iiwib3B0aW9uIiwiTW9kZWwiLCIkcmVxdWVzdCIsIiRrZXkiLCIkZmlsZXMiLCJmaWxlcyIsIiRwcm9wZXJ0aWVzIiwicHJvcGVydGllcyIsImluaXRpYWxpemUiLCIkZXhpc3RzIiwiJGNoYW5nZWQiLCIkYXR0cmlidXRlcyIsImZpbGwiLCIkaW5pdGlhbGl6ZWQiLCJlbmRwb2ludCIsImV4aXN0cyIsImlkIiwic2V0QXR0cmlidXRlcyIsImdldEF0dHJpYnV0ZXMiLCJnZXRBdHRyaWJ1dGUiLCJ1bmRlZmluZWQiLCJfa2V5cyIsImhhbmRsZUF0dHJpYnV0ZUNoYW5nZSIsIl9zaXplIiwiY291bnQiLCJ0b3RhbCIsIl9yZWR1Y2UiLCJjYXJyeSIsIkZpbGUiLCJGaWxlTGlzdCIsInRvSlNPTiIsImhhbmRsZVByaW1hcnlLZXlDaGFuZ2UiLCJjb25maWciLCJjcmVhdGUiLCJoYXNGaWxlcyIsInRvSnNvbiIsInRvRm9ybURhdGEiLCJjb25zdHJ1Y3RvciIsInVyaSIsImFzc2lnbiIsInBvc3QiLCJkZWxldGUiLCJmb3JtIiwiaXRlbSIsIkpTT04iLCJzdHJpbmdpZnkiLCJfcGlja0J5IiwibGVuZ3RoIiwibW9kZWwiLCJtYXAiLCJlcnJvcnMiLCJpbmxpbmUiLCJub3ZhbGlkYXRlIiwicXVlcnkiLCJyZWRpcmVjdCIsIm9uU3VibWl0Iiwic3VibWl0Iiwib25TdWJtaXRTdWNjZXNzIiwiJHJvdXRlciIsIm9uU3VibWl0RmFpbGVkIiwib25VcGxvYWRQcm9ncmVzcyIsIkJhc2VGb3JtIiwiQnJlYWRjcnVtYkl0ZW0iLCJCcmVhZGNydW1iIiwic3JPbmx5Iiwic3JPbmx5Rm9jdXNhYmxlIiwic2NyZWVucmVhZGVyQ2xhc3NlcyIsIlNjcmVlbnJlYWRlcnMiLCJIZWxwVGV4dCIsIkZvcm1Hcm91cCIsIkZvcm1MYWJlbCIsImludmFsaWQiLCJ2YWxpZCIsIkZvcm1GZWVkYmFjayIsImF1dG9jb21wbGV0ZSIsInBsYWNlaG9sZGVyIiwiZ3JvdXAiLCJwYXR0ZXJuIiwiZmVlZGJhY2siLCJiaW5kRXZlbnRzIiwiZGVmYXVsdENvbnRyb2xDbGFzcyIsImhpZGVMYWJlbCIsInNwYWNpbmciLCJwbGFpbnRleHQiLCJyZWFkb25seSIsImhlbHBUZXh0IiwibWF4bGVuZ3RoIiwiYmluZCIsImJpbmRpbmciLCJ2bm9kZSIsImV2ZW50cyIsImJsdXIiLCJnZXRJbnB1dEZpZWxkIiwiZ2V0RmllbGRFcnJvcnMiLCJjYWxsYmFja3MiLCJpbnZhbGlkRmVlZGJhY2siLCJ2YWxpZEZlZWRiYWNrIiwiY29udHJvbENsYXNzIiwiY29udHJvbFNpemVDbGFzcyIsImNvbnRyb2xDbGFzc2VzIiwiaGFzRGVmYXVsdFNsb3QiLCJGb3JtQ29udHJvbCIsIklucHV0RmllbGQiLCJleHRlbnNpb25zIiwibXVsdGlwbGUiLCJGaWxlRmllbGQiLCJCdG5GaWxlIiwiYnV0dG9ucyIsInZlcnRpY2FsIiwiQnRuR3JvdXAiLCJCdG5Hcm91cFRvZ2dsZSIsIkJ0blRvb2xiYXIiLCJ1dWlkIiwiciIsIk1hdGgiLCJyYW5kb20iLCJ2IiwiYyIsInRvU3RyaW5nIiwicHJveHkiLCJwcmV2ZW50RGVmYXVsdCIsIlByb3h5IiwiYnV0dG9uIiwiaGVhZGVyIiwiRHJvcGRvd25NZW51SXRlbSIsIkRyb3Bkb3duTWVudUhlYWRlciIsIkRyb3Bkb3duTWVudURpdmlkZXIiLCJ0b0xvd2VyQ2FzZSIsIm9uSXRlbUNsaWNrIiwiJGNoaWxkcmVuIiwiY2hpbGQiLCJEcm9wZG93bk1lbnUiLCJUQUJfS0VZQ09ERSIsIkxFRlRfQVJST1dfS0VZQ09ERSIsIlJJR0hUX0FSUk9XX0tFWUNPREUiLCJVUF9BUlJPV19LRVlDT0RFIiwiRE9XTl9BUlJPV19LRVlDT0RFIiwiaWdub3JlQmx1ckV2ZW50IiwiYXV0b2Nsb3NlIiwiZHJvcHVwIiwiZHJvcHJpZ2h0IiwiZHJvcGxlZnQiLCJxdWVyeUZvY3VzYWJsZSIsImlzRm9jdXNhYmxlIiwiaXNEcm9wZG93blNob3dpbmciLCJoaWRlIiwic2lkZSIsIm1lbnUiLCJwb3NpdGlvbiIsIm9uQmx1ciIsImNvbnRhaW5zIiwicmVsYXRlZFRhcmdldCIsIm9uTWVudUNsaWNrIiwiYWN0aW9uQ2xhc3NlcyIsInRvZ2dsZUNsYXNzZXMiLCJrZXlkb3duIiwiaWdub3JlIiwia2V5Q29kZSIsIm1vdXNlZG93biIsIkJ0bkRyb3Bkb3duIiwiZ2V0U2xvdCIsInNsb3QiLCJoYXNTbG90IiwiaGFzU2xvdHMiLCJzbG90cyIsIkhhc1Nsb3RzIiwiY2xhc3NOYW1lIiwiQ2FyZCIsIkNhcmRIZWFkZXIiLCJhbHQiLCJ0ZXh0VHJ1bmNhdGUiLCJzcmMiLCJDYXJkSW1nIiwiQ2FyZEJvZHkiLCJDYXJkQnRuR3JvdXAiLCJDYXJkRGVjayIsIkNhcmRGb290ZXIiLCJDYXJkSW1nVG9wIiwiQ2FyZEltZ0JvdHRvbSIsIkNhcmRJbWdPdmVybGF5IiwiQ2FyZExpbmsiLCJDYXJkU3VidGl0bGUiLCJDYXJkVGl0bGUiLCJjdXN0b20iLCJjaGVja2VkIiwiY2hlY2tlZFZhbHVlIiwibGFiZWxDbGFzcyIsImlucHV0Q2xhc3MiLCJpbmxpbmVDbGFzcyIsImN1c3RvbUNvbnRyb2xDbGFzcyIsIlJhZGlvRmllbGQiLCJjaGVja2VkVmFsdWVzIiwiaW5kZXgiLCJDaGVja2JveEZpZWxkIiwib25Ecm9wIiwiaXNEcmFnZ2luZyIsIm9uRHJhZ292ZXIiLCJvbkRyYWdlbnRlciIsIm9uRHJhZ2xlYXZlIiwiRHJvcHpvbmUiLCJyZWFkRmlsZSIsImZpbGUiLCJwcm9ncmVzcyIsInJlYWRlciIsIkZpbGVSZWFkZXIiLCJvbnByb2dyZXNzIiwib25sb2FkIiwib25lcnJvciIsIm9uYWJvcnQiLCJyZWFkQXNEYXRhVVJMIiwicmVhZHkiLCJpbnNlcnRlZCIsImhpZGVDbG9zZSIsInBvc3RlciIsIm9yaWdfZmlsZW5hbWUiLCJleHRlbnNpb24iLCJwb3AiLCJieXRlc1RvU2l6ZSIsIm1pbWUiLCJpc0ltYWdlIiwiaXNWaWRlbyIsImxhc3RNb2RpZmllZCIsImxhc3RNb2RpZmllZERhdGUiLCJzdGFydCIsImxvYWRlZCIsImxlbmd0aENvbXB1dGFibGUiLCJwYXJzZUludCIsImltYWdlIiwicmVzdWx0IiwiZGlmZiIsImJ5dGVzIiwic2l6ZXMiLCJmbG9vciIsImxvZyIsInJvdW5kIiwicG93Iiwib25Mb2FkIiwiRmlsZVByZXZpZXciLCJzZWxlY3QiLCJ0aHJlc2hvbGQiLCJzY3JvbGxJbnRvVmlld3BvcnQiLCJlbnRyeSIsInNjcm9sbE91dFZpZXdwb3J0IiwiaGVpZ2h0VW5pdCIsIkludGVyc2VjdGlvbk9ic2VydmVyIiwiZW50cmllcyIsIm9ic2VydmVyIiwiaXNJbnRlcnNlY3RpbmciLCJoYXNTY3JvbGxlZEludG9WaWV3cG9ydCIsIm9ic2VydmUiLCJJbnB1dEdyb3VwVGV4dCIsIklucHV0R3JvdXBBcHBlbmQiLCJJbnB1dEdyb3VwUHJlcGVuZCIsInByZXBlbmQiLCJJbnB1dEdyb3VwIiwiRm9ybUNvbnRyb2xNaXhpbiIsImFjdGl2ZUNsYXNzIiwib25WYWx1ZSIsIm9mZlZhbHVlIiwiaXNBY3RpdmUiLCJkcmFnZ2luZyIsImdldFRyYW5zaXRpb25Jbk1pbGxpc2Vjb25kcyIsIkxpZ2h0U3dpdGNoRmllbGQiLCJiYWRnZSIsImJhZGdlT3B0aW9ucyIsInByZXZWYWx1ZSIsIkxpc3RHcm91cEl0ZW0iLCJiaW5kRXZlbnRzVG9DaGlsZHJlbiIsIiRvZmYiLCJvbkNsaWNrSXRlbSIsInVwZGF0ZWQiLCJMaXN0R3JvdXAiLCJoMSIsImNvbGxhcHNlIiwiTmF2YmFyVG9nZ2xlckljb24iLCJleHBhbmRlZCIsIk5hdmJhckJyYW5kIiwiTmF2YmFyQ29sbGFwc2UiLCJOYXZiYXJUZXh0IiwiTmF2YmFyVG9nZ2xlciIsImV4cGFuZCIsInN0aWNreSIsImV4cGFuZGVkQ2xhc3MiLCJOYXZpZ2F0aW9uRXJyb3IiLCJpc0l0ZW0iLCIkcGFyZW50IiwiTmF2aWdhdGlvbkxpbmsiLCJsaXN0IiwiTmF2aWdhdGlvbkl0ZW0iLCJjYXJkIiwianVzdGlmaWVkIiwicGlsbHMiLCJ0YWJzIiwicm9sZSIsImlzQ2FyZCIsIk5hdmlnYXRpb24iLCJOYXZpZ2F0aW9uRHJvcGRvd24iLCJOYXZiYXIiLCJOYXZiYXJOYXYiLCJwYWdlIiwidG90YWxQYWdlcyIsInNob3dQYWdlcyIsInBhZ2luYXRlIiwiY3VycmVudFBhZ2UiLCJwcmV2IiwiY3VycmVudFRhcmdldCIsInBhcmVudE5vZGUiLCJzZXRBY3RpdmVQYWdlIiwiZ2VuZXJhdGUiLCJwYWdlcyIsInN0YXJ0UGFnZSIsInN0YXJ0T2Zmc2V0IiwiZW5kUGFnZSIsImRpdmlkZXIiLCJQYWdpbmF0aW9uIiwiQ1VTVE9NX1NFTEVDVF9QUkVGSVgiLCJjdXN0b21TZWxlY3RDbGFzc2VzIiwiY3VzdG9tU2VsZWN0U2l6ZUNsYXNzIiwiU2VsZWN0RmllbGQiLCJmaW5kSW5kZXgiLCJvbGRWYWx1ZSIsImxhc3RTbGlkZSIsImN1cnJlbnRTbGlkZSIsInNsaWRlcyIsInNsaWRlIiwiZmluZFNsaWRlQnlLZXkiLCJmaW5kU2xpZGVCeUluZGV4IiwiZ2V0U2xpZGVJbmRleCIsIl9maW5kSW5kZXgiLCJTbGlkZXMiLCJTbGlkZURlY2tDb250cm9scyIsImNvbnRyb2xzIiwiZmxleCIsIm92ZXJmbG93IiwicmVzaXplTW9kZSIsImRpcmVjdGlvbiIsIiRyZWZzIiwicmVzaXplIiwibWFyZ2luTGVmdCIsIm1hcmdpblJpZ2h0IiwibWFyZ2luVG9wIiwibWFyZ2luQm90dG9tIiwib25DbGlja0NvbnRyb2wiLCJvblNsaWRlQWZ0ZXJFbnRlciIsIm9uU2xpZGVCZWZvcmVFbnRlciIsIm9uU2xpZGVFbnRlciIsImRvbmUiLCJvblNsaWRlQWZ0ZXJMZWF2ZSIsIm9uU2xpZGVCZWZvcmVMZWF2ZSIsIm9uU2xpZGVMZWF2ZSIsIm92ZXJmbG93RWxlbWVudCIsImVsbSIsIlNsaWRlRGVjayIsIlRhYmxlVmlld0hlYWRlciIsImNvbHVtbnMiLCJob3ZlciIsImxvYWRpbmciLCJlbGVtZW50cyIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInRhYmxlQ29sdW1ucyIsImNvbHVtbiIsIlRyYW5zZm9ybWVyIiwiJG9yaWdpbmFsUmVzcG9uc2UiLCIkcmVxdWlyZWQiLCIkdHJhbnNmb3JtZWRSZXNwb25zZSIsInRyYW5zZm9ybSIsIlRhYmxlVmlld1RyYW5zZm9ybWVyIiwiRGF0YVRhYmxlIiwibGltaXQiLCJvcmRlciIsInNvcnQiLCJkZXNjcmlwdGlvbiIsIm9yZGVyQnkiLCJkZWZhdWx0U29ydCIsImN1cnJlbnRTb3J0IiwiZ2V0UmVxdWVzdFBhcmFtIiwiY3VycmVudE9yZGVyIiwiYWRkUmVxdWVzdFBhcmFtIiwiZmV0Y2giLCJnZXRSZXF1ZXN0SGVhZGVyIiwiYWRkUmVxdWVzdEhlYWRlciIsIm9uUGFnaW5hdGUiLCIkYXR0cnMiLCJiZWZvcmVEZXN0cm95IiwiVGFibGVWaWV3Iiwicm93cyIsIlRleHRhcmVhRmllbGQiLCJmbHVpZCIsIlRodW1ibmFpbExpc3RJdGVtIiwibm9GbGV4IiwiZ3JpZCIsIndyYXAiLCJpbWFnZXMiLCJUaHVtYm5haWxMaXN0IiwiYXJyYXlQcm90byIsIm1heFVwbG9hZHMiLCJkcm9wem9uZU1pbkhlaWdodCIsImRyb3B6b25lIiwicmVtb3ZlRmlsZSIsImFkZEZpbGUiLCJ1cGxvYWQiLCJhZGRGaWxlcyIsIiRzZXQiLCJwcm9ncmVzc0JhcnMiLCJzYXZlIiwiZ2V0UmVxdWVzdCIsIm9uQ2hhbmdlIiwiZGF0YVRyYW5zZmVyIiwib25EcmFnT3ZlciIsImlzRHJhZ2dpbmdJbnNpZGUiLCJvbkRyYWdFbnRlciIsIm9uRHJhZ0xlYXZlIiwic2hvd0Ryb3BFbGVtZW50IiwiVXBsb2FkRmllbGQiLCJmaW5kIiwiYmFja0J1dHRvbiIsImZpbmlzaEJ1dHRvbiIsIm5leHRCdXR0b24iLCJzdGVwcyIsIm9uQ2xpY2tCYWNrIiwib25DbGlja0ZpbmlzaCIsIm9uQ2xpY2tOZXh0IiwiY2hlY2tWYWxpZGl0eSIsIndpemFyZCIsInBlcmZvcm1WYWxpZGl0eUNoZWNrcyIsImVuYWJsZUJhY2tCdXR0b24iLCJkaXNhYmxlQmFja0J1dHRvbiIsImRpc2FibGVOZXh0QnV0dG9uIiwiZGlzYWJsZUZpbmlzaEJ1dHRvbiIsImVuYWJsZU5leHRCdXR0b24iLCJlbmFibGVGaW5pc2hCdXR0b24iLCJXaXphcmRTdGVwIiwiaGlnaGVzdFN0ZXAiLCJzdGVwIiwiV2l6YXJkQnV0dG9ucyIsIldpemFyZEVycm9yIiwiV2l6YXJkSGVhZGVyIiwiV2l6YXJkUHJvZ3Jlc3MiLCJXaXphcmRTdWNjZXNzIiwiY29tcGxldGVkIiwiY3VycmVudFN0ZXAiLCJiYWNrIiwiZGlzYWJsZUJ1dHRvbnMiLCJpc0JhY2tCdXR0b25EaXNhYmxlZCIsImlzRmluaXNoQnV0dG9uRGlzYWJsZWQiLCJpc05leHRCdXR0b25EaXNhYmxlZCIsImVtaXRCdWJibGVFdmVudCIsInNsaWRlRGVjayIsImNvbXBvbmVudEluc3RhbmNlIiwiZW5hYmxlQnV0dG9ucyIsImZpbmlzaCIsImhhc0ZhaWxlZCIsImlzRmluaXNoZWQiLCJfZmluZCIsIm9uQmVmb3JlRW50ZXIiLCJvbkNsaWNrVGVzdCIsImRlZmF1bHRQcmV2ZW50ZWQiLCJvbkVudGVyIiwib25MZWF2ZSIsIm9uUHJvZ3Jlc3NDbGljayIsIldpemFyZCIsIlNUWUxFX0FUVFJJQlVURVMiLCJpbnQiLCJzdHIiLCJpbnB1dCIsImRpdiIsImlubmVySFRNTCIsImF0dHIiLCJkeW5hbWljSGVpZ2h0IiwibWltaWMiLCJib3R0b20iLCJ6SW5kZXgiLCJ2aXNpYmlsaXR5IiwiaW5pdCIsInRhZ05hbWUiLCIkY29sbGFwc2VkSGVpZ2h0IiwiX2dldCIsImV4cHJlc3Npb24iLCJlZGl0YWJsZSIsImRpc3BhdGNoRXZlbnQiLCJFdmVudCIsIiR3YXRjaCIsIklucHV0RXZlbnQiLCJyZWR1Y2UiLCJvIiwiYmxvYiIsInhociIsIlhNTEh0dHBSZXF1ZXN0IiwiZWxhcHNlZCIsImVsYXBzZWRDYWxsYmFjayIsImhhc0VsYXBzZWQiLCJzdG9wIiwiY2xlYXJUaW1lb3V0IiwicHJvbWlzZSIsInJlc29sdmVyIiwiX3dyYXAiLCJmaW5hbGx5IiwiZWFzaW5ncyIsImxpbmVhciIsInQiLCJlYXNlSW5RdWFkIiwiZWFzZU91dFF1YWQiLCJlYXNlSW5PdXRRdWFkIiwiZWFzZUluQ3ViaWMiLCJlYXNlT3V0Q3ViaWMiLCJlYXNlSW5PdXRDdWJpYyIsImVhc2VJblF1YXJ0IiwiZWFzZU91dFF1YXJ0IiwiZWFzZUluT3V0UXVhcnQiLCJlYXNlSW5RdWludCIsImVhc2VPdXRRdWludCIsImVhc2VJbk91dFF1aW50Iiwic2Nyb2xsVG8iLCJkZXN0aW5hdGlvbiIsImVhc2luZyIsInZpZXdwb3J0Iiwidmlld3BvcnRCb3VuZHMiLCJkZXN0aW5hdGlvbkJvdW5kcyIsImRlc3RpbmF0aW9uT2Zmc2V0VG9TY3JvbGwiLCJjZWlsIiwidG9wIiwiZG9jdW1lbnRFbGVtZW50Iiwic2Nyb2xsVG9wIiwiaXNTY3JvbGxCb3R0b20iLCJpbm5lckhlaWdodCIsInN0YXJ0VGltZSIsInBlcmZvcm1hbmNlIiwibm93IiwiaXNTdGFydGluZ0JvdHRvbSIsInNjcm9sbCIsInRpbWUiLCJ0aW1lRnVuY3Rpb24iLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJDQUxMQkFDS1MiLCJfZmluZEtleSIsImNvbXBhcmUiLCJyZXN0YXJ0Iiwid2FpdCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0lBRWUscUJBQVNBLEtBQVQsRUFBZ0JDLE1BQWhCLEVBQXdCO0lBQ25DLE1BQUdELEtBQUgsRUFBVTtJQUNOLFdBQU9FLE9BQU9DLE9BQU9ILEtBQVAsQ0FBUCxFQUFzQkMsTUFBdEIsQ0FBNkJBLE1BQTdCLENBQVA7SUFDSDs7SUFFRCxTQUFPLEVBQVA7SUFDSDs7SUNOYyx1QkFBU0QsS0FBVCxFQUFnQkMsTUFBaEIsRUFBd0I7SUFDbkMsU0FBT0QsUUFBUUUsT0FBT0MsT0FBT0gsS0FBUCxDQUFQLENBQVIsR0FB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SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxXQUFXLENBQUMsS0FBSyxFQUFFO0lBQzVCLEVBQUUsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNsQyxDQUFDOztJQ1BEO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLFFBQVEsQ0FBQyxNQUFNLEVBQUU7SUFDMUIsRUFBRSxJQUFJLEtBQUssR0FBRyxDQUFDLENBQUM7SUFDaEIsTUFBTSxNQUFNLEdBQUcsTUFBTSxJQUFJLElBQUksR0FBRyxDQUFDLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQzs7SUFFbEQsRUFBRSxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksUUFBUSxDQUFDO0lBQy9CLEVBQUUsT0FBTyxFQUFFLEtBQUssR0FBRyxNQUFNLEVBQUU7SUFDM0IsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBQzVCLEdBQUc7SUFDSCxDQUFDOztJQUVEO0lBQ0EsUUFBUSxDQUFDLFNBQVMsQ0FBQyxHQUFHLEdBQUcsUUFBUSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEdBQUcsV0FBVyxDQUFDO0lBQy9ELFFBQVEsQ0FBQyxTQUFTLENBQUMsR0FBRyxHQUFHLFdBQVcsQ0FBQzs7SUN4QnJDO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxTQUFTLENBQUMsS0FBSyxFQUFFLFNBQVMsRUFBRTtJQUNyQyxFQUFFLElBQUksS0FBSyxHQUFHLENBQUMsQ0FBQztJQUNoQixNQUFNLE1BQU0sR0FBRyxLQUFLLElBQUksSUFBSSxHQUFHLENBQUMsR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDOztJQUVoRCxFQUFFLE9BQU8sRUFBRSxLQUFLLEdBQUcsTUFBTSxFQUFFO0lBQzNCLElBQUksSUFBSSxTQUFTLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxFQUFFLEtBQUssRUFBRSxLQUFLLENBQUMsRUFBRTtJQUMvQyxNQUFNLE9BQU8sSUFBSSxDQUFDO0lBQ2xCLEtBQUs7SUFDTCxHQUFHO0lBQ0gsRUFBRSxPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7O0lDcEJEO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLFFBQVEsQ0FBQyxLQUFLLEVBQUUsR0FBRyxFQUFFO0lBQzlCLEVBQUUsT0FBTyxLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3hCLENBQUM7O0lDTkQ7SUFDQSxJQUFJLG9CQUFvQixHQUFHLENBQUM7SUFDNUIsSUFBSSxzQkFBc0IsR0FBRyxDQUFDLENBQUM7O0lBRS9CO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxXQUFXLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUUsVUFBVSxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUU7SUFDMUUsRUFBRSxJQUFJLFNBQVMsR0FBRyxPQUFPLEdBQUcsb0JBQW9CO0lBQ2hELE1BQU0sU0FBUyxHQUFHLEtBQUssQ0FBQyxNQUFNO0lBQzlCLE1BQU0sU0FBUyxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUM7O0lBRS9CLEVBQUUsSUFBSSxTQUFTLElBQUksU0FBUyxJQUFJLEVBQUUsU0FBUyxJQUFJLFNBQVMsR0FBRyxTQUFTLENBQUMsRUFBRTtJQUN2RSxJQUFJLE9BQU8sS0FBSyxDQUFDO0lBQ2pCLEdBQUc7SUFDSDtJQUNBLEVBQUUsSUFBSSxPQUFPLEdBQUcsS0FBSyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNqQyxFQUFFLElBQUksT0FBTyxJQUFJLEtBQUssQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEVBQUU7SUFDbkMsSUFBSSxPQUFPLE9BQU8sSUFBSSxLQUFLLENBQUM7SUFDNUIsR0FBRztJQUNILEVBQUUsSUFBSSxLQUFLLEdBQUcsQ0FBQyxDQUFDO0lBQ2hCLE1BQU0sTUFBTSxHQUFHLElBQUk7SUFDbkIsTUFBTSxJQUFJLEdBQUcsQ0FBQyxPQUFPLEdBQUcsc0JBQXNCLElBQUksSUFBSSxRQUFRLEdBQUcsU0FBUyxDQUFDOztJQUUzRSxFQUFFLEtBQUssQ0FBQyxHQUFHLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQzFCLEVBQUUsS0FBSyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUM7O0lBRTFCO0lBQ0EsRUFBRSxPQUFPLEVBQUUsS0FBSyxHQUFHLFNBQVMsRUFBRTtJQUM5QixJQUFJLElBQUksUUFBUSxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUM7SUFDL0IsUUFBUSxRQUFRLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDOztJQUVoQyxJQUFJLElBQUksVUFBVSxFQUFFO0lBQ3BCLE1BQU0sSUFBSSxRQUFRLEdBQUcsU0FBUztJQUM5QixVQUFVLFVBQVUsQ0FBQyxRQUFRLEVBQUUsUUFBUSxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssQ0FBQztJQUNwRSxVQUFVLFVBQVUsQ0FBQyxRQUFRLEVBQUUsUUFBUSxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQ3JFLEtBQUs7SUFDTCxJQUFJLElBQUksUUFBUSxLQUFLLFNBQVMsRUFBRTtJQUNoQyxNQUFNLElBQUksUUFBUSxFQUFFO0lBQ3BCLFFBQVEsU0FBUztJQUNqQixPQUFPO0lBQ1AsTUFBTSxNQUFNLEdBQUcsS0FBSyxDQUFDO0lBQ3JCLE1BQU0sTUFBTTtJQUNaLEtBQUs7SUFDTDtJQUNBLElBQUksSUFBSSxJQUFJLEVBQUU7SUFDZCxNQUFNLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxFQUFFLFNBQVMsUUFBUSxFQUFFLFFBQVEsRUFBRTtJQUN6RCxZQUFZLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLFFBQVEsQ0FBQztJQUN6QyxpQkFBaUIsUUFBUSxLQUFLLFFBQVEsSUFBSSxTQUFTLENBQUMsUUFBUSxFQUFFLFFBQVEsRUFBRSxPQUFPLEVBQUUsVUFBVSxFQUFFLEtBQUssQ0FBQyxDQUFDLEVBQUU7SUFDdEcsY0FBYyxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDekMsYUFBYTtJQUNiLFdBQVcsQ0FBQyxFQUFFO0lBQ2QsUUFBUSxNQUFNLEdBQUcsS0FBSyxDQUFDO0lBQ3ZCLFFBQVEsTUFBTTtJQUNkLE9BQU87SUFDUCxLQUFLLE1BQU0sSUFBSTtJQUNmLFVBQVUsUUFBUSxLQUFLLFFBQVE7SUFDL0IsWUFBWSxTQUFTLENBQUMsUUFBUSxFQUFFLFFBQVEsRUFBRSxPQUFPLEVBQUUsVUFBVSxFQUFFLEtBQUssQ0FBQztJQUNyRSxTQUFTLEVBQUU7SUFDWCxNQUFNLE1BQU0sR0FBRyxLQUFLLENBQUM7SUFDckIsTUFBTSxNQUFNO0lBQ1osS0FBSztJQUNMLEdBQUc7SUFDSCxFQUFFLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN6QixFQUFFLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN6QixFQUFFLE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUM7O0lDaEZEO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxVQUFVLENBQUMsR0FBRyxFQUFFO0lBQ3pCLEVBQUUsSUFBSSxLQUFLLEdBQUcsQ0FBQyxDQUFDO0lBQ2hCLE1BQU0sTUFBTSxHQUFHLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7O0lBRS9CLEVBQUUsR0FBRyxDQUFDLE9BQU8sQ0FBQyxTQUFTLEtBQUssRUFBRSxHQUFHLEVBQUU7SUFDbkMsSUFBSSxNQUFNLENBQUMsRUFBRSxLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsQ0FBQztJQUNuQyxHQUFHLENBQUMsQ0FBQztJQUNMLEVBQUUsT0FBTyxNQUFNLENBQUM7SUFDaEIsQ0FBQzs7SUNmRDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsVUFBVSxDQUFDLEdBQUcsRUFBRTtJQUN6QixFQUFFLElBQUksS0FBSyxHQUFHLENBQUMsQ0FBQztJQUNoQixNQUFNLE1BQU0sR0FBRyxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDOztJQUUvQixFQUFFLEdBQUcsQ0FBQyxPQUFPLENBQUMsU0FBUyxLQUFLLEVBQUU7SUFDOUIsSUFBSSxNQUFNLENBQUMsRUFBRSxLQUFLLENBQUMsR0FBRyxLQUFLLENBQUM7SUFDNUIsR0FBRyxDQUFDLENBQUM7SUFDTCxFQUFFLE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUM7O0lDUkQ7SUFDQSxJQUFJVyxzQkFBb0IsR0FBRyxDQUFDO0lBQzVCLElBQUlDLHdCQUFzQixHQUFHLENBQUMsQ0FBQzs7SUFFL0I7SUFDQSxJQUFJRixTQUFPLEdBQUcsa0JBQWtCO0lBQ2hDLElBQUlHLFNBQU8sR0FBRyxlQUFlO0lBQzdCLElBQUlDLFVBQVEsR0FBRyxnQkFBZ0I7SUFDL0IsSUFBSUMsUUFBTSxHQUFHLGNBQWM7SUFDM0IsSUFBSUMsV0FBUyxHQUFHLGlCQUFpQjtJQUNqQyxJQUFJQyxXQUFTLEdBQUcsaUJBQWlCO0lBQ2pDLElBQUlDLFFBQU0sR0FBRyxjQUFjO0lBQzNCLElBQUlDLFdBQVMsR0FBRyxpQkFBaUI7SUFDakMsSUFBSSxTQUFTLEdBQUcsaUJBQWlCLENBQUM7O0lBRWxDLElBQUlDLGdCQUFjLEdBQUcsc0JBQXNCO0lBQzNDLElBQUlDLGFBQVcsR0FBRyxtQkFBbUIsQ0FBQzs7SUFFdEM7SUFDQSxJQUFJLFdBQVcsR0FBRzlCLFFBQU0sR0FBR0EsUUFBTSxDQUFDLFNBQVMsR0FBRyxTQUFTO0lBQ3ZELElBQUksYUFBYSxHQUFHLFdBQVcsR0FBRyxXQUFXLENBQUMsT0FBTyxHQUFHLFNBQVMsQ0FBQzs7SUFFbEU7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsVUFBVSxDQUFDLE1BQU0sRUFBRSxLQUFLLEVBQUUsR0FBRyxFQUFFLE9BQU8sRUFBRSxVQUFVLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRTtJQUMvRSxFQUFFLFFBQVEsR0FBRztJQUNiLElBQUksS0FBSzhCLGFBQVc7SUFDcEIsTUFBTSxJQUFJLENBQUMsTUFBTSxDQUFDLFVBQVUsSUFBSSxLQUFLLENBQUMsVUFBVTtJQUNoRCxXQUFXLE1BQU0sQ0FBQyxVQUFVLElBQUksS0FBSyxDQUFDLFVBQVUsQ0FBQyxFQUFFO0lBQ25ELFFBQVEsT0FBTyxLQUFLLENBQUM7SUFDckIsT0FBTztJQUNQLE1BQU0sTUFBTSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUM7SUFDN0IsTUFBTSxLQUFLLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQzs7SUFFM0IsSUFBSSxLQUFLRCxnQkFBYztJQUN2QixNQUFNLElBQUksQ0FBQyxNQUFNLENBQUMsVUFBVSxJQUFJLEtBQUssQ0FBQyxVQUFVO0lBQ2hELFVBQVUsQ0FBQyxTQUFTLENBQUMsSUFBSSxVQUFVLENBQUMsTUFBTSxDQUFDLEVBQUUsSUFBSSxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRTtJQUNyRSxRQUFRLE9BQU8sS0FBSyxDQUFDO0lBQ3JCLE9BQU87SUFDUCxNQUFNLE9BQU8sSUFBSSxDQUFDOztJQUVsQixJQUFJLEtBQUtWLFNBQU8sQ0FBQztJQUNqQixJQUFJLEtBQUtHLFNBQU8sQ0FBQztJQUNqQixJQUFJLEtBQUtHLFdBQVM7SUFDbEI7SUFDQTtJQUNBLE1BQU0sT0FBTyxFQUFFLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQzs7SUFFakMsSUFBSSxLQUFLRixVQUFRO0lBQ2pCLE1BQU0sT0FBTyxNQUFNLENBQUMsSUFBSSxJQUFJLEtBQUssQ0FBQyxJQUFJLElBQUksTUFBTSxDQUFDLE9BQU8sSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDOztJQUUxRSxJQUFJLEtBQUtHLFdBQVMsQ0FBQztJQUNuQixJQUFJLEtBQUtFLFdBQVM7SUFDbEI7SUFDQTtJQUNBO0lBQ0EsTUFBTSxPQUFPLE1BQU0sS0FBSyxLQUFLLEdBQUcsRUFBRSxDQUFDLENBQUM7O0lBRXBDLElBQUksS0FBS0osUUFBTTtJQUNmLE1BQU0sSUFBSSxPQUFPLEdBQUcsVUFBVSxDQUFDOztJQUUvQixJQUFJLEtBQUtHLFFBQU07SUFDZixNQUFNLElBQUksU0FBUyxHQUFHLE9BQU8sR0FBR1Asc0JBQW9CLENBQUM7SUFDckQsTUFBTSxPQUFPLEtBQUssT0FBTyxHQUFHLFVBQVUsQ0FBQyxDQUFDOztJQUV4QyxNQUFNLElBQUksTUFBTSxDQUFDLElBQUksSUFBSSxLQUFLLENBQUMsSUFBSSxJQUFJLENBQUMsU0FBUyxFQUFFO0lBQ25ELFFBQVEsT0FBTyxLQUFLLENBQUM7SUFDckIsT0FBTztJQUNQO0lBQ0EsTUFBTSxJQUFJLE9BQU8sR0FBRyxLQUFLLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ3RDLE1BQU0sSUFBSSxPQUFPLEVBQUU7SUFDbkIsUUFBUSxPQUFPLE9BQU8sSUFBSSxLQUFLLENBQUM7SUFDaEMsT0FBTztJQUNQLE1BQU0sT0FBTyxJQUFJQyx3QkFBc0IsQ0FBQzs7SUFFeEM7SUFDQSxNQUFNLEtBQUssQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQy9CLE1BQU0sSUFBSSxNQUFNLEdBQUcsV0FBVyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsRUFBRSxPQUFPLENBQUMsS0FBSyxDQUFDLEVBQUUsT0FBTyxFQUFFLFVBQVUsRUFBRSxTQUFTLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFDdkcsTUFBTSxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDOUIsTUFBTSxPQUFPLE1BQU0sQ0FBQzs7SUFFcEIsSUFBSSxLQUFLLFNBQVM7SUFDbEIsTUFBTSxJQUFJLGFBQWEsRUFBRTtJQUN6QixRQUFRLE9BQU8sYUFBYSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxhQUFhLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3ZFLE9BQU87SUFDUCxHQUFHO0lBQ0gsRUFBRSxPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7O0lDN0dEO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLFNBQVMsQ0FBQyxLQUFLLEVBQUUsTUFBTSxFQUFFO0lBQ2xDLEVBQUUsSUFBSSxLQUFLLEdBQUcsQ0FBQyxDQUFDO0lBQ2hCLE1BQU0sTUFBTSxHQUFHLE1BQU0sQ0FBQyxNQUFNO0lBQzVCLE1BQU0sTUFBTSxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUM7O0lBRTVCLEVBQUUsT0FBTyxFQUFFLEtBQUssR0FBRyxNQUFNLEVBQUU7SUFDM0IsSUFBSSxLQUFLLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQyxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUMxQyxHQUFHO0lBQ0gsRUFBRSxPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7O0lDZEQ7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsY0FBYyxDQUFDLE1BQU0sRUFBRSxRQUFRLEVBQUUsV0FBVyxFQUFFO0lBQ3ZELEVBQUUsSUFBSSxNQUFNLEdBQUcsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ2hDLEVBQUUsT0FBTyxPQUFPLENBQUMsTUFBTSxDQUFDLEdBQUcsTUFBTSxHQUFHLFNBQVMsQ0FBQyxNQUFNLEVBQUUsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7SUFDM0UsQ0FBQzs7SUNqQkQ7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxXQUFXLENBQUMsS0FBSyxFQUFFLFNBQVMsRUFBRTtJQUN2QyxFQUFFLElBQUksS0FBSyxHQUFHLENBQUMsQ0FBQztJQUNoQixNQUFNLE1BQU0sR0FBRyxLQUFLLElBQUksSUFBSSxHQUFHLENBQUMsR0FBRyxLQUFLLENBQUMsTUFBTTtJQUMvQyxNQUFNLFFBQVEsR0FBRyxDQUFDO0lBQ2xCLE1BQU0sTUFBTSxHQUFHLEVBQUUsQ0FBQzs7SUFFbEIsRUFBRSxPQUFPLEVBQUUsS0FBSyxHQUFHLE1BQU0sRUFBRTtJQUMzQixJQUFJLElBQUksS0FBSyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUM3QixJQUFJLElBQUksU0FBUyxDQUFDLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxDQUFDLEVBQUU7SUFDeEMsTUFBTSxNQUFNLENBQUMsUUFBUSxFQUFFLENBQUMsR0FBRyxLQUFLLENBQUM7SUFDakMsS0FBSztJQUNMLEdBQUc7SUFDSCxFQUFFLE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUM7O0lDdEJEO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsU0FBUyxHQUFHO0lBQ3JCLEVBQUUsT0FBTyxFQUFFLENBQUM7SUFDWixDQUFDOztJQ2pCRDtJQUNBLElBQUlwQixjQUFXLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FBQzs7SUFFbkM7SUFDQSxJQUFJOEIsc0JBQW9CLEdBQUc5QixjQUFXLENBQUMsb0JBQW9CLENBQUM7O0lBRTVEO0lBQ0EsSUFBSSxnQkFBZ0IsR0FBRyxNQUFNLENBQUMscUJBQXFCLENBQUM7O0lBRXBEO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsSUFBSSxVQUFVLEdBQUcsQ0FBQyxnQkFBZ0IsR0FBRyxTQUFTLEdBQUcsU0FBUyxNQUFNLEVBQUU7SUFDbEUsRUFBRSxJQUFJLE1BQU0sSUFBSSxJQUFJLEVBQUU7SUFDdEIsSUFBSSxPQUFPLEVBQUUsQ0FBQztJQUNkLEdBQUc7SUFDSCxFQUFFLE1BQU0sR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDMUIsRUFBRSxPQUFPLFdBQVcsQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsRUFBRSxTQUFTLE1BQU0sRUFBRTtJQUNoRSxJQUFJLE9BQU84QixzQkFBb0IsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBQ3JELEdBQUcsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDOztJQ3ZCRjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsVUFBVSxDQUFDLE1BQU0sRUFBRTtJQUM1QixFQUFFLE9BQU8sY0FBYyxDQUFDLE1BQU0sRUFBRSxJQUFJLEVBQUUsVUFBVSxDQUFDLENBQUM7SUFDbEQsQ0FBQzs7SUNYRDtJQUNBLElBQUlYLHNCQUFvQixHQUFHLENBQUMsQ0FBQzs7SUFFN0I7SUFDQSxJQUFJbkIsY0FBVyxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUM7O0lBRW5DO0lBQ0EsSUFBSU0saUJBQWMsR0FBR04sY0FBVyxDQUFDLGNBQWMsQ0FBQzs7SUFFaEQ7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLFlBQVksQ0FBQyxNQUFNLEVBQUUsS0FBSyxFQUFFLE9BQU8sRUFBRSxVQUFVLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRTtJQUM1RSxFQUFFLElBQUksU0FBUyxHQUFHLE9BQU8sR0FBR21CLHNCQUFvQjtJQUNoRCxNQUFNLFFBQVEsR0FBRyxVQUFVLENBQUMsTUFBTSxDQUFDO0lBQ25DLE1BQU0sU0FBUyxHQUFHLFFBQVEsQ0FBQyxNQUFNO0lBQ2pDLE1BQU0sUUFBUSxHQUFHLFVBQVUsQ0FBQyxLQUFLLENBQUM7SUFDbEMsTUFBTSxTQUFTLEdBQUcsUUFBUSxDQUFDLE1BQU0sQ0FBQzs7SUFFbEMsRUFBRSxJQUFJLFNBQVMsSUFBSSxTQUFTLElBQUksQ0FBQyxTQUFTLEVBQUU7SUFDNUMsSUFBSSxPQUFPLEtBQUssQ0FBQztJQUNqQixHQUFHO0lBQ0gsRUFBRSxJQUFJLEtBQUssR0FBRyxTQUFTLENBQUM7SUFDeEIsRUFBRSxPQUFPLEtBQUssRUFBRSxFQUFFO0lBQ2xCLElBQUksSUFBSSxHQUFHLEdBQUcsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQzlCLElBQUksSUFBSSxFQUFFLFNBQVMsR0FBRyxHQUFHLElBQUksS0FBSyxHQUFHYixpQkFBYyxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDLENBQUMsRUFBRTtJQUN2RSxNQUFNLE9BQU8sS0FBSyxDQUFDO0lBQ25CLEtBQUs7SUFDTCxHQUFHO0lBQ0g7SUFDQSxFQUFFLElBQUksT0FBTyxHQUFHLEtBQUssQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDbEMsRUFBRSxJQUFJLE9BQU8sSUFBSSxLQUFLLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxFQUFFO0lBQ25DLElBQUksT0FBTyxPQUFPLElBQUksS0FBSyxDQUFDO0lBQzVCLEdBQUc7SUFDSCxFQUFFLElBQUksTUFBTSxHQUFHLElBQUksQ0FBQztJQUNwQixFQUFFLEtBQUssQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQzNCLEVBQUUsS0FBSyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUM7O0lBRTNCLEVBQUUsSUFBSSxRQUFRLEdBQUcsU0FBUyxDQUFDO0lBQzNCLEVBQUUsT0FBTyxFQUFFLEtBQUssR0FBRyxTQUFTLEVBQUU7SUFDOUIsSUFBSSxHQUFHLEdBQUcsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQzFCLElBQUksSUFBSSxRQUFRLEdBQUcsTUFBTSxDQUFDLEdBQUcsQ0FBQztJQUM5QixRQUFRLFFBQVEsR0FBRyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7O0lBRTlCLElBQUksSUFBSSxVQUFVLEVBQUU7SUFDcEIsTUFBTSxJQUFJLFFBQVEsR0FBRyxTQUFTO0lBQzlCLFVBQVUsVUFBVSxDQUFDLFFBQVEsRUFBRSxRQUFRLEVBQUUsR0FBRyxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsS0FBSyxDQUFDO0lBQ25FLFVBQVUsVUFBVSxDQUFDLFFBQVEsRUFBRSxRQUFRLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFDcEUsS0FBSztJQUNMO0lBQ0EsSUFBSSxJQUFJLEVBQUUsUUFBUSxLQUFLLFNBQVM7SUFDaEMsYUFBYSxRQUFRLEtBQUssUUFBUSxJQUFJLFNBQVMsQ0FBQyxRQUFRLEVBQUUsUUFBUSxFQUFFLE9BQU8sRUFBRSxVQUFVLEVBQUUsS0FBSyxDQUFDO0lBQy9GLFlBQVksUUFBUTtJQUNwQixTQUFTLEVBQUU7SUFDWCxNQUFNLE1BQU0sR0FBRyxLQUFLLENBQUM7SUFDckIsTUFBTSxNQUFNO0lBQ1osS0FBSztJQUNMLElBQUksUUFBUSxLQUFLLFFBQVEsR0FBRyxHQUFHLElBQUksYUFBYSxDQUFDLENBQUM7SUFDbEQsR0FBRztJQUNILEVBQUUsSUFBSSxNQUFNLElBQUksQ0FBQyxRQUFRLEVBQUU7SUFDM0IsSUFBSSxJQUFJLE9BQU8sR0FBRyxNQUFNLENBQUMsV0FBVztJQUNwQyxRQUFRLE9BQU8sR0FBRyxLQUFLLENBQUMsV0FBVyxDQUFDOztJQUVwQztJQUNBLElBQUksSUFBSSxPQUFPLElBQUksT0FBTztJQUMxQixTQUFTLGFBQWEsSUFBSSxNQUFNLElBQUksYUFBYSxJQUFJLEtBQUssQ0FBQztJQUMzRCxRQUFRLEVBQUUsT0FBTyxPQUFPLElBQUksVUFBVSxJQUFJLE9BQU8sWUFBWSxPQUFPO0lBQ3BFLFVBQVUsT0FBTyxPQUFPLElBQUksVUFBVSxJQUFJLE9BQU8sWUFBWSxPQUFPLENBQUMsRUFBRTtJQUN2RSxNQUFNLE1BQU0sR0FBRyxLQUFLLENBQUM7SUFDckIsS0FBSztJQUNMLEdBQUc7SUFDSCxFQUFFLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUMxQixFQUFFLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN6QixFQUFFLE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUM7O0lDbkZEO0lBQ0EsSUFBSSxRQUFRLEdBQUcsU0FBUyxDQUFDLElBQUksRUFBRSxVQUFVLENBQUMsQ0FBQzs7SUNEM0M7SUFDQSxJQUFJeUIsU0FBTyxHQUFHLFNBQVMsQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7O0lDRHpDO0lBQ0EsSUFBSSxHQUFHLEdBQUcsU0FBUyxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQzs7SUNEakM7SUFDQSxJQUFJLE9BQU8sR0FBRyxTQUFTLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFDOztJQ0l6QztJQUNBLElBQUlSLFFBQU0sR0FBRyxjQUFjO0lBQzNCLElBQUlSLFdBQVMsR0FBRyxpQkFBaUI7SUFDakMsSUFBSSxVQUFVLEdBQUcsa0JBQWtCO0lBQ25DLElBQUlXLFFBQU0sR0FBRyxjQUFjO0lBQzNCLElBQUlNLFlBQVUsR0FBRyxrQkFBa0IsQ0FBQzs7SUFFcEMsSUFBSUgsYUFBVyxHQUFHLG1CQUFtQixDQUFDOztJQUV0QztJQUNBLElBQUksa0JBQWtCLEdBQUcsUUFBUSxDQUFDLFFBQVEsQ0FBQztJQUMzQyxJQUFJLGFBQWEsR0FBRyxRQUFRLENBQUN0QixLQUFHLENBQUM7SUFDakMsSUFBSSxpQkFBaUIsR0FBRyxRQUFRLENBQUN3QixTQUFPLENBQUM7SUFDekMsSUFBSSxhQUFhLEdBQUcsUUFBUSxDQUFDLEdBQUcsQ0FBQztJQUNqQyxJQUFJLGlCQUFpQixHQUFHLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQzs7SUFFMUM7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxJQUFJLE1BQU0sR0FBRyxVQUFVLENBQUM7O0lBRXhCO0lBQ0EsSUFBSSxDQUFDLFFBQVEsSUFBSSxNQUFNLENBQUMsSUFBSSxRQUFRLENBQUMsSUFBSSxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJRixhQUFXO0lBQ3hFLEtBQUt0QixLQUFHLElBQUksTUFBTSxDQUFDLElBQUlBLEtBQUcsQ0FBQyxJQUFJZ0IsUUFBTSxDQUFDO0lBQ3RDLEtBQUtRLFNBQU8sSUFBSSxNQUFNLENBQUNBLFNBQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQyxJQUFJLFVBQVUsQ0FBQztJQUN4RCxLQUFLLEdBQUcsSUFBSSxNQUFNLENBQUMsSUFBSSxHQUFHLENBQUMsSUFBSUwsUUFBTSxDQUFDO0lBQ3RDLEtBQUssT0FBTyxJQUFJLE1BQU0sQ0FBQyxJQUFJLE9BQU8sQ0FBQyxJQUFJTSxZQUFVLENBQUMsRUFBRTtJQUNwRCxFQUFFLE1BQU0sR0FBRyxTQUFTLEtBQUssRUFBRTtJQUMzQixJQUFJLElBQUksTUFBTSxHQUFHLFVBQVUsQ0FBQyxLQUFLLENBQUM7SUFDbEMsUUFBUSxJQUFJLEdBQUcsTUFBTSxJQUFJakIsV0FBUyxHQUFHLEtBQUssQ0FBQyxXQUFXLEdBQUcsU0FBUztJQUNsRSxRQUFRLFVBQVUsR0FBRyxJQUFJLEdBQUcsUUFBUSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQzs7SUFFaEQsSUFBSSxJQUFJLFVBQVUsRUFBRTtJQUNwQixNQUFNLFFBQVEsVUFBVTtJQUN4QixRQUFRLEtBQUssa0JBQWtCLEVBQUUsT0FBT2MsYUFBVyxDQUFDO0lBQ3BELFFBQVEsS0FBSyxhQUFhLEVBQUUsT0FBT04sUUFBTSxDQUFDO0lBQzFDLFFBQVEsS0FBSyxpQkFBaUIsRUFBRSxPQUFPLFVBQVUsQ0FBQztJQUNsRCxRQUFRLEtBQUssYUFBYSxFQUFFLE9BQU9HLFFBQU0sQ0FBQztJQUMxQyxRQUFRLEtBQUssaUJBQWlCLEVBQUUsT0FBT00sWUFBVSxDQUFDO0lBQ2xELE9BQU87SUFDUCxLQUFLO0lBQ0wsSUFBSSxPQUFPLE1BQU0sQ0FBQztJQUNsQixHQUFHLENBQUM7SUFDSixDQUFDOztBQUVELG1CQUFlLE1BQU0sQ0FBQzs7SUNoRHRCO0lBQ0EsSUFBSWIsc0JBQW9CLEdBQUcsQ0FBQyxDQUFDOztJQUU3QjtJQUNBLElBQUlOLFNBQU8sR0FBRyxvQkFBb0I7SUFDbEMsSUFBSW9CLFVBQVEsR0FBRyxnQkFBZ0I7SUFDL0IsSUFBSWxCLFdBQVMsR0FBRyxpQkFBaUIsQ0FBQzs7SUFFbEM7SUFDQSxJQUFJZixjQUFXLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FBQzs7SUFFbkM7SUFDQSxJQUFJTSxpQkFBYyxHQUFHTixjQUFXLENBQUMsY0FBYyxDQUFDOztJQUVoRDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxlQUFlLENBQUMsTUFBTSxFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUUsVUFBVSxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUU7SUFDL0UsRUFBRSxJQUFJLFFBQVEsR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDO0lBQ2hDLE1BQU0sUUFBUSxHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUM7SUFDL0IsTUFBTSxNQUFNLEdBQUcsUUFBUSxHQUFHaUMsVUFBUSxHQUFHQyxRQUFNLENBQUMsTUFBTSxDQUFDO0lBQ25ELE1BQU0sTUFBTSxHQUFHLFFBQVEsR0FBR0QsVUFBUSxHQUFHQyxRQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7O0lBRW5ELEVBQUUsTUFBTSxHQUFHLE1BQU0sSUFBSXJCLFNBQU8sR0FBR0UsV0FBUyxHQUFHLE1BQU0sQ0FBQztJQUNsRCxFQUFFLE1BQU0sR0FBRyxNQUFNLElBQUlGLFNBQU8sR0FBR0UsV0FBUyxHQUFHLE1BQU0sQ0FBQzs7SUFFbEQsRUFBRSxJQUFJLFFBQVEsR0FBRyxNQUFNLElBQUlBLFdBQVM7SUFDcEMsTUFBTSxRQUFRLEdBQUcsTUFBTSxJQUFJQSxXQUFTO0lBQ3BDLE1BQU0sU0FBUyxHQUFHLE1BQU0sSUFBSSxNQUFNLENBQUM7O0lBRW5DLEVBQUUsSUFBSSxTQUFTLElBQUksUUFBUSxDQUFDLE1BQU0sQ0FBQyxFQUFFO0lBQ3JDLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsRUFBRTtJQUMxQixNQUFNLE9BQU8sS0FBSyxDQUFDO0lBQ25CLEtBQUs7SUFDTCxJQUFJLFFBQVEsR0FBRyxJQUFJLENBQUM7SUFDcEIsSUFBSSxRQUFRLEdBQUcsS0FBSyxDQUFDO0lBQ3JCLEdBQUc7SUFDSCxFQUFFLElBQUksU0FBUyxJQUFJLENBQUMsUUFBUSxFQUFFO0lBQzlCLElBQUksS0FBSyxLQUFLLEtBQUssR0FBRyxJQUFJLEtBQUssQ0FBQyxDQUFDO0lBQ2pDLElBQUksT0FBTyxDQUFDLFFBQVEsSUFBSSxZQUFZLENBQUMsTUFBTSxDQUFDO0lBQzVDLFFBQVEsV0FBVyxDQUFDLE1BQU0sRUFBRSxLQUFLLEVBQUUsT0FBTyxFQUFFLFVBQVUsRUFBRSxTQUFTLEVBQUUsS0FBSyxDQUFDO0lBQ3pFLFFBQVEsVUFBVSxDQUFDLE1BQU0sRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLE9BQU8sRUFBRSxVQUFVLEVBQUUsU0FBUyxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQ2pGLEdBQUc7SUFDSCxFQUFFLElBQUksRUFBRSxPQUFPLEdBQUdJLHNCQUFvQixDQUFDLEVBQUU7SUFDekMsSUFBSSxJQUFJLFlBQVksR0FBRyxRQUFRLElBQUliLGlCQUFjLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxhQUFhLENBQUM7SUFDN0UsUUFBUSxZQUFZLEdBQUcsUUFBUSxJQUFJQSxpQkFBYyxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsYUFBYSxDQUFDLENBQUM7O0lBRTdFLElBQUksSUFBSSxZQUFZLElBQUksWUFBWSxFQUFFO0lBQ3RDLE1BQU0sSUFBSSxZQUFZLEdBQUcsWUFBWSxHQUFHLE1BQU0sQ0FBQyxLQUFLLEVBQUUsR0FBRyxNQUFNO0lBQy9ELFVBQVUsWUFBWSxHQUFHLFlBQVksR0FBRyxLQUFLLENBQUMsS0FBSyxFQUFFLEdBQUcsS0FBSyxDQUFDOztJQUU5RCxNQUFNLEtBQUssS0FBSyxLQUFLLEdBQUcsSUFBSSxLQUFLLENBQUMsQ0FBQztJQUNuQyxNQUFNLE9BQU8sU0FBUyxDQUFDLFlBQVksRUFBRSxZQUFZLEVBQUUsT0FBTyxFQUFFLFVBQVUsRUFBRSxLQUFLLENBQUMsQ0FBQztJQUMvRSxLQUFLO0lBQ0wsR0FBRztJQUNILEVBQUUsSUFBSSxDQUFDLFNBQVMsRUFBRTtJQUNsQixJQUFJLE9BQU8sS0FBSyxDQUFDO0lBQ2pCLEdBQUc7SUFDSCxFQUFFLEtBQUssS0FBSyxLQUFLLEdBQUcsSUFBSSxLQUFLLENBQUMsQ0FBQztJQUMvQixFQUFFLE9BQU8sWUFBWSxDQUFDLE1BQU0sRUFBRSxLQUFLLEVBQUUsT0FBTyxFQUFFLFVBQVUsRUFBRSxTQUFTLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFDNUUsQ0FBQzs7SUM3RUQ7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsV0FBVyxDQUFDLEtBQUssRUFBRSxLQUFLLEVBQUUsT0FBTyxFQUFFLFVBQVUsRUFBRSxLQUFLLEVBQUU7SUFDL0QsRUFBRSxJQUFJLEtBQUssS0FBSyxLQUFLLEVBQUU7SUFDdkIsSUFBSSxPQUFPLElBQUksQ0FBQztJQUNoQixHQUFHO0lBQ0gsRUFBRSxJQUFJLEtBQUssSUFBSSxJQUFJLElBQUksS0FBSyxJQUFJLElBQUksS0FBSyxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFO0lBQ3hGLElBQUksT0FBTyxLQUFLLEtBQUssS0FBSyxJQUFJLEtBQUssS0FBSyxLQUFLLENBQUM7SUFDOUMsR0FBRztJQUNILEVBQUUsT0FBTyxlQUFlLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUUsVUFBVSxFQUFFLFdBQVcsRUFBRSxLQUFLLENBQUMsQ0FBQztJQUNoRixDQUFDOztJQ3RCRDtJQUNBLElBQUlhLHNCQUFvQixHQUFHLENBQUM7SUFDNUIsSUFBSUMsd0JBQXNCLEdBQUcsQ0FBQyxDQUFDOztJQUUvQjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsV0FBVyxDQUFDLE1BQU0sRUFBRSxNQUFNLEVBQUUsU0FBUyxFQUFFLFVBQVUsRUFBRTtJQUM1RCxFQUFFLElBQUksS0FBSyxHQUFHLFNBQVMsQ0FBQyxNQUFNO0lBQzlCLE1BQU0sTUFBTSxHQUFHLEtBQUs7SUFDcEIsTUFBTSxZQUFZLEdBQUcsQ0FBQyxVQUFVLENBQUM7O0lBRWpDLEVBQUUsSUFBSSxNQUFNLElBQUksSUFBSSxFQUFFO0lBQ3RCLElBQUksT0FBTyxDQUFDLE1BQU0sQ0FBQztJQUNuQixHQUFHO0lBQ0gsRUFBRSxNQUFNLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQzFCLEVBQUUsT0FBTyxLQUFLLEVBQUUsRUFBRTtJQUNsQixJQUFJLElBQUksSUFBSSxHQUFHLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNoQyxJQUFJLElBQUksQ0FBQyxZQUFZLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQztJQUNoQyxZQUFZLElBQUksQ0FBQyxDQUFDLENBQUMsS0FBSyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3ZDLFlBQVksRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksTUFBTSxDQUFDO0lBQ2hDLFVBQVU7SUFDVixNQUFNLE9BQU8sS0FBSyxDQUFDO0lBQ25CLEtBQUs7SUFDTCxHQUFHO0lBQ0gsRUFBRSxPQUFPLEVBQUUsS0FBSyxHQUFHLE1BQU0sRUFBRTtJQUMzQixJQUFJLElBQUksR0FBRyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDNUIsSUFBSSxJQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDO0lBQ3JCLFFBQVEsUUFBUSxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUM7SUFDOUIsUUFBUSxRQUFRLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDOztJQUUzQixJQUFJLElBQUksWUFBWSxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRTtJQUNqQyxNQUFNLElBQUksUUFBUSxLQUFLLFNBQVMsSUFBSSxFQUFFLEdBQUcsSUFBSSxNQUFNLENBQUMsRUFBRTtJQUN0RCxRQUFRLE9BQU8sS0FBSyxDQUFDO0lBQ3JCLE9BQU87SUFDUCxLQUFLLE1BQU07SUFDWCxNQUFNLElBQUksS0FBSyxHQUFHLElBQUksS0FBSyxDQUFDO0lBQzVCLE1BQU0sSUFBSSxVQUFVLEVBQUU7SUFDdEIsUUFBUSxJQUFJLE1BQU0sR0FBRyxVQUFVLENBQUMsUUFBUSxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxLQUFLLENBQUMsQ0FBQztJQUNoRixPQUFPO0lBQ1AsTUFBTSxJQUFJLEVBQUUsTUFBTSxLQUFLLFNBQVM7SUFDaEMsY0FBYyxXQUFXLENBQUMsUUFBUSxFQUFFLFFBQVEsRUFBRUQsc0JBQW9CLEdBQUdDLHdCQUFzQixFQUFFLFVBQVUsRUFBRSxLQUFLLENBQUM7SUFDL0csY0FBYyxNQUFNO0lBQ3BCLFdBQVcsRUFBRTtJQUNiLFFBQVEsT0FBTyxLQUFLLENBQUM7SUFDckIsT0FBTztJQUNQLEtBQUs7SUFDTCxHQUFHO0lBQ0gsRUFBRSxPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7O0lDekREO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLGtCQUFrQixDQUFDLEtBQUssRUFBRTtJQUNuQyxFQUFFLE9BQU8sS0FBSyxLQUFLLEtBQUssSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUM3QyxDQUFDOztJQ1REO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxZQUFZLENBQUMsTUFBTSxFQUFFO0lBQzlCLEVBQUUsSUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQztJQUMzQixNQUFNLE1BQU0sR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDOztJQUU3QixFQUFFLE9BQU8sTUFBTSxFQUFFLEVBQUU7SUFDbkIsSUFBSSxJQUFJLEdBQUcsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDO0lBQzVCLFFBQVEsS0FBSyxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQzs7SUFFNUIsSUFBSSxNQUFNLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsS0FBSyxFQUFFLGtCQUFrQixDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7SUFDN0QsR0FBRztJQUNILEVBQUUsT0FBTyxNQUFNLENBQUM7SUFDaEIsQ0FBQzs7SUNyQkQ7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyx1QkFBdUIsQ0FBQyxHQUFHLEVBQUUsUUFBUSxFQUFFO0lBQ2hELEVBQUUsT0FBTyxTQUFTLE1BQU0sRUFBRTtJQUMxQixJQUFJLElBQUksTUFBTSxJQUFJLElBQUksRUFBRTtJQUN4QixNQUFNLE9BQU8sS0FBSyxDQUFDO0lBQ25CLEtBQUs7SUFDTCxJQUFJLE9BQU8sTUFBTSxDQUFDLEdBQUcsQ0FBQyxLQUFLLFFBQVE7SUFDbkMsT0FBTyxRQUFRLEtBQUssU0FBUyxLQUFLLEdBQUcsSUFBSSxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzFELEdBQUcsQ0FBQztJQUNKLENBQUM7O0lDYkQ7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLFdBQVcsQ0FBQyxNQUFNLEVBQUU7SUFDN0IsRUFBRSxJQUFJLFNBQVMsR0FBRyxZQUFZLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDdkMsRUFBRSxJQUFJLFNBQVMsQ0FBQyxNQUFNLElBQUksQ0FBQyxJQUFJLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRTtJQUNoRCxJQUFJLE9BQU8sdUJBQXVCLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3JFLEdBQUc7SUFDSCxFQUFFLE9BQU8sU0FBUyxNQUFNLEVBQUU7SUFDMUIsSUFBSSxPQUFPLE1BQU0sS0FBSyxNQUFNLElBQUksV0FBVyxDQUFDLE1BQU0sRUFBRSxNQUFNLEVBQUUsU0FBUyxDQUFDLENBQUM7SUFDdkUsR0FBRyxDQUFDO0lBQ0osQ0FBQzs7SUNoQkQ7SUFDQSxJQUFJZSxXQUFTLEdBQUcsaUJBQWlCLENBQUM7O0lBRWxDO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLFFBQVEsQ0FBQyxLQUFLLEVBQUU7SUFDekIsRUFBRSxPQUFPLE9BQU8sS0FBSyxJQUFJLFFBQVE7SUFDakMsS0FBSyxZQUFZLENBQUMsS0FBSyxDQUFDLElBQUksVUFBVSxDQUFDLEtBQUssQ0FBQyxJQUFJQSxXQUFTLENBQUMsQ0FBQztJQUM1RCxDQUFDOztJQ3ZCRDtJQUNBLElBQUksWUFBWSxHQUFHLGtEQUFrRDtJQUNyRSxJQUFJLGFBQWEsR0FBRyxPQUFPLENBQUM7O0lBRTVCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLEtBQUssQ0FBQyxLQUFLLEVBQUUsTUFBTSxFQUFFO0lBQzlCLEVBQUUsSUFBSSxPQUFPLENBQUMsS0FBSyxDQUFDLEVBQUU7SUFDdEIsSUFBSSxPQUFPLEtBQUssQ0FBQztJQUNqQixHQUFHO0lBQ0gsRUFBRSxJQUFJLElBQUksR0FBRyxPQUFPLEtBQUssQ0FBQztJQUMxQixFQUFFLElBQUksSUFBSSxJQUFJLFFBQVEsSUFBSSxJQUFJLElBQUksUUFBUSxJQUFJLElBQUksSUFBSSxTQUFTO0lBQy9ELE1BQU0sS0FBSyxJQUFJLElBQUksSUFBSSxRQUFRLENBQUMsS0FBSyxDQUFDLEVBQUU7SUFDeEMsSUFBSSxPQUFPLElBQUksQ0FBQztJQUNoQixHQUFHO0lBQ0gsRUFBRSxPQUFPLGFBQWEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQztJQUMvRCxLQUFLLE1BQU0sSUFBSSxJQUFJLElBQUksS0FBSyxJQUFJLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0lBQ2hELENBQUM7O0lDeEJEO0lBQ0EsSUFBSSxlQUFlLEdBQUcscUJBQXFCLENBQUM7O0lBRTVDO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLE9BQU8sQ0FBQyxJQUFJLEVBQUUsUUFBUSxFQUFFO0lBQ2pDLEVBQUUsSUFBSSxPQUFPLElBQUksSUFBSSxVQUFVLEtBQUssUUFBUSxJQUFJLElBQUksSUFBSSxPQUFPLFFBQVEsSUFBSSxVQUFVLENBQUMsRUFBRTtJQUN4RixJQUFJLE1BQU0sSUFBSSxTQUFTLENBQUMsZUFBZSxDQUFDLENBQUM7SUFDekMsR0FBRztJQUNILEVBQUUsSUFBSSxRQUFRLEdBQUcsV0FBVztJQUM1QixJQUFJLElBQUksSUFBSSxHQUFHLFNBQVM7SUFDeEIsUUFBUSxHQUFHLEdBQUcsUUFBUSxHQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUM7SUFDN0QsUUFBUSxLQUFLLEdBQUcsUUFBUSxDQUFDLEtBQUssQ0FBQzs7SUFFL0IsSUFBSSxJQUFJLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUU7SUFDeEIsTUFBTSxPQUFPLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDNUIsS0FBSztJQUNMLElBQUksSUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDeEMsSUFBSSxRQUFRLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLE1BQU0sQ0FBQyxJQUFJLEtBQUssQ0FBQztJQUNyRCxJQUFJLE9BQU8sTUFBTSxDQUFDO0lBQ2xCLEdBQUcsQ0FBQztJQUNKLEVBQUUsUUFBUSxDQUFDLEtBQUssR0FBRyxLQUFLLE9BQU8sQ0FBQyxLQUFLLElBQUksUUFBUSxDQUFDLENBQUM7SUFDbkQsRUFBRSxPQUFPLFFBQVEsQ0FBQztJQUNsQixDQUFDOztJQUVEO0lBQ0EsT0FBTyxDQUFDLEtBQUssR0FBRyxRQUFRLENBQUM7O0lDcEV6QjtJQUNBLElBQUksZ0JBQWdCLEdBQUcsR0FBRyxDQUFDOztJQUUzQjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxhQUFhLENBQUMsSUFBSSxFQUFFO0lBQzdCLEVBQUUsSUFBSSxNQUFNLEdBQUcsT0FBTyxDQUFDLElBQUksRUFBRSxTQUFTLEdBQUcsRUFBRTtJQUMzQyxJQUFJLElBQUksS0FBSyxDQUFDLElBQUksS0FBSyxnQkFBZ0IsRUFBRTtJQUN6QyxNQUFNLEtBQUssQ0FBQyxLQUFLLEVBQUUsQ0FBQztJQUNwQixLQUFLO0lBQ0wsSUFBSSxPQUFPLEdBQUcsQ0FBQztJQUNmLEdBQUcsQ0FBQyxDQUFDOztJQUVMLEVBQUUsSUFBSSxLQUFLLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQztJQUMzQixFQUFFLE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUM7O0lDckJEO0lBQ0EsSUFBSSxVQUFVLEdBQUcsa0dBQWtHLENBQUM7O0lBRXBIO0lBQ0EsSUFBSSxZQUFZLEdBQUcsVUFBVSxDQUFDOztJQUU5QjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLElBQUksWUFBWSxHQUFHLGFBQWEsQ0FBQyxTQUFTLE1BQU0sRUFBRTtJQUNsRCxFQUFFLElBQUksTUFBTSxHQUFHLEVBQUUsQ0FBQztJQUNsQixFQUFFLElBQUksTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLFVBQVU7SUFDM0MsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQ3BCLEdBQUc7SUFDSCxFQUFFLE1BQU0sQ0FBQyxPQUFPLENBQUMsVUFBVSxFQUFFLFNBQVMsS0FBSyxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsU0FBUyxFQUFFO0lBQ3ZFLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLEdBQUcsU0FBUyxDQUFDLE9BQU8sQ0FBQyxZQUFZLEVBQUUsSUFBSSxDQUFDLElBQUksTUFBTSxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUM7SUFDbkYsR0FBRyxDQUFDLENBQUM7SUFDTCxFQUFFLE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUMsQ0FBQyxDQUFDOztJQ3hCSDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLFFBQVEsQ0FBQyxLQUFLLEVBQUUsUUFBUSxFQUFFO0lBQ25DLEVBQUUsSUFBSSxLQUFLLEdBQUcsQ0FBQyxDQUFDO0lBQ2hCLE1BQU0sTUFBTSxHQUFHLEtBQUssSUFBSSxJQUFJLEdBQUcsQ0FBQyxHQUFHLEtBQUssQ0FBQyxNQUFNO0lBQy9DLE1BQU0sTUFBTSxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQzs7SUFFN0IsRUFBRSxPQUFPLEVBQUUsS0FBSyxHQUFHLE1BQU0sRUFBRTtJQUMzQixJQUFJLE1BQU0sQ0FBQyxLQUFLLENBQUMsR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxFQUFFLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQztJQUN6RCxHQUFHO0lBQ0gsRUFBRSxPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDOztJQ2JEO0lBQ0EsSUFBSSxRQUFRLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQzs7SUFFckI7SUFDQSxJQUFJQyxhQUFXLEdBQUdyQyxRQUFNLEdBQUdBLFFBQU0sQ0FBQyxTQUFTLEdBQUcsU0FBUztJQUN2RCxJQUFJLGNBQWMsR0FBR3FDLGFBQVcsR0FBR0EsYUFBVyxDQUFDLFFBQVEsR0FBRyxTQUFTLENBQUM7O0lBRXBFO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLFlBQVksQ0FBQyxLQUFLLEVBQUU7SUFDN0I7SUFDQSxFQUFFLElBQUksT0FBTyxLQUFLLElBQUksUUFBUSxFQUFFO0lBQ2hDLElBQUksT0FBTyxLQUFLLENBQUM7SUFDakIsR0FBRztJQUNILEVBQUUsSUFBSSxPQUFPLENBQUMsS0FBSyxDQUFDLEVBQUU7SUFDdEI7SUFDQSxJQUFJLE9BQU8sUUFBUSxDQUFDLEtBQUssRUFBRSxZQUFZLENBQUMsR0FBRyxFQUFFLENBQUM7SUFDOUMsR0FBRztJQUNILEVBQUUsSUFBSSxRQUFRLENBQUMsS0FBSyxDQUFDLEVBQUU7SUFDdkIsSUFBSSxPQUFPLGNBQWMsR0FBRyxjQUFjLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsQ0FBQztJQUM1RCxHQUFHO0lBQ0gsRUFBRSxJQUFJLE1BQU0sSUFBSSxLQUFLLEdBQUcsRUFBRSxDQUFDLENBQUM7SUFDNUIsRUFBRSxPQUFPLENBQUMsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxLQUFLLEtBQUssQ0FBQyxRQUFRLElBQUksSUFBSSxHQUFHLE1BQU0sQ0FBQztJQUNyRSxDQUFDOztJQ2hDRDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLFFBQVEsQ0FBQyxLQUFLLEVBQUU7SUFDekIsRUFBRSxPQUFPLEtBQUssSUFBSSxJQUFJLEdBQUcsRUFBRSxHQUFHLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNsRCxDQUFDOztJQ3BCRDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxRQUFRLENBQUMsS0FBSyxFQUFFLE1BQU0sRUFBRTtJQUNqQyxFQUFFLElBQUksT0FBTyxDQUFDLEtBQUssQ0FBQyxFQUFFO0lBQ3RCLElBQUksT0FBTyxLQUFLLENBQUM7SUFDakIsR0FBRztJQUNILEVBQUUsT0FBTyxLQUFLLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEdBQUcsWUFBWSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBQ3hFLENBQUM7O0lDaEJEO0lBQ0EsSUFBSUMsVUFBUSxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7O0lBRXJCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxLQUFLLENBQUMsS0FBSyxFQUFFO0lBQ3RCLEVBQUUsSUFBSSxPQUFPLEtBQUssSUFBSSxRQUFRLElBQUksUUFBUSxDQUFDLEtBQUssQ0FBQyxFQUFFO0lBQ25ELElBQUksT0FBTyxLQUFLLENBQUM7SUFDakIsR0FBRztJQUNILEVBQUUsSUFBSSxNQUFNLElBQUksS0FBSyxHQUFHLEVBQUUsQ0FBQyxDQUFDO0lBQzVCLEVBQUUsT0FBTyxDQUFDLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSyxLQUFLLENBQUNBLFVBQVEsSUFBSSxJQUFJLEdBQUcsTUFBTSxDQUFDO0lBQ3JFLENBQUM7O0lDZkQ7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsT0FBTyxDQUFDLE1BQU0sRUFBRSxJQUFJLEVBQUU7SUFDL0IsRUFBRSxJQUFJLEdBQUcsUUFBUSxDQUFDLElBQUksRUFBRSxNQUFNLENBQUMsQ0FBQzs7SUFFaEMsRUFBRSxJQUFJLEtBQUssR0FBRyxDQUFDO0lBQ2YsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQzs7SUFFM0IsRUFBRSxPQUFPLE1BQU0sSUFBSSxJQUFJLElBQUksS0FBSyxHQUFHLE1BQU0sRUFBRTtJQUMzQyxJQUFJLE1BQU0sR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUMxQyxHQUFHO0lBQ0gsRUFBRSxPQUFPLENBQUMsS0FBSyxJQUFJLEtBQUssSUFBSSxNQUFNLElBQUksTUFBTSxHQUFHLFNBQVMsQ0FBQztJQUN6RCxDQUFDOztJQ25CRDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsR0FBRyxDQUFDLE1BQU0sRUFBRSxJQUFJLEVBQUUsWUFBWSxFQUFFO0lBQ3pDLEVBQUUsSUFBSSxNQUFNLEdBQUcsTUFBTSxJQUFJLElBQUksR0FBRyxTQUFTLEdBQUcsT0FBTyxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsQ0FBQztJQUNsRSxFQUFFLE9BQU8sTUFBTSxLQUFLLFNBQVMsR0FBRyxZQUFZLEdBQUcsTUFBTSxDQUFDO0lBQ3RELENBQUM7O0lDOUJEO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLFNBQVMsQ0FBQyxNQUFNLEVBQUUsR0FBRyxFQUFFO0lBQ2hDLEVBQUUsT0FBTyxNQUFNLElBQUksSUFBSSxJQUFJLEdBQUcsSUFBSSxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDakQsQ0FBQzs7SUNIRDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLE9BQU8sQ0FBQyxNQUFNLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRTtJQUN4QyxFQUFFLElBQUksR0FBRyxRQUFRLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxDQUFDOztJQUVoQyxFQUFFLElBQUksS0FBSyxHQUFHLENBQUMsQ0FBQztJQUNoQixNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTTtJQUMxQixNQUFNLE1BQU0sR0FBRyxLQUFLLENBQUM7O0lBRXJCLEVBQUUsT0FBTyxFQUFFLEtBQUssR0FBRyxNQUFNLEVBQUU7SUFDM0IsSUFBSSxJQUFJLEdBQUcsR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7SUFDakMsSUFBSSxJQUFJLEVBQUUsTUFBTSxHQUFHLE1BQU0sSUFBSSxJQUFJLElBQUksT0FBTyxDQUFDLE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBQyxFQUFFO0lBQzVELE1BQU0sTUFBTTtJQUNaLEtBQUs7SUFDTCxJQUFJLE1BQU0sR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDekIsR0FBRztJQUNILEVBQUUsSUFBSSxNQUFNLElBQUksRUFBRSxLQUFLLElBQUksTUFBTSxFQUFFO0lBQ25DLElBQUksT0FBTyxNQUFNLENBQUM7SUFDbEIsR0FBRztJQUNILEVBQUUsTUFBTSxHQUFHLE1BQU0sSUFBSSxJQUFJLEdBQUcsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUM7SUFDOUMsRUFBRSxPQUFPLENBQUMsQ0FBQyxNQUFNLElBQUksUUFBUSxDQUFDLE1BQU0sQ0FBQyxJQUFJLE9BQU8sQ0FBQyxHQUFHLEVBQUUsTUFBTSxDQUFDO0lBQzdELEtBQUssT0FBTyxDQUFDLE1BQU0sQ0FBQyxJQUFJLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0lBQzdDLENBQUM7O0lDakNEO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLEtBQUssQ0FBQyxNQUFNLEVBQUUsSUFBSSxFQUFFO0lBQzdCLEVBQUUsT0FBTyxNQUFNLElBQUksSUFBSSxJQUFJLE9BQU8sQ0FBQyxNQUFNLEVBQUUsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0lBQzVELENBQUM7O0lDdkJEO0lBQ0EsSUFBSWxCLHNCQUFvQixHQUFHLENBQUM7SUFDNUIsSUFBSUMsd0JBQXNCLEdBQUcsQ0FBQyxDQUFDOztJQUUvQjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxtQkFBbUIsQ0FBQyxJQUFJLEVBQUUsUUFBUSxFQUFFO0lBQzdDLEVBQUUsSUFBSSxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksa0JBQWtCLENBQUMsUUFBUSxDQUFDLEVBQUU7SUFDbkQsSUFBSSxPQUFPLHVCQUF1QixDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxRQUFRLENBQUMsQ0FBQztJQUMxRCxHQUFHO0lBQ0gsRUFBRSxPQUFPLFNBQVMsTUFBTSxFQUFFO0lBQzFCLElBQUksSUFBSSxRQUFRLEdBQUcsR0FBRyxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsQ0FBQztJQUNyQyxJQUFJLE9BQU8sQ0FBQyxRQUFRLEtBQUssU0FBUyxJQUFJLFFBQVEsS0FBSyxRQUFRO0lBQzNELFFBQVEsS0FBSyxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUM7SUFDM0IsUUFBUSxXQUFXLENBQUMsUUFBUSxFQUFFLFFBQVEsRUFBRUQsc0JBQW9CLEdBQUdDLHdCQUFzQixDQUFDLENBQUM7SUFDdkYsR0FBRyxDQUFDO0lBQ0osQ0FBQzs7SUM5QkQ7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLFlBQVksQ0FBQyxHQUFHLEVBQUU7SUFDM0IsRUFBRSxPQUFPLFNBQVMsTUFBTSxFQUFFO0lBQzFCLElBQUksT0FBTyxNQUFNLElBQUksSUFBSSxHQUFHLFNBQVMsR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDcEQsR0FBRyxDQUFDO0lBQ0osQ0FBQzs7SUNURDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsZ0JBQWdCLENBQUMsSUFBSSxFQUFFO0lBQ2hDLEVBQUUsT0FBTyxTQUFTLE1BQU0sRUFBRTtJQUMxQixJQUFJLE9BQU8sT0FBTyxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsQ0FBQztJQUNqQyxHQUFHLENBQUM7SUFDSixDQUFDOztJQ1JEO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxRQUFRLENBQUMsSUFBSSxFQUFFO0lBQ3hCLEVBQUUsT0FBTyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsWUFBWSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLGdCQUFnQixDQUFDLElBQUksQ0FBQyxDQUFDO0lBQzFFLENBQUM7O0lDdkJEO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxZQUFZLENBQUMsS0FBSyxFQUFFO0lBQzdCO0lBQ0E7SUFDQSxFQUFFLElBQUksT0FBTyxLQUFLLElBQUksVUFBVSxFQUFFO0lBQ2xDLElBQUksT0FBTyxLQUFLLENBQUM7SUFDakIsR0FBRztJQUNILEVBQUUsSUFBSSxLQUFLLElBQUksSUFBSSxFQUFFO0lBQ3JCLElBQUksT0FBTyxRQUFRLENBQUM7SUFDcEIsR0FBRztJQUNILEVBQUUsSUFBSSxPQUFPLEtBQUssSUFBSSxRQUFRLEVBQUU7SUFDaEMsSUFBSSxPQUFPLE9BQU8sQ0FBQyxLQUFLLENBQUM7SUFDekIsUUFBUSxtQkFBbUIsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQy9DLFFBQVEsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQzNCLEdBQUc7SUFDSCxFQUFFLE9BQU8sUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3pCLENBQUM7O0lDeEJEO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsT0FBTyxDQUFDLE1BQU0sRUFBRSxRQUFRLEVBQUU7SUFDbkMsRUFBRSxJQUFJLE1BQU0sR0FBRyxFQUFFLENBQUM7SUFDbEIsRUFBRSxRQUFRLEdBQUcsWUFBWSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUMsQ0FBQzs7SUFFdkMsRUFBRSxVQUFVLENBQUMsTUFBTSxFQUFFLFNBQVMsS0FBSyxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUU7SUFDbEQsSUFBSSxlQUFlLENBQUMsTUFBTSxFQUFFLFFBQVEsQ0FBQyxLQUFLLEVBQUUsR0FBRyxFQUFFLE1BQU0sQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQ2pFLEdBQUcsQ0FBQyxDQUFDO0lBQ0wsRUFBRSxPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDOztJQ2pDRDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxNQUFNLENBQUMsS0FBSyxFQUFFO0lBQ3ZCLEVBQUUsT0FBTyxLQUFLLEtBQUssSUFBSSxDQUFDO0lBQ3hCLENBQUM7O0lDakJEO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLGNBQWMsQ0FBQyxRQUFRLEVBQUUsU0FBUyxFQUFFO0lBQzdDLEVBQUUsT0FBTyxTQUFTLFVBQVUsRUFBRSxRQUFRLEVBQUU7SUFDeEMsSUFBSSxJQUFJLFVBQVUsSUFBSSxJQUFJLEVBQUU7SUFDNUIsTUFBTSxPQUFPLFVBQVUsQ0FBQztJQUN4QixLQUFLO0lBQ0wsSUFBSSxJQUFJLENBQUMsV0FBVyxDQUFDLFVBQVUsQ0FBQyxFQUFFO0lBQ2xDLE1BQU0sT0FBTyxRQUFRLENBQUMsVUFBVSxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBQzVDLEtBQUs7SUFDTCxJQUFJLElBQUksTUFBTSxHQUFHLFVBQVUsQ0FBQyxNQUFNO0lBQ2xDLFFBQVEsS0FBSyxHQUFHLFNBQVMsR0FBRyxNQUFNLEdBQUcsQ0FBQyxDQUFDO0lBQ3ZDLFFBQVEsUUFBUSxHQUFHLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQzs7SUFFdEMsSUFBSSxRQUFRLFNBQVMsR0FBRyxLQUFLLEVBQUUsR0FBRyxFQUFFLEtBQUssR0FBRyxNQUFNLEdBQUc7SUFDckQsTUFBTSxJQUFJLFFBQVEsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLEVBQUUsS0FBSyxFQUFFLFFBQVEsQ0FBQyxLQUFLLEtBQUssRUFBRTtJQUNoRSxRQUFRLE1BQU07SUFDZCxPQUFPO0lBQ1AsS0FBSztJQUNMLElBQUksT0FBTyxVQUFVLENBQUM7SUFDdEIsR0FBRyxDQUFDO0lBQ0osQ0FBQzs7SUMxQkQ7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLElBQUksUUFBUSxHQUFHLGNBQWMsQ0FBQyxVQUFVLENBQUMsQ0FBQzs7SUNUMUM7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsVUFBVSxDQUFDLFVBQVUsRUFBRSxTQUFTLEVBQUU7SUFDM0MsRUFBRSxJQUFJLE1BQU0sR0FBRyxFQUFFLENBQUM7SUFDbEIsRUFBRSxRQUFRLENBQUMsVUFBVSxFQUFFLFNBQVMsS0FBSyxFQUFFLEtBQUssRUFBRSxVQUFVLEVBQUU7SUFDMUQsSUFBSSxJQUFJLFNBQVMsQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLFVBQVUsQ0FBQyxFQUFFO0lBQzdDLE1BQU0sTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN6QixLQUFLO0lBQ0wsR0FBRyxDQUFDLENBQUM7SUFDTCxFQUFFLE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUM7O0lDYkQ7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLE1BQU0sQ0FBQyxVQUFVLEVBQUUsU0FBUyxFQUFFO0lBQ3ZDLEVBQUUsSUFBSSxJQUFJLEdBQUcsT0FBTyxDQUFDLFVBQVUsQ0FBQyxHQUFHLFdBQVcsR0FBRyxVQUFVLENBQUM7SUFDNUQsRUFBRSxPQUFPLElBQUksQ0FBQyxVQUFVLEVBQUUsWUFBWSxDQUFDLFNBQVMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3RELENBQUM7O0lDdENjLFNBQVNrQixNQUFULENBQWdCQyxPQUFoQixFQUF5QkQsTUFBekIsRUFBa0Q7SUFBQSxNQUFqQkUsU0FBaUIsdUVBQUwsR0FBSzs7SUFDN0QsTUFBTUMsV0FBVyxTQUFYQSxRQUFXLENBQUNwRCxLQUFELEVBQVFxRCxHQUFSLEVBQWdCO0lBQzdCLFFBQU1DLFNBQVNELE9BQU9yRCxLQUF0QjtJQUVBLFdBQU91RCxPQUFPLENBQ1ZOLE1BRFUsRUFFVkssT0FBT0UsT0FBUCxDQUFlLElBQUlDLE1BQUosWUFBZVIsTUFBZixTQUF3QkUsU0FBeEIsT0FBZixFQUFzRCxFQUF0RCxDQUZVLENBQVAsRUFHSk8sSUFISSxDQUdDUCxTQUhELENBQVA7SUFJSCxHQVBEOztJQVNBLE1BQUdRLFVBQVVULE9BQVYsS0FBc0JVLE9BQU9WLE9BQVAsQ0FBdEIsSUFBeUNXLFlBQVlYLE9BQVosQ0FBNUMsRUFBa0U7SUFDOUQsV0FBT0EsT0FBUDtJQUNIOztJQUVELE1BQUdZLFNBQVNaLE9BQVQsQ0FBSCxFQUFzQjtJQUNsQixXQUFPYSxRQUFRYixPQUFSLEVBQWlCRSxRQUFqQixDQUFQO0lBQ0g7O0lBRUQsU0FBT0EsU0FBU0YsT0FBVCxDQUFQO0lBQ0g7O0FDeEJELGtCQUFlO0lBRVhjLFNBQU87SUFFSDs7Ozs7SUFLQUMsYUFBUztJQUNMQyxZQUFNL0QsTUFERDtJQUVMZ0UsZUFBUztJQUZKO0lBUE4sR0FGSTtJQWdCWEMsWUFBVTtJQUVOQyxzQkFGTSxnQ0FFZTtJQUNqQixhQUFPLEtBQUtDLFFBQUwsQ0FBY0MsSUFBckI7SUFDSCxLQUpLO0lBTU5DLGdCQU5NLDBCQU1TO0lBQ1gsYUFBT3ZCLE9BQU8sS0FBS2dCLE9BQVosRUFBcUIsS0FBS0ksa0JBQTFCLENBQVA7SUFDSDtJQVJLO0lBaEJDLENBQWY7O0FDQUEsbUJBQWU7SUFFWEwsU0FBTztJQUVIOzs7OztJQUtBUyxVQUFNO0lBQ0ZQLFlBQU0vRCxNQURKO0lBRUZnRSxlQUFTLElBRlA7SUFHRk8sZ0JBQVU7SUFBQSxlQUFTLENBQUMsSUFBRCxFQUFPLElBQVAsRUFBYSxJQUFiLEVBQW1CQyxPQUFuQixDQUEyQjNFLEtBQTNCLE1BQXNDLENBQUMsQ0FBaEQ7SUFBQTtJQUhSO0lBUEgsR0FGSTtJQWlCWG9FLFlBQVU7SUFFTlEsdUJBRk0saUNBRWdCO0lBQ2xCLGFBQU8sS0FBS04sUUFBTCxDQUFjQyxJQUFyQjtJQUNILEtBSks7SUFNTk0saUJBTk0sMkJBTVU7SUFDWixhQUFPNUIsT0FBTyxLQUFLd0IsSUFBWixFQUFrQixLQUFLRyxtQkFBdkIsQ0FBUDtJQUNIO0lBUks7SUFqQkMsQ0FBZjs7SUNGQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLFNBQVMsQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRTtJQUN0QyxFQUFFLElBQUksS0FBSyxHQUFHLENBQUMsQ0FBQztJQUNoQixNQUFNLE1BQU0sR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDOztJQUU1QixFQUFFLElBQUksS0FBSyxHQUFHLENBQUMsRUFBRTtJQUNqQixJQUFJLEtBQUssR0FBRyxDQUFDLEtBQUssR0FBRyxNQUFNLEdBQUcsQ0FBQyxJQUFJLE1BQU0sR0FBRyxLQUFLLENBQUMsQ0FBQztJQUNuRCxHQUFHO0lBQ0gsRUFBRSxHQUFHLEdBQUcsR0FBRyxHQUFHLE1BQU0sR0FBRyxNQUFNLEdBQUcsR0FBRyxDQUFDO0lBQ3BDLEVBQUUsSUFBSSxHQUFHLEdBQUcsQ0FBQyxFQUFFO0lBQ2YsSUFBSSxHQUFHLElBQUksTUFBTSxDQUFDO0lBQ2xCLEdBQUc7SUFDSCxFQUFFLE1BQU0sR0FBRyxLQUFLLEdBQUcsR0FBRyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsR0FBRyxLQUFLLE1BQU0sQ0FBQyxDQUFDLENBQUM7SUFDbkQsRUFBRSxLQUFLLE1BQU0sQ0FBQyxDQUFDOztJQUVmLEVBQUUsSUFBSSxNQUFNLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQzdCLEVBQUUsT0FBTyxFQUFFLEtBQUssR0FBRyxNQUFNLEVBQUU7SUFDM0IsSUFBSSxNQUFNLENBQUMsS0FBSyxDQUFDLEdBQUcsS0FBSyxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUMsQ0FBQztJQUN6QyxHQUFHO0lBQ0gsRUFBRSxPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDOztJQzFCRDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLFNBQVMsQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRTtJQUN0QyxFQUFFLElBQUksTUFBTSxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUM7SUFDNUIsRUFBRSxHQUFHLEdBQUcsR0FBRyxLQUFLLFNBQVMsR0FBRyxNQUFNLEdBQUcsR0FBRyxDQUFDO0lBQ3pDLEVBQUUsT0FBTyxDQUFDLENBQUMsS0FBSyxJQUFJLEdBQUcsSUFBSSxNQUFNLElBQUksS0FBSyxHQUFHLFNBQVMsQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBQzFFLENBQUM7O0lDZkQ7SUFDQSxJQUFJLGFBQWEsR0FBRyxpQkFBaUI7SUFDckMsSUFBSSxpQkFBaUIsR0FBRyxpQkFBaUI7SUFDekMsSUFBSSxxQkFBcUIsR0FBRyxpQkFBaUI7SUFDN0MsSUFBSSxtQkFBbUIsR0FBRyxpQkFBaUI7SUFDM0MsSUFBSSxZQUFZLEdBQUcsaUJBQWlCLEdBQUcscUJBQXFCLEdBQUcsbUJBQW1CO0lBQ2xGLElBQUksVUFBVSxHQUFHLGdCQUFnQixDQUFDOztJQUVsQztJQUNBLElBQUksS0FBSyxHQUFHLFNBQVMsQ0FBQzs7SUFFdEI7SUFDQSxJQUFJLFlBQVksR0FBRyxNQUFNLENBQUMsR0FBRyxHQUFHLEtBQUssR0FBRyxhQUFhLElBQUksWUFBWSxHQUFHLFVBQVUsR0FBRyxHQUFHLENBQUMsQ0FBQzs7SUFFMUY7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLFVBQVUsQ0FBQyxNQUFNLEVBQUU7SUFDNUIsRUFBRSxPQUFPLFlBQVksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDbkMsQ0FBQzs7SUN2QkQ7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLFlBQVksQ0FBQyxNQUFNLEVBQUU7SUFDOUIsRUFBRSxPQUFPLE1BQU0sQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDMUIsQ0FBQzs7SUNURDtJQUNBLElBQUlFLGVBQWEsR0FBRyxpQkFBaUI7SUFDckMsSUFBSUMsbUJBQWlCLEdBQUcsaUJBQWlCO0lBQ3pDLElBQUlDLHVCQUFxQixHQUFHLGlCQUFpQjtJQUM3QyxJQUFJQyxxQkFBbUIsR0FBRyxpQkFBaUI7SUFDM0MsSUFBSUMsY0FBWSxHQUFHSCxtQkFBaUIsR0FBR0MsdUJBQXFCLEdBQUdDLHFCQUFtQjtJQUNsRixJQUFJRSxZQUFVLEdBQUcsZ0JBQWdCLENBQUM7O0lBRWxDO0lBQ0EsSUFBSSxRQUFRLEdBQUcsR0FBRyxHQUFHTCxlQUFhLEdBQUcsR0FBRztJQUN4QyxJQUFJLE9BQU8sR0FBRyxHQUFHLEdBQUdJLGNBQVksR0FBRyxHQUFHO0lBQ3RDLElBQUksTUFBTSxHQUFHLDBCQUEwQjtJQUN2QyxJQUFJLFVBQVUsR0FBRyxLQUFLLEdBQUcsT0FBTyxHQUFHLEdBQUcsR0FBRyxNQUFNLEdBQUcsR0FBRztJQUNyRCxJQUFJLFdBQVcsR0FBRyxJQUFJLEdBQUdKLGVBQWEsR0FBRyxHQUFHO0lBQzVDLElBQUksVUFBVSxHQUFHLGlDQUFpQztJQUNsRCxJQUFJLFVBQVUsR0FBRyxvQ0FBb0M7SUFDckQsSUFBSU0sT0FBSyxHQUFHLFNBQVMsQ0FBQzs7SUFFdEI7SUFDQSxJQUFJLFFBQVEsR0FBRyxVQUFVLEdBQUcsR0FBRztJQUMvQixJQUFJLFFBQVEsR0FBRyxHQUFHLEdBQUdELFlBQVUsR0FBRyxJQUFJO0lBQ3RDLElBQUksU0FBUyxHQUFHLEtBQUssR0FBR0MsT0FBSyxHQUFHLEtBQUssR0FBRyxDQUFDLFdBQVcsRUFBRSxVQUFVLEVBQUUsVUFBVSxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEdBQUcsR0FBRyxRQUFRLEdBQUcsUUFBUSxHQUFHLElBQUk7SUFDMUgsSUFBSSxLQUFLLEdBQUcsUUFBUSxHQUFHLFFBQVEsR0FBRyxTQUFTO0lBQzNDLElBQUksUUFBUSxHQUFHLEtBQUssR0FBRyxDQUFDLFdBQVcsR0FBRyxPQUFPLEdBQUcsR0FBRyxFQUFFLE9BQU8sRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFLFFBQVEsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxHQUFHLENBQUM7O0lBRWhIO0lBQ0EsSUFBSSxTQUFTLEdBQUcsTUFBTSxDQUFDLE1BQU0sR0FBRyxLQUFLLEdBQUcsTUFBTSxHQUFHLElBQUksR0FBRyxRQUFRLEdBQUcsS0FBSyxFQUFFLEdBQUcsQ0FBQyxDQUFDOztJQUUvRTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsY0FBYyxDQUFDLE1BQU0sRUFBRTtJQUNoQyxFQUFFLE9BQU8sTUFBTSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLENBQUM7SUFDdkMsQ0FBQzs7SUNqQ0Q7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLGFBQWEsQ0FBQyxNQUFNLEVBQUU7SUFDL0IsRUFBRSxPQUFPLFVBQVUsQ0FBQyxNQUFNLENBQUM7SUFDM0IsTUFBTSxjQUFjLENBQUMsTUFBTSxDQUFDO0lBQzVCLE1BQU0sWUFBWSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQzNCLENBQUM7O0lDVkQ7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLGVBQWUsQ0FBQyxVQUFVLEVBQUU7SUFDckMsRUFBRSxPQUFPLFNBQVMsTUFBTSxFQUFFO0lBQzFCLElBQUksTUFBTSxHQUFHLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQzs7SUFFOUIsSUFBSSxJQUFJLFVBQVUsR0FBRyxVQUFVLENBQUMsTUFBTSxDQUFDO0lBQ3ZDLFFBQVEsYUFBYSxDQUFDLE1BQU0sQ0FBQztJQUM3QixRQUFRLFNBQVMsQ0FBQzs7SUFFbEIsSUFBSSxJQUFJLEdBQUcsR0FBRyxVQUFVO0lBQ3hCLFFBQVEsVUFBVSxDQUFDLENBQUMsQ0FBQztJQUNyQixRQUFRLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7O0lBRXpCLElBQUksSUFBSSxRQUFRLEdBQUcsVUFBVTtJQUM3QixRQUFRLFNBQVMsQ0FBQyxVQUFVLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQztJQUN6QyxRQUFRLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7O0lBRXhCLElBQUksT0FBTyxHQUFHLENBQUMsVUFBVSxDQUFDLEVBQUUsR0FBRyxRQUFRLENBQUM7SUFDeEMsR0FBRyxDQUFDO0lBQ0osQ0FBQzs7SUM1QkQ7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLElBQUksVUFBVSxHQUFHLGVBQWUsQ0FBQyxhQUFhLENBQUMsQ0FBQzs7SUNoQmhEO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsVUFBVSxDQUFDLE1BQU0sRUFBRTtJQUM1QixFQUFFLE9BQU8sVUFBVSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDO0lBQ3BELENBQUM7O0lDcEJEO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsV0FBVyxDQUFDLEtBQUssRUFBRSxRQUFRLEVBQUUsV0FBVyxFQUFFLFNBQVMsRUFBRTtJQUM5RCxFQUFFLElBQUksS0FBSyxHQUFHLENBQUMsQ0FBQztJQUNoQixNQUFNLE1BQU0sR0FBRyxLQUFLLElBQUksSUFBSSxHQUFHLENBQUMsR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDOztJQUVoRCxFQUFFLElBQUksU0FBUyxJQUFJLE1BQU0sRUFBRTtJQUMzQixJQUFJLFdBQVcsR0FBRyxLQUFLLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQztJQUNqQyxHQUFHO0lBQ0gsRUFBRSxPQUFPLEVBQUUsS0FBSyxHQUFHLE1BQU0sRUFBRTtJQUMzQixJQUFJLFdBQVcsR0FBRyxRQUFRLENBQUMsV0FBVyxFQUFFLEtBQUssQ0FBQyxLQUFLLENBQUMsRUFBRSxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFDcEUsR0FBRztJQUNILEVBQUUsT0FBTyxXQUFXLENBQUM7SUFDckIsQ0FBQzs7SUN2QkQ7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLGNBQWMsQ0FBQyxNQUFNLEVBQUU7SUFDaEMsRUFBRSxPQUFPLFNBQVMsR0FBRyxFQUFFO0lBQ3ZCLElBQUksT0FBTyxNQUFNLElBQUksSUFBSSxHQUFHLFNBQVMsR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDcEQsR0FBRyxDQUFDO0lBQ0osQ0FBQzs7SUNURDtJQUNBLElBQUksZUFBZSxHQUFHO0lBQ3RCO0lBQ0EsRUFBRSxNQUFNLEVBQUUsR0FBRyxHQUFHLE1BQU0sRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLEdBQUc7SUFDL0UsRUFBRSxNQUFNLEVBQUUsR0FBRyxHQUFHLE1BQU0sRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLEdBQUc7SUFDL0UsRUFBRSxNQUFNLEVBQUUsR0FBRyxHQUFHLE1BQU0sRUFBRSxHQUFHO0lBQzNCLEVBQUUsTUFBTSxFQUFFLEdBQUcsR0FBRyxNQUFNLEVBQUUsR0FBRztJQUMzQixFQUFFLE1BQU0sRUFBRSxHQUFHLEdBQUcsTUFBTSxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxHQUFHO0lBQ3JELEVBQUUsTUFBTSxFQUFFLEdBQUcsR0FBRyxNQUFNLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLEdBQUc7SUFDckQsRUFBRSxNQUFNLEVBQUUsR0FBRyxHQUFHLE1BQU0sRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsR0FBRztJQUNyRCxFQUFFLE1BQU0sRUFBRSxHQUFHLEdBQUcsTUFBTSxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxHQUFHO0lBQ3JELEVBQUUsTUFBTSxFQUFFLEdBQUcsR0FBRyxNQUFNLEVBQUUsR0FBRztJQUMzQixFQUFFLE1BQU0sRUFBRSxHQUFHLEdBQUcsTUFBTSxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsR0FBRztJQUMvRSxFQUFFLE1BQU0sRUFBRSxHQUFHLEdBQUcsTUFBTSxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsR0FBRztJQUMvRSxFQUFFLE1BQU0sRUFBRSxHQUFHLEdBQUcsTUFBTSxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxHQUFHO0lBQ3JELEVBQUUsTUFBTSxFQUFFLEdBQUcsR0FBRyxNQUFNLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLEdBQUc7SUFDckQsRUFBRSxNQUFNLEVBQUUsR0FBRyxHQUFHLE1BQU0sRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLEdBQUc7SUFDeEMsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxJQUFJO0lBQzVCLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsSUFBSTtJQUM1QixFQUFFLE1BQU0sRUFBRSxJQUFJO0lBQ2Q7SUFDQSxFQUFFLFFBQVEsRUFBRSxHQUFHLEdBQUcsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRztJQUM5QyxFQUFFLFFBQVEsRUFBRSxHQUFHLEdBQUcsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRztJQUM5QyxFQUFFLFFBQVEsRUFBRSxHQUFHLEdBQUcsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHO0lBQzdELEVBQUUsUUFBUSxFQUFFLEdBQUcsR0FBRyxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUc7SUFDN0QsRUFBRSxRQUFRLEVBQUUsR0FBRyxHQUFHLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRztJQUM3RCxFQUFFLFFBQVEsRUFBRSxHQUFHLEdBQUcsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUc7SUFDNUUsRUFBRSxRQUFRLEVBQUUsR0FBRyxHQUFHLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHO0lBQzVFLEVBQUUsUUFBUSxFQUFFLEdBQUcsR0FBRyxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUc7SUFDN0QsRUFBRSxRQUFRLEVBQUUsR0FBRyxHQUFHLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRztJQUM3RCxFQUFFLFFBQVEsRUFBRSxHQUFHLEdBQUcsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHO0lBQzdELEVBQUUsUUFBUSxFQUFFLEdBQUcsR0FBRyxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRztJQUM1RSxFQUFFLFFBQVEsRUFBRSxHQUFHLEdBQUcsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUc7SUFDNUUsRUFBRSxRQUFRLEVBQUUsR0FBRyxHQUFHLFFBQVEsRUFBRSxHQUFHO0lBQy9CLEVBQUUsUUFBUSxFQUFFLEdBQUcsR0FBRyxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHO0lBQzlDLEVBQUUsUUFBUSxFQUFFLEdBQUcsR0FBRyxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRztJQUM1RSxFQUFFLFFBQVEsRUFBRSxHQUFHLEdBQUcsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUc7SUFDNUUsRUFBRSxRQUFRLEVBQUUsR0FBRyxHQUFHLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRztJQUM3RCxFQUFFLFFBQVEsRUFBRSxHQUFHLEdBQUcsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHO0lBQzdELEVBQUUsUUFBUSxFQUFFLEdBQUcsR0FBRyxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHO0lBQzlDLEVBQUUsUUFBUSxFQUFFLEdBQUcsR0FBRyxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHO0lBQzlDLEVBQUUsUUFBUSxFQUFFLEdBQUcsR0FBRyxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHO0lBQzlDLEVBQUUsUUFBUSxFQUFFLEdBQUcsR0FBRyxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHO0lBQzlDLEVBQUUsUUFBUSxFQUFFLEdBQUcsR0FBRyxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUc7SUFDN0QsRUFBRSxRQUFRLEVBQUUsR0FBRyxHQUFHLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRztJQUM3RCxFQUFFLFFBQVEsRUFBRSxHQUFHLEdBQUcsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRztJQUM5QyxFQUFFLFFBQVEsRUFBRSxHQUFHLEdBQUcsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRztJQUM5QyxFQUFFLFFBQVEsRUFBRSxHQUFHLEdBQUcsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRztJQUMzRixFQUFFLFFBQVEsRUFBRSxHQUFHLEdBQUcsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRztJQUMzRixFQUFFLFFBQVEsRUFBRSxHQUFHLEdBQUcsUUFBUSxFQUFFLEdBQUc7SUFDL0IsRUFBRSxRQUFRLEVBQUUsR0FBRyxHQUFHLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUc7SUFDOUMsRUFBRSxRQUFRLEVBQUUsR0FBRyxHQUFHLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFB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QUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDaEQsTUFBTSxLQUFLLENBQUMsRUFBRSxPQUFPLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDekQsTUFBTSxLQUFLLENBQUMsRUFBRSxPQUFPLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2xFLE1BQU0sS0FBSyxDQUFDLEVBQUUsT0FBTyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDM0UsTUFBTSxLQUFLLENBQUMsRUFBRSxPQUFPLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDcEYsTUFBTSxLQUFLLENBQUMsRUFBRSxPQUFPLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENB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SUFFRCxTQUFTc3RCLElBQVQsQ0FBYzNkLEVBQWQsRUFBa0I7SUFDZDRkLGVBQWE1ZCxFQUFiO0lBQ0EsU0FBT3FnQixVQUFVcmdCLEVBQVYsQ0FBUDtJQUNIOztJQUVELFNBQVMrTSxLQUFULENBQWV4YyxRQUFmLEVBQXlCRixZQUF6QixFQUF1QztJQUNuQyxTQUFPZ3dCLFVBQVVqMUIsV0FBV21GLFFBQVgsRUFBcUJGLFlBQXJCLENBQVYsSUFBZ0RFLFFBQXZEO0lBQ0g7O0FBRUQsSUFBZSxTQUFTa3dCLElBQVQsQ0FBY3B3QixZQUFkLEVBQTRCRSxRQUE1QixFQUFzQztJQUNqRCxTQUFPLElBQUk1SyxPQUFKLENBQVksVUFBQ3NGLE9BQUQsRUFBVUMsTUFBVixFQUFxQjtJQUNwQyxhQUFTNHlCLFFBQVQsQ0FBa0JBLFFBQWxCLEVBQTRCcGYsUUFBNUIsRUFBc0M7SUFDbEMsYUFBT29mLFNBQVNwZixRQUFULENBQVA7SUFDSDtJQUVEOGhCLFlBQVF6QyxLQUFLeHRCLFFBQUwsRUFBZSxvQkFBWTtJQUMvQixhQUFPQSxTQUFTd3RCLEtBQUs5eUIsT0FBTCxFQUFjNnlCLFFBQWQsQ0FBVCxFQUFrQ0MsS0FBSzd5QixNQUFMLEVBQWE0eUIsUUFBYixDQUFsQyxDQUFQO0lBQ0gsS0FGTyxDQUFSLEVBRUl6dEIsWUFGSjtJQUdILEdBUk0sQ0FBUDtJQVVBLFNBQU93dEIsUUFBUUcsT0FBUixDQUFnQkwsSUFBaEIsRUFBc0JBLElBQXRCLENBQVA7SUFDSDtJQUdEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMUJBLGVBQWVud0IsYUFBYUMsR0FBYixDQUFpQjtJQUU1QmUsU0FGNEIsbUJBRXBCbkwsR0FGb0IsRUFFZjtJQUNUbUssaUJBQWFHLE9BQWIsQ0FBcUJ0SyxHQUFyQixFQUEwQnNLLFNBQTFCO0lBQ0FILGlCQUFhSSxPQUFiLENBQXFCdkssR0FBckIsRUFBMEJ1SyxPQUExQjtJQUNBSixpQkFBYVEsVUFBYixDQUF3QjNLLEdBQXhCLEVBQTZCMkssWUFBN0I7SUFDQVIsaUJBQWFNLFVBQWIsQ0FBd0J6SyxHQUF4QixFQUE2QnlLLFlBQTdCO0lBQ0g7SUFQMkIsQ0FBakIsQ0FBZjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OyJ9
