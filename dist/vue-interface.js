(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('moment'), require('axios')) :
    typeof define === 'function' && define.amd ? define(['exports', 'moment', 'axios'], factory) :
    (factory((global.VueInterface = {}),global.moment,global.axios));
}(this, (function (exports,moment,axios) { 'use strict';

    moment = moment && moment.hasOwnProperty('default') ? moment['default'] : moment;
    axios = axios && axios.hasOwnProperty('default') ? axios['default'] : axios;

    function DateFilter (value, format) {
      if (value) {
        return moment(String(value)).format(format);
      }

      return '';
    }

    function MomentFilter (value, format) {
      return value ? moment(String(value)) : null;
    }

    function index (Vue, options) {
      Vue.filter('date', DateFilter);
      Vue.filter('moment', MomentFilter);
    }



    var filters = /*#__PURE__*/Object.freeze({
        DateFilter: index,
        MomentFilter: index
    });

    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == 'object' || type == 'function');
    }

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
    var isArray = Array.isArray;

    var global$1 = typeof global !== "undefined" ? global :
                typeof self !== "undefined" ? self :
                typeof window !== "undefined" ? window : {}

    /** Detect free variable `global` from Node.js. */
    var freeGlobal = typeof global$1 == 'object' && global$1 && global$1.Object === Object && global$1;

    /** Detect free variable `self`. */
    var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

    /** Used as a reference to the global object. */
    var root = freeGlobal || freeSelf || Function('return this')();

    /** Built-in value references. */
    var Symbol$1 = root.Symbol;

    /** Used for built-in method references. */
    var objectProto = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString = objectProto.toString;

    /** Built-in value references. */
    var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;

    /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag),
          tag = value[symToStringTag];

      try {
        value[symToStringTag] = undefined;
        var unmasked = true;
      } catch (e) {}

      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }

    /** Used for built-in method references. */
    var objectProto$1 = Object.prototype;

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString$1 = objectProto$1.toString;

    /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */
    function objectToString(value) {
      return nativeObjectToString$1.call(value);
    }

    /** `Object#toString` result references. */
    var nullTag = '[object Null]',
        undefinedTag = '[object Undefined]';

    /** Built-in value references. */
    var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;

    /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    function baseGetTag(value) {
      if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
      }
      return (symToStringTag$1 && symToStringTag$1 in Object(value))
        ? getRawTag(value)
        : objectToString(value);
    }

    /** `Object#toString` result references. */
    var asyncTag = '[object AsyncFunction]',
        funcTag = '[object Function]',
        genTag = '[object GeneratorFunction]',
        proxyTag = '[object Proxy]';

    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction$1(value) {
      if (!isObject(value)) {
        return false;
      }
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 9 which returns 'object' for typed arrays and other constructors.
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }

    /** Used to detect overreaching core-js shims. */
    var coreJsData = root['__core-js_shared__'];

    /** Used to detect methods masquerading as native. */
    var maskSrcKey = (function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
      return uid ? ('Symbol(src)_1.' + uid) : '';
    }());

    /**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */
    function isMasked(func) {
      return !!maskSrcKey && (maskSrcKey in func);
    }

    /** Used for built-in method references. */
    var funcProto = Function.prototype;

    /** Used to resolve the decompiled source of functions. */
    var funcToString = funcProto.toString;

    /**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to convert.
     * @returns {string} Returns the source code.
     */
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {}
        try {
          return (func + '');
        } catch (e) {}
      }
      return '';
    }

    /**
     * Used to match `RegExp`
     * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
     */
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

    /** Used to detect host constructors (Safari). */
    var reIsHostCtor = /^\[object .+?Constructor\]$/;

    /** Used for built-in method references. */
    var funcProto$1 = Function.prototype,
        objectProto$2 = Object.prototype;

    /** Used to resolve the decompiled source of functions. */
    var funcToString$1 = funcProto$1.toString;

    /** Used to check objects for own properties. */
    var hasOwnProperty$1 = objectProto$2.hasOwnProperty;

    /** Used to detect if a method is native. */
    var reIsNative = RegExp('^' +
      funcToString$1.call(hasOwnProperty$1).replace(reRegExpChar, '\\$&')
      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
    );

    /**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction$1(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }

    /**
     * Gets the value at `key` of `object`.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */
    function getValue(object, key) {
      return object == null ? undefined : object[key];
    }

    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : undefined;
    }

    var defineProperty = (function() {
      try {
        var func = getNative(Object, 'defineProperty');
        func({}, '', {});
        return func;
      } catch (e) {}
    }());

    /**
     * The base implementation of `assignValue` and `assignMergeValue` without
     * value checks.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function baseAssignValue(object, key, value) {
      if (key == '__proto__' && defineProperty) {
        defineProperty(object, key, {
          'configurable': true,
          'enumerable': true,
          'value': value,
          'writable': true
        });
      } else {
        object[key] = value;
      }
    }

    /**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */
    function eq(value, other) {
      return value === other || (value !== value && other !== other);
    }

    /** Used for built-in method references. */
    var objectProto$3 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$2 = objectProto$3.hasOwnProperty;

    /**
     * Assigns `value` to `key` of `object` if the existing value is not equivalent
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty$2.call(object, key) && eq(objValue, value)) ||
          (value === undefined && !(key in object))) {
        baseAssignValue(object, key, value);
      }
    }

    /**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property identifiers to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Function} [customizer] The function to customize copied values.
     * @returns {Object} Returns `object`.
     */
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});

      var index = -1,
          length = props.length;

      while (++index < length) {
        var key = props[index];

        var newValue = customizer
          ? customizer(object[key], source[key], key, object, source)
          : undefined;

        if (newValue === undefined) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }

    /**
     * This method returns the first argument it receives.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'a': 1 };
     *
     * console.log(_.identity(object) === object);
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * A faster alternative to `Function#apply`, this function invokes `func`
     * with the `this` binding of `thisArg` and the arguments of `args`.
     *
     * @private
     * @param {Function} func The function to invoke.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} args The arguments to invoke `func` with.
     * @returns {*} Returns the result of `func`.
     */
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0: return func.call(thisArg);
        case 1: return func.call(thisArg, args[0]);
        case 2: return func.call(thisArg, args[0], args[1]);
        case 3: return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeMax = Math.max;

    /**
     * A specialized version of `baseRest` which transforms the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @param {Function} transform The rest array transform.
     * @returns {Function} Returns the new function.
     */
    function overRest(func, start, transform) {
      start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
      return function() {
        var args = arguments,
            index = -1,
            length = nativeMax(args.length - start, 0),
            array = Array(length);

        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new constant function.
     * @example
     *
     * var objects = _.times(2, _.constant({ 'a': 1 }));
     *
     * console.log(objects);
     * // => [{ 'a': 1 }, { 'a': 1 }]
     *
     * console.log(objects[0] === objects[1]);
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    /**
     * The base implementation of `setToString` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
    var baseSetToString = !defineProperty ? identity : function(func, string) {
      return defineProperty(func, 'toString', {
        'configurable': true,
        'enumerable': false,
        'value': constant(string),
        'writable': true
      });
    };

    /** Used to detect hot functions by number of calls within a span of milliseconds. */
    var HOT_COUNT = 800,
        HOT_SPAN = 16;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeNow = Date.now;

    /**
     * Creates a function that'll short out and invoke `identity` instead
     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
     * milliseconds.
     *
     * @private
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new shortable function.
     */
    function shortOut(func) {
      var count = 0,
          lastCalled = 0;

      return function() {
        var stamp = nativeNow(),
            remaining = HOT_SPAN - (stamp - lastCalled);

        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(undefined, arguments);
      };
    }

    /**
     * Sets the `toString` method of `func` to return `string`.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
    var setToString = shortOut(baseSetToString);

    /**
     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     */
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + '');
    }

    /** Used as references for various `Number` constants. */
    var MAX_SAFE_INTEGER = 9007199254740991;

    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */
    function isLength(value) {
      return typeof value == 'number' &&
        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction$1(value);
    }

    /** Used as references for various `Number` constants. */
    var MAX_SAFE_INTEGER$1 = 9007199254740991;

    /** Used to detect unsigned integer values. */
    var reIsUint = /^(?:0|[1-9]\d*)$/;

    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER$1 : length;

      return !!length &&
        (type == 'number' ||
          (type != 'symbol' && reIsUint.test(value))) &&
            (value > -1 && value % 1 == 0 && value < length);
    }

    /**
     * Checks if the given arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
     *  else `false`.
     */
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == 'number'
            ? (isArrayLike(object) && isIndex(index, object.length))
            : (type == 'string' && index in object)
          ) {
        return eq(object[index], value);
      }
      return false;
    }

    /**
     * Creates a function like `_.assign`.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1,
            length = sources.length,
            customizer = length > 1 ? sources[length - 1] : undefined,
            guard = length > 2 ? sources[2] : undefined;

        customizer = (assigner.length > 3 && typeof customizer == 'function')
          ? (length--, customizer)
          : undefined;

        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? undefined : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }

    /**
     * The base implementation of `_.times` without support for iteratee shorthands
     * or max array length checks.
     *
     * @private
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     */
    function baseTimes(n, iteratee) {
      var index = -1,
          result = Array(n);

      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }

    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return value != null && typeof value == 'object';
    }

    /** `Object#toString` result references. */
    var argsTag = '[object Arguments]';

    /**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }

    /** Used for built-in method references. */
    var objectProto$4 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$3 = objectProto$4.hasOwnProperty;

    /** Built-in value references. */
    var propertyIsEnumerable = objectProto$4.propertyIsEnumerable;

    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty$3.call(value, 'callee') &&
        !propertyIsEnumerable.call(value, 'callee');
    };

    /**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */
    function stubFalse() {
      return false;
    }

    /** Detect free variable `exports`. */
    var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

    /** Detect free variable `module`. */
    var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

    /** Detect the popular CommonJS extension `module.exports`. */
    var moduleExports = freeModule && freeModule.exports === freeExports;

    /** Built-in value references. */
    var Buffer = moduleExports ? root.Buffer : undefined;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */
    var isBuffer = nativeIsBuffer || stubFalse;

    /** `Object#toString` result references. */
    var argsTag$1 = '[object Arguments]',
        arrayTag = '[object Array]',
        boolTag = '[object Boolean]',
        dateTag = '[object Date]',
        errorTag = '[object Error]',
        funcTag$1 = '[object Function]',
        mapTag = '[object Map]',
        numberTag = '[object Number]',
        objectTag = '[object Object]',
        regexpTag = '[object RegExp]',
        setTag = '[object Set]',
        stringTag = '[object String]',
        weakMapTag = '[object WeakMap]';

    var arrayBufferTag = '[object ArrayBuffer]',
        dataViewTag = '[object DataView]',
        float32Tag = '[object Float32Array]',
        float64Tag = '[object Float64Array]',
        int8Tag = '[object Int8Array]',
        int16Tag = '[object Int16Array]',
        int32Tag = '[object Int32Array]',
        uint8Tag = '[object Uint8Array]',
        uint8ClampedTag = '[object Uint8ClampedArray]',
        uint16Tag = '[object Uint16Array]',
        uint32Tag = '[object Uint32Array]';

    /** Used to identify `toStringTag` values of typed arrays. */
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
    typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
    typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
    typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
    typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag$1] = typedArrayTags[arrayTag] =
    typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
    typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
    typedArrayTags[errorTag] = typedArrayTags[funcTag$1] =
    typedArrayTags[mapTag] = typedArrayTags[numberTag] =
    typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
    typedArrayTags[setTag] = typedArrayTags[stringTag] =
    typedArrayTags[weakMapTag] = false;

    /**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */
    function baseIsTypedArray(value) {
      return isObjectLike(value) &&
        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }

    /**
     * The base implementation of `_.unary` without support for storing metadata.
     *
     * @private
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     */
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }

    /** Detect free variable `exports`. */
    var freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;

    /** Detect free variable `module`. */
    var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;

    /** Detect the popular CommonJS extension `module.exports`. */
    var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;

    /** Detect free variable `process` from Node.js. */
    var freeProcess = moduleExports$1 && freeGlobal.process;

    /** Used to access faster Node.js helpers. */
    var nodeUtil = (function() {
      try {
        return freeProcess && freeProcess.binding && freeProcess.binding('util');
      } catch (e) {}
    }());

    /* Node.js helper references. */
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

    /** Used for built-in method references. */
    var objectProto$5 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$4 = objectProto$5.hasOwnProperty;

    /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value),
          isArg = !isArr && isArguments(value),
          isBuff = !isArr && !isArg && isBuffer(value),
          isType = !isArr && !isArg && !isBuff && isTypedArray(value),
          skipIndexes = isArr || isArg || isBuff || isType,
          result = skipIndexes ? baseTimes(value.length, String) : [],
          length = result.length;

      for (var key in value) {
        if ((inherited || hasOwnProperty$4.call(value, key)) &&
            !(skipIndexes && (
               // Safari 9 has enumerable `arguments.length` in strict mode.
               key == 'length' ||
               // Node.js 0.10 has enumerable non-index properties on buffers.
               (isBuff && (key == 'offset' || key == 'parent')) ||
               // PhantomJS 2 has enumerable non-index properties on typed arrays.
               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
               // Skip index properties.
               isIndex(key, length)
            ))) {
          result.push(key);
        }
      }
      return result;
    }

    /** Used for built-in method references. */
    var objectProto$6 = Object.prototype;

    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */
    function isPrototype(value) {
      var Ctor = value && value.constructor,
          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$6;

      return value === proto;
    }

    /**
     * This function is like
     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * except that it includes inherited enumerable properties.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }

    /** Used for built-in method references. */
    var objectProto$7 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$5 = objectProto$7.hasOwnProperty;

    /**
     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object),
          result = [];

      for (var key in object) {
        if (!(key == 'constructor' && (isProto || !hasOwnProperty$5.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */
    function keysIn$1(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }

    /**
     * This method is like `_.assign` except that it iterates over own and
     * inherited source properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assign
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
     */
    var assignIn = createAssigner(function(object, source) {
      copyObject(source, keysIn$1(source), object);
    });

    /**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }

    /**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }

    /** Used for built-in method references. */
    var arrayProto = Array.prototype;

    /** Built-in value references. */
    var splice = arrayProto.splice;

    /**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function listCacheDelete(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }

    /**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function listCacheGet(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      return index < 0 ? undefined : data[index][1];
    }

    /**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }

    /**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */
    function listCacheSet(key, value) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }

    /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function ListCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    // Add methods to `ListCache`.
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype['delete'] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;

    /**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */
    function stackClear() {
      this.__data__ = new ListCache;
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function stackDelete(key) {
      var data = this.__data__,
          result = data['delete'](key);

      this.size = data.size;
      return result;
    }

    /**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function stackGet(key) {
      return this.__data__.get(key);
    }

    /**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function stackHas(key) {
      return this.__data__.has(key);
    }

    /* Built-in method references that are verified to be native. */
    var Map$1 = getNative(root, 'Map');

    /* Built-in method references that are verified to be native. */
    var nativeCreate = getNative(Object, 'create');

    /**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }

    /** Used to stand-in for `undefined` hash values. */
    var HASH_UNDEFINED = '__lodash_hash_undefined__';

    /** Used for built-in method references. */
    var objectProto$8 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$6 = objectProto$8.hasOwnProperty;

    /**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
      }
      return hasOwnProperty$6.call(data, key) ? data[key] : undefined;
    }

    /** Used for built-in method references. */
    var objectProto$9 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$7 = objectProto$9.hasOwnProperty;

    /**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? (data[key] !== undefined) : hasOwnProperty$7.call(data, key);
    }

    /** Used to stand-in for `undefined` hash values. */
    var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

    /**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED$1 : value;
      return this;
    }

    /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Hash(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    // Add methods to `Hash`.
    Hash.prototype.clear = hashClear;
    Hash.prototype['delete'] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;

    /**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        'hash': new Hash,
        'map': new (Map$1 || ListCache),
        'string': new Hash
      };
    }

    /**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */
    function isKeyable(value) {
      var type = typeof value;
      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
        ? (value !== '__proto__')
        : (value === null);
    }

    /**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key)
        ? data[typeof key == 'string' ? 'string' : 'hash']
        : data.map;
    }

    /**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function mapCacheDelete(key) {
      var result = getMapData(this, key)['delete'](key);
      this.size -= result ? 1 : 0;
      return result;
    }

    /**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }

    /**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }

    /**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */
    function mapCacheSet(key, value) {
      var data = getMapData(this, key),
          size = data.size;

      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }

    /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function MapCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    // Add methods to `MapCache`.
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype['delete'] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;

    /** Used as the size to enable large array optimizations. */
    var LARGE_ARRAY_SIZE = 200;

    /**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map$1 || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }

    /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }

    // Add methods to `Stack`.
    Stack.prototype.clear = stackClear;
    Stack.prototype['delete'] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;

    /**
     * This function is like `assignValue` except that it doesn't assign
     * `undefined` values.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignMergeValue(object, key, value) {
      if ((value !== undefined && !eq(object[key], value)) ||
          (value === undefined && !(key in object))) {
        baseAssignValue(object, key, value);
      }
    }

    /**
     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1,
            iterable = Object(object),
            props = keysFunc(object),
            length = props.length;

        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }

    /**
     * The base implementation of `baseForOwn` which iterates over `object`
     * properties returned by `keysFunc` and invokes `iteratee` for each property.
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseFor = createBaseFor();

    /** Detect free variable `exports`. */
    var freeExports$2 = typeof exports == 'object' && exports && !exports.nodeType && exports;

    /** Detect free variable `module`. */
    var freeModule$2 = freeExports$2 && typeof module == 'object' && module && !module.nodeType && module;

    /** Detect the popular CommonJS extension `module.exports`. */
    var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;

    /** Built-in value references. */
    var Buffer$1 = moduleExports$2 ? root.Buffer : undefined,
        allocUnsafe = Buffer$1 ? Buffer$1.allocUnsafe : undefined;

    /**
     * Creates a clone of  `buffer`.
     *
     * @private
     * @param {Buffer} buffer The buffer to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Buffer} Returns the cloned buffer.
     */
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length,
          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

      buffer.copy(result);
      return result;
    }

    /** Built-in value references. */
    var Uint8Array = root.Uint8Array;

    /**
     * Creates a clone of `arrayBuffer`.
     *
     * @private
     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array(result).set(new Uint8Array(arrayBuffer));
      return result;
    }

    /**
     * Creates a clone of `typedArray`.
     *
     * @private
     * @param {Object} typedArray The typed array to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned typed array.
     */
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }

    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function copyArray(source, array) {
      var index = -1,
          length = source.length;

      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }

    /** Built-in value references. */
    var objectCreate = Object.create;

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} proto The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    var baseCreate = (function() {
      function object() {}
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object;
        object.prototype = undefined;
        return result;
      };
    }());

    /**
     * Creates a unary function that invokes `func` with its argument transformed.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {Function} transform The argument transform.
     * @returns {Function} Returns the new function.
     */
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }

    /** Built-in value references. */
    var getPrototype = overArg(Object.getPrototypeOf, Object);

    /**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneObject(object) {
      return (typeof object.constructor == 'function' && !isPrototype(object))
        ? baseCreate(getPrototype(object))
        : {};
    }

    /**
     * This method is like `_.isArrayLike` except that it also checks if `value`
     * is an object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array-like object,
     *  else `false`.
     * @example
     *
     * _.isArrayLikeObject([1, 2, 3]);
     * // => true
     *
     * _.isArrayLikeObject(document.body.children);
     * // => true
     *
     * _.isArrayLikeObject('abc');
     * // => false
     *
     * _.isArrayLikeObject(_.noop);
     * // => false
     */
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }

    /** `Object#toString` result references. */
    var objectTag$1 = '[object Object]';

    /** Used for built-in method references. */
    var funcProto$2 = Function.prototype,
        objectProto$10 = Object.prototype;

    /** Used to resolve the decompiled source of functions. */
    var funcToString$2 = funcProto$2.toString;

    /** Used to check objects for own properties. */
    var hasOwnProperty$8 = objectProto$10.hasOwnProperty;

    /** Used to infer the `Object` constructor. */
    var objectCtorString = funcToString$2.call(Object);

    /**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * @static
     * @memberOf _
     * @since 0.8.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag$1) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty$8.call(proto, 'constructor') && proto.constructor;
      return typeof Ctor == 'function' && Ctor instanceof Ctor &&
        funcToString$2.call(Ctor) == objectCtorString;
    }

    /**
     * Gets the value at `key`, unless `key` is "__proto__".
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */
    function safeGet(object, key) {
      return key == '__proto__'
        ? undefined
        : object[key];
    }

    /**
     * Converts `value` to a plain object flattening inherited enumerable string
     * keyed properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */
    function toPlainObject(value) {
      return copyObject(value, keysIn$1(value));
    }

    /**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key),
          srcValue = safeGet(source, key),
          stacked = stack.get(srcValue);

      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer
        ? customizer(objValue, srcValue, (key + ''), object, source, stack)
        : undefined;

      var isCommon = newValue === undefined;

      if (isCommon) {
        var isArr = isArray(srcValue),
            isBuff = !isArr && isBuffer(srcValue),
            isTyped = !isArr && !isBuff && isTypedArray(srcValue);

        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          }
          else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          }
          else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          }
          else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          }
          else {
            newValue = [];
          }
        }
        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          }
          else if (!isObject(objValue) || (srcIndex && isFunction$1(objValue))) {
            newValue = initCloneObject(srcValue);
          }
        }
        else {
          isCommon = false;
        }
      }
      if (isCommon) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack['delete'](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }

    /**
     * The base implementation of `_.merge` without support for multiple sources.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        if (isObject(srcValue)) {
          stack || (stack = new Stack);
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        }
        else {
          var newValue = customizer
            ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
            : undefined;

          if (newValue === undefined) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn$1);
    }

    /**
     * This method is like `_.assign` except that it recursively merges own and
     * inherited enumerable string keyed properties of source objects into the
     * destination object. Source properties that resolve to `undefined` are
     * skipped if a destination value exists. Array and plain object properties
     * are merged recursively. Other objects and value types are overridden by
     * assignment. Source objects are applied from left to right. Subsequent
     * sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {
     *   'a': [{ 'b': 2 }, { 'd': 4 }]
     * };
     *
     * var other = {
     *   'a': [{ 'c': 3 }, { 'e': 5 }]
     * };
     *
     * _.merge(object, other);
     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
     */
    var merge = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });

    /**
     * A specialized version of `_.forEach` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns `array`.
     */
    function arrayEach(array, iteratee) {
      var index = -1,
          length = array == null ? 0 : array.length;

      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeKeys = overArg(Object.keys, Object);

    /** Used for built-in method references. */
    var objectProto$11 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$9 = objectProto$11.hasOwnProperty;

    /**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty$9.call(object, key) && key != 'constructor') {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }

    /**
     * The base implementation of `_.forOwn` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }

    /**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length,
            index = fromRight ? length : -1,
            iterable = Object(collection);

        while ((fromRight ? index-- : ++index < length)) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }

    /**
     * The base implementation of `_.forEach` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
    var baseEach = createBaseEach(baseForOwn);

    /**
     * Casts `value` to `identity` if it's not a function.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Function} Returns cast function.
     */
    function castFunction(value) {
      return typeof value == 'function' ? value : identity;
    }

    /**
     * Iterates over elements of `collection` and invokes `iteratee` for each element.
     * The iteratee is invoked with three arguments: (value, index|key, collection).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a "length"
     * property are iterated like arrays. To avoid this behavior use `_.forIn`
     * or `_.forOwn` for object iteration.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias each
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEachRight
     * @example
     *
     * _.forEach([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `1` then `2`.
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */
    function forEach(collection, iteratee) {
      var func = isArray(collection) ? arrayEach : baseEach;
      return func(collection, castFunction(iteratee));
    }

    function MergeClasses (Vue, options) {
      Vue.prototype.$mergeClasses = function () {
        var classes = {};

        forEach([].slice.call(arguments), function (arg) {
          if (isObject(arg)) {
            assignIn(classes, arg);
          } else if (isArray(arg)) {
            merge(classes, arg);
          } else if (arg) {
            classes[arg] = true;
          }
        });

        return classes;
      };
    }

    /**
     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
     * objects into destination objects that are passed thru.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to merge.
     * @param {Object} object The parent object of `objValue`.
     * @param {Object} source The parent object of `srcValue`.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     * @returns {*} Returns the value to assign.
     */
    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
      if (isObject(objValue) && isObject(srcValue)) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        stack.set(srcValue, objValue);
        baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);
        stack['delete'](srcValue);
      }
      return objValue;
    }

    /**
     * This method is like `_.merge` except that it accepts `customizer` which
     * is invoked to produce the merged values of the destination and source
     * properties. If `customizer` returns `undefined`, merging is handled by the
     * method instead. The `customizer` is invoked with six arguments:
     * (objValue, srcValue, key, object, source, stack).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   if (_.isArray(objValue)) {
     *     return objValue.concat(srcValue);
     *   }
     * }
     *
     * var object = { 'a': [1], 'b': [2] };
     * var other = { 'a': [3], 'b': [4] };
     *
     * _.mergeWith(object, other, customizer);
     * // => { 'a': [1, 3], 'b': [2, 4] }
     */
    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
      baseMerge(object, source, srcIndex, customizer);
    });

    /**
     * This method is like `_.defaults` except that it recursively assigns
     * default properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaults
     * @example
     *
     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
     * // => { 'a': { 'b': 2, 'c': 3 } }
     */
    var defaultsDeep = baseRest(function(args) {
      args.push(undefined, customDefaultsMerge);
      return apply(mergeWith, undefined, args);
    });

    /** `Object#toString` result references. */
    var stringTag$1 = '[object String]';

    /**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */
    function isString(value) {
      return typeof value == 'string' ||
        (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag$1);
    }

    /**
     * A specialized version of `_.reduce` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {boolean} [initAccum] Specify using the first element of `array` as
     *  the initial value.
     * @returns {*} Returns the accumulated value.
     */
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1,
          length = array == null ? 0 : array.length;

      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }

    /**
     * The base implementation of `_.propertyOf` without support for deep paths.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new accessor function.
     */
    function basePropertyOf(object) {
      return function(key) {
        return object == null ? undefined : object[key];
      };
    }

    /** Used to map Latin Unicode letters to basic Latin letters. */
    var deburredLetters = {
      // Latin-1 Supplement block.
      '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
      '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
      '\xc7': 'C',  '\xe7': 'c',
      '\xd0': 'D',  '\xf0': 'd',
      '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
      '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
      '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
      '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
      '\xd1': 'N',  '\xf1': 'n',
      '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
      '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
      '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
      '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
      '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
      '\xc6': 'Ae', '\xe6': 'ae',
      '\xde': 'Th', '\xfe': 'th',
      '\xdf': 'ss',
      // Latin Extended-A block.
      '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
      '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
      '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
      '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
      '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
      '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
      '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
      '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
      '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
      '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
      '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
      '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
      '\u0134': 'J',  '\u0135': 'j',
      '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
      '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
      '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
      '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
      '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
      '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
      '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
      '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
      '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
      '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
      '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
      '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
      '\u0163': 't',  '\u0165': 't', '\u0167': 't',
      '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
      '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
      '\u0174': 'W',  '\u0175': 'w',
      '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
      '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
      '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
      '\u0132': 'IJ', '\u0133': 'ij',
      '\u0152': 'Oe', '\u0153': 'oe',
      '\u0149': "'n", '\u017f': 's'
    };

    /**
     * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
     * letters to basic Latin letters.
     *
     * @private
     * @param {string} letter The matched letter to deburr.
     * @returns {string} Returns the deburred letter.
     */
    var deburrLetter = basePropertyOf(deburredLetters);

    /**
     * A specialized version of `_.map` for arrays without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function arrayMap(array, iteratee) {
      var index = -1,
          length = array == null ? 0 : array.length,
          result = Array(length);

      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }

    /** `Object#toString` result references. */
    var symbolTag = '[object Symbol]';

    /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */
    function isSymbol(value) {
      return typeof value == 'symbol' ||
        (isObjectLike(value) && baseGetTag(value) == symbolTag);
    }

    /** Used as references for various `Number` constants. */
    var INFINITY = 1 / 0;

    /** Used to convert symbols to primitives and strings. */
    var symbolProto = Symbol$1 ? Symbol$1.prototype : undefined,
        symbolToString = symbolProto ? symbolProto.toString : undefined;

    /**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */
    function baseToString(value) {
      // Exit early for strings to avoid a performance hit in some environments.
      if (typeof value == 'string') {
        return value;
      }
      if (isArray(value)) {
        // Recursively convert values (susceptible to call stack limits).
        return arrayMap(value, baseToString) + '';
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : '';
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }

    /**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */
    function toString(value) {
      return value == null ? '' : baseToString(value);
    }

    /** Used to match Latin Unicode letters (excluding mathematical operators). */
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

    /** Used to compose unicode character classes. */
    var rsComboMarksRange = '\\u0300-\\u036f',
        reComboHalfMarksRange = '\\ufe20-\\ufe2f',
        rsComboSymbolsRange = '\\u20d0-\\u20ff',
        rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;

    /** Used to compose unicode capture groups. */
    var rsCombo = '[' + rsComboRange + ']';

    /**
     * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
     * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
     */
    var reComboMark = RegExp(rsCombo, 'g');

    /**
     * Deburrs `string` by converting
     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
     * letters to basic Latin letters and removing
     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('déjà vu');
     * // => 'deja vu'
     */
    function deburr(string) {
      string = toString(string);
      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
    }

    /** Used to match words composed of alphanumeric characters. */
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

    /**
     * Splits an ASCII `string` into an array of its words.
     *
     * @private
     * @param {string} The string to inspect.
     * @returns {Array} Returns the words of `string`.
     */
    function asciiWords(string) {
      return string.match(reAsciiWord) || [];
    }

    /** Used to detect strings that need a more robust regexp to match words. */
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

    /**
     * Checks if `string` contains a word composed of Unicode symbols.
     *
     * @private
     * @param {string} string The string to inspect.
     * @returns {boolean} Returns `true` if a word is found, else `false`.
     */
    function hasUnicodeWord(string) {
      return reHasUnicodeWord.test(string);
    }

    /** Used to compose unicode character classes. */
    var rsAstralRange = '\\ud800-\\udfff',
        rsComboMarksRange$1 = '\\u0300-\\u036f',
        reComboHalfMarksRange$1 = '\\ufe20-\\ufe2f',
        rsComboSymbolsRange$1 = '\\u20d0-\\u20ff',
        rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1,
        rsDingbatRange = '\\u2700-\\u27bf',
        rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
        rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
        rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
        rsPunctuationRange = '\\u2000-\\u206f',
        rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
        rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
        rsVarRange = '\\ufe0e\\ufe0f',
        rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

    /** Used to compose unicode capture groups. */
    var rsApos = "['\u2019]",
        rsBreak = '[' + rsBreakRange + ']',
        rsCombo$1 = '[' + rsComboRange$1 + ']',
        rsDigits = '\\d+',
        rsDingbat = '[' + rsDingbatRange + ']',
        rsLower = '[' + rsLowerRange + ']',
        rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
        rsFitz = '\\ud83c[\\udffb-\\udfff]',
        rsModifier = '(?:' + rsCombo$1 + '|' + rsFitz + ')',
        rsNonAstral = '[^' + rsAstralRange + ']',
        rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
        rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
        rsUpper = '[' + rsUpperRange + ']',
        rsZWJ = '\\u200d';

    /** Used to compose unicode regexes. */
    var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
        rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
        rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
        rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
        reOptMod = rsModifier + '?',
        rsOptVar = '[' + rsVarRange + ']?',
        rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
        rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
        rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
        rsSeq = rsOptVar + reOptMod + rsOptJoin,
        rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq;

    /** Used to match complex or compound words. */
    var reUnicodeWord = RegExp([
      rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
      rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
      rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
      rsUpper + '+' + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join('|'), 'g');

    /**
     * Splits a Unicode `string` into an array of its words.
     *
     * @private
     * @param {string} The string to inspect.
     * @returns {Array} Returns the words of `string`.
     */
    function unicodeWords(string) {
      return string.match(reUnicodeWord) || [];
    }

    /**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */
    function words(string, pattern, guard) {
      string = toString(string);
      pattern = guard ? undefined : pattern;

      if (pattern === undefined) {
        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
      }
      return string.match(pattern) || [];
    }

    /** Used to compose unicode capture groups. */
    var rsApos$1 = "['\u2019]";

    /** Used to match apostrophes. */
    var reApos = RegExp(rsApos$1, 'g');

    /**
     * Creates a function like `_.camelCase`.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */
    function createCompounder(callback) {
      return function(string) {
        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
      };
    }

    /**
     * Converts `string` to
     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__FOO_BAR__');
     * // => 'foo-bar'
     */
    var kebabCase = createCompounder(function(result, word, index) {
      return result + (index ? '-' : '') + word.toLowerCase();
    });

    var BaseType = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "activity-indicator",
          class: _vm.classes
        }, _vm._l(_vm.nodes, function (i) {
          return _c('div');
        }));
      },
      staticRenderFns: [],
      props: {
        nodes: {
          type: Number,
          default: 3
        },
        size: {
          type: String,
          default: ''
        },
        prefix: {
          type: String,
          default: 'activity-indicator-'
        }
      },
      computed: {
        classes: function classes() {
          var classes = {};
          classes[this.$options.name] = !!this.$options.name;
          classes[this.prefix + this.size.replace(this.prefix, '')] = !!this.size;
          return classes;
        }
      }
    };

    var ActivityIndicatorDots = {
      name: 'activity-indicator-dots',
      extends: BaseType
    };

    var ActivityIndicatorSpinner = {
      name: 'activity-indicator-spinner',
      extends: BaseType,
      props: assignIn({}, BaseType.props, {
        nodes: {
          type: Number,
          default: 12
        }
      })
    };

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeIsFinite = root.isFinite;

    /**
     * Checks if `value` is a finite primitive number.
     *
     * **Note:** This method is based on
     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
     * @example
     *
     * _.isFinite(3);
     * // => true
     *
     * _.isFinite(Number.MIN_VALUE);
     * // => true
     *
     * _.isFinite(Infinity);
     * // => false
     *
     * _.isFinite('3');
     * // => false
     */
    function isFinite$1(value) {
      return typeof value == 'number' && nativeIsFinite(value);
    }

    function unit (height) {
      return isFinite$1(height) ? height + 'px' : height;
    }

    var ActivityIndicator = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _vm.center ? _c('div', {
          staticClass: "center-wrapper",
          class: {
            'position-relative': _vm.relative,
            'position-fixed': _vm.fixed
          },
          style: {
            minHeight: _vm.unit(this.minHeight),
            minWidth: _vm.unit(this.minWidth)
          }
        }, [_c('div', {
          staticClass: "center-content"
        }, [_c(_vm.component, {
          tag: "component",
          attrs: {
            "size": _vm.size,
            "prefix": _vm.prefix
          }
        })], 1)]) : _c(_vm.component, {
          tag: "component",
          style: {
            minHeight: _vm.unit(this.minHeight),
            minWidth: _vm.unit(this.minWidth)
          },
          attrs: {
            "size": _vm.size,
            "prefix": _vm.prefix
          }
        });
      },
      staticRenderFns: [],
      name: 'activity-indicator',
      extends: BaseType,
      props: {
        center: Boolean,
        fixed: Boolean,
        relative: Boolean,
        type: {
          type: String,
          default: 'dots'
        },
        minHeight: [String, Number],
        minWidth: [String, Number]
      },
      components: {
        ActivityIndicatorDots: ActivityIndicatorDots,
        ActivityIndicatorSpinner: ActivityIndicatorSpinner
      },
      methods: {
        unit: function unit$$1(value) {
          return unit(value);
        }
      },
      computed: {
        component: function component() {
          return kebabCase(this.prefix + this.type.replace(this.prefix, ''));
        }
      }
    };

    var loaded = {};

    function element(url) {
      var script = document.createElement('script');
      script.setAttribute('src', url);
      script.setAttribute('type', 'text/javascript');
      script.setAttribute('charset', 'utf-8');
      return script;
    }

    function append(script) {
      if (document.querySelector('head')) {
        document.querySelector('head').appendChild(script);
      } else {
        document.querySelector('body').appendChild(script);
      }

      return script;
    }

    function script(url) {
      if (loaded[url] instanceof Promise) {
        return loaded[url];
      }

      return loaded[url] = new Promise(function (resolve, reject) {
        try {
          if (!loaded[url]) {
            append(element(url)).addEventListener('load', function (event) {
              resolve(loaded[url] = event);
            });
          } else {
            resolve(loaded[url]);
          }
        } catch (e) {
          reject(e);
        }
      });
    }

    var VueInstaller = {
      use: use,
      script: script,
      plugin: plugin,
      plugins: plugins,
      filter: filter,
      filters: filters$1,
      component: component,
      components: components,
      directive: directive,
      directives: directives,
      $plugins: {},
      $filters: {},
      $directives: {},
      $components: {}
    };
    function use(plugin) {
      if (typeof window !== 'undefined' && window.Vue) {
        window.Vue.use(plugin);
      }

      return plugin;
    }
    function plugin(Vue, name, def) {
      if (!VueInstaller.$plugins[name]) {
        Vue.use(VueInstaller.$plugins[name] = def);
      }
    }
    function plugins(Vue, plugins) {
      forEach(plugins, function (def, name) {
        plugin(Vue, name, def);
      });
    }
    function filter(Vue, name, def) {
      if (!VueInstaller.$filters[name]) {
        Vue.use(VueInstaller.$filters[name] = def);
      }
    }
    function filters$1(Vue, filters) {
      forEach(filters, function (def, name) {
        filter(Vue, name, def);
      });
    }
    function component(Vue, name, def) {
      if (!VueInstaller.$components[name]) {
        Vue.component(name, VueInstaller.$components[name] = def);
      }
    }
    function components(Vue, components) {
      forEach(components, function (def, name) {
        component(Vue, name, def);
      });
    }
    function directive(Vue, name, def) {
      if (!VueInstaller.$directives[name]) {
        if (isFunction$1(def)) {
          Vue.use(VueInstaller.$directives[name] = def);
        } else {
          Vue.directive(name, def);
        }
      }
    }
    function directives(Vue, directives) {
      forEach(directives, function (def, name) {
        directive(Vue, name, def);
      });
    }

    var plugin$1 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          ActivityIndicator: ActivityIndicator
        });
      }
    });

    var convertAnimationDelayToInt = function convertAnimationDelayToInt(delay) {
      var num = parseFloat(delay, 10);
      var matches = delay.match(/m?s/);
      var unit = matches ? matches[0] : false;
      var milliseconds;

      switch (unit) {
        case "s":
          // seconds
          milliseconds = num * 1000;
          break;

        case "ms":
        default:
          milliseconds = num;
          break;
      }

      return milliseconds || 0;
    };

    var animated = function animated(el, callback) {
      var defaultView = (el.ownerDocument || document).defaultView;
      setTimeout(function () {
        callback.apply();
      }, convertAnimationDelayToInt(defaultView.getComputedStyle(el).animationDuration));
    };

    var BtnActivity = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('button', {
          staticClass: "btn",
          class: _vm.classes,
          attrs: {
            "type": _vm.type
          },
          on: {
            "click": _vm.onClick
          }
        }, [_vm.icon ? _c('i', {
          class: _vm.icon
        }) : _vm._e(), _vm._v(" " + _vm._s(_vm.label) + " "), _vm._t("default"), _vm._v(" "), _c('activity-indicator', {
          attrs: {
            "type": _vm.indicator
          }
        })], 2);
      },
      staticRenderFns: [],
      name: 'activity-button',
      components: {
        ActivityIndicator: ActivityIndicator
      },
      props: {
        /**
         * Make the button appear with the active state.
         *
         * @property {Boolea}n}
         */
        active: Boolean,

        /**
         * Show the activity indicator inside the button.
         *
         * @property {Boolea}n}
         */
        activity: Boolean,

        /**
         * Display the button as block width.
         *
         * @property {Boolea}n}
         */
        block: Boolean,

        /**
         * Make the button appear with the disabled state.
         *
         * @property {Boolea}n}
         */
        disabled: Boolean,

        /**
         * The button label. If not passed as a property, label must be passed
         * inside the element's html.
         *
         * @property {String}
         */
        label: String,

        /**
         * The button icon
         *
         * @property {String}
         */
        icon: String,

        /**
         * The `type` attribute for the button element.
         *
         * @property {String}
         */
        type: String,

        /**
         * The size of the button.
         *
         * @property {String}
         */
        size: {
          type: String,
          default: 'md'
        },

        /**
         * The variant of the button.
         *
         * @property {String}
         */
        variant: {
          type: String,
          default: 'primary'
        },

        /**
         * The type of activity indicator inside the button.
         *
         * @property {String}
         */
        indicator: {
          type: String,
          default: 'spinner'
        },

        /**
         * The orientation of the activity button inside the button.
         *
         * @property {String}
         */
        orientation: {
          type: String,
          default: 'right'
        }
      },
      methods: {
        /**
         * Disable the button.
         *
         * @return void
         */
        disable: function disable() {
          this.$el.disabled = true;
        },

        /**
         * Enable the button.
         *
         * @return void
         */
        enable: function enable() {
          this.$el.disabled = false;
        },

        /**
         * Show the activity indicator inside the button.
         *
         * @return void
         */
        showActivity: function showActivity() {
          var _this = this;

          this.disable();
          animated(this.$el, function () {
            _this.$el.classList.add('btn-activity');

            _this.$emit('activity:show');
          });
        },

        /**
         * Hide the activity indicator inside the button.
         *
         * @return void
         */
        hideActivity: function hideActivity() {
          var _this2 = this;

          this.$el.classList.add('btn-hide-activity');
          animated(this.$el, function () {
            _this2.enable();

            _this2.$el.classList.remove('btn-activity', 'btn-hide-activity');

            _this2.$emit('activity:hide');
          });
        },

        /**
         * The click callback function
         *
         * @return void
         */
        onClick: function onClick(event) {
          this.$emit('click', event, this);
        }
      },
      computed: {
        /**
         * An object of classes to append to the button.
         *
         * @return void
         */
        classes: function classes() {
          var classes = {
            'disabled': this.disabled,
            'active': this.active,
            'btn-block': this.block,
            'btn-activity': this.activity
          };
          classes['btn-' + this.size.replace('btn-', '')] = !!this.size;
          classes['btn-' + this.variant.replace('btn-', '')] = !!this.variant;
          classes['btn-activity-' + this.orientation.replace('btn-activity-', '')] = !!this.orientation;
          classes['btn-activity-indicator-' + this.indicator.replace('btn-activity-indicator-', '')] = !!this.indicator;
          return classes;
        }
      },
      watch: {
        activity: function activity(value) {
          if (value) {
            this.showActivity();
          } else {
            this.hideActivity();
          }
        }
      }
    };

    var plugin$2 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          BtnActivity: BtnActivity
        });
      }
    });

    var ModalBody = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "modal-body"
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'modal-body'
    };

    var ModalBackdrop = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "modal-backdrop",
          class: {
            'fade': _vm.fade,
            'show': _vm.show
          }
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'modal-backdrop',
      props: {
        /**
         * Show the modal with a fade effect.
         *
         * @property Boolean
         */
        fade: {
          type: Boolean,
          default: true
        },

        /**
         * Is the modal showing.
         *
         * @property Boolean
         */
        show: {
          type: Boolean,
          default: true
        }
      }
    };

    var ModalContent = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "modal-content"
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'modal-content'
    };

    var ModalDialog = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "modal-dialog",
          attrs: {
            "role": "document"
          }
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'modal-dialog'
    };

    var ModalTitle = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('h5', {
          staticClass: "modal-title"
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'modal-title'
    };

    var ModalHeader = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "modal-header"
        }, [_vm._t("title", [_c('modal-title', [_vm._t("default")], 2)]), _vm._v(" "), _vm._t("close-button", [_vm.closeable ? _c('button', {
          staticClass: "close",
          attrs: {
            "type": "button",
            "aria-label": "ariaLabel"
          },
          on: {
            "click": function click($event) {
              _vm.$emit('close');
            }
          }
        }, [_c('span', {
          attrs: {
            "aria-hidden": "true"
          }
        }, [_vm._v("×")])]) : _vm._e()])], 2);
      },
      staticRenderFns: [],
      name: 'modal-header',
      components: {
        ModalTitle: ModalTitle
      },
      props: {
        ariaLabel: {
          type: String,
          default: 'Close'
        },
        closeable: {
          type: Boolean,
          default: true
        }
      }
    };

    var ModalFooter = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "modal-footer"
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'modal-footer'
    };

    function duration(el) {
      var duration = getComputedStyle(el).transitionDuration;
      var numeric = parseFloat(duration, 10) || 0;
      var unit = duration.match(/m?s/);

      switch (unit[0]) {
        case 's':
          return numeric * 1000;

        case 'ms':
          return numeric;
      }
    }

    function transition(el) {
      return new Promise(function (resolve, reject) {
        try {
          var delay = duration(el);
          setTimeout(function () {
            resolve(delay);
          }, delay);
        } catch (e) {
          reject(e);
        }
      });
    }

    var Triggerable = {
      props: {
        /**
         * Show the triggerable element with a fade effect.
         *
         * @type {Boolean}
         */
        fade: {
          type: Boolean,
          default: true
        },

        /**
         * Is the triggerable element showing.
         *
         * @property Boolean
         */
        show: Boolean,

        /**
         * The target element used to position the popover.
         *
         * @type {String|Element|Boolean}
         */
        target: {
          type: [String, Element, Boolean],
          default: false
        },

        /**
         * How the modal is triggered - click | hover | focus | manual. You may
         * pass multiple triggers; separate them with a space. `manual` cannot
         * be combined with any other trigger.
         *
         * @type {String}
         */
        trigger: {
          type: [String, Array],
          default: 'click'
        }
      },
      methods: {
        initializeTrigger: function initializeTrigger(el) {
          var _this = this;

          forEach(isString(this.trigger) ? this.trigger.split(' ') : this.trigger, function (trigger) {
            el.addEventListener(trigger, function (event) {
              _this.toggle();
            });
          });
        },

        /**
         * Focus on the first field in the modal (if exists).
         *
         * @return void
         */
        focus: function focus() {
          var el = this.$el.querySelector('.form-control, input, select, textarea');

          if (el) {
            el.focus();
          } else {
            this.$el.focus();
          }
        },

        /**
         * Open the triggereable element
         *
         * @return void
         */
        open: function open() {
          var _this2 = this;

          this.isDisplaying = true;
          this.$nextTick(function () {
            transition(_this2.$el).then(function (delay) {
              _this2.isShowing = true;

              _this2.$emit('open');
            });
          });
        },

        /**
         * Close the triggereable element
         *
         * @return void
         */
        close: function close(event) {
          var _this3 = this;

          transition(this.$el).then(function (delay) {
            _this3.isDisplaying = false;

            _this3.$emit('close', event, _this3);
          });
          this.isShowing = false;
        },

        /**
         * Toggle the triggereable element's open/close method.
         *
         * @return void
         */
        toggle: function toggle() {
          if (!this.isShowing) {
            this.open();
          } else {
            this.close();
          }
        }
      },
      computed: {
        triggerableClasses: function triggerableClasses() {
          return {
            'fade': this.fade,
            'show': this.isShowing
          };
        }
      },
      watch: {
        isShowing: function isShowing(value) {
          if (value) {
            this.focus();
          }
        },
        show: function show(value) {
          this.isShowing = value;
        }
      },
      mounted: function mounted() {
        var _this4 = this;

        if (this.target && this.trigger !== 'manual') {
          if (this.target instanceof Element) {
            this.initializeTrigger(this.target);
          } else {
            document.querySelectorAll(this.target).forEach(function (el) {
              _this4.initializeTrigger(el);
            });
          }
        }
      },
      data: function data() {
        return {
          isDisplaying: this.show || !this.target,
          isShowing: this.show || !this.target
        };
      }
    };

    var Modal = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "modal",
          class: _vm.triggerableClasses,
          style: {
            display: _vm.isDisplaying ? 'block' : 'none'
          },
          attrs: {
            "tabindex": "-1",
            "role": "dialog"
          },
          on: {
            "keydown": function keydown($event) {
              if (!('button' in $event) && _vm._k($event.keyCode, "esc", 27, $event.key, "Escape")) {
                return null;
              }

              return _vm.onEsc($event);
            }
          }
        }, [_c('modal-dialog', {
          class: {
            'modal-dialog-centered': _vm.center
          }
        }, [_c('modal-content', [_vm._t("header", [_vm.title ? _c('modal-header', {
          on: {
            "close": _vm.cancel
          }
        }, [_vm._v(_vm._s(_vm.title))]) : _vm._e()]), _vm._v(" "), _vm._t("body", [_c(!_vm.flush ? 'modal-body' : 'div', {
          tag: "component",
          staticClass: "child-component"
        }, [_vm._t("default")], 2)]), _vm._v(" "), _vm._t("footer", [_vm.type ? _c('modal-footer', [_vm.type === 'alert' ? [_c('btn-activity', {
          attrs: {
            "activity": _vm.activity,
            "variant": "primary"
          },
          domProps: {
            "innerHTML": _vm._s(_vm.okLabel)
          },
          on: {
            "click": _vm.confirm
          }
        })] : [_c('btn', {
          attrs: {
            "type": "button",
            "variant": "secondary"
          },
          domProps: {
            "innerHTML": _vm._s(_vm.cancelLabel)
          },
          on: {
            "click": _vm.cancel
          }
        }), _vm._v(" "), _c('btn-activity', {
          attrs: {
            "activity": _vm.activity,
            "variant": "primary"
          },
          domProps: {
            "innerHTML": _vm._s(_vm.okLabel)
          },
          on: {
            "click": _vm.confirm
          }
        })]], 2) : _vm._e()])], 2)], 1)], 1);
      },
      staticRenderFns: [],
      name: 'modal',
      components: {
        BtnActivity: BtnActivity,
        ModalBody: ModalBody,
        ModalBackdrop: ModalBackdrop,
        ModalContent: ModalContent,
        ModalDialog: ModalDialog,
        ModalHeader: ModalHeader,
        ModalFooter: ModalFooter
      },
      mixins: [Triggerable],
      watch: {
        isShowing: function isShowing(value) {
          if (value) {
            document.querySelector('body').classList.add('modal-open');

            if (this.backdrop && !document.querySelector('.modal-backdrop')) {
              this.backdropComponent = new (Vue.extend(ModalBackdrop))().$mount(document.body.appendChild(document.createElement('div')));
            }
          } else {
            document.querySelector('body').classList.remove('modal-open');

            if (this.backdropComponent) {
              this.backdropComponent.$destroy();
              this.backdropComponent.$el.remove();
              this.backdropComponent = null;
            }
          }

          this.$emit('update:show', value);
        }
      },
      props: {
        /**
         * Show the modal activity indicator.
         *
         * @type {Boolean}
         */
        activity: Boolean,

        /**
         * Show the modal with a backdrop.
         *
         * @type {Boolean}
         */
        backdrop: {
          type: Boolean,
          default: true
        },

        /**
         * Is the modal centered in the screen.
         *
         * @type {Boolean}
         */
        center: Boolean,

        /**
         * Is the modal content fixed position
         *
         * @type {Boolean}
         */
        closeable: {
          type: Boolean,
          default: true
        },

        /**
         * Is the modal content flush with the modal edges? If true, no modal-body
         * will be used to wrap the content.
         *
         * @type {Boolean}
         */
        flush: Boolean,

        /**
         * The ok label text.
         *
         * @type {String}
         */
        okLabel: {
          type: String,
          default: 'Ok'
        },

        /**
         * The cancel label text.
         *
         * @type {String}
         */
        cancelLabel: {
          type: String,
          default: 'Cancel'
        },

        /**
         * The modal title.
         *
         * @type {String}
         */
        title: String,

        /**
         * Is the modal type.
         *
         * @type {Boolean}
         */
        type: {
          type: [Boolean, String],
          default: false,
          validate: function validate(value) {
            return ['alert', 'confirm', 'prompt'].indexOf(value) !== -1;
          }
        }
      },
      methods: {
        /**
         * Cancel the modal
         *
         * @return void
         */
        cancel: function cancel(event) {
          this.$emit('cancel', event, this);
          this.close(event);
        },

        /**
         * Confirm the modal
         *
         * @return void
         */
        confirm: function confirm(event) {
          this.$emit('confirm', event, this);
        },

        /**
         * A callback for the escape function.
         *
         * @return void
         */
        onEsc: function onEsc(event) {
          this.type === 'confirm' || this.type === 'prompt' ? this.cancel(event) : this.close(event);
        }
      },
      data: function data() {
        return {
          backdropComponent: null,
          isDisplaying: this.show || !this.target,
          isShowing: this.show || !this.target
        };
      },
      beforeRouteLeave: function beforeRouteLeave(to, from, next) {
        modal.close();
      }
    };

    function ensure(options, values) {
      if (!options) {
        options = {};
      }

      return {
        propsData: defaultsDeep(options.propsData || options, values || {})
      };
    }

    function modal$1 (Vue, options) {

      function promise(modal) {
        var promise = new Promise(function (resolve, reject) {
          var preventDefault = false;

          modal.preventDefault = function () {
            return preventDefault = true;
          };

          modal.$on('confirm', function (event) {
            console.log('confirm'); //promise.then(finish);
            //resolve(modal);
          });
          modal.$on('cancel', function (event) {
            reject(modal);
          });
        });
        return promise;
      }

      Vue.prototype.$modal = function (title, content, options, modalOptions, ModalComponent) {
        var _this = this;

        if (isString(content)) {
          content = Vue.extend({
            template: "<div>".concat(content, "</div>")
          });
        }

        var component = function component(vue, options) {
          if (!(vue instanceof Vue) && isObject(vue)) {
            vue = Vue.extend(vue);
            vue.options.route = _this.$route;
            vue.options.router = _this.$router;
          }

          return isFunction$1(vue) ? new vue(options) : vue;
        };

        var modal = component(ModalComponent || Modal, ensure(modalOptions));
        modal.$content = component(content, ensure(options));
        modal.open(modal.$content);
        modal.$on('cancel', function (event) {
          modal.$content.$emit('modal:cancel');
        });
        modal.$on('close', function (event) {
          modal.$content.$emit('modal:close');
        });
        modal.$on('confirm', function (event) {
          modal.$content.$emit('modal:confirm');
        });
        modal.$content.$on('modal:close', function (event) {
          modal.close();
        });
        return modal;
      };

      Vue.prototype.$alert = function (title, content, options, modalOptions, ModalComponent) {
        return promise(this.$modal(title, content, options, ensure({
          type: 'alert',
          title: title
        }, modalOptions), ModalComponent));
      };

      Vue.prototype.$confirm = function (title, content, options, modalOptions, ModalComponent) {
        return promise(this.$modal(title, content, options, ensure({
          type: 'confirm',
          title: title
        }, modalOptions), ModalComponent));
      };

      Vue.prototype.$prompt = function (title, content, options, modalOptions, ModalComponent) {
        modalOptions = ensure({
          title: title,
          type: 'prompt'
        }, modalOptions);
        return promise(this.$modal(title, content, options, modalOptions, ModalComponent));
      };
    }

    var OverlayBody = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "overlay-body"
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'overlay-body'
    };

    var Container = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "container"
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'container'
    };

    var plugin$3 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          Container: Container
        });
      }
    });

    var OverlayContent = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('container', {
          staticClass: "overlay-content"
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'overlay-content',
      components: {
        Container: Container
      }
    };

    var Overlay = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "overlay",
          class: _vm.triggerableClasses,
          style: {
            'background': _vm.background,
            'display': _vm.isDisplaying ? 'flex' : 'none'
          },
          attrs: {
            "role": "dialog",
            "tabindex": "-1"
          },
          on: {
            "keydown": function keydown($event) {
              if (!('button' in $event) && _vm._k($event.keyCode, "esc", 27, $event.key, "Escape")) {
                return null;
              }

              return _vm.onEsc($event);
            }
          }
        }, [_vm.closeable && !_vm.hideCloseButton ? _c('button', {
          staticClass: "btn btn-link overlay-close",
          attrs: {
            "type": "button"
          },
          on: {
            "click": _vm.onClickClose
          }
        }, [_c('i', {
          staticClass: "fa fa-times-circle"
        })]) : _vm._e(), _vm._v(" "), _c('overlay-content', {
          class: {
            'overlay-content-fixed': _vm.fixedContent,
            'overlay-content-center': _vm.center
          },
          style: {
            minHeight: _vm.minHeight
          }
        }, [_vm._t("body", [_c('overlay-body', [_vm._t("default")], 2)])], 2)], 1);
      },
      staticRenderFns: [],
      name: 'overlay',
      components: {
        OverlayBody: OverlayBody,
        OverlayContent: OverlayContent
      },
      mixins: [Triggerable],
      props: {
        /**
         * The overlay background color.
         *
         * @property String
         */
        background: {
          type: String,
          default: 'rgba(255, 255, 255, .925)'
        },

        /**
         * Is the overlay content fixed position
         *
         * @property Boolean
         */
        closeable: {
          type: Boolean,
          default: true
        },

        /**
         * Center the overlay content on the screen using flex box.
         *
         * @type {Boolean}
         */
        center: {
          type: Boolean,
          default: true
        },

        /**
         * Is the overlay content fixed position
         *
         * @property Boolean
         */
        fixedContent: Boolean,

        /**
         * Is the overlay close button hidden but still closeable.
         *
         * @property Boolean
         */
        hideCloseButton: Boolean,

        /**
         * Is the overlay content minimum height.
         *
         * @property Boolean
         */
        minHeight: [String, Number]
      },
      methods: {
        /**
         * The callback for the `click` event on the close button.
         *
         * @return void
         */
        onClickClose: function onClickClose(event) {
          this.$emit('click:close', event, this);
          this.close();
        },
        onEsc: function onEsc(event) {
          this.closeable && this.close();
        }
      }
    };

    function ensure$1(options, values) {
      if (!options) {
        options = {};
      }

      return {
        propsData: defaultsDeep(options.propsData || options, values || {})
      };
    }

    function overlay (Vue, options) {
      Vue.prototype.$overlay = function (ContentComponent, options, overlayOptions, CustomOverlayComponent) {
        var _this = this;

        var component = function component(vue, options) {
          if (!(vue instanceof Vue) && isObject(vue)) {
            vue = Vue.extend(vue);
            vue.options.route = _this.$route;
            vue.options.router = _this.$router;
          }

          return isFunction$1(vue) ? new vue(options) : vue;
        };

        var overlay = component(CustomOverlayComponent || Overlay, ensure$1(overlayOptions));
        overlay.$content = component(ContentComponent, ensure$1(options));
        overlay.show(overlay.$content);
        return overlay;
      };
    }

    /*
    import { defaultsDeep } from 'lodash-es';

    function ensure(options, values) {
        if(!options) {
            options = {};
        }

        return {
            propsData: defaultsDeep(options.propsData || options, values || {})
        };
    }
    */
    function instance(Vue, Component, options) {
      if (Component instanceof Vue) {
        return Component;
      }

      if (isObject(Component)) {
        Component = Vue.extend(Component);
      }

      return new Component(options);
    }

    /**!
     * @fileOverview Kickass library to create and place poppers near their reference elements.
     * @version 1.14.3
     * @license
     * Copyright (c) 2016 Federico Zivolo and contributors
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */
    var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';

    var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];
    var timeoutDuration = 0;
    for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
      if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
        timeoutDuration = 1;
        break;
      }
    }

    function microtaskDebounce(fn) {
      var called = false;
      return function () {
        if (called) {
          return;
        }
        called = true;
        window.Promise.resolve().then(function () {
          called = false;
          fn();
        });
      };
    }

    function taskDebounce(fn) {
      var scheduled = false;
      return function () {
        if (!scheduled) {
          scheduled = true;
          setTimeout(function () {
            scheduled = false;
            fn();
          }, timeoutDuration);
        }
      };
    }

    var supportsMicroTasks = isBrowser && window.Promise;

    /**
    * Create a debounced version of a method, that's asynchronously deferred
    * but called in the minimum time possible.
    *
    * @method
    * @memberof Popper.Utils
    * @argument {Function} fn
    * @returns {Function}
    */
    var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;

    /**
     * Check if the given variable is a function
     * @method
     * @memberof Popper.Utils
     * @argument {Any} functionToCheck - variable to check
     * @returns {Boolean} answer to: is a function?
     */
    function isFunction$2(functionToCheck) {
      var getType = {};
      return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
    }

    /**
     * Get CSS computed property of the given element
     * @method
     * @memberof Popper.Utils
     * @argument {Eement} element
     * @argument {String} property
     */
    function getStyleComputedProperty(element, property) {
      if (element.nodeType !== 1) {
        return [];
      }
      // NOTE: 1 DOM access here
      var css = getComputedStyle(element, null);
      return property ? css[property] : css;
    }

    /**
     * Returns the parentNode or the host of the element
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element
     * @returns {Element} parent
     */
    function getParentNode(element) {
      if (element.nodeName === 'HTML') {
        return element;
      }
      return element.parentNode || element.host;
    }

    /**
     * Returns the scrolling parent of the given element
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element
     * @returns {Element} scroll parent
     */
    function getScrollParent(element) {
      // Return body, `getScroll` will take care to get the correct `scrollTop` from it
      if (!element) {
        return document.body;
      }

      switch (element.nodeName) {
        case 'HTML':
        case 'BODY':
          return element.ownerDocument.body;
        case '#document':
          return element.body;
      }

      // Firefox want us to check `-x` and `-y` variations as well

      var _getStyleComputedProp = getStyleComputedProperty(element),
          overflow = _getStyleComputedProp.overflow,
          overflowX = _getStyleComputedProp.overflowX,
          overflowY = _getStyleComputedProp.overflowY;

      if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
        return element;
      }

      return getScrollParent(getParentNode(element));
    }

    var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
    var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);

    /**
     * Determines if the browser is Internet Explorer
     * @method
     * @memberof Popper.Utils
     * @param {Number} version to check
     * @returns {Boolean} isIE
     */
    function isIE(version) {
      if (version === 11) {
        return isIE11;
      }
      if (version === 10) {
        return isIE10;
      }
      return isIE11 || isIE10;
    }

    /**
     * Returns the offset parent of the given element
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element
     * @returns {Element} offset parent
     */
    function getOffsetParent(element) {
      if (!element) {
        return document.documentElement;
      }

      var noOffsetParent = isIE(10) ? document.body : null;

      // NOTE: 1 DOM access here
      var offsetParent = element.offsetParent;
      // Skip hidden elements which don't have an offsetParent
      while (offsetParent === noOffsetParent && element.nextElementSibling) {
        offsetParent = (element = element.nextElementSibling).offsetParent;
      }

      var nodeName = offsetParent && offsetParent.nodeName;

      if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
        return element ? element.ownerDocument.documentElement : document.documentElement;
      }

      // .offsetParent will return the closest TD or TABLE in case
      // no offsetParent is present, I hate this job...
      if (['TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
        return getOffsetParent(offsetParent);
      }

      return offsetParent;
    }

    function isOffsetContainer(element) {
      var nodeName = element.nodeName;

      if (nodeName === 'BODY') {
        return false;
      }
      return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
    }

    /**
     * Finds the root node (document, shadowDOM root) of the given element
     * @method
     * @memberof Popper.Utils
     * @argument {Element} node
     * @returns {Element} root node
     */
    function getRoot(node) {
      if (node.parentNode !== null) {
        return getRoot(node.parentNode);
      }

      return node;
    }

    /**
     * Finds the offset parent common to the two provided nodes
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element1
     * @argument {Element} element2
     * @returns {Element} common offset parent
     */
    function findCommonOffsetParent(element1, element2) {
      // This check is needed to avoid errors in case one of the elements isn't defined for any reason
      if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
        return document.documentElement;
      }

      // Here we make sure to give as "start" the element that comes first in the DOM
      var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
      var start = order ? element1 : element2;
      var end = order ? element2 : element1;

      // Get common ancestor container
      var range = document.createRange();
      range.setStart(start, 0);
      range.setEnd(end, 0);
      var commonAncestorContainer = range.commonAncestorContainer;

      // Both nodes are inside #document

      if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
        if (isOffsetContainer(commonAncestorContainer)) {
          return commonAncestorContainer;
        }

        return getOffsetParent(commonAncestorContainer);
      }

      // one of the nodes is inside shadowDOM, find which one
      var element1root = getRoot(element1);
      if (element1root.host) {
        return findCommonOffsetParent(element1root.host, element2);
      } else {
        return findCommonOffsetParent(element1, getRoot(element2).host);
      }
    }

    /**
     * Gets the scroll value of the given element in the given side (top and left)
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element
     * @argument {String} side `top` or `left`
     * @returns {number} amount of scrolled pixels
     */
    function getScroll(element) {
      var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';

      var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
      var nodeName = element.nodeName;

      if (nodeName === 'BODY' || nodeName === 'HTML') {
        var html = element.ownerDocument.documentElement;
        var scrollingElement = element.ownerDocument.scrollingElement || html;
        return scrollingElement[upperSide];
      }

      return element[upperSide];
    }

    /*
     * Sum or subtract the element scroll values (left and top) from a given rect object
     * @method
     * @memberof Popper.Utils
     * @param {Object} rect - Rect object you want to change
     * @param {HTMLElement} element - The element from the function reads the scroll values
     * @param {Boolean} subtract - set to true if you want to subtract the scroll values
     * @return {Object} rect - The modifier rect object
     */
    function includeScroll(rect, element) {
      var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      var scrollTop = getScroll(element, 'top');
      var scrollLeft = getScroll(element, 'left');
      var modifier = subtract ? -1 : 1;
      rect.top += scrollTop * modifier;
      rect.bottom += scrollTop * modifier;
      rect.left += scrollLeft * modifier;
      rect.right += scrollLeft * modifier;
      return rect;
    }

    /*
     * Helper to detect borders of a given element
     * @method
     * @memberof Popper.Utils
     * @param {CSSStyleDeclaration} styles
     * Result of `getStyleComputedProperty` on the given element
     * @param {String} axis - `x` or `y`
     * @return {number} borders - The borders size of the given axis
     */

    function getBordersSize(styles, axis) {
      var sideA = axis === 'x' ? 'Left' : 'Top';
      var sideB = sideA === 'Left' ? 'Right' : 'Bottom';

      return parseFloat(styles['border' + sideA + 'Width'], 10) + parseFloat(styles['border' + sideB + 'Width'], 10);
    }

    function getSize(axis, body, html, computedStyle) {
      return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? html['offset' + axis] + computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')] + computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')] : 0);
    }

    function getWindowSizes() {
      var body = document.body;
      var html = document.documentElement;
      var computedStyle = isIE(10) && getComputedStyle(html);

      return {
        height: getSize('Height', body, html, computedStyle),
        width: getSize('Width', body, html, computedStyle)
      };
    }

    var classCallCheck = function (instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    };

    var createClass = function () {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();





    var defineProperty$1 = function (obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    };

    var _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    /**
     * Given element offsets, generate an output similar to getBoundingClientRect
     * @method
     * @memberof Popper.Utils
     * @argument {Object} offsets
     * @returns {Object} ClientRect like output
     */
    function getClientRect(offsets) {
      return _extends({}, offsets, {
        right: offsets.left + offsets.width,
        bottom: offsets.top + offsets.height
      });
    }

    /**
     * Get bounding client rect of given element
     * @method
     * @memberof Popper.Utils
     * @param {HTMLElement} element
     * @return {Object} client rect
     */
    function getBoundingClientRect(element) {
      var rect = {};

      // IE10 10 FIX: Please, don't ask, the element isn't
      // considered in DOM in some circumstances...
      // This isn't reproducible in IE10 compatibility mode of IE11
      try {
        if (isIE(10)) {
          rect = element.getBoundingClientRect();
          var scrollTop = getScroll(element, 'top');
          var scrollLeft = getScroll(element, 'left');
          rect.top += scrollTop;
          rect.left += scrollLeft;
          rect.bottom += scrollTop;
          rect.right += scrollLeft;
        } else {
          rect = element.getBoundingClientRect();
        }
      } catch (e) {}

      var result = {
        left: rect.left,
        top: rect.top,
        width: rect.right - rect.left,
        height: rect.bottom - rect.top
      };

      // subtract scrollbar size from sizes
      var sizes = element.nodeName === 'HTML' ? getWindowSizes() : {};
      var width = sizes.width || element.clientWidth || result.right - result.left;
      var height = sizes.height || element.clientHeight || result.bottom - result.top;

      var horizScrollbar = element.offsetWidth - width;
      var vertScrollbar = element.offsetHeight - height;

      // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
      // we make this check conditional for performance reasons
      if (horizScrollbar || vertScrollbar) {
        var styles = getStyleComputedProperty(element);
        horizScrollbar -= getBordersSize(styles, 'x');
        vertScrollbar -= getBordersSize(styles, 'y');

        result.width -= horizScrollbar;
        result.height -= vertScrollbar;
      }

      return getClientRect(result);
    }

    function getOffsetRectRelativeToArbitraryNode(children, parent) {
      var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      var isIE10 = isIE(10);
      var isHTML = parent.nodeName === 'HTML';
      var childrenRect = getBoundingClientRect(children);
      var parentRect = getBoundingClientRect(parent);
      var scrollParent = getScrollParent(children);

      var styles = getStyleComputedProperty(parent);
      var borderTopWidth = parseFloat(styles.borderTopWidth, 10);
      var borderLeftWidth = parseFloat(styles.borderLeftWidth, 10);

      // In cases where the parent is fixed, we must ignore negative scroll in offset calc
      if (fixedPosition && parent.nodeName === 'HTML') {
        parentRect.top = Math.max(parentRect.top, 0);
        parentRect.left = Math.max(parentRect.left, 0);
      }
      var offsets = getClientRect({
        top: childrenRect.top - parentRect.top - borderTopWidth,
        left: childrenRect.left - parentRect.left - borderLeftWidth,
        width: childrenRect.width,
        height: childrenRect.height
      });
      offsets.marginTop = 0;
      offsets.marginLeft = 0;

      // Subtract margins of documentElement in case it's being used as parent
      // we do this only on HTML because it's the only element that behaves
      // differently when margins are applied to it. The margins are included in
      // the box of the documentElement, in the other cases not.
      if (!isIE10 && isHTML) {
        var marginTop = parseFloat(styles.marginTop, 10);
        var marginLeft = parseFloat(styles.marginLeft, 10);

        offsets.top -= borderTopWidth - marginTop;
        offsets.bottom -= borderTopWidth - marginTop;
        offsets.left -= borderLeftWidth - marginLeft;
        offsets.right -= borderLeftWidth - marginLeft;

        // Attach marginTop and marginLeft because in some circumstances we may need them
        offsets.marginTop = marginTop;
        offsets.marginLeft = marginLeft;
      }

      if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
        offsets = includeScroll(offsets, parent);
      }

      return offsets;
    }

    function getViewportOffsetRectRelativeToArtbitraryNode(element) {
      var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      var html = element.ownerDocument.documentElement;
      var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
      var width = Math.max(html.clientWidth, window.innerWidth || 0);
      var height = Math.max(html.clientHeight, window.innerHeight || 0);

      var scrollTop = !excludeScroll ? getScroll(html) : 0;
      var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;

      var offset = {
        top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
        left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
        width: width,
        height: height
      };

      return getClientRect(offset);
    }

    /**
     * Check if the given element is fixed or is inside a fixed parent
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element
     * @argument {Element} customContainer
     * @returns {Boolean} answer to "isFixed?"
     */
    function isFixed(element) {
      var nodeName = element.nodeName;
      if (nodeName === 'BODY' || nodeName === 'HTML') {
        return false;
      }
      if (getStyleComputedProperty(element, 'position') === 'fixed') {
        return true;
      }
      return isFixed(getParentNode(element));
    }

    /**
     * Finds the first parent of an element that has a transformed property defined
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element
     * @returns {Element} first transformed parent or documentElement
     */

    function getFixedPositionOffsetParent(element) {
      // This check is needed to avoid errors in case one of the elements isn't defined for any reason
      if (!element || !element.parentElement || isIE()) {
        return document.documentElement;
      }
      var el = element.parentElement;
      while (el && getStyleComputedProperty(el, 'transform') === 'none') {
        el = el.parentElement;
      }
      return el || document.documentElement;
    }

    /**
     * Computed the boundaries limits and return them
     * @method
     * @memberof Popper.Utils
     * @param {HTMLElement} popper
     * @param {HTMLElement} reference
     * @param {number} padding
     * @param {HTMLElement} boundariesElement - Element used to define the boundaries
     * @param {Boolean} fixedPosition - Is in fixed position mode
     * @returns {Object} Coordinates of the boundaries
     */
    function getBoundaries(popper, reference, padding, boundariesElement) {
      var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

      // NOTE: 1 DOM access here

      var boundaries = { top: 0, left: 0 };
      var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);

      // Handle viewport case
      if (boundariesElement === 'viewport') {
        boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
      } else {
        // Handle other cases based on DOM element used as boundaries
        var boundariesNode = void 0;
        if (boundariesElement === 'scrollParent') {
          boundariesNode = getScrollParent(getParentNode(reference));
          if (boundariesNode.nodeName === 'BODY') {
            boundariesNode = popper.ownerDocument.documentElement;
          }
        } else if (boundariesElement === 'window') {
          boundariesNode = popper.ownerDocument.documentElement;
        } else {
          boundariesNode = boundariesElement;
        }

        var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);

        // In case of HTML, we need a different computation
        if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
          var _getWindowSizes = getWindowSizes(),
              height = _getWindowSizes.height,
              width = _getWindowSizes.width;

          boundaries.top += offsets.top - offsets.marginTop;
          boundaries.bottom = height + offsets.top;
          boundaries.left += offsets.left - offsets.marginLeft;
          boundaries.right = width + offsets.left;
        } else {
          // for all the other DOM elements, this one is good
          boundaries = offsets;
        }
      }

      // Add paddings
      boundaries.left += padding;
      boundaries.top += padding;
      boundaries.right -= padding;
      boundaries.bottom -= padding;

      return boundaries;
    }

    function getArea(_ref) {
      var width = _ref.width,
          height = _ref.height;

      return width * height;
    }

    /**
     * Utility used to transform the `auto` placement to the placement with more
     * available space.
     * @method
     * @memberof Popper.Utils
     * @argument {Object} data - The data object generated by update method
     * @argument {Object} options - Modifiers configuration and options
     * @returns {Object} The data object, properly modified
     */
    function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
      var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

      if (placement.indexOf('auto') === -1) {
        return placement;
      }

      var boundaries = getBoundaries(popper, reference, padding, boundariesElement);

      var rects = {
        top: {
          width: boundaries.width,
          height: refRect.top - boundaries.top
        },
        right: {
          width: boundaries.right - refRect.right,
          height: boundaries.height
        },
        bottom: {
          width: boundaries.width,
          height: boundaries.bottom - refRect.bottom
        },
        left: {
          width: refRect.left - boundaries.left,
          height: boundaries.height
        }
      };

      var sortedAreas = Object.keys(rects).map(function (key) {
        return _extends({
          key: key
        }, rects[key], {
          area: getArea(rects[key])
        });
      }).sort(function (a, b) {
        return b.area - a.area;
      });

      var filteredAreas = sortedAreas.filter(function (_ref2) {
        var width = _ref2.width,
            height = _ref2.height;
        return width >= popper.clientWidth && height >= popper.clientHeight;
      });

      var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;

      var variation = placement.split('-')[1];

      return computedPlacement + (variation ? '-' + variation : '');
    }

    /**
     * Get offsets to the reference element
     * @method
     * @memberof Popper.Utils
     * @param {Object} state
     * @param {Element} popper - the popper element
     * @param {Element} reference - the reference element (the popper will be relative to this)
     * @param {Element} fixedPosition - is in fixed position mode
     * @returns {Object} An object containing the offsets which will be applied to the popper
     */
    function getReferenceOffsets(state, popper, reference) {
      var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

      var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);
      return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
    }

    /**
     * Get the outer sizes of the given element (offset size + margins)
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element
     * @returns {Object} object containing width and height properties
     */
    function getOuterSizes(element) {
      var styles = getComputedStyle(element);
      var x = parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);
      var y = parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);
      var result = {
        width: element.offsetWidth + y,
        height: element.offsetHeight + x
      };
      return result;
    }

    /**
     * Get the opposite placement of the given one
     * @method
     * @memberof Popper.Utils
     * @argument {String} placement
     * @returns {String} flipped placement
     */
    function getOppositePlacement(placement) {
      var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };
      return placement.replace(/left|right|bottom|top/g, function (matched) {
        return hash[matched];
      });
    }

    /**
     * Get offsets to the popper
     * @method
     * @memberof Popper.Utils
     * @param {Object} position - CSS position the Popper will get applied
     * @param {HTMLElement} popper - the popper element
     * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
     * @param {String} placement - one of the valid placement options
     * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
     */
    function getPopperOffsets(popper, referenceOffsets, placement) {
      placement = placement.split('-')[0];

      // Get popper node sizes
      var popperRect = getOuterSizes(popper);

      // Add position, width and height to our offsets object
      var popperOffsets = {
        width: popperRect.width,
        height: popperRect.height
      };

      // depending by the popper placement we have to compute its offsets slightly differently
      var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
      var mainSide = isHoriz ? 'top' : 'left';
      var secondarySide = isHoriz ? 'left' : 'top';
      var measurement = isHoriz ? 'height' : 'width';
      var secondaryMeasurement = !isHoriz ? 'height' : 'width';

      popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
      if (placement === secondarySide) {
        popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
      } else {
        popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
      }

      return popperOffsets;
    }

    /**
     * Mimics the `find` method of Array
     * @method
     * @memberof Popper.Utils
     * @argument {Array} arr
     * @argument prop
     * @argument value
     * @returns index or -1
     */
    function find(arr, check) {
      // use native find if supported
      if (Array.prototype.find) {
        return arr.find(check);
      }

      // use `filter` to obtain the same behavior of `find`
      return arr.filter(check)[0];
    }

    /**
     * Return the index of the matching object
     * @method
     * @memberof Popper.Utils
     * @argument {Array} arr
     * @argument prop
     * @argument value
     * @returns index or -1
     */
    function findIndex(arr, prop, value) {
      // use native findIndex if supported
      if (Array.prototype.findIndex) {
        return arr.findIndex(function (cur) {
          return cur[prop] === value;
        });
      }

      // use `find` + `indexOf` if `findIndex` isn't supported
      var match = find(arr, function (obj) {
        return obj[prop] === value;
      });
      return arr.indexOf(match);
    }

    /**
     * Loop trough the list of modifiers and run them in order,
     * each of them will then edit the data object.
     * @method
     * @memberof Popper.Utils
     * @param {dataObject} data
     * @param {Array} modifiers
     * @param {String} ends - Optional modifier name used as stopper
     * @returns {dataObject}
     */
    function runModifiers(modifiers, data, ends) {
      var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));

      modifiersToRun.forEach(function (modifier) {
        if (modifier['function']) {
          // eslint-disable-line dot-notation
          console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
        }
        var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation
        if (modifier.enabled && isFunction$2(fn)) {
          // Add properties to offsets to make them a complete clientRect object
          // we do this before each modifier to make sure the previous one doesn't
          // mess with these values
          data.offsets.popper = getClientRect(data.offsets.popper);
          data.offsets.reference = getClientRect(data.offsets.reference);

          data = fn(data, modifier);
        }
      });

      return data;
    }

    /**
     * Updates the position of the popper, computing the new offsets and applying
     * the new style.<br />
     * Prefer `scheduleUpdate` over `update` because of performance reasons.
     * @method
     * @memberof Popper
     */
    function update() {
      // if popper is destroyed, don't perform any further update
      if (this.state.isDestroyed) {
        return;
      }

      var data = {
        instance: this,
        styles: {},
        arrowStyles: {},
        attributes: {},
        flipped: false,
        offsets: {}
      };

      // compute reference element offsets
      data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);

      // compute auto placement, store placement inside the data object,
      // modifiers will be able to edit `placement` if needed
      // and refer to originalPlacement to know the original value
      data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);

      // store the computed placement inside `originalPlacement`
      data.originalPlacement = data.placement;

      data.positionFixed = this.options.positionFixed;

      // compute the popper offsets
      data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);

      data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';

      // run the modifiers
      data = runModifiers(this.modifiers, data);

      // the first `update` will call `onCreate` callback
      // the other ones will call `onUpdate` callback
      if (!this.state.isCreated) {
        this.state.isCreated = true;
        this.options.onCreate(data);
      } else {
        this.options.onUpdate(data);
      }
    }

    /**
     * Helper used to know if the given modifier is enabled.
     * @method
     * @memberof Popper.Utils
     * @returns {Boolean}
     */
    function isModifierEnabled(modifiers, modifierName) {
      return modifiers.some(function (_ref) {
        var name = _ref.name,
            enabled = _ref.enabled;
        return enabled && name === modifierName;
      });
    }

    /**
     * Get the prefixed supported property name
     * @method
     * @memberof Popper.Utils
     * @argument {String} property (camelCase)
     * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
     */
    function getSupportedPropertyName(property) {
      var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
      var upperProp = property.charAt(0).toUpperCase() + property.slice(1);

      for (var i = 0; i < prefixes.length; i++) {
        var prefix = prefixes[i];
        var toCheck = prefix ? '' + prefix + upperProp : property;
        if (typeof document.body.style[toCheck] !== 'undefined') {
          return toCheck;
        }
      }
      return null;
    }

    /**
     * Destroy the popper
     * @method
     * @memberof Popper
     */
    function destroy() {
      this.state.isDestroyed = true;

      // touch DOM only if `applyStyle` modifier is enabled
      if (isModifierEnabled(this.modifiers, 'applyStyle')) {
        this.popper.removeAttribute('x-placement');
        this.popper.style.position = '';
        this.popper.style.top = '';
        this.popper.style.left = '';
        this.popper.style.right = '';
        this.popper.style.bottom = '';
        this.popper.style.willChange = '';
        this.popper.style[getSupportedPropertyName('transform')] = '';
      }

      this.disableEventListeners();

      // remove the popper if user explicity asked for the deletion on destroy
      // do not use `remove` because IE11 doesn't support it
      if (this.options.removeOnDestroy) {
        this.popper.parentNode.removeChild(this.popper);
      }
      return this;
    }

    /**
     * Get the window associated with the element
     * @argument {Element} element
     * @returns {Window}
     */
    function getWindow(element) {
      var ownerDocument = element.ownerDocument;
      return ownerDocument ? ownerDocument.defaultView : window;
    }

    function attachToScrollParents(scrollParent, event, callback, scrollParents) {
      var isBody = scrollParent.nodeName === 'BODY';
      var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
      target.addEventListener(event, callback, { passive: true });

      if (!isBody) {
        attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
      }
      scrollParents.push(target);
    }

    /**
     * Setup needed event listeners used to update the popper position
     * @method
     * @memberof Popper.Utils
     * @private
     */
    function setupEventListeners(reference, options, state, updateBound) {
      // Resize event listener on window
      state.updateBound = updateBound;
      getWindow(reference).addEventListener('resize', state.updateBound, { passive: true });

      // Scroll event listener on scroll parents
      var scrollElement = getScrollParent(reference);
      attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
      state.scrollElement = scrollElement;
      state.eventsEnabled = true;

      return state;
    }

    /**
     * It will add resize/scroll events and start recalculating
     * position of the popper element when they are triggered.
     * @method
     * @memberof Popper
     */
    function enableEventListeners() {
      if (!this.state.eventsEnabled) {
        this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
      }
    }

    /**
     * Remove event listeners used to update the popper position
     * @method
     * @memberof Popper.Utils
     * @private
     */
    function removeEventListeners(reference, state) {
      // Remove resize event listener on window
      getWindow(reference).removeEventListener('resize', state.updateBound);

      // Remove scroll event listener on scroll parents
      state.scrollParents.forEach(function (target) {
        target.removeEventListener('scroll', state.updateBound);
      });

      // Reset state
      state.updateBound = null;
      state.scrollParents = [];
      state.scrollElement = null;
      state.eventsEnabled = false;
      return state;
    }

    /**
     * It will remove resize/scroll events and won't recalculate popper position
     * when they are triggered. It also won't trigger onUpdate callback anymore,
     * unless you call `update` method manually.
     * @method
     * @memberof Popper
     */
    function disableEventListeners() {
      if (this.state.eventsEnabled) {
        cancelAnimationFrame(this.scheduleUpdate);
        this.state = removeEventListeners(this.reference, this.state);
      }
    }

    /**
     * Tells if a given input is a number
     * @method
     * @memberof Popper.Utils
     * @param {*} input to check
     * @return {Boolean}
     */
    function isNumeric(n) {
      return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
    }

    /**
     * Set the style to the given popper
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element - Element to apply the style to
     * @argument {Object} styles
     * Object with a list of properties and values which will be applied to the element
     */
    function setStyles(element, styles) {
      Object.keys(styles).forEach(function (prop) {
        var unit = '';
        // add unit if the value is numeric and is one of the following
        if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
          unit = 'px';
        }
        element.style[prop] = styles[prop] + unit;
      });
    }

    /**
     * Set the attributes to the given popper
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element - Element to apply the attributes to
     * @argument {Object} styles
     * Object with a list of properties and values which will be applied to the element
     */
    function setAttributes(element, attributes) {
      Object.keys(attributes).forEach(function (prop) {
        var value = attributes[prop];
        if (value !== false) {
          element.setAttribute(prop, attributes[prop]);
        } else {
          element.removeAttribute(prop);
        }
      });
    }

    /**
     * @function
     * @memberof Modifiers
     * @argument {Object} data - The data object generated by `update` method
     * @argument {Object} data.styles - List of style properties - values to apply to popper element
     * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
     * @argument {Object} options - Modifiers configuration and options
     * @returns {Object} The same data object
     */
    function applyStyle(data) {
      // any property present in `data.styles` will be applied to the popper,
      // in this way we can make the 3rd party modifiers add custom styles to it
      // Be aware, modifiers could override the properties defined in the previous
      // lines of this modifier!
      setStyles(data.instance.popper, data.styles);

      // any property present in `data.attributes` will be applied to the popper,
      // they will be set as HTML attributes of the element
      setAttributes(data.instance.popper, data.attributes);

      // if arrowElement is defined and arrowStyles has some properties
      if (data.arrowElement && Object.keys(data.arrowStyles).length) {
        setStyles(data.arrowElement, data.arrowStyles);
      }

      return data;
    }

    /**
     * Set the x-placement attribute before everything else because it could be used
     * to add margins to the popper margins needs to be calculated to get the
     * correct popper offsets.
     * @method
     * @memberof Popper.modifiers
     * @param {HTMLElement} reference - The reference element used to position the popper
     * @param {HTMLElement} popper - The HTML element used as popper
     * @param {Object} options - Popper.js options
     */
    function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
      // compute reference element offsets
      var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);

      // compute auto placement, store placement inside the data object,
      // modifiers will be able to edit `placement` if needed
      // and refer to originalPlacement to know the original value
      var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);

      popper.setAttribute('x-placement', placement);

      // Apply `position` to popper before anything else because
      // without the position applied we can't guarantee correct computations
      setStyles(popper, { position: options.positionFixed ? 'fixed' : 'absolute' });

      return options;
    }

    /**
     * @function
     * @memberof Modifiers
     * @argument {Object} data - The data object generated by `update` method
     * @argument {Object} options - Modifiers configuration and options
     * @returns {Object} The data object, properly modified
     */
    function computeStyle(data, options) {
      var x = options.x,
          y = options.y;
      var popper = data.offsets.popper;

      // Remove this legacy support in Popper.js v2

      var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
        return modifier.name === 'applyStyle';
      }).gpuAcceleration;
      if (legacyGpuAccelerationOption !== undefined) {
        console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
      }
      var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;

      var offsetParent = getOffsetParent(data.instance.popper);
      var offsetParentRect = getBoundingClientRect(offsetParent);

      // Styles
      var styles = {
        position: popper.position
      };

      // Avoid blurry text by using full pixel integers.
      // For pixel-perfect positioning, top/bottom prefers rounded
      // values, while left/right prefers floored values.
      var offsets = {
        left: Math.floor(popper.left),
        top: Math.round(popper.top),
        bottom: Math.round(popper.bottom),
        right: Math.floor(popper.right)
      };

      var sideA = x === 'bottom' ? 'top' : 'bottom';
      var sideB = y === 'right' ? 'left' : 'right';

      // if gpuAcceleration is set to `true` and transform is supported,
      //  we use `translate3d` to apply the position to the popper we
      // automatically use the supported prefixed version if needed
      var prefixedProperty = getSupportedPropertyName('transform');

      // now, let's make a step back and look at this code closely (wtf?)
      // If the content of the popper grows once it's been positioned, it
      // may happen that the popper gets misplaced because of the new content
      // overflowing its reference element
      // To avoid this problem, we provide two options (x and y), which allow
      // the consumer to define the offset origin.
      // If we position a popper on top of a reference element, we can set
      // `x` to `top` to make the popper grow towards its top instead of
      // its bottom.
      var left = void 0,
          top = void 0;
      if (sideA === 'bottom') {
        top = -offsetParentRect.height + offsets.bottom;
      } else {
        top = offsets.top;
      }
      if (sideB === 'right') {
        left = -offsetParentRect.width + offsets.right;
      } else {
        left = offsets.left;
      }
      if (gpuAcceleration && prefixedProperty) {
        styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
        styles[sideA] = 0;
        styles[sideB] = 0;
        styles.willChange = 'transform';
      } else {
        // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
        var invertTop = sideA === 'bottom' ? -1 : 1;
        var invertLeft = sideB === 'right' ? -1 : 1;
        styles[sideA] = top * invertTop;
        styles[sideB] = left * invertLeft;
        styles.willChange = sideA + ', ' + sideB;
      }

      // Attributes
      var attributes = {
        'x-placement': data.placement
      };

      // Update `data` attributes, styles and arrowStyles
      data.attributes = _extends({}, attributes, data.attributes);
      data.styles = _extends({}, styles, data.styles);
      data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);

      return data;
    }

    /**
     * Helper used to know if the given modifier depends from another one.<br />
     * It checks if the needed modifier is listed and enabled.
     * @method
     * @memberof Popper.Utils
     * @param {Array} modifiers - list of modifiers
     * @param {String} requestingName - name of requesting modifier
     * @param {String} requestedName - name of requested modifier
     * @returns {Boolean}
     */
    function isModifierRequired(modifiers, requestingName, requestedName) {
      var requesting = find(modifiers, function (_ref) {
        var name = _ref.name;
        return name === requestingName;
      });

      var isRequired = !!requesting && modifiers.some(function (modifier) {
        return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
      });

      if (!isRequired) {
        var _requesting = '`' + requestingName + '`';
        var requested = '`' + requestedName + '`';
        console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
      }
      return isRequired;
    }

    /**
     * @function
     * @memberof Modifiers
     * @argument {Object} data - The data object generated by update method
     * @argument {Object} options - Modifiers configuration and options
     * @returns {Object} The data object, properly modified
     */
    function arrow(data, options) {
      var _data$offsets$arrow;

      // arrow depends on keepTogether in order to work
      if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
        return data;
      }

      var arrowElement = options.element;

      // if arrowElement is a string, suppose it's a CSS selector
      if (typeof arrowElement === 'string') {
        arrowElement = data.instance.popper.querySelector(arrowElement);

        // if arrowElement is not found, don't run the modifier
        if (!arrowElement) {
          return data;
        }
      } else {
        // if the arrowElement isn't a query selector we must check that the
        // provided DOM node is child of its popper node
        if (!data.instance.popper.contains(arrowElement)) {
          console.warn('WARNING: `arrow.element` must be child of its popper element!');
          return data;
        }
      }

      var placement = data.placement.split('-')[0];
      var _data$offsets = data.offsets,
          popper = _data$offsets.popper,
          reference = _data$offsets.reference;

      var isVertical = ['left', 'right'].indexOf(placement) !== -1;

      var len = isVertical ? 'height' : 'width';
      var sideCapitalized = isVertical ? 'Top' : 'Left';
      var side = sideCapitalized.toLowerCase();
      var altSide = isVertical ? 'left' : 'top';
      var opSide = isVertical ? 'bottom' : 'right';
      var arrowElementSize = getOuterSizes(arrowElement)[len];

      //
      // extends keepTogether behavior making sure the popper and its
      // reference have enough pixels in conjuction
      //

      // top/left side
      if (reference[opSide] - arrowElementSize < popper[side]) {
        data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
      }
      // bottom/right side
      if (reference[side] + arrowElementSize > popper[opSide]) {
        data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
      }
      data.offsets.popper = getClientRect(data.offsets.popper);

      // compute center of the popper
      var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;

      // Compute the sideValue using the updated popper offsets
      // take popper margin in account because we don't have this info available
      var css = getStyleComputedProperty(data.instance.popper);
      var popperMarginSide = parseFloat(css['margin' + sideCapitalized], 10);
      var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width'], 10);
      var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;

      // prevent arrowElement from being placed not contiguously to its popper
      sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);

      data.arrowElement = arrowElement;
      data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty$1(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty$1(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);

      return data;
    }

    /**
     * Get the opposite placement variation of the given one
     * @method
     * @memberof Popper.Utils
     * @argument {String} placement variation
     * @returns {String} flipped placement variation
     */
    function getOppositeVariation(variation) {
      if (variation === 'end') {
        return 'start';
      } else if (variation === 'start') {
        return 'end';
      }
      return variation;
    }

    /**
     * List of accepted placements to use as values of the `placement` option.<br />
     * Valid placements are:
     * - `auto`
     * - `top`
     * - `right`
     * - `bottom`
     * - `left`
     *
     * Each placement can have a variation from this list:
     * - `-start`
     * - `-end`
     *
     * Variations are interpreted easily if you think of them as the left to right
     * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
     * is right.<br />
     * Vertically (`left` and `right`), `start` is top and `end` is bottom.
     *
     * Some valid examples are:
     * - `top-end` (on top of reference, right aligned)
     * - `right-start` (on right of reference, top aligned)
     * - `bottom` (on bottom, centered)
     * - `auto-right` (on the side with more space available, alignment depends by placement)
     *
     * @static
     * @type {Array}
     * @enum {String}
     * @readonly
     * @method placements
     * @memberof Popper
     */
    var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];

    // Get rid of `auto` `auto-start` and `auto-end`
    var validPlacements = placements.slice(3);

    /**
     * Given an initial placement, returns all the subsequent placements
     * clockwise (or counter-clockwise).
     *
     * @method
     * @memberof Popper.Utils
     * @argument {String} placement - A valid placement (it accepts variations)
     * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
     * @returns {Array} placements including their variations
     */
    function clockwise(placement) {
      var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      var index = validPlacements.indexOf(placement);
      var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
      return counter ? arr.reverse() : arr;
    }

    var BEHAVIORS = {
      FLIP: 'flip',
      CLOCKWISE: 'clockwise',
      COUNTERCLOCKWISE: 'counterclockwise'
    };

    /**
     * @function
     * @memberof Modifiers
     * @argument {Object} data - The data object generated by update method
     * @argument {Object} options - Modifiers configuration and options
     * @returns {Object} The data object, properly modified
     */
    function flip(data, options) {
      // if `inner` modifier is enabled, we can't use the `flip` modifier
      if (isModifierEnabled(data.instance.modifiers, 'inner')) {
        return data;
      }

      if (data.flipped && data.placement === data.originalPlacement) {
        // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
        return data;
      }

      var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);

      var placement = data.placement.split('-')[0];
      var placementOpposite = getOppositePlacement(placement);
      var variation = data.placement.split('-')[1] || '';

      var flipOrder = [];

      switch (options.behavior) {
        case BEHAVIORS.FLIP:
          flipOrder = [placement, placementOpposite];
          break;
        case BEHAVIORS.CLOCKWISE:
          flipOrder = clockwise(placement);
          break;
        case BEHAVIORS.COUNTERCLOCKWISE:
          flipOrder = clockwise(placement, true);
          break;
        default:
          flipOrder = options.behavior;
      }

      flipOrder.forEach(function (step, index) {
        if (placement !== step || flipOrder.length === index + 1) {
          return data;
        }

        placement = data.placement.split('-')[0];
        placementOpposite = getOppositePlacement(placement);

        var popperOffsets = data.offsets.popper;
        var refOffsets = data.offsets.reference;

        // using floor because the reference offsets may contain decimals we are not going to consider here
        var floor = Math.floor;
        var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);

        var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
        var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
        var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
        var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);

        var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;

        // flip the variation if required
        var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
        var flippedVariation = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);

        if (overlapsRef || overflowsBoundaries || flippedVariation) {
          // this boolean to detect any flip loop
          data.flipped = true;

          if (overlapsRef || overflowsBoundaries) {
            placement = flipOrder[index + 1];
          }

          if (flippedVariation) {
            variation = getOppositeVariation(variation);
          }

          data.placement = placement + (variation ? '-' + variation : '');

          // this object contains `position`, we want to preserve it along with
          // any additional property we may add in the future
          data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));

          data = runModifiers(data.instance.modifiers, data, 'flip');
        }
      });
      return data;
    }

    /**
     * @function
     * @memberof Modifiers
     * @argument {Object} data - The data object generated by update method
     * @argument {Object} options - Modifiers configuration and options
     * @returns {Object} The data object, properly modified
     */
    function keepTogether(data) {
      var _data$offsets = data.offsets,
          popper = _data$offsets.popper,
          reference = _data$offsets.reference;

      var placement = data.placement.split('-')[0];
      var floor = Math.floor;
      var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
      var side = isVertical ? 'right' : 'bottom';
      var opSide = isVertical ? 'left' : 'top';
      var measurement = isVertical ? 'width' : 'height';

      if (popper[side] < floor(reference[opSide])) {
        data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
      }
      if (popper[opSide] > floor(reference[side])) {
        data.offsets.popper[opSide] = floor(reference[side]);
      }

      return data;
    }

    /**
     * Converts a string containing value + unit into a px value number
     * @function
     * @memberof {modifiers~offset}
     * @private
     * @argument {String} str - Value + unit string
     * @argument {String} measurement - `height` or `width`
     * @argument {Object} popperOffsets
     * @argument {Object} referenceOffsets
     * @returns {Number|String}
     * Value in pixels, or original string if no values were extracted
     */
    function toValue(str, measurement, popperOffsets, referenceOffsets) {
      // separate value from unit
      var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
      var value = +split[1];
      var unit = split[2];

      // If it's not a number it's an operator, I guess
      if (!value) {
        return str;
      }

      if (unit.indexOf('%') === 0) {
        var element = void 0;
        switch (unit) {
          case '%p':
            element = popperOffsets;
            break;
          case '%':
          case '%r':
          default:
            element = referenceOffsets;
        }

        var rect = getClientRect(element);
        return rect[measurement] / 100 * value;
      } else if (unit === 'vh' || unit === 'vw') {
        // if is a vh or vw, we calculate the size based on the viewport
        var size = void 0;
        if (unit === 'vh') {
          size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
        } else {
          size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
        }
        return size / 100 * value;
      } else {
        // if is an explicit pixel unit, we get rid of the unit and keep the value
        // if is an implicit unit, it's px, and we return just the value
        return value;
      }
    }

    /**
     * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
     * @function
     * @memberof {modifiers~offset}
     * @private
     * @argument {String} offset
     * @argument {Object} popperOffsets
     * @argument {Object} referenceOffsets
     * @argument {String} basePlacement
     * @returns {Array} a two cells array with x and y offsets in numbers
     */
    function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
      var offsets = [0, 0];

      // Use height if placement is left or right and index is 0 otherwise use width
      // in this way the first offset will use an axis and the second one
      // will use the other one
      var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;

      // Split the offset string to obtain a list of values and operands
      // The regex addresses values with the plus or minus sign in front (+10, -20, etc)
      var fragments = offset.split(/(\+|\-)/).map(function (frag) {
        return frag.trim();
      });

      // Detect if the offset string contains a pair of values or a single one
      // they could be separated by comma or space
      var divider = fragments.indexOf(find(fragments, function (frag) {
        return frag.search(/,|\s/) !== -1;
      }));

      if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
        console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
      }

      // If divider is found, we divide the list of values and operands to divide
      // them by ofset X and Y.
      var splitRegex = /\s*,\s*|\s+/;
      var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];

      // Convert the values with units to absolute pixels to allow our computations
      ops = ops.map(function (op, index) {
        // Most of the units rely on the orientation of the popper
        var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
        var mergeWithPrevious = false;
        return op
        // This aggregates any `+` or `-` sign that aren't considered operators
        // e.g.: 10 + +5 => [10, +, +5]
        .reduce(function (a, b) {
          if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
            a[a.length - 1] = b;
            mergeWithPrevious = true;
            return a;
          } else if (mergeWithPrevious) {
            a[a.length - 1] += b;
            mergeWithPrevious = false;
            return a;
          } else {
            return a.concat(b);
          }
        }, [])
        // Here we convert the string values into number values (in px)
        .map(function (str) {
          return toValue(str, measurement, popperOffsets, referenceOffsets);
        });
      });

      // Loop trough the offsets arrays and execute the operations
      ops.forEach(function (op, index) {
        op.forEach(function (frag, index2) {
          if (isNumeric(frag)) {
            offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
          }
        });
      });
      return offsets;
    }

    /**
     * @function
     * @memberof Modifiers
     * @argument {Object} data - The data object generated by update method
     * @argument {Object} options - Modifiers configuration and options
     * @argument {Number|String} options.offset=0
     * The offset value as described in the modifier description
     * @returns {Object} The data object, properly modified
     */
    function offset(data, _ref) {
      var offset = _ref.offset;
      var placement = data.placement,
          _data$offsets = data.offsets,
          popper = _data$offsets.popper,
          reference = _data$offsets.reference;

      var basePlacement = placement.split('-')[0];

      var offsets = void 0;
      if (isNumeric(+offset)) {
        offsets = [+offset, 0];
      } else {
        offsets = parseOffset(offset, popper, reference, basePlacement);
      }

      if (basePlacement === 'left') {
        popper.top += offsets[0];
        popper.left -= offsets[1];
      } else if (basePlacement === 'right') {
        popper.top += offsets[0];
        popper.left += offsets[1];
      } else if (basePlacement === 'top') {
        popper.left += offsets[0];
        popper.top -= offsets[1];
      } else if (basePlacement === 'bottom') {
        popper.left += offsets[0];
        popper.top += offsets[1];
      }

      data.popper = popper;
      return data;
    }

    /**
     * @function
     * @memberof Modifiers
     * @argument {Object} data - The data object generated by `update` method
     * @argument {Object} options - Modifiers configuration and options
     * @returns {Object} The data object, properly modified
     */
    function preventOverflow(data, options) {
      var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);

      // If offsetParent is the reference element, we really want to
      // go one step up and use the next offsetParent as reference to
      // avoid to make this modifier completely useless and look like broken
      if (data.instance.reference === boundariesElement) {
        boundariesElement = getOffsetParent(boundariesElement);
      }

      // NOTE: DOM access here
      // resets the popper's position so that the document size can be calculated excluding
      // the size of the popper element itself
      var transformProp = getSupportedPropertyName('transform');
      var popperStyles = data.instance.popper.style; // assignment to help minification
      var top = popperStyles.top,
          left = popperStyles.left,
          transform = popperStyles[transformProp];

      popperStyles.top = '';
      popperStyles.left = '';
      popperStyles[transformProp] = '';

      var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);

      // NOTE: DOM access here
      // restores the original style properties after the offsets have been computed
      popperStyles.top = top;
      popperStyles.left = left;
      popperStyles[transformProp] = transform;

      options.boundaries = boundaries;

      var order = options.priority;
      var popper = data.offsets.popper;

      var check = {
        primary: function primary(placement) {
          var value = popper[placement];
          if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
            value = Math.max(popper[placement], boundaries[placement]);
          }
          return defineProperty$1({}, placement, value);
        },
        secondary: function secondary(placement) {
          var mainSide = placement === 'right' ? 'left' : 'top';
          var value = popper[mainSide];
          if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
            value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
          }
          return defineProperty$1({}, mainSide, value);
        }
      };

      order.forEach(function (placement) {
        var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
        popper = _extends({}, popper, check[side](placement));
      });

      data.offsets.popper = popper;

      return data;
    }

    /**
     * @function
     * @memberof Modifiers
     * @argument {Object} data - The data object generated by `update` method
     * @argument {Object} options - Modifiers configuration and options
     * @returns {Object} The data object, properly modified
     */
    function shift(data) {
      var placement = data.placement;
      var basePlacement = placement.split('-')[0];
      var shiftvariation = placement.split('-')[1];

      // if shift shiftvariation is specified, run the modifier
      if (shiftvariation) {
        var _data$offsets = data.offsets,
            reference = _data$offsets.reference,
            popper = _data$offsets.popper;

        var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
        var side = isVertical ? 'left' : 'top';
        var measurement = isVertical ? 'width' : 'height';

        var shiftOffsets = {
          start: defineProperty$1({}, side, reference[side]),
          end: defineProperty$1({}, side, reference[side] + reference[measurement] - popper[measurement])
        };

        data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
      }

      return data;
    }

    /**
     * @function
     * @memberof Modifiers
     * @argument {Object} data - The data object generated by update method
     * @argument {Object} options - Modifiers configuration and options
     * @returns {Object} The data object, properly modified
     */
    function hide(data) {
      if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
        return data;
      }

      var refRect = data.offsets.reference;
      var bound = find(data.instance.modifiers, function (modifier) {
        return modifier.name === 'preventOverflow';
      }).boundaries;

      if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
        // Avoid unnecessary DOM access if visibility hasn't changed
        if (data.hide === true) {
          return data;
        }

        data.hide = true;
        data.attributes['x-out-of-boundaries'] = '';
      } else {
        // Avoid unnecessary DOM access if visibility hasn't changed
        if (data.hide === false) {
          return data;
        }

        data.hide = false;
        data.attributes['x-out-of-boundaries'] = false;
      }

      return data;
    }

    /**
     * @function
     * @memberof Modifiers
     * @argument {Object} data - The data object generated by `update` method
     * @argument {Object} options - Modifiers configuration and options
     * @returns {Object} The data object, properly modified
     */
    function inner(data) {
      var placement = data.placement;
      var basePlacement = placement.split('-')[0];
      var _data$offsets = data.offsets,
          popper = _data$offsets.popper,
          reference = _data$offsets.reference;

      var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;

      var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;

      popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);

      data.placement = getOppositePlacement(placement);
      data.offsets.popper = getClientRect(popper);

      return data;
    }

    /**
     * Modifier function, each modifier can have a function of this type assigned
     * to its `fn` property.<br />
     * These functions will be called on each update, this means that you must
     * make sure they are performant enough to avoid performance bottlenecks.
     *
     * @function ModifierFn
     * @argument {dataObject} data - The data object generated by `update` method
     * @argument {Object} options - Modifiers configuration and options
     * @returns {dataObject} The data object, properly modified
     */

    /**
     * Modifiers are plugins used to alter the behavior of your poppers.<br />
     * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
     * needed by the library.
     *
     * Usually you don't want to override the `order`, `fn` and `onLoad` props.
     * All the other properties are configurations that could be tweaked.
     * @namespace modifiers
     */
    var modifiers = {
      /**
       * Modifier used to shift the popper on the start or end of its reference
       * element.<br />
       * It will read the variation of the `placement` property.<br />
       * It can be one either `-end` or `-start`.
       * @memberof modifiers
       * @inner
       */
      shift: {
        /** @prop {number} order=100 - Index used to define the order of execution */
        order: 100,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: shift
      },

      /**
       * The `offset` modifier can shift your popper on both its axis.
       *
       * It accepts the following units:
       * - `px` or unitless, interpreted as pixels
       * - `%` or `%r`, percentage relative to the length of the reference element
       * - `%p`, percentage relative to the length of the popper element
       * - `vw`, CSS viewport width unit
       * - `vh`, CSS viewport height unit
       *
       * For length is intended the main axis relative to the placement of the popper.<br />
       * This means that if the placement is `top` or `bottom`, the length will be the
       * `width`. In case of `left` or `right`, it will be the height.
       *
       * You can provide a single value (as `Number` or `String`), or a pair of values
       * as `String` divided by a comma or one (or more) white spaces.<br />
       * The latter is a deprecated method because it leads to confusion and will be
       * removed in v2.<br />
       * Additionally, it accepts additions and subtractions between different units.
       * Note that multiplications and divisions aren't supported.
       *
       * Valid examples are:
       * ```
       * 10
       * '10%'
       * '10, 10'
       * '10%, 10'
       * '10 + 10%'
       * '10 - 5vh + 3%'
       * '-10px + 5vh, 5px - 6%'
       * ```
       * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
       * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
       * > More on this [reading this issue](https://github.com/FezVrasta/popper.js/issues/373)
       *
       * @memberof modifiers
       * @inner
       */
      offset: {
        /** @prop {number} order=200 - Index used to define the order of execution */
        order: 200,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: offset,
        /** @prop {Number|String} offset=0
         * The offset value as described in the modifier description
         */
        offset: 0
      },

      /**
       * Modifier used to prevent the popper from being positioned outside the boundary.
       *
       * An scenario exists where the reference itself is not within the boundaries.<br />
       * We can say it has "escaped the boundaries" — or just "escaped".<br />
       * In this case we need to decide whether the popper should either:
       *
       * - detach from the reference and remain "trapped" in the boundaries, or
       * - if it should ignore the boundary and "escape with its reference"
       *
       * When `escapeWithReference` is set to`true` and reference is completely
       * outside its boundaries, the popper will overflow (or completely leave)
       * the boundaries in order to remain attached to the edge of the reference.
       *
       * @memberof modifiers
       * @inner
       */
      preventOverflow: {
        /** @prop {number} order=300 - Index used to define the order of execution */
        order: 300,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: preventOverflow,
        /**
         * @prop {Array} [priority=['left','right','top','bottom']]
         * Popper will try to prevent overflow following these priorities by default,
         * then, it could overflow on the left and on top of the `boundariesElement`
         */
        priority: ['left', 'right', 'top', 'bottom'],
        /**
         * @prop {number} padding=5
         * Amount of pixel used to define a minimum distance between the boundaries
         * and the popper this makes sure the popper has always a little padding
         * between the edges of its container
         */
        padding: 5,
        /**
         * @prop {String|HTMLElement} boundariesElement='scrollParent'
         * Boundaries used by the modifier, can be `scrollParent`, `window`,
         * `viewport` or any DOM element.
         */
        boundariesElement: 'scrollParent'
      },

      /**
       * Modifier used to make sure the reference and its popper stay near eachothers
       * without leaving any gap between the two. Expecially useful when the arrow is
       * enabled and you want to assure it to point to its reference element.
       * It cares only about the first axis, you can still have poppers with margin
       * between the popper and its reference element.
       * @memberof modifiers
       * @inner
       */
      keepTogether: {
        /** @prop {number} order=400 - Index used to define the order of execution */
        order: 400,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: keepTogether
      },

      /**
       * This modifier is used to move the `arrowElement` of the popper to make
       * sure it is positioned between the reference element and its popper element.
       * It will read the outer size of the `arrowElement` node to detect how many
       * pixels of conjuction are needed.
       *
       * It has no effect if no `arrowElement` is provided.
       * @memberof modifiers
       * @inner
       */
      arrow: {
        /** @prop {number} order=500 - Index used to define the order of execution */
        order: 500,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: arrow,
        /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
        element: '[x-arrow]'
      },

      /**
       * Modifier used to flip the popper's placement when it starts to overlap its
       * reference element.
       *
       * Requires the `preventOverflow` modifier before it in order to work.
       *
       * **NOTE:** this modifier will interrupt the current update cycle and will
       * restart it if it detects the need to flip the placement.
       * @memberof modifiers
       * @inner
       */
      flip: {
        /** @prop {number} order=600 - Index used to define the order of execution */
        order: 600,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: flip,
        /**
         * @prop {String|Array} behavior='flip'
         * The behavior used to change the popper's placement. It can be one of
         * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
         * placements (with optional variations).
         */
        behavior: 'flip',
        /**
         * @prop {number} padding=5
         * The popper will flip if it hits the edges of the `boundariesElement`
         */
        padding: 5,
        /**
         * @prop {String|HTMLElement} boundariesElement='viewport'
         * The element which will define the boundaries of the popper position,
         * the popper will never be placed outside of the defined boundaries
         * (except if keepTogether is enabled)
         */
        boundariesElement: 'viewport'
      },

      /**
       * Modifier used to make the popper flow toward the inner of the reference element.
       * By default, when this modifier is disabled, the popper will be placed outside
       * the reference element.
       * @memberof modifiers
       * @inner
       */
      inner: {
        /** @prop {number} order=700 - Index used to define the order of execution */
        order: 700,
        /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
        enabled: false,
        /** @prop {ModifierFn} */
        fn: inner
      },

      /**
       * Modifier used to hide the popper when its reference element is outside of the
       * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
       * be used to hide with a CSS selector the popper when its reference is
       * out of boundaries.
       *
       * Requires the `preventOverflow` modifier before it in order to work.
       * @memberof modifiers
       * @inner
       */
      hide: {
        /** @prop {number} order=800 - Index used to define the order of execution */
        order: 800,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: hide
      },

      /**
       * Computes the style that will be applied to the popper element to gets
       * properly positioned.
       *
       * Note that this modifier will not touch the DOM, it just prepares the styles
       * so that `applyStyle` modifier can apply it. This separation is useful
       * in case you need to replace `applyStyle` with a custom implementation.
       *
       * This modifier has `850` as `order` value to maintain backward compatibility
       * with previous versions of Popper.js. Expect the modifiers ordering method
       * to change in future major versions of the library.
       *
       * @memberof modifiers
       * @inner
       */
      computeStyle: {
        /** @prop {number} order=850 - Index used to define the order of execution */
        order: 850,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: computeStyle,
        /**
         * @prop {Boolean} gpuAcceleration=true
         * If true, it uses the CSS 3d transformation to position the popper.
         * Otherwise, it will use the `top` and `left` properties.
         */
        gpuAcceleration: true,
        /**
         * @prop {string} [x='bottom']
         * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
         * Change this if your popper should grow in a direction different from `bottom`
         */
        x: 'bottom',
        /**
         * @prop {string} [x='left']
         * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
         * Change this if your popper should grow in a direction different from `right`
         */
        y: 'right'
      },

      /**
       * Applies the computed styles to the popper element.
       *
       * All the DOM manipulations are limited to this modifier. This is useful in case
       * you want to integrate Popper.js inside a framework or view library and you
       * want to delegate all the DOM manipulations to it.
       *
       * Note that if you disable this modifier, you must make sure the popper element
       * has its position set to `absolute` before Popper.js can do its work!
       *
       * Just disable this modifier and define you own to achieve the desired effect.
       *
       * @memberof modifiers
       * @inner
       */
      applyStyle: {
        /** @prop {number} order=900 - Index used to define the order of execution */
        order: 900,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: applyStyle,
        /** @prop {Function} */
        onLoad: applyStyleOnLoad,
        /**
         * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
         * @prop {Boolean} gpuAcceleration=true
         * If true, it uses the CSS 3d transformation to position the popper.
         * Otherwise, it will use the `top` and `left` properties.
         */
        gpuAcceleration: undefined
      }
    };

    /**
     * The `dataObject` is an object containing all the informations used by Popper.js
     * this object get passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
     * @name dataObject
     * @property {Object} data.instance The Popper.js instance
     * @property {String} data.placement Placement applied to popper
     * @property {String} data.originalPlacement Placement originally defined on init
     * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
     * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper.
     * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
     * @property {Object} data.styles Any CSS property defined here will be applied to the popper, it expects the JavaScript nomenclature (eg. `marginBottom`)
     * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow, it expects the JavaScript nomenclature (eg. `marginBottom`)
     * @property {Object} data.boundaries Offsets of the popper boundaries
     * @property {Object} data.offsets The measurements of popper, reference and arrow elements.
     * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
     * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
     * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
     */

    /**
     * Default options provided to Popper.js constructor.<br />
     * These can be overriden using the `options` argument of Popper.js.<br />
     * To override an option, simply pass as 3rd argument an object with the same
     * structure of this object, example:
     * ```
     * new Popper(ref, pop, {
     *   modifiers: {
     *     preventOverflow: { enabled: false }
     *   }
     * })
     * ```
     * @type {Object}
     * @static
     * @memberof Popper
     */
    var Defaults = {
      /**
       * Popper's placement
       * @prop {Popper.placements} placement='bottom'
       */
      placement: 'bottom',

      /**
       * Set this to true if you want popper to position it self in 'fixed' mode
       * @prop {Boolean} positionFixed=false
       */
      positionFixed: false,

      /**
       * Whether events (resize, scroll) are initially enabled
       * @prop {Boolean} eventsEnabled=true
       */
      eventsEnabled: true,

      /**
       * Set to true if you want to automatically remove the popper when
       * you call the `destroy` method.
       * @prop {Boolean} removeOnDestroy=false
       */
      removeOnDestroy: false,

      /**
       * Callback called when the popper is created.<br />
       * By default, is set to no-op.<br />
       * Access Popper.js instance with `data.instance`.
       * @prop {onCreate}
       */
      onCreate: function onCreate() {},

      /**
       * Callback called when the popper is updated, this callback is not called
       * on the initialization/creation of the popper, but only on subsequent
       * updates.<br />
       * By default, is set to no-op.<br />
       * Access Popper.js instance with `data.instance`.
       * @prop {onUpdate}
       */
      onUpdate: function onUpdate() {},

      /**
       * List of modifiers used to modify the offsets before they are applied to the popper.
       * They provide most of the functionalities of Popper.js
       * @prop {modifiers}
       */
      modifiers: modifiers
    };

    /**
     * @callback onCreate
     * @param {dataObject} data
     */

    /**
     * @callback onUpdate
     * @param {dataObject} data
     */

    // Utils
    // Methods
    var Popper = function () {
      /**
       * Create a new Popper.js instance
       * @class Popper
       * @param {HTMLElement|referenceObject} reference - The reference element used to position the popper
       * @param {HTMLElement} popper - The HTML element used as popper.
       * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
       * @return {Object} instance - The generated Popper.js instance
       */
      function Popper(reference, popper) {
        var _this = this;

        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        classCallCheck(this, Popper);

        this.scheduleUpdate = function () {
          return requestAnimationFrame(_this.update);
        };

        // make update() debounced, so that it only runs at most once-per-tick
        this.update = debounce(this.update.bind(this));

        // with {} we create a new object with the options inside it
        this.options = _extends({}, Popper.Defaults, options);

        // init state
        this.state = {
          isDestroyed: false,
          isCreated: false,
          scrollParents: []
        };

        // get reference and popper elements (allow jQuery wrappers)
        this.reference = reference && reference.jquery ? reference[0] : reference;
        this.popper = popper && popper.jquery ? popper[0] : popper;

        // Deep merge modifiers options
        this.options.modifiers = {};
        Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
          _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
        });

        // Refactoring modifiers' list (Object => Array)
        this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
          return _extends({
            name: name
          }, _this.options.modifiers[name]);
        })
        // sort the modifiers by order
        .sort(function (a, b) {
          return a.order - b.order;
        });

        // modifiers have the ability to execute arbitrary code when Popper.js get inited
        // such code is executed in the same order of its modifier
        // they could add new properties to their options configuration
        // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!
        this.modifiers.forEach(function (modifierOptions) {
          if (modifierOptions.enabled && isFunction$2(modifierOptions.onLoad)) {
            modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
          }
        });

        // fire the first update to position the popper in the right place
        this.update();

        var eventsEnabled = this.options.eventsEnabled;
        if (eventsEnabled) {
          // setup event listeners, they will take care of update the position in specific situations
          this.enableEventListeners();
        }

        this.state.eventsEnabled = eventsEnabled;
      }

      // We can't use class properties because they don't get listed in the
      // class prototype and break stuff like Sinon stubs


      createClass(Popper, [{
        key: 'update',
        value: function update$$1() {
          return update.call(this);
        }
      }, {
        key: 'destroy',
        value: function destroy$$1() {
          return destroy.call(this);
        }
      }, {
        key: 'enableEventListeners',
        value: function enableEventListeners$$1() {
          return enableEventListeners.call(this);
        }
      }, {
        key: 'disableEventListeners',
        value: function disableEventListeners$$1() {
          return disableEventListeners.call(this);
        }

        /**
         * Schedule an update, it will run on the next UI update available
         * @method scheduleUpdate
         * @memberof Popper
         */


        /**
         * Collection of utilities useful when writing custom modifiers.
         * Starting from version 1.7, this method is available only if you
         * include `popper-utils.js` before `popper.js`.
         *
         * **DEPRECATION**: This way to access PopperUtils is deprecated
         * and will be removed in v2! Use the PopperUtils module directly instead.
         * Due to the high instability of the methods contained in Utils, we can't
         * guarantee them to follow semver. Use them at your own risk!
         * @static
         * @private
         * @type {Object}
         * @deprecated since version 1.8
         * @member Utils
         * @memberof Popper
         */

      }]);
      return Popper;
    }();

    /**
     * The `referenceObject` is an object that provides an interface compatible with Popper.js
     * and lets you use it as replacement of a real DOM node.<br />
     * You can use this method to position a popper relatively to a set of coordinates
     * in case you don't have a DOM node to use as reference.
     *
     * ```
     * new Popper(referenceObject, popperNode);
     * ```
     *
     * NB: This feature isn't supported in Internet Explorer 10
     * @name referenceObject
     * @property {Function} data.getBoundingClientRect
     * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
     * @property {number} data.clientWidth
     * An ES6 getter that will return the width of the virtual reference element.
     * @property {number} data.clientHeight
     * An ES6 getter that will return the height of the virtual reference element.
     */


    Popper.Utils = (typeof window !== 'undefined' ? window : global$1).PopperUtils;
    Popper.placements = placements;
    Popper.Defaults = Defaults;
    //# sourceMappingURL=popper.js.map

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */
    function isUndefined(value) {
      return value === undefined;
    }

    /** `Object#toString` result references. */
    var boolTag$1 = '[object Boolean]';

    /**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false ||
        (isObjectLike(value) && baseGetTag(value) == boolTag$1);
    }

    /** Used to stand-in for `undefined` hash values. */
    var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

    /**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED$2);
      return this;
    }

    /**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */
    function setCacheHas(value) {
      return this.__data__.has(value);
    }

    /**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */
    function SetCache(values) {
      var index = -1,
          length = values == null ? 0 : values.length;

      this.__data__ = new MapCache;
      while (++index < length) {
        this.add(values[index]);
      }
    }

    // Add methods to `SetCache`.
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;

    /**
     * A specialized version of `_.some` for arrays without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function arraySome(array, predicate) {
      var index = -1,
          length = array == null ? 0 : array.length;

      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }

    /**
     * Checks if a `cache` value for `key` exists.
     *
     * @private
     * @param {Object} cache The cache to query.
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function cacheHas(cache, key) {
      return cache.has(key);
    }

    /** Used to compose bitmasks for value comparisons. */
    var COMPARE_PARTIAL_FLAG = 1,
        COMPARE_UNORDERED_FLAG = 2;

    /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
          arrLength = array.length,
          othLength = other.length;

      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(array);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var index = -1,
          result = true,
          seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

      stack.set(array, other);
      stack.set(other, array);

      // Ignore non-index properties.
      while (++index < arrLength) {
        var arrValue = array[index],
            othValue = other[index];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, arrValue, index, other, array, stack)
            : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== undefined) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        // Recursively compare arrays (susceptible to call stack limits).
        if (seen) {
          if (!arraySome(other, function(othValue, othIndex) {
                if (!cacheHas(seen, othIndex) &&
                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
            result = false;
            break;
          }
        } else if (!(
              arrValue === othValue ||
                equalFunc(arrValue, othValue, bitmask, customizer, stack)
            )) {
          result = false;
          break;
        }
      }
      stack['delete'](array);
      stack['delete'](other);
      return result;
    }

    /**
     * Converts `map` to its key-value pairs.
     *
     * @private
     * @param {Object} map The map to convert.
     * @returns {Array} Returns the key-value pairs.
     */
    function mapToArray(map) {
      var index = -1,
          result = Array(map.size);

      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }

    /**
     * Converts `set` to an array of its values.
     *
     * @private
     * @param {Object} set The set to convert.
     * @returns {Array} Returns the values.
     */
    function setToArray(set) {
      var index = -1,
          result = Array(set.size);

      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }

    /** Used to compose bitmasks for value comparisons. */
    var COMPARE_PARTIAL_FLAG$1 = 1,
        COMPARE_UNORDERED_FLAG$1 = 2;

    /** `Object#toString` result references. */
    var boolTag$2 = '[object Boolean]',
        dateTag$1 = '[object Date]',
        errorTag$1 = '[object Error]',
        mapTag$1 = '[object Map]',
        numberTag$1 = '[object Number]',
        regexpTag$1 = '[object RegExp]',
        setTag$1 = '[object Set]',
        stringTag$2 = '[object String]',
        symbolTag$1 = '[object Symbol]';

    var arrayBufferTag$1 = '[object ArrayBuffer]',
        dataViewTag$1 = '[object DataView]';

    /** Used to convert symbols to primitives and strings. */
    var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : undefined,
        symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : undefined;

    /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag$1:
          if ((object.byteLength != other.byteLength) ||
              (object.byteOffset != other.byteOffset)) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;

        case arrayBufferTag$1:
          if ((object.byteLength != other.byteLength) ||
              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
            return false;
          }
          return true;

        case boolTag$2:
        case dateTag$1:
        case numberTag$1:
          // Coerce booleans to `1` or `0` and dates to milliseconds.
          // Invalid dates are coerced to `NaN`.
          return eq(+object, +other);

        case errorTag$1:
          return object.name == other.name && object.message == other.message;

        case regexpTag$1:
        case stringTag$2:
          // Coerce regexes to strings and treat strings, primitives and objects,
          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
          // for more details.
          return object == (other + '');

        case mapTag$1:
          var convert = mapToArray;

        case setTag$1:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1;
          convert || (convert = setToArray);

          if (object.size != other.size && !isPartial) {
            return false;
          }
          // Assume cyclic values are equal.
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG$1;

          // Recursively compare objects (susceptible to call stack limits).
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack['delete'](object);
          return result;

        case symbolTag$1:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }

    /**
     * Appends the elements of `values` to `array`.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to append.
     * @returns {Array} Returns `array`.
     */
    function arrayPush(array, values) {
      var index = -1,
          length = values.length,
          offset = array.length;

      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }

    /**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }

    /**
     * A specialized version of `_.filter` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function arrayFilter(array, predicate) {
      var index = -1,
          length = array == null ? 0 : array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }

    /**
     * This method returns a new empty array.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Array} Returns the new empty array.
     * @example
     *
     * var arrays = _.times(2, _.stubArray);
     *
     * console.log(arrays);
     * // => [[], []]
     *
     * console.log(arrays[0] === arrays[1]);
     * // => false
     */
    function stubArray() {
      return [];
    }

    /** Used for built-in method references. */
    var objectProto$12 = Object.prototype;

    /** Built-in value references. */
    var propertyIsEnumerable$1 = objectProto$12.propertyIsEnumerable;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeGetSymbols = Object.getOwnPropertySymbols;

    /**
     * Creates an array of the own enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable$1.call(object, symbol);
      });
    };

    /**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }

    /** Used to compose bitmasks for value comparisons. */
    var COMPARE_PARTIAL_FLAG$2 = 1;

    /** Used for built-in method references. */
    var objectProto$13 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$10 = objectProto$13.hasOwnProperty;

    /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2,
          objProps = getAllKeys(object),
          objLength = objProps.length,
          othProps = getAllKeys(other),
          othLength = othProps.length;

      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty$10.call(other, key))) {
          return false;
        }
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);

      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key],
            othValue = other[key];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, objValue, key, other, object, stack)
            : customizer(objValue, othValue, key, object, other, stack);
        }
        // Recursively compare objects (susceptible to call stack limits).
        if (!(compared === undefined
              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
              : compared
            )) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == 'constructor');
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor,
            othCtor = other.constructor;

        // Non `Object` object instances with different constructors are not equal.
        if (objCtor != othCtor &&
            ('constructor' in object && 'constructor' in other) &&
            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack['delete'](object);
      stack['delete'](other);
      return result;
    }

    /* Built-in method references that are verified to be native. */
    var DataView = getNative(root, 'DataView');

    /* Built-in method references that are verified to be native. */
    var Promise$1 = getNative(root, 'Promise');

    /* Built-in method references that are verified to be native. */
    var Set = getNative(root, 'Set');

    /* Built-in method references that are verified to be native. */
    var WeakMap = getNative(root, 'WeakMap');

    /** `Object#toString` result references. */
    var mapTag$2 = '[object Map]',
        objectTag$2 = '[object Object]',
        promiseTag = '[object Promise]',
        setTag$2 = '[object Set]',
        weakMapTag$1 = '[object WeakMap]';

    var dataViewTag$2 = '[object DataView]';

    /** Used to detect maps, sets, and weakmaps. */
    var dataViewCtorString = toSource(DataView),
        mapCtorString = toSource(Map$1),
        promiseCtorString = toSource(Promise$1),
        setCtorString = toSource(Set),
        weakMapCtorString = toSource(WeakMap);

    /**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    var getTag = baseGetTag;

    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag$2) ||
        (Map$1 && getTag(new Map$1) != mapTag$2) ||
        (Promise$1 && getTag(Promise$1.resolve()) != promiseTag) ||
        (Set && getTag(new Set) != setTag$2) ||
        (WeakMap && getTag(new WeakMap) != weakMapTag$1)) {
      getTag = function(value) {
        var result = baseGetTag(value),
            Ctor = result == objectTag$2 ? value.constructor : undefined,
            ctorString = Ctor ? toSource(Ctor) : '';

        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString: return dataViewTag$2;
            case mapCtorString: return mapTag$2;
            case promiseCtorString: return promiseTag;
            case setCtorString: return setTag$2;
            case weakMapCtorString: return weakMapTag$1;
          }
        }
        return result;
      };
    }

    var getTag$1 = getTag;

    /** Used to compose bitmasks for value comparisons. */
    var COMPARE_PARTIAL_FLAG$3 = 1;

    /** `Object#toString` result references. */
    var argsTag$2 = '[object Arguments]',
        arrayTag$1 = '[object Array]',
        objectTag$3 = '[object Object]';

    /** Used for built-in method references. */
    var objectProto$14 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$11 = objectProto$14.hasOwnProperty;

    /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object),
          othIsArr = isArray(other),
          objTag = objIsArr ? arrayTag$1 : getTag$1(object),
          othTag = othIsArr ? arrayTag$1 : getTag$1(other);

      objTag = objTag == argsTag$2 ? objectTag$3 : objTag;
      othTag = othTag == argsTag$2 ? objectTag$3 : othTag;

      var objIsObj = objTag == objectTag$3,
          othIsObj = othTag == objectTag$3,
          isSameTag = objTag == othTag;

      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack);
        return (objIsArr || isTypedArray(object))
          ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
          : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG$3)) {
        var objIsWrapped = objIsObj && hasOwnProperty$11.call(object, '__wrapped__'),
            othIsWrapped = othIsObj && hasOwnProperty$11.call(other, '__wrapped__');

        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object,
              othUnwrapped = othIsWrapped ? other.value() : other;

          stack || (stack = new Stack);
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack);
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }

    /**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Unordered comparison
     *  2 - Partial comparison
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }

    /** Used to compose bitmasks for value comparisons. */
    var COMPARE_PARTIAL_FLAG$4 = 1,
        COMPARE_UNORDERED_FLAG$2 = 2;

    /**
     * The base implementation of `_.isMatch` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Array} matchData The property names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length,
          length = index,
          noCustomizer = !customizer;

      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if ((noCustomizer && data[2])
              ? data[1] !== object[data[0]]
              : !(data[0] in object)
            ) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0],
            objValue = object[key],
            srcValue = data[1];

        if (noCustomizer && data[2]) {
          if (objValue === undefined && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack;
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === undefined
                ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$4 | COMPARE_UNORDERED_FLAG$2, customizer, stack)
                : result
              )) {
            return false;
          }
        }
      }
      return true;
    }

    /**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }

    /**
     * Gets the property names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */
    function getMatchData(object) {
      var result = keys(object),
          length = result.length;

      while (length--) {
        var key = result[length],
            value = object[key];

        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }

    /**
     * A specialized version of `matchesProperty` for source values suitable
     * for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue &&
          (srcValue !== undefined || (key in Object(object)));
      };
    }

    /**
     * The base implementation of `_.matches` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }

    /** Used to match property names within property paths. */
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
        reIsPlainProp = /^\w*$/;

    /**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == 'number' || type == 'symbol' || type == 'boolean' ||
          value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
        (object != null && value in Object(object));
    }

    /** Error message constants. */
    var FUNC_ERROR_TEXT = 'Expected a function';

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided, it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the
     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoized function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // Modify the result cache.
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // Replace `_.memoize.Cache`.
     * _.memoize.Cache = WeakMap;
     */
    function memoize(func, resolver) {
      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments,
            key = resolver ? resolver.apply(this, args) : args[0],
            cache = memoized.cache;

        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache);
      return memoized;
    }

    // Expose `MapCache`.
    memoize.Cache = MapCache;

    /** Used as the maximum memoize cache size. */
    var MAX_MEMOIZE_SIZE = 500;

    /**
     * A specialized version of `_.memoize` which clears the memoized function's
     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
     *
     * @private
     * @param {Function} func The function to have its output memoized.
     * @returns {Function} Returns the new memoized function.
     */
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });

      var cache = result.cache;
      return result;
    }

    /** Used to match property names within property paths. */
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

    /** Used to match backslashes in property paths. */
    var reEscapeChar = /\\(\\)?/g;

    /**
     * Converts `string` to a property path array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the property path array.
     */
    var stringToPath = memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46 /* . */) {
        result.push('');
      }
      string.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
      });
      return result;
    });

    /**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {Object} [object] The object to query keys on.
     * @returns {Array} Returns the cast property path array.
     */
    function castPath(value, object) {
      if (isArray(value)) {
        return value;
      }
      return isKey(value, object) ? [value] : stringToPath(toString(value));
    }

    /** Used as references for various `Number` constants. */
    var INFINITY$1 = 1 / 0;

    /**
     * Converts `value` to a string key if it's not a string or symbol.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {string|symbol} Returns the key.
     */
    function toKey(value) {
      if (typeof value == 'string' || isSymbol(value)) {
        return value;
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY$1) ? '-0' : result;
    }

    /**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */
    function baseGet(object, path) {
      path = castPath(path, object);

      var index = 0,
          length = path.length;

      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return (index && index == length) ? object : undefined;
    }

    /**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined`, the `defaultValue` is returned in its place.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */
    function get(object, path, defaultValue) {
      var result = object == null ? undefined : baseGet(object, path);
      return result === undefined ? defaultValue : result;
    }

    /**
     * The base implementation of `_.hasIn` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }

    /**
     * Checks if `path` exists on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @param {Function} hasFunc The function to check properties.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     */
    function hasPath(object, path, hasFunc) {
      path = castPath(path, object);

      var index = -1,
          length = path.length,
          result = false;

      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result || ++index != length) {
        return result;
      }
      length = object == null ? 0 : object.length;
      return !!length && isLength(length) && isIndex(key, length) &&
        (isArray(object) || isArguments(object));
    }

    /**
     * Checks if `path` is a direct or inherited property of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.hasIn(object, 'a');
     * // => true
     *
     * _.hasIn(object, 'a.b');
     * // => true
     *
     * _.hasIn(object, ['a', 'b']);
     * // => true
     *
     * _.hasIn(object, 'b');
     * // => false
     */
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }

    /** Used to compose bitmasks for value comparisons. */
    var COMPARE_PARTIAL_FLAG$5 = 1,
        COMPARE_UNORDERED_FLAG$3 = 2;

    /**
     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get(object, path);
        return (objValue === undefined && objValue === srcValue)
          ? hasIn(object, path)
          : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$5 | COMPARE_UNORDERED_FLAG$3);
      };
    }

    /**
     * The base implementation of `_.property` without support for deep paths.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @returns {Function} Returns the new accessor function.
     */
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined : object[key];
      };
    }

    /**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     */
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }

    /**
     * Creates a function that returns the value at `path` of a given object.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': 2 } },
     *   { 'a': { 'b': 1 } }
     * ];
     *
     * _.map(objects, _.property('a.b'));
     * // => [2, 1]
     *
     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
     * // => [1, 2]
     */
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }

    /**
     * The base implementation of `_.iteratee`.
     *
     * @private
     * @param {*} [value=_.identity] The value to convert to an iteratee.
     * @returns {Function} Returns the iteratee.
     */
    function baseIteratee(value) {
      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
      if (typeof value == 'function') {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == 'object') {
        return isArray(value)
          ? baseMatchesProperty(value[0], value[1])
          : baseMatches(value);
      }
      return property(value);
    }

    /**
     * The opposite of `_.mapValues`; this method creates an object with the
     * same values as `object` and keys generated by running each own enumerable
     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
     * with three arguments: (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapValues
     * @example
     *
     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
     *   return key + value;
     * });
     * // => { 'a1': 1, 'b2': 2 }
     */
    function mapKeys(object, iteratee) {
      var result = {};
      iteratee = baseIteratee(iteratee, 3);

      baseForOwn(object, function(value, key, object) {
        baseAssignValue(result, iteratee(value, key, object), value);
      });
      return result;
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    function prefix(subject, prefix) {
      var delimeter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '-';

      var prefixer = function prefixer(value, key) {
        var string = key || value;
        return [prefix, string.replace(new RegExp("^".concat(prefix).concat(delimeter, "?")), '')].join(delimeter);
      };

      if (isBoolean(subject) || isNull(subject) || isUndefined(subject)) {
        return subject;
      }

      if (isObject(subject)) {
        return mapKeys(subject, prefixer);
      }

      return prefixer(subject);
    }

    var Popover = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          directives: [{
            name: "show",
            rawName: "v-show",
            value: _vm.isShowing,
            expression: "isShowing"
          }],
          staticClass: "popover",
          class: _vm.classes,
          attrs: {
            "role": "tooltip"
          }
        }, [_c('div', {
          staticClass: "arrow"
        }), _vm._v(" "), _vm.title ? _c('popover-header', {
          domProps: {
            "innerHTML": _vm._s(_vm.title)
          }
        }) : _vm._e(), _vm._v(" "), _c('popover-body', [_vm.content ? _c(_vm.content.$options, _vm._b({
          tag: "component"
        }, 'component', _vm.content.$options.propsData, false)) : _vm._e(), _vm._v(" "), _vm._t("default")], 2)], 1);
      },
      staticRenderFns: [],
      name: 'popover',
      props: {
        /**
         * Apply a CSS fade transition to the popover
         *
         * @type {Boolean}
         */
        animation: {
          type: Boolean,
          default: true
        },

        /**
         * Overflow constraint boundary of the popover. Accepts the values of
         * 'viewport', 'window', 'scrollParent', or an HTMLElement reference
         * (JavaScript only). For more information refer to Popper.js's
         * preventOverflow docs.
         *
         * @type {Object}
         */
        boundary: {
          type: [String, Array],
          default: 'scrollParent',
          validate: function validate(value) {
            return ['viewport', 'window', 'viewport'].indexOf(value) !== -1;
          }
        },

        /**
         * Appends the popover to a specific element.
         *
         * Example: container: 'body'.
         *
         * This option is particularly useful in that it allows you to position
         * the popover in the flow of the document near the triggering element -
         * which will prevent the popover from floating away from thetriggering
         * element during a window resize.
         *
         * @type {String|Element|Boolean}
         */
        container: {
          type: [String, Element, Boolean],
          default: false
        },

        /**
         * Does the same thing as the default slot, except it's meant to be used
         * when using the $popover plugin or programmatically instantiated popovers.
         *
         * @type {Function}
         */
        content: {
          type: Object,
          validate: function validate(value) {
            return value.constructor.name === 'VueComponent';
          }
        },

        /**
         * Delay closeing and hiding the popover (ms) - does not apply to manual trigger type
         *
         * If a number is supplied, delay is applied to both open/close
         *
         * Object structure is: delay: { "close": 500, "open": 100 }
         *
         * @type {Number|Object}
         */
        delay: {
          type: [Number, Object],
          default: 0
        },

        /**
         * Allow to specify which position Popper will use on fallback. For more
         * information refer to Popper.js's behavior docs
         *
         * @type {String|Array}
         */
        fallbackPlacement: {
          type: [String, Array],
          default: 'flip'
        },

        /**
         * Offset of the popover relative to its target. For more information
         * refer to Popper.js's offset docs.
         *
         * @type {Number|String}
         */
        offset: {
          type: [Number, String],
          default: 0
        },

        /**
         * How to position the popover - auto | top | bottom | left | right.
         *
         * When auto is specified, it will dynamically reorient the popover.
         *
         * When a function is used to determine the placement, it is called with
         * the popover DOM node as its first argument and the triggering element
         * DOM node as its second. The this context is set to the popover
         * instance.
         *
         * @type {String|Function}
         */
        placement: {
          type: [String, Function],
          default: 'top',
          validate: function validate(value) {
            return ['auto', 'top', 'bottom', 'left', 'right'].indexOf(value) !== -1;
          }
        },

        /**
         * If this property is passed, it will force the popover to be visible
         * by default.
         *
         * @type {Boolean}
         */
        show: Boolean,

        /**
         * If a selector is provided, popover objects will be delegated to the
         * specified targets. In practice, this is used to enable dynamic HTML
         * content to have popovers added. See this and an informative example.
         *
         * @type {Boolean|String}
         */
        selector: {
          type: [Boolean, String],
          default: false
        },

        /**
         * The target element used to position the popover.
         *
         * @type {String|Element|Boolean}
         */
        target: {
          type: [String, Element, Boolean],
          default: false
        },

        /**
         * The popover title
         *
         * @type {String}
         */
        title: String,

        /**
         * How popover is triggered - click | hover | focus | manual. You may
         * pass multiple triggers; separate them with a space. `manual` cannot
         * be combined with any other trigger.
         *
         * @type {String}
         */
        trigger: {
          type: [String, Array],
          default: 'click'
        }
      },
      methods: {
        open: function open() {
          this.isShowing = false;
        },
        close: function close() {
          this.isShowing = true;
        },
        toggle: function toggle() {
          if (!this.isShowing) {
            this.close();
          } else {
            this.open();
          }
        },
        createPopper: function createPopper(el) {
          return new Popper(el, this.$el, {
            offset: this.offset,
            placement: this.placement,
            modifiers: {
              flip: {
                boundariesElement: this.container,
                behavior: this.fallbackPlacement
              },
              offset: {
                enabled: !!this.offset,
                offset: this.offset
              },
              arrow: {
                enable: true,
                element: this.$el.querySelector('.arrow')
              }
            }
          });
        },
        getArrowElement: function getArrowElement() {
          return this.$el.querySelector('.arrow');
        }
      },
      computed: {
        classes: function classes() {
          return prefix({
            'top': this.placement === 'top',
            'bottom': this.placement === 'bottom',
            'left': this.placement === 'left',
            'right': this.placement === 'right'
          }, 'bs-popover');
        }
      },
      data: function data() {
        return {
          isShowing: this.show || !this.target
        };
      },
      beforeCreate: function beforeCreate() {
        if (!this.$poppers) {
          this.$poppers = {};
        }
      },
      mounted: function mounted() {
        var _this = this;

        var init = function init(el) {
          _this.$poppers[el] = {
            trigger: isString(_this.trigger) ? _this.trigger.split(' ') : _this.trigger,
            popper: _this.createPopper(el),
            event: function event(_event) {
              _this.toggle();

              _this.$poppers[el].popper.update();
            }
          };

          forEach(_this.$poppers[el].trigger, function (trigger) {
            el.addEventListener(trigger, _this.$poppers[el].event);
          });
        };

        if (this.target) {
          if (this.target instanceof Element) {
            init(this.target);
          } else {
            document.querySelectorAll(this.target).forEach(function (el) {
              init(el);
            });
          }
        }
      }
    };

    var PopoverBody = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "popover-body"
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'popover-body'
    };

    var PopoverHeader = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c(_vm.tag, {
          tag: "component",
          staticClass: "popover-header"
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'popover-header',
      props: {
        /**
         * The component HTML element
         *
         * @type {String}
         */
        tag: {
          type: String,
          default: 'h3'
        }
      }
    };

    var plugin$4 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          Popover: Popover,
          PopoverBody: PopoverBody,
          PopoverHeader: PopoverHeader
        });
      }
    });

    function popover (Vue, options) {
      Vue.prototype.$popover = function (target, Component, options) {
        if (!isObject(options)) {
          options = {};
        }

        if (!target.$popover) {
          target.$popover = instance(Vue, Popover, defaultsDeep(options.popover, {
            propsData: {
              show: true,
              target: target,
              content: instance(Vue, Component, options.content)
            }
          }));
          target.$popover.$mount(document.body.appendChild(document.createElement('div')));
        }
      };
    }



    var plugins$1 = /*#__PURE__*/Object.freeze({
        mergeClasses: MergeClasses,
        modal: modal$1,
        overlay: overlay,
        popover: popover
    });

    var AlertClose = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('button', {
          staticClass: "close",
          attrs: {
            "type": "button",
            "data-dismiss": "alert",
            "aria-label": "Close"
          },
          on: {
            "click": _vm.onClick
          }
        }, [_c('span', {
          attrs: {
            "aria-hidden": "true"
          }
        }, [_vm._v("×")])]);
      },
      staticRenderFns: [],
      name: 'alert-close',
      methods: {
        onClick: function onClick(event) {
          this.$emit('click', event);
        }
      }
    };

    var AlertHeading = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('h4', {
          staticClass: "alert-heading"
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'alert-heading'
    };

    var Variant = {
      props: {
        /**
         * The variant attribute
         *
         * @property String
         */
        variant: {
          type: String,
          default: 'primary'
        }
      },
      computed: {
        variantClassPrefix: function variantClassPrefix() {
          return this.$options.name;
        },
        variantClass: function variantClass() {
          return prefix(this.variant, this.variantClassPrefix);
        }
      }
    };

    var ProgressBar = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "progress",
          style: {
            'height': _vm.formattedHeight
          }
        }, [_c('div', {
          staticClass: "progress-bar",
          class: _vm.$mergeClasses(_vm.progressClasses, _vm.variantClass),
          style: {
            'width': _vm.offsetValue + '%'
          },
          attrs: {
            "role": "progressbar",
            "aria-valuenow": _vm.offsetValue,
            "aria-valuemin": _vm.min,
            "aria-valuemax": _vm.max
          }
        }, [_vm.label ? _c('span', [_vm._v(_vm._s(_vm.offsetValue) + "%")]) : _vm._e()])]);
      },
      staticRenderFns: [],
      name: 'progress-bar',
      mixins: [Variant],
      props: {
        /**
         * The progress bar percentage value
         *
         * @property String
         */
        value: {
          type: Number,
          required: true
        },

        /**
         * The height of the progress bar
         *
         * @property String
         */
        height: [Number, String],

        /**
         * Show the progress bar value as a label inside the bar
         *
         * @property String
         */
        label: Boolean,

        /**
         * Should the progress bar appear with stripes
         *
         * @property String
         */
        striped: Boolean,

        /**
         * Should the progress bar appear with animated stripes
         *
         * @property String
         */
        animated: Boolean,

        /**
         * The minimum value
         *
         * @property String
         */
        min: {
          type: Number,
          default: 0
        },

        /**
         * The max value
         *
         * @property String
         */
        max: {
          type: Number,
          default: 100
        }
      },
      computed: {
        variantClassPrefix: function variantClassPrefix() {
          return 'bg';
        },
        offsetValue: function offsetValue() {
          return this.value / this.max * 100;
        },
        formattedHeight: function formattedHeight() {
          return this.height ? unit(this.height) : null;
        },
        progressClasses: function progressClasses() {
          return {
            'progress-bar-striped': this.striped,
            'progress-bar-animated': this.animated
          };
        }
      }
    };

    var plugin$5 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          ProgressBar: ProgressBar
        });
      }
    });

    var Alert = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "alert",
          class: _vm.$mergeClasses(_vm.variantClass, {
            show: _vm.isVisible,
            fade: _vm.fade
          }),
          attrs: {
            "role": "alert"
          }
        }, [_vm.title || _vm.heading ? _c('alert-heading', [_vm._v(_vm._s(_vm.title || _vm.heading))]) : _vm._e(), _vm._v(" "), _vm._t("default"), _vm._v(" "), _vm.dismissible ? _c('alert-close', {
          on: {
            "click": function click($event) {
              _vm.dismiss();
            }
          }
        }) : _vm._e(), _vm._v(" "), typeof _vm.show === 'number' ? _c('progress-bar', {
          staticClass: "my-3",
          attrs: {
            "variant": _vm.variant,
            "height": 5,
            "value": _vm.dismissCount,
            "max": _vm.show
          }
        }) : _vm._e()], 2);
      },
      staticRenderFns: [],
      name: 'alert',
      components: {
        AlertClose: AlertClose,
        AlertHeading: AlertHeading,
        ProgressBar: ProgressBar
      },
      mixins: [Variant],
      props: {
        /**
         * Is the alert dismissible
         *
         * @property Boolean
         */
        dismissible: Boolean,

        /**
         * The alert's title/heading
         *
         * @property Boolean
         */
        heading: String,

        /**
         * The alert's title/heading
         *
         * @property Boolean
         */
        title: String,

        /**
         * Should the alert fade when hidden
         *
         * @property Boolean
         */
        fade: {
          type: Boolean,
          default: true
        },

        /**
         * Should the alert be visible by default. If passed a number, alert
         * will be shown for the number of seconds that are passed.
         *
         * @property Boolean
         */
        show: {
          type: [Number, Boolean],
          default: true
        }
      },
      methods: {
        dismiss: function dismiss() {
          var _this = this;

          transition(this.$el).then(function (delay) {
            _this.$emit('dismissed');
          });
          this.$emit('update:visible', this.isVisible = false);
        }
      },
      mounted: function mounted() {
        var _this2 = this;

        if (typeof this.show === 'number') {
          var el = this.$el.querySelector('.progress-bar');
          this.$emit('dismiss-countdown', this.dismissCount = this.show);
          var interval = setInterval(function () {
            _this2.$emit('dismiss-countdown', _this2.dismissCount -= 1);

            if (!_this2.dismissCount) {
              clearInterval(interval);
              transition(el).then(function (delay) {
                return _this2.dismiss();
              });
            }
          }, 1000);
        }
      },
      data: function data() {
        return {
          dismissCount: this.show,
          isVisible: this.show
        };
      }
    };

    var AlertLink = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('a', {
          staticClass: "alert-link"
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'alert-link'
    };

    var plugin$6 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          Alert: Alert,
          AlertLink: AlertLink,
          AlertClose: AlertClose,
          AlertHeading: AlertHeading
        });
      }
    });

    var Badge = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _vm.href ? _c('a', {
          staticClass: "badge",
          class: _vm.$mergeClasses(_vm.classes, _vm.variantClass),
          attrs: {
            "href": _vm.href
          }
        }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))]), _vm._v(" "), _c('span', {
          staticClass: "sr-only",
          domProps: {
            "innerHTML": _vm._s(_vm.accessibility)
          }
        })], 2) : _c('span', {
          staticClass: "badge",
          class: _vm.$mergeClasses(_vm.classes, _vm.variantClass)
        }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))]), _vm._v(" "), _c('span', {
          staticClass: "sr-only",
          domProps: {
            "innerHTML": _vm._s(_vm.accessibility)
          }
        })], 2);
      },
      staticRenderFns: [],
      name: 'badge',
      mixins: [Variant],
      props: {
        /**
         * The screen reader accessibility label.
         *
         * @property String
         */
        accessibility: String,

        /**
         * If an href attribute is passed, the badge becomes an anchor.
         *
         * @property String
         */
        href: String,

        /**
         * The badge appear as pill shaped.
         *
         * @property String
         */
        pill: Boolean,

        /**
         * The badge label.
         *
         * @property String
         */
        label: [Number, String],

        /**
         * The badge appear as secondary in size to the parent element.
         *
         * @property String
         */
        secondary: Boolean
      },
      computed: {
        classes: function classes() {
          return prefix({
            'pill': this.pill,
            'secondary': this.secondary
          }, this.$options.name);
        }
      }
    };

    var plugin$7 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          Badge: Badge
        });
      }
    });

    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      return Constructor;
    }

    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }

    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }

      return _assertThisInitialized(self);
    }

    /**
     * The base implementation of `_.reduce` and `_.reduceRight`, without support
     * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} accumulator The initial value.
     * @param {boolean} initAccum Specify using the first or last element of
     *  `collection` as the initial value.
     * @param {Function} eachFunc The function to iterate over `collection`.
     * @returns {*} Returns the accumulated value.
     */
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function(value, index, collection) {
        accumulator = initAccum
          ? (initAccum = false, value)
          : iteratee(accumulator, value, index, collection);
      });
      return accumulator;
    }

    /**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` thru `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not given, the first element of `collection` is used as the initial
     * value. The iteratee is invoked with four arguments:
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
     * and `sortBy`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduceRight
     * @example
     *
     * _.reduce([1, 2], function(sum, n) {
     *   return sum + n;
     * }, 0);
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     *   return result;
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
     */
    function reduce(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduce : baseReduce,
          initAccum = arguments.length < 3;

      return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);
    }

    /**
     * The base implementation of `_.set`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */
    function baseSet(object, path, value, customizer) {
      if (!isObject(object)) {
        return object;
      }
      path = castPath(path, object);

      var index = -1,
          length = path.length,
          lastIndex = length - 1,
          nested = object;

      while (nested != null && ++index < length) {
        var key = toKey(path[index]),
            newValue = value;

        if (index != lastIndex) {
          var objValue = nested[key];
          newValue = customizer ? customizer(objValue, key, nested) : undefined;
          if (newValue === undefined) {
            newValue = isObject(objValue)
              ? objValue
              : (isIndex(path[index + 1]) ? [] : {});
          }
        }
        assignValue(nested, key, newValue);
        nested = nested[key];
      }
      return object;
    }

    /**
     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @param {Function} predicate The function invoked per property.
     * @returns {Object} Returns the new object.
     */
    function basePickBy(object, paths, predicate) {
      var index = -1,
          length = paths.length,
          result = {};

      while (++index < length) {
        var path = paths[index],
            value = baseGet(object, path);

        if (predicate(value, path)) {
          baseSet(result, castPath(path, object), value);
        }
      }
      return result;
    }

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeGetSymbols$1 = Object.getOwnPropertySymbols;

    /**
     * Creates an array of the own and inherited enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbolsIn = !nativeGetSymbols$1 ? stubArray : function(object) {
      var result = [];
      while (object) {
        arrayPush(result, getSymbols(object));
        object = getPrototype(object);
      }
      return result;
    };

    /**
     * Creates an array of own and inherited enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeysIn(object) {
      return baseGetAllKeys(object, keysIn$1, getSymbolsIn);
    }

    /**
     * Creates an object composed of the `object` properties `predicate` returns
     * truthy for. The predicate is invoked with two arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pickBy(object, _.isNumber);
     * // => { 'a': 1, 'c': 3 }
     */
    function pickBy(object, predicate) {
      if (object == null) {
        return {};
      }
      var props = arrayMap(getAllKeysIn(object), function(prop) {
        return [prop];
      });
      predicate = baseIteratee(predicate);
      return basePickBy(object, props, function(value, path) {
        return predicate(value, path[0]);
      });
    }

    /**
     * The base implementation of `_.filter` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function baseFilter(collection, predicate) {
      var result = [];
      baseEach(collection, function(value, index, collection) {
        if (predicate(value, index, collection)) {
          result.push(value);
        }
      });
      return result;
    }

    /**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * **Note:** Unlike `_.remove`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.reject
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, { 'age': 36, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.filter(users, 'active');
     * // => objects for ['barney']
     */
    function filter$1(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, baseIteratee(predicate, 3));
    }

    /**
     * Gets the size of an ASCII `string`.
     *
     * @private
     * @param {string} string The string inspect.
     * @returns {number} Returns the string size.
     */
    var asciiSize = baseProperty('length');

    /** Used to compose unicode character classes. */
    var rsAstralRange$1 = '\\ud800-\\udfff',
        rsComboMarksRange$2 = '\\u0300-\\u036f',
        reComboHalfMarksRange$2 = '\\ufe20-\\ufe2f',
        rsComboSymbolsRange$2 = '\\u20d0-\\u20ff',
        rsComboRange$2 = rsComboMarksRange$2 + reComboHalfMarksRange$2 + rsComboSymbolsRange$2,
        rsVarRange$1 = '\\ufe0e\\ufe0f';

    /** Used to compose unicode capture groups. */
    var rsZWJ$1 = '\\u200d';

    /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
    var reHasUnicode = RegExp('[' + rsZWJ$1 + rsAstralRange$1  + rsComboRange$2 + rsVarRange$1 + ']');

    /**
     * Checks if `string` contains Unicode symbols.
     *
     * @private
     * @param {string} string The string to inspect.
     * @returns {boolean} Returns `true` if a symbol is found, else `false`.
     */
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }

    /** Used to compose unicode character classes. */
    var rsAstralRange$2 = '\\ud800-\\udfff',
        rsComboMarksRange$3 = '\\u0300-\\u036f',
        reComboHalfMarksRange$3 = '\\ufe20-\\ufe2f',
        rsComboSymbolsRange$3 = '\\u20d0-\\u20ff',
        rsComboRange$3 = rsComboMarksRange$3 + reComboHalfMarksRange$3 + rsComboSymbolsRange$3,
        rsVarRange$2 = '\\ufe0e\\ufe0f';

    /** Used to compose unicode capture groups. */
    var rsAstral = '[' + rsAstralRange$2 + ']',
        rsCombo$2 = '[' + rsComboRange$3 + ']',
        rsFitz$1 = '\\ud83c[\\udffb-\\udfff]',
        rsModifier$1 = '(?:' + rsCombo$2 + '|' + rsFitz$1 + ')',
        rsNonAstral$1 = '[^' + rsAstralRange$2 + ']',
        rsRegional$1 = '(?:\\ud83c[\\udde6-\\uddff]){2}',
        rsSurrPair$1 = '[\\ud800-\\udbff][\\udc00-\\udfff]',
        rsZWJ$2 = '\\u200d';

    /** Used to compose unicode regexes. */
    var reOptMod$1 = rsModifier$1 + '?',
        rsOptVar$1 = '[' + rsVarRange$2 + ']?',
        rsOptJoin$1 = '(?:' + rsZWJ$2 + '(?:' + [rsNonAstral$1, rsRegional$1, rsSurrPair$1].join('|') + ')' + rsOptVar$1 + reOptMod$1 + ')*',
        rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1,
        rsSymbol = '(?:' + [rsNonAstral$1 + rsCombo$2 + '?', rsCombo$2, rsRegional$1, rsSurrPair$1, rsAstral].join('|') + ')';

    /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
    var reUnicode = RegExp(rsFitz$1 + '(?=' + rsFitz$1 + ')|' + rsSymbol + rsSeq$1, 'g');

    /**
     * Gets the size of a Unicode `string`.
     *
     * @private
     * @param {string} string The string inspect.
     * @returns {number} Returns the string size.
     */
    function unicodeSize(string) {
      var result = reUnicode.lastIndex = 0;
      while (reUnicode.test(string)) {
        ++result;
      }
      return result;
    }

    /**
     * Gets the number of symbols in `string`.
     *
     * @private
     * @param {string} string The string to inspect.
     * @returns {number} Returns the string size.
     */
    function stringSize(string) {
      return hasUnicode(string)
        ? unicodeSize(string)
        : asciiSize(string);
    }

    /** `Object#toString` result references. */
    var mapTag$3 = '[object Map]',
        setTag$3 = '[object Set]';

    /**
     * Gets the size of `collection` by returning its length for array-like
     * values or the number of own enumerable string keyed properties for objects.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns the collection size.
     * @example
     *
     * _.size([1, 2, 3]);
     * // => 3
     *
     * _.size({ 'a': 1, 'b': 2 });
     * // => 2
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      if (collection == null) {
        return 0;
      }
      if (isArrayLike(collection)) {
        return isString(collection) ? stringSize(collection) : collection.length;
      }
      var tag = getTag$1(collection);
      if (tag == mapTag$3 || tag == setTag$3) {
        return collection.size;
      }
      return baseKeys(collection).length;
    }

    /**
     * The base implementation of `_.map` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function baseMap(collection, iteratee) {
      var index = -1,
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value, key, collection) {
        result[++index] = iteratee(value, key, collection);
      });
      return result;
    }

    /**
     * Creates an array of values by running each element in `collection` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * _.map([4, 8], square);
     * // => [16, 64]
     *
     * _.map({ 'a': 4, 'b': 8 }, square);
     * // => [16, 64] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */
    function map(collection, iteratee) {
      var func = isArray(collection) ? arrayMap : baseMap;
      return func(collection, baseIteratee(iteratee, 3));
    }

    /**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseSlice(array, start, end) {
      var index = -1,
          length = array.length;

      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : ((end - start) >>> 0);
      start >>>= 0;

      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }

    /**
     * Casts `array` to a slice if it's needed.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {number} start The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the cast slice.
     */
    function castSlice(array, start, end) {
      var length = array.length;
      end = end === undefined ? length : end;
      return (!start && end >= length) ? array : baseSlice(array, start, end);
    }

    /**
     * Converts an ASCII `string` to an array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the converted array.
     */
    function asciiToArray(string) {
      return string.split('');
    }

    /** Used to compose unicode character classes. */
    var rsAstralRange$3 = '\\ud800-\\udfff',
        rsComboMarksRange$4 = '\\u0300-\\u036f',
        reComboHalfMarksRange$4 = '\\ufe20-\\ufe2f',
        rsComboSymbolsRange$4 = '\\u20d0-\\u20ff',
        rsComboRange$4 = rsComboMarksRange$4 + reComboHalfMarksRange$4 + rsComboSymbolsRange$4,
        rsVarRange$3 = '\\ufe0e\\ufe0f';

    /** Used to compose unicode capture groups. */
    var rsAstral$1 = '[' + rsAstralRange$3 + ']',
        rsCombo$3 = '[' + rsComboRange$4 + ']',
        rsFitz$2 = '\\ud83c[\\udffb-\\udfff]',
        rsModifier$2 = '(?:' + rsCombo$3 + '|' + rsFitz$2 + ')',
        rsNonAstral$2 = '[^' + rsAstralRange$3 + ']',
        rsRegional$2 = '(?:\\ud83c[\\udde6-\\uddff]){2}',
        rsSurrPair$2 = '[\\ud800-\\udbff][\\udc00-\\udfff]',
        rsZWJ$3 = '\\u200d';

    /** Used to compose unicode regexes. */
    var reOptMod$2 = rsModifier$2 + '?',
        rsOptVar$2 = '[' + rsVarRange$3 + ']?',
        rsOptJoin$2 = '(?:' + rsZWJ$3 + '(?:' + [rsNonAstral$2, rsRegional$2, rsSurrPair$2].join('|') + ')' + rsOptVar$2 + reOptMod$2 + ')*',
        rsSeq$2 = rsOptVar$2 + reOptMod$2 + rsOptJoin$2,
        rsSymbol$1 = '(?:' + [rsNonAstral$2 + rsCombo$3 + '?', rsCombo$3, rsRegional$2, rsSurrPair$2, rsAstral$1].join('|') + ')';

    /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
    var reUnicode$1 = RegExp(rsFitz$2 + '(?=' + rsFitz$2 + ')|' + rsSymbol$1 + rsSeq$2, 'g');

    /**
     * Converts a Unicode `string` to an array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the converted array.
     */
    function unicodeToArray(string) {
      return string.match(reUnicode$1) || [];
    }

    /**
     * Converts `string` to an array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the converted array.
     */
    function stringToArray(string) {
      return hasUnicode(string)
        ? unicodeToArray(string)
        : asciiToArray(string);
    }

    /**
     * Creates a function like `_.lowerFirst`.
     *
     * @private
     * @param {string} methodName The name of the `String` case method to use.
     * @returns {Function} Returns the new case function.
     */
    function createCaseFirst(methodName) {
      return function(string) {
        string = toString(string);

        var strSymbols = hasUnicode(string)
          ? stringToArray(string)
          : undefined;

        var chr = strSymbols
          ? strSymbols[0]
          : string.charAt(0);

        var trailing = strSymbols
          ? castSlice(strSymbols, 1).join('')
          : string.slice(1);

        return chr[methodName]() + trailing;
      };
    }

    /**
     * Converts the first character of `string` to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.upperFirst('fred');
     * // => 'Fred'
     *
     * _.upperFirst('FRED');
     * // => 'FRED'
     */
    var upperFirst = createCaseFirst('toUpperCase');

    /**
     * Converts the first character of `string` to upper case and the remaining
     * to lower case.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('FRED');
     * // => 'Fred'
     */
    function capitalize(string) {
      return upperFirst(toString(string).toLowerCase());
    }

    /**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar--');
     * // => 'fooBar'
     *
     * _.camelCase('__FOO_BAR__');
     * // => 'fooBar'
     */
    var camelCase = createCompounder(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? capitalize(word) : word);
    });

    /**
     * The base implementation of `_.assign` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }

    /**
     * The base implementation of `_.assignIn` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssignIn(object, source) {
      return object && copyObject(source, keysIn$1(source), object);
    }

    /**
     * Copies own symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }

    /**
     * Copies own and inherited symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbolsIn(source, object) {
      return copyObject(source, getSymbolsIn(source), object);
    }

    /** Used for built-in method references. */
    var objectProto$15 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$12 = objectProto$15.hasOwnProperty;

    /**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */
    function initCloneArray(array) {
      var length = array.length,
          result = new array.constructor(length);

      // Add properties assigned by `RegExp#exec`.
      if (length && typeof array[0] == 'string' && hasOwnProperty$12.call(array, 'index')) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }

    /**
     * Creates a clone of `dataView`.
     *
     * @private
     * @param {Object} dataView The data view to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned data view.
     */
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }

    /** Used to match `RegExp` flags from their coerced string values. */
    var reFlags = /\w*$/;

    /**
     * Creates a clone of `regexp`.
     *
     * @private
     * @param {Object} regexp The regexp to clone.
     * @returns {Object} Returns the cloned regexp.
     */
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }

    /** Used to convert symbols to primitives and strings. */
    var symbolProto$2 = Symbol$1 ? Symbol$1.prototype : undefined,
        symbolValueOf$1 = symbolProto$2 ? symbolProto$2.valueOf : undefined;

    /**
     * Creates a clone of the `symbol` object.
     *
     * @private
     * @param {Object} symbol The symbol object to clone.
     * @returns {Object} Returns the cloned symbol object.
     */
    function cloneSymbol(symbol) {
      return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
    }

    /** `Object#toString` result references. */
    var boolTag$3 = '[object Boolean]',
        dateTag$2 = '[object Date]',
        mapTag$4 = '[object Map]',
        numberTag$2 = '[object Number]',
        regexpTag$2 = '[object RegExp]',
        setTag$4 = '[object Set]',
        stringTag$3 = '[object String]',
        symbolTag$2 = '[object Symbol]';

    var arrayBufferTag$2 = '[object ArrayBuffer]',
        dataViewTag$3 = '[object DataView]',
        float32Tag$1 = '[object Float32Array]',
        float64Tag$1 = '[object Float64Array]',
        int8Tag$1 = '[object Int8Array]',
        int16Tag$1 = '[object Int16Array]',
        int32Tag$1 = '[object Int32Array]',
        uint8Tag$1 = '[object Uint8Array]',
        uint8ClampedTag$1 = '[object Uint8ClampedArray]',
        uint16Tag$1 = '[object Uint16Array]',
        uint32Tag$1 = '[object Uint32Array]';

    /**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag$2:
          return cloneArrayBuffer(object);

        case boolTag$3:
        case dateTag$2:
          return new Ctor(+object);

        case dataViewTag$3:
          return cloneDataView(object, isDeep);

        case float32Tag$1: case float64Tag$1:
        case int8Tag$1: case int16Tag$1: case int32Tag$1:
        case uint8Tag$1: case uint8ClampedTag$1: case uint16Tag$1: case uint32Tag$1:
          return cloneTypedArray(object, isDeep);

        case mapTag$4:
          return new Ctor;

        case numberTag$2:
        case stringTag$3:
          return new Ctor(object);

        case regexpTag$2:
          return cloneRegExp(object);

        case setTag$4:
          return new Ctor;

        case symbolTag$2:
          return cloneSymbol(object);
      }
    }

    /** `Object#toString` result references. */
    var mapTag$5 = '[object Map]';

    /**
     * The base implementation of `_.isMap` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     */
    function baseIsMap(value) {
      return isObjectLike(value) && getTag$1(value) == mapTag$5;
    }

    /* Node.js helper references. */
    var nodeIsMap = nodeUtil && nodeUtil.isMap;

    /**
     * Checks if `value` is classified as a `Map` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     * @example
     *
     * _.isMap(new Map);
     * // => true
     *
     * _.isMap(new WeakMap);
     * // => false
     */
    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

    /** `Object#toString` result references. */
    var setTag$5 = '[object Set]';

    /**
     * The base implementation of `_.isSet` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     */
    function baseIsSet(value) {
      return isObjectLike(value) && getTag$1(value) == setTag$5;
    }

    /* Node.js helper references. */
    var nodeIsSet = nodeUtil && nodeUtil.isSet;

    /**
     * Checks if `value` is classified as a `Set` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     * @example
     *
     * _.isSet(new Set);
     * // => true
     *
     * _.isSet(new WeakSet);
     * // => false
     */
    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

    /** Used to compose bitmasks for cloning. */
    var CLONE_DEEP_FLAG = 1,
        CLONE_FLAT_FLAG = 2,
        CLONE_SYMBOLS_FLAG = 4;

    /** `Object#toString` result references. */
    var argsTag$3 = '[object Arguments]',
        arrayTag$2 = '[object Array]',
        boolTag$4 = '[object Boolean]',
        dateTag$3 = '[object Date]',
        errorTag$2 = '[object Error]',
        funcTag$2 = '[object Function]',
        genTag$1 = '[object GeneratorFunction]',
        mapTag$6 = '[object Map]',
        numberTag$3 = '[object Number]',
        objectTag$4 = '[object Object]',
        regexpTag$3 = '[object RegExp]',
        setTag$6 = '[object Set]',
        stringTag$4 = '[object String]',
        symbolTag$3 = '[object Symbol]',
        weakMapTag$2 = '[object WeakMap]';

    var arrayBufferTag$3 = '[object ArrayBuffer]',
        dataViewTag$4 = '[object DataView]',
        float32Tag$2 = '[object Float32Array]',
        float64Tag$2 = '[object Float64Array]',
        int8Tag$2 = '[object Int8Array]',
        int16Tag$2 = '[object Int16Array]',
        int32Tag$2 = '[object Int32Array]',
        uint8Tag$2 = '[object Uint8Array]',
        uint8ClampedTag$2 = '[object Uint8ClampedArray]',
        uint16Tag$2 = '[object Uint16Array]',
        uint32Tag$2 = '[object Uint32Array]';

    /** Used to identify `toStringTag` values supported by `_.clone`. */
    var cloneableTags = {};
    cloneableTags[argsTag$3] = cloneableTags[arrayTag$2] =
    cloneableTags[arrayBufferTag$3] = cloneableTags[dataViewTag$4] =
    cloneableTags[boolTag$4] = cloneableTags[dateTag$3] =
    cloneableTags[float32Tag$2] = cloneableTags[float64Tag$2] =
    cloneableTags[int8Tag$2] = cloneableTags[int16Tag$2] =
    cloneableTags[int32Tag$2] = cloneableTags[mapTag$6] =
    cloneableTags[numberTag$3] = cloneableTags[objectTag$4] =
    cloneableTags[regexpTag$3] = cloneableTags[setTag$6] =
    cloneableTags[stringTag$4] = cloneableTags[symbolTag$3] =
    cloneableTags[uint8Tag$2] = cloneableTags[uint8ClampedTag$2] =
    cloneableTags[uint16Tag$2] = cloneableTags[uint32Tag$2] = true;
    cloneableTags[errorTag$2] = cloneableTags[funcTag$2] =
    cloneableTags[weakMapTag$2] = false;

    /**
     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
     * traversed objects.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Deep clone
     *  2 - Flatten inherited properties
     *  4 - Clone symbols
     * @param {Function} [customizer] The function to customize cloning.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The parent object of `value`.
     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, bitmask, customizer, key, object, stack) {
      var result,
          isDeep = bitmask & CLONE_DEEP_FLAG,
          isFlat = bitmask & CLONE_FLAT_FLAG,
          isFull = bitmask & CLONE_SYMBOLS_FLAG;

      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== undefined) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag$1(value),
            isFunc = tag == funcTag$2 || tag == genTag$1;

        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag$4 || tag == argsTag$3 || (isFunc && !object)) {
          result = (isFlat || isFunc) ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat
              ? copySymbolsIn(value, baseAssignIn(result, value))
              : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      // Check for circular references and return its corresponding clone.
      stack || (stack = new Stack);
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);

      if (isSet(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
        });

        return result;
      }

      if (isMap(value)) {
        value.forEach(function(subValue, key) {
          result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
        });

        return result;
      }

      var keysFunc = isFull
        ? (isFlat ? getAllKeysIn : getAllKeys)
        : (isFlat ? keysIn : keys);

      var props = isArr ? undefined : keysFunc(value);
      arrayEach(props || value, function(subValue, key) {
        if (props) {
          key = subValue;
          subValue = value[key];
        }
        // Recursively populate clone (susceptible to call stack limits).
        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
      });
      return result;
    }

    /** Used to compose bitmasks for cloning. */
    var CLONE_DEEP_FLAG$1 = 1,
        CLONE_SYMBOLS_FLAG$1 = 4;

    /**
     * This method is like `_.clone` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @returns {*} Returns the deep cloned value.
     * @see _.clone
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var deep = _.cloneDeep(objects);
     * console.log(deep[0] === objects[0]);
     * // => false
     */
    function cloneDeep(value) {
      return baseClone(value, CLONE_DEEP_FLAG$1 | CLONE_SYMBOLS_FLAG$1);
    }

    /**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias first
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.head([1, 2, 3]);
     * // => 1
     *
     * _.head([]);
     * // => undefined
     */
    function head(array) {
      return (array && array.length) ? array[0] : undefined;
    }

    /** Used to store function metadata. */
    var metaMap = WeakMap && new WeakMap;

    /**
     * The base implementation of `setData` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var baseSetData = !metaMap ? identity : function(func, data) {
      metaMap.set(func, data);
      return func;
    };

    /**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCtor(Ctor) {
      return function() {
        // Use a `switch` statement to work with class constructors. See
        // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
        // for more details.
        var args = arguments;
        switch (args.length) {
          case 0: return new Ctor;
          case 1: return new Ctor(args[0]);
          case 2: return new Ctor(args[0], args[1]);
          case 3: return new Ctor(args[0], args[1], args[2]);
          case 4: return new Ctor(args[0], args[1], args[2], args[3]);
          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
        }
        var thisBinding = baseCreate(Ctor.prototype),
            result = Ctor.apply(thisBinding, args);

        // Mimic the constructor's `return` behavior.
        // See https://es5.github.io/#x13.2.2 for more details.
        return isObject(result) ? result : thisBinding;
      };
    }

    /** Used to compose bitmasks for function metadata. */
    var WRAP_BIND_FLAG = 1;

    /**
     * Creates a function that wraps `func` to invoke it with the optional `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createBind(func, bitmask, thisArg) {
      var isBind = bitmask & WRAP_BIND_FLAG,
          Ctor = createCtor(func);

      function wrapper() {
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return fn.apply(isBind ? thisArg : this, arguments);
      }
      return wrapper;
    }

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeMax$1 = Math.max;

    /**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgs(args, partials, holders, isCurried) {
      var argsIndex = -1,
          argsLength = args.length,
          holdersLength = holders.length,
          leftIndex = -1,
          leftLength = partials.length,
          rangeLength = nativeMax$1(argsLength - holdersLength, 0),
          result = Array(leftLength + rangeLength),
          isUncurried = !isCurried;

      while (++leftIndex < leftLength) {
        result[leftIndex] = partials[leftIndex];
      }
      while (++argsIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[holders[argsIndex]] = args[argsIndex];
        }
      }
      while (rangeLength--) {
        result[leftIndex++] = args[argsIndex++];
      }
      return result;
    }

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeMax$2 = Math.max;

    /**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgsRight(args, partials, holders, isCurried) {
      var argsIndex = -1,
          argsLength = args.length,
          holdersIndex = -1,
          holdersLength = holders.length,
          rightIndex = -1,
          rightLength = partials.length,
          rangeLength = nativeMax$2(argsLength - holdersLength, 0),
          result = Array(rangeLength + rightLength),
          isUncurried = !isCurried;

      while (++argsIndex < rangeLength) {
        result[argsIndex] = args[argsIndex];
      }
      var offset = argsIndex;
      while (++rightIndex < rightLength) {
        result[offset + rightIndex] = partials[rightIndex];
      }
      while (++holdersIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[offset + holders[holdersIndex]] = args[argsIndex++];
        }
      }
      return result;
    }

    /**
     * Gets the number of `placeholder` occurrences in `array`.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} placeholder The placeholder to search for.
     * @returns {number} Returns the placeholder count.
     */
    function countHolders(array, placeholder) {
      var length = array.length,
          result = 0;

      while (length--) {
        if (array[length] === placeholder) {
          ++result;
        }
      }
      return result;
    }

    /**
     * The function whose prototype chain sequence wrappers inherit from.
     *
     * @private
     */
    function baseLodash() {
      // No operation performed.
    }

    /** Used as references for the maximum length and index of an array. */
    var MAX_ARRAY_LENGTH = 4294967295;

    /**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @constructor
     * @param {*} value The value to wrap.
     */
    function LazyWrapper(value) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__dir__ = 1;
      this.__filtered__ = false;
      this.__iteratees__ = [];
      this.__takeCount__ = MAX_ARRAY_LENGTH;
      this.__views__ = [];
    }

    // Ensure `LazyWrapper` is an instance of `baseLodash`.
    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
    LazyWrapper.prototype.constructor = LazyWrapper;

    /**
     * This method returns `undefined`.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Util
     * @example
     *
     * _.times(2, _.noop);
     * // => [undefined, undefined]
     */
    function noop() {
      // No operation performed.
    }

    /**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */
    var getData = !metaMap ? noop : function(func) {
      return metaMap.get(func);
    };

    /** Used to lookup unminified function names. */
    var realNames = {};

    /** Used for built-in method references. */
    var objectProto$16 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$13 = objectProto$16.hasOwnProperty;

    /**
     * Gets the name of `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {string} Returns the function name.
     */
    function getFuncName(func) {
      var result = (func.name + ''),
          array = realNames[result],
          length = hasOwnProperty$13.call(realNames, result) ? array.length : 0;

      while (length--) {
        var data = array[length],
            otherFunc = data.func;
        if (otherFunc == null || otherFunc == func) {
          return data.name;
        }
      }
      return result;
    }

    /**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable explicit method chain sequences.
     */
    function LodashWrapper(value, chainAll) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__chain__ = !!chainAll;
      this.__index__ = 0;
      this.__values__ = undefined;
    }

    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
    LodashWrapper.prototype.constructor = LodashWrapper;

    /**
     * Creates a clone of `wrapper`.
     *
     * @private
     * @param {Object} wrapper The wrapper to clone.
     * @returns {Object} Returns the cloned wrapper.
     */
    function wrapperClone(wrapper) {
      if (wrapper instanceof LazyWrapper) {
        return wrapper.clone();
      }
      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
      result.__actions__ = copyArray(wrapper.__actions__);
      result.__index__  = wrapper.__index__;
      result.__values__ = wrapper.__values__;
      return result;
    }

    /** Used for built-in method references. */
    var objectProto$17 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$14 = objectProto$17.hasOwnProperty;

    /**
     * Creates a `lodash` object which wraps `value` to enable implicit method
     * chain sequences. Methods that operate on and return arrays, collections,
     * and functions can be chained together. Methods that retrieve a single value
     * or may return a primitive value will automatically end the chain sequence
     * and return the unwrapped value. Otherwise, the value must be unwrapped
     * with `_#value`.
     *
     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
     * enabled using `_.chain`.
     *
     * The execution of chained methods is lazy, that is, it's deferred until
     * `_#value` is implicitly or explicitly called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion.
     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
     * the creation of intermediate arrays and can greatly reduce the number of
     * iteratee executions. Sections of a chain sequence qualify for shortcut
     * fusion if the section is applied to an array and iteratees accept only
     * one argument. The heuristic for whether a section qualifies for shortcut
     * fusion is subject to change.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers have `Array` and `String` methods.
     *
     * The wrapper `Array` methods are:
     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
     *
     * The wrapper `String` methods are:
     * `replace` and `split`
     *
     * The wrapper methods that support shortcut fusion are:
     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
     * `zipObject`, `zipObjectDeep`, and `zipWith`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
     * `upperFirst`, `value`, and `words`
     *
     * @name _
     * @constructor
     * @category Seq
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // Returns an unwrapped value.
     * wrapped.reduce(_.add);
     * // => 6
     *
     * // Returns a wrapped value.
     * var squares = wrapped.map(square);
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
        if (value instanceof LodashWrapper) {
          return value;
        }
        if (hasOwnProperty$14.call(value, '__wrapped__')) {
          return wrapperClone(value);
        }
      }
      return new LodashWrapper(value);
    }

    // Ensure wrappers are instances of `baseLodash`.
    lodash.prototype = baseLodash.prototype;
    lodash.prototype.constructor = lodash;

    /**
     * Checks if `func` has a lazy counterpart.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
     *  else `false`.
     */
    function isLaziable(func) {
      var funcName = getFuncName(func),
          other = lodash[funcName];

      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
        return false;
      }
      if (func === other) {
        return true;
      }
      var data = getData(other);
      return !!data && func === data[0];
    }

    /**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity
     * function to avoid garbage collection pauses in V8. See
     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var setData = shortOut(baseSetData);

    /** Used to match wrap detail comments. */
    var reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
        reSplitDetails = /,? & /;

    /**
     * Extracts wrapper details from the `source` body comment.
     *
     * @private
     * @param {string} source The source to inspect.
     * @returns {Array} Returns the wrapper details.
     */
    function getWrapDetails(source) {
      var match = source.match(reWrapDetails);
      return match ? match[1].split(reSplitDetails) : [];
    }

    /** Used to match wrap detail comments. */
    var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/;

    /**
     * Inserts wrapper `details` in a comment at the top of the `source` body.
     *
     * @private
     * @param {string} source The source to modify.
     * @returns {Array} details The details to insert.
     * @returns {string} Returns the modified source.
     */
    function insertWrapDetails(source, details) {
      var length = details.length;
      if (!length) {
        return source;
      }
      var lastIndex = length - 1;
      details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
      details = details.join(length > 2 ? ', ' : ' ');
      return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
    }

    /**
     * The base implementation of `_.findIndex` and `_.findLastIndex` without
     * support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} predicate The function invoked per iteration.
     * @param {number} fromIndex The index to search from.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length,
          index = fromIndex + (fromRight ? 1 : -1);

      while ((fromRight ? index-- : ++index < length)) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * The base implementation of `_.isNaN` without support for number objects.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     */
    function baseIsNaN(value) {
      return value !== value;
    }

    /**
     * A specialized version of `_.indexOf` which performs strict equality
     * comparisons of values, i.e. `===`.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} fromIndex The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function strictIndexOf(array, value, fromIndex) {
      var index = fromIndex - 1,
          length = array.length;

      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }

    /**
     * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} fromIndex The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function baseIndexOf(array, value, fromIndex) {
      return value === value
        ? strictIndexOf(array, value, fromIndex)
        : baseFindIndex(array, baseIsNaN, fromIndex);
    }

    /**
     * A specialized version of `_.includes` for arrays without support for
     * specifying an index to search from.
     *
     * @private
     * @param {Array} [array] The array to inspect.
     * @param {*} target The value to search for.
     * @returns {boolean} Returns `true` if `target` is found, else `false`.
     */
    function arrayIncludes(array, value) {
      var length = array == null ? 0 : array.length;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }

    /** Used to compose bitmasks for function metadata. */
    var WRAP_BIND_FLAG$1 = 1,
        WRAP_BIND_KEY_FLAG = 2,
        WRAP_CURRY_FLAG = 8,
        WRAP_CURRY_RIGHT_FLAG = 16,
        WRAP_PARTIAL_FLAG = 32,
        WRAP_PARTIAL_RIGHT_FLAG = 64,
        WRAP_ARY_FLAG = 128,
        WRAP_REARG_FLAG = 256,
        WRAP_FLIP_FLAG = 512;

    /** Used to associate wrap methods with their bit flags. */
    var wrapFlags = [
      ['ary', WRAP_ARY_FLAG],
      ['bind', WRAP_BIND_FLAG$1],
      ['bindKey', WRAP_BIND_KEY_FLAG],
      ['curry', WRAP_CURRY_FLAG],
      ['curryRight', WRAP_CURRY_RIGHT_FLAG],
      ['flip', WRAP_FLIP_FLAG],
      ['partial', WRAP_PARTIAL_FLAG],
      ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
      ['rearg', WRAP_REARG_FLAG]
    ];

    /**
     * Updates wrapper `details` based on `bitmask` flags.
     *
     * @private
     * @returns {Array} details The details to modify.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Array} Returns `details`.
     */
    function updateWrapDetails(details, bitmask) {
      arrayEach(wrapFlags, function(pair) {
        var value = '_.' + pair[0];
        if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
          details.push(value);
        }
      });
      return details.sort();
    }

    /**
     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
     * with wrapper details in a comment at the top of the source body.
     *
     * @private
     * @param {Function} wrapper The function to modify.
     * @param {Function} reference The reference function.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Function} Returns `wrapper`.
     */
    function setWrapToString(wrapper, reference, bitmask) {
      var source = (reference + '');
      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
    }

    /** Used to compose bitmasks for function metadata. */
    var WRAP_BIND_FLAG$2 = 1,
        WRAP_BIND_KEY_FLAG$1 = 2,
        WRAP_CURRY_BOUND_FLAG = 4,
        WRAP_CURRY_FLAG$1 = 8,
        WRAP_PARTIAL_FLAG$1 = 32,
        WRAP_PARTIAL_RIGHT_FLAG$1 = 64;

    /**
     * Creates a function that wraps `func` to continue currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {Function} wrapFunc The function to create the `func` wrapper.
     * @param {*} placeholder The placeholder value.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
      var isCurry = bitmask & WRAP_CURRY_FLAG$1,
          newHolders = isCurry ? holders : undefined,
          newHoldersRight = isCurry ? undefined : holders,
          newPartials = isCurry ? partials : undefined,
          newPartialsRight = isCurry ? undefined : partials;

      bitmask |= (isCurry ? WRAP_PARTIAL_FLAG$1 : WRAP_PARTIAL_RIGHT_FLAG$1);
      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG$1 : WRAP_PARTIAL_FLAG$1);

      if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
        bitmask &= ~(WRAP_BIND_FLAG$2 | WRAP_BIND_KEY_FLAG$1);
      }
      var newData = [
        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
        newHoldersRight, argPos, ary, arity
      ];

      var result = wrapFunc.apply(undefined, newData);
      if (isLaziable(func)) {
        setData(result, newData);
      }
      result.placeholder = placeholder;
      return setWrapToString(result, func, bitmask);
    }

    /**
     * Gets the argument placeholder value for `func`.
     *
     * @private
     * @param {Function} func The function to inspect.
     * @returns {*} Returns the placeholder value.
     */
    function getHolder(func) {
      var object = func;
      return object.placeholder;
    }

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeMin = Math.min;

    /**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */
    function reorder(array, indexes) {
      var arrLength = array.length,
          length = nativeMin(indexes.length, arrLength),
          oldArray = copyArray(array);

      while (length--) {
        var index = indexes[length];
        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
      }
      return array;
    }

    /** Used as the internal argument placeholder. */
    var PLACEHOLDER = '__lodash_placeholder__';

    /**
     * Replaces all `placeholder` elements in `array` with an internal placeholder
     * and returns an array of their indexes.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {*} placeholder The placeholder to replace.
     * @returns {Array} Returns the new array of placeholder indexes.
     */
    function replaceHolders(array, placeholder) {
      var index = -1,
          length = array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value === placeholder || value === PLACEHOLDER) {
          array[index] = PLACEHOLDER;
          result[resIndex++] = index;
        }
      }
      return result;
    }

    /** Used to compose bitmasks for function metadata. */
    var WRAP_BIND_FLAG$3 = 1,
        WRAP_BIND_KEY_FLAG$2 = 2,
        WRAP_CURRY_FLAG$2 = 8,
        WRAP_CURRY_RIGHT_FLAG$1 = 16,
        WRAP_ARY_FLAG$1 = 128,
        WRAP_FLIP_FLAG$1 = 512;

    /**
     * Creates a function that wraps `func` to invoke it with optional `this`
     * binding of `thisArg`, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided
     *  to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
      var isAry = bitmask & WRAP_ARY_FLAG$1,
          isBind = bitmask & WRAP_BIND_FLAG$3,
          isBindKey = bitmask & WRAP_BIND_KEY_FLAG$2,
          isCurried = bitmask & (WRAP_CURRY_FLAG$2 | WRAP_CURRY_RIGHT_FLAG$1),
          isFlip = bitmask & WRAP_FLIP_FLAG$1,
          Ctor = isBindKey ? undefined : createCtor(func);

      function wrapper() {
        var length = arguments.length,
            args = Array(length),
            index = length;

        while (index--) {
          args[index] = arguments[index];
        }
        if (isCurried) {
          var placeholder = getHolder(wrapper),
              holdersCount = countHolders(args, placeholder);
        }
        if (partials) {
          args = composeArgs(args, partials, holders, isCurried);
        }
        if (partialsRight) {
          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
        }
        length -= holdersCount;
        if (isCurried && length < arity) {
          var newHolders = replaceHolders(args, placeholder);
          return createRecurry(
            func, bitmask, createHybrid, wrapper.placeholder, thisArg,
            args, newHolders, argPos, ary, arity - length
          );
        }
        var thisBinding = isBind ? thisArg : this,
            fn = isBindKey ? thisBinding[func] : func;

        length = args.length;
        if (argPos) {
          args = reorder(args, argPos);
        } else if (isFlip && length > 1) {
          args.reverse();
        }
        if (isAry && ary < length) {
          args.length = ary;
        }
        if (this && this !== root && this instanceof wrapper) {
          fn = Ctor || createCtor(fn);
        }
        return fn.apply(thisBinding, args);
      }
      return wrapper;
    }

    /**
     * Creates a function that wraps `func` to enable currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {number} arity The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCurry(func, bitmask, arity) {
      var Ctor = createCtor(func);

      function wrapper() {
        var length = arguments.length,
            args = Array(length),
            index = length,
            placeholder = getHolder(wrapper);

        while (index--) {
          args[index] = arguments[index];
        }
        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
          ? []
          : replaceHolders(args, placeholder);

        length -= holders.length;
        if (length < arity) {
          return createRecurry(
            func, bitmask, createHybrid, wrapper.placeholder, undefined,
            args, holders, undefined, undefined, arity - length);
        }
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return apply(fn, this, args);
      }
      return wrapper;
    }

    /** Used to compose bitmasks for function metadata. */
    var WRAP_BIND_FLAG$4 = 1;

    /**
     * Creates a function that wraps `func` to invoke it with the `this` binding
     * of `thisArg` and `partials` prepended to the arguments it receives.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to
     *  the new function.
     * @returns {Function} Returns the new wrapped function.
     */
    function createPartial(func, bitmask, thisArg, partials) {
      var isBind = bitmask & WRAP_BIND_FLAG$4,
          Ctor = createCtor(func);

      function wrapper() {
        var argsIndex = -1,
            argsLength = arguments.length,
            leftIndex = -1,
            leftLength = partials.length,
            args = Array(leftLength + argsLength),
            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

        while (++leftIndex < leftLength) {
          args[leftIndex] = partials[leftIndex];
        }
        while (argsLength--) {
          args[leftIndex++] = arguments[++argsIndex];
        }
        return apply(fn, isBind ? thisArg : this, args);
      }
      return wrapper;
    }

    /** Used as the internal argument placeholder. */
    var PLACEHOLDER$1 = '__lodash_placeholder__';

    /** Used to compose bitmasks for function metadata. */
    var WRAP_BIND_FLAG$5 = 1,
        WRAP_BIND_KEY_FLAG$3 = 2,
        WRAP_CURRY_BOUND_FLAG$1 = 4,
        WRAP_CURRY_FLAG$3 = 8,
        WRAP_ARY_FLAG$2 = 128,
        WRAP_REARG_FLAG$1 = 256;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeMin$1 = Math.min;

    /**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers used to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and
     * `_.rearg` modify function arguments, making the order in which they are
     * executed important, preventing the merging of metadata. However, we make
     * an exception for a safe combined case where curried functions have `_.ary`
     * and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */
    function mergeData(data, source) {
      var bitmask = data[1],
          srcBitmask = source[1],
          newBitmask = bitmask | srcBitmask,
          isCommon = newBitmask < (WRAP_BIND_FLAG$5 | WRAP_BIND_KEY_FLAG$3 | WRAP_ARY_FLAG$2);

      var isCombo =
        ((srcBitmask == WRAP_ARY_FLAG$2) && (bitmask == WRAP_CURRY_FLAG$3)) ||
        ((srcBitmask == WRAP_ARY_FLAG$2) && (bitmask == WRAP_REARG_FLAG$1) && (data[7].length <= source[8])) ||
        ((srcBitmask == (WRAP_ARY_FLAG$2 | WRAP_REARG_FLAG$1)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG$3));

      // Exit early if metadata can't be merged.
      if (!(isCommon || isCombo)) {
        return data;
      }
      // Use source `thisArg` if available.
      if (srcBitmask & WRAP_BIND_FLAG$5) {
        data[2] = source[2];
        // Set when currying a bound function.
        newBitmask |= bitmask & WRAP_BIND_FLAG$5 ? 0 : WRAP_CURRY_BOUND_FLAG$1;
      }
      // Compose partial arguments.
      var value = source[3];
      if (value) {
        var partials = data[3];
        data[3] = partials ? composeArgs(partials, value, source[4]) : value;
        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER$1) : source[4];
      }
      // Compose partial right arguments.
      value = source[5];
      if (value) {
        partials = data[5];
        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER$1) : source[6];
      }
      // Use source `argPos` if available.
      value = source[7];
      if (value) {
        data[7] = value;
      }
      // Use source `ary` if it's smaller.
      if (srcBitmask & WRAP_ARY_FLAG$2) {
        data[8] = data[8] == null ? source[8] : nativeMin$1(data[8], source[8]);
      }
      // Use source `arity` if one is not provided.
      if (data[9] == null) {
        data[9] = source[9];
      }
      // Use source `func` and merge bitmasks.
      data[0] = source[0];
      data[1] = newBitmask;

      return data;
    }

    /** Used as references for various `Number` constants. */
    var NAN = 0 / 0;

    /** Used to match leading and trailing whitespace. */
    var reTrim = /^\s+|\s+$/g;

    /** Used to detect bad signed hexadecimal string values. */
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

    /** Used to detect binary string values. */
    var reIsBinary = /^0b[01]+$/i;

    /** Used to detect octal string values. */
    var reIsOctal = /^0o[0-7]+$/i;

    /** Built-in method references without a dependency on `root`. */
    var freeParseInt = parseInt;

    /**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */
    function toNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
        value = isObject(other) ? (other + '') : other;
      }
      if (typeof value != 'string') {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, '');
      var isBinary = reIsBinary.test(value);
      return (isBinary || reIsOctal.test(value))
        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
        : (reIsBadHex.test(value) ? NAN : +value);
    }

    /** Used as references for various `Number` constants. */
    var INFINITY$2 = 1 / 0,
        MAX_INTEGER = 1.7976931348623157e+308;

    /**
     * Converts `value` to a finite number.
     *
     * @static
     * @memberOf _
     * @since 4.12.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted number.
     * @example
     *
     * _.toFinite(3.2);
     * // => 3.2
     *
     * _.toFinite(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toFinite(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toFinite('3.2');
     * // => 3.2
     */
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY$2 || value === -INFINITY$2) {
        var sign = (value < 0 ? -1 : 1);
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }

    /**
     * Converts `value` to an integer.
     *
     * **Note:** This method is loosely based on
     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toInteger(3.2);
     * // => 3
     *
     * _.toInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toInteger(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toInteger('3.2');
     * // => 3
     */
    function toInteger(value) {
      var result = toFinite(value),
          remainder = result % 1;

      return result === result ? (remainder ? result - remainder : result) : 0;
    }

    /** Error message constants. */
    var FUNC_ERROR_TEXT$1 = 'Expected a function';

    /** Used to compose bitmasks for function metadata. */
    var WRAP_BIND_FLAG$6 = 1,
        WRAP_BIND_KEY_FLAG$4 = 2,
        WRAP_CURRY_FLAG$4 = 8,
        WRAP_CURRY_RIGHT_FLAG$2 = 16,
        WRAP_PARTIAL_FLAG$2 = 32,
        WRAP_PARTIAL_RIGHT_FLAG$2 = 64;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeMax$3 = Math.max;

    /**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags.
     *    1 - `_.bind`
     *    2 - `_.bindKey`
     *    4 - `_.curry` or `_.curryRight` of a bound function
     *    8 - `_.curry`
     *   16 - `_.curryRight`
     *   32 - `_.partial`
     *   64 - `_.partialRight`
     *  128 - `_.rearg`
     *  256 - `_.ary`
     *  512 - `_.flip`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG$4;
      if (!isBindKey && typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT$1);
      }
      var length = partials ? partials.length : 0;
      if (!length) {
        bitmask &= ~(WRAP_PARTIAL_FLAG$2 | WRAP_PARTIAL_RIGHT_FLAG$2);
        partials = holders = undefined;
      }
      ary = ary === undefined ? ary : nativeMax$3(toInteger(ary), 0);
      arity = arity === undefined ? arity : toInteger(arity);
      length -= holders ? holders.length : 0;

      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG$2) {
        var partialsRight = partials,
            holdersRight = holders;

        partials = holders = undefined;
      }
      var data = isBindKey ? undefined : getData(func);

      var newData = [
        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
        argPos, ary, arity
      ];

      if (data) {
        mergeData(newData, data);
      }
      func = newData[0];
      bitmask = newData[1];
      thisArg = newData[2];
      partials = newData[3];
      holders = newData[4];
      arity = newData[9] = newData[9] === undefined
        ? (isBindKey ? 0 : func.length)
        : nativeMax$3(newData[9] - length, 0);

      if (!arity && bitmask & (WRAP_CURRY_FLAG$4 | WRAP_CURRY_RIGHT_FLAG$2)) {
        bitmask &= ~(WRAP_CURRY_FLAG$4 | WRAP_CURRY_RIGHT_FLAG$2);
      }
      if (!bitmask || bitmask == WRAP_BIND_FLAG$6) {
        var result = createBind(func, bitmask, thisArg);
      } else if (bitmask == WRAP_CURRY_FLAG$4 || bitmask == WRAP_CURRY_RIGHT_FLAG$2) {
        result = createCurry(func, bitmask, arity);
      } else if ((bitmask == WRAP_PARTIAL_FLAG$2 || bitmask == (WRAP_BIND_FLAG$6 | WRAP_PARTIAL_FLAG$2)) && !holders.length) {
        result = createPartial(func, bitmask, thisArg, partials);
      } else {
        result = createHybrid.apply(undefined, newData);
      }
      var setter = data ? baseSetData : setData;
      return setWrapToString(setter(result, newData), func, bitmask);
    }

    /** Used to compose bitmasks for function metadata. */
    var WRAP_BIND_FLAG$7 = 1,
        WRAP_PARTIAL_FLAG$3 = 32;

    /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and `partials` prepended to the arguments it receives.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * function greet(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * }
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */
    var bind = baseRest(function(func, thisArg, partials) {
      var bitmask = WRAP_BIND_FLAG$7;
      if (partials.length) {
        var holders = replaceHolders(partials, getHolder(bind));
        bitmask |= WRAP_PARTIAL_FLAG$3;
      }
      return createWrap(func, bitmask, thisArg, partials, holders);
    });

    // Assign default placeholders.
    bind.placeholder = {};

    var RequestOptions = {
      // `responseType` indicates the type of data that the server will respond with
      // options are 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream'
      responseType: 'json',
      // default
      // `transformRequest` allows changes to the request data before it is sent to the server
      // This is only applicable for request methods 'PUT', 'POST', and 'PATCH'
      // The last function in the array must return a string or an instance of Buffer, ArrayBuffer,
      // FormData or Stream
      // You may modify the headers object.
      transformRequest: [],
      // `transformResponse` allows changes to the response data to be made before
      // it is passed to then/catch
      transformResponse: []
      /*
      // `url` is the server URL that will be used for the request
        // `method` is the request method to be used when making the request
      method: 'get', // default
       // `baseURL` will be prepended to `url` unless `url` is absolute.
      // It can be convenient to set `baseURL` for an instance of axios to pass relative URLs
      // to methods of that instance.
      baseURL: 'https://some-domain.com/api/',
       // `headers` are custom headers to be sent
      headers: {'X-Requested-With': 'XMLHttpRequest'},
       // `params` are the URL parameters to be sent with the request
      // Must be a plain object or a URLSearchParams object
      params: {
          ID: 12345
      },
       // `paramsSerializer` is an optional function in charge of serializing `params`
      // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)
      paramsSerializer: function(params) {
          return Qs.stringify(params, {arrayFormat: 'brackets'})
      },
       // `data` is the data to be sent as the request body
      // Only applicable for request methods 'PUT', 'POST', and 'PATCH'
      // When no `transformRequest` is set, must be of one of the following types:
      // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams
      // - Browser only: FormData, File, Blob
      // - Node only: Stream, Buffer
      data: {
          firstName: 'Fred'
      },
       // `timeout` specifies the number of milliseconds before the request times out.
      // If the request takes longer than `timeout`, the request will be aborted.
      timeout: 1000,
       // `withCredentials` indicates whether or not cross-site Access-Control requests
      // should be made using credentials
      withCredentials: false, // default
       // `adapter` allows custom handling of requests which makes testing easier.
      // Return a promise and supply a valid response (see lib/adapters/README.md).
      adapter: function (config) {
          //
      },
       // `auth` indicates that HTTP Basic auth should be used, and supplies credentials.
      // This will set an `Authorization` header, overwriting any existing
      // `Authorization` custom headers you have set using `headers`.
      auth: {
          username: 'janedoe',
          password: 's00pers3cret'
      },
       // `responseEncoding` indicates encoding to use for decoding responses
      // Note: Ignored for `responseType` of 'stream' or client-side requests
      responseEncoding: 'utf8', // default
       // `xsrfCookieName` is the name of the cookie to use as a value for xsrf token
      xsrfCookieName: 'XSRF-TOKEN', // default
       // `xsrfHeaderName` is the name of the http header that carries the xsrf token value
      xsrfHeaderName: 'X-XSRF-TOKEN', // default
       // `onUploadProgress` allows handling of progress events for uploads
      onUploadProgress: function (progressEvent) {
          // Do whatever you want with the native progress event
      },
       // `onDownloadProgress` allows handling of progress events for downloads
      onDownloadProgress: function (progressEvent) {
          // Do whatever you want with the native progress event
      },
       // `maxContentLength` defines the max size of the http response content in bytes allowed
      maxContentLength: 2000,
       // `validateStatus` defines whether to resolve or reject the promise for a given
      // HTTP response status code. If `validateStatus` returns `true` (or is set to `null`
      // or `undefined`), the promise will be resolved; otherwise, the promise will be
      // rejected.
      validateStatus: function (status) {
          return status >= 200 && status < 300; // default
      },
       // `maxRedirects` defines the maximum number of redirects to follow in node.js.
      // If set to 0, no redirects will be followed.
      maxRedirects: 5, // default
       // `socketPath` defines a UNIX Socket to be used in node.js.
      // e.g. '/var/run/docker.sock' to send requests to the docker daemon.
      // Only either `socketPath` or `proxy` can be specified.
      // If both are specified, `socketPath` is used.
      socketPath: null, // default
       // `httpAgent` and `httpsAgent` define a custom agent to be used when performing http
      // and https requests, respectively, in node.js. This allows options to be added like
      // `keepAlive` that are not enabled by default.
      httpAgent: new http.Agent({ keepAlive: true }),
      httpsAgent: new https.Agent({ keepAlive: true }),
       // 'proxy' defines the hostname and port of the proxy server
      // Use `false` to disable proxies, ignoring environment variables.
      // `auth` indicates that HTTP Basic auth should be used to connect to the proxy, and
      // supplies credentials.
      // This will set an `Proxy-Authorization` header, overwriting any existing
      // `Proxy-Authorization` custom headers you have set using `headers`.
      proxy: {
          host: '127.0.0.1',
          port: 9000,
          auth: {
              username: 'mikeymike',
              password: 'rapunz3l'
          }
      },
       // `cancelToken` specifies a cancel token that can be used to cancel the request
      // (see Cancellation section below for details)
      cancelToken: new CancelToken(function (cancel) {
       })
      */

    };

    function transformRequest(transformer, context) {
      if (!isFunction$1(transformer)) {
        throw new Error('The transformer must be a defined as a function with two arguments: [data, headers].');
      }

      (context || RequestOptions.transformRequest).push(transformer);
    }

    function transformResponse(transformer, context) {
      if (!isFunction$1(transformer)) {
        throw new Error('The transformer must be a defined as a function with one arguments: [data].');
      }

      (context || RequestOptions.transformResponse).push(transformer);
    }

    var PROXY_OPTION_PROPERTIES = ['headers', 'params', 'data'];
    var PROXY_OPTION_METHODS = {
      get: function get(prop, context) {
        return function () {
          return context[prop];
        };
      },
      set: function set(prop, context) {
        return function (value) {
          context[prop] = value;
        };
      },
      add: function add(prop, context) {
        return function (key, value) {
          context[prop][key] = value;
        };
      },
      remove: function remove(prop, context) {
        return function (key) {
          delete context[prop][key];
        };
      },
      merge: function merge(prop, context) {
        return function (key, values) {
          assignIn(context[prop], key);
        };
      }
    };

    var method = function method(action, prop) {
      return camelCase([action, prop].join(' '));
    };

    var chainable = function chainable(prop) {
      var _this = this;

      return function (key, value) {
        if (key instanceof FormData) {
          _this[method('set', prop)](key);
        } else if (isObject(key)) {
          _this[method('merge', prop)](key);
        } else {
          _this[method('add', prop)](key, value);
        }

        return _this;
      };
    };

    function merge$1() {
      var args = [].slice.call(arguments);
      var items = args.splice(1);

      var subject = head(args);

      for (var i in items) {
        subject = mergeWith(subject, items[i], function (subject, value) {
          if (isArray(subject)) {
            return subject.concat(value);
          } else if (isObject(subject)) {
            return assignIn(subject, value);
          }

          return value;
        });
      }

      return subject;
    }

    var Request =
    /*#__PURE__*/
    function () {
      function Request(url) {
        var _this2 = this;

        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        _classCallCheck(this, Request);

        this.$options = merge$1({
          url: url,
          data: {},
          headers: {},
          params: {}
        }, cloneDeep(RequestOptions), options);

        forEach(PROXY_OPTION_METHODS, function (callback, key) {
          _this2[method(key, 'option')] = bind(callback)('$options', _this2);
        });

        forEach(PROXY_OPTION_PROPERTIES, function (prop) {
          forEach(PROXY_OPTION_METHODS, function (callback, key) {
            _this2[method(key, prop)] = bind(callback)(prop, _this2.$options);
          });

          _this2[prop] = bind(chainable, _this2)(prop);
        });

        this.reset();
      }

      _createClass(Request, [{
        key: "reset",
        value: function reset() {
          this.$error = null;
          this.$status = null;
          this.$statusText = null;
          this.$response = null;
          this.$requestSentAt = null;
          this.$responseReceivedAt = null;
        }
      }, {
        key: "hasSent",
        value: function hasSent() {
          return !!this.$requestSentAt;
        }
      }, {
        key: "hasResponse",
        value: function hasResponse() {
          return !!this.$responseReceivedAt;
        }
      }, {
        key: "passed",
        value: function passed() {
          return this.hasResponse() && !this.$error;
        }
      }, {
        key: "failed",
        value: function failed() {
          return this.hasResponse() && !!this.$error;
        }
      }, {
        key: "get",
        value: function get() {
          var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          var headers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          return this.params(params).headers(headers).send('get');
        }
      }, {
        key: "post",
        value: function post() {
          var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          var headers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          return this.data(data).headers(headers).send('post');
        }
      }, {
        key: "put",
        value: function put() {
          var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          var headers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          return this.data(data).headers(headers).send('put');
        }
      }, {
        key: "delete",
        value: function _delete() {
          var headers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          return this.headers(headers).send('delete');
        }
      }, {
        key: "send",
        value: function send(method) {
          var _this3 = this;

          this.reset();
          this.$requestSentAt = moment();
          this.addOption('method', method);
          return new Promise(function (resolve, reject) {
            axios(_this3.$options).then(function (response) {
              _this3.$response = response;
              _this3.$responseReceivedAt = moment();
              _this3.$status = response.status;
              _this3.$statusText = response.statusText;
              resolve(response.data);
            }, function (error) {
              _this3.$error = error;
              _this3.$response = error.response;
              _this3.$responseReceivedAt = moment();
              _this3.$status = error.response ? error.response.status : null;
              _this3.$statusText = error.response ? error.response.statusText : null;
              reject(error.response || error);
            });
          });
        }
      }, {
        key: "transformRequest",
        value: function transformRequest$$1(transformer) {
          if (!this.$options.transformRequest) {
            this.$options.transformRequest = [];
          }

          transformRequest(transformer, this.$options.transformRequest);
        }
      }, {
        key: "transformResponse",
        value: function transformResponse$$1(transformer) {
          if (this.$options.transformResponse) {
            this.$options.transformResponse = [];
          }

          transformResponse(transformer, this.$options.transformResponse);
        }
      }], [{
        key: "interceptRequest",
        value: function interceptRequest(success, error) {
          this.interceptors().request.use(success, error);
        }
      }, {
        key: "interceptResponse",
        value: function interceptResponse(success, error) {
          this.interceptors().response.use(success, error);
        }
      }, {
        key: "interceptors",
        value: function interceptors() {
          return axios.interceptors;
        }
      }, {
        key: "option",
        value: function option(key, value) {
          if (isObject(key)) {
            merge$1(RequestOptions, key);
          } else {
            var option = {};
            option[key] = value;
            merge$1(RequestOptions, option);
          }
        }
      }, {
        key: "make",
        value: function make(url) {
          var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          return new this(url, params);
        }
      }]);

      return Request;
    }();

    var Model =
    /*#__PURE__*/
    function () {
      /**
       * Construct the model instance
       *
       * @param data object
       * @return void
       */
      function Model() {
        var _this = this;

        var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        _classCallCheck(this, Model);

        this.$key = this.key();
        this.$properties = this.properties();
        this.$files = this.files();

        forEach(params, function (value, key) {
          _this[key] = value;
        });

        this.initialize(data);
      }
      /**
       * Initialize the model with the given data without considering the data
       * as "changed".
       *
       * @param data object
       * @return this
       */


      _createClass(Model, [{
        key: "initialize",
        value: function initialize(data) {
          this.$exists = false;
          this.$changed = {};
          this.$attributes = {};
          this.fill(data);
          this.$initialized = true;
          return this;
        }
        /**
         * Define the corresponding API endpoint slug
         *
         * @return string
         */

      }, {
        key: "endpoint",
        value: function endpoint() {} //

        /**
         * Define the corresponding uri schema.
         *
         * @return string
         */

      }, {
        key: "uri",
        value: function uri() {
          return filter$1([this.endpoint() || '', this.exists() ? this.id() : null].concat([].slice.call(arguments))).join('/').replace(/^\//, '');
        }
        /**
         * Return the primary key value for the model
         *
         * @return {Number}
         */

      }, {
        key: "id",
        value: function id() {
          return this.get(this.key());
        }
        /**
         * Define a primary key. This is used to determine if the model exists and
         * which endpoint to use.
         *
         * @return string
         */

      }, {
        key: "key",
        value: function key() {
          return 'id';
        }
        /**
         * Return an array of properties that are sent to the API. If no properties
         * are defined, then all the attributes will be included in the request.
         *
         * @return array
         */

      }, {
        key: "properties",
        value: function properties() {
          return [];
        }
        /**
         * Return an array of file properties that are sent to the API. If no fies
         * are defined, then request will always be sent with JSON vs. multipart.
         *
         * @return array
         */

      }, {
        key: "files",
        value: function files() {
          return [];
        }
        /**
         * Set the attributes in the model with the data given.
         *
         * @param data object
         * @return this
         */

      }, {
        key: "fill",
        value: function fill(data) {
          this.setAttributes(data);
          return this;
        }
        /**
         * Get one or more attributes from the model.
         *
         * @param data string|array
         * @return array|mixed
         */

      }, {
        key: "get",
        value: function get(key) {
          if (isArray(key) || isObject(key)) {
            return this.getAttributes().filter(function (value) {
              return data.indexOf(value) !== -1;
            });
          } else {
            return this.getAttribute(key);
          }
        }
        /**
         * Alias for setAttributes() except this method returns `this`. This method
         * also accepts an array of values or key/value pair.
         *
         * @return this
         */

      }, {
        key: "set",
        value: function set(key) {
          var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

          if (isArray(key) || isObject(key)) {
            this.setAttributes(key);
          } else {
            this.setAttribute(key, value);
          }

          return this;
        }
        /**
         * Get all the defined attributes.
         *
         * @return array
         */

      }, {
        key: "getAttributes",
        value: function getAttributes() {
          return this.$attributes;
        }
        /**
         * Get the changed attributes
         *
         * @return array
         */

      }, {
        key: "getChangedAttributes",
        value: function getChangedAttributes() {
          return keys(this.$changed);
        }
        /**
         * Get the changed attributes
         *
         * @return array
         */

      }, {
        key: "getOriginalValue",
        value: function getOriginalValue(key) {
          return this.$changed[key] || this.$attributes[key];
        }
        /**
         * Get the unchanged attributes
         *
         * @return array
         */

      }, {
        key: "getUnchangedAttributes",
        value: function getUnchangedAttributes() {
          var _this2 = this;

          return filter$1(keys(this.$attributes), function (key) {
            return !(key in _this2.$changed);
          });
        }
        /**
         * Get an attribute with a given key. If no key is defined
         *
         * @param key string
         * @param default undefined|mixed
         * @return array
         */

      }, {
        key: "getAttribute",
        value: function getAttribute(key) {
          var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
          return this.$attributes[key] || value;
        }
        /**
         * Set an array or object of data as attributes.
         *
         * @param attributes array|object
         * @return void
         */

      }, {
        key: "setAttributes",
        value: function setAttributes(data) {
          var _this3 = this;

          if (isArray(data) || isObject(data)) {
            forEach(data, function (value, key) {
              _this3.setAttribute(key, value);
            });
          }
        }
        /**
         * Set an attribute with a given key/value pair. This will track the changes
         * in the model within the `this.$changed` property. If the primary key
         * is set, it will also change the `this.$exists` property.
         *
         * @param key string
         * @param value mixed
         * @return void
         */

      }, {
        key: "setAttribute",
        value: function setAttribute(key, value) {
          if (this.getAttribute(key) !== value) {
            this.handleAttributeChange(key, value);

            if (isUndefined(value)) {
              delete this.$attributes[key];
            } else {
              this.$attributes[key] = value;
            }
          }
        }
        /**
         * Revert the model to its original state.
         *
         * @return bool
         */

      }, {
        key: "revert",
        value: function revert() {
          var _this4 = this;

          forEach(this.$changed, function (value, key) {
            if (!isUndefined(value)) {
              _this4.$attributes[key] = value;
            } else {
              delete _this4.$attributes[key];
            }
          });

          this.$changed = {};
        }
        /**
         * Returns if the model has a primary key set.
         *
         * @return bool
         */

      }, {
        key: "exists",
        value: function exists() {
          return !!this.$exists;
        }
        /**
         * Returns the model been changed or not.
         *
         * @return bool
         */

      }, {
        key: "hasChanged",
        value: function hasChanged(key) {
          return !key ? size(this.$changed) > 0 : !isUndefined(this.$changed[key]);
        }
        /**
         * Does the model have any File objects. If so, need to send as multipart.
         *
         * @return bool
         */

      }, {
        key: "hasFiles",
        value: function hasFiles() {
          function count(files) {
            var total = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            return reduce(files, function (carry, value) {
              if (isArray(value)) {
                return carry + count(value, total);
              } else if (value instanceof File || value instanceof FileList) {
                return carry + 1;
              } else {
                return carry;
              }
            }, total);
          }

          return count(this.toJSON()) !== 0;
        }
        /**
         * Handle settings the $changed attributes when an attribute value is set.
         *
         * @param key string
         * @param value mixed
         * @return void
         */

      }, {
        key: "handleAttributeChange",
        value: function handleAttributeChange(key, value) {
          if (this.$initialized) {
            if (this.$changed[key] === value) {
              delete this.$changed[key];
            } else if (!(key in this.$changed)) {
              this.$changed[key] = this.getAttribute(key);
            }
          }

          this.handlePrimaryKeyChange(key, value);
        }
        /**
         * Set an array or object of data as attributes.
         *
         * @param key string
         * @param value mixed
         * @return void
         */

      }, {
        key: "handlePrimaryKeyChange",
        value: function handlePrimaryKeyChange(key, value) {
          if (this.$key === key) {
            this.$exists = !isUndefined(value) && !isNull(value);
          }
        }
        /**
         * Save the model to the database
         *
         * @param data object
         * @return bool
         */

      }, {
        key: "save",
        value: function save() {
          var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          return !this.exists() ? this.create(data, config) : this.update(data, config);
        }
        /**
         * Create a new model
         *
         * @param data object
         * @return bool
         */

      }, {
        key: "create",
        value: function create() {
          var _this5 = this;

          var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          this.fill(data);
          return new Promise(function (resolve, reject) {
            var request = _this5.constructor.request(_this5.uri(), assignIn({}, config));

            var data = !_this5.hasFiles() ? _this5.toJson() : _this5.toFormData();
            request.post(data).then(function (response) {
              resolve(_this5.fill(response));
            }, reject);
          });
        }
        /**
         * Update an existing model
         *
         * @param data object
         * @return bool
         */

      }, {
        key: "update",
        value: function update() {
          var _this6 = this;

          var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          this.fill(data);
          return new Promise(function (resolve, reject) {
            var request = _this6.constructor.request(_this6.uri(), config);

            var data = !_this6.hasFiles() ? _this6.toJson() : _this6.toFormData();
            request[_this6.hasFiles() ? 'post' : 'put'](data).then(function (response) {
              resolve(_this6.fill(response));
            }, reject);
          });
        }
        /**
         * Delete an existing model
         *
         * @param data object
         * @return bool
         */

      }, {
        key: "delete",
        value: function _delete() {
          var _this7 = this;

          var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          return new Promise(function (resolve, reject) {
            if (!_this7.exists()) {
              reject(new Error('The model must have a primary key before it can be delete.'));
            }

            var request = _this7.constructor.request(_this7.uri(), config);

            request.delete().then(function (response) {
              resolve(response); //resolve(this.fill(response));
            }, reject);
          });
        }
        /**
         * Convert the Model instance to a FormData instance
         *
         * @return object
         */

      }, {
        key: "toFormData",
        value: function toFormData() {
          var form = new FormData();

          forEach(this.toJSON(), function (value, key) {
            if (isArray(value)) {
              forEach(value, function (item) {
                if (!(item instanceof File) && (isObject(item) || isArray(item))) {
                  item = JSON.stringify(item);
                }

                form.append(key.replace(/(.+)(\[.+\]?)$/, '$1') + '[]', item);
              });
            } else if (!(value instanceof File) && isObject(value)) {
              form.append(key, JSON.stringify(value));
            } else if (!isNull(value)) {
              form.append(key, value);
            }
          });

          return form;
        }
        /**
         * Convert the instance to JSON payload
         *
         * @return object
         */

      }, {
        key: "toJSON",
        value: function toJSON() {
          var _this8 = this;

          return pickBy(this.$attributes, function (value, key) {
            return !_this8.$properties.length || key === _this8.key() || _this8.$properties.indexOf(key) !== -1;
          });
        }
        /**
         * Alias for toJSON
         *
         * @return object
         */

      }, {
        key: "toJson",
        value: function toJson() {
          return this.toJSON();
        }
        /**
         * Search for a collection of models
         *
         * @param data object
         * @return bool
         */

      }], [{
        key: "search",
        value: function search(uri) {
          var _this9 = this;

          var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
          var model = new this();

          if (!uri) {
            uri = model.uri();
          }

          return new Promise(function (resolve, reject) {
            var request = _this9.request(uri, config);

            request.get(params).then(function (response) {
              resolve(map(response.data, function (data) {
                return new _this9(data);
              }));
            }, function (errors) {
              reject(errors);
            });
          });
        }
        /**
         * Find an existing model by id
         *
         * @param data object
         * @return bool
         */

      }, {
        key: "find",
        value: function find(id) {
          var _this10 = this;

          var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          return new Promise(function (resolve, reject) {
            var model = new _this10();

            _this10.request(model.uri(id), config).get().then(function (response) {
              resolve(model.initialize(response));
            }, function (error) {
              reject(error);
            });
          });
        }
        /**
         * Create a request from the model data
         *
         * @param data object
         * @return bool
         */

      }, {
        key: "request",
        value: function request(url) {
          var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          return new Request(url, config);
        }
      }]);

      return Model;
    }();

    var BaseForm = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('form', {
          class: {
            'form-inline': _vm.inline
          },
          attrs: {
            "novalidate": _vm.novalidate
          },
          on: {
            "submit": function submit($event) {
              $event.preventDefault();
              return _vm.onSubmit($event);
            }
          }
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      props: {
        /**
         * The Model method used to send the request.
         *
         * @property Boolean
         */
        method: {
          type: String,
          default: 'save',
          validate: function validate(value) {
            return this.model && isFunction$1(this.model[value]);
          }
        },

        /**
         * An object of form data
         *
         * @property Object
         */
        data: {
          type: Object,
          default: function _default() {
            return {};
          }
        },

        /**
         * Display the form fields inline
         *
         * @property Object
         */
        model: {
          type: Object,
          validate: function validate(value) {
            return value instanceof Model;
          }
        },

        /**
         * Display the form fields inline
         *
         * @property Boolean
         */
        inline: Boolean,

        /**
         * A callback function for the `submit` event
         *
         * @property Boolean
         */
        novalidate: {
          type: Boolean,
          default: true
        },

        /**
         * A URI or URL used to redirect user after form submits successfully.
         *
         * @property Function|String
         */
        redirect: [Object, String, Function],

        /**
         * A callback function for the `submit` event
         *
         * @property Function
         */
        onSubmit: {
          type: Function,
          default: function _default(event) {
            this.model && this.submit(event);
          }
        },

        /**
         * A callback function for the `submit:success` event
         *
         * @property Function
         */
        onSubmitSuccess: {
          type: Function,
          default: function _default(event, data) {
            this.$emit('submit:success', event, data);
            this.$emit('submit:complete', event, true, data);

            if (this.redirect && isFunction$1(this.redirect)) {
              this.redirect(this);
            } else if (this.redirect) {
              this.$router.push(this.redirect);
            }
          }
        },

        /**
         * A callback function for the `submit:success` event
         *
         * @property Function
         */
        onSubmitFailed: {
          type: Function,
          default: function _default(event, errors) {
            this.$emit('submit:failed', event, errors);
            this.$emit('submit:complete', event, false, errors);
          }
        }
      },
      methods: {
        submit: function submit(event) {
          var _this = this;

          this.$emit('submit', event);
          return this.model[this.method](this.data, {
            onUploadProgress: function onUploadProgress(event) {
              _this.$emit('submit:progress', event);
            }
          }).then(function (data) {
            _this.onSubmitSuccess(event, data);
          }, function (errors) {
            _this.onSubmitFailed(event, errors);
          });
        }
      },
      data: function data() {
        return {
          errors: {}
        };
      }
    };

    var plugin$8 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          BaseForm: BaseForm
        });
      }
    });

    var BreadcrumbItem = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('li', {
          staticClass: "breadcrumb-item",
          class: {
            'active': _vm.active
          },
          attrs: {
            "aria-current": _vm.active ? 'page' : false
          }
        }, [!_vm.active && _vm.href ? _c('a', {
          attrs: {
            "href": _vm.href
          }
        }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))])], 2) : [_vm._t("default", [_vm._v(_vm._s(_vm.label))])]], 2);
      },
      staticRenderFns: [],
      name: 'breadcrumb-item',
      props: {
        /**
         * Is the item active?
         *
         * @prop {Boolean}
         */
        active: Boolean,

        /**
         * An href attribute
         *
         * @prop {String}
         */
        href: String,

        /**
         * An breadcrumb label
         *
         * @prop {String}
         */
        label: String
      }
    };

    var Breadcrumb = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('nav', {
          attrs: {
            "aria-label": "breadcrumb"
          }
        }, [_c('ol', {
          staticClass: "breadcrumb"
        }, [_vm._l(_vm.items, function (item, i) {
          return _vm.items.length ? _c('breadcrumb-item', _vm._b({
            key: i,
            attrs: {
              "current": i === item.length - 1
            }
          }, 'breadcrumb-item', item, false)) : _vm._e();
        }), _vm._v(" "), _vm._t("default")], 2)]);
      },
      staticRenderFns: [],
      name: 'breadcrumb',
      components: {
        BreadcrumbItem: BreadcrumbItem
      },
      props: {
        /**
         * An array of breadcrumbs
         *
         * @prop {Array}
         */
        items: Array
      }
    };

    var plugin$9 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          Breadcrumb: Breadcrumb,
          BreadcrumbItem: BreadcrumbItem
        });
      }
    });

    var Sizeable = {
      props: {
        /**
         * The size of the form control
         *
         * @property String
         */
        size: {
          type: String,
          default: 'md',
          validate: function validate(value) {
            return ['sm', 'md', 'lg'].indexOf(value) !== -1;
          }
        }
      },
      computed: {
        sizeableClassPrefix: function sizeableClassPrefix() {
          return this.$options.name;
        },
        sizeableClass: function sizeableClass() {
          return prefix(this.size, this.sizeableClassPrefix);
        }
      }
    };

    /** Error message constants. */
    var FUNC_ERROR_TEXT$2 = 'Expected a function';

    /**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new negated function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */
    function negate(predicate) {
      if (typeof predicate != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT$2);
      }
      return function() {
        var args = arguments;
        switch (args.length) {
          case 0: return !predicate.call(this);
          case 1: return !predicate.call(this, args[0]);
          case 2: return !predicate.call(this, args[0], args[1]);
          case 3: return !predicate.call(this, args[0], args[1], args[2]);
        }
        return !predicate.apply(this, args);
      };
    }

    /**
     * The opposite of `_.pickBy`; this method creates an object composed of
     * the own and inherited enumerable string keyed properties of `object` that
     * `predicate` doesn't return truthy for. The predicate is invoked with two
     * arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omitBy(object, _.isNumber);
     * // => { 'b': '2' }
     */
    function omitBy(object, predicate) {
      return pickBy(object, negate(baseIteratee(predicate)));
    }

    var COLORS = ['primary', 'secondary', 'success', 'danger', 'warning', 'info', 'light', 'dark', 'white', 'muted'];
    var props = {};

    forEach(['border', 'text', 'bg', 'bg-gradient'], function (namespace) {
      forEach(COLORS, function (color) {
        props[camelCase(prefix(color, namespace))] = Boolean;
      });
    });

    function classes(instance, namespace) {
      return filter$1(map(COLORS, function (color) {
        return instance[camelCase(color = prefix(color, namespace))] ? color : null;
      }));
    }

    var Colorable = {
      props: props,
      methods: {
        textColor: function textColor() {
          return classes(this, 'text');
        },
        bgColor: function bgColor() {
          return classes(this, 'bg');
        },
        borderColor: function borderColor() {
          return classes(this, 'border');
        },
        bgGradientColor: function bgGradientColor() {
          return classes(this, 'bg-gradient');
        }
      },
      computed: {
        textColorClasses: function textColorClasses() {
          return this.textColor().join(' ').trim() || null;
        },
        borderColorClasses: function borderColorClasses() {
          return this.borderColor().join(' ').trim() || null;
        },
        bgColorClasses: function bgColorClasses() {
          return this.bgColor().join(' ').trim() || null;
        },
        bgGradientColorClasses: function bgGradientColorClasses() {
          return this.bgGradientColor().join(' ').trim() || null;
        },
        colorableClasses: function colorableClasses() {
          var classes = {};
          classes[this.textColorClasses] = !!this.textColorClasses;
          classes[this.borderColorClasses] = !!this.borderColorClasses;
          classes[this.bgColorClasses] = !!this.bgColorClasses;
          classes[this.bgGradientColorClasses] = !!this.bgGradientColorClasses;
          return omitBy(classes, function (key, value) {
            return !key || !value;
          });
        }
      }
    };

    var Btn = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _vm.to ? _c('router-link', {
          class: _vm.classes,
          attrs: {
            "to": _vm.to,
            "disabled": _vm.disabled,
            "role": "button"
          },
          on: {
            "click": _vm.onClick
          }
        }, [_vm._t("default")], 2) : _vm.href ? _c('a', {
          class: _vm.classes,
          attrs: {
            "href": _vm.href,
            "disabled": _vm.disabled,
            "role": "button"
          },
          on: {
            "click": _vm.onClick
          }
        }, [_vm._t("default")], 2) : _vm.label ? _c('label', {
          class: _vm.classes,
          attrs: {
            "disabled": _vm.disabled,
            "role": "button"
          },
          on: {
            "click": _vm.onClick
          }
        }, [_vm._t("default")], 2) : _c('button', {
          class: _vm.classes,
          attrs: {
            "type": _vm.type,
            "disabled": _vm.disabled
          },
          on: {
            "click": _vm.onClick
          }
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'btn',
      mixins: [Variant, Sizeable, Colorable],
      props: {
        /**
         * Display button with active state
         *
         * @property String
         */
        active: Boolean,

        /**
         * Display button with blocked state
         *
         * @property String
         */
        block: Boolean,

        /**
         * Display button with disabled state
         *
         * @property String
         */
        disabled: Boolean,

        /**
         * If an href is passed, button is an router-link element
         *
         * @property Boolean
         */
        href: String,

        /**
         * Should use <label> as the element for the button. Used for inputs
         * wrappers (toggles).
         *
         * @property Boolean
         */
        label: Boolean,

        /**
         * Display as an outline button
         *
         * @property String
         */
        outline: Boolean,

        /**
         * If an to is passed, button is an router-link element
         *
         * @property Boolean
         */
        to: [Object, String],

        /**
         * The type attribute for the button. Not applied if an anchor
         *
         * @property String
         */
        type: String
      },
      methods: {
        onClick: function onClick(event) {
          this.$emit('click', event, this);
        }
      },
      computed: {
        variantClassPrefix: function variantClassPrefix() {
          return this.$options.name + (this.outline ? '-outline' : '');
        },
        classes: function classes() {
          return this.$mergeClasses('btn', this.variantClass, this.sizeableClass, this.colorableClasses, this.block ? 'btn-block' : '', this.active ? 'active' : '');
        }
      }
    };

    var plugin$10 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          Btn: Btn
        });
      }
    });

    var Screenreaders = {
      props: {
        /**
         * Should show only for screenreaders
         *
         * @property Boolean
         */
        srOnly: Boolean,

        /**
         * Should be focusable for screenreaders
         *
         * @property Boolean
         */
        srOnlyFocusable: Boolean
      },
      computed: {
        screenreaderClasses: function screenreaderClasses() {
          return {
            'sr-only': this.srOnly,
            'sr-only-focusable': this.srOnlyFocusable
          };
        }
      }
    };

    var HelpText = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('small', {
          staticClass: "form-text",
          class: _vm.classes
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'help-text',
      mixins: [Colorable, Screenreaders],
      computed: {
        classes: function classes() {
          return assignIn({}, this.screenreaderClasses, this.colorableClasses);
        }
      }
    };

    var plugin$11 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          HelpText: HelpText
        });
      }
    });

    var FormGroup = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "form-group"
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'form-group'
    };

    var plugin$12 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          FormGroup: FormGroup
        });
      }
    });

    var FormLabel = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('label', {
          class: _vm.classes
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'form-label',
      mixins: [Colorable, Screenreaders],
      computed: {
        classes: function classes() {
          return assignIn({}, this.screenreaderClasses, this.colorableClasses);
        }
      }
    };

    var plugin$13 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          FormLabel: FormLabel
        });
      }
    });

    var FormFeedback = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          class: {
            'invalid-feedback': _vm.invalid,
            'valid-feedback': _vm.valid && !_vm.invalid
          }
        }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))])], 2);
      },
      staticRenderFns: [],
      name: 'form-feedback',
      mixins: [Colorable],
      props: {
        /**
         * The value of label element. If no value, no label will appear.
         *
         * @property String
         */
        label: String,

        /**
         * Should the feedback marked as invalid
         *
         * @property String
         */
        invalid: Boolean,

        /**
         * Should the feedback marked as invalid
         *
         * @property String
         */
        valid: Boolean
      }
    };

    var plugin$14 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          FormFeedback: FormFeedback
        });
      }
    });

    var FormControl = {
      props: {
        /**
         * The autocomplete attribute value.
         *
         * @property String
         */
        autocomplete: String,

        /**
         * The field id attribute value.
         *
         * @property String
         */
        id: [Number, String],

        /**
         * The value of label element. If no value, no label will appear.
         *
         * @property String
         */
        label: [Number, String],

        /**
         * The field name attribute value.
         *
         * @property String
         */
        name: String,

        /**
         * The field id attribute value.
         *
         * @property String
         */
        value: {
          default: null
        },

        /**
         * The placeholder attribute value.
         *
         * @property String
         */
        placeholder: String,

        /**
         * Is the field required.
         *
         * @property String
         */
        required: Boolean,

        /**
         * Add form-group wrapper to input
         *
         * @property String
         */
        group: {
          type: Boolean,
          value: true
        },

        /**
         * The regex pattern for validation.
         *
         * @property String
         */
        pattern: String,

        /**
         * An inline field validation error.
         *
         * @property String|Boolean
         */
        error: String,

        /**
         * An inline field validation errors passed as object with key/value
         * pairs. If errors passed as an object, the form name will be used for
         * the key.
         *
         * @property Object|Boolean
         */
        errors: {
          type: Object,
          default: function _default() {
            return {};
          }
        },

        /**
         * Some feedback to add to the field once the field is successfully
         * valid.
         *
         * @property String
         */
        feedback: [String, Array],

        /**
         * An array of event names that correlate with callback functions
         *
         * @property Function
         */
        bindEvents: {
          type: Array,
          default: function _default() {
            return ['focus', 'blur', 'change', 'click', 'keyup', 'keydown', 'progress'];
          }
        },

        /**
         * The default class name assigned to the control element
         *
         * @property String
         */
        defaultControlClass: {
          type: String,
          default: 'form-control'
        },

        /**
         * Hide the label for browsers, but leave it for screen readers.
         *
         * @property String
         */
        hideLabel: Boolean,

        /**
         * Additional margin/padding classes for fine control of spacing
         *
         * @property String
         */
        spacing: String,

        /**
         * The size of the form control
         *
         * @property String
         */
        size: {
          type: String,
          default: 'md',
          validate: function validate(value) {
            return ['sm', 'md', 'lg'].indexOf(value) !== -1;
          }
        },

        /**
         * Display the form field inline
         *
         * @property String
         */
        inline: Boolean,

        /**
         * If the form control is readonly, display only as text?
         *
         * @property String
         */
        plaintext: Boolean,

        /**
         * Is the form control readonly?
         *
         * @property String
         */
        readonly: Boolean,

        /**
         * Is the form control disabled?
         *
         * @property String
         */
        disabled: Boolean,

        /**
         * Some instructions to appear under the field label
         *
         * @property String
         */
        helpText: String,

        /**
         * The maxlength attribute
         *
         * @property String
         */
        maxlength: [Number, String]
      },
      directives: {
        bindEvents: {
          bind: function bind(el, binding, vnode) {
            var events = binding.value || vnode.context.bindEvents;

            forEach(events, function (name) {
              el.addEventListener(name, function (event) {
                vnode.context.$emit(name, event);
              });
            });
          }
        }
      },
      methods: {
        getInputField: function getInputField() {
          return this.$el.querySelector('.form-control, input, select, textarea');
        },
        getFieldErrors: function getFieldErrors() {
          var errors = this.error || this.errors;

          if (isObject(this.errors)) {
            errors = this.errors[this.name || this.id];
          }

          return !errors || isArray(errors) || isObject(errors) ? errors : [errors];
        },
        updated: function updated(value, event) {
          this.$emit(event || 'input', value);
        }
      },
      computed: {
        callbacks: function callbacks() {
          var _this = this;

          return this.bindEvents.map(function (event) {
            return {
              name: event,
              callback: _this[camelCase(['on', event].join(' '))]
            };
          }).filter(function (event) {
            return !isUndefined(event.callback);
          });
        },
        invalidFeedback: function invalidFeedback() {
          if (this.error) {
            return this.error;
          }

          var errors = this.getFieldErrors();
          return isArray(errors) ? errors.join('<br>') : errors;
        },
        validFeedback: function validFeedback() {
          return isArray(this.feedback) ? this.feedback.join('<br>') : this.feedback;
        },
        controlClass: function controlClass() {
          return this.defaultControlClass + (this.plaintext ? '-plaintext' : '');
        },
        controlSizeClass: function controlSizeClass() {
          return prefix(this.size, this.controlClass);
        },
        controlClasses: function controlClasses() {
          return [this.controlClass, this.controlSizeClass, this.spacing || '', this.invalidFeedback ? 'is-invalid' : ''].join(' ');
        },
        hasDefaultSlot: function hasDefaultSlot() {
          return !!this.$slots.default;
        }
      }
    };

    var InputField = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('form-group', [_vm._t("label", [_vm.label || _vm.hasDefaultSlot ? _c('form-label', {
          attrs: {
            "for": _vm.id
          },
          domProps: {
            "innerHTML": _vm._s(_vm.label)
          }
        }) : _vm._e()]), _vm._v(" "), _vm._t("control", [_c('input', {
          directives: [{
            name: "bind-events",
            rawName: "v-bind-events",
            value: _vm.bindEvents,
            expression: "bindEvents"
          }],
          class: _vm.$mergeClasses(_vm.controlClasses, _vm.colorableClasses),
          attrs: {
            "id": _vm.id,
            "type": _vm.type,
            "name": _vm.name,
            "pattern": _vm.pattern,
            "readonly": _vm.readonly,
            "required": _vm.required,
            "maxlength": _vm.maxlength,
            "placeholder": _vm.placeholder,
            "disabled": _vm.disabled || _vm.readonly,
            "aria-label": _vm.label,
            "aria-describedby": _vm.id,
            "autocomplete": _vm.autocomplete
          },
          domProps: {
            "value": _vm.value
          },
          on: {
            "input": function input($event) {
              _vm.updated($event.target.value);
            }
          }
        })]), _vm._v(" "), _vm._t("default"), _vm._v(" "), _vm._t("help", [_vm.helpText ? _c('help-text', {
          domProps: {
            "innerHTML": _vm._s(_vm.helpText)
          }
        }) : _vm._e()]), _vm._v(" "), _vm._t("feedback", [_vm.validFeedback ? _c('form-feedback', {
          attrs: {
            "valid": ""
          },
          domProps: {
            "innerHTML": _vm._s(_vm.validFeedback)
          }
        }) : _vm._e(), _vm._v(" "), _vm.invalidFeedback ? _c('form-feedback', {
          attrs: {
            "invalid": ""
          },
          domProps: {
            "innerHTML": _vm._s(_vm.invalidFeedback)
          }
        }) : _vm._e()])], 2);
      },
      staticRenderFns: [],
      name: 'input-field',
      mixins: [Colorable, FormControl],
      components: {
        HelpText: HelpText,
        FormGroup: FormGroup,
        FormLabel: FormLabel,
        FormFeedback: FormFeedback
      },
      props: {
        /**
         * The type attribute
         *
         * @property String
         */
        type: {
          type: String,
          default: 'text'
        }
      }
    };

    var plugin$15 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          InputField: InputField
        });
      }
    });

    var FileField = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('form-group', [_vm._t("label", [_vm.label || _vm.hasDefaultSlot ? _c('form-label', {
          attrs: {
            "for": _vm.id
          }
        }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))])], 2) : _vm._e()]), _vm._v(" "), _c('div', {
          staticClass: "custom-file"
        }, [_vm._t("placeholder", [_c('form-label', {
          class: _vm.$mergeClasses(_vm.colorableClasses, 'custom-file-label'),
          attrs: {
            "for": _vm.id
          },
          domProps: {
            "innerHTML": _vm._s(_vm.placeholder || 'Choose file')
          }
        })]), _vm._v(" "), _c('input', {
          directives: [{
            name: "bind-events",
            rawName: "v-bind-events"
          }],
          class: _vm.controlClasses,
          attrs: {
            "type": "file",
            "id": _vm.id,
            "width": _vm.width,
            "height": _vm.height,
            "required": _vm.required,
            "multiple": _vm.multiple,
            "readonly": _vm.readonly
          },
          on: {
            "change": function change($event) {
              _vm.updated($event.target.files, 'change');
            }
          }
        }), _vm._v(" "), _vm._t("help", [_vm.helpText ? _c('help-text', {
          domProps: {
            "innerHTML": _vm._s(_vm.helpText)
          }
        }) : _vm._e()]), _vm._v(" "), _vm._t("feedback", [_vm.validFeedback ? _c('form-feedback', {
          attrs: {
            "valid": ""
          },
          domProps: {
            "innerHTML": _vm._s(_vm.validFeedback)
          }
        }) : _vm._e(), _vm._v(" "), _vm.invalidFeedback ? _c('form-feedback', {
          attrs: {
            "invalid": ""
          },
          domProps: {
            "innerHTML": _vm._s(_vm.invalidFeedback)
          }
        }) : _vm._e()])], 2)], 2);
      },
      staticRenderFns: [],
      name: 'file-field',
      extends: InputField,
      components: {
        HelpText: HelpText,
        FormGroup: FormGroup,
        FormLabel: FormLabel,
        FormFeedback: FormFeedback
      },
      model: {
        event: 'change'
      },
      props: {
        /**
         * An array of event names that correlate with callback functions
         *
         * @property Function
         */
        bindEvents: {
          type: Array,
          default: function _default() {
            return ['focus', 'blur', 'input', 'click', 'keyup', 'keydown', 'progress'];
          }
        },

        /**
         * The class name assigned to the control element
         *
         * @property String
         */
        defaultControlClass: {
          type: String,
          default: 'custom-file-input'
        },

        /**
         * An array of valid extensions
         *
         * @property String
         */
        extensions: Array,

        /**
         * The type attribute
         *
         * @property String
         */
        multiple: Boolean,

        /**
         * The height attribute for the control element
         *
         * @property String
         */
        height: [Number, String],

        /**
         * The width attribute for the control element
         *
         * @property String
         */
        width: [Number, String]
      }
    };

    var BtnFile = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('btn', {
          staticClass: "btn-file",
          attrs: {
            "type": _vm.type,
            "variant": _vm.variant,
            "block": _vm.block,
            "size": _vm.size,
            "disabled": _vm.disabled,
            "active": _vm.active
          }
        }, [_vm._t("default"), _vm._v(" "), _c('input', {
          directives: [{
            name: "bind-events",
            rawName: "v-bind-events"
          }],
          class: _vm.controlClasses,
          attrs: {
            "type": "file",
            "id": _vm.id,
            "width": _vm.width,
            "height": _vm.height,
            "required": _vm.required,
            "multiple": _vm.multiple,
            "readonly": _vm.readonly
          },
          on: {
            "change": function change($event) {
              _vm.updated($event.target.files, 'change');
            }
          }
        })], 2);
      },
      staticRenderFns: [],
      name: 'btn-file',
      mixins: [Btn, FileField],
      model: {
        event: 'change'
      },
      props: {
        /**
         * The type attribute for the button. Not applied if an anchor
         *
         * @property String
         */
        type: {
          type: String,
          default: 'button'
        }
      }
    };

    var plugin$16 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          BtnFile: BtnFile
        });
      }
    });

    var BtnGroup = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          class: _vm.classes,
          attrs: {
            "data-toggle": _vm.toggle ? 'buttons' : false,
            "role": "group"
          }
        }, [_vm._l(_vm.buttons, function (button, i) {
          return _vm.buttons ? _c('btn', _vm._b({
            key: i
          }, 'btn', button, false)) : _vm._e();
        }), _vm._v(" "), _vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'btn-group',
      components: {
        Btn: Btn
      },
      mixins: [Colorable],
      props: {
        /**
         * An array of buttons
         *
         * @type {Array}
         */
        buttons: Array,

        /**
         * Denote the button group as toggle buttons
         *
         * @type {Boolean}
         */
        toggle: Boolean,

        /**
         * Display the buttons vertically
         *
         * @type {Boolean}
         */
        vertical: Boolean
      },
      computed: {
        classes: function classes() {
          return this.$mergeClasses(this.colorableClasses, {
            'btn-group': !this.vertical,
            'btn-group-toggle': this.toggle,
            'btn-group-vertical': this.vertical
          });
        }
      }
    };

    var BtnGroupToggle = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "btn-group-toggle",
          attrs: {
            "data-toggle": "buttons"
          }
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'btn-group-toggle'
    };

    var BtnToolbar = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "btn-toolbar",
          attrs: {
            "role": "toolbar"
          }
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'btn-toolbar'
    };

    var plugin$17 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          BtnGroup: BtnGroup,
          BtnGroupToggle: BtnGroupToggle,
          BtnToolbar: BtnToolbar
        });
      }
    });

    function uuid() {
      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        var r = Math.random() * 16 | 0,
            v = c == 'x' ? r : r & 0x3 | 0x8;
        return v.toString(16);
      });
    }

    var Proxy = {
      methods: {
        proxy: function proxy(callback, event) {
          if (isFunction$1(callback)) {
            callback.apply(this, [].slice.call(arguments).splice(1));
            event.preventDefault();
          }
        }
      }
    };

    var DropdownMenuItem = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c(_vm.component, {
          tag: "component",
          staticClass: "dropdown-item",
          class: {
            'active': _vm.active
          },
          attrs: {
            "href": _vm.href || (_vm.component === 'a' ? '#' : false),
            "type": _vm.component === 'button' ? 'button' : false
          },
          on: {
            "click": _vm.onClick
          }
        }, [_vm.icon ? _c('i', {
          class: _vm.icon
        }) : _vm._e(), _vm._v(" "), _vm._t("default", [_vm._v(_vm._s(_vm.label))])], 2);
      },
      staticRenderFns: [],
      mixins: [Proxy],
      props: {
        /**
         * Is the menu item active.
         *
         * @property Object
         */
        active: Boolean,

        /**
         * Is the menu item a button
         *
         * @property Object
         */
        button: Boolean,

        /**
         * The `element` attribute.
         *
         * @property Object
         */
        element: String,

        /**
         * The `href` attribute.
         *
         * @property Object
         */
        href: String,

        /**
         * The icon of the dropdown menu item.
         *
         * @property Object
         */
        icon: String,

        /**
         * The label of the dropdown menu item.
         *
         * @property Object
         */
        label: String
      },
      computed: {
        component: function component() {
          return this.element || (this.button ? 'button' : 'a');
        }
      },
      methods: {
        /**
         * A callback function for the `click` event.
         *
         * @property Object
         */
        onClick: function onClick(event) {
          this.$emit('click', event, this);
        }
      }
    };

    var DropdownMenuHeader = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('h5', {
          staticClass: "dropdown-header"
        }, [_vm._t("default", [_vm._v(_vm._s(_vm.header))])], 2);
      },
      staticRenderFns: [],
      name: 'dropdown-menu-header',
      props: {
        /**
         * The value of the header
         *
         * @property Object
         */
        header: String
      }
    };

    var DropdownMenuDivider = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "dropdown-divider"
        });
      },
      staticRenderFns: [],
      name: 'dropdown-menu-divider'
    };

    var DropdownMenu = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "dropdown-menu",
          class: {
            'dropdown-menu-right': _vm.align === 'right',
            'show': _vm.show
          },
          attrs: {
            "aria-labelledby": _vm.id,
            "tabindex": "-1"
          },
          on: {
            "click": _vm.onClick
          }
        }, [_vm._l(_vm.items, function (item) {
          return [_c(_vm.prefix(item.type || 'item', 'dropdown-menu'), _vm._b({
            tag: "component"
          }, 'component', item, false))];
        }), _vm._v(" "), _vm._t("default")], 2);
      },
      staticRenderFns: [],
      components: {
        DropdownMenuItem: DropdownMenuItem,
        DropdownMenuHeader: DropdownMenuHeader,
        DropdownMenuDivider: DropdownMenuDivider
      },
      props: {
        /**
         * The `id` attribute on the toggle button and aria label. If no `id` is
         * defined, then a UUID will be generated instead.
         *
         * @property Object
         */
        id: {
          type: String,
          default: uuid
        },

        /**
         * Display the dropdown menu aligned left or right
         *
         * @property String
         */
        align: {
          type: String,
          default: 'left',
          validate: function validate(value) {
            return ['left', 'right'].indexOf(value.toLowerCase()) !== -1;
          }
        },

        /**
         * The default visibility of the dropdown menu.
         *
         * @property Object
         */
        show: Boolean,

        /**
         * An array of dropdown items. If an key/value pair isn't defined, the
         * default value will be used. If no items are defined, then the slot
         * named "items" can be used to define the options with HTML.
         *
         * [{
         *      type: 'item', // String [item|header|divider]
         *      href: '#', // String
         *      label: 'Some label', // String
         *      onClick: (event) => {} // Function
         * }]
         *
         * @property Array
         */
        items: Array
      },
      methods: {
        prefix: prefix,

        /**
         * A callback function for the `click` event.
         *
         * @param Object event
         * @param Object item
         * @return void
         */
        onClick: function onClick(event) {
          this.$emit('click', event, this);
        },

        /**
         * A callback function for the `click` event.
         *
         * @param Object event
         * @param Object item
         * @return void
         */
        onItemClick: function onItemClick(event, item) {
          this.$emit('item:click', event, item);
        }
      },
      mounted: function mounted() {
        var _this = this;

        forEach(this.$children, function (child) {
          child.$on('click', function (event) {
            _this.onItemClick(event, child);
          });
        });
      }
    };

    var plugin$18 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          DropdownMenu: DropdownMenu,
          DropdownMenuDivider: DropdownMenuDivider,
          DropdownMenuHeader: DropdownMenuHeader,
          DropdownMenuItem: DropdownMenuItem
        });
      }
    });

    var TAB_KEYCODE = 9;
    var LEFT_ARROW_KEYCODE = 37;
    var RIGHT_ARROW_KEYCODE = 39;
    var UP_ARROW_KEYCODE = 38;
    var DOWN_ARROW_KEYCODE = 40;
    var ignoreBlurEvent = false;
    var BtnDropdown = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _vm.split ? _c('btn-group', [!_vm.dropleft ? [_vm.href ? _c('a', {
          class: _vm.actionClasses,
          attrs: {
            "href": _vm.href
          },
          on: {
            "click": _vm.onClick
          }
        }, [_vm._t("label", [_vm.icon ? _c('i', {
          class: _vm.icon
        }) : _vm._e(), _vm._v(" " + _vm._s(_vm.label))])], 2) : _c('button', {
          class: _vm.actionClasses,
          attrs: {
            "type": _vm.type
          },
          on: {
            "click": _vm.onClick
          }
        }, [_vm._t("label-wrapper", [_vm.icon ? _c('i', {
          class: _vm.icon
        }) : _vm._e(), _vm._v(" "), _vm._t("label", [_vm._v(_vm._s(_vm.label))])])], 2)] : _vm._e(), _vm._v(" "), _c('btn-group', {
          class: {
            'dropup': _vm.dropup,
            'dropright': _vm.dropright,
            'dropleft': _vm.dropleft
          }
        }, [_c('button', {
          class: _vm.toggleClasses,
          attrs: {
            "type": "button",
            "aria-haspopup": "true",
            "aria-expanded": _vm.isDropdownShowing,
            "id": _vm.id
          },
          on: {
            "click": function click($event) {
              $event.preventDefault();
              !_vm.isDropdownShowing ? _vm.show() : _vm.hide();
            },
            "blur": _vm.onBlur
          }
        }), _vm._v(" "), _c('dropdown-menu', {
          attrs: {
            "id": _vm.id,
            "align": _vm.align,
            "show": _vm.isDropdownShowing
          },
          on: {
            "update:show": function updateShow($event) {
              _vm.isDropdownShowing = $event;
            },
            "click": _vm.onMenuClick,
            "item:click": _vm.onItemClick
          }
        }, [_vm._t("default")], 2)], 1), _vm._v(" "), _vm.dropleft ? [_vm.href ? _c('a', {
          class: _vm.actionClasses,
          attrs: {
            "href": _vm.href
          },
          on: {
            "click": _vm.onClick
          }
        }, [_vm._t("label", [_vm.icon ? _c('i', {
          class: _vm.icon
        }) : _vm._e(), _vm._v(" " + _vm._s(_vm.label))])], 2) : _c('button', {
          class: _vm.actionClasses,
          attrs: {
            "type": _vm.type
          },
          on: {
            "click": _vm.onClick
          }
        }, [_vm._t("label-wrapper", [_vm.icon ? _c('i', {
          class: _vm.icon
        }) : _vm._e(), _vm._v(" "), _vm._t("label", [_vm._v(_vm._s(_vm.label))])])], 2)] : _vm._e()], 2) : _c('btn-group', {
          class: {
            'dropup': _vm.dropup,
            'dropright': _vm.dropright,
            'dropleft': _vm.dropleft
          },
          on: {
            "click": _vm.onClick
          }
        }, [_c('button', {
          class: _vm.toggleClasses,
          attrs: {
            "aria-haspopup": "true",
            "aria-expanded": _vm.isDropdownShowing,
            "type": _vm.type,
            "id": _vm.id
          },
          on: {
            "click": function click($event) {
              $event.preventDefault();
              !_vm.isDropdownShowing ? _vm.show() : _vm.hide();
            },
            "blur": _vm.onBlur
          }
        }, [_vm._t("label", [_vm.icon ? _c('i', {
          class: _vm.icon
        }) : _vm._e(), _vm._v(" " + _vm._s(_vm.label))])], 2), _vm._v(" "), _c('dropdown-menu', {
          attrs: {
            "id": _vm.id,
            "align": _vm.align,
            "show": _vm.isDropdownShowing
          },
          on: {
            "update:show": function updateShow($event) {
              _vm.isDropdownShowing = $event;
            },
            "click": _vm.onMenuClick,
            "item:click": _vm.onItemClick
          }
        }, [_vm._t("default")], 2)], 1);
      },
      staticRenderFns: [],
      name: 'btn-dropdown',
      extends: Btn,
      components: {
        BtnGroup: BtnGroup,
        DropdownMenu: DropdownMenu
      },
      props: {
        /**
         * The button icon that appears before the label.
         *
         * @property String
         */
        autoclose: Boolean,

        /**
         * The button icon that appears before the label.
         *
         * @property String
         */
        icon: String,

        /**
         * The toggle button's label. If not defined as an attribute,
         * you can override with the component's slot (inner html).
         *
         * @property String
         */
        label: String,

        /**
         * The `id` attribute on the toggle button and aria label. If no `id` is
         * defined, then a UUID will be generated instead.
         *
         * @property String
         */
        id: {
          type: String,
          default: uuid
        },

        /**
         * The button type attribute.
         *
         * @property String
         */
        type: {
          type: String,
          default: 'button'
        },

        /**
         * Display the dropdown menu aligned left or right
         *
         * @property String
         */
        align: {
          type: String,
          default: 'left',
          validate: function validate(value) {
            return ['left', 'right'].indexOf(value.toLowerCase()) !== -1;
          }
        },

        /**
         * Display the dropdown button with a split toggle button.
         *
         * @property Boolean
         */
        split: {
          type: Boolean,
          default: false
        },

        /**
         * Display as a dropup instead of a dropdown.
         *
         * @property Boolean
         */
        dropup: {
          type: Boolean,
          default: false
        },

        /**
         * Display as a dropright instead of a dropdown.
         *
         * @property Boolean
         */
        dropright: {
          type: Boolean,
          default: false
        },

        /**
         * Display as a dropleft instead of a dropdown.
         *
         * @property Boolean
         */
        dropleft: {
          type: Boolean,
          default: false
        }
      },
      methods: {
        /**
         * Focus on the the dropdown toggle button
         *
         * @return void
         */
        focus: function focus() {
          this.$el.querySelector('.dropdown-toggle').focus();
        },

        /**
         * Focus on the the dropdown toggle button
         *
         * @return void
         */
        queryFocusable: function queryFocusable() {
          return this.$el.querySelector('.dropdown-menu').querySelectorAll('label, input, select, textarea, [tabindex]:not([tabindex="-1"])');
        },

        /**
         * Method to check if the given element is focusable.
         *
         * @return void
         */
        isFocusable: function isFocusable(element) {
          var nodes = this.queryFocusable();

          for (var i in nodes) {
            if (element === nodes[i]) {
              return true;
            }
          }

          return false;
        },

        /**
         * Toggle the dropdown menu
         *
         * @return void
         */
        toggle: function toggle() {
          !this.isDropdownShowing ? this.show() : this.hide();
        },

        /**
         * Show the dropdown menu
         *
         * @return void
         */
        show: function show() {
          var _this = this;

          this.isDropdownShowing = true;
          this.$nextTick(function () {
            var side = 'bottom';

            if (_this.dropup) {
              side = 'top';
            } else if (_this.dropleft) {
              side = 'left';
            } else if (_this.dropright) {
              side = 'right';
            }

            var menu = _this.$el.querySelector('.dropdown-menu');

            var toggle = _this.$el.querySelector('.dropdown-toggle');

            var position = [side, _this.align === 'left' ? 'start' : 'end'];
            new Popper(toggle, menu, {
              placement: position.join('-')
            });

            if (_this.queryFocusable().item(0)) {
              _this.$el.querySelector('input, select, textarea').focus();
            }

            _this.$emit('show');
          });
        },

        /**
         * Hide the dropdown menu
         *
         * @return void
         */
        hide: function hide() {
          this.$emit('toggle', this.isDropdownShowing = false);
          this.$emit('hide');
        },

        /**
         * A callback function for the `click` event for the action button
         *
         * @return void
         */
        onClick: function onClick(event) {
          this.hide();
          this.$emit('click', event);
        },

        /**
         * A callback function for the `blur` event for the action button
         *
         * @return void
         */
        onBlur: function onBlur(event) {
          if (!this.$el.contains(event.relatedTarget)) {
            this.hide();
          }
        },

        /**
         * A callback function for the `item:click` event for the action button
         *
         * @return void
         */
        onMenuClick: function onMenuClick(event, item) {
          if (event.target === this.$el.querySelector('.dropdown-menu')) {
            this.focus();
          }
        },

        /**
         * A callback function for the `item:click` event for the action button
         *
         * @return void
         */
        onItemClick: function onItemClick(event, item) {
          if (!this.isFocusable(event.target)) {
            this.hide();
          }

          this.$emit('item:click', event, item);
        }
      },
      computed: {
        variantClassPrefix: function variantClassPrefix() {
          return 'btn' + (this.outline ? '-outline' : '');
        },
        sizeableClassPrefix: function sizeableClassPrefix() {
          return 'btn';
        },
        actionClasses: function actionClasses() {
          return ['btn', prefix(this.size, 'btn'), prefix(this.variant, 'btn')].join(' ');
        },
        toggleClasses: function toggleClasses() {
          return ['btn', 'dropdown-toggle', this.variantClass, this.sizeableClass, this.active ? 'active' : '', this.block ? 'btn-block' : '', this.split ? 'dropdown-toggle-split' : ''].join(' ');
        }
      },
      data: function data() {
        return {
          isDropdownShowing: false
        };
      },
      mounted: function mounted() {
        var _this2 = this;

        forEach(this.$el.querySelectorAll('[type=submit], input, select, textarea, [tabindex]:not([tabindex="-1"]'), function (el) {
          var keydown = function keydown(event) {
            var ignore = [LEFT_ARROW_KEYCODE, RIGHT_ARROW_KEYCODE, UP_ARROW_KEYCODE, DOWN_ARROW_KEYCODE, TAB_KEYCODE];

            if (ignore.indexOf(event.keyCode) !== -1) {
              ignoreBlurEvent = true;
            }
          };

          var blur = function blur(event) {
            if (!ignoreBlurEvent) {
              _this2.focus();
            }

            ignoreBlurEvent = false;
          };

          var focus = function focus(event) {
            ignoreBlurEvent = false;
          };

          var mousedown = function mousedown(event) {
            ignoreBlurEvent = true;
          };

          el.addEventListener('blur', blur);
          el.addEventListener('focus', focus);
          el.addEventListener('keydown', keydown);
          el.addEventListener('mousedown', mousedown);
        });
      }
    };

    var plugin$19 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          BtnDropdown: BtnDropdown
        });
      }
    });

    var HasSlots = {
      methods: {
        getSlot: function getSlot(slot) {
          return this.$slots[slot];
        },
        hasSlot: function hasSlot(slot) {
          return !!this.$slots[slot];
        },
        hasSlots: function hasSlots(slots) {
          for (var i in slots) {
            if (!this.hasSlot(slots[i])) {
              return false;
            }
          }
        }
      },
      computed: {
        hasDefaultSlot: function hasDefaultSlot() {
          return this.hasSlot('default');
        }
      }
    };

    var Card = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          class: _vm.$mergeClasses(_vm.className, _vm.colorableClasses)
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'card',
      mixins: [HasSlots, Colorable],
      computed: {
        className: function className() {
          return this.$options.name;
        }
      }
    };

    var CardBody = {
      name: 'card-body',
      extends: Card
    };

    var CardBtnGroup = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('btn-group', {
          staticClass: "card-btn-group"
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'card-btn-group',
      extends: Card
    };

    var CardDeck = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "card-deck"
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'card-deck'
    };

    var CardHeader = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c(_vm.tag, {
          tag: "component",
          class: _vm.$mergeClasses(_vm.className, _vm.colorableClasses)
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'card-header',
      extends: Card,
      props: {
        /**
         * The component's HTML tag name
         *
         * @property String
         */
        tag: {
          type: String,
          default: 'h5'
        }
      }
    };

    var CardFooter = {
      name: 'card-footer',
      extends: CardHeader,
      props: {
        /**
         * The component's HTML tag name
         *
         * @property String
         */
        tag: {
          type: String,
          default: 'div'
        }
      }
    };

    var CardImg = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "d-flex justify-content-center align-items-center",
          class: _vm.$mergeClasses(_vm.className),
          style: {
            height: _vm.unit(_vm.height)
          }
        }, [_vm.background ? _c('div', {
          staticClass: "card-img-bg",
          style: {
            background: _vm.background ? "url(".concat(this.src, ")") : null,
            overflow: _vm.blur ? 'hidden' : 'inherit',
            filter: _vm.blur ? "blur(".concat(_vm.unit(_vm.blur), ")") : null
          }
        }) : _vm._e(), _vm._v(" "), !_vm.background && _vm.src ? _c('img', {
          staticClass: "img-fluid",
          attrs: {
            "src": _vm.src,
            "alt": _vm.alt
          }
        }) : _vm._e(), _vm._v(" "), _c('div', {
          staticClass: "card-img-content",
          class: {
            'text-truncate': _vm.textTruncate
          }
        }, [_vm._t("default")], 2)]);
      },
      staticRenderFns: [],
      name: 'card-img',
      extends: Card,
      props: {
        /**
         * The alt attribute
         *
         * @property String
         */
        alt: String,

        /**
         * Display the image as a background image fit with CSS cover.
         *
         * @property String
         */
        background: Boolean,

        /**
         * The amount to blur the background image.
         *
         * @property String
         */
        blur: [Number, String],

        /**
         * The height attribute
         *
         * @property String
         */
        height: [Number, String],

        /**
         * Truncate the text in the content
         *
         * @property String
         */
        textTruncate: Boolean,

        /**
         * The src attribute
         *
         * @property String
         */
        src: String
      },
      methods: {
        unit: function unit$$1(value) {
          return unit(value);
        }
      }
    };

    var CardImgTop = {
      name: 'card-img-top',
      extends: CardImg
    };

    var CardImgBottom = {
      name: 'card-img-bottom',
      extends: CardImg
    };

    var CardImgOverlay = {
      name: 'card-img-overlay',
      extends: Card
    };

    var CardLink = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('router-link', {
          class: _vm.$mergeClasses(_vm.className, _vm.colorableClasses),
          attrs: {
            "to": _vm.href
          },
          on: {
            "click": _vm.onClick
          }
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'card-link',
      extends: Card,
      props: {
        /**
         * The alt attribute
         *
         * @property String
         */
        alt: String,

        /**
         * The href attribute
         *
         * @property String
         */
        href: String,

        /**
         * The to attribute
         *
         * @property String
         */
        to: [Object, String]
      },
      methods: {
        onClick: function onClick(event) {
          this.$emit('click', event, this);
        }
      }
    };

    var CardSubtitle = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('h6', {
          class: _vm.$mergeClasses(_vm.className, _vm.colorableClasses)
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'card-subtitle',
      extends: Card
    };

    var CardTitle = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('h5', {
          class: _vm.$mergeClasses(_vm.className, _vm.colorableClasses)
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'card-title',
      mixins: [Card]
    };

    var plugin$20 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          Card: Card,
          CardBody: CardBody,
          CardBtnGroup: CardBtnGroup,
          CardDeck: CardDeck,
          CardFooter: CardFooter,
          CardHeader: CardHeader,
          CardImg: CardImg,
          CardImgTop: CardImgTop,
          CardImgBottom: CardImgBottom,
          CardImgOverlay: CardImgOverlay,
          CardLink: CardLink,
          CardSubtitle: CardSubtitle,
          CardTitle: CardTitle
        });
      }
    });

    var RadioField = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          class: _vm.$mergeClasses(_vm.controlClass, _vm.customControlClass, _vm.sizeableClass, _vm.inline ? _vm.inlineClass : '')
        }, [_vm.custom && _vm.id ? [_c('input', {
          directives: [{
            name: "bind-events",
            rawName: "v-bind-events"
          }],
          class: _vm.$mergeClasses(_vm.inputClass, _vm.invalidFeedback ? 'is-invalid' : ''),
          attrs: {
            "type": "radio",
            "name": _vm.name,
            "id": _vm.id,
            "required": _vm.required,
            "disabled": _vm.disabled || _vm.readonly,
            "readonly": _vm.readonly,
            "pattern": _vm.pattern
          },
          domProps: {
            "value": _vm.value,
            "checked": _vm.checkedValue === _vm.value || _vm.checked
          },
          on: {
            "change": function change($event) {
              _vm.updated($event.target.value, 'change');
            }
          }
        }), _vm._v(" "), _c('label', {
          class: _vm.$mergeClasses(_vm.labelClass, _vm.colorableClasses),
          attrs: {
            "for": _vm.id
          }
        }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))]), _vm._v(" "), _vm._t("feedback", [_vm.validFeedback ? _c('form-feedback', {
          attrs: {
            "valid": ""
          },
          domProps: {
            "innerHTML": _vm._s(_vm.validFeedback)
          }
        }) : _vm._e(), _vm._v(" "), _vm.invalidFeedback ? _c('form-feedback', {
          attrs: {
            "invalid": ""
          },
          domProps: {
            "innerHTML": _vm._s(_vm.invalidFeedback)
          }
        }) : _vm._e()])], 2)] : [_c('label', {
          class: _vm.$mergeClasses(_vm.labelClass, _vm.colorableClasses),
          attrs: {
            "for": _vm.id
          }
        }, [_c('input', {
          directives: [{
            name: "bind-events",
            rawName: "v-bind-events"
          }],
          class: _vm.$mergeClasses(_vm.inputClass, _vm.invalidFeedback ? 'is-invalid' : ''),
          attrs: {
            "type": "radio",
            "name": _vm.name,
            "id": _vm.id,
            "required": _vm.required,
            "disabled": _vm.disabled || _vm.readonly,
            "readonly": _vm.readonly,
            "pattern": _vm.pattern
          },
          domProps: {
            "value": _vm.value,
            "checked": _vm.checkedValue === _vm.value || _vm.checked
          },
          on: {
            "change": function change($event) {
              _vm.updated($event.target.value, 'change');
            }
          }
        }), _vm._v(" "), _vm._t("default", [_vm._v(_vm._s(_vm.label))]), _vm._v(" "), _vm._t("feedback", [_vm.validFeedback ? _c('form-feedback', {
          attrs: {
            "valid": ""
          },
          domProps: {
            "innerHTML": _vm._s(_vm.validFeedback)
          }
        }) : _vm._e(), _vm._v(" "), _vm.invalidFeedback ? _c('form-feedback', {
          attrs: {
            "invalid": ""
          },
          domProps: {
            "innerHTML": _vm._s(_vm.invalidFeedback)
          }
        }) : _vm._e()])], 2)], _vm._v(" "), _vm._t("help", [_vm.helpText ? _c('help-text', {
          domProps: {
            "innerHTML": _vm._s(_vm.helpText)
          }
        }) : _vm._e()])], 2);
      },
      staticRenderFns: [],
      name: 'radio-field',
      components: {
        HelpText: HelpText,
        FormFeedback: FormFeedback
      },
      mixins: [Colorable, FormControl],
      model: {
        event: 'change',
        prop: 'checkedValue'
      },
      props: {
        /**
         * An array of event names that correlate with callback functions
         *
         * @property Function
         */
        bindEvents: {
          type: Array,
          default: function _default() {
            return ['focus', 'blur', 'input', 'click', 'keyup', 'keydown', 'progress'];
          }
        },

        /**
         * Is this a custom element
         *
         * @property String
         */
        custom: Boolean,

        /**
         * Display the form field and label inline
         *
         * @property Function
         */
        inline: Boolean,

        /**
         * The checked values
         *
         * @property String
         */
        checked: Boolean,

        /**
         * The checked value
         *
         * @property String
         */
        checkedValue: [Boolean, Number, String, Object],

        /**
         * The class name assigned to the control element
         *
         * @property String
         */
        defaultControlClass: {
          type: String,
          default: 'form-check'
        }
      },
      computed: {
        labelClass: function labelClass() {
          return prefix('label', this.controlClass);
        },
        inputClass: function inputClass() {
          return prefix('input', this.controlClass);
        },
        inlineClass: function inlineClass() {
          return prefix('inline', this.controlClass);
        },
        controlClass: function controlClass() {
          return this.custom ? 'custom-control' : this.defaultControlClass;
        },
        customControlClass: function customControlClass() {
          return this.custom ? prefix(this.$options.name.replace('-field', ''), 'custom') : '';
        },
        sizeableClass: function sizeableClass() {
          return prefix(this.size, 'form-control');
        }
      }
    };

    var CheckboxField = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          class: _vm.$mergeClasses(_vm.controlClass, _vm.customControlClass, _vm.sizeableClass, _vm.inline ? _vm.inlineClass : '')
        }, [_vm.custom && _vm.id ? [_c('input', {
          directives: [{
            name: "bind-events",
            rawName: "v-bind-events"
          }],
          class: _vm.$mergeClasses(_vm.inputClass, _vm.invalidFeedback ? 'is-invalid' : ''),
          attrs: {
            "type": "checkbox",
            "name": _vm.name,
            "id": _vm.id,
            "required": _vm.required,
            "disabled": _vm.disabled || _vm.readonly,
            "readonly": _vm.readonly,
            "pattern": _vm.pattern
          },
          domProps: {
            "value": _vm.value,
            "checked": _vm.checkedValues.indexOf(_vm.value) !== -1 || _vm.checked
          },
          on: {
            "change": function change($event) {
              _vm.updated($event.target.value, 'change');
            }
          }
        }), _vm._v(" "), _c('label', {
          class: _vm.$mergeClasses(_vm.labelClass, _vm.colorableClasses),
          attrs: {
            "for": _vm.id
          }
        }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))]), _vm._v(" "), _vm._t("feedback", [_vm.validFeedback ? _c('form-feedback', {
          attrs: {
            "valid": ""
          },
          domProps: {
            "innerHTML": _vm._s(_vm.validFeedback)
          }
        }) : _vm._e(), _vm._v(" "), _vm.invalidFeedback ? _c('form-feedback', {
          attrs: {
            "invalid": ""
          },
          domProps: {
            "innerHTML": _vm._s(_vm.invalidFeedback)
          }
        }) : _vm._e()])], 2)] : [_c('label', {
          class: _vm.$mergeClasses(_vm.labelClass, _vm.colorableClasses),
          attrs: {
            "for": _vm.id
          }
        }, [_c('input', {
          directives: [{
            name: "bind-events",
            rawName: "v-bind-events"
          }],
          class: _vm.$mergeClasses(_vm.inputClass, _vm.invalidFeedback ? 'is-invalid' : ''),
          attrs: {
            "type": "checkbox",
            "name": _vm.name,
            "id": _vm.id,
            "required": _vm.required,
            "disabled": _vm.disabled || _vm.readonly,
            "readonly": _vm.readonly,
            "pattern": _vm.pattern
          },
          domProps: {
            "value": _vm.value,
            "checked": _vm.checkedValues.indexOf(_vm.value) !== -1 || _vm.checked
          },
          on: {
            "change": function change($event) {
              _vm.updated($event.target.value, 'change');
            }
          }
        }), _vm._v(" "), _vm._t("default", [_vm._v(_vm._s(_vm.label))]), _vm._v(" "), _vm._t("feedback", [_vm.validFeedback ? _c('form-feedback', {
          attrs: {
            "valid": ""
          },
          domProps: {
            "innerHTML": _vm._s(_vm.validFeedback)
          }
        }) : _vm._e(), _vm._v(" "), _vm.invalidFeedback ? _c('form-feedback', {
          attrs: {
            "invalid": ""
          },
          domProps: {
            "innerHTML": _vm._s(_vm.invalidFeedback)
          }
        }) : _vm._e()])], 2)], _vm._v(" "), _vm._t("help", [_vm.helpText ? _c('help-text', {
          domProps: {
            "innerHTML": _vm._s(_vm.helpText)
          }
        }) : _vm._e()])], 2);
      },
      staticRenderFns: [],
      name: 'checkbox-field',
      extends: RadioField,
      model: {
        event: 'change',
        prop: 'checkedValues'
      },
      props: {
        /**
         * The checked values
         *
         * @property String
         */
        checkedValues: {
          type: Array,
          default: function _default() {
            return [];
          }
        }
      },
      methods: {
        updated: function updated(value) {
          var checked = this.checkedValues.slice(0);
          var index = this.checkedValues.indexOf(value);

          if (index === -1) {
            checked.push(value);
          } else {
            checked.splice(index, 1);
          }

          this.$emit('change', checked);
        }
      }
    };

    var plugin$21 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          CheckboxField: CheckboxField
        });
      }
    });

    var Dropzone = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "dropzone",
          class: {
            'is-dragging': _vm.isDragging
          },
          on: {
            "drop": function drop($event) {
              $event.preventDefault();
              return _vm.onDrop($event);
            },
            "dragover": function dragover($event) {
              $event.preventDefault();
              return _vm.onDragover($event);
            },
            "dragenter": function dragenter($event) {
              $event.preventDefault();
              return _vm.onDragenter($event);
            },
            "dragleave": function dragleave($event) {
              $event.preventDefault();
              return _vm.onDragleave($event);
            }
          }
        }, [_vm._t("placeholder", [_c('div', {
          staticClass: "dropzone-placeholder text-center"
        }, [_c('card', [_c('card-body', [_c('h1', {
          staticClass: "mt-4"
        }, [_vm._v("Drag & Drop")]), _vm._v(" "), _c('p', [_vm._v("Drag and drop your files here to upload them!")]), _vm._v(" "), _c('div', {
          staticClass: "mt-3 mb-4"
        }, [_c('i', {
          staticClass: "fa fa-image"
        })])])], 1)], 1)]), _vm._v(" "), _vm._t("default")], 2);
      },
      staticRenderFns: [],
      _scopeId: 'data-v-744e8f62',
      name: 'dropzone',
      components: {
        Card: Card,
        CardBody: CardBody
      },
      methods: {
        onDrop: function onDrop(event) {
          this.isDragging = false;
          this.$emit('drop', event, this);
        },
        onDragover: function onDragover(event) {
          this.isDragging = true;
          this.$emit('dragover', event, this);
        },
        onDragenter: function onDragenter(event) {
          this.isDragging = true;
          this.$emit('dragenter', event, this);
          this.onDragover(event);
        },
        onDragleave: function onDragleave(event) {
          this.isDragging = false;
          this.$emit('dragleave', event, this);
        }
      },
      data: function data() {
        return {
          files: null,
          isDragging: false
        };
      }
    };

    var plugin$22 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          Dropzone: Dropzone
        });
      }
    });

    var plugin$23 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          FileField: FileField
        });
      }
    });

    function readFile(file, progress) {
      return new Promise(function (resolve, reject) {
        var reader = new FileReader();

        reader.onload = function (e) {
          return resolve(e);
        };

        reader.onerror = function (e) {
          return reject(e);
        };

        reader.onabort = function (e) {
          return reject(e);
        };

        reader.onprogress = function (e) {
          return progress(e, reader);
        };

        reader.readAsDataURL(file);
      });
    }

    var FilePreview = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "file-preview",
          class: {
            'is-image': _vm.isImage
          }
        }, [_c('div', {
          staticClass: "file-preview-inner"
        }, [!_vm.hideClose && (!_vm.isImage || _vm.image) ? _c('a', {
          staticClass: "file-preview-close",
          attrs: {
            "href": "#"
          },
          on: {
            "click": function click($event) {
              $event.preventDefault();

              _vm.$emit('close', _vm.file);
            }
          }
        }, [_c('i', {
          staticClass: "fa fa-times-circle"
        })]) : _vm._e(), _vm._v(" "), _vm.isImage ? _c('div', {
          staticClass: "file-preview-image"
        }, [_vm.image ? _c('img', {
          staticClass: "file-preview-thumbnail",
          attrs: {
            "src": _vm.image
          }
        }) : _c('progress-bar', {
          directives: [{
            name: "ready",
            rawName: "v-ready",
            value: _vm.readFile,
            expression: "readFile"
          }],
          attrs: {
            "value": _vm.loaded,
            "height": 10
          }
        })], 1) : _c('div', {
          staticClass: "file-preview-icon"
        }, [_c('i', {
          staticClass: "fa fa-file-o"
        })]), _vm._v(" "), _c('div', {
          staticClass: "file-preview-filename",
          domProps: {
            "innerHTML": _vm._s(_vm.name)
          }
        }), _vm._v(" "), _c('div', {
          staticClass: "file-preview-filesize"
        }, [_vm._v("(" + _vm._s(_vm.size) + ")")]), _vm._v(" "), _c('div')])]);
      },
      staticRenderFns: [],
      name: 'file-preview',
      components: {
        ProgressBar: ProgressBar
      },
      directives: {
        ready: {
          inserted: function inserted(el, binding) {
            setTimeout(function () {
              if (isFunction$1(binding.value)) {
                binding.value();
              }
            }, 50);
          }
        }
      },
      props: {
        /**
         * Hide the close button for the preview
         *
         * @property Object
         */
        hideClose: Boolean,

        /**
         * The uploaded File object
         *
         * @property Object
         */
        file: {
          type: [Object, File],
          required: true
        },

        /**
         * An array of mime types that should be used to determine if the
         * file is an image.
         *
         * @property Array
         */
        imageMimes: {
          type: Array,
          default: function _default() {
            return ['image/gif', 'image/png', 'image/jpeg', 'image/bmp', 'image/webp'];
          }
        }
      },
      computed: {
        /**
         * Get the file name
         *
         * @property String
         */
        name: function name() {
          return this.file instanceof File ? this.file.name : this.file.orig_filename;
        },

        /**
         * Get the file extension
         *
         * @property String
         */
        extension: function extension() {
          return this.file instanceof File ? this.file.name.split('.').pop().toLowerCase() : this.file.extension;
        },

        /**
         * Get the file formatted size
         *
         * @property String
         */
        size: function size() {
          return this.bytesToSize(this.file instanceof File ? this.file.size : this.file.bytes);
        },

        /**
         * Get the file type
         *
         * @property String
         */
        type: function type() {
          return this.file instanceof File ? this.file.type : this.file.mime;
        },

        /**
         * If the file an image?
         *
         * @property String
         */
        isImage: function isImage() {
          return this.imageMimes.indexOf(this.type) !== -1;
        },

        /**
         * Get the last time the file was modified (as timestamp)
         *
         * @property String
         */
        lastModified: function lastModified() {
          return this.file instanceof File ? this.file.lastModified : null;
        },

        /**
         * Get the last time the file was modified (as Date)
         *
         * @property String
         */
        lastModifiedDate: function lastModifiedDate() {
          return this.file instanceof File ? this.file.lastModifiedDate : null;
        }
      },
      methods: {
        readFile: function readFile$$1() {
          var _this = this;

          if (this.file instanceof File) {
            var start = moment();

            readFile(this.file, function (e) {
              if (e.lengthComputable) {
                _this.loaded = parseInt(e.loaded / e.total * 100, 10);
              }
            }).then(function (event) {
              setTimeout(function () {
                _this.image = event.target.result;

                _this.$emit('loaded', event, _this);
              }, 600 - moment().diff(start));
            }, function (error) {
              _this.$emit('error', error);
            });
          }
        },
        bytesToSize: function bytesToSize(bytes) {
          var sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
          if (bytes == 0) return '0 Byte';
          var i = parseInt(Math.floor(Math.log(bytes) / Math.log(1024)));
          return Math.round(bytes / Math.pow(1024, i), 2) + ' ' + sizes[i];
        }
      },
      data: function data() {
        return {
          loaded: 0,
          image: this.file.url
        };
      }
    };

    var plugin$24 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          FilePreview: FilePreview
        });
      }
    });

    var FormControl$1 = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c(!_vm.select ? 'input' : 'select', {
          directives: [{
            name: "bind-events",
            rawName: "v-bind-events",
            value: _vm.bindEvents,
            expression: "bindEvents"
          }],
          tag: "component",
          class: _vm.$mergeClasses(_vm.controlClasses, _vm.colorableClasses),
          attrs: {
            "name": _vm.name,
            "id": _vm.id,
            "type": !_vm.select ? _vm.type : false,
            "value": _vm.value,
            "pattern": _vm.pattern,
            "required": _vm.required,
            "readonly": _vm.readonly,
            "placeholder": _vm.placeholder,
            "disabled": _vm.disabled || _vm.readonly,
            "aria-label": _vm.label,
            "aria-describedby": _vm.id
          },
          on: {
            "input": _vm.updated
          }
        });
      },
      staticRenderFns: [],
      name: 'form-control',
      mixins: [Colorable, FormControl],
      props: {
        /**
         * Is the element a select?
         *
         * @property String
         */
        select: Boolean,

        /**
         * The type attribute
         *
         * @property String
         */
        type: {
          type: String,
          default: 'text'
        }
      }
    };

    var plugin$25 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          FormControl: FormControl$1
        });
      }
    });

    /**
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the W3C SOFTWARE AND DOCUMENT NOTICE AND LICENSE.
     *
     *  https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
     *
     */

    (function(window, document) {


    // Exits early if all IntersectionObserver and IntersectionObserverEntry
    // features are natively supported.
    if ('IntersectionObserver' in window &&
        'IntersectionObserverEntry' in window &&
        'intersectionRatio' in window.IntersectionObserverEntry.prototype) {

      // Minimal polyfill for Edge 15's lack of `isIntersecting`
      // See: https://github.com/w3c/IntersectionObserver/issues/211
      if (!('isIntersecting' in window.IntersectionObserverEntry.prototype)) {
        Object.defineProperty(window.IntersectionObserverEntry.prototype,
          'isIntersecting', {
          get: function () {
            return this.intersectionRatio > 0;
          }
        });
      }
      return;
    }


    /**
     * Creates the global IntersectionObserverEntry constructor.
     * https://w3c.github.io/IntersectionObserver/#intersection-observer-entry
     * @param {Object} entry A dictionary of instance properties.
     * @constructor
     */
    function IntersectionObserverEntry(entry) {
      this.time = entry.time;
      this.target = entry.target;
      this.rootBounds = entry.rootBounds;
      this.boundingClientRect = entry.boundingClientRect;
      this.intersectionRect = entry.intersectionRect || getEmptyRect();
      this.isIntersecting = !!entry.intersectionRect;

      // Calculates the intersection ratio.
      var targetRect = this.boundingClientRect;
      var targetArea = targetRect.width * targetRect.height;
      var intersectionRect = this.intersectionRect;
      var intersectionArea = intersectionRect.width * intersectionRect.height;

      // Sets intersection ratio.
      if (targetArea) {
        this.intersectionRatio = intersectionArea / targetArea;
      } else {
        // If area is zero and is intersecting, sets to 1, otherwise to 0
        this.intersectionRatio = this.isIntersecting ? 1 : 0;
      }
    }


    /**
     * Creates the global IntersectionObserver constructor.
     * https://w3c.github.io/IntersectionObserver/#intersection-observer-interface
     * @param {Function} callback The function to be invoked after intersection
     *     changes have queued. The function is not invoked if the queue has
     *     been emptied by calling the `takeRecords` method.
     * @param {Object=} opt_options Optional configuration options.
     * @constructor
     */
    function IntersectionObserver(callback, opt_options) {

      var options = opt_options || {};

      if (typeof callback != 'function') {
        throw new Error('callback must be a function');
      }

      if (options.root && options.root.nodeType != 1) {
        throw new Error('root must be an Element');
      }

      // Binds and throttles `this._checkForIntersections`.
      this._checkForIntersections = throttle(
          this._checkForIntersections.bind(this), this.THROTTLE_TIMEOUT);

      // Private properties.
      this._callback = callback;
      this._observationTargets = [];
      this._queuedEntries = [];
      this._rootMarginValues = this._parseRootMargin(options.rootMargin);

      // Public properties.
      this.thresholds = this._initThresholds(options.threshold);
      this.root = options.root || null;
      this.rootMargin = this._rootMarginValues.map(function(margin) {
        return margin.value + margin.unit;
      }).join(' ');
    }


    /**
     * The minimum interval within which the document will be checked for
     * intersection changes.
     */
    IntersectionObserver.prototype.THROTTLE_TIMEOUT = 100;


    /**
     * The frequency in which the polyfill polls for intersection changes.
     * this can be updated on a per instance basis and must be set prior to
     * calling `observe` on the first target.
     */
    IntersectionObserver.prototype.POLL_INTERVAL = null;

    /**
     * Use a mutation observer on the root element
     * to detect intersection changes.
     */
    IntersectionObserver.prototype.USE_MUTATION_OBSERVER = true;


    /**
     * Starts observing a target element for intersection changes based on
     * the thresholds values.
     * @param {Element} target The DOM element to observe.
     */
    IntersectionObserver.prototype.observe = function(target) {
      var isTargetAlreadyObserved = this._observationTargets.some(function(item) {
        return item.element == target;
      });

      if (isTargetAlreadyObserved) {
        return;
      }

      if (!(target && target.nodeType == 1)) {
        throw new Error('target must be an Element');
      }

      this._registerInstance();
      this._observationTargets.push({element: target, entry: null});
      this._monitorIntersections();
      this._checkForIntersections();
    };


    /**
     * Stops observing a target element for intersection changes.
     * @param {Element} target The DOM element to observe.
     */
    IntersectionObserver.prototype.unobserve = function(target) {
      this._observationTargets =
          this._observationTargets.filter(function(item) {

        return item.element != target;
      });
      if (!this._observationTargets.length) {
        this._unmonitorIntersections();
        this._unregisterInstance();
      }
    };


    /**
     * Stops observing all target elements for intersection changes.
     */
    IntersectionObserver.prototype.disconnect = function() {
      this._observationTargets = [];
      this._unmonitorIntersections();
      this._unregisterInstance();
    };


    /**
     * Returns any queue entries that have not yet been reported to the
     * callback and clears the queue. This can be used in conjunction with the
     * callback to obtain the absolute most up-to-date intersection information.
     * @return {Array} The currently queued entries.
     */
    IntersectionObserver.prototype.takeRecords = function() {
      var records = this._queuedEntries.slice();
      this._queuedEntries = [];
      return records;
    };


    /**
     * Accepts the threshold value from the user configuration object and
     * returns a sorted array of unique threshold values. If a value is not
     * between 0 and 1 and error is thrown.
     * @private
     * @param {Array|number=} opt_threshold An optional threshold value or
     *     a list of threshold values, defaulting to [0].
     * @return {Array} A sorted list of unique and valid threshold values.
     */
    IntersectionObserver.prototype._initThresholds = function(opt_threshold) {
      var threshold = opt_threshold || [0];
      if (!Array.isArray(threshold)) threshold = [threshold];

      return threshold.sort().filter(function(t, i, a) {
        if (typeof t != 'number' || isNaN(t) || t < 0 || t > 1) {
          throw new Error('threshold must be a number between 0 and 1 inclusively');
        }
        return t !== a[i - 1];
      });
    };


    /**
     * Accepts the rootMargin value from the user configuration object
     * and returns an array of the four margin values as an object containing
     * the value and unit properties. If any of the values are not properly
     * formatted or use a unit other than px or %, and error is thrown.
     * @private
     * @param {string=} opt_rootMargin An optional rootMargin value,
     *     defaulting to '0px'.
     * @return {Array<Object>} An array of margin objects with the keys
     *     value and unit.
     */
    IntersectionObserver.prototype._parseRootMargin = function(opt_rootMargin) {
      var marginString = opt_rootMargin || '0px';
      var margins = marginString.split(/\s+/).map(function(margin) {
        var parts = /^(-?\d*\.?\d+)(px|%)$/.exec(margin);
        if (!parts) {
          throw new Error('rootMargin must be specified in pixels or percent');
        }
        return {value: parseFloat(parts[1]), unit: parts[2]};
      });

      // Handles shorthand.
      margins[1] = margins[1] || margins[0];
      margins[2] = margins[2] || margins[0];
      margins[3] = margins[3] || margins[1];

      return margins;
    };


    /**
     * Starts polling for intersection changes if the polling is not already
     * happening, and if the page's visibilty state is visible.
     * @private
     */
    IntersectionObserver.prototype._monitorIntersections = function() {
      if (!this._monitoringIntersections) {
        this._monitoringIntersections = true;

        // If a poll interval is set, use polling instead of listening to
        // resize and scroll events or DOM mutations.
        if (this.POLL_INTERVAL) {
          this._monitoringInterval = setInterval(
              this._checkForIntersections, this.POLL_INTERVAL);
        }
        else {
          addEvent(window, 'resize', this._checkForIntersections, true);
          addEvent(document, 'scroll', this._checkForIntersections, true);

          if (this.USE_MUTATION_OBSERVER && 'MutationObserver' in window) {
            this._domObserver = new MutationObserver(this._checkForIntersections);
            this._domObserver.observe(document, {
              attributes: true,
              childList: true,
              characterData: true,
              subtree: true
            });
          }
        }
      }
    };


    /**
     * Stops polling for intersection changes.
     * @private
     */
    IntersectionObserver.prototype._unmonitorIntersections = function() {
      if (this._monitoringIntersections) {
        this._monitoringIntersections = false;

        clearInterval(this._monitoringInterval);
        this._monitoringInterval = null;

        removeEvent(window, 'resize', this._checkForIntersections, true);
        removeEvent(document, 'scroll', this._checkForIntersections, true);

        if (this._domObserver) {
          this._domObserver.disconnect();
          this._domObserver = null;
        }
      }
    };


    /**
     * Scans each observation target for intersection changes and adds them
     * to the internal entries queue. If new entries are found, it
     * schedules the callback to be invoked.
     * @private
     */
    IntersectionObserver.prototype._checkForIntersections = function() {
      var rootIsInDom = this._rootIsInDom();
      var rootRect = rootIsInDom ? this._getRootRect() : getEmptyRect();

      this._observationTargets.forEach(function(item) {
        var target = item.element;
        var targetRect = getBoundingClientRect(target);
        var rootContainsTarget = this._rootContainsTarget(target);
        var oldEntry = item.entry;
        var intersectionRect = rootIsInDom && rootContainsTarget &&
            this._computeTargetAndRootIntersection(target, rootRect);

        var newEntry = item.entry = new IntersectionObserverEntry({
          time: now(),
          target: target,
          boundingClientRect: targetRect,
          rootBounds: rootRect,
          intersectionRect: intersectionRect
        });

        if (!oldEntry) {
          this._queuedEntries.push(newEntry);
        } else if (rootIsInDom && rootContainsTarget) {
          // If the new entry intersection ratio has crossed any of the
          // thresholds, add a new entry.
          if (this._hasCrossedThreshold(oldEntry, newEntry)) {
            this._queuedEntries.push(newEntry);
          }
        } else {
          // If the root is not in the DOM or target is not contained within
          // root but the previous entry for this target had an intersection,
          // add a new record indicating removal.
          if (oldEntry && oldEntry.isIntersecting) {
            this._queuedEntries.push(newEntry);
          }
        }
      }, this);

      if (this._queuedEntries.length) {
        this._callback(this.takeRecords(), this);
      }
    };


    /**
     * Accepts a target and root rect computes the intersection between then
     * following the algorithm in the spec.
     * TODO(philipwalton): at this time clip-path is not considered.
     * https://w3c.github.io/IntersectionObserver/#calculate-intersection-rect-algo
     * @param {Element} target The target DOM element
     * @param {Object} rootRect The bounding rect of the root after being
     *     expanded by the rootMargin value.
     * @return {?Object} The final intersection rect object or undefined if no
     *     intersection is found.
     * @private
     */
    IntersectionObserver.prototype._computeTargetAndRootIntersection =
        function(target, rootRect) {

      // If the element isn't displayed, an intersection can't happen.
      if (window.getComputedStyle(target).display == 'none') return;

      var targetRect = getBoundingClientRect(target);
      var intersectionRect = targetRect;
      var parent = getParentNode(target);
      var atRoot = false;

      while (!atRoot) {
        var parentRect = null;
        var parentComputedStyle = parent.nodeType == 1 ?
            window.getComputedStyle(parent) : {};

        // If the parent isn't displayed, an intersection can't happen.
        if (parentComputedStyle.display == 'none') return;

        if (parent == this.root || parent == document) {
          atRoot = true;
          parentRect = rootRect;
        } else {
          // If the element has a non-visible overflow, and it's not the <body>
          // or <html> element, update the intersection rect.
          // Note: <body> and <html> cannot be clipped to a rect that's not also
          // the document rect, so no need to compute a new intersection.
          if (parent != document.body &&
              parent != document.documentElement &&
              parentComputedStyle.overflow != 'visible') {
            parentRect = getBoundingClientRect(parent);
          }
        }

        // If either of the above conditionals set a new parentRect,
        // calculate new intersection data.
        if (parentRect) {
          intersectionRect = computeRectIntersection(parentRect, intersectionRect);

          if (!intersectionRect) break;
        }
        parent = getParentNode(parent);
      }
      return intersectionRect;
    };


    /**
     * Returns the root rect after being expanded by the rootMargin value.
     * @return {Object} The expanded root rect.
     * @private
     */
    IntersectionObserver.prototype._getRootRect = function() {
      var rootRect;
      if (this.root) {
        rootRect = getBoundingClientRect(this.root);
      } else {
        // Use <html>/<body> instead of window since scroll bars affect size.
        var html = document.documentElement;
        var body = document.body;
        rootRect = {
          top: 0,
          left: 0,
          right: html.clientWidth || body.clientWidth,
          width: html.clientWidth || body.clientWidth,
          bottom: html.clientHeight || body.clientHeight,
          height: html.clientHeight || body.clientHeight
        };
      }
      return this._expandRectByRootMargin(rootRect);
    };


    /**
     * Accepts a rect and expands it by the rootMargin value.
     * @param {Object} rect The rect object to expand.
     * @return {Object} The expanded rect.
     * @private
     */
    IntersectionObserver.prototype._expandRectByRootMargin = function(rect) {
      var margins = this._rootMarginValues.map(function(margin, i) {
        return margin.unit == 'px' ? margin.value :
            margin.value * (i % 2 ? rect.width : rect.height) / 100;
      });
      var newRect = {
        top: rect.top - margins[0],
        right: rect.right + margins[1],
        bottom: rect.bottom + margins[2],
        left: rect.left - margins[3]
      };
      newRect.width = newRect.right - newRect.left;
      newRect.height = newRect.bottom - newRect.top;

      return newRect;
    };


    /**
     * Accepts an old and new entry and returns true if at least one of the
     * threshold values has been crossed.
     * @param {?IntersectionObserverEntry} oldEntry The previous entry for a
     *    particular target element or null if no previous entry exists.
     * @param {IntersectionObserverEntry} newEntry The current entry for a
     *    particular target element.
     * @return {boolean} Returns true if a any threshold has been crossed.
     * @private
     */
    IntersectionObserver.prototype._hasCrossedThreshold =
        function(oldEntry, newEntry) {

      // To make comparing easier, an entry that has a ratio of 0
      // but does not actually intersect is given a value of -1
      var oldRatio = oldEntry && oldEntry.isIntersecting ?
          oldEntry.intersectionRatio || 0 : -1;
      var newRatio = newEntry.isIntersecting ?
          newEntry.intersectionRatio || 0 : -1;

      // Ignore unchanged ratios
      if (oldRatio === newRatio) return;

      for (var i = 0; i < this.thresholds.length; i++) {
        var threshold = this.thresholds[i];

        // Return true if an entry matches a threshold or if the new ratio
        // and the old ratio are on the opposite sides of a threshold.
        if (threshold == oldRatio || threshold == newRatio ||
            threshold < oldRatio !== threshold < newRatio) {
          return true;
        }
      }
    };


    /**
     * Returns whether or not the root element is an element and is in the DOM.
     * @return {boolean} True if the root element is an element and is in the DOM.
     * @private
     */
    IntersectionObserver.prototype._rootIsInDom = function() {
      return !this.root || containsDeep(document, this.root);
    };


    /**
     * Returns whether or not the target element is a child of root.
     * @param {Element} target The target element to check.
     * @return {boolean} True if the target element is a child of root.
     * @private
     */
    IntersectionObserver.prototype._rootContainsTarget = function(target) {
      return containsDeep(this.root || document, target);
    };


    /**
     * Adds the instance to the global IntersectionObserver registry if it isn't
     * already present.
     * @private
     */
    IntersectionObserver.prototype._registerInstance = function() {
    };


    /**
     * Removes the instance from the global IntersectionObserver registry.
     * @private
     */
    IntersectionObserver.prototype._unregisterInstance = function() {
    };


    /**
     * Returns the result of the performance.now() method or null in browsers
     * that don't support the API.
     * @return {number} The elapsed time since the page was requested.
     */
    function now() {
      return window.performance && performance.now && performance.now();
    }


    /**
     * Throttles a function and delays its executiong, so it's only called at most
     * once within a given time period.
     * @param {Function} fn The function to throttle.
     * @param {number} timeout The amount of time that must pass before the
     *     function can be called again.
     * @return {Function} The throttled function.
     */
    function throttle(fn, timeout) {
      var timer = null;
      return function () {
        if (!timer) {
          timer = setTimeout(function() {
            fn();
            timer = null;
          }, timeout);
        }
      };
    }


    /**
     * Adds an event handler to a DOM node ensuring cross-browser compatibility.
     * @param {Node} node The DOM node to add the event handler to.
     * @param {string} event The event name.
     * @param {Function} fn The event handler to add.
     * @param {boolean} opt_useCapture Optionally adds the even to the capture
     *     phase. Note: this only works in modern browsers.
     */
    function addEvent(node, event, fn, opt_useCapture) {
      if (typeof node.addEventListener == 'function') {
        node.addEventListener(event, fn, opt_useCapture || false);
      }
      else if (typeof node.attachEvent == 'function') {
        node.attachEvent('on' + event, fn);
      }
    }


    /**
     * Removes a previously added event handler from a DOM node.
     * @param {Node} node The DOM node to remove the event handler from.
     * @param {string} event The event name.
     * @param {Function} fn The event handler to remove.
     * @param {boolean} opt_useCapture If the event handler was added with this
     *     flag set to true, it should be set to true here in order to remove it.
     */
    function removeEvent(node, event, fn, opt_useCapture) {
      if (typeof node.removeEventListener == 'function') {
        node.removeEventListener(event, fn, opt_useCapture || false);
      }
      else if (typeof node.detatchEvent == 'function') {
        node.detatchEvent('on' + event, fn);
      }
    }


    /**
     * Returns the intersection between two rect objects.
     * @param {Object} rect1 The first rect.
     * @param {Object} rect2 The second rect.
     * @return {?Object} The intersection rect or undefined if no intersection
     *     is found.
     */
    function computeRectIntersection(rect1, rect2) {
      var top = Math.max(rect1.top, rect2.top);
      var bottom = Math.min(rect1.bottom, rect2.bottom);
      var left = Math.max(rect1.left, rect2.left);
      var right = Math.min(rect1.right, rect2.right);
      var width = right - left;
      var height = bottom - top;

      return (width >= 0 && height >= 0) && {
        top: top,
        bottom: bottom,
        left: left,
        right: right,
        width: width,
        height: height
      };
    }


    /**
     * Shims the native getBoundingClientRect for compatibility with older IE.
     * @param {Element} el The element whose bounding rect to get.
     * @return {Object} The (possibly shimmed) rect of the element.
     */
    function getBoundingClientRect(el) {
      var rect;

      try {
        rect = el.getBoundingClientRect();
      } catch (err) {
        // Ignore Windows 7 IE11 "Unspecified error"
        // https://github.com/w3c/IntersectionObserver/pull/205
      }

      if (!rect) return getEmptyRect();

      // Older IE
      if (!(rect.width && rect.height)) {
        rect = {
          top: rect.top,
          right: rect.right,
          bottom: rect.bottom,
          left: rect.left,
          width: rect.right - rect.left,
          height: rect.bottom - rect.top
        };
      }
      return rect;
    }


    /**
     * Returns an empty rect object. An empty rect is returned when an element
     * is not in the DOM.
     * @return {Object} The empty rect.
     */
    function getEmptyRect() {
      return {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0,
        width: 0,
        height: 0
      };
    }

    /**
     * Checks to see if a parent element contains a child elemnt (including inside
     * shadow DOM).
     * @param {Node} parent The parent element.
     * @param {Node} child The child element.
     * @return {boolean} True if the parent node contains the child node.
     */
    function containsDeep(parent, child) {
      var node = child;
      while (node) {
        if (node == parent) return true;

        node = getParentNode(node);
      }
      return false;
    }


    /**
     * Gets the parent node of an element or its host element if the parent node
     * is a shadow root.
     * @param {Node} node The node whose parent to get.
     * @return {Node|null} The parent node or null if no parent exists.
     */
    function getParentNode(node) {
      var parent = node.parentNode;

      if (parent && parent.nodeType == 11 && parent.host) {
        // If the parent is a shadow root, return the host element.
        return parent.host;
      }
      return parent;
    }


    // Exposes the constructors globally.
    window.IntersectionObserver = IntersectionObserver;
    window.IntersectionObserverEntry = IntersectionObserverEntry;

    }(window, document));

    var InfiniteScrolling = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "infinite-scrolling",
          style: {
            height: _vm.heightUnit,
            background: _vm.background
          }
        }, [_vm.activity ? _c('activity-indicator', {
          attrs: {
            "size": _vm.size,
            "type": _vm.type,
            "center": ""
          }
        }) : _vm._e()], 1);
      },
      staticRenderFns: [],
      name: 'infinite-scrolling',
      components: {
        ActivityIndicator: ActivityIndicator
      },
      props: {
        /**
         * Is the activity indicator showing
         *
         * @property String
         */
        activity: Boolean,

        /**
         * The activity indicator background style
         *
         * @property String
         */
        background: String,

        /**
         * The activity indicator size
         *
         * @property String
         */
        height: {
          type: Number,
          default: 100
        },

        /**
         * The activity indicator size
         *
         * @property String
         */
        size: String,

        /**
         * The activity indicator type
         *
         * @property String
         */
        type: String,

        /**
         * The scroll observer threshold for when an element is considered
         * into view. Must be a validate between 0 and 1, and is a percentage.
         *
         * @property Number
         */
        threshold: {
          type: Number,
          default: .75,
          validate: function validate(value) {
            return value >= 0 && value <= 1;
          }
        }
      },
      methods: {
        scrollIntoViewport: function scrollIntoViewport(entry) {
          this.$emit('scroll:in', entry);

          if (!this.activity) {
            this.$emit('load', entry);
          }
        },
        scrollOutViewport: function scrollOutViewport(entry) {
          this.$emit('scroll:out', entry);
        }
      },
      computed: {
        heightUnit: function heightUnit() {
          return unit(this.height);
        }
      },
      mounted: function mounted() {
        var _this = this;

        this.$nextTick(function () {
          new IntersectionObserver(function (entries, observer) {
            entries.forEach(function (entry) {
              if (entry.isIntersecting && !_this.hasScrolledIntoViewport) {
                _this.scrollIntoViewport(entry, observer);

                _this.hasScrolledIntoViewport = true;
              } else if (_this.hasScrolledIntoViewport) {
                _this.scrollOutViewport(entry, observer);

                _this.hasScrolledIntoViewport = false;
              }
            });
          }, {
            threshold: _this.threshold
          }).observe(_this.$el);
        });
      },
      data: function data() {
        return {
          hasScrolledIntoViewport: false
        };
      }
    };

    var InputGroupText = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('span', {
          staticClass: "input-group-text",
          attrs: {
            "id": _vm.id
          }
        }, [_vm._t("default", [_vm._v(_vm._s(_vm.text))])], 2);
      },
      staticRenderFns: [],
      name: 'input-group-text',
      props: {
        /**
         * The id attribute
         *
         * @property String
         */
        id: String,

        /**
         * The type attribute
         *
         * @property String
         */
        text: [Array, Number, String]
      }
    };

    var InputGroupAppend = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "input-group-append"
        }, [_vm.text ? _c('input-group-text', [_vm._t("default")], 2) : _vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'input-group-append',
      props: {
        /**
         * The type attribute
         *
         * @property String
         */
        text: Boolean
      }
    };

    var InputGroupPrepend = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "input-group-prepend"
        }, [_vm.text ? _c('input-group-text', [_vm._t("default")], 2) : _vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'input-group-prepend',
      props: {
        /**
         * The type attribute
         *
         * @property String
         */
        text: Boolean
      }
    };

    var InputGroup = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "input-group",
          class: _vm.$mergeClasses(_vm.colorableClasses, _vm.sizeableClass)
        }, [_vm._t("prepend", [_vm.prepend instanceof Array ? [_c('input-group-prepend', _vm._l(_vm.prepend, function (value) {
          return _c('input-group-text', {
            attrs: {
              "text": value
            }
          });
        }))] : _vm.prepend ? [_c('input-group-prepend', {
          attrs: {
            "text": ""
          }
        }, [_vm._v(_vm._s(_vm.prepend))])] : _vm._e()]), _vm._v(" "), _vm._t("default"), _vm._v(" "), _vm._t("append", [_vm.append instanceof Array ? [_c('input-group-append', _vm._l(_vm.append, function (value) {
          return _c('input-group-text', {
            attrs: {
              "text": value
            }
          });
        }))] : _vm.append ? [_c('input-group-append', {
          attrs: {
            "text": ""
          }
        }, [_vm._v(_vm._s(_vm.append))])] : _vm._e()])], 2);
      },
      staticRenderFns: [],
      name: 'input-group',
      components: {
        InputGroupText: InputGroupText,
        InputGroupAppend: InputGroupAppend,
        InputGroupPrepend: InputGroupPrepend
      },
      mixins: [HasSlots, Sizeable, Colorable],
      props: {
        append: [Array, Number, String],
        prepend: [Array, Number, String]
      }
    };

    var plugin$26 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          InputGroup: InputGroup,
          InputGroupAppend: InputGroupAppend,
          InputGroupPrepend: InputGroupPrepend,
          InputGroupText: InputGroupText
        });
      }
    });

    var LightSwitchField = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('form-group', [_vm._t("label", [_vm.label ? _c('form-label', {
          attrs: {
            "for": _vm.id
          },
          domProps: {
            "innerHTML": _vm._s(_vm.label)
          }
        }) : _vm._e()]), _vm._v(" "), _c('div', {
          class: _vm.controlClasses,
          attrs: {
            "tabindex": "0"
          },
          on: {
            "click": function click($event) {
              _vm.toggle();
            },
            "keyup": [function ($event) {
              if (!('button' in $event) && $event.keyCode !== 32) {
                return null;
              }

              _vm.toggle();
            }, function ($event) {
              if (!('button' in $event) && $event.keyCode !== 37) {
                return null;
              }

              _vm.toggle(_vm.offValue);
            }, function ($event) {
              if (!('button' in $event) && $event.keyCode !== 39) {
                return null;
              }

              _vm.toggle(_vm.onValue);
            }]
          }
        }, [_c('div', {
          staticClass: "light-switch-handle"
        }), _vm._v(" "), _c('div', {
          staticClass: "light-switch-container"
        }, [_c('div', {
          staticClass: "light-switch-label on-value"
        }), _vm._v(" "), _c('div', {
          staticClass: "light-switch-label off-value"
        })])]), _vm._v(" "), _c('form-control', {
          staticClass: "d-none",
          attrs: {
            "name": _vm.name,
            "value": _vm.value,
            "id": _vm.id
          }
        }), _vm._v(" "), _vm._t("feedback", [_vm.validFeedback ? _c('form-feedback', {
          attrs: {
            "valid": ""
          },
          domProps: {
            "innerHTML": _vm._s(_vm.validFeedback)
          }
        }) : _vm._e(), _vm._v(" "), _vm.invalidFeedback ? _c('form-feedback', {
          attrs: {
            "invalid": ""
          },
          domProps: {
            "innerHTML": _vm._s(_vm.invalidFeedback)
          }
        }) : _vm._e()]), _vm._v(" "), _vm._t("help", [_vm.helpText ? _c('help-text', {
          domProps: {
            "innerHTML": _vm._s(_vm.helpText)
          }
        }) : _vm._e()])], 2);
      },
      staticRenderFns: [],
      name: 'light-switch-field',
      components: {
        HelpText: HelpText,
        FormGroup: FormGroup,
        FormLabel: FormLabel,
        FormFeedback: FormFeedback
      },
      mixins: [FormControl],
      props: {
        /**
         * The class name assigned to the control element
         *
         * @property String
         */
        defaultControlClass: {
          type: String,
          default: 'form-control light-switch'
        },

        /**
         * The class name assigned to the control element
         *
         * @property String
         */
        activeClass: {
          type: String,
          default: 'on'
        },

        /**
         * The class name assigned to the control element
         *
         * @property String
         */
        onValue: {
          default: 1
        },

        /**
         * The class name assigned to the control element
         *
         * @property String
         */
        offValue: {
          default: 0
        }
      },
      computed: {
        isActive: function isActive() {
          return this.value === this.onValue;
        },
        controlClasses: function controlClasses() {
          return [this.controlClass, this.controlSizeClass, this.spacing || '', this.invalidFeedback ? 'is-invalid' : '', this.dragging ? 'is-dragging' : '', this.isActive ? 'is-active' : ''].join(' ');
        }
      },
      methods: {
        getTransitionInMilliseconds: function getTransitionInMilliseconds() {
          var duration = getComputedStyle(this.$el.querySelector('.light-switch-handle')).transitionDuration;
          var numeric = parseFloat(duration, 10);
          var unit = duration.match(/m?s/);

          switch (unit[0]) {
            case 's':
              return numeric * 1000;

            case 'ms':
              return numeric;
          }

          throw new Error("\"".concat(unit[0], "\" is not a valid unit of measure. Unit must be \"s\" (seconds) or \"ms\" (milliseconds)."));
        },
        toggle: function toggle(value) {
          this.$emit('input', !isUndefined(value) ? value : this.isActive ? this.offValue : this.onValue);
        }
      },
      watch: {
        value: function value() {
          var _this = this;

          this.dragging = true;
          setTimeout(function () {
            _this.dragging = false;
          }, this.getTransitionInMilliseconds());
        }
      },
      data: function data() {
        return {
          dragging: false
        };
      }
    };

    var plugin$27 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          LightSwitchField: LightSwitchField
        });
      }
    });

    var ListGroupItem = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _vm.to ? _c('router-link', {
          class: _vm.classes,
          attrs: {
            "to": _vm.to
          },
          on: {
            "click": _vm.onClick
          }
        }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))]), _vm._v(" "), _vm.badge ? _c('badge', _vm._b({}, 'badge', _vm.badgeOptions, false)) : _vm._e()], 2) : _vm.action ? _c('button', {
          class: _vm.classes,
          attrs: {
            "type": "button"
          },
          on: {
            "click": function click($event) {
              $event.preventDefault();
              return _vm.onClick($event);
            }
          }
        }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))]), _vm._v(" "), _vm.badge ? _c('badge', _vm._b({}, 'badge', _vm.badgeOptions, false)) : _vm._e()], 2) : _c('div', {
          class: _vm.classes,
          on: {
            "click": _vm.onClick
          }
        }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))]), _vm._v(" "), _vm.badge ? _c('badge', _vm._b({}, 'badge', _vm.badgeOptions, false)) : _vm._e()], 2);
      },
      staticRenderFns: [],
      components: {
        Badge: Badge
      },
      props: {
        /**
         * The badge label (if number or string) or object of options to pass to
         * the component.
         *
         * @property String|Object
         */
        badge: [Number, String, Object],

        /**
         * The list group item href attribute.
         *
         * @property String
         */
        href: String,

        /**
         * The list group item variant.
         *
         * @property String
         */
        variant: String,

        /**
         * Optionally pass the item as a object to use programmatically later.
         *
         * @property String
         */
        item: Object,

        /**
         * The list group item an action, or clickable item.
         *
         * @property Boolean
         */
        action: {
          type: Boolean,
          default: false
        },

        /**
         * The list group item active.
         *
         * @property Boolean
         */
        active: {
          type: Boolean,
          default: false
        },

        /**
         * The list group item disabled.
         *
         * @property Boolean
         */
        disabled: {
          type: Boolean,
          default: false
        },

        /**
         * The list item label.
         *
         * @property Object
         */
        label: {
          type: [Number, String],
          value: null
        },

        /**
         * The to attribute to be passed to a <router-link> component.
         *
         * @property String
         */
        to: [String, Object]
      },
      computed: {
        classes: function classes() {
          var classes = prefix({
            'action': this.action
          }, 'list-group-item');
          classes['list-group-item'] = true;
          classes['active'] = this.isActive;
          classes['disabled'] = this.isDisabled;

          if (this.variant) {
            classes[prefix(this.variant, 'list-group-item')] = true;
          }

          return classes;
        },
        badgeOptions: function badgeOptions() {
          return isObject(this.badge) ? this.badge : {
            label: this.badge
          };
        }
      },
      methods: {
        /**
         * Toggle the list item's active class.
         *
         * @return void
         */
        toggle: function toggle() {
          this.isActive = !this.isActive;
        },

        /**
         * Activate the list item.
         *
         * @return void
         */
        activate: function activate() {
          this.isActive = true;
        },

        /**
         * Deactivate the list item.
         *
         * @return void
         */
        deactivate: function deactivate() {
          this.isActive = false;
        },

        /**
         * Activate the list item.
         *
         * @return void
         */
        disable: function disable() {
          this.isDisabled = false;
        },

        /**
         * Deactivate the list item.
         *
         * @return void
         */
        enable: function enable() {
          this.isDisabled = false;
        },

        /**
         * The callback function for the `click` event.
         *
         * @return void
         */
        onClick: function onClick(event) {
          this.$emit('click', event, this);
        }
      },
      watch: {
        isActive: function isActive(value, prevValue) {
          this.$emit('update:active', this.isActive);
          this.$emit('toggle', this.isActive, this);
          this.$emit(value ? 'activate' : 'deactivate', this);
        }
      },
      data: function data() {
        return {
          isActive: this.active,
          isDisabled: this.disabled
        };
      }
    };

    var ListGroup = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "list-group",
          class: _vm.classes
        }, [_vm._t("default", _vm._l(_vm.items, function (item, key) {
          return _c('list-group-item', _vm._b({
            key: key
          }, 'list-group-item', item, false));
        }))], 2);
      },
      staticRenderFns: [],
      components: {
        ListGroupItem: ListGroupItem
      },
      props: {
        /**
         * An array of list item objects.
         *
         * [{label: 'Some Label', badge: 1}]
         *
         * @property Object
         */
        items: Array,

        /**
         * Can the list items be activated.
         *
         * @property Boolean
         */
        activateable: {
          type: Boolean,
          default: false
        },

        /**
         * The list group appear flush (without some borders).
         *
         * @property Boolean
         */
        flush: {
          type: Boolean,
          default: false
        },

        /**
         * Can activate multiple list items
         *
         * @property Boolean
         */
        multiple: {
          type: Boolean,
          default: false
        }
      },
      computed: {
        classes: function classes() {
          return prefix({
            'flush': this.flush
          }, 'list-group');
        }
      },
      methods: {
        bindEventsToChildren: function bindEventsToChildren() {
          var _this = this;

          forEach(this.$children, function (child) {
            child.$off('click', _this.onClickItem);
            child.$on('click', _this.onClickItem);
            child.$off('activate', _this.onActivate);
            child.$on('activate', _this.onActivate);
            child.$off('deactivate', _this.onDeactivate);
            child.$on('deactivate', _this.onDeactivate);
          });
        },
        onClickItem: function onClickItem(event, child) {
          if (this.activateable) {
            child.toggle();
          }

          this.$emit('item:click', event, child);
        },
        onActivate: function onActivate(item) {
          if (!this.multiple && this.activeItem !== item) {
            if (this.activeItem) {
              this.activeItem.deactivate();
            }

            this.activeItem = item;
          }

          this.$emit('item:activate', event, item);
        },
        onDeactivate: function onDeactivate(item) {
          if (!this.multiple && this.activeItem === item) {
            this.activeItem = null;
          }

          this.$emit('item:deactivate', event, item);
        }
      },
      data: function data() {
        return {
          activeItem: null
        };
      },
      mounted: function mounted() {
        this.bindEventsToChildren();
      },
      updated: function updated() {
        this.bindEventsToChildren();
      }
    };

    var plugin$28 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          ListGroup: ListGroup
        });
      }
    });

    var plugin$29 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          Modal: Modal
        });
      }
    });

    var NavbarBrand = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c(_vm.component, {
          tag: "component",
          staticClass: "navbar-brand",
          class: {
            'h1': _vm.h1
          },
          attrs: {
            "to": _vm.to,
            "href": _vm.href
          }
        }, [_vm.src ? _c('img', {
          staticClass: "d-inline-block align-center",
          attrs: {
            "src": _vm.src,
            "width": _vm.unit(_vm.width),
            "height": _vm.unit(_vm.height),
            "alt": _vm.alt
          }
        }) : _vm._e(), _vm._v(" "), _vm._t("default")], 2);
      },
      staticRenderFns: [],
      props: {
        /**
         * The img `alt` attribute. `src` must be define before this prop has
         * any affect.
         *
         * @property Object
         */
        alt: String,

        /**
         * The HTML wrapping tag.
         *
         * @property Object
         */
        tag: String,

        /**
         * The img `width` attribute. `src` must be define before this prop has
         * any affect.
         *
         * @property Object
         */
        width: [Number, String],

        /**
         * The img `height` attribute. `src` must be define before this prop has
         * any affect.
         *
         * @property Object
         */
        height: [Number, String],

        /**
         * The `to` attribute that is passed to the component.
         *
         * @property Object
         */
        to: [Object, String],

        /**
         * The `href` attribute that is passed to the component.
         *
         * @property Object
         */
        href: String,

        /**
         * Append the `h1` class to increase the display size
         *
         * @property Object
         */
        h1: Boolean,

        /**
         * If a `src` attribute is passed, then use it to add an img tag
         *
         * @property Object
         */
        src: String
      },
      computed: {
        component: function component() {
          return this.tag || (this.to ? 'router-link' : this.href ? 'a' : 'span');
        }
      },
      methods: {
        unit: function unit$$1(value) {
          return unit(value);
        }
      }
    };

    var NavbarCollapse = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "navbar-collapse",
          class: {
            'collapse': _vm.collapse
          },
          attrs: {
            "id": "navbarCollapse"
          }
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'navbar-collapse',
      props: {
        collapse: {
          type: Boolean,
          default: true
        }
      }
    };

    var NavbarText = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('span', {
          staticClass: "navbar-text"
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'navbar-text'
    };

    var NavbarTogglerIcon = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('span', {
          staticClass: "navbar-toggler-icon"
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'navbar-toggler-icon'
    };

    var NavbarToggler = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('button', {
          staticClass: "navbar-toggler",
          attrs: {
            "type": "button",
            "data-toggle": "collapse",
            "data-target": _vm.target,
            "aria-controls": _vm.target,
            "aria-expanded": _vm.expanded,
            "aria-label": _vm.label
          },
          on: {
            "click": _vm.onClick
          }
        }, [_vm._t("default", [_c('navbar-toggler-icon')])], 2);
      },
      staticRenderFns: [],
      name: 'navbar-toggler',
      components: {
        NavbarTogglerIcon: NavbarTogglerIcon
      },
      props: {
        expanded: Boolean,
        label: {
          type: String,
          default: 'Toggle navigation'
        },
        target: {
          type: String,
          default: '.navbar-collapse'
        }
      },
      methods: {
        onClick: function onClick(event) {
          this.$emit('click', event, this);
        }
      }
    };

    var Navbar = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('nav', {
          class: _vm.classes
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'navbar',
      components: {
        NavbarBrand: NavbarBrand,
        NavbarCollapse: NavbarCollapse,
        NavbarText: NavbarText,
        NavbarToggler: NavbarToggler,
        NavbarTogglerIcon: NavbarTogglerIcon
      },
      mixins: [Variant, Colorable],
      props: {
        /**
         * Expand the navbar. If true, applies to all size, otherwise pass a string.
         *
         * @property Object
         */
        expand: {
          type: [Boolean, String],
          default: 'lg',
          validate: function validate(value) {
            ['xs', 'sm', 'md', 'lg', 'xl'].indexOf(value) !== -1 || isBoolean(value);
          }
        },

        /**
         * The should the navbar be fixed at the top.
         *
         * @property String
         */
        fixed: {
          type: [String, Boolean],
          validate: function validate(value) {
            ['top', 'bottom'].indexOf(value) !== -1 || isBoolean(value);
          }
        },

        /**
         * The should the navbar be stickied at the top.
         *
         * @property String
         */
        sticky: {
          type: [String, Boolean],
          validate: function validate(value) {
            ['top', 'bottom'].indexOf(value) !== -1 || isBoolean(value);
          }
        },

        /**
         * The variant attribute
         *
         * @property String
         */
        variant: {
          type: String,
          default: 'light',
          validate: function validate(value) {
            return ['light', 'dark'].indexOf(value) !== -1;
          }
        }
      },
      computed: {
        expandedClass: function expandedClass() {
          if (isBoolean(this.expand)) {
            return this.expand;
          }

          return prefix(prefix(this.expand, 'expand'), 'navbar');
        },
        classes: function classes() {
          return this.$mergeClasses('navbar', prefix(this.sticky === true ? 'top' : this.sticky, 'sticky'), prefix(this.fixed === true ? 'top' : this.fixed, 'fixed'), this.expandedClass, this.variantClass, this.colorableClasses);
        }
      },
      data: function data() {
        return {};
      }
    };

    var NavigationLink = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c(_vm.component, {
          tag: "component",
          class: _vm.classes,
          attrs: {
            "href": _vm.href,
            "to": _vm.to
          }
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'navigation-link',
      props: {
        /**
         * Is the navigation item active
         *
         * @prop {Boolean}
         */
        active: Boolean,

        /**
         * Is the navigation item disabled
         *
         * @prop {Boolean}
         */
        disabled: Boolean,

        /**
         * The href attribute
         *
         * @prop {String}
         */
        href: String,

        /**
         * The component HTML tag
         *
         * @prop {String}
         */
        tag: String,

        /**
         * The to attribute, will be passed to router-link.
         *
         * @prop {String}
         */
        to: [Object, String],

        /**
         * Add the nav-item class to the link
         *
         * @prop {Boolean}
         */
        item: {
          type: Boolean,
          default: true
        }
      },
      computed: {
        component: function component() {
          return this.tag || (this.to ? 'router-link' : 'a');
        },
        classes: function classes() {
          var _this = this;

          this.$nextTick(function () {
            if (!_this.isItem) {
              _this.isItem = !_this.$parent.$el.classList.contains('nav-item');
            }
          });
          return {
            'nav-link': this.href,
            'nav-item': this.item,
            'active': this.active,
            'disabled': this.disabled
          };
        }
      }
    };

    var NavigationItem = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c(_vm.component, {
          tag: "component",
          class: _vm.classes
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'navigation-item',
      extends: NavigationLink,
      props: {
        /**
         * The HTML element
         *
         * @prop {String}
         */
        element: String,

        /**
         * Is the component a list element
         *
         * @prop {Boolean}
         */
        list: Boolean,

        /**
         * Add the nav-item class to the link
         *
         * @prop {Boolean}
         */
        item: {
          type: Boolean,
          default: true
        }
      },
      computed: {
        component: function component() {
          if (this.element) {
            return this.element;
          } else if (this.href) {
            return 'a';
          } else if (this.list) {
            return 'li';
          }

          return 'div';
        }
      }
    };

    var Navigation = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('nav', {
          staticClass: "nav",
          class: _vm.classes,
          attrs: {
            "role": _vm.role
          }
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'navigation',
      components: {
        NavigationItem: NavigationItem
      },
      mixins: [Colorable],
      props: {
        /**
         * Helper to add the justify-content-X class.
         *
         * @prop {Array}
         */
        align: String,

        /**
         * An array of buttons
         *
         * @prop {Array}
         */
        buttons: Array,

        /**
         * The navigation inside a card
         *
         * @prop {Boolean}
         */
        card: Boolean,

        /**
         * Justify nav items to fill the width equally (using flex).
         *
         * @prop {Array}
         */
        fill: Boolean,

        /**
         * Add `nav-justified` class to the component.
         *
         * @prop {Array}
         */
        justified: Boolean,

        /**
         * Display items as pill shapes
         *
         * @prop {Array}
         */
        pills: Boolean,

        /**
         * Display items as tab shapes
         *
         * @prop {Array}
         */
        tabs: Boolean,

        /**
         * Display the buttons vertically
         *
         * @prop {Boolean}
         */
        vertical: Boolean,

        /**
         * The role attribute
         *
         * @prop {String}
         */
        role: String
      },
      computed: {
        classes: function classes() {
          var _this = this;

          this.$nextTick(function () {
            if (!_this.isCard) {
              _this.isCard = _this.$parent.$el.classList.contains('card-header');
            }
          });
          return this.$mergeClasses(prefix(this.align, 'justify-content'), this.colorableClasses, {
            'card-header-tabs': this.isCard && this.tabs,
            'card-header-pills': this.isCard && this.pills,
            'nav-justified': this.justified,
            'nav-fill': this.fill,
            'nav-pills': this.pills,
            'nav-tabs': this.tabs,
            'flex-column': this.vertical
          });
        }
      },
      data: function data() {
        return {
          isCard: this.card
        };
      }
    };

    var NavigationDropdown = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('navigation-item', {
          staticClass: "dropdown"
        }, [_vm._t("toggle-button", [_c('navigation-link', {
          staticClass: "dropdown-toggle",
          attrs: {
            "href": "#",
            "data-toggle": "dropdown",
            "role": "button",
            "aria-haspopup": "true",
            "aria-expanded": _vm.isDropdownShowing
          },
          on: {
            "blur": _vm.onBlur
          },
          nativeOn: {
            "click": function click($event) {
              $event.preventDefault();

              _vm.toggle();
            }
          }
        }, [_vm._v(" " + _vm._s(_vm.label) + " ")])]), _vm._v(" "), _vm._t("dropdown-menu", [_c('dropdown-menu', {
          attrs: {
            "id": _vm.id,
            "items": _vm.items,
            "align": _vm.align,
            "show": _vm.isDropdownShowing
          },
          on: {
            "update:show": function updateShow($event) {
              _vm.isDropdownShowing = $event;
            },
            "item:click": _vm.onItemClick
          }
        }, [_vm._t("default")], 2)])], 2);
      },
      staticRenderFns: [],
      name: 'navigation-dropdown',
      extends: BtnDropdown,
      components: {
        BtnDropdown: BtnDropdown,
        DropdownMenu: DropdownMenu,
        NavigationItem: NavigationItem,
        NavigationLink: NavigationLink
      }
    };

    var plugin$30 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          Navigation: Navigation,
          NavigationItem: NavigationItem,
          NavigationLink: NavigationLink,
          NavigationDropdown: NavigationDropdown
        });
      }
    });

    var NavbarNav = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('ul', {
          staticClass: "navbar-nav",
          class: _vm.classes,
          attrs: {
            "role": _vm.role
          }
        }, [_vm._t("default")], 2);
      },
      staticRenderFns: [],
      name: 'navbar-nav',
      components: {
        Navigation: Navigation
      }
    };

    var plugin$31 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          Navbar: Navbar,
          NavbarBrand: NavbarBrand,
          NavbarCollapse: NavbarCollapse,
          NavbarNav: NavbarNav,
          NavbarText: NavbarText,
          NavbarToggler: NavbarToggler,
          NavbarTogglerIcon: NavbarTogglerIcon
        });
      }
    });

    var plugin$32 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          Overlay: Overlay
        });
      }
    });

    var Pagination = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('nav', {
          attrs: {
            "aria-label": "Page navigation example"
          }
        }, [_c('ul', {
          staticClass: "pagination",
          class: _vm.classes
        }, [_c('li', {
          staticClass: "page-item",
          class: {
            'disabled': _vm.currentPage === 1
          }
        }, [_c('a', {
          staticClass: "page-link",
          attrs: {
            "href": "#",
            "aria-label": "Previous"
          },
          on: {
            "click": function click($event) {
              $event.preventDefault();

              _vm.prev($event);
            }
          }
        }, [_c('span', {
          attrs: {
            "aria-hidden": "true"
          }
        }, [_vm._v("«")])])]), _vm._v(" "), _vm._l(_vm.pages, function (item) {
          return _c('li', {
            staticClass: "page-item",
            class: {
              'active': item.page === _vm.currentPage,
              'disabled': !!item.divider
            },
            attrs: {
              "data-page": item.page
            }
          }, [_vm._t("default", [item.divider ? _c('a', {
            staticClass: "page-link"
          }, [_vm._v("…")]) : _c('a', {
            staticClass: "page-link",
            class: item.class,
            attrs: {
              "href": "#",
              "data-label": item.label
            },
            on: {
              "click": function click($event) {
                $event.preventDefault();

                _vm.paginate(item.page, $event);
              }
            }
          }, [item.label ? _c('span', {
            attrs: {
              "aria-hidden": "true"
            },
            domProps: {
              "innerHTML": _vm._s(item.label)
            }
          }) : _vm._e(), _vm._v(" "), item.page ? _c('span', {
            attrs: {
              "aria-hidden": "true"
            },
            domProps: {
              "innerHTML": _vm._s(item.page)
            }
          }) : _vm._e()])], {
            item: item
          })], 2);
        }), _vm._v(" "), _c('li', {
          staticClass: "page-item",
          class: {
            'disabled': _vm.currentPage >= _vm.totalPages
          }
        }, [_c('a', {
          staticClass: "page-link",
          attrs: {
            "href": "#",
            "aria-label": "Next"
          },
          on: {
            "click": function click($event) {
              $event.preventDefault();

              _vm.next($event);
            }
          }
        }, [_c('span', {
          attrs: {
            "aria-hidden": "true"
          }
        }, [_vm._v("»")])])])], 2)]);
      },
      staticRenderFns: [],
      name: 'pagination',
      props: {
        /**
         * The alignment of the pagination component.
         *
         * @prop String
         */
        align: {
          type: String,
          validate: function validate(value) {
            return ['start', 'end', 'center'].indexOf(value) !== -1;
          }
        },

        /**
         * The page on which the paginator should start.
         *
         * @prop String
         */
        page: {
          type: Number,
          default: 1
        },

        /**
         * The total number of pages in the paginator.
         *
         * @prop String
         */
        totalPages: {
          type: Number,
          default: 1
        },

        /**
         * The number of pages to show when the total number of pages is
         * greater than the number of pages that should be shown.
         *
         * @prop String
         */
        showPages: {
          type: Number,
          default: 6
        },
        onPaginate: Function
      },
      methods: {
        next: function next(event) {
          this.paginate(this.currentPage >= this.totalPages ? this.currentPage : this.currentPage + 1, event);
        },
        prev: function prev(event) {
          this.paginate(this.currentPage <= 1 ? this.currentPage : this.currentPage - 1, event);
        },
        paginate: function paginate(page, event) {
          if (event.currentTarget.parentNode.classList.contains('disabled')) {
            return;
          }

          this.setActivePage(page);

          if (this.onPaginate) {
            this.onPaginate(page, event);
          }

          this.$emit('paginate', page, event);
        },
        setActivePage: function setActivePage(page) {
          if (this.currentPage !== page) {
            this.currentPage = page;
          }
        },
        generate: function generate() {
          var pages = [];
          var showPages = this.showPages % 2 ? this.showPages + 1 : this.showPages;
          var startPage = this.currentPage >= showPages ? this.currentPage - showPages / 2 : 1;
          var startOffset = showPages + startPage;
          var endPage = this.totalPages < startOffset ? this.totalPages : startOffset;
          var diff = startPage - endPage + showPages;
          startPage -= startPage - diff > 0 ? diff : 0;

          if (startPage > 1) {
            pages.push({
              page: 1
            });
          }

          if (startPage > 2) {
            pages.push({
              divider: true
            });
          }

          for (var i = startPage; i < endPage; i++) {
            pages.push({
              page: i
            });
          }

          if (endPage <= this.totalPages) {
            if (this.totalPages - 1 > endPage) {
              pages.push({
                divider: true
              });
            }

            pages.push({
              page: this.totalPages
            });
          }

          return pages;
        }
      },
      computed: {
        pages: function pages() {
          return this.generate();
        },
        classes: function classes() {
          var classes = {};
          classes['justify-content-' + this.align] = true;
          return classes;
        }
      },
      data: function data() {
        return {
          currentPage: this.page
        };
      }
    };

    var plugin$33 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          Pagination: Pagination
        });
      }
    });

    var plugin$34 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          RadioField: RadioField
        });
      }
    });

    var CUSTOM_SELECT_PREFIX = 'custom-select-';
    var SelectField = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('form-group', [_vm._t("label", [_vm.label ? _c('form-label', {
          attrs: {
            "for": _vm.id
          },
          domProps: {
            "innerHTML": _vm._s(_vm.label)
          }
        }) : _vm._e()]), _vm._v(" "), _vm._t("control", [_c('select', {
          class: _vm.$mergeClasses(_vm.controlClasses, _vm.colorableClasses),
          attrs: {
            "id": _vm.id,
            "name": _vm.name,
            "required": _vm.required,
            "disabled": _vm.disabled || _vm.readonly,
            "readonly": _vm.readonly,
            "pattern": _vm.pattern
          },
          domProps: {
            "value": _vm.value
          },
          on: {
            "input": function input($event) {
              _vm.updated($event.target.value);
            }
          }
        }, [_vm._t("default")], 2)]), _vm._v(" "), _vm._t("help", [_vm.helpText ? _c('help-text', {
          domProps: {
            "innerHTML": _vm._s(_vm.helpText)
          }
        }) : _vm._e()]), _vm._v(" "), _vm._t("feedback", [_vm.validFeedback ? _c('form-feedback', {
          attrs: {
            "valid": ""
          },
          domProps: {
            "innerHTML": _vm._s(_vm.validFeedback)
          }
        }) : _vm._e(), _vm._v(" "), _vm.invalidFeedback ? _c('form-feedback', {
          attrs: {
            "invalid": ""
          },
          domProps: {
            "innerHTML": _vm._s(_vm.invalidFeedback)
          }
        }) : _vm._e()])], 2);
      },
      staticRenderFns: [],
      name: 'select-field',
      components: {
        HelpText: HelpText,
        FormGroup: FormGroup,
        FormLabel: FormLabel,
        FormFeedback: FormFeedback
      },
      extends: FormControl,
      mixins: [FormControl, Colorable],
      props: {
        /**
         * Add `custom-select` to the form control if true.
         *
         * @property String
         */
        custom: Boolean
      },
      computed: {
        controlClass: function controlClass() {
          var controlClass = this.custom ? 'custom-select' : this.defaultControlClass;
          return this.plaintext ? "".concat(controlClass, "-plaintext") : controlClass;
        },
        customSelectClasses: function customSelectClasses() {
          return [CUSTOM_SELECT_PREFIX.replace(/\-$/, '') + (this.plaintext ? '-plaintext' : ''), this.customSelectSizeClass, this.spacing || ''].join(' ');
        }
      }
    };

    var plugin$35 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          SelectField: SelectField
        });
      }
    });

    var Slide = {
      name: 'slide',
      functional: true,
      props: {
        vnode: {
          type: Object,
          required: true,
          validate: function validate(value) {
            return value.tag && value.elm;
          }
        }
      },
      render: function render(h, context) {
        return context.props.vnode;
      }
    };

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeMax$4 = Math.max;

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(o) { return o.user == 'barney'; });
     * // => 0
     *
     * // The `_.matches` iteratee shorthand.
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findIndex(users, ['active', false]);
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.findIndex(users, 'active');
     * // => 2
     */
    function findIndex$1(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax$4(length + index, 0);
      }
      return baseFindIndex(array, baseIteratee(predicate, 3), index);
    }

    var SlideDeckControls = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "slide-deck-controls"
        }, _vm._l(_vm.slides, function (slide) {
          return _c('a', {
            staticClass: "slide-deck-control-icon",
            class: {
              'is-active': (slide.data ? slide.data.key : slide.key) === _vm.active
            },
            attrs: {
              "href": "#"
            },
            on: {
              "click": function click($event) {
                $event.preventDefault();

                _vm.onClick($event, slide);
              }
            }
          }, [_c('i', {
            staticClass: "fa fa-circle"
          })]);
        }));
      },
      staticRenderFns: [],
      name: 'slide-deck-controls',
      props: {
        /**
         * The slide key or index that should show.
         *
         * @type {Number}
         */
        active: {
          type: [String, Number],
          default: 0
        },

        /**
         * An array of slide vnodes
         *
         * @type {Number}
         */
        slides: {
          type: Array,
          required: true
        }
      },
      methods: {
        onClick: function onClick(event, slide) {
          this.$emit('click', event, slide);
        }
      },
      computed: {},
      data: function data() {
        return {};
      }
    };

    var RESIZE_MODES = {
      auto: function auto(el) {
        if (el.clientHeight) {
          this.height = el.style.height = unit(el.clientHeight);
        }

        if (el.clientWidth) {
          this.width = el.style.width = unit(el.clientWidth);
        }
      },
      initial: function initial(el) {
        if (!this.height && this.$el.clientHeight) {
          this.height = unit(this.$el.clientHeight);
        }

        el.style.height = this.height;

        if (!this.width && this.$el.clientWidth) {
          this.width = unit(this.$el.clientWidth);
        }

        el.style.width = this.width;
      }
    };
    var SlideDeck = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "slide-deck",
          class: {
            'slide-deck-flex': _vm.center
          },
          style: {
            height: _vm.height,
            width: _vm.width
          }
        }, [_c('div', {
          staticClass: "slide-deck-content"
        }, [_c('keep-alive', [_c('transition', {
          attrs: {
            "name": "slide-".concat(_vm.direction)
          },
          on: {
            "enter": _vm.onSlideEnter,
            "leave": _vm.onSlideLeave
          }
        }, [_c('slide', {
          attrs: {
            "vnode": _vm.component
          }
        })], 1)], 1)], 1), _vm._v(" "), _vm._t("controls", [_vm.controls ? _c('slide-deck-controls', {
          attrs: {
            "slides": _vm.slides,
            "active": _vm.currentSlide
          },
          on: {
            "click": _vm.onClickControl
          }
        }) : _vm._e()])], 2);
      },
      staticRenderFns: [],
      name: 'slide-deck',
      components: {
        Slide: Slide,
        SlideDeckControls: SlideDeckControls
      },
      props: {
        /**
         * The slide key or index that should show.
         *
         * @type {Number}
         */
        active: {
          type: [String, Number],
          default: 0
        },

        /**
         * Flex the content within the popover.
         *
         * @type Boolean
         */
        flex: {
          type: Boolean,
          default: true
        },

        /**
         * Show the slide-deck controls to change the slide.
         *
         * @type Boolean
         */
        controls: Boolean,

        /**
         * The mode determines how the popover content will flex based on the
         * varying heights of the slides.
         *
         * @type Boolean
         */
        resizeMode: {
          type: [Function, Boolean, String],
          default: 'auto',
          validate: function validate(value) {
            return ['auto', 'initial', 'inherit'].indexOf(value) !== 1;
          }
        }
      },
      watch: {
        active: function active(value, oldValue) {
          this.currentSlide = value;
        },
        currentSlide: function currentSlide(value, oldValue) {
          this.direction = this.findSlideIndex(oldValue) > this.findSlideIndex(value) ? 'backward' : 'forward';
        },
        height: function height(value, oldValue) {//this.$emit('resize', this, value);
        }
      },
      methods: {
        findSlideByKey: function findSlideByKey(key) {
          return head(filter$1(this.slides, function (vnode, i) {
            return vnode.data ? vnode.data.key === key : i === key;
          }));
        },
        findSlideByIndex: function findSlideByIndex(index) {
          return this.slides[index] || null;
        },
        findSlideIndex: function findSlideIndex(key) {
          return findIndex$1(this.slides, function (vnode, i) {
            return vnode.data ? vnode.data.key === key : i === key;
          });
        },
        resize: function resize(el) {
          if (isFunction$1(this.resizeMode)) {
            this.resizeMode.call(this, el);
          } else if (isFunction$1(RESIZE_MODES[this.resizeMode])) {
            RESIZE_MODES[this.resizeMode].call(this, el);
          }
        },
        onClickControl: function onClickControl(event, vnode) {
          this.currentSlide = vnode.data ? vnode.data.key : vnode.key;
        },
        onSlideEnter: function onSlideEnter(el, done) {
          var _this = this;

          this.resize(el);
          transition(el).then(function (delay) {
            _this.$nextTick(done);
          });
        },
        onSlideLeave: function onSlideLeave(el, done) {
          var _this2 = this;

          this.resize(el);
          transition(el).then(function (delay) {
            _this2.$nextTick(done);
          });
        }
      },
      computed: {
        slides: function slides() {
          return map(filter$1(this.$slots.default, function (vnode, i) {
            return !!vnode.tag;
          }), function (vnode, i) {
            if (!vnode.key) {
              vnode.data = assignIn(vnode.data, {
                key: vnode.key = i
              });
            }

            return vnode;
          });
        },
        component: function component() {
          return this.findSlideByKey(this.currentSlide) || this.findSlideByIndex(this.currentSlide) || head(this.slides);
        }
      },
      mounted: function mounted() {
        this.$el.parentElement.style.overflow = 'hidden';
        this.resize(this.$el);
      },
      updated: function updated() {},
      data: function data() {
        return {
          height: null,
          width: null,
          currentSlide: this.active,
          direction: 'forward'
        };
      }
    };

    var plugin$36 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          Slide: Slide,
          SlideDeck: SlideDeck
        });
      }
    });

    var Transformer =
    /*#__PURE__*/
    function () {
      /**
       * Initialize the transformer instance using an HTTP response object.
       *
       * @param data object
       * @return void
       */
      function Transformer(response) {
        _classCallCheck(this, Transformer);

        if (!isObject(this.$originalResponse = response)) {
          throw new Error('The transformer must be instantiated with a response object.');
        }

        if (!isArray(this.$required = this.required()) || !this.$required.length) {
          throw new Error('A transformer must have at least one required property.');
        }

        this.$transformedResponse = this.transform(response);
        this.validate();
        this.initialize();
      }
      /**
       * A method to override to perform logic to finished initializing.
       *
       * @return void
       */


      _createClass(Transformer, [{
        key: "initialize",
        value: function initialize() {} //

        /**
         * Define an array of required properties with at least one value.
         *
         * @return void
         */

      }, {
        key: "required",
        value: function required() {} //

        /**
         * Tranform the response object
         *
         * @property String
         */

      }, {
        key: "transform",
        value: function transform(response) {
          return response;
        }
        /**
         * Get the tranformed response
         *
         * @property String
         */

      }, {
        key: "response",
        value: function response() {
          return this.$transformedResponse;
        }
        /**
         * Validate the tranformed response.
         *
         * @return void
         */

      }, {
        key: "validate",
        value: function validate() {
          var _this = this;

          if (!isObject(this.$transformedResponse)) {
            throw new Error('The transformed response must be an object.');
          }

          forEach(this.$required, function (key) {
            if (!(key in _this.$transformedResponse)) {
              throw new Error("\"".concat(key, "\" is a required property and does not exist in the tranformed response."));
            }
          });
        }
      }]);

      return Transformer;
    }();

    var TableViewTransformer =
    /*#__PURE__*/
    function (_Transformer) {
      _inherits(TableViewTransformer, _Transformer);

      function TableViewTransformer() {
        _classCallCheck(this, TableViewTransformer);

        return _possibleConstructorReturn(this, (TableViewTransformer.__proto__ || Object.getPrototypeOf(TableViewTransformer)).apply(this, arguments));
      }

      _createClass(TableViewTransformer, [{
        key: "required",
        value: function required() {
          return [// The end of the count of the paginated list.
          'to', // The start of the count of the paginated list.
          'from', // The total number of items (not just included in the pagination)
          'total', // The number of items per page
          'per_page', // The last page number (or total pages)
          'last_page', // The current page number
          'current_page', // The actual response data to appear in the table
          'data'];
        }
      }, {
        key: "data",
        value: function data() {
          return this.$transformedResponse.data;
        }
      }, {
        key: "initialize",
        value: function initialize() {
          if (!isArray(this.data())) {
            throw new Error('The data property must be an array.');
          }
        }
      }]);

      return TableViewTransformer;
    }(Transformer);

    var TableView = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "table-view"
        }, [_c('div', {
          staticClass: "d-flex justify-content-between align-items-center"
        }, [_vm._t("header", [_c('div', {
          staticClass: "table-view-header"
        }, [_vm._t("heading", [_vm.heading ? _c('h3', {
          domProps: {
            "innerHTML": _vm._s(_vm.heading)
          }
        }) : _vm._e()]), _vm._v(" "), _vm._t("description", [_vm.description ? _c('p', {
          domProps: {
            "innerHTML": _vm._s(_vm.description)
          }
        }) : _vm._e()])], 2)]), _vm._v(" "), _vm._t("buttons", [_vm.buttons.length ? _c('div', {
          staticClass: "buttons-wrapper my-3"
        }, [_c('span', _vm._l(_vm.buttons, function (button, key) {
          return _c('a', {
            class: button.className || 'btn btn-primary',
            attrs: {
              "href": button.href || '#'
            },
            on: {
              "click": function click($event) {
                _vm.proxy(button.onClick, $event);
              }
            }
          }, [button.icon ? _c('i', {
            class: button.icon
          }) : _vm._e(), _vm._v(" "), _c('span', {
            domProps: {
              "innerHTML": _vm._s(button.label)
            }
          })]);
        }))]) : _vm._e()])], 2), _vm._v(" "), _c('table', {
          staticClass: "table",
          class: {
            'table-hover': _vm.hover && !_vm.loading && _vm.data.length
          }
        }, [_vm._t("thead", [_c('thead', [_c('tr', _vm._l(_vm.tableColumns, function (column) {
          return _c('th', {
            attrs: {
              "scope": "col",
              "width": column.width
            }
          }, [column.id ? _c('div', [_c('a', {
            staticClass: "sort",
            attrs: {
              "href": "#",
              "data-id": column.id
            },
            domProps: {
              "innerHTML": _vm._s(column.name || column.id)
            },
            on: {
              "click": function click($event) {
                $event.preventDefault();

                _vm.orderBy(column.id);
              }
            }
          }), _vm._v(" "), _vm.request.params.order === column.id && _vm.request.params.sort === 'asc' ? _c('i', {
            staticClass: "sort-icon fa fa-sort-asc"
          }) : _vm._e(), _vm._v(" "), _vm.request.params.order === column.id && _vm.request.params.sort === 'desc' ? _c('i', {
            staticClass: "sort-icon fa fa-sort-desc"
          }) : _vm._e()]) : _c('div', {
            domProps: {
              "innerHTML": _vm._s(column.name)
            }
          })]);
        }))])]), _vm._v(" "), _vm._t("tbody", [_c('tbody', [_vm.loading ? _c('tr', [_c('td', {
          staticClass: "position-relative",
          style: {
            'height': _vm.height(_vm.minHeight)
          },
          attrs: {
            "colspan": _vm.tableColumns.length
          }
        }, [_c('activity-indicator', {
          attrs: {
            "center": true
          }
        })], 1)]) : !_vm.data.length ? _c('tr', [_c('td', {
          staticClass: "position-relative",
          attrs: {
            "colspan": _vm.tableColumns.length
          }
        }, [_c('alert', {
          staticClass: "my-3",
          attrs: {
            "variant": "warning"
          }
        }, [_c('i', {
          staticClass: "fa fa-warning"
        }), _vm._v(" There are no results found. ")])], 1)]) : _vm._t("default", _vm._l(_vm.data, function (row, i) {
          return _c('tr', _vm._l(_vm.tableColumns, function (column) {
            return _c('td', {
              domProps: {
                "innerHTML": _vm._s(row[column.id] || row[column.name])
              }
            });
          }));
        }), {
          data: _vm.data,
          columns: _vm.tableColumns
        })], 2)]), _vm._v(" "), _vm._t("tfoot", [_c('tfoot', [_c('td', {
          staticClass: "table-view-footer",
          attrs: {
            "colspan": _vm.tableColumns.length
          }
        }, [_vm._t("pagination", [_vm.paginate && _vm.response ? _c('pagination', {
          attrs: {
            "align": "center",
            "page": _vm.response.current_page,
            "total-pages": _vm.response.last_page,
            "on-paginate": _vm.onPaginate
          }
        }) : _vm._e()])], 2)])])], 2)]);
      },
      staticRenderFns: [],
      name: 'table-view',
      mixins: [Proxy],
      components: {
        Pagination: Pagination,
        ActivityIndicator: ActivityIndicator
      },
      props: {
        // (string) A relative or absolute endpoint URL used to fetch data
        url: {
          type: String,
          required: true
        },
        // (integer) The starting page of the table
        page: {
          type: Number,
          default: 1
        },
        // (integer) The total number of results per page
        limit: {
          type: Number,
          default: 20
        },
        // (string) The column used to order the data
        order: String,
        // (string) The sort direction (asc|desc)
        sort: {
          type: String,
          validate: function validate(value) {
            return ['asc', 'desc'].indexOf(value) !== -1;
          }
        },
        // (integer) The minimum height of the row when loading data
        minHeight: {
          type: Number,
          default: 400
        },
        // (array) An array of button objects
        // [{href: 'test-123', label: 'Test 123'}]
        buttons: {
          type: Array,
          default: function _default() {
            return [];
          }
        },
        // (array) An array of table column
        // [{id: 'database_id', name: 'Database id', width: '20%'}]
        columns: {
          type: Array,
          default: function _default() {
            return [];
          }
        },
        // (string) The table heading
        heading: String,
        // (string) Add table-hover to the table element
        hover: {
          type: Boolean,
          default: true
        },
        // (string) The table description
        description: String,
        // (bool) Should show the pagination for this table
        paginate: {
          type: Boolean,
          default: true
        },
        // (object) The HTTP response transformer instance
        transformer: {
          type: Object,
          validate: function validate(value) {
            return value instanceof TableViewTransformer;
          }
        }
      },
      computed: {
        tableColumns: function tableColumns() {
          var columns = this.columns;

          if (!columns || !columns.length) {
            columns = keys(this.data[0]);
          }

          return columns.map(function (column) {
            return isObject(column) ? column : {
              name: column
            };
          });
        }
      },
      methods: {
        orderBy: function orderBy(order) {
          var defaultSort = 'desc';
          var currentSort = this.getRequestParam('sort');
          var currentOrder = this.getRequestParam('order');
          this.addRequestParam('order', order);
          this.addRequestParam('sort', currentOrder !== order || !currentSort ? defaultSort : currentSort === defaultSort ? 'asc' : null);
          this.fetch();
        },
        getRequestHeader: function getRequestHeader(key, value) {
          return this.request.headers[key] || value;
        },
        addRequestHeader: function addRequestHeader(key, value) {
          if (!this.request.headers) {
            this.request.headers = {};
          }

          this.request.headers[key] = value;
        },
        getRequestParam: function getRequestParam(key, value) {
          return this.request.params[key] || value;
        },
        addRequestParam: function addRequestParam(key, value) {
          if (!this.request.params) {
            this.request.params = {};
          }

          this.request.params[key] = value;
        },
        fetch: function fetch() {
          var _this = this;

          var request = new Request(this.url, this.request);
          this.loading = true;
          return request.get().then(function (response) {
            var transformer = _this.transformer || new TableViewTransformer(response);
            _this.response = transformer.response();
            _this.data = transformer.data();
            _this.loading = false;
          }, function (errors) {
            _this.loading = false;
          });
        },
        height: function height(min) {
          var elements = [// this.$el.querySelector('thead'),
          this.$el.querySelector('tbody')];
          var height = 0;

          forEach(elements, function (el) {
            height += el.getBoundingClientRect().height;
          });

          return unit(Math.max(min, height));
        },
        onPaginate: function onPaginate(page, event) {
          if (!this.request.params) {
            this.request.params = {};
          }

          this.request.params.page = page;
          this.fetch();
        }
      },
      data: function data() {
        return {
          // (array) The dataset for the table
          data: this.$attrs.data || [],
          // (bool) Is the table currently loading data
          loading: false,
          // (null|object) The response object
          response: null,
          // (object) The HTTP request object
          request: assignIn({
            headers: {},
            params: {
              page: this.page,
              limit: this.limit,
              order: this.order,
              sort: this.sort
            }
          }, this.$attrs.request)
        };
      },
      mounted: function mounted() {
        this.fetch();
      },

      /*
      data() {
          return extend({
              buttons: [],
               columns: [],
               header: false,
               description: false,
               // (bool) Should show the pagination for this table
              paginate: true,
               // (bool) Is the table currently loading data
              loading: false,
               // (object) An object with key/value pairs for components used in the template
              components: {
                  // (string) The name of the component used for the table header
                  header: 'table-view-header',
                   // (string) The name of the component used for the table row
                  row: 'table-view-row',
                   // (string) The name of the component used for the table row
                  footer: 'table-view-footer'
              },
               // (int) The starting page
              // page: 1,
               // (string) The order of the date being returned
              // order: null,
               // (string) Either asc or desc sorting order
              // sort: null,
               // (int) The numbers of rows per page
              // limit: 20,
               // (bool) Fetch the data when table is shown
              // fetchOnRender: true,
               // (array) An array of headers appended to the request
              // requestHeaders: [],
               // (array) The default options used to generate the query string
              // defaultRequestDataOptions: [
              //    'page',
              //    'limit',
              //    'order',
              //    'sort'
              // ],
               // (object) An option to pass an object with request data
              // requestData: {},
               // (array) Additional options used to generate the query string
              // requestDataOptions: [],
               // (object) The body view options object
              // bodyViewOptions: false,
               // (object) The pagination view class
              // footerView: 'pagination',
               // (object) The pagination view options object
              // footerViewOptions: false,
               // (string) The table footer class name
              // footerClassName: 'table-header',
               // (string) The table header
              // header: false,
               // (string) The table header tag name
              // headerTagName: 'h3',
               // (string) The table header class name
              // headerClassName: 'table-header',
               // (object) The header view class
              // headerView: false,
               // (object) The header view options object
              // headerViewOptions: false,
               // (string) The table description
              // description: false,
               // (string) The table description tag
              // descriptionTag: 'p',
               // (string) The table description tag
              // descriptionClassName: 'description row col-sm-6',
               // (string) The table class name
              // tableClassName: 'table',
               // (string) The loading class name
              // loadingClassName: 'loading',
               // (string) The name of the property in the model storing the columns
              // childViewColumnsProperty: 'columns',
               // (object) The activity indicator options
              // indicatorOptions: {
              //     indicator: 'small'
              // },
               // (string) The message to display if there are no table rows
              // emptyMessage: 'No rows found',
               // (string) The name of the class appended to the buttons
              // buttonClassName: 'btn btn-default',
          }, this.$attrs);
      },
      */
      beforeDestroy: function beforeDestroy() {
        this.$off();
      }
    };

    var plugin$37 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          TableView: TableView
        });
      }
    });

    var TextareaField = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('form-group', [_vm._t("label", [_vm.label || _vm.hasDefaultSlot ? _c('form-label', {
          attrs: {
            "for": _vm.id
          }
        }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))])], 2) : _vm._e()]), _vm._v(" "), _vm._t("control", [_c('textarea', {
          directives: [{
            name: "bind-events",
            rawName: "v-bind-events",
            value: _vm.bindEvents,
            expression: "bindEvents"
          }],
          class: _vm.$mergeClasses(_vm.controlClasses, _vm.colorableClasses),
          attrs: {
            "id": _vm.id,
            "rows": _vm.rows,
            "errors": _vm.errors,
            "pattern": _vm.pattern,
            "readonly": _vm.readonly,
            "required": _vm.required,
            "maxlength": _vm.maxlength,
            "placeholder": _vm.placeholder,
            "disabled": _vm.disabled || _vm.readonly
          },
          domProps: {
            "value": _vm.value
          },
          on: {
            "input": function input($event) {
              _vm.updated($event.target.value);
            }
          }
        })]), _vm._v(" "), _vm._t("help", [_vm.helpText ? _c('help-text', {
          domProps: {
            "innerHTML": _vm._s(_vm.helpText)
          }
        }) : _vm._e()]), _vm._v(" "), _vm._t("feedback", [_vm.validFeedback ? _c('form-feedback', {
          attrs: {
            "valid": ""
          },
          domProps: {
            "innerHTML": _vm._s(_vm.validFeedback)
          }
        }) : _vm._e(), _vm._v(" "), _vm.invalidFeedback ? _c('form-feedback', {
          attrs: {
            "invalid": ""
          },
          domProps: {
            "innerHTML": _vm._s(_vm.invalidFeedback)
          }
        }) : _vm._e()])], 2);
      },
      staticRenderFns: [],
      name: 'textarea-field',
      components: {
        HelpText: HelpText,
        FormGroup: FormGroup,
        FormLabel: FormLabel,
        FormFeedback: FormFeedback
      },
      mixins: [Colorable, FormControl],
      props: {
        /**
         * The type attribute
         *
         * @property String
         */
        type: {
          type: String,
          default: 'text'
        },

        /**
         * The rows attribute
         *
         * @property String
         */
        rows: [Number, String]
      }
    };

    var plugin$38 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          TextareaField: TextareaField
        });
      }
    });

    var ThumbnailListItem = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "thumbnail-list-item",
          style: {
            height: _vm.unit(_vm.height),
            width: _vm.unit(_vm.width),
            minHeight: _vm.unit(_vm.minHeight),
            maxHeight: _vm.unit(_vm.maxHeight),
            minWidth: _vm.unit(_vm.minWidth),
            maxWidth: _vm.unit(_vm.maxWidth)
          }
        }, [_vm.src ? _c('img', {
          class: {
            'img-fluid': _vm.fluid
          },
          attrs: {
            "src": _vm.src,
            "alt": _vm.alt
          }
        }) : _vm._e(), _vm._v(" "), _vm._t("default")], 2);
      },
      staticRenderFns: [],
      props: {
        alt: String,
        src: String,
        width: [String, Number],
        height: [String, Number],
        minHeight: [String, Number],
        maxHeight: [String, Number],
        minWidth: [String, Number],
        maxWidth: [String, Number],
        fluid: {
          type: Boolean,
          default: true
        }
      },
      methods: {
        unit: unit
      }
    };

    var ThumbnailList = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', {
          staticClass: "thumbnail-list",
          class: _vm.classes
        }, [_vm._l(_vm.images, function (image) {
          return !!_vm.images ? _c('thumbnail-list-item', {
            attrs: {
              "src": image,
              "width": _vm.width
            }
          }) : _vm._e();
        }), _vm._v(" "), _vm._t("default")], 2);
      },
      staticRenderFns: [],
      components: {
        ThumbnailListItem: ThumbnailListItem
      },
      props: {
        fill: Boolean,
        flex: Boolean,
        noFlex: Boolean,
        grid: Boolean,
        wrap: Boolean,
        images: Array,
        width: {
          type: [String, Number],
          default: 75
        }
      },
      computed: {
        classes: function classes() {
          return {
            'thumbnail-list-fill': this.fill,
            'thumbnail-list-flex': this.flex,
            'thumbnail-list-noflex': this.noFlex,
            'thumbnail-list-grid': this.grid,
            'thumbnail-list-wrap': this.wrap
          };
        }
      }
    };

    var plugin$39 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          ThumbnailList: ThumbnailList
        });
      }
    });

    /**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */
    function last(array) {
      var length = array == null ? 0 : array.length;
      return length ? array[length - 1] : undefined;
    }

    /**
     * Gets the parent value at `path` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} path The path to get the parent value of.
     * @returns {*} Returns the parent value.
     */
    function parent(object, path) {
      return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
    }

    /**
     * The base implementation of `_.unset`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The property path to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     */
    function baseUnset(object, path) {
      path = castPath(path, object);
      object = parent(object, path);
      return object == null || delete object[toKey(last(path))];
    }

    /** Used for built-in method references. */
    var arrayProto$1 = Array.prototype;

    /** Built-in value references. */
    var splice$1 = arrayProto$1.splice;

    /**
     * The base implementation of `_.pullAt` without support for individual
     * indexes or capturing the removed elements.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {number[]} indexes The indexes of elements to remove.
     * @returns {Array} Returns `array`.
     */
    function basePullAt(array, indexes) {
      var length = array ? indexes.length : 0,
          lastIndex = length - 1;

      while (length--) {
        var index = indexes[length];
        if (length == lastIndex || index !== previous) {
          var previous = index;
          if (isIndex(index)) {
            splice$1.call(array, index, 1);
          } else {
            baseUnset(array, index);
          }
        }
      }
      return array;
    }

    /**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is invoked
     * with three arguments: (value, index, array).
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
     * to pull elements from an array by value.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */
    function remove(array, predicate) {
      var result = [];
      if (!(array && array.length)) {
        return result;
      }
      var index = -1,
          indexes = [],
          length = array.length;

      predicate = baseIteratee(predicate, 3);
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result.push(value);
          indexes.push(index);
        }
      }
      basePullAt(array, indexes);
      return result;
    }

    var UploadField = {
      render: function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('form-group', {
          staticClass: "upload-field",
          class: {
            'enable-dropzone': _vm.dropzone,
            'enable-multiple': _vm.multiple
          }
        }, [_c('dropzone', {
          on: {
            "drop": _vm.onDrop
          }
        }, [_vm.multiple && (!_vm.maxUploads || _vm.maxUploads > _vm.value.length) || !_vm.multiple && !_vm.value ? _c('file-field', {
          attrs: {
            "name": _vm.name,
            "label": _vm.label,
            "placeholder": _vm.placeholder,
            "help-text": _vm.helpText,
            "multiple": _vm.multiple,
            "errors": _vm.errors
          },
          on: {
            "change": _vm.onChange
          }
        }) : _vm._e(), _vm._v(" "), _vm.multiple && _vm.value && _vm.value.length ? _c('thumbnail-list', {
          staticClass: "mt-4",
          attrs: {
            "wrap": ""
          }
        }, _vm._l(_vm.value, function (file, key) {
          return _c('thumbnail-list-item', {
            key: file.id || key,
            attrs: {
              "width": _vm.width,
              "min-width": _vm.minWidth,
              "max-width": _vm.maxWidth,
              "height": _vm.height,
              "min-height": _vm.minHeight,
              "max-height": _vm.maxHeight
            }
          }, [_c('file-preview', {
            attrs: {
              "file": file
            },
            on: {
              "close": function close($event) {
                _vm.removeFile(file);
              }
            }
          }), _vm._v(" "), _vm._t("default", null, {
            file: file
          }), _vm._v(" "), _c('thumbnail-list-item')], 2);
        })) : !_vm.multiple && _vm.value ? _c('thumbnail-list', {
          staticClass: "mt-4",
          attrs: {
            "wrap": ""
          }
        }, [_c('thumbnail-list-item', {
          attrs: {
            "width": _vm.width,
            "min-width": _vm.minWidth,
            "max-width": _vm.maxWidth,
            "height": _vm.height,
            "min-height": _vm.minHeight,
            "max-height": _vm.maxHeight
          }
        }, [_c('file-preview', {
          attrs: {
            "file": _vm.value
          },
          on: {
            "close": function close($event) {
              _vm.removeFile(_vm.value);
            }
          }
        }), _vm._v(" "), _vm._t("default", null, {
          file: _vm.value
        }), _vm._v(" "), _c('thumbnail-list-item')], 2)], 1) : _vm._e(), _vm._v(" "), _vm.showDropElement ? _c('div', {
          staticClass: "upload-field-dropzone",
          style: {
            'min-height': _vm.dropzoneMinHeight
          },
          on: {
            "drop": function drop($event) {
              $event.preventDefault();
              return _vm.onDrop($event);
            }
          }
        }, [_c('i', {
          staticClass: "fa fa-cloud-upload"
        }), _vm._v(" "), _c('div', [_vm._v("Drag and drop files to upload")])]) : _vm._e()], 1)], 1);
      },
      staticRenderFns: [],
      name: 'upload-field',
      mixins: [FormControl],
      components: {
        Dropzone: Dropzone,
        FormGroup: FormGroup,
        FileField: FileField,
        FilePreview: FilePreview,
        ThumbnailList: ThumbnailList,
        ThumbnailListItem: ThumbnailListItem
      },
      model: {
        prop: 'value',
        event: 'change'
      },
      props: {
        /**
         * Can user upload multiple files
         *
         * @property String
         */
        multiple: Boolean,

        /**
         * The maximum number of files that a user can upload
         *
         * @property String
         */
        maxUploads: Number,

        /**
         * The height attribute for the control element
         *
         * @property String
         */
        height: [Number, String],

        /**
         * The minimum height attribute for the control element
         *
         * @property String
         */
        minHeight: [Number, String],

        /**
         * The maximum height attribute for the control element
         *
         * @property String
         */
        maxHeight: [Number, String],

        /**
         * The width attribute for the control element
         *
         * @property String
         */
        width: [Number, String],

        /**
         * The minimum width attribute for the control element
         *
         * @property String
         */
        minWidth: [Number, String],

        /**
         * The maximum width attribute for the control element
         *
         * @property String
         */
        maxWidth: [Number, String],

        /**
         * Can user drag/drop files into browser to upload them.
         *
         * @property String
         */
        dropzoneMinHeight: [Number, String],

        /**
         * Is the user dragging a file over the dropzone
         *
         * @property String
         */
        dragging: {
          type: [String, Boolean],
          default: function _default() {
            return undefined;
          }
        },

        /**
         * Can user drag/drop files into browser to upload them.
         *
         * @property String
         */
        dropzone: {
          type: Boolean,
          default: true
        },

        /**
         * The data attribute
         *
         * @property File|FileList|Array
         */
        value: {
          type: [Object, File, FileList, Array],
          default: function _default() {
            return !this.multiple ? null : [];
          }
        }
      },
      methods: _defineProperty({
        removeFile: function removeFile(data) {
          if (this.multiple) {
            var files = isArray(this.value) ? this.value.slice(0) : [];

            if (data instanceof File) {
              remove(files, {
                name: data.name,
                size: data.size,
                lastModified: data.lastModified
              });
            } else {
              remove(files, data);
            }

            this.$emit('change', files);
          } else {
            this.$emit('change', null);
          }
        },
        addFile: function addFile(file, subject) {
          var data = {
            name: file.name,
            lastModified: file.lastModified,
            lastModifiedDate: file.lastModifiedDate,
            size: file.size,
            type: file.type
          };

          if (this.multiple) {
            var files = subject || (isArray(this.value) ? this.value.slice(0) : []);

            if (!this.maxUploads || this.maxUploads > files.length) {
              if (findIndex$1(files, data) === -1) {
                files.push(file);
              }

              this.$emit('change', files);
            }
          } else {
            this.$emit('change', file);
          }
        },
        addFiles: function addFiles(files) {
          var _this = this;

          var subject = isArray(this.value) ? this.value.slice(0) : [];

          forEach(files, function (file) {
            _this.addFile(file, subject);
          });

          event.target.value = null;
        },
        onDrop: function onDrop(event) {
          this.onChange(event.dataTransfer.files);
        },
        onChange: function onChange(files) {
          if (files instanceof FileList) {
            this.addFiles(files);
          } else {
            this.addFile(files);
          }
        },

        /**
         * The `dragover` event callback.
         *
         * @property String
         */
        onDragOver: function onDragOver(event) {
          this.isDraggingInside = true;
          this.$emit('update:dragging', true);
          this.$emit('drag:over', event);
        },

        /**
         * The `dragover` event callback.
         *
         * @property String
         */
        onDragEnter: function onDragEnter(event) {
          this.isDraggingInside = true;
          this.$emit('update:dragging', true);
          this.$emit('drag:enter', event);
        },

        /**
         * The `dragleave` event callback.
         *
         * @property String
         */
        onDragLeave: function onDragLeave(event) {
          this.isDraggingInside = false;
          this.$emit('update:dragging', false);
          this.$emit('drag:leave', event);
        }
      }, "onDrop", function onDrop(event) {
        this.isDraggingInside = false;
        this.addFiles(event.dataTransfer.files);
        this.$emit('update:dragging', false);
        this.$emit('drop', event);
      }),
      computed: {
        showDropElement: function showDropElement() {
          return !isUndefined(this.dragging) ? this.dragging : this.isDraggingInside;
        }
      },
      data: function data() {
        return {
          isDraggingInside: false
        };
      }
    };

    var plugin$40 = VueInstaller.use({
      install: function install(Vue, options) {
        VueInstaller.components({
          UploadField: UploadField
        });
      }
    });



    var components$1 = /*#__PURE__*/Object.freeze({
        ActivityIndicator: ActivityIndicator,
        Alert: Alert,
        AlertClose: AlertClose,
        AlertHeading: AlertHeading,
        AlertLink: AlertLink,
        Badge: Badge,
        BaseForm: BaseForm,
        Breadcrumb: Breadcrumb,
        BreadcrumbItem: BreadcrumbItem,
        Btn: Btn,
        BtnActivity: BtnActivity,
        BtnFile: BtnFile,
        BtnGroup: BtnGroup,
        BtnGroupToggle: BtnGroupToggle,
        BtnToolbar: BtnToolbar,
        BtnDropdown: BtnDropdown,
        Card: Card,
        CardBody: CardBody,
        CardBtnGroup: CardBtnGroup,
        CardDeck: CardDeck,
        CardFooter: CardFooter,
        CardHeader: CardHeader,
        CardImg: CardImg,
        CardImgTop: CardImgTop,
        CardImgBottom: CardImgBottom,
        CardImgOverlay: CardImgOverlay,
        CardLink: CardLink,
        CardSubtitle: CardSubtitle,
        CardTitle: CardTitle,
        CheckboxField: CheckboxField,
        Container: Container,
        DropdownMenu: DropdownMenu,
        DropdownMenuItem: DropdownMenuItem,
        DropdownMenuHeader: DropdownMenuHeader,
        DropdownMenuDivider: DropdownMenuDivider,
        Dropzone: Dropzone,
        FileField: FileField,
        FilePreview: FilePreview,
        FormControl: FormControl$1,
        FormFeedback: FormFeedback,
        FormGroup: FormGroup,
        FormLabel: FormLabel,
        HelpText: HelpText,
        InfiniteScrolling: InfiniteScrolling,
        InputField: InputField,
        InputGroup: InputGroup,
        InputGroupAppend: InputGroupAppend,
        InputGroupPrepend: InputGroupPrepend,
        InputGroupText: InputGroupText,
        LightSwitchField: LightSwitchField,
        ListGroup: ListGroup,
        ListGroupItem: ListGroupItem,
        Navbar: Navbar,
        NavbarBrand: NavbarBrand,
        NavbarCollapse: NavbarCollapse,
        NavbarNav: NavbarNav,
        NavbarText: NavbarText,
        NavbarToggler: NavbarToggler,
        NavbarTogglerIcon: NavbarTogglerIcon,
        Modal: Modal,
        ModalBackdrop: ModalBackdrop,
        ModalBody: ModalBody,
        ModalContent: ModalContent,
        ModalDialog: ModalDialog,
        ModalFooter: ModalFooter,
        ModalHeader: ModalHeader,
        ModalTitle: ModalTitle,
        Navigation: Navigation,
        NavigationItem: NavigationItem,
        NavigationLink: NavigationLink,
        NavigationDropdown: NavigationDropdown,
        Overlay: Overlay,
        Pagination: Pagination,
        Popover: Popover,
        PopoverBody: PopoverBody,
        PopoverHeader: PopoverHeader,
        ProgressBar: ProgressBar,
        RadioField: RadioField,
        SelectField: SelectField,
        SlideDeck: SlideDeck,
        Slide: Slide,
        TableView: TableView,
        TextareaField: TextareaField,
        ThumbnailList: ThumbnailList,
        ThumbnailListItem: ThumbnailListItem,
        UploadField: UploadField
    });

    var STYLE_ATTRIBUTES = ['font', 'fontFamily', 'fontKerning', 'fontSize', 'fontStretch', 'fontStyle', 'fontVariant', 'fontVariantLigatures', 'fontVariantCaps', 'fontVariantNumeric', 'fontVariantEastAsian', 'fontWeight', 'lineHeight', 'letterSpacing', 'padding', 'margin', 'textAlign', 'textAlignLast', 'textDecoration', 'textDecorationLine', 'textDecorationStyle', 'textDecorationColor', 'textDecorationSkipInk', 'textDecorationPosition', 'textIndent', 'textRendering', 'textShadow', 'textSizeAdjust', 'textOverflow', 'textTransform', 'width', 'wordBreak', 'wordSpacing', 'wordWrap'];

    function int(str) {
      if (typeof str === "number") {
        return str;
      } else if (!str || !str.replace) {
        return 0;
      }

      return parseInt(str.replace(/[^\d.]+/g, ''));
    }

    function input(div, event) {
      div.innerHTML = event.target.value.replace(/(?:\r\n|\r|\n)/g, '<br />');
    }

    function height(el) {
      return int(el.getBoundingClientRect().height);
    }

    function style(el, attr) {
      return window.getComputedStyle(el)[attr];
    }

    function resize(target, div, minHeight, maxHeight) {
      var dynamicHeight = Math.max(height(div) + int(style(div, 'lineHeight')), minHeight);
      target.style.height = (!maxHeight || dynamicHeight < maxHeight ? dynamicHeight : maxHeight) + 'px';
    }

    function mimic(el) {
      var div = document.createElement('div');
      var styles = window.getComputedStyle(el);

      for (var i in STYLE_ATTRIBUTES) {
        var key = STYLE_ATTRIBUTES[i];
        div.style[key] = styles[key];
      }

      div.style.position = 'absolute';
      div.style.bottom = '100%';
      div.style.zIndex = -1;
      div.style.visibility = 'hidden';
      return div;
    }

    function init(el, maxHeight) {
      var div = mimic(el);
      var minHeight = height(el);
      el.addEventListener('input', function (event) {
        input(div, event);
        resize(el, div, minHeight, maxHeight);
      });
      document.body.appendChild(div);
      el.dispatchEvent(new Event('input'));
    }

    var Autogrow = {
      inserted: function inserted(el, binding, vnode) {
        if (el.tagName.toLowerCase() !== 'textarea') {
          el = el.querySelector('textarea');
        }

        if (!el) {
          throw new Error('A textarea is required for the v-autogrow directive.');
        }

        init(el, binding.value);
      }
    };

    function index$1 (Vue, options) {
      Vue.directive('autogrow', Autogrow);
    }

    function show(el, target, vnode) {
      target.classList.remove('collapse');
      target.classList.add('show');
      target.$collapsedHeight = getComputedStyle(target).height;
      target.classList.add('collapsing');
      vnode.context.$nextTick(function () {
        target.style.height = target.$collapsedHeight;
      });
      transition(target).then(function (delay) {
        target.style.height = null;
        target.classList.add('collapse');
        target.classList.remove('collapsing');
        el.classList.remove('collapsed');
      });
    }

    function hide$1(el, target, vnode) {
      target.style.height = target.$collapsedHeight;
      target.classList.add('collapsing');
      target.classList.remove('collapse');
      vnode.context.$nextTick(function () {
        target.style.height = 0;
      });
      transition(target).then(function (delay) {
        target.style.height = null;
        target.classList.add('collapse');
        target.classList.remove('show', 'collapsing');
        el.classList.add('collapsed');
      });
    }

    var Collapse = {
      inserted: function inserted(el, binding, vnode) {
        if (isUndefined(binding.value) || binding.value === true) {
          el.classList.add('collapsed');
          el.setAttribute('data-toggle', 'collapse');
          var target = el.getAttribute('data-target') || el.getAttribute('href');
          var elements = document.querySelectorAll(target);
          el.addEventListener('click', function (event) {
            elements.forEach(function (element) {
              if (!element.classList.contains('show')) {
                show(el, element, vnode);
              } else {
                hide$1(el, element, vnode);
              }
            });
            event.preventDefault();
          });
          elements.forEach(function (element) {
            /*
            if(!element.$collapsedHeight) {
                element.$collapsedHeight = getComputedStyle(element).height;
            }
            */
            if (!element.classList.contains('collapse')) {
              element.classList.add('collapse');
            }
          });
        }
      }
    };

    function index$2 (Vue, options) {
      Vue.directive('collapse', Collapse);
    }



    var directives$1 = /*#__PURE__*/Object.freeze({
        Autogrow: index$1,
        Collapse: index$2
    });

    function blob(url, progress) {
      return new Promise(function (resolve, reject) {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, true);
        xhr.responseType = 'blob';

        if (isFunction(progress)) {
          xhr.onprogress = function (e) {
            return progress(e, xhr);
          };
        }

        xhr.onerror = function (e) {
          return reject(e);
        };

        xhr.onabort = function (e) {
          return reject(e);
        };

        xhr.onload = function (e) {
          if (this.status === 200) {
            resolve(this.response);
          } else {
            reject(e);
          }
        };

        xhr.send();
      });
    }

    var main = VueInstaller.use({
      install: function install(Vue) {
        /*
        if("development" === 'development') {
            const domain = (location.host || 'localhost').split(':')[0];
            const port = {"watch":"/Users/justinkimbrell/Github/vue-interface/src/","port":35730} && {"watch":"/Users/justinkimbrell/Github/vue-interface/src/","port":35730}.port;
            VueInstaller.script(`http://${domain}:${port}/livereload.js?snipver=1`);
        }
        */
        VueInstaller.plugins(Vue, plugins$1);
        VueInstaller.filters(Vue, filters);
        VueInstaller.directives(Vue, directives$1);
        VueInstaller.components(Vue, components$1);
      }
    });

    exports.default = main;
    exports.Model = Model;
    exports.Request = Request;
    exports.RequestOptions = RequestOptions;
    exports.transformRequest = transformRequest;
    exports.transformResponse = transformResponse;
    exports.Colorable = Colorable;
    exports.FormControlMixin = FormControl;
    exports.HasSlots = HasSlots;
    exports.Proxy = Proxy;
    exports.Screenreaders = Screenreaders;
    exports.Sizeable = Sizeable;
    exports.Triggerable = Triggerable;
    exports.Variant = Variant;
    exports.mergeClasses = MergeClasses;
    exports.modal = modal$1;
    exports.overlay = overlay;
    exports.popover = popover;
    exports.ActivityIndicator = ActivityIndicator;
    exports.Alert = Alert;
    exports.AlertClose = AlertClose;
    exports.AlertHeading = AlertHeading;
    exports.AlertLink = AlertLink;
    exports.Badge = Badge;
    exports.BaseForm = BaseForm;
    exports.Breadcrumb = Breadcrumb;
    exports.BreadcrumbItem = BreadcrumbItem;
    exports.Btn = Btn;
    exports.BtnActivity = BtnActivity;
    exports.BtnFile = BtnFile;
    exports.BtnGroup = BtnGroup;
    exports.BtnGroupToggle = BtnGroupToggle;
    exports.BtnToolbar = BtnToolbar;
    exports.BtnDropdown = BtnDropdown;
    exports.Card = Card;
    exports.CardBody = CardBody;
    exports.CardBtnGroup = CardBtnGroup;
    exports.CardDeck = CardDeck;
    exports.CardFooter = CardFooter;
    exports.CardHeader = CardHeader;
    exports.CardImg = CardImg;
    exports.CardImgTop = CardImgTop;
    exports.CardImgBottom = CardImgBottom;
    exports.CardImgOverlay = CardImgOverlay;
    exports.CardLink = CardLink;
    exports.CardSubtitle = CardSubtitle;
    exports.CardTitle = CardTitle;
    exports.CheckboxField = CheckboxField;
    exports.Container = Container;
    exports.DropdownMenu = DropdownMenu;
    exports.DropdownMenuItem = DropdownMenuItem;
    exports.DropdownMenuHeader = DropdownMenuHeader;
    exports.DropdownMenuDivider = DropdownMenuDivider;
    exports.Dropzone = Dropzone;
    exports.FileField = FileField;
    exports.FilePreview = FilePreview;
    exports.FormControl = FormControl$1;
    exports.FormFeedback = FormFeedback;
    exports.FormGroup = FormGroup;
    exports.FormLabel = FormLabel;
    exports.HelpText = HelpText;
    exports.InfiniteScrolling = InfiniteScrolling;
    exports.InputField = InputField;
    exports.InputGroup = InputGroup;
    exports.InputGroupAppend = InputGroupAppend;
    exports.InputGroupPrepend = InputGroupPrepend;
    exports.InputGroupText = InputGroupText;
    exports.LightSwitchField = LightSwitchField;
    exports.ListGroup = ListGroup;
    exports.ListGroupItem = ListGroupItem;
    exports.Navbar = Navbar;
    exports.NavbarBrand = NavbarBrand;
    exports.NavbarCollapse = NavbarCollapse;
    exports.NavbarNav = NavbarNav;
    exports.NavbarText = NavbarText;
    exports.NavbarToggler = NavbarToggler;
    exports.NavbarTogglerIcon = NavbarTogglerIcon;
    exports.Modal = Modal;
    exports.ModalBackdrop = ModalBackdrop;
    exports.ModalBody = ModalBody;
    exports.ModalContent = ModalContent;
    exports.ModalDialog = ModalDialog;
    exports.ModalFooter = ModalFooter;
    exports.ModalHeader = ModalHeader;
    exports.ModalTitle = ModalTitle;
    exports.Navigation = Navigation;
    exports.NavigationItem = NavigationItem;
    exports.NavigationLink = NavigationLink;
    exports.NavigationDropdown = NavigationDropdown;
    exports.Overlay = Overlay;
    exports.Pagination = Pagination;
    exports.Popover = Popover;
    exports.PopoverBody = PopoverBody;
    exports.PopoverHeader = PopoverHeader;
    exports.ProgressBar = ProgressBar;
    exports.RadioField = RadioField;
    exports.SelectField = SelectField;
    exports.SlideDeck = SlideDeck;
    exports.Slide = Slide;
    exports.TableView = TableView;
    exports.TextareaField = TextareaField;
    exports.ThumbnailList = ThumbnailList;
    exports.ThumbnailListItem = ThumbnailListItem;
    exports.UploadField = UploadField;
    exports.Autogrow = index$1;
    exports.Collapse = index$2;
    exports.DateFilter = index;
    exports.MomentFilter = index;
    exports.blob = blob;
    exports.instance = instance;
    exports.prefix = prefix;
    exports.readFile = readFile;
    exports.script = script;
    exports.transition = transition;
    exports.unit = unit;
    exports.uuid = uuid;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidnVlLWludGVyZmFjZS5qcyIsInNvdXJjZXMiOlsiLi4vc3JjL0ZpbHRlcnMvRGF0ZS9EYXRlRmlsdGVyLmpzIiwiLi4vc3JjL0ZpbHRlcnMvRGF0ZS9Nb21lbnRGaWx0ZXIuanMiLCIuLi9zcmMvRmlsdGVycy9EYXRlL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc09iamVjdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNBcnJheS5qcyIsIi4uL25vZGVfbW9kdWxlcy9yb2xsdXAtcGx1Z2luLW5vZGUtZ2xvYmFscy9zcmMvZ2xvYmFsLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZnJlZUdsb2JhbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3Jvb3QuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19TeW1ib2wuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRSYXdUYWcuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19vYmplY3RUb1N0cmluZy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VHZXRUYWcuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzRnVuY3Rpb24uanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jb3JlSnNEYXRhLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNNYXNrZWQuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL190b1NvdXJjZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VJc05hdGl2ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldFZhbHVlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0TmF0aXZlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZGVmaW5lUHJvcGVydHkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlQXNzaWduVmFsdWUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2VxLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXNzaWduVmFsdWUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jb3B5T2JqZWN0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pZGVudGl0eS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FwcGx5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fb3ZlclJlc3QuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2NvbnN0YW50LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVNldFRvU3RyaW5nLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc2hvcnRPdXQuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zZXRUb1N0cmluZy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VSZXN0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0xlbmd0aC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNBcnJheUxpa2UuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc0luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNJdGVyYXRlZUNhbGwuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jcmVhdGVBc3NpZ25lci5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VUaW1lcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNPYmplY3RMaWtlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzQXJndW1lbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0FyZ3VtZW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvc3R1YkZhbHNlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0J1ZmZlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VJc1R5cGVkQXJyYXkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlVW5hcnkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19ub2RlVXRpbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNUeXBlZEFycmF5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXJyYXlMaWtlS2V5cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2lzUHJvdG90eXBlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbmF0aXZlS2V5c0luLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUtleXNJbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMva2V5c0luLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9hc3NpZ25Jbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2xpc3RDYWNoZUNsZWFyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXNzb2NJbmRleE9mLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbGlzdENhY2hlRGVsZXRlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbGlzdENhY2hlR2V0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbGlzdENhY2hlSGFzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbGlzdENhY2hlU2V0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fTGlzdENhY2hlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc3RhY2tDbGVhci5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3N0YWNrRGVsZXRlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc3RhY2tHZXQuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zdGFja0hhcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX01hcC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX25hdGl2ZUNyZWF0ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2hhc2hDbGVhci5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2hhc2hEZWxldGUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19oYXNoR2V0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faGFzaEhhcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2hhc2hTZXQuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19IYXNoLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbWFwQ2FjaGVDbGVhci5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2lzS2V5YWJsZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldE1hcERhdGEuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19tYXBDYWNoZURlbGV0ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcENhY2hlR2V0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbWFwQ2FjaGVIYXMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19tYXBDYWNoZVNldC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX01hcENhY2hlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc3RhY2tTZXQuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19TdGFjay5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Fzc2lnbk1lcmdlVmFsdWUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jcmVhdGVCYXNlRm9yLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUZvci5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Nsb25lQnVmZmVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fVWludDhBcnJheS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Nsb25lQXJyYXlCdWZmZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jbG9uZVR5cGVkQXJyYXkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jb3B5QXJyYXkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlQ3JlYXRlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fb3ZlckFyZy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldFByb3RvdHlwZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2luaXRDbG9uZU9iamVjdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNBcnJheUxpa2VPYmplY3QuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzUGxhaW5PYmplY3QuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zYWZlR2V0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy90b1BsYWluT2JqZWN0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZU1lcmdlRGVlcC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VNZXJnZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvbWVyZ2UuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheUVhY2guanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19uYXRpdmVLZXlzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUtleXMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2tleXMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlRm9yT3duLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY3JlYXRlQmFzZUVhY2guanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlRWFjaC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Nhc3RGdW5jdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvZm9yRWFjaC5qcyIsIi4uL3NyYy9QbHVnaW5zL01lcmdlQ2xhc3Nlcy9NZXJnZUNsYXNzZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jdXN0b21EZWZhdWx0c01lcmdlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9tZXJnZVdpdGguanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2RlZmF1bHRzRGVlcC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNTdHJpbmcuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheVJlZHVjZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VQcm9wZXJ0eU9mLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZGVidXJyTGV0dGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXJyYXlNYXAuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzU3ltYm9sLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVRvU3RyaW5nLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy90b1N0cmluZy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvZGVidXJyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXNjaWlXb3Jkcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2hhc1VuaWNvZGVXb3JkLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fdW5pY29kZVdvcmRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy93b3Jkcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NyZWF0ZUNvbXBvdW5kZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2tlYmFiQ2FzZS5qcyIsIi4uL3NyYy9Db21wb25lbnRzL0FjdGl2aXR5SW5kaWNhdG9yL1R5cGVzL0Jhc2VUeXBlLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL0FjdGl2aXR5SW5kaWNhdG9yL1R5cGVzL0RvdHMudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvQWN0aXZpdHlJbmRpY2F0b3IvVHlwZXMvU3Bpbm5lci52dWUiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzRmluaXRlLmpzIiwiLi4vc3JjL0hlbHBlcnMvVW5pdC9Vbml0LmpzIiwiLi4vc3JjL0NvbXBvbmVudHMvQWN0aXZpdHlJbmRpY2F0b3IvQWN0aXZpdHlJbmRpY2F0b3IudnVlIiwiLi4vc3JjL0hlbHBlcnMvU2NyaXB0L1NjcmlwdC5qcyIsIi4uL3NyYy9IZWxwZXJzL1Z1ZUluc3RhbGxlci9WdWVJbnN0YWxsZXIuanMiLCIuLi9zcmMvQ29tcG9uZW50cy9BY3Rpdml0eUluZGljYXRvci9pbmRleC5qcyIsIi4uL3NyYy9Db21wb25lbnRzL0J0bkFjdGl2aXR5L0J0bkFjdGl2aXR5LnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL0J0bkFjdGl2aXR5L2luZGV4LmpzIiwiLi4vc3JjL0NvbXBvbmVudHMvTW9kYWwvTW9kYWxCb2R5LnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL01vZGFsL01vZGFsQmFja2Ryb3AudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvTW9kYWwvTW9kYWxDb250ZW50LnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL01vZGFsL01vZGFsRGlhbG9nLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL01vZGFsL01vZGFsVGl0bGUudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvTW9kYWwvTW9kYWxIZWFkZXIudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvTW9kYWwvTW9kYWxGb290ZXIudnVlIiwiLi4vc3JjL0hlbHBlcnMvVHJhbnNpdGlvbi9UcmFuc2l0aW9uLmpzIiwiLi4vc3JjL01peGlucy9UcmlnZ2VyYWJsZS9UcmlnZ2VyYWJsZS5qcyIsIi4uL3NyYy9Db21wb25lbnRzL01vZGFsL01vZGFsLnZ1ZSIsIi4uL3NyYy9QbHVnaW5zL01vZGFsL01vZGFsLmpzIiwiLi4vc3JjL0NvbXBvbmVudHMvT3ZlcmxheS9PdmVybGF5Qm9keS52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9Db250YWluZXIvQ29udGFpbmVyLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL0NvbnRhaW5lci9pbmRleC5qcyIsIi4uL3NyYy9Db21wb25lbnRzL092ZXJsYXkvT3ZlcmxheUNvbnRlbnQudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvT3ZlcmxheS9PdmVybGF5LnZ1ZSIsIi4uL3NyYy9QbHVnaW5zL092ZXJsYXkvT3ZlcmxheS5qcyIsIi4uL3NyYy9IZWxwZXJzL0luc3RhbmNlL0luc3RhbmNlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3BvcHBlci5qcy9kaXN0L2VzbS9wb3BwZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzVW5kZWZpbmVkLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0Jvb2xlYW4uanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zZXRDYWNoZUFkZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3NldENhY2hlSGFzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fU2V0Q2FjaGUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheVNvbWUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jYWNoZUhhcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2VxdWFsQXJyYXlzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbWFwVG9BcnJheS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3NldFRvQXJyYXkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19lcXVhbEJ5VGFnLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXJyYXlQdXNoLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUdldEFsbEtleXMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheUZpbHRlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvc3R1YkFycmF5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0U3ltYm9scy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldEFsbEtleXMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19lcXVhbE9iamVjdHMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19EYXRhVmlldy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX1Byb21pc2UuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19TZXQuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19XZWFrTWFwLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0VGFnLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzRXF1YWxEZWVwLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzRXF1YWwuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXNNYXRjaC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2lzU3RyaWN0Q29tcGFyYWJsZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldE1hdGNoRGF0YS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZU1hdGNoZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc0tleS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvbWVtb2l6ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21lbW9pemVDYXBwZWQuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zdHJpbmdUb1BhdGguanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jYXN0UGF0aC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3RvS2V5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUdldC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvZ2V0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUhhc0luLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faGFzUGF0aC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaGFzSW4uanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlTWF0Y2hlc1Byb3BlcnR5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVByb3BlcnR5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVByb3BlcnR5RGVlcC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvcHJvcGVydHkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXRlcmF0ZWUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL21hcEtleXMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzTnVsbC5qcyIsIi4uL3NyYy9IZWxwZXJzL1ByZWZpeC9QcmVmaXguanMiLCIuLi9zcmMvQ29tcG9uZW50cy9Qb3BvdmVyL1BvcG92ZXIudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvUG9wb3Zlci9Qb3BvdmVyQm9keS52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9Qb3BvdmVyL1BvcG92ZXJIZWFkZXIudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvUG9wb3Zlci9pbmRleC5qcyIsIi4uL3NyYy9QbHVnaW5zL1BvcG92ZXIvUG9wb3Zlci5qcyIsIi4uL3NyYy9Db21wb25lbnRzL0FsZXJ0L0FsZXJ0Q2xvc2UudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvQWxlcnQvQWxlcnRIZWFkaW5nLnZ1ZSIsIi4uL3NyYy9NaXhpbnMvVmFyaWFudC9WYXJpYW50LmpzIiwiLi4vc3JjL0NvbXBvbmVudHMvUHJvZ3Jlc3NCYXIvUHJvZ3Jlc3NCYXIudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvUHJvZ3Jlc3NCYXIvaW5kZXguanMiLCIuLi9zcmMvQ29tcG9uZW50cy9BbGVydC9BbGVydC52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9BbGVydC9BbGVydExpbmsudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvQWxlcnQvaW5kZXguanMiLCIuLi9zcmMvQ29tcG9uZW50cy9CYWRnZS9CYWRnZS52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9CYWRnZS9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VSZWR1Y2UuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3JlZHVjZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VTZXQuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlUGlja0J5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0U3ltYm9sc0luLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0QWxsS2V5c0luLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9waWNrQnkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlRmlsdGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9maWx0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hc2NpaVNpemUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19oYXNVbmljb2RlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fdW5pY29kZVNpemUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zdHJpbmdTaXplLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9zaXplLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZU1hcC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvbWFwLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVNsaWNlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY2FzdFNsaWNlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXNjaWlUb0FycmF5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fdW5pY29kZVRvQXJyYXkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zdHJpbmdUb0FycmF5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY3JlYXRlQ2FzZUZpcnN0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy91cHBlckZpcnN0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9jYXBpdGFsaXplLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9jYW1lbENhc2UuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlQXNzaWduLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUFzc2lnbkluLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY29weVN5bWJvbHMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jb3B5U3ltYm9sc0luLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faW5pdENsb25lQXJyYXkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jbG9uZURhdGFWaWV3LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY2xvbmVSZWdFeHAuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jbG9uZVN5bWJvbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2luaXRDbG9uZUJ5VGFnLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzTWFwLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc01hcC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VJc1NldC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNTZXQuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlQ2xvbmUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2Nsb25lRGVlcC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaGVhZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21ldGFNYXAuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlU2V0RGF0YS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NyZWF0ZUN0b3IuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jcmVhdGVCaW5kLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY29tcG9zZUFyZ3MuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jb21wb3NlQXJnc1JpZ2h0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY291bnRIb2xkZXJzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUxvZGFzaC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX0xhenlXcmFwcGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9ub29wLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0RGF0YS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3JlYWxOYW1lcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldEZ1bmNOYW1lLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fTG9kYXNoV3JhcHBlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3dyYXBwZXJDbG9uZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvd3JhcHBlckxvZGFzaC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2lzTGF6aWFibGUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zZXREYXRhLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0V3JhcERldGFpbHMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pbnNlcnRXcmFwRGV0YWlscy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VGaW5kSW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXNOYU4uanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zdHJpY3RJbmRleE9mLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUluZGV4T2YuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheUluY2x1ZGVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fdXBkYXRlV3JhcERldGFpbHMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zZXRXcmFwVG9TdHJpbmcuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jcmVhdGVSZWN1cnJ5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0SG9sZGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fcmVvcmRlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3JlcGxhY2VIb2xkZXJzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY3JlYXRlSHlicmlkLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY3JlYXRlQ3VycnkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jcmVhdGVQYXJ0aWFsLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbWVyZ2VEYXRhLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy90b051bWJlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdG9GaW5pdGUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3RvSW50ZWdlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NyZWF0ZVdyYXAuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2JpbmQuanMiLCIuLi9zcmMvSHR0cC9SZXF1ZXN0L1JlcXVlc3RPcHRpb25zLmpzIiwiLi4vc3JjL0h0dHAvUmVxdWVzdC9UcmFuc2Zvcm1SZXF1ZXN0LmpzIiwiLi4vc3JjL0h0dHAvUmVxdWVzdC9UcmFuc2Zvcm1SZXNwb25zZS5qcyIsIi4uL3NyYy9IdHRwL1JlcXVlc3QvUmVxdWVzdC5qcyIsIi4uL3NyYy9IdHRwL01vZGVsL01vZGVsLmpzIiwiLi4vc3JjL0NvbXBvbmVudHMvQmFzZUZvcm0vQmFzZUZvcm0udnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvQmFzZUZvcm0vaW5kZXguanMiLCIuLi9zcmMvQ29tcG9uZW50cy9CcmVhZGNydW1iL0JyZWFkY3J1bWJJdGVtLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL0JyZWFkY3J1bWIvQnJlYWRjcnVtYi52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9CcmVhZGNydW1iL2luZGV4LmpzIiwiLi4vc3JjL01peGlucy9TaXplYWJsZS9TaXplYWJsZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvbmVnYXRlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9vbWl0QnkuanMiLCIuLi9zcmMvTWl4aW5zL0NvbG9yYWJsZS9Db2xvcmFibGUuanMiLCIuLi9zcmMvQ29tcG9uZW50cy9CdG4vQnRuLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL0J0bi9pbmRleC5qcyIsIi4uL3NyYy9NaXhpbnMvU2NyZWVucmVhZGVycy9TY3JlZW5yZWFkZXJzLmpzIiwiLi4vc3JjL0NvbXBvbmVudHMvSGVscFRleHQvSGVscFRleHQudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvSGVscFRleHQvaW5kZXguanMiLCIuLi9zcmMvQ29tcG9uZW50cy9Gb3JtR3JvdXAvRm9ybUdyb3VwLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL0Zvcm1Hcm91cC9pbmRleC5qcyIsIi4uL3NyYy9Db21wb25lbnRzL0Zvcm1MYWJlbC9Gb3JtTGFiZWwudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvRm9ybUxhYmVsL2luZGV4LmpzIiwiLi4vc3JjL0NvbXBvbmVudHMvRm9ybUZlZWRiYWNrL0Zvcm1GZWVkYmFjay52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9Gb3JtRmVlZGJhY2svaW5kZXguanMiLCIuLi9zcmMvTWl4aW5zL0Zvcm1Db250cm9sL0Zvcm1Db250cm9sLmpzIiwiLi4vc3JjL0NvbXBvbmVudHMvSW5wdXRGaWVsZC9JbnB1dEZpZWxkLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL0lucHV0RmllbGQvaW5kZXguanMiLCIuLi9zcmMvQ29tcG9uZW50cy9GaWxlRmllbGQvRmlsZUZpZWxkLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL0J0bkZpbGUvQnRuRmlsZS52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9CdG5GaWxlL2luZGV4LmpzIiwiLi4vc3JjL0NvbXBvbmVudHMvQnRuR3JvdXAvQnRuR3JvdXAudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvQnRuR3JvdXAvQnRuR3JvdXBUb2dnbGUudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvQnRuR3JvdXAvQnRuVG9vbGJhci52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9CdG5Hcm91cC9pbmRleC5qcyIsIi4uL3NyYy9IZWxwZXJzL1V1aWQvVXVpZC5qcyIsIi4uL3NyYy9NaXhpbnMvUHJveHkvUHJveHkuanMiLCIuLi9zcmMvQ29tcG9uZW50cy9Ecm9wZG93bk1lbnUvRHJvcGRvd25NZW51SXRlbS52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9Ecm9wZG93bk1lbnUvRHJvcGRvd25NZW51SGVhZGVyLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL0Ryb3Bkb3duTWVudS9Ecm9wZG93bk1lbnVEaXZpZGVyLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL0Ryb3Bkb3duTWVudS9Ecm9wZG93bk1lbnUudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvRHJvcGRvd25NZW51L2luZGV4LmpzIiwiLi4vc3JjL0NvbXBvbmVudHMvQnRuRHJvcGRvd24vQnRuRHJvcGRvd24udnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvQnRuRHJvcGRvd24vaW5kZXguanMiLCIuLi9zcmMvTWl4aW5zL0hhc1Nsb3RzL0hhc1Nsb3RzLmpzIiwiLi4vc3JjL0NvbXBvbmVudHMvQ2FyZC9DYXJkLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL0NhcmQvQ2FyZEJvZHkudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvQ2FyZC9DYXJkQnRuR3JvdXAudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvQ2FyZC9DYXJkRGVjay52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9DYXJkL0NhcmRIZWFkZXIudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvQ2FyZC9DYXJkRm9vdGVyLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL0NhcmQvQ2FyZEltZy52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9DYXJkL0NhcmRJbWdUb3AudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvQ2FyZC9DYXJkSW1nQm90dG9tLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL0NhcmQvQ2FyZEltZ092ZXJsYXkudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvQ2FyZC9DYXJkTGluay52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9DYXJkL0NhcmRTdWJ0aXRsZS52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9DYXJkL0NhcmRUaXRsZS52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9DYXJkL2luZGV4LmpzIiwiLi4vc3JjL0NvbXBvbmVudHMvUmFkaW9GaWVsZC9SYWRpb0ZpZWxkLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL0NoZWNrYm94RmllbGQvQ2hlY2tib3hGaWVsZC52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9DaGVja2JveEZpZWxkL2luZGV4LmpzIiwiLi4vc3JjL0NvbXBvbmVudHMvRHJvcHpvbmUvRHJvcHpvbmUudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvRHJvcHpvbmUvaW5kZXguanMiLCIuLi9zcmMvQ29tcG9uZW50cy9GaWxlRmllbGQvaW5kZXguanMiLCIuLi9zcmMvSGVscGVycy9SZWFkRmlsZS9SZWFkRmlsZS5qcyIsIi4uL3NyYy9Db21wb25lbnRzL0ZpbGVQcmV2aWV3L0ZpbGVQcmV2aWV3LnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL0ZpbGVQcmV2aWV3L2luZGV4LmpzIiwiLi4vc3JjL0NvbXBvbmVudHMvRm9ybUNvbnRyb2wvRm9ybUNvbnRyb2wudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvRm9ybUNvbnRyb2wvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvaW50ZXJzZWN0aW9uLW9ic2VydmVyL2ludGVyc2VjdGlvbi1vYnNlcnZlci5qcyIsIi4uL3NyYy9Db21wb25lbnRzL0luZmluaXRlU2Nyb2xsaW5nL0luZmluaXRlU2Nyb2xsaW5nLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL0lucHV0R3JvdXAvSW5wdXRHcm91cFRleHQudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvSW5wdXRHcm91cC9JbnB1dEdyb3VwQXBwZW5kLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL0lucHV0R3JvdXAvSW5wdXRHcm91cFByZXBlbmQudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvSW5wdXRHcm91cC9JbnB1dEdyb3VwLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL0lucHV0R3JvdXAvaW5kZXguanMiLCIuLi9zcmMvQ29tcG9uZW50cy9MaWdodFN3aXRjaEZpZWxkL0xpZ2h0U3dpdGNoRmllbGQudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvTGlnaHRTd2l0Y2hGaWVsZC9pbmRleC5qcyIsIi4uL3NyYy9Db21wb25lbnRzL0xpc3RHcm91cC9MaXN0R3JvdXBJdGVtLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL0xpc3RHcm91cC9MaXN0R3JvdXAudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvTGlzdEdyb3VwL2luZGV4LmpzIiwiLi4vc3JjL0NvbXBvbmVudHMvTW9kYWwvaW5kZXguanMiLCIuLi9zcmMvQ29tcG9uZW50cy9OYXZiYXIvTmF2YmFyQnJhbmQudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvTmF2YmFyL05hdmJhckNvbGxhcHNlLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL05hdmJhci9OYXZiYXJUZXh0LnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL05hdmJhci9OYXZiYXJUb2dnbGVySWNvbi52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9OYXZiYXIvTmF2YmFyVG9nZ2xlci52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9OYXZiYXIvTmF2YmFyLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL05hdmlnYXRpb24vTmF2aWdhdGlvbkxpbmsudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvTmF2aWdhdGlvbi9OYXZpZ2F0aW9uSXRlbS52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9OYXZpZ2F0aW9uL05hdmlnYXRpb24udnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvTmF2aWdhdGlvbi9OYXZpZ2F0aW9uRHJvcGRvd24udnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvTmF2aWdhdGlvbi9pbmRleC5qcyIsIi4uL3NyYy9Db21wb25lbnRzL05hdmJhci9OYXZiYXJOYXYudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvTmF2YmFyL2luZGV4LmpzIiwiLi4vc3JjL0NvbXBvbmVudHMvT3ZlcmxheS9pbmRleC5qcyIsIi4uL3NyYy9Db21wb25lbnRzL1BhZ2luYXRpb24vUGFnaW5hdGlvbi52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9QYWdpbmF0aW9uL2luZGV4LmpzIiwiLi4vc3JjL0NvbXBvbmVudHMvUmFkaW9GaWVsZC9pbmRleC5qcyIsIi4uL3NyYy9Db21wb25lbnRzL1NlbGVjdEZpZWxkL1NlbGVjdEZpZWxkLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL1NlbGVjdEZpZWxkL2luZGV4LmpzIiwiLi4vc3JjL0NvbXBvbmVudHMvU2xpZGVEZWNrL1NsaWRlLnZ1ZSIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvZmluZEluZGV4LmpzIiwiLi4vc3JjL0NvbXBvbmVudHMvU2xpZGVEZWNrL1NsaWRlRGVja0NvbnRyb2xzLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL1NsaWRlRGVjay9TbGlkZURlY2sudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvU2xpZGVEZWNrL2luZGV4LmpzIiwiLi4vc3JjL0h0dHAvVHJhbnNmb3JtZXIvVHJhbnNmb3JtZXIuanMiLCIuLi9zcmMvSHR0cC9UYWJsZVZpZXdUcmFuc2Zvcm1lci9UYWJsZVZpZXdUcmFuc2Zvcm1lci5qcyIsIi4uL3NyYy9Db21wb25lbnRzL1RhYmxlVmlldy9UYWJsZVZpZXcudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvVGFibGVWaWV3L2luZGV4LmpzIiwiLi4vc3JjL0NvbXBvbmVudHMvVGV4dGFyZWFGaWVsZC9UZXh0YXJlYUZpZWxkLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL1RleHRhcmVhRmllbGQvaW5kZXguanMiLCIuLi9zcmMvQ29tcG9uZW50cy9UaHVtYm5haWxMaXN0L1RodW1ibmFpbExpc3RJdGVtLnZ1ZSIsIi4uL3NyYy9Db21wb25lbnRzL1RodW1ibmFpbExpc3QvVGh1bWJuYWlsTGlzdC52dWUiLCIuLi9zcmMvQ29tcG9uZW50cy9UaHVtYm5haWxMaXN0L2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9sYXN0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fcGFyZW50LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVVuc2V0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVB1bGxBdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvcmVtb3ZlLmpzIiwiLi4vc3JjL0NvbXBvbmVudHMvVXBsb2FkRmllbGQvVXBsb2FkRmllbGQudnVlIiwiLi4vc3JjL0NvbXBvbmVudHMvVXBsb2FkRmllbGQvaW5kZXguanMiLCIuLi9zcmMvRGlyZWN0aXZlcy9BdXRvZ3Jvdy9BdXRvZ3Jvdy5qcyIsIi4uL3NyYy9EaXJlY3RpdmVzL0F1dG9ncm93L2luZGV4LmpzIiwiLi4vc3JjL0RpcmVjdGl2ZXMvQ29sbGFwc2UvQ29sbGFwc2UuanMiLCIuLi9zcmMvRGlyZWN0aXZlcy9Db2xsYXBzZS9pbmRleC5qcyIsIi4uL3NyYy9IZWxwZXJzL0Jsb2IvQmxvYi5qcyIsIi4uL3NyYy9tYWluLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtb21lbnQgZnJvbSAnbW9tZW50JztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWUsIGZvcm1hdCkge1xuICAgIGlmKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBtb21lbnQoU3RyaW5nKHZhbHVlKSkuZm9ybWF0KGZvcm1hdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xufVxuIiwiaW1wb3J0IG1vbWVudCBmcm9tICdtb21lbnQnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZSwgZm9ybWF0KSB7XG4gICAgcmV0dXJuIHZhbHVlID8gbW9tZW50KFN0cmluZyh2YWx1ZSkpIDogbnVsbDtcbn1cbiIsImltcG9ydCBEYXRlRmlsdGVyIGZyb20gJy4vRGF0ZUZpbHRlcic7XG5pbXBvcnQgTW9tZW50RmlsdGVyIGZyb20gJy4vTW9tZW50RmlsdGVyJztcblxuZXhwb3J0IHtcbiAgICBEYXRlRmlsdGVyLFxuICAgIE1vbWVudEZpbHRlclxufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oVnVlLCBvcHRpb25zKSB7XG4gICAgVnVlLmZpbHRlcignZGF0ZScsIERhdGVGaWx0ZXIpO1xuICAgIFZ1ZS5maWx0ZXIoJ21vbWVudCcsIE1vbWVudEZpbHRlcik7XG59O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzT2JqZWN0O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbmV4cG9ydCBkZWZhdWx0IGlzQXJyYXk7XG4iLCJleHBvcnQgZGVmYXVsdCB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDpcbiAgICAgICAgICAgIHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6XG4gICAgICAgICAgICB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge31cbiIsIi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbmV4cG9ydCBkZWZhdWx0IGZyZWVHbG9iYWw7XG4iLCJpbXBvcnQgZnJlZUdsb2JhbCBmcm9tICcuL19mcmVlR2xvYmFsLmpzJztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG5leHBvcnQgZGVmYXVsdCByb290O1xuIiwiaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5leHBvcnQgZGVmYXVsdCBTeW1ib2w7XG4iLCJpbXBvcnQgU3ltYm9sIGZyb20gJy4vX1N5bWJvbC5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0UmF3VGFnO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG9iamVjdFRvU3RyaW5nO1xuIiwiaW1wb3J0IFN5bWJvbCBmcm9tICcuL19TeW1ib2wuanMnO1xuaW1wb3J0IGdldFJhd1RhZyBmcm9tICcuL19nZXRSYXdUYWcuanMnO1xuaW1wb3J0IG9iamVjdFRvU3RyaW5nIGZyb20gJy4vX29iamVjdFRvU3RyaW5nLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VHZXRUYWc7XG4iLCJpbXBvcnQgYmFzZUdldFRhZyBmcm9tICcuL19iYXNlR2V0VGFnLmpzJztcbmltcG9ydCBpc09iamVjdCBmcm9tICcuL2lzT2JqZWN0LmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNGdW5jdGlvbjtcbiIsImltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG52YXIgY29yZUpzRGF0YSA9IHJvb3RbJ19fY29yZS1qc19zaGFyZWRfXyddO1xuXG5leHBvcnQgZGVmYXVsdCBjb3JlSnNEYXRhO1xuIiwiaW1wb3J0IGNvcmVKc0RhdGEgZnJvbSAnLi9fY29yZUpzRGF0YS5qcyc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xufSgpKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzTWFza2VkO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5leHBvcnQgZGVmYXVsdCB0b1NvdXJjZTtcbiIsImltcG9ydCBpc0Z1bmN0aW9uIGZyb20gJy4vaXNGdW5jdGlvbi5qcyc7XG5pbXBvcnQgaXNNYXNrZWQgZnJvbSAnLi9faXNNYXNrZWQuanMnO1xuaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuaW1wb3J0IHRvU291cmNlIGZyb20gJy4vX3RvU291cmNlLmpzJztcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAqL1xudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUlzTmF0aXZlO1xuIiwiLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldFZhbHVlO1xuIiwiaW1wb3J0IGJhc2VJc05hdGl2ZSBmcm9tICcuL19iYXNlSXNOYXRpdmUuanMnO1xuaW1wb3J0IGdldFZhbHVlIGZyb20gJy4vX2dldFZhbHVlLmpzJztcblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcbiAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0TmF0aXZlO1xuIiwiaW1wb3J0IGdldE5hdGl2ZSBmcm9tICcuL19nZXROYXRpdmUuanMnO1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgdmFyIGZ1bmMgPSBnZXROYXRpdmUoT2JqZWN0LCAnZGVmaW5lUHJvcGVydHknKTtcbiAgICBmdW5jKHt9LCAnJywge30pO1xuICAgIHJldHVybiBmdW5jO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxuZXhwb3J0IGRlZmF1bHQgZGVmaW5lUHJvcGVydHk7XG4iLCJpbXBvcnQgZGVmaW5lUHJvcGVydHkgZnJvbSAnLi9fZGVmaW5lUHJvcGVydHkuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBhc3NpZ25WYWx1ZWAgYW5kIGBhc3NpZ25NZXJnZVZhbHVlYCB3aXRob3V0XG4gKiB2YWx1ZSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5ID09ICdfX3Byb3RvX18nICYmIGRlZmluZVByb3BlcnR5KSB7XG4gICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcbiAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICAgJ2VudW1lcmFibGUnOiB0cnVlLFxuICAgICAgJ3ZhbHVlJzogdmFsdWUsXG4gICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlQXNzaWduVmFsdWU7XG4iLCIvKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZXE7XG4iLCJpbXBvcnQgYmFzZUFzc2lnblZhbHVlIGZyb20gJy4vX2Jhc2VBc3NpZ25WYWx1ZS5qcyc7XG5pbXBvcnQgZXEgZnJvbSAnLi9lcS5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQXNzaWducyBgdmFsdWVgIHRvIGBrZXlgIG9mIGBvYmplY3RgIGlmIHRoZSBleGlzdGluZyB2YWx1ZSBpcyBub3QgZXF1aXZhbGVudFxuICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV07XG4gIGlmICghKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGVxKG9ialZhbHVlLCB2YWx1ZSkpIHx8XG4gICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFzc2lnblZhbHVlO1xuIiwiaW1wb3J0IGFzc2lnblZhbHVlIGZyb20gJy4vX2Fzc2lnblZhbHVlLmpzJztcbmltcG9ydCBiYXNlQXNzaWduVmFsdWUgZnJvbSAnLi9fYmFzZUFzc2lnblZhbHVlLmpzJztcblxuLyoqXG4gKiBDb3BpZXMgcHJvcGVydGllcyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzIHRvIGNvcHkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG8uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb3BpZWQgdmFsdWVzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weU9iamVjdChzb3VyY2UsIHByb3BzLCBvYmplY3QsIGN1c3RvbWl6ZXIpIHtcbiAgdmFyIGlzTmV3ID0gIW9iamVjdDtcbiAgb2JqZWN0IHx8IChvYmplY3QgPSB7fSk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuXG4gICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgPyBjdXN0b21pemVyKG9iamVjdFtrZXldLCBzb3VyY2Vba2V5XSwga2V5LCBvYmplY3QsIHNvdXJjZSlcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG5ld1ZhbHVlID0gc291cmNlW2tleV07XG4gICAgfVxuICAgIGlmIChpc05ldykge1xuICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNvcHlPYmplY3Q7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IGl0IHJlY2VpdmVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICpcbiAqIGNvbnNvbGUubG9nKF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpZGVudGl0eTtcbiIsIi8qKlxuICogQSBmYXN0ZXIgYWx0ZXJuYXRpdmUgdG8gYEZ1bmN0aW9uI2FwcGx5YCwgdGhpcyBmdW5jdGlvbiBpbnZva2VzIGBmdW5jYFxuICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgIGFuZCB0aGUgYXJndW1lbnRzIG9mIGBhcmdzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5KGZ1bmMsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnKTtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgfVxuICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXBwbHk7XG4iLCJpbXBvcnQgYXBwbHkgZnJvbSAnLi9fYXBwbHkuanMnO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXg7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUmVzdGAgd2hpY2ggdHJhbnNmb3JtcyB0aGUgcmVzdCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgcmVzdCBhcnJheSB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlclJlc3QoZnVuYywgc3RhcnQsIHRyYW5zZm9ybSkge1xuICBzdGFydCA9IG5hdGl2ZU1heChzdGFydCA9PT0gdW5kZWZpbmVkID8gKGZ1bmMubGVuZ3RoIC0gMSkgOiBzdGFydCwgMCk7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3MubGVuZ3RoIC0gc3RhcnQsIDApLFxuICAgICAgICBhcnJheSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgYXJyYXlbaW5kZXhdID0gYXJnc1tzdGFydCArIGluZGV4XTtcbiAgICB9XG4gICAgaW5kZXggPSAtMTtcbiAgICB2YXIgb3RoZXJBcmdzID0gQXJyYXkoc3RhcnQgKyAxKTtcbiAgICB3aGlsZSAoKytpbmRleCA8IHN0YXJ0KSB7XG4gICAgICBvdGhlckFyZ3NbaW5kZXhdID0gYXJnc1tpbmRleF07XG4gICAgfVxuICAgIG90aGVyQXJnc1tzdGFydF0gPSB0cmFuc2Zvcm0oYXJyYXkpO1xuICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzLCBvdGhlckFyZ3MpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBvdmVyUmVzdDtcbiIsIi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgdmFsdWVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4gZnJvbSB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29uc3RhbnQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gXy50aW1lcygyLCBfLmNvbnN0YW50KHsgJ2EnOiAxIH0pKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhvYmplY3RzKTtcbiAqIC8vID0+IFt7ICdhJzogMSB9LCB7ICdhJzogMSB9XVxuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHNbMF0gPT09IG9iamVjdHNbMV0pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBjb25zdGFudCh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjb25zdGFudDtcbiIsImltcG9ydCBjb25zdGFudCBmcm9tICcuL2NvbnN0YW50LmpzJztcbmltcG9ydCBkZWZpbmVQcm9wZXJ0eSBmcm9tICcuL19kZWZpbmVQcm9wZXJ0eS5qcyc7XG5pbXBvcnQgaWRlbnRpdHkgZnJvbSAnLi9pZGVudGl0eS5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldFRvU3RyaW5nYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIHNob3J0aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIGJhc2VTZXRUb1N0cmluZyA9ICFkZWZpbmVQcm9wZXJ0eSA/IGlkZW50aXR5IDogZnVuY3Rpb24oZnVuYywgc3RyaW5nKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eShmdW5jLCAndG9TdHJpbmcnLCB7XG4gICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgJ2VudW1lcmFibGUnOiBmYWxzZSxcbiAgICAndmFsdWUnOiBjb25zdGFudChzdHJpbmcpLFxuICAgICd3cml0YWJsZSc6IHRydWVcbiAgfSk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBiYXNlU2V0VG9TdHJpbmc7XG4iLCIvKiogVXNlZCB0byBkZXRlY3QgaG90IGZ1bmN0aW9ucyBieSBudW1iZXIgb2YgY2FsbHMgd2l0aGluIGEgc3BhbiBvZiBtaWxsaXNlY29uZHMuICovXG52YXIgSE9UX0NPVU5UID0gODAwLFxuICAgIEhPVF9TUEFOID0gMTY7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVOb3cgPSBEYXRlLm5vdztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCdsbCBzaG9ydCBvdXQgYW5kIGludm9rZSBgaWRlbnRpdHlgIGluc3RlYWRcbiAqIG9mIGBmdW5jYCB3aGVuIGl0J3MgY2FsbGVkIGBIT1RfQ09VTlRgIG9yIG1vcmUgdGltZXMgaW4gYEhPVF9TUEFOYFxuICogbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNob3J0YWJsZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gc2hvcnRPdXQoZnVuYykge1xuICB2YXIgY291bnQgPSAwLFxuICAgICAgbGFzdENhbGxlZCA9IDA7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGFtcCA9IG5hdGl2ZU5vdygpLFxuICAgICAgICByZW1haW5pbmcgPSBIT1RfU1BBTiAtIChzdGFtcCAtIGxhc3RDYWxsZWQpO1xuXG4gICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgICBpZiAoKytjb3VudCA+PSBIT1RfQ09VTlQpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IHNob3J0T3V0O1xuIiwiaW1wb3J0IGJhc2VTZXRUb1N0cmluZyBmcm9tICcuL19iYXNlU2V0VG9TdHJpbmcuanMnO1xuaW1wb3J0IHNob3J0T3V0IGZyb20gJy4vX3Nob3J0T3V0LmpzJztcblxuLyoqXG4gKiBTZXRzIHRoZSBgdG9TdHJpbmdgIG1ldGhvZCBvZiBgZnVuY2AgdG8gcmV0dXJuIGBzdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIHNldFRvU3RyaW5nID0gc2hvcnRPdXQoYmFzZVNldFRvU3RyaW5nKTtcblxuZXhwb3J0IGRlZmF1bHQgc2V0VG9TdHJpbmc7XG4iLCJpbXBvcnQgaWRlbnRpdHkgZnJvbSAnLi9pZGVudGl0eS5qcyc7XG5pbXBvcnQgb3ZlclJlc3QgZnJvbSAnLi9fb3ZlclJlc3QuanMnO1xuaW1wb3J0IHNldFRvU3RyaW5nIGZyb20gJy4vX3NldFRvU3RyaW5nLmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZXN0YCB3aGljaCBkb2Vzbid0IHZhbGlkYXRlIG9yIGNvZXJjZSBhcmd1bWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVJlc3QoZnVuYywgc3RhcnQpIHtcbiAgcmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCBpZGVudGl0eSksIGZ1bmMgKyAnJyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VSZXN0O1xuIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0xlbmd0aDtcbiIsImltcG9ydCBpc0Z1bmN0aW9uIGZyb20gJy4vaXNGdW5jdGlvbi5qcyc7XG5pbXBvcnQgaXNMZW5ndGggZnJvbSAnLi9pc0xlbmd0aC5qcyc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0FycmF5TGlrZTtcbiIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuXG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlID09ICdudW1iZXInIHx8XG4gICAgICAodHlwZSAhPSAnc3ltYm9sJyAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkpICYmXG4gICAgICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNJbmRleDtcbiIsImltcG9ydCBlcSBmcm9tICcuL2VxLmpzJztcbmltcG9ydCBpc0FycmF5TGlrZSBmcm9tICcuL2lzQXJyYXlMaWtlLmpzJztcbmltcG9ydCBpc0luZGV4IGZyb20gJy4vX2lzSW5kZXguanMnO1xuaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSB2YWx1ZSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gaW5kZXggVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBpbmRleCBvciBrZXkgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIG9iamVjdCBhcmd1bWVudC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHR5cGUgPSB0eXBlb2YgaW5kZXg7XG4gIGlmICh0eXBlID09ICdudW1iZXInXG4gICAgICAgID8gKGlzQXJyYXlMaWtlKG9iamVjdCkgJiYgaXNJbmRleChpbmRleCwgb2JqZWN0Lmxlbmd0aCkpXG4gICAgICAgIDogKHR5cGUgPT0gJ3N0cmluZycgJiYgaW5kZXggaW4gb2JqZWN0KVxuICAgICAgKSB7XG4gICAgcmV0dXJuIGVxKG9iamVjdFtpbmRleF0sIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzSXRlcmF0ZWVDYWxsO1xuIiwiaW1wb3J0IGJhc2VSZXN0IGZyb20gJy4vX2Jhc2VSZXN0LmpzJztcbmltcG9ydCBpc0l0ZXJhdGVlQ2FsbCBmcm9tICcuL19pc0l0ZXJhdGVlQ2FsbC5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uYXNzaWduYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gYXNzaWduZXIgVGhlIGZ1bmN0aW9uIHRvIGFzc2lnbiB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhc3NpZ25lciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQXNzaWduZXIoYXNzaWduZXIpIHtcbiAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwgc291cmNlcykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBzb3VyY2VzLmxlbmd0aCxcbiAgICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA+IDEgPyBzb3VyY2VzW2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkLFxuICAgICAgICBndWFyZCA9IGxlbmd0aCA+IDIgPyBzb3VyY2VzWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgY3VzdG9taXplciA9IChhc3NpZ25lci5sZW5ndGggPiAzICYmIHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicpXG4gICAgICA/IChsZW5ndGgtLSwgY3VzdG9taXplcilcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiBjdXN0b21pemVyO1xuICAgICAgbGVuZ3RoID0gMTtcbiAgICB9XG4gICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgYXNzaWduZXIob2JqZWN0LCBzb3VyY2UsIGluZGV4LCBjdXN0b21pemVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZUFzc2lnbmVyO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVRpbWVzO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzT2JqZWN0TGlrZTtcbiIsImltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqL1xuZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VJc0FyZ3VtZW50cztcbiIsImltcG9ydCBiYXNlSXNBcmd1bWVudHMgZnJvbSAnLi9fYmFzZUlzQXJndW1lbnRzLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgaXNBcmd1bWVudHM7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0dWJGYWxzZTtcbiIsImltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuaW1wb3J0IHN0dWJGYWxzZSBmcm9tICcuL3N0dWJGYWxzZS5qcyc7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZTtcblxuZXhwb3J0IGRlZmF1bHQgaXNCdWZmZXI7XG4iLCJpbXBvcnQgYmFzZUdldFRhZyBmcm9tICcuL19iYXNlR2V0VGFnLmpzJztcbmltcG9ydCBpc0xlbmd0aCBmcm9tICcuL2lzTGVuZ3RoLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG52YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xudHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxudHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxudHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJlxuICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VJc1R5cGVkQXJyYXk7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VVbmFyeTtcbiIsImltcG9ydCBmcmVlR2xvYmFsIGZyb20gJy4vX2ZyZWVHbG9iYWwuanMnO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTtcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbmV4cG9ydCBkZWZhdWx0IG5vZGVVdGlsO1xuIiwiaW1wb3J0IGJhc2VJc1R5cGVkQXJyYXkgZnJvbSAnLi9fYmFzZUlzVHlwZWRBcnJheS5qcyc7XG5pbXBvcnQgYmFzZVVuYXJ5IGZyb20gJy4vX2Jhc2VVbmFyeS5qcyc7XG5pbXBvcnQgbm9kZVV0aWwgZnJvbSAnLi9fbm9kZVV0aWwuanMnO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxuZXhwb3J0IGRlZmF1bHQgaXNUeXBlZEFycmF5O1xuIiwiaW1wb3J0IGJhc2VUaW1lcyBmcm9tICcuL19iYXNlVGltZXMuanMnO1xuaW1wb3J0IGlzQXJndW1lbnRzIGZyb20gJy4vaXNBcmd1bWVudHMuanMnO1xuaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5LmpzJztcbmltcG9ydCBpc0J1ZmZlciBmcm9tICcuL2lzQnVmZmVyLmpzJztcbmltcG9ydCBpc0luZGV4IGZyb20gJy4vX2lzSW5kZXguanMnO1xuaW1wb3J0IGlzVHlwZWRBcnJheSBmcm9tICcuL2lzVHlwZWRBcnJheS5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKSxcbiAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzKHZhbHVlKSxcbiAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIodmFsdWUpLFxuICAgICAgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheSh2YWx1ZSksXG4gICAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsXG4gICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoXG4gICAgICAgICAgIC8vIFNhZmFyaSA5IGhhcyBlbnVtZXJhYmxlIGBhcmd1bWVudHMubGVuZ3RoYCBpbiBzdHJpY3QgbW9kZS5cbiAgICAgICAgICAga2V5ID09ICdsZW5ndGgnIHx8XG4gICAgICAgICAgIC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuICAgICAgICAgICAoaXNCdWZmICYmIChrZXkgPT0gJ29mZnNldCcgfHwga2V5ID09ICdwYXJlbnQnKSkgfHxcbiAgICAgICAgICAgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuICAgICAgICAgICAoaXNUeXBlICYmIChrZXkgPT0gJ2J1ZmZlcicgfHwga2V5ID09ICdieXRlTGVuZ3RoJyB8fCBrZXkgPT0gJ2J5dGVPZmZzZXQnKSkgfHxcbiAgICAgICAgICAgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICBpc0luZGV4KGtleSwgbGVuZ3RoKVxuICAgICAgICApKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXJyYXlMaWtlS2V5cztcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNQcm90b3R5cGU7XG4iLCIvKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZVxuICogW2BPYmplY3Qua2V5c2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZXhjZXB0IHRoYXQgaXQgaW5jbHVkZXMgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gbmF0aXZlS2V5c0luKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChvYmplY3QgIT0gbnVsbCkge1xuICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbmF0aXZlS2V5c0luO1xuIiwiaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuaW1wb3J0IGlzUHJvdG90eXBlIGZyb20gJy4vX2lzUHJvdG90eXBlLmpzJztcbmltcG9ydCBuYXRpdmVLZXlzSW4gZnJvbSAnLi9fbmF0aXZlS2V5c0luLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzSW5gIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXNJbihvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXNJbihvYmplY3QpO1xuICB9XG4gIHZhciBpc1Byb3RvID0gaXNQcm90b3R5cGUob2JqZWN0KSxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICBpZiAoIShrZXkgPT0gJ2NvbnN0cnVjdG9yJyAmJiAoaXNQcm90byB8fCAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUtleXNJbjtcbiIsImltcG9ydCBhcnJheUxpa2VLZXlzIGZyb20gJy4vX2FycmF5TGlrZUtleXMuanMnO1xuaW1wb3J0IGJhc2VLZXlzSW4gZnJvbSAnLi9fYmFzZUtleXNJbi5qcyc7XG5pbXBvcnQgaXNBcnJheUxpa2UgZnJvbSAnLi9pc0FycmF5TGlrZS5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXNJbihuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJywgJ2MnXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICovXG5mdW5jdGlvbiBrZXlzSW4ob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QsIHRydWUpIDogYmFzZUtleXNJbihvYmplY3QpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBrZXlzSW47XG4iLCJpbXBvcnQgY29weU9iamVjdCBmcm9tICcuL19jb3B5T2JqZWN0LmpzJztcbmltcG9ydCBjcmVhdGVBc3NpZ25lciBmcm9tICcuL19jcmVhdGVBc3NpZ25lci5qcyc7XG5pbXBvcnQga2V5c0luIGZyb20gJy4va2V5c0luLmpzJztcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBvd24gYW5kXG4gKiBpbmhlcml0ZWQgc291cmNlIHByb3BlcnRpZXMuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGFsaWFzIGV4dGVuZFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICogQHNlZSBfLmFzc2lnblxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiB9XG4gKlxuICogZnVuY3Rpb24gQmFyKCkge1xuICogICB0aGlzLmMgPSAzO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYiA9IDI7XG4gKiBCYXIucHJvdG90eXBlLmQgPSA0O1xuICpcbiAqIF8uYXNzaWduSW4oeyAnYSc6IDAgfSwgbmV3IEZvbywgbmV3IEJhcik7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMsICdkJzogNCB9XG4gKi9cbnZhciBhc3NpZ25JbiA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlKSB7XG4gIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzSW4oc291cmNlKSwgb2JqZWN0KTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBhc3NpZ25JbjtcbiIsIi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbGlzdENhY2hlQ2xlYXI7XG4iLCJpbXBvcnQgZXEgZnJvbSAnLi9lcS5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFzc29jSW5kZXhPZjtcbiIsImltcG9ydCBhc3NvY0luZGV4T2YgZnJvbSAnLi9fYXNzb2NJbmRleE9mLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgZGF0YS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gIH1cbiAgLS10aGlzLnNpemU7XG4gIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBsaXN0Q2FjaGVEZWxldGU7XG4iLCJpbXBvcnQgYXNzb2NJbmRleE9mIGZyb20gJy4vX2Fzc29jSW5kZXhPZi5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGxpc3RDYWNoZUdldDtcbiIsImltcG9ydCBhc3NvY0luZGV4T2YgZnJvbSAnLi9fYXNzb2NJbmRleE9mLmpzJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGxpc3RDYWNoZUhhcztcbiIsImltcG9ydCBhc3NvY0luZGV4T2YgZnJvbSAnLi9fYXNzb2NJbmRleE9mLmpzJztcblxuLyoqXG4gKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICArK3RoaXMuc2l6ZTtcbiAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG5leHBvcnQgZGVmYXVsdCBsaXN0Q2FjaGVTZXQ7XG4iLCJpbXBvcnQgbGlzdENhY2hlQ2xlYXIgZnJvbSAnLi9fbGlzdENhY2hlQ2xlYXIuanMnO1xuaW1wb3J0IGxpc3RDYWNoZURlbGV0ZSBmcm9tICcuL19saXN0Q2FjaGVEZWxldGUuanMnO1xuaW1wb3J0IGxpc3RDYWNoZUdldCBmcm9tICcuL19saXN0Q2FjaGVHZXQuanMnO1xuaW1wb3J0IGxpc3RDYWNoZUhhcyBmcm9tICcuL19saXN0Q2FjaGVIYXMuanMnO1xuaW1wb3J0IGxpc3RDYWNoZVNldCBmcm9tICcuL19saXN0Q2FjaGVTZXQuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbkxpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbmV4cG9ydCBkZWZhdWx0IExpc3RDYWNoZTtcbiIsImltcG9ydCBMaXN0Q2FjaGUgZnJvbSAnLi9fTGlzdENhY2hlLmpzJztcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBTdGFja1xuICovXG5mdW5jdGlvbiBzdGFja0NsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3RhY2tDbGVhcjtcbiIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICByZXN1bHQgPSBkYXRhWydkZWxldGUnXShrZXkpO1xuXG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3RhY2tEZWxldGU7XG4iLCIvKipcbiAqIEdldHMgdGhlIHN0YWNrIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzdGFja0dldChrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGtleSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0YWNrR2V0O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3RhY2tIYXM7XG4iLCJpbXBvcnQgZ2V0TmF0aXZlIGZyb20gJy4vX2dldE5hdGl2ZS5qcyc7XG5pbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIE1hcCA9IGdldE5hdGl2ZShyb290LCAnTWFwJyk7XG5cbmV4cG9ydCBkZWZhdWx0IE1hcDtcbiIsImltcG9ydCBnZXROYXRpdmUgZnJvbSAnLi9fZ2V0TmF0aXZlLmpzJztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxuZXhwb3J0IGRlZmF1bHQgbmF0aXZlQ3JlYXRlO1xuIiwiaW1wb3J0IG5hdGl2ZUNyZWF0ZSBmcm9tICcuL19uYXRpdmVDcmVhdGUuanMnO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaGFzaENsZWFyO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaGFzaERlbGV0ZTtcbiIsImltcG9ydCBuYXRpdmVDcmVhdGUgZnJvbSAnLi9fbmF0aXZlQ3JlYXRlLmpzJztcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBoYXNoR2V0O1xuIiwiaW1wb3J0IG5hdGl2ZUNyZWF0ZSBmcm9tICcuL19uYXRpdmVDcmVhdGUuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IChkYXRhW2tleV0gIT09IHVuZGVmaW5lZCkgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGhhc2hIYXM7XG4iLCJpbXBvcnQgbmF0aXZlQ3JlYXRlIGZyb20gJy4vX25hdGl2ZUNyZWF0ZS5qcyc7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqXG4gKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaGFzaCBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgdGhpcy5zaXplICs9IHRoaXMuaGFzKGtleSkgPyAwIDogMTtcbiAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gIHJldHVybiB0aGlzO1xufVxuXG5leHBvcnQgZGVmYXVsdCBoYXNoU2V0O1xuIiwiaW1wb3J0IGhhc2hDbGVhciBmcm9tICcuL19oYXNoQ2xlYXIuanMnO1xuaW1wb3J0IGhhc2hEZWxldGUgZnJvbSAnLi9faGFzaERlbGV0ZS5qcyc7XG5pbXBvcnQgaGFzaEdldCBmcm9tICcuL19oYXNoR2V0LmpzJztcbmltcG9ydCBoYXNoSGFzIGZyb20gJy4vX2hhc2hIYXMuanMnO1xuaW1wb3J0IGhhc2hTZXQgZnJvbSAnLi9faGFzaFNldC5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG5leHBvcnQgZGVmYXVsdCBIYXNoO1xuIiwiaW1wb3J0IEhhc2ggZnJvbSAnLi9fSGFzaC5qcyc7XG5pbXBvcnQgTGlzdENhY2hlIGZyb20gJy4vX0xpc3RDYWNoZS5qcyc7XG5pbXBvcnQgTWFwIGZyb20gJy4vX01hcC5qcyc7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuc2l6ZSA9IDA7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWFwQ2FjaGVDbGVhcjtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNLZXlhYmxlO1xuIiwiaW1wb3J0IGlzS2V5YWJsZSBmcm9tICcuL19pc0tleWFibGUuanMnO1xuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldE1hcERhdGE7XG4iLCJpbXBvcnQgZ2V0TWFwRGF0YSBmcm9tICcuL19nZXRNYXBEYXRhLmpzJztcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1hcENhY2hlRGVsZXRlO1xuIiwiaW1wb3J0IGdldE1hcERhdGEgZnJvbSAnLi9fZ2V0TWFwRGF0YS5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWFwQ2FjaGVHZXQ7XG4iLCJpbXBvcnQgZ2V0TWFwRGF0YSBmcm9tICcuL19nZXRNYXBEYXRhLmpzJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWFwQ2FjaGVIYXM7XG4iLCJpbXBvcnQgZ2V0TWFwRGF0YSBmcm9tICcuL19nZXRNYXBEYXRhLmpzJztcblxuLyoqXG4gKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLFxuICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplICs9IGRhdGEuc2l6ZSA9PSBzaXplID8gMCA6IDE7XG4gIHJldHVybiB0aGlzO1xufVxuXG5leHBvcnQgZGVmYXVsdCBtYXBDYWNoZVNldDtcbiIsImltcG9ydCBtYXBDYWNoZUNsZWFyIGZyb20gJy4vX21hcENhY2hlQ2xlYXIuanMnO1xuaW1wb3J0IG1hcENhY2hlRGVsZXRlIGZyb20gJy4vX21hcENhY2hlRGVsZXRlLmpzJztcbmltcG9ydCBtYXBDYWNoZUdldCBmcm9tICcuL19tYXBDYWNoZUdldC5qcyc7XG5pbXBvcnQgbWFwQ2FjaGVIYXMgZnJvbSAnLi9fbWFwQ2FjaGVIYXMuanMnO1xuaW1wb3J0IG1hcENhY2hlU2V0IGZyb20gJy4vX21hcENhY2hlU2V0LmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbmV4cG9ydCBkZWZhdWx0IE1hcENhY2hlO1xuIiwiaW1wb3J0IExpc3RDYWNoZSBmcm9tICcuL19MaXN0Q2FjaGUuanMnO1xuaW1wb3J0IE1hcCBmcm9tICcuL19NYXAuanMnO1xuaW1wb3J0IE1hcENhY2hlIGZyb20gJy4vX01hcENhY2hlLmpzJztcblxuLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG52YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuLyoqXG4gKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBzdGFjayBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgTGlzdENhY2hlKSB7XG4gICAgdmFyIHBhaXJzID0gZGF0YS5fX2RhdGFfXztcbiAgICBpZiAoIU1hcCB8fCAocGFpcnMubGVuZ3RoIDwgTEFSR0VfQVJSQVlfU0laRSAtIDEpKSB7XG4gICAgICBwYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICB0aGlzLnNpemUgPSArK2RhdGEuc2l6ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZShwYWlycyk7XG4gIH1cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0YWNrU2V0O1xuIiwiaW1wb3J0IExpc3RDYWNoZSBmcm9tICcuL19MaXN0Q2FjaGUuanMnO1xuaW1wb3J0IHN0YWNrQ2xlYXIgZnJvbSAnLi9fc3RhY2tDbGVhci5qcyc7XG5pbXBvcnQgc3RhY2tEZWxldGUgZnJvbSAnLi9fc3RhY2tEZWxldGUuanMnO1xuaW1wb3J0IHN0YWNrR2V0IGZyb20gJy4vX3N0YWNrR2V0LmpzJztcbmltcG9ydCBzdGFja0hhcyBmcm9tICcuL19zdGFja0hhcy5qcyc7XG5pbXBvcnQgc3RhY2tTZXQgZnJvbSAnLi9fc3RhY2tTZXQuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoZW50cmllcyk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFN0YWNrYC5cblN0YWNrLnByb3RvdHlwZS5jbGVhciA9IHN0YWNrQ2xlYXI7XG5TdGFjay5wcm90b3R5cGVbJ2RlbGV0ZSddID0gc3RhY2tEZWxldGU7XG5TdGFjay5wcm90b3R5cGUuZ2V0ID0gc3RhY2tHZXQ7XG5TdGFjay5wcm90b3R5cGUuaGFzID0gc3RhY2tIYXM7XG5TdGFjay5wcm90b3R5cGUuc2V0ID0gc3RhY2tTZXQ7XG5cbmV4cG9ydCBkZWZhdWx0IFN0YWNrO1xuIiwiaW1wb3J0IGJhc2VBc3NpZ25WYWx1ZSBmcm9tICcuL19iYXNlQXNzaWduVmFsdWUuanMnO1xuaW1wb3J0IGVxIGZyb20gJy4vZXEuanMnO1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYXNzaWduVmFsdWVgIGV4Y2VwdCB0aGF0IGl0IGRvZXNuJ3QgYXNzaWduXG4gKiBgdW5kZWZpbmVkYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgaWYgKCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmICFlcShvYmplY3Rba2V5XSwgdmFsdWUpKSB8fFxuICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBhc3NpZ25NZXJnZVZhbHVlO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgYmFzZSBmdW5jdGlvbiBmb3IgbWV0aG9kcyBsaWtlIGBfLmZvckluYCBhbmQgYF8uZm9yT3duYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVCYXNlRm9yKGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSwga2V5c0Z1bmMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgaXRlcmFibGUgPSBPYmplY3Qob2JqZWN0KSxcbiAgICAgICAgcHJvcHMgPSBrZXlzRnVuYyhvYmplY3QpLFxuICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wc1tmcm9tUmlnaHQgPyBsZW5ndGggOiArK2luZGV4XTtcbiAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZUJhc2VGb3I7XG4iLCJpbXBvcnQgY3JlYXRlQmFzZUZvciBmcm9tICcuL19jcmVhdGVCYXNlRm9yLmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYmFzZUZvck93bmAgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgb2JqZWN0YFxuICogcHJvcGVydGllcyByZXR1cm5lZCBieSBga2V5c0Z1bmNgIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuXG4gKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbnZhciBiYXNlRm9yID0gY3JlYXRlQmFzZUZvcigpO1xuXG5leHBvcnQgZGVmYXVsdCBiYXNlRm9yO1xuIiwiaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgIGFsbG9jVW5zYWZlID0gQnVmZmVyID8gQnVmZmVyLmFsbG9jVW5zYWZlIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiAgYGJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgVGhlIGJ1ZmZlciB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBjbG9uZUJ1ZmZlcihidWZmZXIsIGlzRGVlcCkge1xuICBpZiAoaXNEZWVwKSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5zbGljZSgpO1xuICB9XG4gIHZhciBsZW5ndGggPSBidWZmZXIubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gYWxsb2NVbnNhZmUgPyBhbGxvY1Vuc2FmZShsZW5ndGgpIDogbmV3IGJ1ZmZlci5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gIGJ1ZmZlci5jb3B5KHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsb25lQnVmZmVyO1xuIiwiaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFVpbnQ4QXJyYXkgPSByb290LlVpbnQ4QXJyYXk7XG5cbmV4cG9ydCBkZWZhdWx0IFVpbnQ4QXJyYXk7XG4iLCJpbXBvcnQgVWludDhBcnJheSBmcm9tICcuL19VaW50OEFycmF5LmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGFycmF5QnVmZmVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYXJyYXlCdWZmZXIgVGhlIGFycmF5IGJ1ZmZlciB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGFycmF5IGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY2xvbmVBcnJheUJ1ZmZlcihhcnJheUJ1ZmZlcikge1xuICB2YXIgcmVzdWx0ID0gbmV3IGFycmF5QnVmZmVyLmNvbnN0cnVjdG9yKGFycmF5QnVmZmVyLmJ5dGVMZW5ndGgpO1xuICBuZXcgVWludDhBcnJheShyZXN1bHQpLnNldChuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcikpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbG9uZUFycmF5QnVmZmVyO1xuIiwiaW1wb3J0IGNsb25lQXJyYXlCdWZmZXIgZnJvbSAnLi9fY2xvbmVBcnJheUJ1ZmZlci5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGB0eXBlZEFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHR5cGVkQXJyYXkgVGhlIHR5cGVkIGFycmF5IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCB0eXBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2xvbmVUeXBlZEFycmF5KHR5cGVkQXJyYXksIGlzRGVlcCkge1xuICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcih0eXBlZEFycmF5LmJ1ZmZlcikgOiB0eXBlZEFycmF5LmJ1ZmZlcjtcbiAgcmV0dXJuIG5ldyB0eXBlZEFycmF5LmNvbnN0cnVjdG9yKGJ1ZmZlciwgdHlwZWRBcnJheS5ieXRlT2Zmc2V0LCB0eXBlZEFycmF5Lmxlbmd0aCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsb25lVHlwZWRBcnJheTtcbiIsIi8qKlxuICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgYHNvdXJjZWAgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgdG8uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gY29weUFycmF5KHNvdXJjZSwgYXJyYXkpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuXG4gIGFycmF5IHx8IChhcnJheSA9IEFycmF5KGxlbmd0aCkpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjb3B5QXJyYXk7XG4iLCJpbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdC5qcyc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY3JlYXRlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFzc2lnbmluZ1xuICogcHJvcGVydGllcyB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90byBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKi9cbnZhciBiYXNlQ3JlYXRlID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBvYmplY3QoKSB7fVxuICByZXR1cm4gZnVuY3Rpb24ocHJvdG8pIHtcbiAgICBpZiAoIWlzT2JqZWN0KHByb3RvKSkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBpZiAob2JqZWN0Q3JlYXRlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0Q3JlYXRlKHByb3RvKTtcbiAgICB9XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHByb3RvO1xuICAgIHZhciByZXN1bHQgPSBuZXcgb2JqZWN0O1xuICAgIG9iamVjdC5wcm90b3R5cGUgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn0oKSk7XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VDcmVhdGU7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgb3ZlckFyZztcbiIsImltcG9ydCBvdmVyQXJnIGZyb20gJy4vX292ZXJBcmcuanMnO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBnZXRQcm90b3R5cGUgPSBvdmVyQXJnKE9iamVjdC5nZXRQcm90b3R5cGVPZiwgT2JqZWN0KTtcblxuZXhwb3J0IGRlZmF1bHQgZ2V0UHJvdG90eXBlO1xuIiwiaW1wb3J0IGJhc2VDcmVhdGUgZnJvbSAnLi9fYmFzZUNyZWF0ZS5qcyc7XG5pbXBvcnQgZ2V0UHJvdG90eXBlIGZyb20gJy4vX2dldFByb3RvdHlwZS5qcyc7XG5pbXBvcnQgaXNQcm90b3R5cGUgZnJvbSAnLi9faXNQcm90b3R5cGUuanMnO1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZU9iamVjdChvYmplY3QpIHtcbiAgcmV0dXJuICh0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgIWlzUHJvdG90eXBlKG9iamVjdCkpXG4gICAgPyBiYXNlQ3JlYXRlKGdldFByb3RvdHlwZShvYmplY3QpKVxuICAgIDoge307XG59XG5cbmV4cG9ydCBkZWZhdWx0IGluaXRDbG9uZU9iamVjdDtcbiIsImltcG9ydCBpc0FycmF5TGlrZSBmcm9tICcuL2lzQXJyYXlMaWtlLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNBcnJheUxpa2VgIGV4Y2VwdCB0aGF0IGl0IGFsc28gY2hlY2tzIGlmIGB2YWx1ZWBcbiAqIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheS1saWtlIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0FycmF5TGlrZSh2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzQXJyYXlMaWtlT2JqZWN0O1xuIiwiaW1wb3J0IGJhc2VHZXRUYWcgZnJvbSAnLi9fYmFzZUdldFRhZy5qcyc7XG5pbXBvcnQgZ2V0UHJvdG90eXBlIGZyb20gJy4vX2dldFByb3RvdHlwZS5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gaW5mZXIgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yLiAqL1xudmFyIG9iamVjdEN0b3JTdHJpbmcgPSBmdW5jVG9TdHJpbmcuY2FsbChPYmplY3QpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGF0IGlzLCBhbiBvYmplY3QgY3JlYXRlZCBieSB0aGVcbiAqIGBPYmplY3RgIGNvbnN0cnVjdG9yIG9yIG9uZSB3aXRoIGEgYFtbUHJvdG90eXBlXV1gIG9mIGBudWxsYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuOC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiB9XG4gKlxuICogXy5pc1BsYWluT2JqZWN0KG5ldyBGb28pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KHsgJ3gnOiAwLCAneSc6IDAgfSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3RMaWtlKHZhbHVlKSB8fCBiYXNlR2V0VGFnKHZhbHVlKSAhPSBvYmplY3RUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHByb3RvID0gZ2V0UHJvdG90eXBlKHZhbHVlKTtcbiAgaWYgKHByb3RvID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIEN0b3IgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCAnY29uc3RydWN0b3InKSAmJiBwcm90by5jb25zdHJ1Y3RvcjtcbiAgcmV0dXJuIHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3RvciBpbnN0YW5jZW9mIEN0b3IgJiZcbiAgICBmdW5jVG9TdHJpbmcuY2FsbChDdG9yKSA9PSBvYmplY3RDdG9yU3RyaW5nO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc1BsYWluT2JqZWN0O1xuIiwiLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCwgdW5sZXNzIGBrZXlgIGlzIFwiX19wcm90b19fXCIuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzYWZlR2V0KG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBrZXkgPT0gJ19fcHJvdG9fXydcbiAgICA/IHVuZGVmaW5lZFxuICAgIDogb2JqZWN0W2tleV07XG59XG5cbmV4cG9ydCBkZWZhdWx0IHNhZmVHZXQ7XG4iLCJpbXBvcnQgY29weU9iamVjdCBmcm9tICcuL19jb3B5T2JqZWN0LmpzJztcbmltcG9ydCBrZXlzSW4gZnJvbSAnLi9rZXlzSW4uanMnO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBwbGFpbiBvYmplY3QgZmxhdHRlbmluZyBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmdcbiAqIGtleWVkIHByb3BlcnRpZXMgb2YgYHZhbHVlYCB0byBvd24gcHJvcGVydGllcyBvZiB0aGUgcGxhaW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29udmVydGVkIHBsYWluIG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgbmV3IEZvbyk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAqXG4gKiBfLmFzc2lnbih7ICdhJzogMSB9LCBfLnRvUGxhaW5PYmplY3QobmV3IEZvbykpO1xuICogLy8gPT4geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH1cbiAqL1xuZnVuY3Rpb24gdG9QbGFpbk9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gY29weU9iamVjdCh2YWx1ZSwga2V5c0luKHZhbHVlKSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHRvUGxhaW5PYmplY3Q7XG4iLCJpbXBvcnQgYXNzaWduTWVyZ2VWYWx1ZSBmcm9tICcuL19hc3NpZ25NZXJnZVZhbHVlLmpzJztcbmltcG9ydCBjbG9uZUJ1ZmZlciBmcm9tICcuL19jbG9uZUJ1ZmZlci5qcyc7XG5pbXBvcnQgY2xvbmVUeXBlZEFycmF5IGZyb20gJy4vX2Nsb25lVHlwZWRBcnJheS5qcyc7XG5pbXBvcnQgY29weUFycmF5IGZyb20gJy4vX2NvcHlBcnJheS5qcyc7XG5pbXBvcnQgaW5pdENsb25lT2JqZWN0IGZyb20gJy4vX2luaXRDbG9uZU9iamVjdC5qcyc7XG5pbXBvcnQgaXNBcmd1bWVudHMgZnJvbSAnLi9pc0FyZ3VtZW50cy5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuaW1wb3J0IGlzQXJyYXlMaWtlT2JqZWN0IGZyb20gJy4vaXNBcnJheUxpa2VPYmplY3QuanMnO1xuaW1wb3J0IGlzQnVmZmVyIGZyb20gJy4vaXNCdWZmZXIuanMnO1xuaW1wb3J0IGlzRnVuY3Rpb24gZnJvbSAnLi9pc0Z1bmN0aW9uLmpzJztcbmltcG9ydCBpc09iamVjdCBmcm9tICcuL2lzT2JqZWN0LmpzJztcbmltcG9ydCBpc1BsYWluT2JqZWN0IGZyb20gJy4vaXNQbGFpbk9iamVjdC5qcyc7XG5pbXBvcnQgaXNUeXBlZEFycmF5IGZyb20gJy4vaXNUeXBlZEFycmF5LmpzJztcbmltcG9ydCBzYWZlR2V0IGZyb20gJy4vX3NhZmVHZXQuanMnO1xuaW1wb3J0IHRvUGxhaW5PYmplY3QgZnJvbSAnLi90b1BsYWluT2JqZWN0LmpzJztcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VNZXJnZWAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICogZGVlcCBtZXJnZXMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAqIHJlZmVyZW5jZXMgdG8gYmUgbWVyZ2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBtZXJnZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzcmNJbmRleCBUaGUgaW5kZXggb2YgYHNvdXJjZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXJnZUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1lcmdlIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkXG4gKiAgY291bnRlcnBhcnRzLlxuICovXG5mdW5jdGlvbiBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIHNyY0luZGV4LCBtZXJnZUZ1bmMsIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIHZhciBvYmpWYWx1ZSA9IHNhZmVHZXQob2JqZWN0LCBrZXkpLFxuICAgICAgc3JjVmFsdWUgPSBzYWZlR2V0KHNvdXJjZSwga2V5KSxcbiAgICAgIHN0YWNrZWQgPSBzdGFjay5nZXQoc3JjVmFsdWUpO1xuXG4gIGlmIChzdGFja2VkKSB7XG4gICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgc3RhY2tlZCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCAoa2V5ICsgJycpLCBvYmplY3QsIHNvdXJjZSwgc3RhY2spXG4gICAgOiB1bmRlZmluZWQ7XG5cbiAgdmFyIGlzQ29tbW9uID0gbmV3VmFsdWUgPT09IHVuZGVmaW5lZDtcblxuICBpZiAoaXNDb21tb24pIHtcbiAgICB2YXIgaXNBcnIgPSBpc0FycmF5KHNyY1ZhbHVlKSxcbiAgICAgICAgaXNCdWZmID0gIWlzQXJyICYmIGlzQnVmZmVyKHNyY1ZhbHVlKSxcbiAgICAgICAgaXNUeXBlZCA9ICFpc0FyciAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheShzcmNWYWx1ZSk7XG5cbiAgICBuZXdWYWx1ZSA9IHNyY1ZhbHVlO1xuICAgIGlmIChpc0FyciB8fCBpc0J1ZmYgfHwgaXNUeXBlZCkge1xuICAgICAgaWYgKGlzQXJyYXkob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gb2JqVmFsdWU7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc0FycmF5TGlrZU9iamVjdChvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBjb3B5QXJyYXkob2JqVmFsdWUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNCdWZmKSB7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIG5ld1ZhbHVlID0gY2xvbmVCdWZmZXIoc3JjVmFsdWUsIHRydWUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNUeXBlZCkge1xuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICBuZXdWYWx1ZSA9IGNsb25lVHlwZWRBcnJheShzcmNWYWx1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbmV3VmFsdWUgPSBbXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNQbGFpbk9iamVjdChzcmNWYWx1ZSkgfHwgaXNBcmd1bWVudHMoc3JjVmFsdWUpKSB7XG4gICAgICBuZXdWYWx1ZSA9IG9ialZhbHVlO1xuICAgICAgaWYgKGlzQXJndW1lbnRzKG9ialZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IHRvUGxhaW5PYmplY3Qob2JqVmFsdWUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoIWlzT2JqZWN0KG9ialZhbHVlKSB8fCAoc3JjSW5kZXggJiYgaXNGdW5jdGlvbihvYmpWYWx1ZSkpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gaW5pdENsb25lT2JqZWN0KHNyY1ZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAoaXNDb21tb24pIHtcbiAgICAvLyBSZWN1cnNpdmVseSBtZXJnZSBvYmplY3RzIGFuZCBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBzdGFjay5zZXQoc3JjVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICBtZXJnZUZ1bmMobmV3VmFsdWUsIHNyY1ZhbHVlLCBzcmNJbmRleCwgY3VzdG9taXplciwgc3RhY2spO1xuICAgIHN0YWNrWydkZWxldGUnXShzcmNWYWx1ZSk7XG4gIH1cbiAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlTWVyZ2VEZWVwO1xuIiwiaW1wb3J0IFN0YWNrIGZyb20gJy4vX1N0YWNrLmpzJztcbmltcG9ydCBhc3NpZ25NZXJnZVZhbHVlIGZyb20gJy4vX2Fzc2lnbk1lcmdlVmFsdWUuanMnO1xuaW1wb3J0IGJhc2VGb3IgZnJvbSAnLi9fYmFzZUZvci5qcyc7XG5pbXBvcnQgYmFzZU1lcmdlRGVlcCBmcm9tICcuL19iYXNlTWVyZ2VEZWVwLmpzJztcbmltcG9ydCBpc09iamVjdCBmcm9tICcuL2lzT2JqZWN0LmpzJztcbmltcG9ydCBrZXlzSW4gZnJvbSAnLi9rZXlzSW4uanMnO1xuaW1wb3J0IHNhZmVHZXQgZnJvbSAnLi9fc2FmZUdldC5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWVyZ2VgIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzcmNJbmRleCBUaGUgaW5kZXggb2YgYHNvdXJjZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBtZXJnZWQgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAqICBjb3VudGVycGFydHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIGlmIChvYmplY3QgPT09IHNvdXJjZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBiYXNlRm9yKHNvdXJjZSwgZnVuY3Rpb24oc3JjVmFsdWUsIGtleSkge1xuICAgIGlmIChpc09iamVjdChzcmNWYWx1ZSkpIHtcbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIHNyY0luZGV4LCBiYXNlTWVyZ2UsIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICAgID8gY3VzdG9taXplcihzYWZlR2V0KG9iamVjdCwga2V5KSwgc3JjVmFsdWUsIChrZXkgKyAnJyksIG9iamVjdCwgc291cmNlLCBzdGFjaylcbiAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gc3JjVmFsdWU7XG4gICAgICB9XG4gICAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfVxuICB9LCBrZXlzSW4pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlTWVyZ2U7XG4iLCJpbXBvcnQgYmFzZU1lcmdlIGZyb20gJy4vX2Jhc2VNZXJnZS5qcyc7XG5pbXBvcnQgY3JlYXRlQXNzaWduZXIgZnJvbSAnLi9fY3JlYXRlQXNzaWduZXIuanMnO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYXNzaWduYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBtZXJnZXMgb3duIGFuZFxuICogaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdHMgaW50byB0aGVcbiAqIGRlc3RpbmF0aW9uIG9iamVjdC4gU291cmNlIHByb3BlcnRpZXMgdGhhdCByZXNvbHZlIHRvIGB1bmRlZmluZWRgIGFyZVxuICogc2tpcHBlZCBpZiBhIGRlc3RpbmF0aW9uIHZhbHVlIGV4aXN0cy4gQXJyYXkgYW5kIHBsYWluIG9iamVjdCBwcm9wZXJ0aWVzXG4gKiBhcmUgbWVyZ2VkIHJlY3Vyc2l2ZWx5LiBPdGhlciBvYmplY3RzIGFuZCB2YWx1ZSB0eXBlcyBhcmUgb3ZlcnJpZGRlbiBieVxuICogYXNzaWdubWVudC4gU291cmNlIG9iamVjdHMgYXJlIGFwcGxpZWQgZnJvbSBsZWZ0IHRvIHJpZ2h0LiBTdWJzZXF1ZW50XG4gKiBzb3VyY2VzIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyBzb3VyY2VzLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC41LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHtcbiAqICAgJ2EnOiBbeyAnYic6IDIgfSwgeyAnZCc6IDQgfV1cbiAqIH07XG4gKlxuICogdmFyIG90aGVyID0ge1xuICogICAnYSc6IFt7ICdjJzogMyB9LCB7ICdlJzogNSB9XVxuICogfTtcbiAqXG4gKiBfLm1lcmdlKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4geyAnYSc6IFt7ICdiJzogMiwgJ2MnOiAzIH0sIHsgJ2QnOiA0LCAnZSc6IDUgfV0gfVxuICovXG52YXIgbWVyZ2UgPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgpIHtcbiAgYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCk7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgbWVyZ2U7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlFYWNoKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSA9PT0gZmFsc2UpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFycmF5RWFjaDtcbiIsImltcG9ydCBvdmVyQXJnIGZyb20gJy4vX292ZXJBcmcuanMnO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCk7XG5cbmV4cG9ydCBkZWZhdWx0IG5hdGl2ZUtleXM7XG4iLCJpbXBvcnQgaXNQcm90b3R5cGUgZnJvbSAnLi9faXNQcm90b3R5cGUuanMnO1xuaW1wb3J0IG5hdGl2ZUtleXMgZnJvbSAnLi9fbmF0aXZlS2V5cy5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUtleXM7XG4iLCJpbXBvcnQgYXJyYXlMaWtlS2V5cyBmcm9tICcuL19hcnJheUxpa2VLZXlzLmpzJztcbmltcG9ydCBiYXNlS2V5cyBmcm9tICcuL19iYXNlS2V5cy5qcyc7XG5pbXBvcnQgaXNBcnJheUxpa2UgZnJvbSAnLi9pc0FycmF5TGlrZS5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8ua2V5cygnaGknKTtcbiAqIC8vID0+IFsnMCcsICcxJ11cbiAqL1xuZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBrZXlzO1xuIiwiaW1wb3J0IGJhc2VGb3IgZnJvbSAnLi9fYmFzZUZvci5qcyc7XG5pbXBvcnQga2V5cyBmcm9tICcuL2tleXMuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvck93bmAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGb3JPd24ob2JqZWN0LCBpdGVyYXRlZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3Iob2JqZWN0LCBpdGVyYXRlZSwga2V5cyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VGb3JPd247XG4iLCJpbXBvcnQgaXNBcnJheUxpa2UgZnJvbSAnLi9pc0FycmF5TGlrZS5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBiYXNlRWFjaGAgb3IgYGJhc2VFYWNoUmlnaHRgIGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGEgY29sbGVjdGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUVhY2goZWFjaEZ1bmMsIGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9XG4gICAgaWYgKCFpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKTtcbiAgICB9XG4gICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxuICAgICAgICBpbmRleCA9IGZyb21SaWdodCA/IGxlbmd0aCA6IC0xLFxuICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChjb2xsZWN0aW9uKTtcblxuICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVbaW5kZXhdLCBpbmRleCwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZUJhc2VFYWNoO1xuIiwiaW1wb3J0IGJhc2VGb3JPd24gZnJvbSAnLi9fYmFzZUZvck93bi5qcyc7XG5pbXBvcnQgY3JlYXRlQmFzZUVhY2ggZnJvbSAnLi9fY3JlYXRlQmFzZUVhY2guanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckVhY2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICovXG52YXIgYmFzZUVhY2ggPSBjcmVhdGVCYXNlRWFjaChiYXNlRm9yT3duKTtcblxuZXhwb3J0IGRlZmF1bHQgYmFzZUVhY2g7XG4iLCJpbXBvcnQgaWRlbnRpdHkgZnJvbSAnLi9pZGVudGl0eS5qcyc7XG5cbi8qKlxuICogQ2FzdHMgYHZhbHVlYCB0byBgaWRlbnRpdHlgIGlmIGl0J3Mgbm90IGEgZnVuY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgY2FzdCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY2FzdEZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlIDogaWRlbnRpdHk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNhc3RGdW5jdGlvbjtcbiIsImltcG9ydCBhcnJheUVhY2ggZnJvbSAnLi9fYXJyYXlFYWNoLmpzJztcbmltcG9ydCBiYXNlRWFjaCBmcm9tICcuL19iYXNlRWFjaC5qcyc7XG5pbXBvcnQgY2FzdEZ1bmN0aW9uIGZyb20gJy4vX2Nhc3RGdW5jdGlvbi5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuXG4vKipcbiAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggZWxlbWVudC5cbiAqIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gKlxuICogKipOb3RlOioqIEFzIHdpdGggb3RoZXIgXCJDb2xsZWN0aW9uc1wiIG1ldGhvZHMsIG9iamVjdHMgd2l0aCBhIFwibGVuZ3RoXCJcbiAqIHByb3BlcnR5IGFyZSBpdGVyYXRlZCBsaWtlIGFycmF5cy4gVG8gYXZvaWQgdGhpcyBiZWhhdmlvciB1c2UgYF8uZm9ySW5gXG4gKiBvciBgXy5mb3JPd25gIGZvciBvYmplY3QgaXRlcmF0aW9uLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBhbGlhcyBlYWNoXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAqIEBzZWUgXy5mb3JFYWNoUmlnaHRcbiAqIEBleGFtcGxlXG4gKlxuICogXy5mb3JFYWNoKFsxLCAyXSwgZnVuY3Rpb24odmFsdWUpIHtcbiAqICAgY29uc29sZS5sb2codmFsdWUpO1xuICogfSk7XG4gKiAvLyA9PiBMb2dzIGAxYCB0aGVuIGAyYC5cbiAqXG4gKiBfLmZvckVhY2goeyAnYSc6IDEsICdiJzogMiB9LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gKiB9KTtcbiAqIC8vID0+IExvZ3MgJ2EnIHRoZW4gJ2InIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpLlxuICovXG5mdW5jdGlvbiBmb3JFYWNoKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RWFjaCA6IGJhc2VFYWNoO1xuICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBjYXN0RnVuY3Rpb24oaXRlcmF0ZWUpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZm9yRWFjaDtcbiIsImltcG9ydCB7IGVhY2ggfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IHsgbWVyZ2UgfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IHsgZXh0ZW5kIH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCB7IGlzQXJyYXkgfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IHsgaXNPYmplY3QgfSBmcm9tICdsb2Rhc2gtZXMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihWdWUsIG9wdGlvbnMpIHtcblxuICAgIFZ1ZS5wcm90b3R5cGUuJG1lcmdlQ2xhc3NlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCBjbGFzc2VzID0ge307XG5cbiAgICAgICAgZWFjaChbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyksIGFyZyA9PiB7XG4gICAgICAgICAgICBpZihpc09iamVjdChhcmcpKSB7XG4gICAgICAgICAgICAgICAgZXh0ZW5kKGNsYXNzZXMsIGFyZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKGlzQXJyYXkoYXJnKSkge1xuICAgICAgICAgICAgICAgIG1lcmdlKGNsYXNzZXMsIGFyZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKGFyZykge1xuICAgICAgICAgICAgICAgIGNsYXNzZXNbYXJnXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBjbGFzc2VzO1xuICAgIH07XG5cbn1cbiIsImltcG9ydCBiYXNlTWVyZ2UgZnJvbSAnLi9fYmFzZU1lcmdlLmpzJztcbmltcG9ydCBpc09iamVjdCBmcm9tICcuL2lzT2JqZWN0LmpzJztcblxuLyoqXG4gKiBVc2VkIGJ5IGBfLmRlZmF1bHRzRGVlcGAgdG8gY3VzdG9taXplIGl0cyBgXy5tZXJnZWAgdXNlIHRvIG1lcmdlIHNvdXJjZVxuICogb2JqZWN0cyBpbnRvIGRlc3RpbmF0aW9uIG9iamVjdHMgdGhhdCBhcmUgcGFzc2VkIHRocnUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gb2JqVmFsdWUgVGhlIGRlc3RpbmF0aW9uIHZhbHVlLlxuICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgc291cmNlIHZhbHVlLlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBtZXJnZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHBhcmVudCBvYmplY3Qgb2YgYG9ialZhbHVlYC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHBhcmVudCBvYmplY3Qgb2YgYHNyY1ZhbHVlYC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkXG4gKiAgY291bnRlcnBhcnRzLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gY3VzdG9tRGVmYXVsdHNNZXJnZShvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKSB7XG4gIGlmIChpc09iamVjdChvYmpWYWx1ZSkgJiYgaXNPYmplY3Qoc3JjVmFsdWUpKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgbWVyZ2Ugb2JqZWN0cyBhbmQgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgc3RhY2suc2V0KHNyY1ZhbHVlLCBvYmpWYWx1ZSk7XG4gICAgYmFzZU1lcmdlKG9ialZhbHVlLCBzcmNWYWx1ZSwgdW5kZWZpbmVkLCBjdXN0b21EZWZhdWx0c01lcmdlLCBzdGFjayk7XG4gICAgc3RhY2tbJ2RlbGV0ZSddKHNyY1ZhbHVlKTtcbiAgfVxuICByZXR1cm4gb2JqVmFsdWU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGN1c3RvbURlZmF1bHRzTWVyZ2U7XG4iLCJpbXBvcnQgYmFzZU1lcmdlIGZyb20gJy4vX2Jhc2VNZXJnZS5qcyc7XG5pbXBvcnQgY3JlYXRlQXNzaWduZXIgZnJvbSAnLi9fY3JlYXRlQXNzaWduZXIuanMnO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ubWVyZ2VgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgIHdoaWNoXG4gKiBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIG1lcmdlZCB2YWx1ZXMgb2YgdGhlIGRlc3RpbmF0aW9uIGFuZCBzb3VyY2VcbiAqIHByb3BlcnRpZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgLCBtZXJnaW5nIGlzIGhhbmRsZWQgYnkgdGhlXG4gKiBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkIHdpdGggc2l4IGFyZ3VtZW50czpcbiAqIChvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKS5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gc291cmNlcyBUaGUgc291cmNlIG9iamVjdHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUpIHtcbiAqICAgaWYgKF8uaXNBcnJheShvYmpWYWx1ZSkpIHtcbiAqICAgICByZXR1cm4gb2JqVmFsdWUuY29uY2F0KHNyY1ZhbHVlKTtcbiAqICAgfVxuICogfVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogWzFdLCAnYic6IFsyXSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IFszXSwgJ2InOiBbNF0gfTtcbiAqXG4gKiBfLm1lcmdlV2l0aChvYmplY3QsIG90aGVyLCBjdXN0b21pemVyKTtcbiAqIC8vID0+IHsgJ2EnOiBbMSwgM10sICdiJzogWzIsIDRdIH1cbiAqL1xudmFyIG1lcmdlV2l0aCA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcikge1xuICBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyKTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBtZXJnZVdpdGg7XG4iLCJpbXBvcnQgYXBwbHkgZnJvbSAnLi9fYXBwbHkuanMnO1xuaW1wb3J0IGJhc2VSZXN0IGZyb20gJy4vX2Jhc2VSZXN0LmpzJztcbmltcG9ydCBjdXN0b21EZWZhdWx0c01lcmdlIGZyb20gJy4vX2N1c3RvbURlZmF1bHRzTWVyZ2UuanMnO1xuaW1wb3J0IG1lcmdlV2l0aCBmcm9tICcuL21lcmdlV2l0aC5qcyc7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5kZWZhdWx0c2AgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgYXNzaWduc1xuICogZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4xMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKiBAc2VlIF8uZGVmYXVsdHNcbiAqIEBleGFtcGxlXG4gKlxuICogXy5kZWZhdWx0c0RlZXAoeyAnYSc6IHsgJ2InOiAyIH0gfSwgeyAnYSc6IHsgJ2InOiAxLCAnYyc6IDMgfSB9KTtcbiAqIC8vID0+IHsgJ2EnOiB7ICdiJzogMiwgJ2MnOiAzIH0gfVxuICovXG52YXIgZGVmYXVsdHNEZWVwID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xuICBhcmdzLnB1c2godW5kZWZpbmVkLCBjdXN0b21EZWZhdWx0c01lcmdlKTtcbiAgcmV0dXJuIGFwcGx5KG1lcmdlV2l0aCwgdW5kZWZpbmVkLCBhcmdzKTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBkZWZhdWx0c0RlZXA7XG4iLCJpbXBvcnQgYmFzZUdldFRhZyBmcm9tICcuL19iYXNlR2V0VGFnLmpzJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3RyaW5nYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3RyaW5nLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTdHJpbmcoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTdHJpbmcoMSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8XG4gICAgKCFpc0FycmF5KHZhbHVlKSAmJiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN0cmluZ1RhZyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzU3RyaW5nO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ucmVkdWNlYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbml0QWNjdW1dIFNwZWNpZnkgdXNpbmcgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YCBhc1xuICogIHRoZSBpbml0aWFsIHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBhcnJheVJlZHVjZShhcnJheSwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0pIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICBpZiAoaW5pdEFjY3VtICYmIGxlbmd0aCkge1xuICAgIGFjY3VtdWxhdG9yID0gYXJyYXlbKytpbmRleF07XG4gIH1cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhY2N1bXVsYXRvciA9IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCBhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIGFjY3VtdWxhdG9yO1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheVJlZHVjZTtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlPZmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5T2Yob2JqZWN0KSB7XG4gIHJldHVybiBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVByb3BlcnR5T2Y7XG4iLCJpbXBvcnQgYmFzZVByb3BlcnR5T2YgZnJvbSAnLi9fYmFzZVByb3BlcnR5T2YuanMnO1xuXG4vKiogVXNlZCB0byBtYXAgTGF0aW4gVW5pY29kZSBsZXR0ZXJzIHRvIGJhc2ljIExhdGluIGxldHRlcnMuICovXG52YXIgZGVidXJyZWRMZXR0ZXJzID0ge1xuICAvLyBMYXRpbi0xIFN1cHBsZW1lbnQgYmxvY2suXG4gICdcXHhjMCc6ICdBJywgICdcXHhjMSc6ICdBJywgJ1xceGMyJzogJ0EnLCAnXFx4YzMnOiAnQScsICdcXHhjNCc6ICdBJywgJ1xceGM1JzogJ0EnLFxuICAnXFx4ZTAnOiAnYScsICAnXFx4ZTEnOiAnYScsICdcXHhlMic6ICdhJywgJ1xceGUzJzogJ2EnLCAnXFx4ZTQnOiAnYScsICdcXHhlNSc6ICdhJyxcbiAgJ1xceGM3JzogJ0MnLCAgJ1xceGU3JzogJ2MnLFxuICAnXFx4ZDAnOiAnRCcsICAnXFx4ZjAnOiAnZCcsXG4gICdcXHhjOCc6ICdFJywgICdcXHhjOSc6ICdFJywgJ1xceGNhJzogJ0UnLCAnXFx4Y2InOiAnRScsXG4gICdcXHhlOCc6ICdlJywgICdcXHhlOSc6ICdlJywgJ1xceGVhJzogJ2UnLCAnXFx4ZWInOiAnZScsXG4gICdcXHhjYyc6ICdJJywgICdcXHhjZCc6ICdJJywgJ1xceGNlJzogJ0knLCAnXFx4Y2YnOiAnSScsXG4gICdcXHhlYyc6ICdpJywgICdcXHhlZCc6ICdpJywgJ1xceGVlJzogJ2knLCAnXFx4ZWYnOiAnaScsXG4gICdcXHhkMSc6ICdOJywgICdcXHhmMSc6ICduJyxcbiAgJ1xceGQyJzogJ08nLCAgJ1xceGQzJzogJ08nLCAnXFx4ZDQnOiAnTycsICdcXHhkNSc6ICdPJywgJ1xceGQ2JzogJ08nLCAnXFx4ZDgnOiAnTycsXG4gICdcXHhmMic6ICdvJywgICdcXHhmMyc6ICdvJywgJ1xceGY0JzogJ28nLCAnXFx4ZjUnOiAnbycsICdcXHhmNic6ICdvJywgJ1xceGY4JzogJ28nLFxuICAnXFx4ZDknOiAnVScsICAnXFx4ZGEnOiAnVScsICdcXHhkYic6ICdVJywgJ1xceGRjJzogJ1UnLFxuICAnXFx4ZjknOiAndScsICAnXFx4ZmEnOiAndScsICdcXHhmYic6ICd1JywgJ1xceGZjJzogJ3UnLFxuICAnXFx4ZGQnOiAnWScsICAnXFx4ZmQnOiAneScsICdcXHhmZic6ICd5JyxcbiAgJ1xceGM2JzogJ0FlJywgJ1xceGU2JzogJ2FlJyxcbiAgJ1xceGRlJzogJ1RoJywgJ1xceGZlJzogJ3RoJyxcbiAgJ1xceGRmJzogJ3NzJyxcbiAgLy8gTGF0aW4gRXh0ZW5kZWQtQSBibG9jay5cbiAgJ1xcdTAxMDAnOiAnQScsICAnXFx1MDEwMic6ICdBJywgJ1xcdTAxMDQnOiAnQScsXG4gICdcXHUwMTAxJzogJ2EnLCAgJ1xcdTAxMDMnOiAnYScsICdcXHUwMTA1JzogJ2EnLFxuICAnXFx1MDEwNic6ICdDJywgICdcXHUwMTA4JzogJ0MnLCAnXFx1MDEwYSc6ICdDJywgJ1xcdTAxMGMnOiAnQycsXG4gICdcXHUwMTA3JzogJ2MnLCAgJ1xcdTAxMDknOiAnYycsICdcXHUwMTBiJzogJ2MnLCAnXFx1MDEwZCc6ICdjJyxcbiAgJ1xcdTAxMGUnOiAnRCcsICAnXFx1MDExMCc6ICdEJywgJ1xcdTAxMGYnOiAnZCcsICdcXHUwMTExJzogJ2QnLFxuICAnXFx1MDExMic6ICdFJywgICdcXHUwMTE0JzogJ0UnLCAnXFx1MDExNic6ICdFJywgJ1xcdTAxMTgnOiAnRScsICdcXHUwMTFhJzogJ0UnLFxuICAnXFx1MDExMyc6ICdlJywgICdcXHUwMTE1JzogJ2UnLCAnXFx1MDExNyc6ICdlJywgJ1xcdTAxMTknOiAnZScsICdcXHUwMTFiJzogJ2UnLFxuICAnXFx1MDExYyc6ICdHJywgICdcXHUwMTFlJzogJ0cnLCAnXFx1MDEyMCc6ICdHJywgJ1xcdTAxMjInOiAnRycsXG4gICdcXHUwMTFkJzogJ2cnLCAgJ1xcdTAxMWYnOiAnZycsICdcXHUwMTIxJzogJ2cnLCAnXFx1MDEyMyc6ICdnJyxcbiAgJ1xcdTAxMjQnOiAnSCcsICAnXFx1MDEyNic6ICdIJywgJ1xcdTAxMjUnOiAnaCcsICdcXHUwMTI3JzogJ2gnLFxuICAnXFx1MDEyOCc6ICdJJywgICdcXHUwMTJhJzogJ0knLCAnXFx1MDEyYyc6ICdJJywgJ1xcdTAxMmUnOiAnSScsICdcXHUwMTMwJzogJ0knLFxuICAnXFx1MDEyOSc6ICdpJywgICdcXHUwMTJiJzogJ2knLCAnXFx1MDEyZCc6ICdpJywgJ1xcdTAxMmYnOiAnaScsICdcXHUwMTMxJzogJ2knLFxuICAnXFx1MDEzNCc6ICdKJywgICdcXHUwMTM1JzogJ2onLFxuICAnXFx1MDEzNic6ICdLJywgICdcXHUwMTM3JzogJ2snLCAnXFx1MDEzOCc6ICdrJyxcbiAgJ1xcdTAxMzknOiAnTCcsICAnXFx1MDEzYic6ICdMJywgJ1xcdTAxM2QnOiAnTCcsICdcXHUwMTNmJzogJ0wnLCAnXFx1MDE0MSc6ICdMJyxcbiAgJ1xcdTAxM2EnOiAnbCcsICAnXFx1MDEzYyc6ICdsJywgJ1xcdTAxM2UnOiAnbCcsICdcXHUwMTQwJzogJ2wnLCAnXFx1MDE0Mic6ICdsJyxcbiAgJ1xcdTAxNDMnOiAnTicsICAnXFx1MDE0NSc6ICdOJywgJ1xcdTAxNDcnOiAnTicsICdcXHUwMTRhJzogJ04nLFxuICAnXFx1MDE0NCc6ICduJywgICdcXHUwMTQ2JzogJ24nLCAnXFx1MDE0OCc6ICduJywgJ1xcdTAxNGInOiAnbicsXG4gICdcXHUwMTRjJzogJ08nLCAgJ1xcdTAxNGUnOiAnTycsICdcXHUwMTUwJzogJ08nLFxuICAnXFx1MDE0ZCc6ICdvJywgICdcXHUwMTRmJzogJ28nLCAnXFx1MDE1MSc6ICdvJyxcbiAgJ1xcdTAxNTQnOiAnUicsICAnXFx1MDE1Nic6ICdSJywgJ1xcdTAxNTgnOiAnUicsXG4gICdcXHUwMTU1JzogJ3InLCAgJ1xcdTAxNTcnOiAncicsICdcXHUwMTU5JzogJ3InLFxuICAnXFx1MDE1YSc6ICdTJywgICdcXHUwMTVjJzogJ1MnLCAnXFx1MDE1ZSc6ICdTJywgJ1xcdTAxNjAnOiAnUycsXG4gICdcXHUwMTViJzogJ3MnLCAgJ1xcdTAxNWQnOiAncycsICdcXHUwMTVmJzogJ3MnLCAnXFx1MDE2MSc6ICdzJyxcbiAgJ1xcdTAxNjInOiAnVCcsICAnXFx1MDE2NCc6ICdUJywgJ1xcdTAxNjYnOiAnVCcsXG4gICdcXHUwMTYzJzogJ3QnLCAgJ1xcdTAxNjUnOiAndCcsICdcXHUwMTY3JzogJ3QnLFxuICAnXFx1MDE2OCc6ICdVJywgICdcXHUwMTZhJzogJ1UnLCAnXFx1MDE2Yyc6ICdVJywgJ1xcdTAxNmUnOiAnVScsICdcXHUwMTcwJzogJ1UnLCAnXFx1MDE3Mic6ICdVJyxcbiAgJ1xcdTAxNjknOiAndScsICAnXFx1MDE2Yic6ICd1JywgJ1xcdTAxNmQnOiAndScsICdcXHUwMTZmJzogJ3UnLCAnXFx1MDE3MSc6ICd1JywgJ1xcdTAxNzMnOiAndScsXG4gICdcXHUwMTc0JzogJ1cnLCAgJ1xcdTAxNzUnOiAndycsXG4gICdcXHUwMTc2JzogJ1knLCAgJ1xcdTAxNzcnOiAneScsICdcXHUwMTc4JzogJ1knLFxuICAnXFx1MDE3OSc6ICdaJywgICdcXHUwMTdiJzogJ1onLCAnXFx1MDE3ZCc6ICdaJyxcbiAgJ1xcdTAxN2EnOiAneicsICAnXFx1MDE3Yyc6ICd6JywgJ1xcdTAxN2UnOiAneicsXG4gICdcXHUwMTMyJzogJ0lKJywgJ1xcdTAxMzMnOiAnaWonLFxuICAnXFx1MDE1Mic6ICdPZScsICdcXHUwMTUzJzogJ29lJyxcbiAgJ1xcdTAxNDknOiBcIiduXCIsICdcXHUwMTdmJzogJ3MnXG59O1xuXG4vKipcbiAqIFVzZWQgYnkgYF8uZGVidXJyYCB0byBjb252ZXJ0IExhdGluLTEgU3VwcGxlbWVudCBhbmQgTGF0aW4gRXh0ZW5kZWQtQVxuICogbGV0dGVycyB0byBiYXNpYyBMYXRpbiBsZXR0ZXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gbGV0dGVyIFRoZSBtYXRjaGVkIGxldHRlciB0byBkZWJ1cnIuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBkZWJ1cnJlZCBsZXR0ZXIuXG4gKi9cbnZhciBkZWJ1cnJMZXR0ZXIgPSBiYXNlUHJvcGVydHlPZihkZWJ1cnJlZExldHRlcnMpO1xuXG5leHBvcnQgZGVmYXVsdCBkZWJ1cnJMZXR0ZXI7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheU1hcDtcbiIsImltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNTeW1ib2w7XG4iLCJpbXBvcnQgU3ltYm9sIGZyb20gJy4vX1N5bWJvbC5qcyc7XG5pbXBvcnQgYXJyYXlNYXAgZnJvbSAnLi9fYXJyYXlNYXAuanMnO1xuaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5LmpzJztcbmltcG9ydCBpc1N5bWJvbCBmcm9tICcuL2lzU3ltYm9sLmpzJztcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFRvU3RyaW5nID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by50b1N0cmluZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1N0cmluZ2Agd2hpY2ggZG9lc24ndCBjb252ZXJ0IG51bGxpc2hcbiAqIHZhbHVlcyB0byBlbXB0eSBzdHJpbmdzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBiYXNlVG9TdHJpbmcodmFsdWUpIHtcbiAgLy8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAvLyBSZWN1cnNpdmVseSBjb252ZXJ0IHZhbHVlcyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIHJldHVybiBhcnJheU1hcCh2YWx1ZSwgYmFzZVRvU3RyaW5nKSArICcnO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3ltYm9sVG9TdHJpbmcgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVRvU3RyaW5nO1xuIiwiaW1wb3J0IGJhc2VUb1N0cmluZyBmcm9tICcuL19iYXNlVG9TdHJpbmcuanMnO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBmb3IgYG51bGxgXG4gKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9TdHJpbmcobnVsbCk7XG4gKiAvLyA9PiAnJ1xuICpcbiAqIF8udG9TdHJpbmcoLTApO1xuICogLy8gPT4gJy0wJ1xuICpcbiAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcbiAqIC8vID0+ICcxLDIsMydcbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHRvU3RyaW5nO1xuIiwiaW1wb3J0IGRlYnVyckxldHRlciBmcm9tICcuL19kZWJ1cnJMZXR0ZXIuanMnO1xuaW1wb3J0IHRvU3RyaW5nIGZyb20gJy4vdG9TdHJpbmcuanMnO1xuXG4vKiogVXNlZCB0byBtYXRjaCBMYXRpbiBVbmljb2RlIGxldHRlcnMgKGV4Y2x1ZGluZyBtYXRoZW1hdGljYWwgb3BlcmF0b3JzKS4gKi9cbnZhciByZUxhdGluID0gL1tcXHhjMC1cXHhkNlxceGQ4LVxceGY2XFx4ZjgtXFx4ZmZcXHUwMTAwLVxcdTAxN2ZdL2c7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjaGFyYWN0ZXIgY2xhc3Nlcy4gKi9cbnZhciByc0NvbWJvTWFya3NSYW5nZSA9ICdcXFxcdTAzMDAtXFxcXHUwMzZmJyxcbiAgICByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgPSAnXFxcXHVmZTIwLVxcXFx1ZmUyZicsXG4gICAgcnNDb21ib1N5bWJvbHNSYW5nZSA9ICdcXFxcdTIwZDAtXFxcXHUyMGZmJyxcbiAgICByc0NvbWJvUmFuZ2UgPSByc0NvbWJvTWFya3NSYW5nZSArIHJlQ29tYm9IYWxmTWFya3NSYW5nZSArIHJzQ29tYm9TeW1ib2xzUmFuZ2U7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjYXB0dXJlIGdyb3Vwcy4gKi9cbnZhciByc0NvbWJvID0gJ1snICsgcnNDb21ib1JhbmdlICsgJ10nO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggW2NvbWJpbmluZyBkaWFjcml0aWNhbCBtYXJrc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzKSBhbmRcbiAqIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3MgZm9yIHN5bWJvbHNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrc19mb3JfU3ltYm9scykuXG4gKi9cbnZhciByZUNvbWJvTWFyayA9IFJlZ0V4cChyc0NvbWJvLCAnZycpO1xuXG4vKipcbiAqIERlYnVycnMgYHN0cmluZ2AgYnkgY29udmVydGluZ1xuICogW0xhdGluLTEgU3VwcGxlbWVudF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGF0aW4tMV9TdXBwbGVtZW50XyhVbmljb2RlX2Jsb2NrKSNDaGFyYWN0ZXJfdGFibGUpXG4gKiBhbmQgW0xhdGluIEV4dGVuZGVkLUFdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xhdGluX0V4dGVuZGVkLUEpXG4gKiBsZXR0ZXJzIHRvIGJhc2ljIExhdGluIGxldHRlcnMgYW5kIHJlbW92aW5nXG4gKiBbY29tYmluaW5nIGRpYWNyaXRpY2FsIG1hcmtzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3MpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGRlYnVyci5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGRlYnVycmVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5kZWJ1cnIoJ2TDqWrDoCB2dScpO1xuICogLy8gPT4gJ2RlamEgdnUnXG4gKi9cbmZ1bmN0aW9uIGRlYnVycihzdHJpbmcpIHtcbiAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgcmV0dXJuIHN0cmluZyAmJiBzdHJpbmcucmVwbGFjZShyZUxhdGluLCBkZWJ1cnJMZXR0ZXIpLnJlcGxhY2UocmVDb21ib01hcmssICcnKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVidXJyO1xuIiwiLyoqIFVzZWQgdG8gbWF0Y2ggd29yZHMgY29tcG9zZWQgb2YgYWxwaGFudW1lcmljIGNoYXJhY3RlcnMuICovXG52YXIgcmVBc2NpaVdvcmQgPSAvW15cXHgwMC1cXHgyZlxceDNhLVxceDQwXFx4NWItXFx4NjBcXHg3Yi1cXHg3Zl0rL2c7XG5cbi8qKlxuICogU3BsaXRzIGFuIEFTQ0lJIGBzdHJpbmdgIGludG8gYW4gYXJyYXkgb2YgaXRzIHdvcmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB3b3JkcyBvZiBgc3RyaW5nYC5cbiAqL1xuZnVuY3Rpb24gYXNjaWlXb3JkcyhzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5tYXRjaChyZUFzY2lpV29yZCkgfHwgW107XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFzY2lpV29yZHM7XG4iLCIvKiogVXNlZCB0byBkZXRlY3Qgc3RyaW5ncyB0aGF0IG5lZWQgYSBtb3JlIHJvYnVzdCByZWdleHAgdG8gbWF0Y2ggd29yZHMuICovXG52YXIgcmVIYXNVbmljb2RlV29yZCA9IC9bYS16XVtBLVpdfFtBLVpdezIsfVthLXpdfFswLTldW2EtekEtWl18W2EtekEtWl1bMC05XXxbXmEtekEtWjAtOSBdLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHN0cmluZ2AgY29udGFpbnMgYSB3b3JkIGNvbXBvc2VkIG9mIFVuaWNvZGUgc3ltYm9scy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYSB3b3JkIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc1VuaWNvZGVXb3JkKHN0cmluZykge1xuICByZXR1cm4gcmVIYXNVbmljb2RlV29yZC50ZXN0KHN0cmluZyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGhhc1VuaWNvZGVXb3JkO1xuIiwiLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNoYXJhY3RlciBjbGFzc2VzLiAqL1xudmFyIHJzQXN0cmFsUmFuZ2UgPSAnXFxcXHVkODAwLVxcXFx1ZGZmZicsXG4gICAgcnNDb21ib01hcmtzUmFuZ2UgPSAnXFxcXHUwMzAwLVxcXFx1MDM2ZicsXG4gICAgcmVDb21ib0hhbGZNYXJrc1JhbmdlID0gJ1xcXFx1ZmUyMC1cXFxcdWZlMmYnLFxuICAgIHJzQ29tYm9TeW1ib2xzUmFuZ2UgPSAnXFxcXHUyMGQwLVxcXFx1MjBmZicsXG4gICAgcnNDb21ib1JhbmdlID0gcnNDb21ib01hcmtzUmFuZ2UgKyByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgKyByc0NvbWJvU3ltYm9sc1JhbmdlLFxuICAgIHJzRGluZ2JhdFJhbmdlID0gJ1xcXFx1MjcwMC1cXFxcdTI3YmYnLFxuICAgIHJzTG93ZXJSYW5nZSA9ICdhLXpcXFxceGRmLVxcXFx4ZjZcXFxceGY4LVxcXFx4ZmYnLFxuICAgIHJzTWF0aE9wUmFuZ2UgPSAnXFxcXHhhY1xcXFx4YjFcXFxceGQ3XFxcXHhmNycsXG4gICAgcnNOb25DaGFyUmFuZ2UgPSAnXFxcXHgwMC1cXFxceDJmXFxcXHgzYS1cXFxceDQwXFxcXHg1Yi1cXFxceDYwXFxcXHg3Yi1cXFxceGJmJyxcbiAgICByc1B1bmN0dWF0aW9uUmFuZ2UgPSAnXFxcXHUyMDAwLVxcXFx1MjA2ZicsXG4gICAgcnNTcGFjZVJhbmdlID0gJyBcXFxcdFxcXFx4MGJcXFxcZlxcXFx4YTBcXFxcdWZlZmZcXFxcblxcXFxyXFxcXHUyMDI4XFxcXHUyMDI5XFxcXHUxNjgwXFxcXHUxODBlXFxcXHUyMDAwXFxcXHUyMDAxXFxcXHUyMDAyXFxcXHUyMDAzXFxcXHUyMDA0XFxcXHUyMDA1XFxcXHUyMDA2XFxcXHUyMDA3XFxcXHUyMDA4XFxcXHUyMDA5XFxcXHUyMDBhXFxcXHUyMDJmXFxcXHUyMDVmXFxcXHUzMDAwJyxcbiAgICByc1VwcGVyUmFuZ2UgPSAnQS1aXFxcXHhjMC1cXFxceGQ2XFxcXHhkOC1cXFxceGRlJyxcbiAgICByc1ZhclJhbmdlID0gJ1xcXFx1ZmUwZVxcXFx1ZmUwZicsXG4gICAgcnNCcmVha1JhbmdlID0gcnNNYXRoT3BSYW5nZSArIHJzTm9uQ2hhclJhbmdlICsgcnNQdW5jdHVhdGlvblJhbmdlICsgcnNTcGFjZVJhbmdlO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2FwdHVyZSBncm91cHMuICovXG52YXIgcnNBcG9zID0gXCJbJ1xcdTIwMTldXCIsXG4gICAgcnNCcmVhayA9ICdbJyArIHJzQnJlYWtSYW5nZSArICddJyxcbiAgICByc0NvbWJvID0gJ1snICsgcnNDb21ib1JhbmdlICsgJ10nLFxuICAgIHJzRGlnaXRzID0gJ1xcXFxkKycsXG4gICAgcnNEaW5nYmF0ID0gJ1snICsgcnNEaW5nYmF0UmFuZ2UgKyAnXScsXG4gICAgcnNMb3dlciA9ICdbJyArIHJzTG93ZXJSYW5nZSArICddJyxcbiAgICByc01pc2MgPSAnW14nICsgcnNBc3RyYWxSYW5nZSArIHJzQnJlYWtSYW5nZSArIHJzRGlnaXRzICsgcnNEaW5nYmF0UmFuZ2UgKyByc0xvd2VyUmFuZ2UgKyByc1VwcGVyUmFuZ2UgKyAnXScsXG4gICAgcnNGaXR6ID0gJ1xcXFx1ZDgzY1tcXFxcdWRmZmItXFxcXHVkZmZmXScsXG4gICAgcnNNb2RpZmllciA9ICcoPzonICsgcnNDb21ibyArICd8JyArIHJzRml0eiArICcpJyxcbiAgICByc05vbkFzdHJhbCA9ICdbXicgKyByc0FzdHJhbFJhbmdlICsgJ10nLFxuICAgIHJzUmVnaW9uYWwgPSAnKD86XFxcXHVkODNjW1xcXFx1ZGRlNi1cXFxcdWRkZmZdKXsyfScsXG4gICAgcnNTdXJyUGFpciA9ICdbXFxcXHVkODAwLVxcXFx1ZGJmZl1bXFxcXHVkYzAwLVxcXFx1ZGZmZl0nLFxuICAgIHJzVXBwZXIgPSAnWycgKyByc1VwcGVyUmFuZ2UgKyAnXScsXG4gICAgcnNaV0ogPSAnXFxcXHUyMDBkJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIHJlZ2V4ZXMuICovXG52YXIgcnNNaXNjTG93ZXIgPSAnKD86JyArIHJzTG93ZXIgKyAnfCcgKyByc01pc2MgKyAnKScsXG4gICAgcnNNaXNjVXBwZXIgPSAnKD86JyArIHJzVXBwZXIgKyAnfCcgKyByc01pc2MgKyAnKScsXG4gICAgcnNPcHRDb250ckxvd2VyID0gJyg/OicgKyByc0Fwb3MgKyAnKD86ZHxsbHxtfHJlfHN8dHx2ZSkpPycsXG4gICAgcnNPcHRDb250clVwcGVyID0gJyg/OicgKyByc0Fwb3MgKyAnKD86RHxMTHxNfFJFfFN8VHxWRSkpPycsXG4gICAgcmVPcHRNb2QgPSByc01vZGlmaWVyICsgJz8nLFxuICAgIHJzT3B0VmFyID0gJ1snICsgcnNWYXJSYW5nZSArICddPycsXG4gICAgcnNPcHRKb2luID0gJyg/OicgKyByc1pXSiArICcoPzonICsgW3JzTm9uQXN0cmFsLCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyXS5qb2luKCd8JykgKyAnKScgKyByc09wdFZhciArIHJlT3B0TW9kICsgJykqJyxcbiAgICByc09yZExvd2VyID0gJ1xcXFxkKig/OjFzdHwybmR8M3JkfCg/IVsxMjNdKVxcXFxkdGgpKD89XFxcXGJ8W0EtWl9dKScsXG4gICAgcnNPcmRVcHBlciA9ICdcXFxcZCooPzoxU1R8Mk5EfDNSRHwoPyFbMTIzXSlcXFxcZFRIKSg/PVxcXFxifFthLXpfXSknLFxuICAgIHJzU2VxID0gcnNPcHRWYXIgKyByZU9wdE1vZCArIHJzT3B0Sm9pbixcbiAgICByc0Vtb2ppID0gJyg/OicgKyBbcnNEaW5nYmF0LCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyXS5qb2luKCd8JykgKyAnKScgKyByc1NlcTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggY29tcGxleCBvciBjb21wb3VuZCB3b3Jkcy4gKi9cbnZhciByZVVuaWNvZGVXb3JkID0gUmVnRXhwKFtcbiAgcnNVcHBlciArICc/JyArIHJzTG93ZXIgKyAnKycgKyByc09wdENvbnRyTG93ZXIgKyAnKD89JyArIFtyc0JyZWFrLCByc1VwcGVyLCAnJCddLmpvaW4oJ3wnKSArICcpJyxcbiAgcnNNaXNjVXBwZXIgKyAnKycgKyByc09wdENvbnRyVXBwZXIgKyAnKD89JyArIFtyc0JyZWFrLCByc1VwcGVyICsgcnNNaXNjTG93ZXIsICckJ10uam9pbignfCcpICsgJyknLFxuICByc1VwcGVyICsgJz8nICsgcnNNaXNjTG93ZXIgKyAnKycgKyByc09wdENvbnRyTG93ZXIsXG4gIHJzVXBwZXIgKyAnKycgKyByc09wdENvbnRyVXBwZXIsXG4gIHJzT3JkVXBwZXIsXG4gIHJzT3JkTG93ZXIsXG4gIHJzRGlnaXRzLFxuICByc0Vtb2ppXG5dLmpvaW4oJ3wnKSwgJ2cnKTtcblxuLyoqXG4gKiBTcGxpdHMgYSBVbmljb2RlIGBzdHJpbmdgIGludG8gYW4gYXJyYXkgb2YgaXRzIHdvcmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB3b3JkcyBvZiBgc3RyaW5nYC5cbiAqL1xuZnVuY3Rpb24gdW5pY29kZVdvcmRzKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlVW5pY29kZVdvcmQpIHx8IFtdO1xufVxuXG5leHBvcnQgZGVmYXVsdCB1bmljb2RlV29yZHM7XG4iLCJpbXBvcnQgYXNjaWlXb3JkcyBmcm9tICcuL19hc2NpaVdvcmRzLmpzJztcbmltcG9ydCBoYXNVbmljb2RlV29yZCBmcm9tICcuL19oYXNVbmljb2RlV29yZC5qcyc7XG5pbXBvcnQgdG9TdHJpbmcgZnJvbSAnLi90b1N0cmluZy5qcyc7XG5pbXBvcnQgdW5pY29kZVdvcmRzIGZyb20gJy4vX3VuaWNvZGVXb3Jkcy5qcyc7XG5cbi8qKlxuICogU3BsaXRzIGBzdHJpbmdgIGludG8gYW4gYXJyYXkgb2YgaXRzIHdvcmRzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge1JlZ0V4cHxzdHJpbmd9IFtwYXR0ZXJuXSBUaGUgcGF0dGVybiB0byBtYXRjaCB3b3Jkcy5cbiAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdvcmRzIG9mIGBzdHJpbmdgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLndvcmRzKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycpO1xuICogLy8gPT4gWydmcmVkJywgJ2Jhcm5leScsICdwZWJibGVzJ11cbiAqXG4gKiBfLndvcmRzKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycsIC9bXiwgXSsvZyk7XG4gKiAvLyA9PiBbJ2ZyZWQnLCAnYmFybmV5JywgJyYnLCAncGViYmxlcyddXG4gKi9cbmZ1bmN0aW9uIHdvcmRzKHN0cmluZywgcGF0dGVybiwgZ3VhcmQpIHtcbiAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgcGF0dGVybiA9IGd1YXJkID8gdW5kZWZpbmVkIDogcGF0dGVybjtcblxuICBpZiAocGF0dGVybiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGhhc1VuaWNvZGVXb3JkKHN0cmluZykgPyB1bmljb2RlV29yZHMoc3RyaW5nKSA6IGFzY2lpV29yZHMoc3RyaW5nKTtcbiAgfVxuICByZXR1cm4gc3RyaW5nLm1hdGNoKHBhdHRlcm4pIHx8IFtdO1xufVxuXG5leHBvcnQgZGVmYXVsdCB3b3JkcztcbiIsImltcG9ydCBhcnJheVJlZHVjZSBmcm9tICcuL19hcnJheVJlZHVjZS5qcyc7XG5pbXBvcnQgZGVidXJyIGZyb20gJy4vZGVidXJyLmpzJztcbmltcG9ydCB3b3JkcyBmcm9tICcuL3dvcmRzLmpzJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNhcHR1cmUgZ3JvdXBzLiAqL1xudmFyIHJzQXBvcyA9IFwiWydcXHUyMDE5XVwiO1xuXG4vKiogVXNlZCB0byBtYXRjaCBhcG9zdHJvcGhlcy4gKi9cbnZhciByZUFwb3MgPSBSZWdFeHAocnNBcG9zLCAnZycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmNhbWVsQ2FzZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBjb21iaW5lIGVhY2ggd29yZC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbXBvdW5kZXIgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvdW5kZXIoY2FsbGJhY2spIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHJldHVybiBhcnJheVJlZHVjZSh3b3JkcyhkZWJ1cnIoc3RyaW5nKS5yZXBsYWNlKHJlQXBvcywgJycpKSwgY2FsbGJhY2ssICcnKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlQ29tcG91bmRlcjtcbiIsImltcG9ydCBjcmVhdGVDb21wb3VuZGVyIGZyb20gJy4vX2NyZWF0ZUNvbXBvdW5kZXIuanMnO1xuXG4vKipcbiAqIENvbnZlcnRzIGBzdHJpbmdgIHRvXG4gKiBba2ViYWIgY2FzZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGV0dGVyX2Nhc2UjU3BlY2lhbF9jYXNlX3N0eWxlcykuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGtlYmFiIGNhc2VkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5rZWJhYkNhc2UoJ0ZvbyBCYXInKTtcbiAqIC8vID0+ICdmb28tYmFyJ1xuICpcbiAqIF8ua2ViYWJDYXNlKCdmb29CYXInKTtcbiAqIC8vID0+ICdmb28tYmFyJ1xuICpcbiAqIF8ua2ViYWJDYXNlKCdfX0ZPT19CQVJfXycpO1xuICogLy8gPT4gJ2Zvby1iYXInXG4gKi9cbnZhciBrZWJhYkNhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/ICctJyA6ICcnKSArIHdvcmQudG9Mb3dlckNhc2UoKTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBrZWJhYkNhc2U7XG4iLCI8dGVtcGxhdGU+XG4gICAgPGRpdiBjbGFzcz1cImFjdGl2aXR5LWluZGljYXRvclwiIDpjbGFzcz1cImNsYXNzZXNcIj5cbiAgICAgICAgPGRpdiB2LWZvcj1cImkgaW4gbm9kZXNcIj48L2Rpdj5cbiAgICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBwcm9wczoge1xuICAgICAgICBub2Rlczoge1xuICAgICAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICAgICAgZGVmYXVsdDogM1xuICAgICAgICB9LFxuICAgICAgICBzaXplOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAnJ1xuICAgICAgICB9LFxuICAgICAgICBwcmVmaXg6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdhY3Rpdml0eS1pbmRpY2F0b3ItJ1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIGNsYXNzZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY29uc3QgY2xhc3NlcyA9IHt9O1xuXG4gICAgICAgICAgICBjbGFzc2VzW3RoaXMuJG9wdGlvbnMubmFtZV0gPSAhIXRoaXMuJG9wdGlvbnMubmFtZTtcbiAgICAgICAgICAgIGNsYXNzZXNbdGhpcy5wcmVmaXggKyB0aGlzLnNpemUucmVwbGFjZSh0aGlzLnByZWZpeCwgJycpXSA9ICEhdGhpcy5zaXplO1xuXG4gICAgICAgICAgICByZXR1cm4gY2xhc3NlcztcbiAgICAgICAgfVxuICAgIH1cblxufVxuPC9zY3JpcHQ+XG4iLCI8c2NyaXB0PlxuaW1wb3J0IEJhc2VUeXBlIGZyb20gJy4vQmFzZVR5cGUnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAnYWN0aXZpdHktaW5kaWNhdG9yLWRvdHMnLFxuXG4gICAgZXh0ZW5kczogQmFzZVR5cGVcbn1cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cInNjc3NcIj5cbkBpbXBvcnQgJy4vbm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC9zY3NzL2Z1bmN0aW9ucy5zY3NzJztcbkBpbXBvcnQgJy4vbm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC9zY3NzL3ZhcmlhYmxlcy5zY3NzJztcblxuJGFjdGl2aXR5LWluZGljYXRvci1kb3Qtc2l6ZTogLjZyZW07XG5cbi5hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyB7XG5cbiAgICAmID4gZGl2IHtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogMTAwJTtcbiAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkZ3JheS05MDA7XG4gICAgICAgIHdpZHRoOiAkYWN0aXZpdHktaW5kaWNhdG9yLWRvdC1zaXplO1xuICAgICAgICBoZWlnaHQ6ICRhY3Rpdml0eS1pbmRpY2F0b3ItZG90LXNpemU7XG4gICAgICAgIGFuaW1hdGlvbjogYWN0aXZpdHktaW5kaWNhdG9yLWRvdHMgMS40cyBpbmZpbml0ZSBlYXNlLWluLW91dCBib3RoO1xuICAgIH1cblxuICAgICYgPiBkaXY6bm90KDpsYXN0LWNoaWxkKSB7XG4gICAgICAgIG1hcmdpbi1yaWdodDogJGFjdGl2aXR5LWluZGljYXRvci1kb3Qtc2l6ZSAqIC4zMztcbiAgICB9XG5cbiAgICAmLmFjdGl2aXR5LWluZGljYXRvci14cyA+IGRpdiB7XG4gICAgICAgIHdpZHRoOiAkYWN0aXZpdHktaW5kaWNhdG9yLWRvdC1zaXplICogLjU7XG4gICAgICAgIGhlaWdodDogJGFjdGl2aXR5LWluZGljYXRvci1kb3Qtc2l6ZSAqIC41O1xuICAgIH1cblxuICAgICYuYWN0aXZpdHktaW5kaWNhdG9yLXNtID4gZGl2IHtcbiAgICAgICAgd2lkdGg6ICRhY3Rpdml0eS1pbmRpY2F0b3ItZG90LXNpemUgKiAuNzU7XG4gICAgICAgIGhlaWdodDogJGFjdGl2aXR5LWluZGljYXRvci1kb3Qtc2l6ZSAqIC43NTtcbiAgICB9XG5cbiAgICAmLmFjdGl2aXR5LWluZGljYXRvci1tZCA+IGRpdiB7XG4gICAgICAgIHdpZHRoOiAkYWN0aXZpdHktaW5kaWNhdG9yLWRvdC1zaXplICogMTtcbiAgICAgICAgaGVpZ2h0OiAkYWN0aXZpdHktaW5kaWNhdG9yLWRvdC1zaXplICogMTtcbiAgICB9XG5cbiAgICAmLmFjdGl2aXR5LWluZGljYXRvci1sZyA+IGRpdiB7XG4gICAgICAgIHdpZHRoOiAkYWN0aXZpdHktaW5kaWNhdG9yLWRvdC1zaXplICogMS41O1xuICAgICAgICBoZWlnaHQ6ICRhY3Rpdml0eS1pbmRpY2F0b3ItZG90LXNpemUgKiAxLjU7XG4gICAgfVxuXG4gICAgJi5hY3Rpdml0eS1pbmRpY2F0b3IteGwgPiBkaXYge1xuICAgICAgICB3aWR0aDogJGFjdGl2aXR5LWluZGljYXRvci1kb3Qtc2l6ZSAqIDI7XG4gICAgICAgIGhlaWdodDogJGFjdGl2aXR5LWluZGljYXRvci1kb3Qtc2l6ZSAqIDI7XG4gICAgfVxuXG4gICAgQGZvciAkaSBmcm9tIDAgdGhyb3VnaCAxMiB7XG4gICAgICAgICYgPiBkaXY6bnRoLWNoaWxkKCN7JGkgKyAxfSkge1xuICAgICAgICAgICAgYW5pbWF0aW9uLWRlbGF5OiAkaSAqIC4xNnM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBAa2V5ZnJhbWVzIGFjdGl2aXR5LWluZGljYXRvci1kb3RzIHtcbiAgICAgICAgMCUsIDgwJSwgMTAwJSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDApO1xuICAgICAgICB9IDQwJSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDEuMCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi5idG4tYWN0aXZpdHktaW5kaWNhdG9yLWRvdHMge1xuICAgICY6bm90KC5idG4td2FybmluZykgLmFjdGl2aXR5LWluZGljYXRvci1kb3RzID4gZGl2IHtcbiAgICAgICAgYmFja2dyb3VuZDogd2hpdGU7XG4gICAgfVxufVxuXG48L3N0eWxlPlxuIiwiPHNjcmlwdD5cbmltcG9ydCBCYXNlVHlwZSBmcm9tICcuL0Jhc2VUeXBlJztcbmltcG9ydCB7IGV4dGVuZCB9IGZyb20gJ2xvZGFzaC1lcyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdhY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lcicsXG5cbiAgICBleHRlbmRzOiBCYXNlVHlwZSxcblxuICAgIHByb3BzOiBleHRlbmQoe30sIEJhc2VUeXBlLnByb3BzLCB7XG4gICAgICAgIG5vZGVzOiB7XG4gICAgICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgICAgICBkZWZhdWx0OiAxMlxuICAgICAgICB9XG4gICAgfSlcbn1cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cInNjc3NcIj5cbkBpbXBvcnQgJy4vbm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC9zY3NzL2Z1bmN0aW9ucy5zY3NzJztcbkBpbXBvcnQgJy4vbm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC9zY3NzL3ZhcmlhYmxlcy5zY3NzJztcblxuJGFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyLXNpemU6ICRmb250LXNpemUtYmFzZSAqIDIuMjU7XG4kYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXItd2lkdGg6IDEwJTtcbiRhY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lci1oZWlnaHQ6IDMwJTtcbiRhY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lci1kZWxheTogMXM7XG5cbkBtaXhpbiBzcGlubmVyLXJvdGF0ZS1zZWxlY3RvcnMoJHN0YXJ0OjEsICRlbmQ6MTYsICRkZWxheToxLjJzKSB7XG4gICAgQGZvciAkaSBmcm9tICRzdGFydCB0aHJvdWdoICRlbmQge1xuICAgICAgICAmID4gZGl2OmZpcnN0LWNoaWxkOm50aC1sYXN0LWNoaWxkKCN7JGl9KSxcbiAgICAgICAgJiA+IGRpdjpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCgjeyRpfSkgfiBkaXYge1xuICAgICAgICAgICAgQGluY2x1ZGUgc3Bpbm5lci1yb3RhdGUtdHJhbnNmb3JtKCRpLCAkZGVsYXkpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5AbWl4aW4gc3Bpbm5lci1yb3RhdGUtdHJhbnNmb3JtKCR0b3RhbCwgJGRlbGF5OjEuMnMpIHtcbiAgICBAZm9yICRpIGZyb20gMSB0aHJvdWdoICR0b3RhbCB7XG4gICAgICAgICY6bnRoLWNoaWxkKCN7JGl9KSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgjezM2MCAvICR0b3RhbCAqICRpfWRlZyk7XG5cbiAgICAgICAgICAgICY6YmVmb3JlIHtcbiAgICAgICAgICAgICAgICBhbmltYXRpb24tZGVsYXk6IC0jeyRkZWxheSAtICgkZGVsYXkgLyAkdG90YWwgKiAoJGkgLSAxKSl9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG4uYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIge1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICB3aWR0aDogJGFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyLXNpemU7XG4gICAgaGVpZ2h0OiAkYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXItc2l6ZTtcblxuICAgICYgPiBkaXYgIHtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICBsZWZ0OiAwO1xuICAgICAgICB0b3A6IDA7XG5cbiAgICAgICAgJjpiZWZvcmUge1xuICAgICAgICAgICAgY29udGVudDogJyc7XG4gICAgICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgICAgIG1hcmdpbjogMCBhdXRvO1xuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogJGdyYXktOTAwO1xuICAgICAgICAgICAgd2lkdGg6ICRhY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lci13aWR0aDtcbiAgICAgICAgICAgIGhlaWdodDogJGFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyLWhlaWdodDtcbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDVweDtcbiAgICAgICAgICAgIGFuaW1hdGlvbjogYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIgJGFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyLWRlbGF5IGluZmluaXRlIGVhc2UtaW4tb3V0IGJvdGg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAmLmFjdGl2aXR5LWluZGljYXRvci14cyB7XG4gICAgICAgIHdpZHRoOiAkYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXItc2l6ZSAqIC41O1xuICAgICAgICBoZWlnaHQ6ICRhY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lci1zaXplICogLjU7XG4gICAgfVxuICAgICYuYWN0aXZpdHktaW5kaWNhdG9yLXNtIHtcbiAgICAgICAgd2lkdGg6ICRhY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lci1zaXplICogLjc1O1xuICAgICAgICBoZWlnaHQ6ICRhY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lci1zaXplICogLjc1O1xuICAgIH1cbiAgICAmLmFjdGl2aXR5LWluZGljYXRvci1tZCB7XG4gICAgICAgIHdpZHRoOiAkYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXItc2l6ZSAqIDE7XG4gICAgICAgIGhlaWdodDogJGFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyLXNpemUgKiAxO1xuICAgIH1cbiAgICAmLmFjdGl2aXR5LWluZGljYXRvci1sZyB7XG4gICAgICAgIHdpZHRoOiAkYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXItc2l6ZSAqIDEuNTtcbiAgICAgICAgaGVpZ2h0OiAkYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXItc2l6ZSAqIDEuNTtcbiAgICB9XG4gICAgJi5hY3Rpdml0eS1pbmRpY2F0b3IteGwge1xuICAgICAgICB3aWR0aDogJGFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyLXNpemUgKiAyO1xuICAgICAgICBoZWlnaHQ6ICRhY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lci1zaXplICogMjtcbiAgICB9XG5cbiAgICBAaW5jbHVkZSBzcGlubmVyLXJvdGF0ZS1zZWxlY3RvcnMoMSwgMTIsICRhY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lci1kZWxheSk7XG5cbiAgICBAa2V5ZnJhbWVzIGFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyIHtcbiAgICAgICAgMCUsIDM5JSwgMTAwJSB7IG9wYWNpdHk6IDA7IH1cbiAgICAgICAgNDAlIHsgb3BhY2l0eTogMTsgfVxuICAgIH1cbn1cblxuLmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lciB7XG4gICAgJjpub3QoLmJ0bi13YXJuaW5nKSAuYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIgPiBkaXY6YmVmb3JlIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XG4gICAgfVxufVxuXG48L3N0eWxlPlxuIiwiaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVJc0Zpbml0ZSA9IHJvb3QuaXNGaW5pdGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBmaW5pdGUgcHJpbWl0aXZlIG51bWJlci5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAqIFtgTnVtYmVyLmlzRmluaXRlYF0oaHR0cHM6Ly9tZG4uaW8vTnVtYmVyL2lzRmluaXRlKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZpbml0ZSBudW1iZXIsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Zpbml0ZSgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRmluaXRlKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGaW5pdGUoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzRmluaXRlKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Zpbml0ZSh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmIG5hdGl2ZUlzRmluaXRlKHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNGaW5pdGU7XG4iLCJpbXBvcnQgeyBpc0Zpbml0ZSB9IGZyb20gJ2xvZGFzaC1lcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGhlaWdodCkge1xuICAgIHJldHVybiBpc0Zpbml0ZShoZWlnaHQpID8gaGVpZ2h0ICsgJ3B4JyA6IGhlaWdodDtcbn1cbiIsIjx0ZW1wbGF0ZT5cbiAgICA8ZGl2IHYtaWY9XCJjZW50ZXJcIiBjbGFzcz1cImNlbnRlci13cmFwcGVyXCIgOmNsYXNzPVwieydwb3NpdGlvbi1yZWxhdGl2ZSc6IHJlbGF0aXZlLCAncG9zaXRpb24tZml4ZWQnOiBmaXhlZH1cIiA6c3R5bGU9XCJ7bWluSGVpZ2h0OiB1bml0KHRoaXMubWluSGVpZ2h0KSwgbWluV2lkdGg6IHVuaXQodGhpcy5taW5XaWR0aCl9XCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJjZW50ZXItY29udGVudFwiPlxuICAgICAgICAgICAgPGNvbXBvbmVudCA6aXM9XCJjb21wb25lbnRcIiA6c2l6ZT1cInNpemVcIiA6cHJlZml4PVwicHJlZml4XCI+PC9jb21wb25lbnQ+XG4gICAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICAgIDxjb21wb25lbnQgdi1lbHNlIDppcz1cImNvbXBvbmVudFwiIDpzdHlsZT1cInttaW5IZWlnaHQ6IHVuaXQodGhpcy5taW5IZWlnaHQpLCBtaW5XaWR0aDogdW5pdCh0aGlzLm1pbldpZHRoKX1cIiA6c2l6ZT1cInNpemVcIiA6cHJlZml4PVwicHJlZml4XCI+PC9jb21wb25lbnQ+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IHsga2ViYWJDYXNlIH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCBCYXNlVHlwZSBmcm9tICcuL1R5cGVzL0Jhc2VUeXBlJztcbmltcG9ydCBBY3Rpdml0eUluZGljYXRvckRvdHMgZnJvbSAnLi9UeXBlcy9Eb3RzJztcbmltcG9ydCBBY3Rpdml0eUluZGljYXRvclNwaW5uZXIgZnJvbSAnLi9UeXBlcy9TcGlubmVyJztcbmltcG9ydCB1bml0IGZyb20gJy4uLy4uL0hlbHBlcnMvVW5pdCc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdhY3Rpdml0eS1pbmRpY2F0b3InLFxuXG4gICAgZXh0ZW5kczogQmFzZVR5cGUsXG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIGNlbnRlcjogQm9vbGVhbixcblxuICAgICAgICBmaXhlZDogQm9vbGVhbixcblxuICAgICAgICByZWxhdGl2ZTogQm9vbGVhbixcblxuICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAnZG90cydcbiAgICAgICAgfSxcblxuICAgICAgICBtaW5IZWlnaHQ6IFtTdHJpbmcsIE51bWJlcl0sXG5cbiAgICAgICAgbWluV2lkdGg6IFtTdHJpbmcsIE51bWJlcl1cblxuICAgIH0sXG5cbiAgICBjb21wb25lbnRzOiB7XG4gICAgICAgIEFjdGl2aXR5SW5kaWNhdG9yRG90cyxcbiAgICAgICAgQWN0aXZpdHlJbmRpY2F0b3JTcGlubmVyXG4gICAgfSxcblxuICAgIG1ldGhvZHM6IHtcblxuICAgICAgICB1bml0KHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5pdCh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBjb21wdXRlZDoge1xuXG4gICAgICAgIGNvbXBvbmVudCgpIHtcbiAgICAgICAgICAgIHJldHVybiBrZWJhYkNhc2UodGhpcy5wcmVmaXggKyB0aGlzLnR5cGUucmVwbGFjZSh0aGlzLnByZWZpeCwgJycpKTtcbiAgICAgICAgfVxuICAgIH1cblxufVxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwic2Nzc1wiPlxuQGltcG9ydCAnLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwL3Njc3MvZnVuY3Rpb25zLnNjc3MnO1xuQGltcG9ydCAnLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwL3Njc3MvdmFyaWFibGVzLnNjc3MnO1xuXG4vLyBDb250ZW50IFBvc2l0aW9uaW5nIEhlbHBlcnNcbi5jZW50ZXItd3JhcHBlciB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHRvcDogMDtcbiAgICBsZWZ0OiAwO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogMTAwJTtcbn1cbi5jZW50ZXItY29udGVudCB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHRvcDogNTAlO1xuICAgIGxlZnQ6IDUwJTtcbiAgICBtYXJnaW4tcmlnaHQ6IC01MCU7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwgLTUwJSlcbn1cblxuPC9zdHlsZT5cbiIsImNvbnN0IGxvYWRlZCA9IHt9O1xuXG5mdW5jdGlvbiBlbGVtZW50KHVybCkge1xuICAgIGNvbnN0IHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgIHNjcmlwdC5zZXRBdHRyaWJ1dGUoJ3NyYycsIHVybCk7XG4gICAgc2NyaXB0LnNldEF0dHJpYnV0ZSgndHlwZScsICd0ZXh0L2phdmFzY3JpcHQnKTtcbiAgICBzY3JpcHQuc2V0QXR0cmlidXRlKCdjaGFyc2V0JywgJ3V0Zi04Jyk7XG4gICAgcmV0dXJuIHNjcmlwdDtcbn1cblxuZnVuY3Rpb24gYXBwZW5kKHNjcmlwdCkge1xuICAgIGlmKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2hlYWQnKSkge1xuICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdoZWFkJykuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2JvZHknKS5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgIH1cblxuICAgIHJldHVybiBzY3JpcHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNjcmlwdCh1cmwpIHtcbiAgICBpZihsb2FkZWRbdXJsXSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgcmV0dXJuIGxvYWRlZFt1cmxdO1xuICAgIH1cblxuICAgIHJldHVybiBsb2FkZWRbdXJsXSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmKCFsb2FkZWRbdXJsXSkge1xuICAgICAgICAgICAgICAgIGFwcGVuZChlbGVtZW50KHVybCkpLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUobG9hZGVkW3VybF0gPSBldmVudCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKGxvYWRlZFt1cmxdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaChlKSB7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbiIsImltcG9ydCB7IGVhY2ggfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IHsgaXNGdW5jdGlvbiB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgc2NyaXB0IGZyb20gJy4uL1NjcmlwdCc7XG5cbmNvbnN0IFZ1ZUluc3RhbGxlciA9IHtcbiAgICB1c2UsXG4gICAgc2NyaXB0LFxuICAgIHBsdWdpbixcbiAgICBwbHVnaW5zLFxuICAgIGZpbHRlcixcbiAgICBmaWx0ZXJzLFxuICAgIGNvbXBvbmVudCxcbiAgICBjb21wb25lbnRzLFxuICAgIGRpcmVjdGl2ZSxcbiAgICBkaXJlY3RpdmVzLFxuICAgICRwbHVnaW5zOiB7fSxcbiAgICAkZmlsdGVyczoge30sXG4gICAgJGRpcmVjdGl2ZXM6IHt9LFxuICAgICRjb21wb25lbnRzOiB7fSxcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2UocGx1Z2luKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5WdWUpIHtcbiAgICAgICAgd2luZG93LlZ1ZS51c2UocGx1Z2luKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGx1Z2luO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGx1Z2luKFZ1ZSwgbmFtZSwgZGVmKSB7XG4gICAgaWYoIVZ1ZUluc3RhbGxlci4kcGx1Z2luc1tuYW1lXSkge1xuICAgICAgICBWdWUudXNlKFZ1ZUluc3RhbGxlci4kcGx1Z2luc1tuYW1lXSA9IGRlZik7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcGx1Z2lucyhWdWUsIHBsdWdpbnMpIHtcbiAgICBlYWNoKHBsdWdpbnMsIChkZWYsIG5hbWUpID0+IHtcbiAgICAgICAgcGx1Z2luKFZ1ZSwgbmFtZSwgZGVmKTtcbiAgICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlcihWdWUsIG5hbWUsIGRlZikge1xuICAgIGlmKCFWdWVJbnN0YWxsZXIuJGZpbHRlcnNbbmFtZV0pIHtcbiAgICAgICAgVnVlLnVzZShWdWVJbnN0YWxsZXIuJGZpbHRlcnNbbmFtZV0gPSBkZWYpO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlcnMoVnVlLCBmaWx0ZXJzKSB7XG4gICAgZWFjaChmaWx0ZXJzLCAoZGVmLCBuYW1lKSA9PiB7XG4gICAgICAgIGZpbHRlcihWdWUsIG5hbWUsIGRlZik7XG4gICAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wb25lbnQoVnVlLCBuYW1lLCBkZWYpIHtcbiAgICBpZighVnVlSW5zdGFsbGVyLiRjb21wb25lbnRzW25hbWVdKSB7XG4gICAgICAgIFZ1ZS5jb21wb25lbnQobmFtZSwgVnVlSW5zdGFsbGVyLiRjb21wb25lbnRzW25hbWVdID0gZGVmKTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wb25lbnRzKFZ1ZSwgY29tcG9uZW50cykge1xuICAgIGVhY2goY29tcG9uZW50cywgKGRlZiwgbmFtZSkgPT4ge1xuICAgICAgICBjb21wb25lbnQoVnVlLCBuYW1lLCBkZWYpO1xuICAgIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGlyZWN0aXZlKFZ1ZSwgbmFtZSwgZGVmKSB7XG4gICAgaWYoIVZ1ZUluc3RhbGxlci4kZGlyZWN0aXZlc1tuYW1lXSkge1xuICAgICAgICBpZihpc0Z1bmN0aW9uKGRlZikpIHtcbiAgICAgICAgICAgIFZ1ZS51c2UoVnVlSW5zdGFsbGVyLiRkaXJlY3RpdmVzW25hbWVdID0gZGVmKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIFZ1ZS5kaXJlY3RpdmUobmFtZSwgZGVmKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpcmVjdGl2ZXMoVnVlLCBkaXJlY3RpdmVzKSB7XG4gICAgZWFjaChkaXJlY3RpdmVzLCAoZGVmLCBuYW1lKSA9PiB7XG4gICAgICAgIGRpcmVjdGl2ZShWdWUsIG5hbWUsIGRlZik7XG4gICAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IFZ1ZUluc3RhbGxlcjtcbiIsImltcG9ydCBBY3Rpdml0eUluZGljYXRvciBmcm9tICcuL0FjdGl2aXR5SW5kaWNhdG9yJztcbmltcG9ydCBWdWVJbnN0YWxsZXIgZnJvbSAnLi4vLi4vSGVscGVycy9WdWVJbnN0YWxsZXIvVnVlSW5zdGFsbGVyJztcblxuY29uc3QgcGx1Z2luID0gVnVlSW5zdGFsbGVyLnVzZSh7XG5cbiAgICBpbnN0YWxsKFZ1ZSwgb3B0aW9ucykge1xuICAgICAgICBWdWVJbnN0YWxsZXIuY29tcG9uZW50cyh7XG4gICAgICAgICAgICBBY3Rpdml0eUluZGljYXRvclxuICAgICAgICB9KTtcbiAgICB9XG5cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBBY3Rpdml0eUluZGljYXRvcjtcbiIsIjx0ZW1wbGF0ZT5cbiAgICA8YnV0dG9uIDp0eXBlPVwidHlwZVwiIGNsYXNzPVwiYnRuXCIgOmNsYXNzPVwiY2xhc3Nlc1wiIEBjbGljaz1cIm9uQ2xpY2tcIj5cbiAgICAgICAgPGkgdi1pZj1cImljb25cIiA6Y2xhc3M9XCJpY29uXCIvPiB7e2xhYmVsfX0gPHNsb3QvPlxuICAgICAgICA8YWN0aXZpdHktaW5kaWNhdG9yIDp0eXBlPVwiaW5kaWNhdG9yXCIgLz5cbiAgICA8L2J1dHRvbj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgQWN0aXZpdHlJbmRpY2F0b3IgZnJvbSAnLi4vQWN0aXZpdHlJbmRpY2F0b3InO1xuXG5jb25zdCBjb252ZXJ0QW5pbWF0aW9uRGVsYXlUb0ludCA9IGZ1bmN0aW9uKGRlbGF5KSB7XG4gICAgY29uc3QgbnVtID0gcGFyc2VGbG9hdChkZWxheSwgMTApO1xuICAgIGNvbnN0IG1hdGNoZXMgPSBkZWxheS5tYXRjaCgvbT9zLyk7XG4gICAgY29uc3QgdW5pdCA9IG1hdGNoZXMgPyBtYXRjaGVzWzBdIDogZmFsc2U7XG5cbiAgICBsZXQgbWlsbGlzZWNvbmRzO1xuXG4gICAgc3dpdGNoICh1bml0KSB7XG4gICAgICAgIGNhc2UgXCJzXCI6IC8vIHNlY29uZHNcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IG51bSAqIDEwMDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm1zXCI6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBtaWxsaXNlY29uZHMgPSBudW07XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gbWlsbGlzZWNvbmRzIHx8IDA7XG59O1xuXG5jb25zdCBhbmltYXRlZCA9IGZ1bmN0aW9uKGVsLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGRlZmF1bHRWaWV3ID0gKGVsLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQpLmRlZmF1bHRWaWV3O1xuXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNhbGxiYWNrLmFwcGx5KCk7XG4gICAgfSwgY29udmVydEFuaW1hdGlvbkRlbGF5VG9JbnQoZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbCkuYW5pbWF0aW9uRHVyYXRpb24pKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdhY3Rpdml0eS1idXR0b24nLFxuXG4gICAgY29tcG9uZW50czoge1xuICAgICAgICBBY3Rpdml0eUluZGljYXRvclxuICAgIH0sXG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYWtlIHRoZSBidXR0b24gYXBwZWFyIHdpdGggdGhlIGFjdGl2ZSBzdGF0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IHtCb29sZWF9bn1cbiAgICAgICAgICovXG4gICAgICAgIGFjdGl2ZTogQm9vbGVhbixcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvdyB0aGUgYWN0aXZpdHkgaW5kaWNhdG9yIGluc2lkZSB0aGUgYnV0dG9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkge0Jvb2xlYX1ufVxuICAgICAgICAgKi9cbiAgICAgICAgYWN0aXZpdHk6IEJvb2xlYW4sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc3BsYXkgdGhlIGJ1dHRvbiBhcyBibG9jayB3aWR0aC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IHtCb29sZWF9bn1cbiAgICAgICAgICovXG4gICAgICAgIGJsb2NrOiBCb29sZWFuLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYWtlIHRoZSBidXR0b24gYXBwZWFyIHdpdGggdGhlIGRpc2FibGVkIHN0YXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkge0Jvb2xlYX1ufVxuICAgICAgICAgKi9cbiAgICAgICAgZGlzYWJsZWQ6IEJvb2xlYW4sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBidXR0b24gbGFiZWwuIElmIG5vdCBwYXNzZWQgYXMgYSBwcm9wZXJ0eSwgbGFiZWwgbXVzdCBiZSBwYXNzZWRcbiAgICAgICAgICogaW5zaWRlIHRoZSBlbGVtZW50J3MgaHRtbC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IHtTdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBsYWJlbDogU3RyaW5nLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYnV0dG9uIGljb25cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IHtTdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBpY29uOiBTdHJpbmcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBgdHlwZWAgYXR0cmlidXRlIGZvciB0aGUgYnV0dG9uIGVsZW1lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdHlwZTogU3RyaW5nLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc2l6ZSBvZiB0aGUgYnV0dG9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkge1N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHNpemU6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdtZCdcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHZhcmlhbnQgb2YgdGhlIGJ1dHRvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IHtTdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB2YXJpYW50OiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAncHJpbWFyeSdcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHR5cGUgb2YgYWN0aXZpdHkgaW5kaWNhdG9yIGluc2lkZSB0aGUgYnV0dG9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkge1N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIGluZGljYXRvcjoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJ3NwaW5uZXInXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBvcmllbnRhdGlvbiBvZiB0aGUgYWN0aXZpdHkgYnV0dG9uIGluc2lkZSB0aGUgYnV0dG9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkge1N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIG9yaWVudGF0aW9uOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAncmlnaHQnXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWV0aG9kczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNhYmxlIHRoZSBidXR0b24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAgICAgKi9cbiAgICAgICAgZGlzYWJsZSgpIHtcbiAgICAgICAgICAgIHRoaXMuJGVsLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5hYmxlIHRoZSBidXR0b24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAgICAgKi9cbiAgICAgICAgZW5hYmxlKCkge1xuICAgICAgICAgICAgdGhpcy4kZWwuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvdyB0aGUgYWN0aXZpdHkgaW5kaWNhdG9yIGluc2lkZSB0aGUgYnV0dG9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgICAgICovXG4gICAgICAgIHNob3dBY3Rpdml0eSgpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzYWJsZSgpO1xuXG4gICAgICAgICAgICBhbmltYXRlZCh0aGlzLiRlbCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuJGVsLmNsYXNzTGlzdC5hZGQoJ2J0bi1hY3Rpdml0eScpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2FjdGl2aXR5OnNob3cnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIaWRlIHRoZSBhY3Rpdml0eSBpbmRpY2F0b3IgaW5zaWRlIHRoZSBidXR0b24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAgICAgKi9cbiAgICAgICAgaGlkZUFjdGl2aXR5KCkge1xuICAgICAgICAgICAgdGhpcy4kZWwuY2xhc3NMaXN0LmFkZCgnYnRuLWhpZGUtYWN0aXZpdHknKTtcblxuICAgICAgICAgICAgYW5pbWF0ZWQodGhpcy4kZWwsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmVuYWJsZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGVsLmNsYXNzTGlzdC5yZW1vdmUoJ2J0bi1hY3Rpdml0eScsICdidG4taGlkZS1hY3Rpdml0eScpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2FjdGl2aXR5OmhpZGUnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY2xpY2sgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB2b2lkXG4gICAgICAgICAqL1xuICAgICAgICBvbkNsaWNrKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCdjbGljaycsIGV2ZW50LCB0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGNvbXB1dGVkOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIG9iamVjdCBvZiBjbGFzc2VzIHRvIGFwcGVuZCB0byB0aGUgYnV0dG9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzZXMoKSB7XG4gICAgICAgICAgICBjb25zdCBjbGFzc2VzID0ge1xuICAgICAgICAgICAgICAgICdkaXNhYmxlZCc6IHRoaXMuZGlzYWJsZWQsXG4gICAgICAgICAgICAgICAgJ2FjdGl2ZSc6IHRoaXMuYWN0aXZlLFxuICAgICAgICAgICAgICAgICdidG4tYmxvY2snOiB0aGlzLmJsb2NrLFxuICAgICAgICAgICAgICAgICdidG4tYWN0aXZpdHknOiB0aGlzLmFjdGl2aXR5XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBjbGFzc2VzWydidG4tJyArIHRoaXMuc2l6ZS5yZXBsYWNlKCdidG4tJywgJycpXSA9ICEhdGhpcy5zaXplO1xuICAgICAgICAgICAgY2xhc3Nlc1snYnRuLScgKyB0aGlzLnZhcmlhbnQucmVwbGFjZSgnYnRuLScsICcnKV0gPSAhIXRoaXMudmFyaWFudDtcbiAgICAgICAgICAgIGNsYXNzZXNbJ2J0bi1hY3Rpdml0eS0nICsgdGhpcy5vcmllbnRhdGlvbi5yZXBsYWNlKCdidG4tYWN0aXZpdHktJywgJycpXSA9ICEhdGhpcy5vcmllbnRhdGlvbjtcbiAgICAgICAgICAgIGNsYXNzZXNbJ2J0bi1hY3Rpdml0eS1pbmRpY2F0b3ItJyArIHRoaXMuaW5kaWNhdG9yLnJlcGxhY2UoJ2J0bi1hY3Rpdml0eS1pbmRpY2F0b3ItJywgJycpXSA9ICEhdGhpcy5pbmRpY2F0b3I7XG5cbiAgICAgICAgICAgIHJldHVybiBjbGFzc2VzO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHdhdGNoOiB7XG5cbiAgICAgICAgYWN0aXZpdHkodmFsdWUpIHtcbiAgICAgICAgICAgIGlmKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaG93QWN0aXZpdHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaGlkZUFjdGl2aXR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH1cblxufVxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwic2Nzc1wiPlxuQGltcG9ydCAnLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwL3Njc3MvZnVuY3Rpb25zLnNjc3MnO1xuQGltcG9ydCAnLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwL3Njc3MvdmFyaWFibGVzLnNjc3MnO1xuXG4vLyBBY3Rpdml0eSBJbmRpY2F0b3IgdmFyaWFibGVzXG4kYWN0aXZpdHktaW5kaWNhdG9yLWFuaW1hdGVkLWRlbGF5LWluOiAzMzNtcztcbiRhY3Rpdml0eS1pbmRpY2F0b3ItYW5pbWF0ZWQtZGVsYXktb3V0OiAzMzNtcztcblxuJGFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyLXNpemU6ICRmb250LXNpemUtYmFzZSAqIDIuMjU7XG4kYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXItd2lkdGg6IDEwJTtcbiRhY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lci1oZWlnaHQ6IDMwJTtcbiRhY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lci1kZWxheTogMXM7XG5cbkBrZXlmcmFtZXMgYnRuLWFjdGl2aXR5LWluIHtcbiAgICAwJSwgMTAwJSB7XG4gICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMSk7XG4gICAgfSAzMCUge1xuICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKC45OCk7XG4gICAgfVxufVxuXG5Aa2V5ZnJhbWVzIGJ0bi1hY3Rpdml0eS1vdXQge1xuICAgIDAlLCAxMDAlIHtcbiAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgxKTtcbiAgICB9IDcwJSB7XG4gICAgICAgIHRyYW5zZm9ybTogc2NhbGUoLjk4KTtcbiAgICB9XG59XG5cbi8vIEFjdGl2aXR5IEluZGljYXRvciBCdXR0b25cbi5idG4tYWN0aXZpdHktdG9wLFxuLmJ0bi1hY3Rpdml0eS1ib3R0b20sXG4uYnRuLWFjdGl2aXR5LWxlZnQsXG4uYnRuLWFjdGl2aXR5LXJpZ2h0IHtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgdHJhbnNpdGlvbjogcGFkZGluZyAoJGFjdGl2aXR5LWluZGljYXRvci1hbmltYXRlZC1kZWxheS1pbiAvIDIpIGVhc2UtaW47XG5cbiAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICBvcGFjaXR5OiAwO1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcbiAgICAgICAgdHJhbnNpdGlvbjogb3BhY2l0eSAkYWN0aXZpdHktaW5kaWNhdG9yLWFuaW1hdGVkLWRlbGF5LW91dCBlYXNlLWluO1xuICAgIH1cbn1cblxuLmJ0bi1hY3Rpdml0eS10b3AgLmFjdGl2aXR5LWluZGljYXRvcixcbi5idG4tYWN0aXZpdHktYm90dG9tIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgIGxlZnQ6IDUwJTtcbiAgICBtYXJnaW4tcmlnaHQ6IC01MCU7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MCUpO1xufVxuLmJ0bi1hY3Rpdml0eS1sZWZ0IC5hY3Rpdml0eS1pbmRpY2F0b3IsXG4uYnRuLWFjdGl2aXR5LXJpZ2h0IC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgIHRvcDogNTAlO1xuICAgIG1hcmdpbi1ib3R0b206IC01MCU7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC01MCUpO1xufVxuXG4uYnRuLWFjdGl2aXR5Om5vdCguYnRuLWxpbmspIHtcbiAgICBhbmltYXRpb246IGJ0bi1hY3Rpdml0eS1pbiAkYWN0aXZpdHktaW5kaWNhdG9yLWFuaW1hdGVkLWRlbGF5LWluO1xufVxuLmJ0bi1oaWRlLWFjdGl2aXR5Om5vdCguYnRuLWxpbmspIHtcbiAgICBhbmltYXRpb246IGJ0bi1hY3Rpdml0eS1vdXQgJGFjdGl2aXR5LWluZGljYXRvci1hbmltYXRlZC1kZWxheS1vdXQ7XG59XG5cbi5idG4tYWN0aXZpdHkge1xuXG4gICAgJi5idG4taGlkZS1hY3Rpdml0eSAuYWN0aXZpdHktaW5kaWNhdG9yIHtcbiAgICAgICAgb3BhY2l0eTogMDtcbiAgICB9XG5cbiAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICBvcGFjaXR5OiAxO1xuICAgICAgICB2aXNpYmlsaXR5OiB2aXNpYmxlO1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgfVxuXG4gICAgJi5idG4tb3V0bGluZS1wcmltYXJ5LmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lciAuYWN0aXZpdHktaW5kaWNhdG9yID4gZGl2OmJlZm9yZSB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICRwcmltYXJ5O1xuICAgIH1cbiAgICAmLmJ0bi1vdXRsaW5lLXNlY29uZGFyeS5idG4tYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIgLmFjdGl2aXR5LWluZGljYXRvciA+IGRpdjpiZWZvcmUge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkc3VjY2VzcztcbiAgICB9XG4gICAgJi5idG4tb3V0bGluZS1kYW5nZXIuYnRuLWFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyIC5hY3Rpdml0eS1pbmRpY2F0b3IgPiBkaXY6YmVmb3JlIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogJGRhbmdlcjtcbiAgICB9XG4gICAgJi5idG4tb3V0bGluZS1zdWNjZXNzLmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lciAuYWN0aXZpdHktaW5kaWNhdG9yID4gZGl2OmJlZm9yZSB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICRzdWNjZXNzO1xuICAgIH1cbiAgICAmLmJ0bi1vdXRsaW5lLXdhcm5pbmcuYnRuLWFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyIC5hY3Rpdml0eS1pbmRpY2F0b3IgPiBkaXY6YmVmb3JlIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogJHdhcm5pbmc7XG4gICAgfVxuICAgICYuYnRuLW91dGxpbmUtaW5mby5idG4tYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIgLmFjdGl2aXR5LWluZGljYXRvciA+IGRpdjpiZWZvcmUge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkaW5mbztcbiAgICB9XG4gICAgJi5idG4tb3V0bGluZS1saW5rLmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lciAuYWN0aXZpdHktaW5kaWNhdG9yID4gZGl2OmJlZm9yZSB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICRsaW5rLWNvbG9yO1xuICAgIH1cblxuICAgICYuYnRuLXhzIHtcbiAgICAgICAgJi5idG4tYWN0aXZpdHktdG9wLmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyB7XG4gICAgICAgICAgICBwYWRkaW5nLXRvcDogJGZvbnQtc2l6ZS1iYXNlICogMS4yNTtcblxuICAgICAgICAgICAgJiAuYWN0aXZpdHktaW5kaWNhdG9yIHtcbiAgICAgICAgICAgICAgICB0b3A6ICRmb250LXNpemUtYmFzZSAqIC41O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJi5idG4tYWN0aXZpdHktYm90dG9tLmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyB7XG4gICAgICAgICAgICBwYWRkaW5nLWJvdHRvbTogJGZvbnQtc2l6ZS1iYXNlICogMS4yNTtcblxuICAgICAgICAgICAgJiAuYWN0aXZpdHktaW5kaWNhdG9yIHtcbiAgICAgICAgICAgICAgICBib3R0b206ICRmb250LXNpemUtYmFzZSAqIC41O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJi5idG4tYWN0aXZpdHktbGVmdC5idG4tYWN0aXZpdHktaW5kaWNhdG9yLWRvdHMge1xuICAgICAgICAgICAgcGFkZGluZy1sZWZ0OiAkZm9udC1zaXplLWJhc2UgKiAyLjMzO1xuXG4gICAgICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICAgICAgICAgIGxlZnQ6ICRmb250LXNpemUtYmFzZSAqIC41O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJi5idG4tYWN0aXZpdHktcmlnaHQuYnRuLWFjdGl2aXR5LWluZGljYXRvci1kb3RzIHtcbiAgICAgICAgICAgIHBhZGRpbmctcmlnaHQ6ICRmb250LXNpemUtYmFzZSAqIDIuMzM7XG5cbiAgICAgICAgICAgICYgLmFjdGl2aXR5LWluZGljYXRvciB7XG4gICAgICAgICAgICAgICAgcmlnaHQ6ICRmb250LXNpemUtYmFzZSAqIC41O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJi5idG4tYWN0aXZpdHktaW5kaWNhdG9yLWRvdHMgLmFjdGl2aXR5LWluZGljYXRvciA+IGRpdixcbiAgICAgICAgJiAuYWN0aXZpdHktaW5kaWNhdG9yLWRvdHMgPiBkaXYge1xuICAgICAgICAgICAgd2lkdGg6ICRmb250LXNpemUtYmFzZSAvIDM7XG4gICAgICAgICAgICBoZWlnaHQ6ICRmb250LXNpemUtYmFzZSAvIDM7XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS10b3AuYnRuLWFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyIHtcbiAgICAgICAgICAgIHBhZGRpbmctdG9wOiAkZm9udC1zaXplLWJhc2UgKiAxLjY2O1xuXG4gICAgICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICAgICAgICAgIHRvcDogJGZvbnQtc2l6ZS1iYXNlICogLjI1O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJi5idG4tYWN0aXZpdHktYm90dG9tLmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lciB7XG4gICAgICAgICAgICBwYWRkaW5nLWJvdHRvbTogJGZvbnQtc2l6ZS1iYXNlICogMS42NjtcblxuICAgICAgICAgICAgJiAuYWN0aXZpdHktaW5kaWNhdG9yIHtcbiAgICAgICAgICAgICAgICBib3R0b206ICRmb250LXNpemUtYmFzZSAqIC4yNTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICYuYnRuLWFjdGl2aXR5LWxlZnQuYnRuLWFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyIHtcbiAgICAgICAgICAgIHBhZGRpbmctbGVmdDogJGZvbnQtc2l6ZS1iYXNlICogMS42NjtcblxuICAgICAgICAgICAgJiAuYWN0aXZpdHktaW5kaWNhdG9yIHtcbiAgICAgICAgICAgICAgICBsZWZ0OiAkZm9udC1zaXplLWJhc2UgKiAuMjU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1yaWdodC5idG4tYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIge1xuICAgICAgICAgICAgcGFkZGluZy1yaWdodDogJGZvbnQtc2l6ZS1iYXNlICogMS42NjtcblxuICAgICAgICAgICAgJiAuYWN0aXZpdHktaW5kaWNhdG9yIHtcbiAgICAgICAgICAgICAgICByaWdodDogJGZvbnQtc2l6ZS1iYXNlICogLjI1O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJi5idG4tYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIgLmFjdGl2aXR5LWluZGljYXRvcixcbiAgICAgICAgJiAuYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIge1xuICAgICAgICAgICAgd2lkdGg6ICRmb250LXNpemUtYmFzZSAqIDE7XG4gICAgICAgICAgICBoZWlnaHQ6ICRmb250LXNpemUtYmFzZSAqIDE7XG5cbiAgICAgICAgICAgICYgPiBkaXY6YmVmb3JlIHtcbiAgICAgICAgICAgICAgICAvL3dpZHRoOiAkYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXItd2lkdGggKiAuNjM7XG4gICAgICAgICAgICAgICAgLy9oZWlnaHQ6ICRhY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lci1oZWlnaHQgKiAuNjY7XG4gICAgICAgICAgICAgICAgd2lkdGg6ICRhY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lci13aWR0aCAqIC44NDtcbiAgICAgICAgICAgICAgICBoZWlnaHQ6ICRhY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lci1oZWlnaHQgKiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgJi5idG4tc20ge1xuICAgICAgICAmLmJ0bi1hY3Rpdml0eS10b3AuYnRuLWFjdGl2aXR5LWluZGljYXRvci1kb3RzIHtcbiAgICAgICAgICAgIHBhZGRpbmctdG9wOiAkZm9udC1zaXplLWJhc2UgKiAxLjc1O1xuXG4gICAgICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICAgICAgICAgIHRvcDogJGZvbnQtc2l6ZS1iYXNlICogLjU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1ib3R0b20uYnRuLWFjdGl2aXR5LWluZGljYXRvci1kb3RzIHtcbiAgICAgICAgICAgIHBhZGRpbmctYm90dG9tOiAkZm9udC1zaXplLWJhc2UgKiAxLjc1O1xuXG4gICAgICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICAgICAgICAgIGJvdHRvbTogJGZvbnQtc2l6ZS1iYXNlICogLjU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1sZWZ0LmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyB7XG4gICAgICAgICAgICBwYWRkaW5nLWxlZnQ6ICRmb250LXNpemUtYmFzZSAqIDM7XG5cbiAgICAgICAgICAgICYgLmFjdGl2aXR5LWluZGljYXRvciB7XG4gICAgICAgICAgICAgICAgbGVmdDogJGZvbnQtc2l6ZS1iYXNlICogLjU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1yaWdodC5idG4tYWN0aXZpdHktaW5kaWNhdG9yLWRvdHMge1xuICAgICAgICAgICAgcGFkZGluZy1yaWdodDogJGZvbnQtc2l6ZS1iYXNlICogMztcblxuICAgICAgICAgICAgJiAuYWN0aXZpdHktaW5kaWNhdG9yIHtcbiAgICAgICAgICAgICAgICByaWdodDogJGZvbnQtc2l6ZS1iYXNlICogLjU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyAuYWN0aXZpdHktaW5kaWNhdG9yID4gZGl2LFxuICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyA+IGRpdiB7XG4gICAgICAgICAgICB3aWR0aDogJGZvbnQtc2l6ZS1iYXNlIC8gMjtcbiAgICAgICAgICAgIGhlaWdodDogJGZvbnQtc2l6ZS1iYXNlIC8gMjtcbiAgICAgICAgfVxuXG4gICAgICAgICYuYnRuLWFjdGl2aXR5LXRvcC5idG4tYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIge1xuICAgICAgICAgICAgcGFkZGluZy10b3A6ICRmb250LXNpemUtYmFzZSAqIDI7XG5cbiAgICAgICAgICAgICYgLmFjdGl2aXR5LWluZGljYXRvciB7XG4gICAgICAgICAgICAgICAgdG9wOiAkZm9udC1zaXplLWJhc2UgKiAuMzM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1ib3R0b20uYnRuLWFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyIHtcbiAgICAgICAgICAgIHBhZGRpbmctYm90dG9tOiAkZm9udC1zaXplLWJhc2UgKiAyO1xuXG4gICAgICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICAgICAgICAgIGJvdHRvbTogJGZvbnQtc2l6ZS1iYXNlICogLjMzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJi5idG4tYWN0aXZpdHktbGVmdC5idG4tYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIge1xuICAgICAgICAgICAgcGFkZGluZy1sZWZ0OiAkZm9udC1zaXplLWJhc2UgKiAyLjU7XG5cbiAgICAgICAgICAgICYgLmFjdGl2aXR5LWluZGljYXRvciB7XG4gICAgICAgICAgICAgICAgbGVmdDogJGZvbnQtc2l6ZS1iYXNlICogLjU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1yaWdodC5idG4tYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIge1xuICAgICAgICAgICAgcGFkZGluZy1yaWdodDogJGZvbnQtc2l6ZS1iYXNlICogMi41O1xuXG4gICAgICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICAgICAgICAgIHJpZ2h0OiAkZm9udC1zaXplLWJhc2UgKiAuNTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICYuYnRuLWFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyIC5hY3Rpdml0eS1pbmRpY2F0b3IsXG4gICAgICAgICYgLmFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyIHtcbiAgICAgICAgICAgIHdpZHRoOiAkZm9udC1zaXplLWJhc2UgKiAxLjU7XG4gICAgICAgICAgICBoZWlnaHQ6ICRmb250LXNpemUtYmFzZSAqIDEuNTtcblxuICAgICAgICAgICAgJiA+IGRpdjpiZWZvcmUge1xuICAgICAgICAgICAgICAgIHdpZHRoOiAkYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXItd2lkdGggKiAuNTY7XG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAkYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXItaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgJjpub3QoLmJ0bi14cyk6bm90KC5idG4tc20pOm5vdCguYnRuLW1kKTpub3QoLmJ0bi1sZyk6bm90KC5idG4teGwpLFxuICAgICYuYnRuLW1kIHtcbiAgICAgICAgJi5idG4tYWN0aXZpdHktdG9wLmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyB7XG4gICAgICAgICAgICBwYWRkaW5nLXRvcDogJGZvbnQtc2l6ZS1iYXNlICogMjtcblxuICAgICAgICAgICAgJiAuYWN0aXZpdHktaW5kaWNhdG9yIHtcbiAgICAgICAgICAgICAgICB0b3A6ICRmb250LXNpemUtYmFzZSAqIC42NjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICYuYnRuLWFjdGl2aXR5LWJvdHRvbS5idG4tYWN0aXZpdHktaW5kaWNhdG9yLWRvdHMge1xuICAgICAgICAgICAgcGFkZGluZy1ib3R0b206ICRmb250LXNpemUtYmFzZSAqIDI7XG5cbiAgICAgICAgICAgICYgLmFjdGl2aXR5LWluZGljYXRvciB7XG4gICAgICAgICAgICAgICAgYm90dG9tOiAkZm9udC1zaXplLWJhc2UgKiAuNjY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1sZWZ0LmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyB7XG4gICAgICAgICAgICBwYWRkaW5nLWxlZnQ6ICRmb250LXNpemUtYmFzZSAqIDQ7XG5cbiAgICAgICAgICAgICYgLmFjdGl2aXR5LWluZGljYXRvciB7XG4gICAgICAgICAgICAgICAgbGVmdDogJGZvbnQtc2l6ZS1iYXNlICogLjU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1yaWdodC5idG4tYWN0aXZpdHktaW5kaWNhdG9yLWRvdHMge1xuICAgICAgICAgICAgcGFkZGluZy1yaWdodDogJGZvbnQtc2l6ZS1iYXNlICogNDtcblxuICAgICAgICAgICAgJiAuYWN0aXZpdHktaW5kaWNhdG9yIHtcbiAgICAgICAgICAgICAgICByaWdodDogJGZvbnQtc2l6ZS1iYXNlICogLjU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyAuYWN0aXZpdHktaW5kaWNhdG9yID4gZGl2LFxuICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyA+IGRpdiB7XG4gICAgICAgICAgICB3aWR0aDogJGZvbnQtc2l6ZS1iYXNlIC8gMS4yNTtcbiAgICAgICAgICAgIGhlaWdodDogJGZvbnQtc2l6ZS1iYXNlIC8gMS4yNTtcbiAgICAgICAgfVxuXG4gICAgICAgICYuYnRuLWFjdGl2aXR5LXRvcC5idG4tYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIge1xuICAgICAgICAgICAgcGFkZGluZy10b3A6ICRmb250LXNpemUtYmFzZSAqIDIuNzU7XG5cbiAgICAgICAgICAgICYgLmFjdGl2aXR5LWluZGljYXRvciB7XG4gICAgICAgICAgICAgICAgdG9wOiAkZm9udC1zaXplLWJhc2UgKiAuMzM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1ib3R0b20uYnRuLWFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyIHtcbiAgICAgICAgICAgIHBhZGRpbmctYm90dG9tOiAkZm9udC1zaXplLWJhc2UgKiAyLjc1O1xuXG4gICAgICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICAgICAgICAgIGJvdHRvbTogJGZvbnQtc2l6ZS1iYXNlICogLjMzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJi5idG4tYWN0aXZpdHktbGVmdC5idG4tYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIge1xuICAgICAgICAgICAgcGFkZGluZy1sZWZ0OiAkZm9udC1zaXplLWJhc2UgKiAyLjc1O1xuXG4gICAgICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICAgICAgICAgIGxlZnQ6ICRmb250LXNpemUtYmFzZSAqIC41O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJi5idG4tYWN0aXZpdHktcmlnaHQuYnRuLWFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyIHtcbiAgICAgICAgICAgIHBhZGRpbmctcmlnaHQ6ICRmb250LXNpemUtYmFzZSAqIDIuNzU7XG5cbiAgICAgICAgICAgICYgLmFjdGl2aXR5LWluZGljYXRvciB7XG4gICAgICAgICAgICAgICAgcmlnaHQ6ICRmb250LXNpemUtYmFzZSAqIC41O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJi5idG4tYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIgLmFjdGl2aXR5LWluZGljYXRvcixcbiAgICAgICAgJiAuYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIge1xuICAgICAgICAgICAgd2lkdGg6ICRmb250LXNpemUtYmFzZSAqIDEuNzU7XG4gICAgICAgICAgICBoZWlnaHQ6ICRmb250LXNpemUtYmFzZSAqIDEuNzU7XG5cbiAgICAgICAgICAgICYgPiBkaXY6YmVmb3JlIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogJGFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyLXdpZHRoICogLjY2O1xuICAgICAgICAgICAgICAgIGhlaWdodDogJGFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyLWhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgICYuYnRuLWxnIHtcbiAgICAgICAgJi5idG4tYWN0aXZpdHktdG9wLmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyB7XG4gICAgICAgICAgICBwYWRkaW5nLXRvcDogJGZvbnQtc2l6ZS1iYXNlICogMi43NTtcblxuICAgICAgICAgICAgJiAuYWN0aXZpdHktaW5kaWNhdG9yIHtcbiAgICAgICAgICAgICAgICB0b3A6ICRmb250LXNpemUtYmFzZSAqIC42NjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICYuYnRuLWFjdGl2aXR5LWJvdHRvbS5idG4tYWN0aXZpdHktaW5kaWNhdG9yLWRvdHMge1xuICAgICAgICAgICAgcGFkZGluZy1ib3R0b206ICRmb250LXNpemUtYmFzZSAqIDIuNzU7XG5cbiAgICAgICAgICAgICYgLmFjdGl2aXR5LWluZGljYXRvciB7XG4gICAgICAgICAgICAgICAgYm90dG9tOiAkZm9udC1zaXplLWJhc2UgKiAuNjY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1sZWZ0LmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyB7XG4gICAgICAgICAgICBwYWRkaW5nLWxlZnQ6ICRmb250LXNpemUtYmFzZSAqIDU7XG5cbiAgICAgICAgICAgICYgLmFjdGl2aXR5LWluZGljYXRvciB7XG4gICAgICAgICAgICAgICAgbGVmdDogJGZvbnQtc2l6ZS1iYXNlICogLjU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1yaWdodC5idG4tYWN0aXZpdHktaW5kaWNhdG9yLWRvdHMge1xuICAgICAgICAgICAgcGFkZGluZy1yaWdodDogJGZvbnQtc2l6ZS1iYXNlICogNTtcblxuICAgICAgICAgICAgJiAuYWN0aXZpdHktaW5kaWNhdG9yIHtcbiAgICAgICAgICAgICAgICByaWdodDogJGZvbnQtc2l6ZS1iYXNlICogLjU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyAuYWN0aXZpdHktaW5kaWNhdG9yID4gZGl2LFxuICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyA+IGRpdiB7XG4gICAgICAgICAgICB3aWR0aDogJGZvbnQtc2l6ZS1iYXNlICogMS4xO1xuICAgICAgICAgICAgaGVpZ2h0OiAkZm9udC1zaXplLWJhc2UgKiAxLjE7XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS10b3AuYnRuLWFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyIHtcbiAgICAgICAgICAgIHBhZGRpbmctdG9wOiAkZm9udC1zaXplLWJhc2UgKiAzLjU7XG5cbiAgICAgICAgICAgICYgLmFjdGl2aXR5LWluZGljYXRvciB7XG4gICAgICAgICAgICAgICAgdG9wOiAkZm9udC1zaXplLWJhc2UgKiAuNTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICYuYnRuLWFjdGl2aXR5LWJvdHRvbS5idG4tYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIge1xuICAgICAgICAgICAgcGFkZGluZy1ib3R0b206ICRmb250LXNpemUtYmFzZSAqIDMuNTtcblxuICAgICAgICAgICAgJiAuYWN0aXZpdHktaW5kaWNhdG9yIHtcbiAgICAgICAgICAgICAgICBib3R0b206ICRmb250LXNpemUtYmFzZSAqIC41O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJi5idG4tYWN0aXZpdHktbGVmdC5idG4tYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIge1xuICAgICAgICAgICAgcGFkZGluZy1sZWZ0OiAkZm9udC1zaXplLWJhc2UgKiAzLjI1O1xuXG4gICAgICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICAgICAgICAgIGxlZnQ6ICRmb250LXNpemUtYmFzZSAqIC41O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJi5idG4tYWN0aXZpdHktcmlnaHQuYnRuLWFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyIHtcbiAgICAgICAgICAgIHBhZGRpbmctcmlnaHQ6ICRmb250LXNpemUtYmFzZSAqIDMuMjU7XG5cbiAgICAgICAgICAgICYgLmFjdGl2aXR5LWluZGljYXRvciB7XG4gICAgICAgICAgICAgICAgcmlnaHQ6ICRmb250LXNpemUtYmFzZSAqIC41O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJi5idG4tYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIgLmFjdGl2aXR5LWluZGljYXRvcixcbiAgICAgICAgJiAuYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIge1xuICAgICAgICAgICAgd2lkdGg6ICRmb250LXNpemUtYmFzZSAqIDIuMTU7XG4gICAgICAgICAgICBoZWlnaHQ6ICRmb250LXNpemUtYmFzZSAqIDIuMTU7XG5cbiAgICAgICAgICAgICYgPiBkaXY6YmVmb3JlIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogJGFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyLXdpZHRoICogLjc1O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgJi5idG4teGwge1xuICAgICAgICAmLmJ0bi1hY3Rpdml0eS10b3AuYnRuLWFjdGl2aXR5LWluZGljYXRvci1kb3RzIHtcbiAgICAgICAgICAgIHBhZGRpbmctdG9wOiAkZm9udC1zaXplLWJhc2UgKiAzLjc1O1xuXG4gICAgICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICAgICAgICAgIHRvcDogJGZvbnQtc2l6ZS1iYXNlICogMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICYuYnRuLWFjdGl2aXR5LWJvdHRvbS5idG4tYWN0aXZpdHktaW5kaWNhdG9yLWRvdHMge1xuICAgICAgICAgICAgcGFkZGluZy1ib3R0b206ICRmb250LXNpemUtYmFzZSAqIDMuNzU7XG5cbiAgICAgICAgICAgICYgLmFjdGl2aXR5LWluZGljYXRvciB7XG4gICAgICAgICAgICAgICAgYm90dG9tOiAkZm9udC1zaXplLWJhc2UgKiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJi5idG4tYWN0aXZpdHktbGVmdC5idG4tYWN0aXZpdHktaW5kaWNhdG9yLWRvdHMge1xuICAgICAgICAgICAgcGFkZGluZy1sZWZ0OiAkZm9udC1zaXplLWJhc2UgKiA2O1xuXG4gICAgICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICAgICAgICAgIGxlZnQ6ICRmb250LXNpemUtYmFzZSAqIC43NTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICYuYnRuLWFjdGl2aXR5LXJpZ2h0LmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyB7XG4gICAgICAgICAgICBwYWRkaW5nLXJpZ2h0OiAkZm9udC1zaXplLWJhc2UgKiA2O1xuXG4gICAgICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICAgICAgICAgIHJpZ2h0OiAkZm9udC1zaXplLWJhc2UgKiAuNzU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyAuYWN0aXZpdHktaW5kaWNhdG9yID4gZGl2LFxuICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3ItZG90cyA+IGRpdiB7XG4gICAgICAgICAgICB3aWR0aDogJGZvbnQtc2l6ZS1iYXNlICogMS4yNTtcbiAgICAgICAgICAgIGhlaWdodDogJGZvbnQtc2l6ZS1iYXNlICogMS4yNTtcbiAgICAgICAgfVxuXG4gICAgICAgICYuYnRuLWFjdGl2aXR5LXRvcC5idG4tYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIge1xuICAgICAgICAgICAgcGFkZGluZy10b3A6ICRmb250LXNpemUtYmFzZSAqIDQuMjU7XG5cbiAgICAgICAgICAgICYgLmFjdGl2aXR5LWluZGljYXRvciB7XG4gICAgICAgICAgICAgICAgdG9wOiAkZm9udC1zaXplLWJhc2UgKiAuNjY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1ib3R0b20uYnRuLWFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyIHtcbiAgICAgICAgICAgIHBhZGRpbmctYm90dG9tOiAkZm9udC1zaXplLWJhc2UgKiA0LjI1O1xuXG4gICAgICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICAgICAgICAgIGJvdHRvbTogJGZvbnQtc2l6ZS1iYXNlICogLjY2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJi5idG4tYWN0aXZpdHktbGVmdC5idG4tYWN0aXZpdHktaW5kaWNhdG9yLXNwaW5uZXIge1xuICAgICAgICAgICAgcGFkZGluZy1sZWZ0OiAkZm9udC1zaXplLWJhc2UgKiA0O1xuXG4gICAgICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICAgICAgICAgIGxlZnQ6ICRmb250LXNpemUtYmFzZSAqIC43NTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICYuYnRuLWFjdGl2aXR5LXJpZ2h0LmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lciB7XG4gICAgICAgICAgICBwYWRkaW5nLXJpZ2h0OiAkZm9udC1zaXplLWJhc2UgKiA0O1xuXG4gICAgICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Ige1xuICAgICAgICAgICAgICAgIHJpZ2h0OiAkZm9udC1zaXplLWJhc2UgKiAuNzU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmLmJ0bi1hY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lciAuYWN0aXZpdHktaW5kaWNhdG9yLFxuICAgICAgICAmIC5hY3Rpdml0eS1pbmRpY2F0b3Itc3Bpbm5lciB7XG4gICAgICAgICAgICB3aWR0aDogJGZvbnQtc2l6ZS1iYXNlICogMi41O1xuICAgICAgICAgICAgaGVpZ2h0OiAkZm9udC1zaXplLWJhc2UgKiAyLjU7XG5cbiAgICAgICAgICAgICYgPiBkaXY6YmVmb3JlIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogJGFjdGl2aXR5LWluZGljYXRvci1zcGlubmVyLXdpZHRoICogLjc1O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG59XG48L3N0eWxlPlxuIiwiaW1wb3J0IEJ0bkFjdGl2aXR5IGZyb20gJy4vQnRuQWN0aXZpdHknO1xuaW1wb3J0IFZ1ZUluc3RhbGxlciBmcm9tICcuLi8uLi9IZWxwZXJzL1Z1ZUluc3RhbGxlci9WdWVJbnN0YWxsZXInO1xuXG5jb25zdCBwbHVnaW4gPSBWdWVJbnN0YWxsZXIudXNlKHtcblxuICAgIGluc3RhbGwoVnVlLCBvcHRpb25zKSB7XG4gICAgICAgIFZ1ZUluc3RhbGxlci5jb21wb25lbnRzKHtcbiAgICAgICAgICAgIEJ0bkFjdGl2aXR5XG4gICAgICAgIH0pXG4gICAgfVxuXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgQnRuQWN0aXZpdHk7XG4iLCI8dGVtcGxhdGU+XG4gICAgPGRpdiBjbGFzcz1cIm1vZGFsLWJvZHlcIj48c2xvdC8+PC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ21vZGFsLWJvZHknXG5cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICAgIDxkaXYgY2xhc3M9XCJtb2RhbC1iYWNrZHJvcFwiIDpjbGFzcz1cInsnZmFkZSc6IGZhZGUsICdzaG93Jzogc2hvd31cIj5cbiAgICAgICAgPHNsb3QvPlxuICAgIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdtb2RhbC1iYWNrZHJvcCcsXG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG93IHRoZSBtb2RhbCB3aXRoIGEgZmFkZSBlZmZlY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBCb29sZWFuXG4gICAgICAgICAqL1xuICAgICAgICBmYWRlOiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJcyB0aGUgbW9kYWwgc2hvd2luZy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IEJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIHNob3c6IHtcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgICBkZWZhdWx0OiB0cnVlXG4gICAgICAgIH1cblxuICAgIH1cblxufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gICAgPGRpdiBjbGFzcz1cIm1vZGFsLWNvbnRlbnRcIj48c2xvdC8+PC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ21vZGFsLWNvbnRlbnQnXG5cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICAgIDxkaXYgY2xhc3M9XCJtb2RhbC1kaWFsb2dcIiByb2xlPVwiZG9jdW1lbnRcIj48c2xvdC8+PC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ21vZGFsLWRpYWxvZydcblxufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gICAgPGg1IGNsYXNzPVwibW9kYWwtdGl0bGVcIj48c2xvdC8+PC9oNT5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAnbW9kYWwtdGl0bGUnXG5cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICAgIDxkaXYgY2xhc3M9XCJtb2RhbC1oZWFkZXJcIj5cbiAgICAgICAgPHNsb3QgbmFtZT1cInRpdGxlXCI+XG4gICAgICAgICAgICA8bW9kYWwtdGl0bGU+PHNsb3QvPjwvbW9kYWwtdGl0bGU+XG4gICAgICAgIDwvc2xvdD5cblxuICAgICAgICA8c2xvdCBuYW1lPVwiY2xvc2UtYnV0dG9uXCI+XG4gICAgICAgICAgICA8YnV0dG9uIHYtaWY9XCJjbG9zZWFibGVcIiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJjbG9zZVwiIGFyaWEtbGFiZWw9XCJhcmlhTGFiZWxcIiBAY2xpY2s9XCIkZW1pdCgnY2xvc2UnKVwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPiZ0aW1lczs8L3NwYW4+XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPC9zbG90PlxuICAgIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBNb2RhbFRpdGxlIGZyb20gJy4vTW9kYWxUaXRsZSc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdtb2RhbC1oZWFkZXInLFxuXG4gICAgY29tcG9uZW50czoge1xuICAgICAgICBNb2RhbFRpdGxlXG4gICAgfSxcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgYXJpYUxhYmVsOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAnQ2xvc2UnXG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xvc2VhYmxlOiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgICB9XG5cbiAgICB9XG5cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICAgIDxkaXYgY2xhc3M9XCJtb2RhbC1mb290ZXJcIj48c2xvdC8+PC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ21vZGFsLWZvb3RlcidcblxufVxuPC9zY3JpcHQ+XG4iLCJmdW5jdGlvbiBkdXJhdGlvbihlbCkge1xuICAgIGNvbnN0IGR1cmF0aW9uID0gZ2V0Q29tcHV0ZWRTdHlsZShlbCkudHJhbnNpdGlvbkR1cmF0aW9uO1xuICAgIGNvbnN0IG51bWVyaWMgPSBwYXJzZUZsb2F0KGR1cmF0aW9uLCAxMCkgfHwgMDtcbiAgICBjb25zdCB1bml0ID0gZHVyYXRpb24ubWF0Y2goL20/cy8pO1xuXG4gICAgc3dpdGNoICh1bml0WzBdKSB7XG4gICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgcmV0dXJuIG51bWVyaWMgKiAxMDAwO1xuICAgICAgICBjYXNlICdtcyc6XG4gICAgICAgICAgICByZXR1cm4gbnVtZXJpYztcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRyYW5zaXRpb24oZWwpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZGVsYXkgPSBkdXJhdGlvbihlbCk7XG5cbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoZGVsYXkpXG4gICAgICAgICAgICB9LCBkZWxheSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2goZSkge1xuICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4iLCJpbXBvcnQgeyBlYWNoIH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCB7IGlzU3RyaW5nIH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCB0cmFuc2l0aW9uIGZyb20gJy4uLy4uL0hlbHBlcnMvVHJhbnNpdGlvbic7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3cgdGhlIHRyaWdnZXJhYmxlIGVsZW1lbnQgd2l0aCBhIGZhZGUgZWZmZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGZhZGU6IHtcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgICBkZWZhdWx0OiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElzIHRoZSB0cmlnZ2VyYWJsZSBlbGVtZW50IHNob3dpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBCb29sZWFuXG4gICAgICAgICAqL1xuICAgICAgICBzaG93OiBCb29sZWFuLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGFyZ2V0IGVsZW1lbnQgdXNlZCB0byBwb3NpdGlvbiB0aGUgcG9wb3Zlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge1N0cmluZ3xFbGVtZW50fEJvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0YXJnZXQ6IHtcbiAgICAgICAgICAgIHR5cGU6IFtTdHJpbmcsIEVsZW1lbnQsIEJvb2xlYW5dLFxuICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSG93IHRoZSBtb2RhbCBpcyB0cmlnZ2VyZWQgLSBjbGljayB8IGhvdmVyIHwgZm9jdXMgfCBtYW51YWwuIFlvdSBtYXlcbiAgICAgICAgICogcGFzcyBtdWx0aXBsZSB0cmlnZ2Vyczsgc2VwYXJhdGUgdGhlbSB3aXRoIGEgc3BhY2UuIGBtYW51YWxgIGNhbm5vdFxuICAgICAgICAgKiBiZSBjb21iaW5lZCB3aXRoIGFueSBvdGhlciB0cmlnZ2VyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdHJpZ2dlcjoge1xuICAgICAgICAgICAgdHlwZTogW1N0cmluZywgQXJyYXldLFxuICAgICAgICAgICAgZGVmYXVsdDogJ2NsaWNrJ1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgbWV0aG9kczoge1xuXG4gICAgICAgIGluaXRpYWxpemVUcmlnZ2VyKGVsKSB7XG4gICAgICAgICAgICBlYWNoKGlzU3RyaW5nKHRoaXMudHJpZ2dlcikgPyB0aGlzLnRyaWdnZXIuc3BsaXQoJyAnKSA6IHRoaXMudHJpZ2dlciwgdHJpZ2dlciA9PiB7XG4gICAgICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcih0cmlnZ2VyLCBldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9nZ2xlKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRm9jdXMgb24gdGhlIGZpcnN0IGZpZWxkIGluIHRoZSBtb2RhbCAoaWYgZXhpc3RzKS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB2b2lkXG4gICAgICAgICAqL1xuICAgICAgICBmb2N1cygpIHtcbiAgICAgICAgICAgIGNvbnN0IGVsID0gdGhpcy4kZWwucXVlcnlTZWxlY3RvcignLmZvcm0tY29udHJvbCwgaW5wdXQsIHNlbGVjdCwgdGV4dGFyZWEnKTtcblxuICAgICAgICAgICAgaWYoZWwpIHtcbiAgICAgICAgICAgICAgICBlbC5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kZWwuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogT3BlbiB0aGUgdHJpZ2dlcmVhYmxlIGVsZW1lbnRcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB2b2lkXG4gICAgICAgICAqL1xuICAgICAgICBvcGVuKCkge1xuICAgICAgICAgICAgdGhpcy5pc0Rpc3BsYXlpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICB0aGlzLiRuZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbih0aGlzLiRlbCkudGhlbihkZWxheSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNTaG93aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZW1pdCgnb3BlbicpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsb3NlIHRoZSB0cmlnZ2VyZWFibGUgZWxlbWVudFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgICAgICovXG4gICAgICAgIGNsb3NlKGV2ZW50KSB7XG4gICAgICAgICAgICB0cmFuc2l0aW9uKHRoaXMuJGVsKS50aGVuKGRlbGF5ID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzRGlzcGxheWluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2Nsb3NlJywgZXZlbnQsIHRoaXMpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMuaXNTaG93aW5nID0gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRvZ2dsZSB0aGUgdHJpZ2dlcmVhYmxlIGVsZW1lbnQncyBvcGVuL2Nsb3NlIG1ldGhvZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB2b2lkXG4gICAgICAgICAqL1xuICAgICAgICB0b2dnbGUoKSB7XG4gICAgICAgICAgICBpZighdGhpcy5pc1Nob3dpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wZW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGNvbXB1dGVkOiB7XG5cbiAgICAgICAgdHJpZ2dlcmFibGVDbGFzc2VzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAnZmFkZSc6IHRoaXMuZmFkZSxcbiAgICAgICAgICAgICAgICAnc2hvdyc6IHRoaXMuaXNTaG93aW5nXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgd2F0Y2g6IHtcblxuICAgICAgICBpc1Nob3dpbmcodmFsdWUpIHtcbiAgICAgICAgICAgIGlmKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHNob3codmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuaXNTaG93aW5nID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBtb3VudGVkKCkge1xuICAgICAgICBpZih0aGlzLnRhcmdldCAmJiB0aGlzLnRyaWdnZXIgIT09ICdtYW51YWwnKSB7XG4gICAgICAgICAgICBpZih0aGlzLnRhcmdldCBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRpYWxpemVUcmlnZ2VyKHRoaXMudGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwodGhpcy50YXJnZXQpLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluaXRpYWxpemVUcmlnZ2VyKGVsKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNEaXNwbGF5aW5nOiB0aGlzLnNob3cgfHwgIXRoaXMudGFyZ2V0LFxuICAgICAgICAgICAgaXNTaG93aW5nOiB0aGlzLnNob3cgfHwgIXRoaXMudGFyZ2V0XG4gICAgICAgIH1cbiAgICB9XG5cbn1cbiIsIjx0ZW1wbGF0ZT5cblxuICAgIDxkaXYgY2xhc3M9XCJtb2RhbFwiIDpjbGFzcz1cInRyaWdnZXJhYmxlQ2xhc3Nlc1wiIDpzdHlsZT1cIntkaXNwbGF5OiBpc0Rpc3BsYXlpbmcgPyAnYmxvY2snIDogJ25vbmUnfVwiIHRhYmluZGV4PVwiLTFcIiByb2xlPVwiZGlhbG9nXCIgQGtleWRvd24uZXNjPVwib25Fc2NcIj5cblxuICAgICAgICA8bW9kYWwtZGlhbG9nIDpjbGFzcz1cInsnbW9kYWwtZGlhbG9nLWNlbnRlcmVkJzogY2VudGVyfVwiPlxuXG4gICAgICAgICAgICA8bW9kYWwtY29udGVudD5cblxuICAgICAgICAgICAgICAgIDxzbG90IG5hbWU9XCJoZWFkZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgPG1vZGFsLWhlYWRlciB2LWlmPVwidGl0bGVcIiBAY2xvc2U9XCJjYW5jZWxcIj57e3RpdGxlfX08L21vZGFsLWhlYWRlcj5cbiAgICAgICAgICAgICAgICA8L3Nsb3Q+XG5cbiAgICAgICAgICAgICAgICA8c2xvdCBuYW1lPVwiYm9keVwiPlxuICAgICAgICAgICAgICAgICAgICA8Y29tcG9uZW50IDppcz1cIiFmbHVzaCA/ICdtb2RhbC1ib2R5JyA6ICdkaXYnXCIgY2xhc3M9XCJjaGlsZC1jb21wb25lbnRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzbG90Lz5cbiAgICAgICAgICAgICAgICAgICAgPC9jb21wb25lbnQ+XG4gICAgICAgICAgICAgICAgPC9zbG90PlxuXG4gICAgICAgICAgICAgICAgPHNsb3QgbmFtZT1cImZvb3RlclwiPlxuICAgICAgICAgICAgICAgICAgICA8bW9kYWwtZm9vdGVyIHYtaWY9XCJ0eXBlXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGVtcGxhdGUgdi1pZj1cInR5cGUgPT09ICdhbGVydCdcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnRuLWFjdGl2aXR5IDphY3Rpdml0eT1cImFjdGl2aXR5XCIgdmFyaWFudD1cInByaW1hcnlcIiBAY2xpY2s9XCJjb25maXJtXCIgdi1odG1sPVwib2tMYWJlbFwiLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdGVtcGxhdGU+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGVtcGxhdGUgdi1lbHNlPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidG4gdHlwZT1cImJ1dHRvblwiIHZhcmlhbnQ9XCJzZWNvbmRhcnlcIiBAY2xpY2s9XCJjYW5jZWxcIiB2LWh0bWw9XCJjYW5jZWxMYWJlbFwiLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnRuLWFjdGl2aXR5IDphY3Rpdml0eT1cImFjdGl2aXR5XCIgdmFyaWFudD1cInByaW1hcnlcIiBAY2xpY2s9XCJjb25maXJtXCIgdi1odG1sPVwib2tMYWJlbFwiLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdGVtcGxhdGU+XG4gICAgICAgICAgICAgICAgICAgIDwvbW9kYWwtZm9vdGVyPlxuICAgICAgICAgICAgICAgIDwvc2xvdD5cblxuICAgICAgICAgICAgPC9tb2RhbC1jb250ZW50PlxuXG4gICAgICAgIDwvbW9kYWwtZGlhbG9nPlxuXG4gICAgPC9kaXY+XG5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgeyBlYWNoIH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCB7IGlzU3RyaW5nIH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCBCdG5BY3Rpdml0eSBmcm9tICcuLi9CdG5BY3Rpdml0eSc7XG5pbXBvcnQgTW9kYWxCb2R5IGZyb20gJy4vTW9kYWxCb2R5JztcbmltcG9ydCBNb2RhbEJhY2tkcm9wIGZyb20gJy4vTW9kYWxCYWNrZHJvcCc7XG5pbXBvcnQgTW9kYWxDb250ZW50IGZyb20gJy4vTW9kYWxDb250ZW50JztcbmltcG9ydCBNb2RhbERpYWxvZyBmcm9tICcuL01vZGFsRGlhbG9nJztcbmltcG9ydCBNb2RhbEhlYWRlciBmcm9tICcuL01vZGFsSGVhZGVyJztcbmltcG9ydCBNb2RhbEZvb3RlciBmcm9tICcuL01vZGFsRm9vdGVyJztcbmltcG9ydCBUcmlnZ2VyYWJsZSBmcm9tICcuLi8uLi9NaXhpbnMvVHJpZ2dlcmFibGUnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAnbW9kYWwnLFxuXG4gICAgY29tcG9uZW50czoge1xuICAgICAgICBCdG5BY3Rpdml0eSxcbiAgICAgICAgTW9kYWxCb2R5LFxuICAgICAgICBNb2RhbEJhY2tkcm9wLFxuICAgICAgICBNb2RhbENvbnRlbnQsXG4gICAgICAgIE1vZGFsRGlhbG9nLFxuICAgICAgICBNb2RhbEhlYWRlcixcbiAgICAgICAgTW9kYWxGb290ZXJcbiAgICB9LFxuXG4gICAgbWl4aW5zOiBbXG4gICAgICAgIFRyaWdnZXJhYmxlXG4gICAgXSxcblxuICAgIHdhdGNoOiB7XG5cbiAgICAgICAgaXNTaG93aW5nKHZhbHVlKSB7XG4gICAgICAgICAgICBpZih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2JvZHknKS5jbGFzc0xpc3QuYWRkKCdtb2RhbC1vcGVuJyk7XG5cbiAgICAgICAgICAgICAgICBpZih0aGlzLmJhY2tkcm9wICYmICFkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcubW9kYWwtYmFja2Ryb3AnKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJhY2tkcm9wQ29tcG9uZW50ID0gbmV3IChWdWUuZXh0ZW5kKE1vZGFsQmFja2Ryb3ApKSgpLiRtb3VudChcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykpXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYm9keScpLmNsYXNzTGlzdC5yZW1vdmUoJ21vZGFsLW9wZW4nKTtcblxuICAgICAgICAgICAgICAgIGlmKHRoaXMuYmFja2Ryb3BDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iYWNrZHJvcENvbXBvbmVudC4kZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJhY2tkcm9wQ29tcG9uZW50LiRlbC5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iYWNrZHJvcENvbXBvbmVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLiRlbWl0KCd1cGRhdGU6c2hvdycsIHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3cgdGhlIG1vZGFsIGFjdGl2aXR5IGluZGljYXRvci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBhY3Rpdml0eTogQm9vbGVhbixcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvdyB0aGUgbW9kYWwgd2l0aCBhIGJhY2tkcm9wLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGJhY2tkcm9wOiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSXMgdGhlIG1vZGFsIGNlbnRlcmVkIGluIHRoZSBzY3JlZW4uXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgY2VudGVyOiBCb29sZWFuLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJcyB0aGUgbW9kYWwgY29udGVudCBmaXhlZCBwb3NpdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGNsb3NlYWJsZToge1xuICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSXMgdGhlIG1vZGFsIGNvbnRlbnQgZmx1c2ggd2l0aCB0aGUgbW9kYWwgZWRnZXM/IElmIHRydWUsIG5vIG1vZGFsLWJvZHlcbiAgICAgICAgICogd2lsbCBiZSB1c2VkIHRvIHdyYXAgdGhlIGNvbnRlbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgZmx1c2g6IEJvb2xlYW4sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBvayBsYWJlbCB0ZXh0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgb2tMYWJlbDoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJ09rJ1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY2FuY2VsIGxhYmVsIHRleHQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBjYW5jZWxMYWJlbDoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJ0NhbmNlbCdcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1vZGFsIHRpdGxlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGl0bGU6IFN0cmluZyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSXMgdGhlIG1vZGFsIHR5cGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgdHlwZTogW0Jvb2xlYW4sIFN0cmluZ10sXG4gICAgICAgICAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsnYWxlcnQnLCAnY29uZmlybScsICdwcm9tcHQnXS5pbmRleE9mKHZhbHVlKSAhPT0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBtZXRob2RzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbmNlbCB0aGUgbW9kYWxcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB2b2lkXG4gICAgICAgICAqL1xuICAgICAgICBjYW5jZWwoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2NhbmNlbCcsIGV2ZW50LCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoZXZlbnQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25maXJtIHRoZSBtb2RhbFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgICAgICovXG4gICAgICAgIGNvbmZpcm0oZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2NvbmZpcm0nLCBldmVudCwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgY2FsbGJhY2sgZm9yIHRoZSBlc2NhcGUgZnVuY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAgICAgKi9cbiAgICAgICAgb25Fc2MoZXZlbnQpIHtcbiAgICAgICAgICAgICh0aGlzLnR5cGUgPT09ICdjb25maXJtJyB8fCB0aGlzLnR5cGUgPT09ICAncHJvbXB0JykgPyB0aGlzLmNhbmNlbChldmVudCkgOiB0aGlzLmNsb3NlKGV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBiYWNrZHJvcENvbXBvbmVudDogbnVsbCxcbiAgICAgICAgICAgIGlzRGlzcGxheWluZzogdGhpcy5zaG93IHx8ICF0aGlzLnRhcmdldCxcbiAgICAgICAgICAgIGlzU2hvd2luZzogdGhpcy5zaG93IHx8ICF0aGlzLnRhcmdldFxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGJlZm9yZVJvdXRlTGVhdmUodG8sIGZyb20sIG5leHQpIHtcbiAgICAgICAgbW9kYWwuY2xvc2UoKTtcbiAgICB9XG5cbn1cblxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgeyBpc1N0cmluZyB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgeyBpc09iamVjdCB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgeyBpc0Z1bmN0aW9uIH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCB7IGRlZmF1bHRzRGVlcCB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgTW9kYWwgZnJvbSAnLi4vLi4vQ29tcG9uZW50cy9Nb2RhbC9Nb2RhbCc7XG5cbmZ1bmN0aW9uIGVuc3VyZShvcHRpb25zLCB2YWx1ZXMpIHtcbiAgICBpZighb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJvcHNEYXRhOiBkZWZhdWx0c0RlZXAob3B0aW9ucy5wcm9wc0RhdGEgfHwgb3B0aW9ucywgdmFsdWVzIHx8IHt9KVxuICAgIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKFZ1ZSwgb3B0aW9ucykge1xuICAgIGZ1bmN0aW9uIHJlbW92ZShtb2RhbCkge1xuICAgICAgICBtb2RhbC4kZGVzdHJveSgpO1xuICAgICAgICBtb2RhbC4kZWwucmVtb3ZlKCk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHByb21pc2UobW9kYWwpIHtcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGxldCBwcmV2ZW50RGVmYXVsdCA9IGZhbHNlO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBmaW5pc2gobW9kYWwpIHtcbiAgICAgICAgICAgICAgICBpZighcHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kYWwuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1vZGFsLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZXZlbnREZWZhdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIG1vZGFsLiRvbignY29uZmlybScsIGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnY29uZmlybScpO1xuICAgICAgICAgICAgICAgIC8vcHJvbWlzZS50aGVuKGZpbmlzaCk7XG4gICAgICAgICAgICAgICAgLy9yZXNvbHZlKG1vZGFsKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBtb2RhbC4kb24oJ2NhbmNlbCcsIGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICByZWplY3QobW9kYWwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cblxuICAgIFZ1ZS5wcm90b3R5cGUuJG1vZGFsID0gZnVuY3Rpb24odGl0bGUsIGNvbnRlbnQsIG9wdGlvbnMsIG1vZGFsT3B0aW9ucywgTW9kYWxDb21wb25lbnQpIHtcbiAgICAgICAgaWYoaXNTdHJpbmcoY29udGVudCkpIHtcbiAgICAgICAgICAgIGNvbnRlbnQgPSBWdWUuZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYDxkaXY+JHtjb250ZW50fTwvZGl2PmBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY29tcG9uZW50ID0gKHZ1ZSwgb3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgaWYoISh2dWUgaW5zdGFuY2VvZiBWdWUpICYmIGlzT2JqZWN0KHZ1ZSkpIHtcbiAgICAgICAgICAgICAgICB2dWUgPSBWdWUuZXh0ZW5kKHZ1ZSk7XG4gICAgICAgICAgICAgICAgdnVlLm9wdGlvbnMucm91dGUgPSB0aGlzLiRyb3V0ZTtcbiAgICAgICAgICAgICAgICB2dWUub3B0aW9ucy5yb3V0ZXIgPSB0aGlzLiRyb3V0ZXI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKHZ1ZSkgPyBuZXcgdnVlKG9wdGlvbnMpIDogdnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbW9kYWwgPSBjb21wb25lbnQoTW9kYWxDb21wb25lbnQgfHwgTW9kYWwsIGVuc3VyZShtb2RhbE9wdGlvbnMpKTtcbiAgICAgICAgbW9kYWwuJGNvbnRlbnQgPSBjb21wb25lbnQoY29udGVudCwgZW5zdXJlKG9wdGlvbnMpKTtcbiAgICAgICAgbW9kYWwub3Blbihtb2RhbC4kY29udGVudCk7XG5cbiAgICAgICAgbW9kYWwuJG9uKCdjYW5jZWwnLCBldmVudCA9PiB7XG4gICAgICAgICAgICBtb2RhbC4kY29udGVudC4kZW1pdCgnbW9kYWw6Y2FuY2VsJyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1vZGFsLiRvbignY2xvc2UnLCBldmVudCA9PiB7XG4gICAgICAgICAgICBtb2RhbC4kY29udGVudC4kZW1pdCgnbW9kYWw6Y2xvc2UnKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbW9kYWwuJG9uKCdjb25maXJtJywgZXZlbnQgPT4ge1xuICAgICAgICAgICAgbW9kYWwuJGNvbnRlbnQuJGVtaXQoJ21vZGFsOmNvbmZpcm0nKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbW9kYWwuJGNvbnRlbnQuJG9uKCdtb2RhbDpjbG9zZScsIGV2ZW50ID0+IHtcbiAgICAgICAgICAgIG1vZGFsLmNsb3NlKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBtb2RhbDtcbiAgICB9O1xuXG4gICAgVnVlLnByb3RvdHlwZS4kYWxlcnQgPSBmdW5jdGlvbih0aXRsZSwgY29udGVudCwgb3B0aW9ucywgbW9kYWxPcHRpb25zLCBNb2RhbENvbXBvbmVudCkge1xuICAgICAgICByZXR1cm4gcHJvbWlzZSh0aGlzLiRtb2RhbChcbiAgICAgICAgICAgIHRpdGxlLCBjb250ZW50LCBvcHRpb25zLCBlbnN1cmUoe3R5cGU6ICdhbGVydCcsIHRpdGxlOiB0aXRsZX0sIG1vZGFsT3B0aW9ucyksIE1vZGFsQ29tcG9uZW50XG4gICAgICAgICkpO1xuICAgIH07XG5cbiAgICBWdWUucHJvdG90eXBlLiRjb25maXJtID0gZnVuY3Rpb24odGl0bGUsIGNvbnRlbnQsIG9wdGlvbnMsIG1vZGFsT3B0aW9ucywgTW9kYWxDb21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2UodGhpcy4kbW9kYWwoXG4gICAgICAgICAgICB0aXRsZSwgY29udGVudCwgb3B0aW9ucywgZW5zdXJlKHt0eXBlOiAnY29uZmlybScsIHRpdGxlOiB0aXRsZX0sIG1vZGFsT3B0aW9ucyksIE1vZGFsQ29tcG9uZW50XG4gICAgICAgICkpO1xuICAgIH07XG5cbiAgICBWdWUucHJvdG90eXBlLiRwcm9tcHQgPSBmdW5jdGlvbih0aXRsZSwgY29udGVudCwgb3B0aW9ucywgbW9kYWxPcHRpb25zLCBNb2RhbENvbXBvbmVudCkge1xuICAgICAgICBtb2RhbE9wdGlvbnMgPSBlbnN1cmUoe1xuICAgICAgICAgICAgdGl0bGU6IHRpdGxlLFxuICAgICAgICAgICAgdHlwZTogJ3Byb21wdCcsXG4gICAgICAgIH0sIG1vZGFsT3B0aW9ucyk7XG5cbiAgICAgICAgcmV0dXJuIHByb21pc2UodGhpcy4kbW9kYWwoXG4gICAgICAgICAgICB0aXRsZSwgY29udGVudCwgb3B0aW9ucywgbW9kYWxPcHRpb25zLCBNb2RhbENvbXBvbmVudFxuICAgICAgICApKTtcbiAgICB9O1xuXG59XG4iLCI8dGVtcGxhdGU+XG4gICAgPGRpdiBjbGFzcz1cIm92ZXJsYXktYm9keVwiPjxzbG90Lz48L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAnb3ZlcmxheS1ib2R5J1xuXG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cblxuICAgIDxkaXYgY2xhc3M9XCJjb250YWluZXJcIj48c2xvdC8+PC9kaXY+XG5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5cblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ2NvbnRhaW5lcidcblxufVxuXG48L3NjcmlwdD5cbiIsImltcG9ydCBDb250YWluZXIgZnJvbSAnLi9Db250YWluZXInO1xuaW1wb3J0IFZ1ZUluc3RhbGxlciBmcm9tICcuLi8uLi9IZWxwZXJzL1Z1ZUluc3RhbGxlci9WdWVJbnN0YWxsZXInO1xuXG5jb25zdCBwbHVnaW4gPSBWdWVJbnN0YWxsZXIudXNlKHtcblxuICAgIGluc3RhbGwoVnVlLCBvcHRpb25zKSB7XG4gICAgICAgIFZ1ZUluc3RhbGxlci5jb21wb25lbnRzKHtcbiAgICAgICAgICAgIENvbnRhaW5lclxuICAgICAgICB9KTtcbiAgICB9XG5cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBDb250YWluZXI7XG4iLCI8dGVtcGxhdGU+XG4gICAgPGNvbnRhaW5lciBjbGFzcz1cIm92ZXJsYXktY29udGVudFwiPlxuICAgICAgICA8c2xvdC8+XG4gICAgPC9jb250YWluZXI+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IENvbnRhaW5lciBmcm9tICcuLi9Db250YWluZXInO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAnb3ZlcmxheS1jb250ZW50JyxcblxuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgICAgQ29udGFpbmVyXG4gICAgfVxuXG59XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJzY3NzXCI+XG5AaW1wb3J0ICcuL25vZGVfbW9kdWxlcy9ib290c3RyYXAvc2Nzcy9mdW5jdGlvbnMuc2Nzcyc7XG5AaW1wb3J0ICcuL25vZGVfbW9kdWxlcy9ib290c3RyYXAvc2Nzcy92YXJpYWJsZXMuc2Nzcyc7XG5cbi5vdmVybGF5LWNvbnRlbnQge1xuICAgIG1hcmdpbjogMCBhdXRvO1xuICAgIG92ZXJmbG93LXk6IGF1dG87XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuXG4gICAgJi5vdmVybGF5LWNvbnRlbnQtY2VudGVyIHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cbiAgICAgICAgLm92ZXJsYXktYm9keSB7XG4gICAgICAgICAgICBmbGV4OiAxO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgJi5vdmVybGF5LWNvbnRlbnQtZml4ZWQge1xuICAgICAgICB0b3A6IDA7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIHBhZGRpbmc6IDA7XG4gICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgICBtYXgtd2lkdGg6IG5vbmU7XG4gICAgfVxuXG4gICAgLm92ZXJsYXktY29udHJvbHMge1xuICAgICAgICBmbG9hdDogcmlnaHQ7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgdG9wOiA0cHg7XG4gICAgICAgIHBhZGRpbmctcmlnaHQ6IDA7XG4gICAgICAgIHBhZGRpbmctYm90dG9tOiAkZm9udC1zaXplLWJhc2U7XG5cbiAgICAgICAgJi5sZWZ0IHtcbiAgICAgICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIH1cbiAgICAgICAgJi5yaWdodCB7XG4gICAgICAgICAgICByaWdodDogMDtcbiAgICAgICAgfVxuXG4gICAgICAgICYgKyAqIHtcbiAgICAgICAgICAgIGNsZWFyOiBib3RoO1xuICAgICAgICB9XG4gICAgfVxufVxuPC9zdHlsZT5cbiIsIjx0ZW1wbGF0ZT5cbiAgICA8ZGl2IGNsYXNzPVwib3ZlcmxheVwiIDpjbGFzcz1cInRyaWdnZXJhYmxlQ2xhc3Nlc1wiIDpzdHlsZT1cInsnYmFja2dyb3VuZCc6IGJhY2tncm91bmQsICdkaXNwbGF5JzogaXNEaXNwbGF5aW5nID8gJ2ZsZXgnIDogJ25vbmUnfVwiIHJvbGU9XCJkaWFsb2dcIiB0YWJpbmRleD1cIi0xXCIgQGtleWRvd24uZXNjPVwib25Fc2NcIj5cbiAgICAgICAgPGJ1dHRvbiB2LWlmPVwiY2xvc2VhYmxlICYmICFoaWRlQ2xvc2VCdXR0b25cIiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLWxpbmsgb3ZlcmxheS1jbG9zZVwiIEBjbGljaz1cIm9uQ2xpY2tDbG9zZVwiPlxuICAgICAgICAgICAgPGkgY2xhc3M9XCJmYSBmYS10aW1lcy1jaXJjbGVcIj48L2k+XG4gICAgICAgIDwvYnV0dG9uPlxuXG4gICAgICAgIDxvdmVybGF5LWNvbnRlbnQgOmNsYXNzPVwieydvdmVybGF5LWNvbnRlbnQtZml4ZWQnOiBmaXhlZENvbnRlbnQsICdvdmVybGF5LWNvbnRlbnQtY2VudGVyJzogY2VudGVyfVwiIDpzdHlsZT1cInttaW5IZWlnaHQ6IG1pbkhlaWdodH1cIj5cbiAgICAgICAgICAgIDxzbG90IG5hbWU9XCJib2R5XCI+XG4gICAgICAgICAgICAgICAgPG92ZXJsYXktYm9keT5cbiAgICAgICAgICAgICAgICAgICAgPHNsb3QvPlxuICAgICAgICAgICAgICAgIDwvb3ZlcmxheS1ib2R5PlxuICAgICAgICAgICAgPC9zbG90PlxuICAgICAgICA8L292ZXJsYXktY29udGVudD5cbiAgICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgT3ZlcmxheUJvZHkgZnJvbSAnLi9PdmVybGF5Qm9keSc7XG5pbXBvcnQgT3ZlcmxheUNvbnRlbnQgZnJvbSAnLi9PdmVybGF5Q29udGVudCc7XG5pbXBvcnQgVHJpZ2dlcmFibGUgZnJvbSAnLi4vLi4vTWl4aW5zL1RyaWdnZXJhYmxlJztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ292ZXJsYXknLFxuXG4gICAgY29tcG9uZW50czoge1xuICAgICAgICBPdmVybGF5Qm9keSxcbiAgICAgICAgT3ZlcmxheUNvbnRlbnRcbiAgICB9LFxuXG4gICAgbWl4aW5zOiBbXG4gICAgICAgIFRyaWdnZXJhYmxlXG4gICAgXSxcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBvdmVybGF5IGJhY2tncm91bmQgY29sb3IuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGJhY2tncm91bmQ6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIC45MjUpJ1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJcyB0aGUgb3ZlcmxheSBjb250ZW50IGZpeGVkIHBvc2l0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBCb29sZWFuXG4gICAgICAgICAqL1xuICAgICAgICBjbG9zZWFibGU6IHtcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgICBkZWZhdWx0OiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENlbnRlciB0aGUgb3ZlcmxheSBjb250ZW50IG9uIHRoZSBzY3JlZW4gdXNpbmcgZmxleCBib3guXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgY2VudGVyOiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJcyB0aGUgb3ZlcmxheSBjb250ZW50IGZpeGVkIHBvc2l0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBCb29sZWFuXG4gICAgICAgICAqL1xuICAgICAgICBmaXhlZENvbnRlbnQ6IEJvb2xlYW4sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElzIHRoZSBvdmVybGF5IGNsb3NlIGJ1dHRvbiBoaWRkZW4gYnV0IHN0aWxsIGNsb3NlYWJsZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IEJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIGhpZGVDbG9zZUJ1dHRvbjogQm9vbGVhbixcblxuICAgICAgICAvKipcbiAgICAgICAgICogSXMgdGhlIG92ZXJsYXkgY29udGVudCBtaW5pbXVtIGhlaWdodC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IEJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIG1pbkhlaWdodDogW1N0cmluZywgTnVtYmVyXVxuXG4gICAgfSxcblxuICAgIG1ldGhvZHM6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNhbGxiYWNrIGZvciB0aGUgYGNsaWNrYCBldmVudCBvbiB0aGUgY2xvc2UgYnV0dG9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgICAgICovXG4gICAgICAgIG9uQ2xpY2tDbG9zZShldmVudCkge1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgnY2xpY2s6Y2xvc2UnLCBldmVudCwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25Fc2MoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VhYmxlICYmIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG59XG5cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cInNjc3NcIj5cbkBpbXBvcnQgJy4vbm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC9zY3NzL2Z1bmN0aW9ucy5zY3NzJztcbkBpbXBvcnQgJy4vbm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC9zY3NzL3ZhcmlhYmxlcy5zY3NzJztcblxuLm92ZXJsYXkge1xuICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIG1pbi1oZWlnaHQ6IDA7XG4gICAgdG9wOiAwO1xuICAgIGxlZnQ6IDA7XG4gICAgei1pbmRleDogLTE7XG4gICAgb3BhY2l0eTogMDtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBoZWlnaHQ6IDEwMCU7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBhbGlnbi1jb250ZW50OiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcblxuICAgICYuZmFkZSB7XG4gICAgICAgIHRyYW5zaXRpb246IG9wYWNpdHkgMzMzbXMgZWFzZS1vdXQ7XG4gICAgfVxuXG4gICAgJi5zaG93IHtcbiAgICAgICAgei1pbmRleDogMTAwMDA7XG4gICAgICAgIG9wYWNpdHk6IDE7XG4gICAgfVxuXG4gICAgLm92ZXJsYXktY29udGVudCB7XG4gICAgICAgIGZsZXg6IDE7XG4gICAgfVxuXG4gICAgLm92ZXJsYXktaGVhZGVyIHtcbiAgICAgICAgbWFyZ2luLXRvcDogJGZvbnQtc2l6ZS1iYXNlICogMS41O1xuICAgIH1cblxuICAgIC5vdmVybGF5LWNsb3NlIHtcbiAgICAgICAgZm9udC1zaXplOiAkZm9udC1zaXplLWJhc2UgKiAxLjI1O1xuICAgICAgICBjb2xvcjogJGdyYXktNzAwO1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogJGZvbnQtc2l6ZS1iYXNlO1xuICAgICAgICByaWdodDogJGZvbnQtc2l6ZS1iYXNlO1xuICAgICAgICB6LWluZGV4OiAxO1xuICAgIH1cbn1cbjwvc3R5bGU+XG4iLCJpbXBvcnQgeyBpc09iamVjdCB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgeyBpc0Z1bmN0aW9uIH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCB7IGRlZmF1bHRzRGVlcCB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgT3ZlcmxheSBmcm9tICcuLi8uLi9Db21wb25lbnRzL092ZXJsYXkvT3ZlcmxheSc7XG5cbmZ1bmN0aW9uIGVuc3VyZShvcHRpb25zLCB2YWx1ZXMpIHtcbiAgICBpZighb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJvcHNEYXRhOiBkZWZhdWx0c0RlZXAob3B0aW9ucy5wcm9wc0RhdGEgfHwgb3B0aW9ucywgdmFsdWVzIHx8IHt9KVxuICAgIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKFZ1ZSwgb3B0aW9ucykge1xuICAgIFZ1ZS5wcm90b3R5cGUuJG92ZXJsYXkgPSBmdW5jdGlvbihDb250ZW50Q29tcG9uZW50LCBvcHRpb25zLCBvdmVybGF5T3B0aW9ucywgQ3VzdG9tT3ZlcmxheUNvbXBvbmVudCkge1xuICAgICAgICBjb25zdCBjb21wb25lbnQgPSAodnVlLCBvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICBpZighKHZ1ZSBpbnN0YW5jZW9mIFZ1ZSkgJiYgaXNPYmplY3QodnVlKSkge1xuICAgICAgICAgICAgICAgIHZ1ZSA9IFZ1ZS5leHRlbmQodnVlKTtcbiAgICAgICAgICAgICAgICB2dWUub3B0aW9ucy5yb3V0ZSA9IHRoaXMuJHJvdXRlO1xuICAgICAgICAgICAgICAgIHZ1ZS5vcHRpb25zLnJvdXRlciA9IHRoaXMuJHJvdXRlcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24odnVlKSA/IG5ldyB2dWUob3B0aW9ucykgOiB2dWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvdmVybGF5ID0gY29tcG9uZW50KEN1c3RvbU92ZXJsYXlDb21wb25lbnQgfHwgT3ZlcmxheSwgZW5zdXJlKG92ZXJsYXlPcHRpb25zKSk7XG4gICAgICAgIG92ZXJsYXkuJGNvbnRlbnQgPSBjb21wb25lbnQoQ29udGVudENvbXBvbmVudCwgZW5zdXJlKG9wdGlvbnMpKTtcbiAgICAgICAgb3ZlcmxheS5zaG93KG92ZXJsYXkuJGNvbnRlbnQpO1xuICAgICAgICByZXR1cm4gb3ZlcmxheTtcbiAgICB9O1xufVxuIiwiaW1wb3J0IHsgaXNPYmplY3QgfSBmcm9tICdsb2Rhc2gtZXMnO1xuXG4vKlxuaW1wb3J0IHsgZGVmYXVsdHNEZWVwIH0gZnJvbSAnbG9kYXNoLWVzJztcblxuZnVuY3Rpb24gZW5zdXJlKG9wdGlvbnMsIHZhbHVlcykge1xuICAgIGlmKCFvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBwcm9wc0RhdGE6IGRlZmF1bHRzRGVlcChvcHRpb25zLnByb3BzRGF0YSB8fCBvcHRpb25zLCB2YWx1ZXMgfHwge30pXG4gICAgfTtcbn1cbiovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGluc3RhbmNlKFZ1ZSwgQ29tcG9uZW50LCBvcHRpb25zKSB7XG4gICAgaWYoQ29tcG9uZW50IGluc3RhbmNlb2YgVnVlKSB7XG4gICAgICAgIHJldHVybiBDb21wb25lbnQ7XG4gICAgfVxuXG4gICAgaWYoaXNPYmplY3QoQ29tcG9uZW50KSkge1xuICAgICAgICBDb21wb25lbnQgPSBWdWUuZXh0ZW5kKENvbXBvbmVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBDb21wb25lbnQob3B0aW9ucyk7XG59XG4iLCIvKiohXG4gKiBAZmlsZU92ZXJ2aWV3IEtpY2thc3MgbGlicmFyeSB0byBjcmVhdGUgYW5kIHBsYWNlIHBvcHBlcnMgbmVhciB0aGVpciByZWZlcmVuY2UgZWxlbWVudHMuXG4gKiBAdmVyc2lvbiAxLjE0LjNcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYgRmVkZXJpY28gWml2b2xvIGFuZCBjb250cmlidXRvcnNcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqIFNPRlRXQVJFLlxuICovXG52YXIgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcblxudmFyIGxvbmdlclRpbWVvdXRCcm93c2VycyA9IFsnRWRnZScsICdUcmlkZW50JywgJ0ZpcmVmb3gnXTtcbnZhciB0aW1lb3V0RHVyYXRpb24gPSAwO1xuZm9yICh2YXIgaSA9IDA7IGkgPCBsb25nZXJUaW1lb3V0QnJvd3NlcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgaWYgKGlzQnJvd3NlciAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YobG9uZ2VyVGltZW91dEJyb3dzZXJzW2ldKSA+PSAwKSB7XG4gICAgdGltZW91dER1cmF0aW9uID0gMTtcbiAgICBicmVhaztcbiAgfVxufVxuXG5mdW5jdGlvbiBtaWNyb3Rhc2tEZWJvdW5jZShmbikge1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNhbGxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsZWQgPSB0cnVlO1xuICAgIHdpbmRvdy5Qcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxlZCA9IGZhbHNlO1xuICAgICAgZm4oKTtcbiAgICB9KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdGFza0RlYm91bmNlKGZuKSB7XG4gIHZhciBzY2hlZHVsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXNjaGVkdWxlZCkge1xuICAgICAgc2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBzY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgZm4oKTtcbiAgICAgIH0sIHRpbWVvdXREdXJhdGlvbik7XG4gICAgfVxuICB9O1xufVxuXG52YXIgc3VwcG9ydHNNaWNyb1Rhc2tzID0gaXNCcm93c2VyICYmIHdpbmRvdy5Qcm9taXNlO1xuXG4vKipcbiogQ3JlYXRlIGEgZGVib3VuY2VkIHZlcnNpb24gb2YgYSBtZXRob2QsIHRoYXQncyBhc3luY2hyb25vdXNseSBkZWZlcnJlZFxuKiBidXQgY2FsbGVkIGluIHRoZSBtaW5pbXVtIHRpbWUgcG9zc2libGUuXG4qXG4qIEBtZXRob2RcbiogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuKiBAYXJndW1lbnQge0Z1bmN0aW9ufSBmblxuKiBAcmV0dXJucyB7RnVuY3Rpb259XG4qL1xudmFyIGRlYm91bmNlID0gc3VwcG9ydHNNaWNyb1Rhc2tzID8gbWljcm90YXNrRGVib3VuY2UgOiB0YXNrRGVib3VuY2U7XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGEgZnVuY3Rpb25cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7QW55fSBmdW5jdGlvblRvQ2hlY2sgLSB2YXJpYWJsZSB0byBjaGVja1xuICogQHJldHVybnMge0Jvb2xlYW59IGFuc3dlciB0bzogaXMgYSBmdW5jdGlvbj9cbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbihmdW5jdGlvblRvQ2hlY2spIHtcbiAgdmFyIGdldFR5cGUgPSB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uVG9DaGVjayAmJiBnZXRUeXBlLnRvU3RyaW5nLmNhbGwoZnVuY3Rpb25Ub0NoZWNrKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn1cblxuLyoqXG4gKiBHZXQgQ1NTIGNvbXB1dGVkIHByb3BlcnR5IG9mIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VlbWVudH0gZWxlbWVudFxuICogQGFyZ3VtZW50IHtTdHJpbmd9IHByb3BlcnR5XG4gKi9cbmZ1bmN0aW9uIGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbGVtZW50LCBwcm9wZXJ0eSkge1xuICBpZiAoZWxlbWVudC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICAvLyBOT1RFOiAxIERPTSBhY2Nlc3MgaGVyZVxuICB2YXIgY3NzID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBudWxsKTtcbiAgcmV0dXJuIHByb3BlcnR5ID8gY3NzW3Byb3BlcnR5XSA6IGNzcztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwYXJlbnROb2RlIG9yIHRoZSBob3N0IG9mIHRoZSBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBwYXJlbnRcbiAqL1xuZnVuY3Rpb24gZ2V0UGFyZW50Tm9kZShlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50Lm5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuICByZXR1cm4gZWxlbWVudC5wYXJlbnROb2RlIHx8IGVsZW1lbnQuaG9zdDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzY3JvbGxpbmcgcGFyZW50IG9mIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBzY3JvbGwgcGFyZW50XG4gKi9cbmZ1bmN0aW9uIGdldFNjcm9sbFBhcmVudChlbGVtZW50KSB7XG4gIC8vIFJldHVybiBib2R5LCBgZ2V0U2Nyb2xsYCB3aWxsIHRha2UgY2FyZSB0byBnZXQgdGhlIGNvcnJlY3QgYHNjcm9sbFRvcGAgZnJvbSBpdFxuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuYm9keTtcbiAgfVxuXG4gIHN3aXRjaCAoZWxlbWVudC5ub2RlTmFtZSkge1xuICAgIGNhc2UgJ0hUTUwnOlxuICAgIGNhc2UgJ0JPRFknOlxuICAgICAgcmV0dXJuIGVsZW1lbnQub3duZXJEb2N1bWVudC5ib2R5O1xuICAgIGNhc2UgJyNkb2N1bWVudCc6XG4gICAgICByZXR1cm4gZWxlbWVudC5ib2R5O1xuICB9XG5cbiAgLy8gRmlyZWZveCB3YW50IHVzIHRvIGNoZWNrIGAteGAgYW5kIGAteWAgdmFyaWF0aW9ucyBhcyB3ZWxsXG5cbiAgdmFyIF9nZXRTdHlsZUNvbXB1dGVkUHJvcCA9IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbGVtZW50KSxcbiAgICAgIG92ZXJmbG93ID0gX2dldFN0eWxlQ29tcHV0ZWRQcm9wLm92ZXJmbG93LFxuICAgICAgb3ZlcmZsb3dYID0gX2dldFN0eWxlQ29tcHV0ZWRQcm9wLm92ZXJmbG93WCxcbiAgICAgIG92ZXJmbG93WSA9IF9nZXRTdHlsZUNvbXB1dGVkUHJvcC5vdmVyZmxvd1k7XG5cbiAgaWYgKC8oYXV0b3xzY3JvbGx8b3ZlcmxheSkvLnRlc3Qob3ZlcmZsb3cgKyBvdmVyZmxvd1kgKyBvdmVyZmxvd1gpKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICByZXR1cm4gZ2V0U2Nyb2xsUGFyZW50KGdldFBhcmVudE5vZGUoZWxlbWVudCkpO1xufVxuXG52YXIgaXNJRTExID0gaXNCcm93c2VyICYmICEhKHdpbmRvdy5NU0lucHV0TWV0aG9kQ29udGV4dCAmJiBkb2N1bWVudC5kb2N1bWVudE1vZGUpO1xudmFyIGlzSUUxMCA9IGlzQnJvd3NlciAmJiAvTVNJRSAxMC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBicm93c2VyIGlzIEludGVybmV0IEV4cGxvcmVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge051bWJlcn0gdmVyc2lvbiB0byBjaGVja1xuICogQHJldHVybnMge0Jvb2xlYW59IGlzSUVcbiAqL1xuZnVuY3Rpb24gaXNJRSh2ZXJzaW9uKSB7XG4gIGlmICh2ZXJzaW9uID09PSAxMSkge1xuICAgIHJldHVybiBpc0lFMTE7XG4gIH1cbiAgaWYgKHZlcnNpb24gPT09IDEwKSB7XG4gICAgcmV0dXJuIGlzSUUxMDtcbiAgfVxuICByZXR1cm4gaXNJRTExIHx8IGlzSUUxMDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBvZmZzZXQgcGFyZW50IG9mIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBvZmZzZXQgcGFyZW50XG4gKi9cbmZ1bmN0aW9uIGdldE9mZnNldFBhcmVudChlbGVtZW50KSB7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIH1cblxuICB2YXIgbm9PZmZzZXRQYXJlbnQgPSBpc0lFKDEwKSA/IGRvY3VtZW50LmJvZHkgOiBudWxsO1xuXG4gIC8vIE5PVEU6IDEgRE9NIGFjY2VzcyBoZXJlXG4gIHZhciBvZmZzZXRQYXJlbnQgPSBlbGVtZW50Lm9mZnNldFBhcmVudDtcbiAgLy8gU2tpcCBoaWRkZW4gZWxlbWVudHMgd2hpY2ggZG9uJ3QgaGF2ZSBhbiBvZmZzZXRQYXJlbnRcbiAgd2hpbGUgKG9mZnNldFBhcmVudCA9PT0gbm9PZmZzZXRQYXJlbnQgJiYgZWxlbWVudC5uZXh0RWxlbWVudFNpYmxpbmcpIHtcbiAgICBvZmZzZXRQYXJlbnQgPSAoZWxlbWVudCA9IGVsZW1lbnQubmV4dEVsZW1lbnRTaWJsaW5nKS5vZmZzZXRQYXJlbnQ7XG4gIH1cblxuICB2YXIgbm9kZU5hbWUgPSBvZmZzZXRQYXJlbnQgJiYgb2Zmc2V0UGFyZW50Lm5vZGVOYW1lO1xuXG4gIGlmICghbm9kZU5hbWUgfHwgbm9kZU5hbWUgPT09ICdCT0RZJyB8fCBub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQgPyBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IDogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB9XG5cbiAgLy8gLm9mZnNldFBhcmVudCB3aWxsIHJldHVybiB0aGUgY2xvc2VzdCBURCBvciBUQUJMRSBpbiBjYXNlXG4gIC8vIG5vIG9mZnNldFBhcmVudCBpcyBwcmVzZW50LCBJIGhhdGUgdGhpcyBqb2IuLi5cbiAgaWYgKFsnVEQnLCAnVEFCTEUnXS5pbmRleE9mKG9mZnNldFBhcmVudC5ub2RlTmFtZSkgIT09IC0xICYmIGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShvZmZzZXRQYXJlbnQsICdwb3NpdGlvbicpID09PSAnc3RhdGljJykge1xuICAgIHJldHVybiBnZXRPZmZzZXRQYXJlbnQob2Zmc2V0UGFyZW50KTtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXRQYXJlbnQ7XG59XG5cbmZ1bmN0aW9uIGlzT2Zmc2V0Q29udGFpbmVyKGVsZW1lbnQpIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZTtcblxuICBpZiAobm9kZU5hbWUgPT09ICdCT0RZJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gbm9kZU5hbWUgPT09ICdIVE1MJyB8fCBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZCkgPT09IGVsZW1lbnQ7XG59XG5cbi8qKlxuICogRmluZHMgdGhlIHJvb3Qgbm9kZSAoZG9jdW1lbnQsIHNoYWRvd0RPTSByb290KSBvZiB0aGUgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBub2RlXG4gKiBAcmV0dXJucyB7RWxlbWVudH0gcm9vdCBub2RlXG4gKi9cbmZ1bmN0aW9uIGdldFJvb3Qobm9kZSkge1xuICBpZiAobm9kZS5wYXJlbnROb2RlICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIGdldFJvb3Qobm9kZS5wYXJlbnROb2RlKTtcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufVxuXG4vKipcbiAqIEZpbmRzIHRoZSBvZmZzZXQgcGFyZW50IGNvbW1vbiB0byB0aGUgdHdvIHByb3ZpZGVkIG5vZGVzXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnQxXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnQyXG4gKiBAcmV0dXJucyB7RWxlbWVudH0gY29tbW9uIG9mZnNldCBwYXJlbnRcbiAqL1xuZnVuY3Rpb24gZmluZENvbW1vbk9mZnNldFBhcmVudChlbGVtZW50MSwgZWxlbWVudDIpIHtcbiAgLy8gVGhpcyBjaGVjayBpcyBuZWVkZWQgdG8gYXZvaWQgZXJyb3JzIGluIGNhc2Ugb25lIG9mIHRoZSBlbGVtZW50cyBpc24ndCBkZWZpbmVkIGZvciBhbnkgcmVhc29uXG4gIGlmICghZWxlbWVudDEgfHwgIWVsZW1lbnQxLm5vZGVUeXBlIHx8ICFlbGVtZW50MiB8fCAhZWxlbWVudDIubm9kZVR5cGUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB9XG5cbiAgLy8gSGVyZSB3ZSBtYWtlIHN1cmUgdG8gZ2l2ZSBhcyBcInN0YXJ0XCIgdGhlIGVsZW1lbnQgdGhhdCBjb21lcyBmaXJzdCBpbiB0aGUgRE9NXG4gIHZhciBvcmRlciA9IGVsZW1lbnQxLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGVsZW1lbnQyKSAmIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fRk9MTE9XSU5HO1xuICB2YXIgc3RhcnQgPSBvcmRlciA/IGVsZW1lbnQxIDogZWxlbWVudDI7XG4gIHZhciBlbmQgPSBvcmRlciA/IGVsZW1lbnQyIDogZWxlbWVudDE7XG5cbiAgLy8gR2V0IGNvbW1vbiBhbmNlc3RvciBjb250YWluZXJcbiAgdmFyIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgcmFuZ2Uuc2V0U3RhcnQoc3RhcnQsIDApO1xuICByYW5nZS5zZXRFbmQoZW5kLCAwKTtcbiAgdmFyIGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyID0gcmFuZ2UuY29tbW9uQW5jZXN0b3JDb250YWluZXI7XG5cbiAgLy8gQm90aCBub2RlcyBhcmUgaW5zaWRlICNkb2N1bWVudFxuXG4gIGlmIChlbGVtZW50MSAhPT0gY29tbW9uQW5jZXN0b3JDb250YWluZXIgJiYgZWxlbWVudDIgIT09IGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyIHx8IHN0YXJ0LmNvbnRhaW5zKGVuZCkpIHtcbiAgICBpZiAoaXNPZmZzZXRDb250YWluZXIoY29tbW9uQW5jZXN0b3JDb250YWluZXIpKSB7XG4gICAgICByZXR1cm4gY29tbW9uQW5jZXN0b3JDb250YWluZXI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdldE9mZnNldFBhcmVudChjb21tb25BbmNlc3RvckNvbnRhaW5lcik7XG4gIH1cblxuICAvLyBvbmUgb2YgdGhlIG5vZGVzIGlzIGluc2lkZSBzaGFkb3dET00sIGZpbmQgd2hpY2ggb25lXG4gIHZhciBlbGVtZW50MXJvb3QgPSBnZXRSb290KGVsZW1lbnQxKTtcbiAgaWYgKGVsZW1lbnQxcm9vdC5ob3N0KSB7XG4gICAgcmV0dXJuIGZpbmRDb21tb25PZmZzZXRQYXJlbnQoZWxlbWVudDFyb290Lmhvc3QsIGVsZW1lbnQyKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmluZENvbW1vbk9mZnNldFBhcmVudChlbGVtZW50MSwgZ2V0Um9vdChlbGVtZW50MikuaG9zdCk7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBzY3JvbGwgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQgaW4gdGhlIGdpdmVuIHNpZGUgKHRvcCBhbmQgbGVmdClcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQGFyZ3VtZW50IHtTdHJpbmd9IHNpZGUgYHRvcGAgb3IgYGxlZnRgXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBhbW91bnQgb2Ygc2Nyb2xsZWQgcGl4ZWxzXG4gKi9cbmZ1bmN0aW9uIGdldFNjcm9sbChlbGVtZW50KSB7XG4gIHZhciBzaWRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAndG9wJztcblxuICB2YXIgdXBwZXJTaWRlID0gc2lkZSA9PT0gJ3RvcCcgPyAnc2Nyb2xsVG9wJyA6ICdzY3JvbGxMZWZ0JztcbiAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZTtcblxuICBpZiAobm9kZU5hbWUgPT09ICdCT0RZJyB8fCBub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgdmFyIGh0bWwgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIHZhciBzY3JvbGxpbmdFbGVtZW50ID0gZWxlbWVudC5vd25lckRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQgfHwgaHRtbDtcbiAgICByZXR1cm4gc2Nyb2xsaW5nRWxlbWVudFt1cHBlclNpZGVdO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnRbdXBwZXJTaWRlXTtcbn1cblxuLypcbiAqIFN1bSBvciBzdWJ0cmFjdCB0aGUgZWxlbWVudCBzY3JvbGwgdmFsdWVzIChsZWZ0IGFuZCB0b3ApIGZyb20gYSBnaXZlbiByZWN0IG9iamVjdFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtPYmplY3R9IHJlY3QgLSBSZWN0IG9iamVjdCB5b3Ugd2FudCB0byBjaGFuZ2VcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBUaGUgZWxlbWVudCBmcm9tIHRoZSBmdW5jdGlvbiByZWFkcyB0aGUgc2Nyb2xsIHZhbHVlc1xuICogQHBhcmFtIHtCb29sZWFufSBzdWJ0cmFjdCAtIHNldCB0byB0cnVlIGlmIHlvdSB3YW50IHRvIHN1YnRyYWN0IHRoZSBzY3JvbGwgdmFsdWVzXG4gKiBAcmV0dXJuIHtPYmplY3R9IHJlY3QgLSBUaGUgbW9kaWZpZXIgcmVjdCBvYmplY3RcbiAqL1xuZnVuY3Rpb24gaW5jbHVkZVNjcm9sbChyZWN0LCBlbGVtZW50KSB7XG4gIHZhciBzdWJ0cmFjdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG5cbiAgdmFyIHNjcm9sbFRvcCA9IGdldFNjcm9sbChlbGVtZW50LCAndG9wJyk7XG4gIHZhciBzY3JvbGxMZWZ0ID0gZ2V0U2Nyb2xsKGVsZW1lbnQsICdsZWZ0Jyk7XG4gIHZhciBtb2RpZmllciA9IHN1YnRyYWN0ID8gLTEgOiAxO1xuICByZWN0LnRvcCArPSBzY3JvbGxUb3AgKiBtb2RpZmllcjtcbiAgcmVjdC5ib3R0b20gKz0gc2Nyb2xsVG9wICogbW9kaWZpZXI7XG4gIHJlY3QubGVmdCArPSBzY3JvbGxMZWZ0ICogbW9kaWZpZXI7XG4gIHJlY3QucmlnaHQgKz0gc2Nyb2xsTGVmdCAqIG1vZGlmaWVyO1xuICByZXR1cm4gcmVjdDtcbn1cblxuLypcbiAqIEhlbHBlciB0byBkZXRlY3QgYm9yZGVycyBvZiBhIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7Q1NTU3R5bGVEZWNsYXJhdGlvbn0gc3R5bGVzXG4gKiBSZXN1bHQgb2YgYGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eWAgb24gdGhlIGdpdmVuIGVsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBheGlzIC0gYHhgIG9yIGB5YFxuICogQHJldHVybiB7bnVtYmVyfSBib3JkZXJzIC0gVGhlIGJvcmRlcnMgc2l6ZSBvZiB0aGUgZ2l2ZW4gYXhpc1xuICovXG5cbmZ1bmN0aW9uIGdldEJvcmRlcnNTaXplKHN0eWxlcywgYXhpcykge1xuICB2YXIgc2lkZUEgPSBheGlzID09PSAneCcgPyAnTGVmdCcgOiAnVG9wJztcbiAgdmFyIHNpZGVCID0gc2lkZUEgPT09ICdMZWZ0JyA/ICdSaWdodCcgOiAnQm90dG9tJztcblxuICByZXR1cm4gcGFyc2VGbG9hdChzdHlsZXNbJ2JvcmRlcicgKyBzaWRlQSArICdXaWR0aCddLCAxMCkgKyBwYXJzZUZsb2F0KHN0eWxlc1snYm9yZGVyJyArIHNpZGVCICsgJ1dpZHRoJ10sIDEwKTtcbn1cblxuZnVuY3Rpb24gZ2V0U2l6ZShheGlzLCBib2R5LCBodG1sLCBjb21wdXRlZFN0eWxlKSB7XG4gIHJldHVybiBNYXRoLm1heChib2R5WydvZmZzZXQnICsgYXhpc10sIGJvZHlbJ3Njcm9sbCcgKyBheGlzXSwgaHRtbFsnY2xpZW50JyArIGF4aXNdLCBodG1sWydvZmZzZXQnICsgYXhpc10sIGh0bWxbJ3Njcm9sbCcgKyBheGlzXSwgaXNJRSgxMCkgPyBodG1sWydvZmZzZXQnICsgYXhpc10gKyBjb21wdXRlZFN0eWxlWydtYXJnaW4nICsgKGF4aXMgPT09ICdIZWlnaHQnID8gJ1RvcCcgOiAnTGVmdCcpXSArIGNvbXB1dGVkU3R5bGVbJ21hcmdpbicgKyAoYXhpcyA9PT0gJ0hlaWdodCcgPyAnQm90dG9tJyA6ICdSaWdodCcpXSA6IDApO1xufVxuXG5mdW5jdGlvbiBnZXRXaW5kb3dTaXplcygpIHtcbiAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuICB2YXIgaHRtbCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgdmFyIGNvbXB1dGVkU3R5bGUgPSBpc0lFKDEwKSAmJiBnZXRDb21wdXRlZFN0eWxlKGh0bWwpO1xuXG4gIHJldHVybiB7XG4gICAgaGVpZ2h0OiBnZXRTaXplKCdIZWlnaHQnLCBib2R5LCBodG1sLCBjb21wdXRlZFN0eWxlKSxcbiAgICB3aWR0aDogZ2V0U2l6ZSgnV2lkdGgnLCBib2R5LCBodG1sLCBjb21wdXRlZFN0eWxlKVxuICB9O1xufVxuXG52YXIgY2xhc3NDYWxsQ2hlY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufTtcblxudmFyIGNyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9O1xufSgpO1xuXG5cblxuXG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbi8qKlxuICogR2l2ZW4gZWxlbWVudCBvZmZzZXRzLCBnZW5lcmF0ZSBhbiBvdXRwdXQgc2ltaWxhciB0byBnZXRCb3VuZGluZ0NsaWVudFJlY3RcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvZmZzZXRzXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBDbGllbnRSZWN0IGxpa2Ugb3V0cHV0XG4gKi9cbmZ1bmN0aW9uIGdldENsaWVudFJlY3Qob2Zmc2V0cykge1xuICByZXR1cm4gX2V4dGVuZHMoe30sIG9mZnNldHMsIHtcbiAgICByaWdodDogb2Zmc2V0cy5sZWZ0ICsgb2Zmc2V0cy53aWR0aCxcbiAgICBib3R0b206IG9mZnNldHMudG9wICsgb2Zmc2V0cy5oZWlnaHRcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0IGJvdW5kaW5nIGNsaWVudCByZWN0IG9mIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm4ge09iamVjdH0gY2xpZW50IHJlY3RcbiAqL1xuZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQpIHtcbiAgdmFyIHJlY3QgPSB7fTtcblxuICAvLyBJRTEwIDEwIEZJWDogUGxlYXNlLCBkb24ndCBhc2ssIHRoZSBlbGVtZW50IGlzbid0XG4gIC8vIGNvbnNpZGVyZWQgaW4gRE9NIGluIHNvbWUgY2lyY3Vtc3RhbmNlcy4uLlxuICAvLyBUaGlzIGlzbid0IHJlcHJvZHVjaWJsZSBpbiBJRTEwIGNvbXBhdGliaWxpdHkgbW9kZSBvZiBJRTExXG4gIHRyeSB7XG4gICAgaWYgKGlzSUUoMTApKSB7XG4gICAgICByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciBzY3JvbGxUb3AgPSBnZXRTY3JvbGwoZWxlbWVudCwgJ3RvcCcpO1xuICAgICAgdmFyIHNjcm9sbExlZnQgPSBnZXRTY3JvbGwoZWxlbWVudCwgJ2xlZnQnKTtcbiAgICAgIHJlY3QudG9wICs9IHNjcm9sbFRvcDtcbiAgICAgIHJlY3QubGVmdCArPSBzY3JvbGxMZWZ0O1xuICAgICAgcmVjdC5ib3R0b20gKz0gc2Nyb2xsVG9wO1xuICAgICAgcmVjdC5yaWdodCArPSBzY3JvbGxMZWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IHtcbiAgICBsZWZ0OiByZWN0LmxlZnQsXG4gICAgdG9wOiByZWN0LnRvcCxcbiAgICB3aWR0aDogcmVjdC5yaWdodCAtIHJlY3QubGVmdCxcbiAgICBoZWlnaHQ6IHJlY3QuYm90dG9tIC0gcmVjdC50b3BcbiAgfTtcblxuICAvLyBzdWJ0cmFjdCBzY3JvbGxiYXIgc2l6ZSBmcm9tIHNpemVzXG4gIHZhciBzaXplcyA9IGVsZW1lbnQubm9kZU5hbWUgPT09ICdIVE1MJyA/IGdldFdpbmRvd1NpemVzKCkgOiB7fTtcbiAgdmFyIHdpZHRoID0gc2l6ZXMud2lkdGggfHwgZWxlbWVudC5jbGllbnRXaWR0aCB8fCByZXN1bHQucmlnaHQgLSByZXN1bHQubGVmdDtcbiAgdmFyIGhlaWdodCA9IHNpemVzLmhlaWdodCB8fCBlbGVtZW50LmNsaWVudEhlaWdodCB8fCByZXN1bHQuYm90dG9tIC0gcmVzdWx0LnRvcDtcblxuICB2YXIgaG9yaXpTY3JvbGxiYXIgPSBlbGVtZW50Lm9mZnNldFdpZHRoIC0gd2lkdGg7XG4gIHZhciB2ZXJ0U2Nyb2xsYmFyID0gZWxlbWVudC5vZmZzZXRIZWlnaHQgLSBoZWlnaHQ7XG5cbiAgLy8gaWYgYW4gaHlwb3RoZXRpY2FsIHNjcm9sbGJhciBpcyBkZXRlY3RlZCwgd2UgbXVzdCBiZSBzdXJlIGl0J3Mgbm90IGEgYGJvcmRlcmBcbiAgLy8gd2UgbWFrZSB0aGlzIGNoZWNrIGNvbmRpdGlvbmFsIGZvciBwZXJmb3JtYW5jZSByZWFzb25zXG4gIGlmIChob3JpelNjcm9sbGJhciB8fCB2ZXJ0U2Nyb2xsYmFyKSB7XG4gICAgdmFyIHN0eWxlcyA9IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbGVtZW50KTtcbiAgICBob3JpelNjcm9sbGJhciAtPSBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsICd4Jyk7XG4gICAgdmVydFNjcm9sbGJhciAtPSBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsICd5Jyk7XG5cbiAgICByZXN1bHQud2lkdGggLT0gaG9yaXpTY3JvbGxiYXI7XG4gICAgcmVzdWx0LmhlaWdodCAtPSB2ZXJ0U2Nyb2xsYmFyO1xuICB9XG5cbiAgcmV0dXJuIGdldENsaWVudFJlY3QocmVzdWx0KTtcbn1cblxuZnVuY3Rpb24gZ2V0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcmJpdHJhcnlOb2RlKGNoaWxkcmVuLCBwYXJlbnQpIHtcbiAgdmFyIGZpeGVkUG9zaXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gIHZhciBpc0lFMTAgPSBpc0lFKDEwKTtcbiAgdmFyIGlzSFRNTCA9IHBhcmVudC5ub2RlTmFtZSA9PT0gJ0hUTUwnO1xuICB2YXIgY2hpbGRyZW5SZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGNoaWxkcmVuKTtcbiAgdmFyIHBhcmVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QocGFyZW50KTtcbiAgdmFyIHNjcm9sbFBhcmVudCA9IGdldFNjcm9sbFBhcmVudChjaGlsZHJlbik7XG5cbiAgdmFyIHN0eWxlcyA9IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShwYXJlbnQpO1xuICB2YXIgYm9yZGVyVG9wV2lkdGggPSBwYXJzZUZsb2F0KHN0eWxlcy5ib3JkZXJUb3BXaWR0aCwgMTApO1xuICB2YXIgYm9yZGVyTGVmdFdpZHRoID0gcGFyc2VGbG9hdChzdHlsZXMuYm9yZGVyTGVmdFdpZHRoLCAxMCk7XG5cbiAgLy8gSW4gY2FzZXMgd2hlcmUgdGhlIHBhcmVudCBpcyBmaXhlZCwgd2UgbXVzdCBpZ25vcmUgbmVnYXRpdmUgc2Nyb2xsIGluIG9mZnNldCBjYWxjXG4gIGlmIChmaXhlZFBvc2l0aW9uICYmIHBhcmVudC5ub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgcGFyZW50UmVjdC50b3AgPSBNYXRoLm1heChwYXJlbnRSZWN0LnRvcCwgMCk7XG4gICAgcGFyZW50UmVjdC5sZWZ0ID0gTWF0aC5tYXgocGFyZW50UmVjdC5sZWZ0LCAwKTtcbiAgfVxuICB2YXIgb2Zmc2V0cyA9IGdldENsaWVudFJlY3Qoe1xuICAgIHRvcDogY2hpbGRyZW5SZWN0LnRvcCAtIHBhcmVudFJlY3QudG9wIC0gYm9yZGVyVG9wV2lkdGgsXG4gICAgbGVmdDogY2hpbGRyZW5SZWN0LmxlZnQgLSBwYXJlbnRSZWN0LmxlZnQgLSBib3JkZXJMZWZ0V2lkdGgsXG4gICAgd2lkdGg6IGNoaWxkcmVuUmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IGNoaWxkcmVuUmVjdC5oZWlnaHRcbiAgfSk7XG4gIG9mZnNldHMubWFyZ2luVG9wID0gMDtcbiAgb2Zmc2V0cy5tYXJnaW5MZWZ0ID0gMDtcblxuICAvLyBTdWJ0cmFjdCBtYXJnaW5zIG9mIGRvY3VtZW50RWxlbWVudCBpbiBjYXNlIGl0J3MgYmVpbmcgdXNlZCBhcyBwYXJlbnRcbiAgLy8gd2UgZG8gdGhpcyBvbmx5IG9uIEhUTUwgYmVjYXVzZSBpdCdzIHRoZSBvbmx5IGVsZW1lbnQgdGhhdCBiZWhhdmVzXG4gIC8vIGRpZmZlcmVudGx5IHdoZW4gbWFyZ2lucyBhcmUgYXBwbGllZCB0byBpdC4gVGhlIG1hcmdpbnMgYXJlIGluY2x1ZGVkIGluXG4gIC8vIHRoZSBib3ggb2YgdGhlIGRvY3VtZW50RWxlbWVudCwgaW4gdGhlIG90aGVyIGNhc2VzIG5vdC5cbiAgaWYgKCFpc0lFMTAgJiYgaXNIVE1MKSB7XG4gICAgdmFyIG1hcmdpblRvcCA9IHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpblRvcCwgMTApO1xuICAgIHZhciBtYXJnaW5MZWZ0ID0gcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luTGVmdCwgMTApO1xuXG4gICAgb2Zmc2V0cy50b3AgLT0gYm9yZGVyVG9wV2lkdGggLSBtYXJnaW5Ub3A7XG4gICAgb2Zmc2V0cy5ib3R0b20gLT0gYm9yZGVyVG9wV2lkdGggLSBtYXJnaW5Ub3A7XG4gICAgb2Zmc2V0cy5sZWZ0IC09IGJvcmRlckxlZnRXaWR0aCAtIG1hcmdpbkxlZnQ7XG4gICAgb2Zmc2V0cy5yaWdodCAtPSBib3JkZXJMZWZ0V2lkdGggLSBtYXJnaW5MZWZ0O1xuXG4gICAgLy8gQXR0YWNoIG1hcmdpblRvcCBhbmQgbWFyZ2luTGVmdCBiZWNhdXNlIGluIHNvbWUgY2lyY3Vtc3RhbmNlcyB3ZSBtYXkgbmVlZCB0aGVtXG4gICAgb2Zmc2V0cy5tYXJnaW5Ub3AgPSBtYXJnaW5Ub3A7XG4gICAgb2Zmc2V0cy5tYXJnaW5MZWZ0ID0gbWFyZ2luTGVmdDtcbiAgfVxuXG4gIGlmIChpc0lFMTAgJiYgIWZpeGVkUG9zaXRpb24gPyBwYXJlbnQuY29udGFpbnMoc2Nyb2xsUGFyZW50KSA6IHBhcmVudCA9PT0gc2Nyb2xsUGFyZW50ICYmIHNjcm9sbFBhcmVudC5ub2RlTmFtZSAhPT0gJ0JPRFknKSB7XG4gICAgb2Zmc2V0cyA9IGluY2x1ZGVTY3JvbGwob2Zmc2V0cywgcGFyZW50KTtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXRzO1xufVxuXG5mdW5jdGlvbiBnZXRWaWV3cG9ydE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJ0Yml0cmFyeU5vZGUoZWxlbWVudCkge1xuICB2YXIgZXhjbHVkZVNjcm9sbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cbiAgdmFyIGh0bWwgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB2YXIgcmVsYXRpdmVPZmZzZXQgPSBnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUoZWxlbWVudCwgaHRtbCk7XG4gIHZhciB3aWR0aCA9IE1hdGgubWF4KGh0bWwuY2xpZW50V2lkdGgsIHdpbmRvdy5pbm5lcldpZHRoIHx8IDApO1xuICB2YXIgaGVpZ2h0ID0gTWF0aC5tYXgoaHRtbC5jbGllbnRIZWlnaHQsIHdpbmRvdy5pbm5lckhlaWdodCB8fCAwKTtcblxuICB2YXIgc2Nyb2xsVG9wID0gIWV4Y2x1ZGVTY3JvbGwgPyBnZXRTY3JvbGwoaHRtbCkgOiAwO1xuICB2YXIgc2Nyb2xsTGVmdCA9ICFleGNsdWRlU2Nyb2xsID8gZ2V0U2Nyb2xsKGh0bWwsICdsZWZ0JykgOiAwO1xuXG4gIHZhciBvZmZzZXQgPSB7XG4gICAgdG9wOiBzY3JvbGxUb3AgLSByZWxhdGl2ZU9mZnNldC50b3AgKyByZWxhdGl2ZU9mZnNldC5tYXJnaW5Ub3AsXG4gICAgbGVmdDogc2Nyb2xsTGVmdCAtIHJlbGF0aXZlT2Zmc2V0LmxlZnQgKyByZWxhdGl2ZU9mZnNldC5tYXJnaW5MZWZ0LFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodFxuICB9O1xuXG4gIHJldHVybiBnZXRDbGllbnRSZWN0KG9mZnNldCk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIGVsZW1lbnQgaXMgZml4ZWQgb3IgaXMgaW5zaWRlIGEgZml4ZWQgcGFyZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gY3VzdG9tQ29udGFpbmVyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gYW5zd2VyIHRvIFwiaXNGaXhlZD9cIlxuICovXG5mdW5jdGlvbiBpc0ZpeGVkKGVsZW1lbnQpIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZTtcbiAgaWYgKG5vZGVOYW1lID09PSAnQk9EWScgfHwgbm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsZW1lbnQsICdwb3NpdGlvbicpID09PSAnZml4ZWQnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGlzRml4ZWQoZ2V0UGFyZW50Tm9kZShlbGVtZW50KSk7XG59XG5cbi8qKlxuICogRmluZHMgdGhlIGZpcnN0IHBhcmVudCBvZiBhbiBlbGVtZW50IHRoYXQgaGFzIGEgdHJhbnNmb3JtZWQgcHJvcGVydHkgZGVmaW5lZFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7RWxlbWVudH0gZmlyc3QgdHJhbnNmb3JtZWQgcGFyZW50IG9yIGRvY3VtZW50RWxlbWVudFxuICovXG5cbmZ1bmN0aW9uIGdldEZpeGVkUG9zaXRpb25PZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICAvLyBUaGlzIGNoZWNrIGlzIG5lZWRlZCB0byBhdm9pZCBlcnJvcnMgaW4gY2FzZSBvbmUgb2YgdGhlIGVsZW1lbnRzIGlzbid0IGRlZmluZWQgZm9yIGFueSByZWFzb25cbiAgaWYgKCFlbGVtZW50IHx8ICFlbGVtZW50LnBhcmVudEVsZW1lbnQgfHwgaXNJRSgpKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgfVxuICB2YXIgZWwgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gIHdoaWxlIChlbCAmJiBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZWwsICd0cmFuc2Zvcm0nKSA9PT0gJ25vbmUnKSB7XG4gICAgZWwgPSBlbC5wYXJlbnRFbGVtZW50O1xuICB9XG4gIHJldHVybiBlbCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG59XG5cbi8qKlxuICogQ29tcHV0ZWQgdGhlIGJvdW5kYXJpZXMgbGltaXRzIGFuZCByZXR1cm4gdGhlbVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcG9wcGVyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSByZWZlcmVuY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYWRkaW5nXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBib3VuZGFyaWVzRWxlbWVudCAtIEVsZW1lbnQgdXNlZCB0byBkZWZpbmUgdGhlIGJvdW5kYXJpZXNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZml4ZWRQb3NpdGlvbiAtIElzIGluIGZpeGVkIHBvc2l0aW9uIG1vZGVcbiAqIEByZXR1cm5zIHtPYmplY3R9IENvb3JkaW5hdGVzIG9mIHRoZSBib3VuZGFyaWVzXG4gKi9cbmZ1bmN0aW9uIGdldEJvdW5kYXJpZXMocG9wcGVyLCByZWZlcmVuY2UsIHBhZGRpbmcsIGJvdW5kYXJpZXNFbGVtZW50KSB7XG4gIHZhciBmaXhlZFBvc2l0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiBmYWxzZTtcblxuICAvLyBOT1RFOiAxIERPTSBhY2Nlc3MgaGVyZVxuXG4gIHZhciBib3VuZGFyaWVzID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcbiAgdmFyIG9mZnNldFBhcmVudCA9IGZpeGVkUG9zaXRpb24gPyBnZXRGaXhlZFBvc2l0aW9uT2Zmc2V0UGFyZW50KHBvcHBlcikgOiBmaW5kQ29tbW9uT2Zmc2V0UGFyZW50KHBvcHBlciwgcmVmZXJlbmNlKTtcblxuICAvLyBIYW5kbGUgdmlld3BvcnQgY2FzZVxuICBpZiAoYm91bmRhcmllc0VsZW1lbnQgPT09ICd2aWV3cG9ydCcpIHtcbiAgICBib3VuZGFyaWVzID0gZ2V0Vmlld3BvcnRPZmZzZXRSZWN0UmVsYXRpdmVUb0FydGJpdHJhcnlOb2RlKG9mZnNldFBhcmVudCwgZml4ZWRQb3NpdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgLy8gSGFuZGxlIG90aGVyIGNhc2VzIGJhc2VkIG9uIERPTSBlbGVtZW50IHVzZWQgYXMgYm91bmRhcmllc1xuICAgIHZhciBib3VuZGFyaWVzTm9kZSA9IHZvaWQgMDtcbiAgICBpZiAoYm91bmRhcmllc0VsZW1lbnQgPT09ICdzY3JvbGxQYXJlbnQnKSB7XG4gICAgICBib3VuZGFyaWVzTm9kZSA9IGdldFNjcm9sbFBhcmVudChnZXRQYXJlbnROb2RlKHJlZmVyZW5jZSkpO1xuICAgICAgaWYgKGJvdW5kYXJpZXNOb2RlLm5vZGVOYW1lID09PSAnQk9EWScpIHtcbiAgICAgICAgYm91bmRhcmllc05vZGUgPSBwb3BwZXIub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChib3VuZGFyaWVzRWxlbWVudCA9PT0gJ3dpbmRvdycpIHtcbiAgICAgIGJvdW5kYXJpZXNOb2RlID0gcG9wcGVyLm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBib3VuZGFyaWVzTm9kZSA9IGJvdW5kYXJpZXNFbGVtZW50O1xuICAgIH1cblxuICAgIHZhciBvZmZzZXRzID0gZ2V0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcmJpdHJhcnlOb2RlKGJvdW5kYXJpZXNOb2RlLCBvZmZzZXRQYXJlbnQsIGZpeGVkUG9zaXRpb24pO1xuXG4gICAgLy8gSW4gY2FzZSBvZiBIVE1MLCB3ZSBuZWVkIGEgZGlmZmVyZW50IGNvbXB1dGF0aW9uXG4gICAgaWYgKGJvdW5kYXJpZXNOb2RlLm5vZGVOYW1lID09PSAnSFRNTCcgJiYgIWlzRml4ZWQob2Zmc2V0UGFyZW50KSkge1xuICAgICAgdmFyIF9nZXRXaW5kb3dTaXplcyA9IGdldFdpbmRvd1NpemVzKCksXG4gICAgICAgICAgaGVpZ2h0ID0gX2dldFdpbmRvd1NpemVzLmhlaWdodCxcbiAgICAgICAgICB3aWR0aCA9IF9nZXRXaW5kb3dTaXplcy53aWR0aDtcblxuICAgICAgYm91bmRhcmllcy50b3AgKz0gb2Zmc2V0cy50b3AgLSBvZmZzZXRzLm1hcmdpblRvcDtcbiAgICAgIGJvdW5kYXJpZXMuYm90dG9tID0gaGVpZ2h0ICsgb2Zmc2V0cy50b3A7XG4gICAgICBib3VuZGFyaWVzLmxlZnQgKz0gb2Zmc2V0cy5sZWZ0IC0gb2Zmc2V0cy5tYXJnaW5MZWZ0O1xuICAgICAgYm91bmRhcmllcy5yaWdodCA9IHdpZHRoICsgb2Zmc2V0cy5sZWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBmb3IgYWxsIHRoZSBvdGhlciBET00gZWxlbWVudHMsIHRoaXMgb25lIGlzIGdvb2RcbiAgICAgIGJvdW5kYXJpZXMgPSBvZmZzZXRzO1xuICAgIH1cbiAgfVxuXG4gIC8vIEFkZCBwYWRkaW5nc1xuICBib3VuZGFyaWVzLmxlZnQgKz0gcGFkZGluZztcbiAgYm91bmRhcmllcy50b3AgKz0gcGFkZGluZztcbiAgYm91bmRhcmllcy5yaWdodCAtPSBwYWRkaW5nO1xuICBib3VuZGFyaWVzLmJvdHRvbSAtPSBwYWRkaW5nO1xuXG4gIHJldHVybiBib3VuZGFyaWVzO1xufVxuXG5mdW5jdGlvbiBnZXRBcmVhKF9yZWYpIHtcbiAgdmFyIHdpZHRoID0gX3JlZi53aWR0aCxcbiAgICAgIGhlaWdodCA9IF9yZWYuaGVpZ2h0O1xuXG4gIHJldHVybiB3aWR0aCAqIGhlaWdodDtcbn1cblxuLyoqXG4gKiBVdGlsaXR5IHVzZWQgdG8gdHJhbnNmb3JtIHRoZSBgYXV0b2AgcGxhY2VtZW50IHRvIHRoZSBwbGFjZW1lbnQgd2l0aCBtb3JlXG4gKiBhdmFpbGFibGUgc3BhY2UuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBjb21wdXRlQXV0b1BsYWNlbWVudChwbGFjZW1lbnQsIHJlZlJlY3QsIHBvcHBlciwgcmVmZXJlbmNlLCBib3VuZGFyaWVzRWxlbWVudCkge1xuICB2YXIgcGFkZGluZyA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogMDtcblxuICBpZiAocGxhY2VtZW50LmluZGV4T2YoJ2F1dG8nKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gcGxhY2VtZW50O1xuICB9XG5cbiAgdmFyIGJvdW5kYXJpZXMgPSBnZXRCb3VuZGFyaWVzKHBvcHBlciwgcmVmZXJlbmNlLCBwYWRkaW5nLCBib3VuZGFyaWVzRWxlbWVudCk7XG5cbiAgdmFyIHJlY3RzID0ge1xuICAgIHRvcDoge1xuICAgICAgd2lkdGg6IGJvdW5kYXJpZXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IHJlZlJlY3QudG9wIC0gYm91bmRhcmllcy50b3BcbiAgICB9LFxuICAgIHJpZ2h0OiB7XG4gICAgICB3aWR0aDogYm91bmRhcmllcy5yaWdodCAtIHJlZlJlY3QucmlnaHQsXG4gICAgICBoZWlnaHQ6IGJvdW5kYXJpZXMuaGVpZ2h0XG4gICAgfSxcbiAgICBib3R0b206IHtcbiAgICAgIHdpZHRoOiBib3VuZGFyaWVzLndpZHRoLFxuICAgICAgaGVpZ2h0OiBib3VuZGFyaWVzLmJvdHRvbSAtIHJlZlJlY3QuYm90dG9tXG4gICAgfSxcbiAgICBsZWZ0OiB7XG4gICAgICB3aWR0aDogcmVmUmVjdC5sZWZ0IC0gYm91bmRhcmllcy5sZWZ0LFxuICAgICAgaGVpZ2h0OiBib3VuZGFyaWVzLmhlaWdodFxuICAgIH1cbiAgfTtcblxuICB2YXIgc29ydGVkQXJlYXMgPSBPYmplY3Qua2V5cyhyZWN0cykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAga2V5OiBrZXlcbiAgICB9LCByZWN0c1trZXldLCB7XG4gICAgICBhcmVhOiBnZXRBcmVhKHJlY3RzW2tleV0pXG4gICAgfSk7XG4gIH0pLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYi5hcmVhIC0gYS5hcmVhO1xuICB9KTtcblxuICB2YXIgZmlsdGVyZWRBcmVhcyA9IHNvcnRlZEFyZWFzLmZpbHRlcihmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICB2YXIgd2lkdGggPSBfcmVmMi53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gX3JlZjIuaGVpZ2h0O1xuICAgIHJldHVybiB3aWR0aCA+PSBwb3BwZXIuY2xpZW50V2lkdGggJiYgaGVpZ2h0ID49IHBvcHBlci5jbGllbnRIZWlnaHQ7XG4gIH0pO1xuXG4gIHZhciBjb21wdXRlZFBsYWNlbWVudCA9IGZpbHRlcmVkQXJlYXMubGVuZ3RoID4gMCA/IGZpbHRlcmVkQXJlYXNbMF0ua2V5IDogc29ydGVkQXJlYXNbMF0ua2V5O1xuXG4gIHZhciB2YXJpYXRpb24gPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVsxXTtcblxuICByZXR1cm4gY29tcHV0ZWRQbGFjZW1lbnQgKyAodmFyaWF0aW9uID8gJy0nICsgdmFyaWF0aW9uIDogJycpO1xufVxuXG4vKipcbiAqIEdldCBvZmZzZXRzIHRvIHRoZSByZWZlcmVuY2UgZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHBvcHBlciAtIHRoZSBwb3BwZXIgZWxlbWVudFxuICogQHBhcmFtIHtFbGVtZW50fSByZWZlcmVuY2UgLSB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgKHRoZSBwb3BwZXIgd2lsbCBiZSByZWxhdGl2ZSB0byB0aGlzKVxuICogQHBhcmFtIHtFbGVtZW50fSBmaXhlZFBvc2l0aW9uIC0gaXMgaW4gZml4ZWQgcG9zaXRpb24gbW9kZVxuICogQHJldHVybnMge09iamVjdH0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9mZnNldHMgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXJcbiAqL1xuZnVuY3Rpb24gZ2V0UmVmZXJlbmNlT2Zmc2V0cyhzdGF0ZSwgcG9wcGVyLCByZWZlcmVuY2UpIHtcbiAgdmFyIGZpeGVkUG9zaXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IG51bGw7XG5cbiAgdmFyIGNvbW1vbk9mZnNldFBhcmVudCA9IGZpeGVkUG9zaXRpb24gPyBnZXRGaXhlZFBvc2l0aW9uT2Zmc2V0UGFyZW50KHBvcHBlcikgOiBmaW5kQ29tbW9uT2Zmc2V0UGFyZW50KHBvcHBlciwgcmVmZXJlbmNlKTtcbiAgcmV0dXJuIGdldE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJiaXRyYXJ5Tm9kZShyZWZlcmVuY2UsIGNvbW1vbk9mZnNldFBhcmVudCwgZml4ZWRQb3NpdGlvbik7XG59XG5cbi8qKlxuICogR2V0IHRoZSBvdXRlciBzaXplcyBvZiB0aGUgZ2l2ZW4gZWxlbWVudCAob2Zmc2V0IHNpemUgKyBtYXJnaW5zKVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBvYmplY3QgY29udGFpbmluZyB3aWR0aCBhbmQgaGVpZ2h0IHByb3BlcnRpZXNcbiAqL1xuZnVuY3Rpb24gZ2V0T3V0ZXJTaXplcyhlbGVtZW50KSB7XG4gIHZhciBzdHlsZXMgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICB2YXIgeCA9IHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpblRvcCkgKyBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5Cb3R0b20pO1xuICB2YXIgeSA9IHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpbkxlZnQpICsgcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luUmlnaHQpO1xuICB2YXIgcmVzdWx0ID0ge1xuICAgIHdpZHRoOiBlbGVtZW50Lm9mZnNldFdpZHRoICsgeSxcbiAgICBoZWlnaHQ6IGVsZW1lbnQub2Zmc2V0SGVpZ2h0ICsgeFxuICB9O1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldCB0aGUgb3Bwb3NpdGUgcGxhY2VtZW50IG9mIHRoZSBnaXZlbiBvbmVcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBwbGFjZW1lbnRcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGZsaXBwZWQgcGxhY2VtZW50XG4gKi9cbmZ1bmN0aW9uIGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICB2YXIgaGFzaCA9IHsgbGVmdDogJ3JpZ2h0JywgcmlnaHQ6ICdsZWZ0JywgYm90dG9tOiAndG9wJywgdG9wOiAnYm90dG9tJyB9O1xuICByZXR1cm4gcGxhY2VtZW50LnJlcGxhY2UoL2xlZnR8cmlnaHR8Ym90dG9tfHRvcC9nLCBmdW5jdGlvbiAobWF0Y2hlZCkge1xuICAgIHJldHVybiBoYXNoW21hdGNoZWRdO1xuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgb2Zmc2V0cyB0byB0aGUgcG9wcGVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge09iamVjdH0gcG9zaXRpb24gLSBDU1MgcG9zaXRpb24gdGhlIFBvcHBlciB3aWxsIGdldCBhcHBsaWVkXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwb3BwZXIgLSB0aGUgcG9wcGVyIGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWZlcmVuY2VPZmZzZXRzIC0gdGhlIHJlZmVyZW5jZSBvZmZzZXRzICh0aGUgcG9wcGVyIHdpbGwgYmUgcmVsYXRpdmUgdG8gdGhpcylcbiAqIEBwYXJhbSB7U3RyaW5nfSBwbGFjZW1lbnQgLSBvbmUgb2YgdGhlIHZhbGlkIHBsYWNlbWVudCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBwb3BwZXJPZmZzZXRzIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9mZnNldHMgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXJcbiAqL1xuZnVuY3Rpb24gZ2V0UG9wcGVyT2Zmc2V0cyhwb3BwZXIsIHJlZmVyZW5jZU9mZnNldHMsIHBsYWNlbWVudCkge1xuICBwbGFjZW1lbnQgPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcblxuICAvLyBHZXQgcG9wcGVyIG5vZGUgc2l6ZXNcbiAgdmFyIHBvcHBlclJlY3QgPSBnZXRPdXRlclNpemVzKHBvcHBlcik7XG5cbiAgLy8gQWRkIHBvc2l0aW9uLCB3aWR0aCBhbmQgaGVpZ2h0IHRvIG91ciBvZmZzZXRzIG9iamVjdFxuICB2YXIgcG9wcGVyT2Zmc2V0cyA9IHtcbiAgICB3aWR0aDogcG9wcGVyUmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IHBvcHBlclJlY3QuaGVpZ2h0XG4gIH07XG5cbiAgLy8gZGVwZW5kaW5nIGJ5IHRoZSBwb3BwZXIgcGxhY2VtZW50IHdlIGhhdmUgdG8gY29tcHV0ZSBpdHMgb2Zmc2V0cyBzbGlnaHRseSBkaWZmZXJlbnRseVxuICB2YXIgaXNIb3JpeiA9IFsncmlnaHQnLCAnbGVmdCddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTE7XG4gIHZhciBtYWluU2lkZSA9IGlzSG9yaXogPyAndG9wJyA6ICdsZWZ0JztcbiAgdmFyIHNlY29uZGFyeVNpZGUgPSBpc0hvcml6ID8gJ2xlZnQnIDogJ3RvcCc7XG4gIHZhciBtZWFzdXJlbWVudCA9IGlzSG9yaXogPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gIHZhciBzZWNvbmRhcnlNZWFzdXJlbWVudCA9ICFpc0hvcml6ID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuXG4gIHBvcHBlck9mZnNldHNbbWFpblNpZGVdID0gcmVmZXJlbmNlT2Zmc2V0c1ttYWluU2lkZV0gKyByZWZlcmVuY2VPZmZzZXRzW21lYXN1cmVtZW50XSAvIDIgLSBwb3BwZXJSZWN0W21lYXN1cmVtZW50XSAvIDI7XG4gIGlmIChwbGFjZW1lbnQgPT09IHNlY29uZGFyeVNpZGUpIHtcbiAgICBwb3BwZXJPZmZzZXRzW3NlY29uZGFyeVNpZGVdID0gcmVmZXJlbmNlT2Zmc2V0c1tzZWNvbmRhcnlTaWRlXSAtIHBvcHBlclJlY3Rbc2Vjb25kYXJ5TWVhc3VyZW1lbnRdO1xuICB9IGVsc2Uge1xuICAgIHBvcHBlck9mZnNldHNbc2Vjb25kYXJ5U2lkZV0gPSByZWZlcmVuY2VPZmZzZXRzW2dldE9wcG9zaXRlUGxhY2VtZW50KHNlY29uZGFyeVNpZGUpXTtcbiAgfVxuXG4gIHJldHVybiBwb3BwZXJPZmZzZXRzO1xufVxuXG4vKipcbiAqIE1pbWljcyB0aGUgYGZpbmRgIG1ldGhvZCBvZiBBcnJheVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtBcnJheX0gYXJyXG4gKiBAYXJndW1lbnQgcHJvcFxuICogQGFyZ3VtZW50IHZhbHVlXG4gKiBAcmV0dXJucyBpbmRleCBvciAtMVxuICovXG5mdW5jdGlvbiBmaW5kKGFyciwgY2hlY2spIHtcbiAgLy8gdXNlIG5hdGl2ZSBmaW5kIGlmIHN1cHBvcnRlZFxuICBpZiAoQXJyYXkucHJvdG90eXBlLmZpbmQpIHtcbiAgICByZXR1cm4gYXJyLmZpbmQoY2hlY2spO1xuICB9XG5cbiAgLy8gdXNlIGBmaWx0ZXJgIHRvIG9idGFpbiB0aGUgc2FtZSBiZWhhdmlvciBvZiBgZmluZGBcbiAgcmV0dXJuIGFyci5maWx0ZXIoY2hlY2spWzBdO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgaW5kZXggb2YgdGhlIG1hdGNoaW5nIG9iamVjdFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtBcnJheX0gYXJyXG4gKiBAYXJndW1lbnQgcHJvcFxuICogQGFyZ3VtZW50IHZhbHVlXG4gKiBAcmV0dXJucyBpbmRleCBvciAtMVxuICovXG5mdW5jdGlvbiBmaW5kSW5kZXgoYXJyLCBwcm9wLCB2YWx1ZSkge1xuICAvLyB1c2UgbmF0aXZlIGZpbmRJbmRleCBpZiBzdXBwb3J0ZWRcbiAgaWYgKEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXgpIHtcbiAgICByZXR1cm4gYXJyLmZpbmRJbmRleChmdW5jdGlvbiAoY3VyKSB7XG4gICAgICByZXR1cm4gY3VyW3Byb3BdID09PSB2YWx1ZTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIHVzZSBgZmluZGAgKyBgaW5kZXhPZmAgaWYgYGZpbmRJbmRleGAgaXNuJ3Qgc3VwcG9ydGVkXG4gIHZhciBtYXRjaCA9IGZpbmQoYXJyLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIG9ialtwcm9wXSA9PT0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gYXJyLmluZGV4T2YobWF0Y2gpO1xufVxuXG4vKipcbiAqIExvb3AgdHJvdWdoIHRoZSBsaXN0IG9mIG1vZGlmaWVycyBhbmQgcnVuIHRoZW0gaW4gb3JkZXIsXG4gKiBlYWNoIG9mIHRoZW0gd2lsbCB0aGVuIGVkaXQgdGhlIGRhdGEgb2JqZWN0LlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtkYXRhT2JqZWN0fSBkYXRhXG4gKiBAcGFyYW0ge0FycmF5fSBtb2RpZmllcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBlbmRzIC0gT3B0aW9uYWwgbW9kaWZpZXIgbmFtZSB1c2VkIGFzIHN0b3BwZXJcbiAqIEByZXR1cm5zIHtkYXRhT2JqZWN0fVxuICovXG5mdW5jdGlvbiBydW5Nb2RpZmllcnMobW9kaWZpZXJzLCBkYXRhLCBlbmRzKSB7XG4gIHZhciBtb2RpZmllcnNUb1J1biA9IGVuZHMgPT09IHVuZGVmaW5lZCA/IG1vZGlmaWVycyA6IG1vZGlmaWVycy5zbGljZSgwLCBmaW5kSW5kZXgobW9kaWZpZXJzLCAnbmFtZScsIGVuZHMpKTtcblxuICBtb2RpZmllcnNUb1J1bi5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIGlmIChtb2RpZmllclsnZnVuY3Rpb24nXSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICAgIGNvbnNvbGUud2FybignYG1vZGlmaWVyLmZ1bmN0aW9uYCBpcyBkZXByZWNhdGVkLCB1c2UgYG1vZGlmaWVyLmZuYCEnKTtcbiAgICB9XG4gICAgdmFyIGZuID0gbW9kaWZpZXJbJ2Z1bmN0aW9uJ10gfHwgbW9kaWZpZXIuZm47IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgaWYgKG1vZGlmaWVyLmVuYWJsZWQgJiYgaXNGdW5jdGlvbihmbikpIHtcbiAgICAgIC8vIEFkZCBwcm9wZXJ0aWVzIHRvIG9mZnNldHMgdG8gbWFrZSB0aGVtIGEgY29tcGxldGUgY2xpZW50UmVjdCBvYmplY3RcbiAgICAgIC8vIHdlIGRvIHRoaXMgYmVmb3JlIGVhY2ggbW9kaWZpZXIgdG8gbWFrZSBzdXJlIHRoZSBwcmV2aW91cyBvbmUgZG9lc24ndFxuICAgICAgLy8gbWVzcyB3aXRoIHRoZXNlIHZhbHVlc1xuICAgICAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IGdldENsaWVudFJlY3QoZGF0YS5vZmZzZXRzLnBvcHBlcik7XG4gICAgICBkYXRhLm9mZnNldHMucmVmZXJlbmNlID0gZ2V0Q2xpZW50UmVjdChkYXRhLm9mZnNldHMucmVmZXJlbmNlKTtcblxuICAgICAgZGF0YSA9IGZuKGRhdGEsIG1vZGlmaWVyKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBwb3BwZXIsIGNvbXB1dGluZyB0aGUgbmV3IG9mZnNldHMgYW5kIGFwcGx5aW5nXG4gKiB0aGUgbmV3IHN0eWxlLjxiciAvPlxuICogUHJlZmVyIGBzY2hlZHVsZVVwZGF0ZWAgb3ZlciBgdXBkYXRlYCBiZWNhdXNlIG9mIHBlcmZvcm1hbmNlIHJlYXNvbnMuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgLy8gaWYgcG9wcGVyIGlzIGRlc3Ryb3llZCwgZG9uJ3QgcGVyZm9ybSBhbnkgZnVydGhlciB1cGRhdGVcbiAgaWYgKHRoaXMuc3RhdGUuaXNEZXN0cm95ZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZGF0YSA9IHtcbiAgICBpbnN0YW5jZTogdGhpcyxcbiAgICBzdHlsZXM6IHt9LFxuICAgIGFycm93U3R5bGVzOiB7fSxcbiAgICBhdHRyaWJ1dGVzOiB7fSxcbiAgICBmbGlwcGVkOiBmYWxzZSxcbiAgICBvZmZzZXRzOiB7fVxuICB9O1xuXG4gIC8vIGNvbXB1dGUgcmVmZXJlbmNlIGVsZW1lbnQgb2Zmc2V0c1xuICBkYXRhLm9mZnNldHMucmVmZXJlbmNlID0gZ2V0UmVmZXJlbmNlT2Zmc2V0cyh0aGlzLnN0YXRlLCB0aGlzLnBvcHBlciwgdGhpcy5yZWZlcmVuY2UsIHRoaXMub3B0aW9ucy5wb3NpdGlvbkZpeGVkKTtcblxuICAvLyBjb21wdXRlIGF1dG8gcGxhY2VtZW50LCBzdG9yZSBwbGFjZW1lbnQgaW5zaWRlIHRoZSBkYXRhIG9iamVjdCxcbiAgLy8gbW9kaWZpZXJzIHdpbGwgYmUgYWJsZSB0byBlZGl0IGBwbGFjZW1lbnRgIGlmIG5lZWRlZFxuICAvLyBhbmQgcmVmZXIgdG8gb3JpZ2luYWxQbGFjZW1lbnQgdG8ga25vdyB0aGUgb3JpZ2luYWwgdmFsdWVcbiAgZGF0YS5wbGFjZW1lbnQgPSBjb21wdXRlQXV0b1BsYWNlbWVudCh0aGlzLm9wdGlvbnMucGxhY2VtZW50LCBkYXRhLm9mZnNldHMucmVmZXJlbmNlLCB0aGlzLnBvcHBlciwgdGhpcy5yZWZlcmVuY2UsIHRoaXMub3B0aW9ucy5tb2RpZmllcnMuZmxpcC5ib3VuZGFyaWVzRWxlbWVudCwgdGhpcy5vcHRpb25zLm1vZGlmaWVycy5mbGlwLnBhZGRpbmcpO1xuXG4gIC8vIHN0b3JlIHRoZSBjb21wdXRlZCBwbGFjZW1lbnQgaW5zaWRlIGBvcmlnaW5hbFBsYWNlbWVudGBcbiAgZGF0YS5vcmlnaW5hbFBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50O1xuXG4gIGRhdGEucG9zaXRpb25GaXhlZCA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbkZpeGVkO1xuXG4gIC8vIGNvbXB1dGUgdGhlIHBvcHBlciBvZmZzZXRzXG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBnZXRQb3BwZXJPZmZzZXRzKHRoaXMucG9wcGVyLCBkYXRhLm9mZnNldHMucmVmZXJlbmNlLCBkYXRhLnBsYWNlbWVudCk7XG5cbiAgZGF0YS5vZmZzZXRzLnBvcHBlci5wb3NpdGlvbiA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbkZpeGVkID8gJ2ZpeGVkJyA6ICdhYnNvbHV0ZSc7XG5cbiAgLy8gcnVuIHRoZSBtb2RpZmllcnNcbiAgZGF0YSA9IHJ1bk1vZGlmaWVycyh0aGlzLm1vZGlmaWVycywgZGF0YSk7XG5cbiAgLy8gdGhlIGZpcnN0IGB1cGRhdGVgIHdpbGwgY2FsbCBgb25DcmVhdGVgIGNhbGxiYWNrXG4gIC8vIHRoZSBvdGhlciBvbmVzIHdpbGwgY2FsbCBgb25VcGRhdGVgIGNhbGxiYWNrXG4gIGlmICghdGhpcy5zdGF0ZS5pc0NyZWF0ZWQpIHtcbiAgICB0aGlzLnN0YXRlLmlzQ3JlYXRlZCA9IHRydWU7XG4gICAgdGhpcy5vcHRpb25zLm9uQ3JlYXRlKGRhdGEpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMub3B0aW9ucy5vblVwZGF0ZShkYXRhKTtcbiAgfVxufVxuXG4vKipcbiAqIEhlbHBlciB1c2VkIHRvIGtub3cgaWYgdGhlIGdpdmVuIG1vZGlmaWVyIGlzIGVuYWJsZWQuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNNb2RpZmllckVuYWJsZWQobW9kaWZpZXJzLCBtb2RpZmllck5hbWUpIHtcbiAgcmV0dXJuIG1vZGlmaWVycy5zb21lKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmLm5hbWUsXG4gICAgICAgIGVuYWJsZWQgPSBfcmVmLmVuYWJsZWQ7XG4gICAgcmV0dXJuIGVuYWJsZWQgJiYgbmFtZSA9PT0gbW9kaWZpZXJOYW1lO1xuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHByZWZpeGVkIHN1cHBvcnRlZCBwcm9wZXJ0eSBuYW1lXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gcHJvcGVydHkgKGNhbWVsQ2FzZSlcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHByZWZpeGVkIHByb3BlcnR5IChjYW1lbENhc2Ugb3IgUGFzY2FsQ2FzZSwgZGVwZW5kaW5nIG9uIHRoZSB2ZW5kb3IgcHJlZml4KVxuICovXG5mdW5jdGlvbiBnZXRTdXBwb3J0ZWRQcm9wZXJ0eU5hbWUocHJvcGVydHkpIHtcbiAgdmFyIHByZWZpeGVzID0gW2ZhbHNlLCAnbXMnLCAnV2Via2l0JywgJ01veicsICdPJ107XG4gIHZhciB1cHBlclByb3AgPSBwcm9wZXJ0eS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3BlcnR5LnNsaWNlKDEpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJlZml4ID0gcHJlZml4ZXNbaV07XG4gICAgdmFyIHRvQ2hlY2sgPSBwcmVmaXggPyAnJyArIHByZWZpeCArIHVwcGVyUHJvcCA6IHByb3BlcnR5O1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQuYm9keS5zdHlsZVt0b0NoZWNrXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB0b0NoZWNrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBEZXN0cm95IHRoZSBwb3BwZXJcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xuZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgdGhpcy5zdGF0ZS5pc0Rlc3Ryb3llZCA9IHRydWU7XG5cbiAgLy8gdG91Y2ggRE9NIG9ubHkgaWYgYGFwcGx5U3R5bGVgIG1vZGlmaWVyIGlzIGVuYWJsZWRcbiAgaWYgKGlzTW9kaWZpZXJFbmFibGVkKHRoaXMubW9kaWZpZXJzLCAnYXBwbHlTdHlsZScpKSB7XG4gICAgdGhpcy5wb3BwZXIucmVtb3ZlQXR0cmlidXRlKCd4LXBsYWNlbWVudCcpO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlLnBvc2l0aW9uID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUudG9wID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUubGVmdCA9ICcnO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlLnJpZ2h0ID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUuYm90dG9tID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUud2lsbENoYW5nZSA9ICcnO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlW2dldFN1cHBvcnRlZFByb3BlcnR5TmFtZSgndHJhbnNmb3JtJyldID0gJyc7XG4gIH1cblxuICB0aGlzLmRpc2FibGVFdmVudExpc3RlbmVycygpO1xuXG4gIC8vIHJlbW92ZSB0aGUgcG9wcGVyIGlmIHVzZXIgZXhwbGljaXR5IGFza2VkIGZvciB0aGUgZGVsZXRpb24gb24gZGVzdHJveVxuICAvLyBkbyBub3QgdXNlIGByZW1vdmVgIGJlY2F1c2UgSUUxMSBkb2Vzbid0IHN1cHBvcnQgaXRcbiAgaWYgKHRoaXMub3B0aW9ucy5yZW1vdmVPbkRlc3Ryb3kpIHtcbiAgICB0aGlzLnBvcHBlci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMucG9wcGVyKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHdpbmRvdyBhc3NvY2lhdGVkIHdpdGggdGhlIGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge1dpbmRvd31cbiAqL1xuZnVuY3Rpb24gZ2V0V2luZG93KGVsZW1lbnQpIHtcbiAgdmFyIG93bmVyRG9jdW1lbnQgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG4gIHJldHVybiBvd25lckRvY3VtZW50ID8gb3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyA6IHdpbmRvdztcbn1cblxuZnVuY3Rpb24gYXR0YWNoVG9TY3JvbGxQYXJlbnRzKHNjcm9sbFBhcmVudCwgZXZlbnQsIGNhbGxiYWNrLCBzY3JvbGxQYXJlbnRzKSB7XG4gIHZhciBpc0JvZHkgPSBzY3JvbGxQYXJlbnQubm9kZU5hbWUgPT09ICdCT0RZJztcbiAgdmFyIHRhcmdldCA9IGlzQm9keSA/IHNjcm9sbFBhcmVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IDogc2Nyb2xsUGFyZW50O1xuICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgY2FsbGJhY2ssIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcblxuICBpZiAoIWlzQm9keSkge1xuICAgIGF0dGFjaFRvU2Nyb2xsUGFyZW50cyhnZXRTY3JvbGxQYXJlbnQodGFyZ2V0LnBhcmVudE5vZGUpLCBldmVudCwgY2FsbGJhY2ssIHNjcm9sbFBhcmVudHMpO1xuICB9XG4gIHNjcm9sbFBhcmVudHMucHVzaCh0YXJnZXQpO1xufVxuXG4vKipcbiAqIFNldHVwIG5lZWRlZCBldmVudCBsaXN0ZW5lcnMgdXNlZCB0byB1cGRhdGUgdGhlIHBvcHBlciBwb3NpdGlvblxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2V0dXBFdmVudExpc3RlbmVycyhyZWZlcmVuY2UsIG9wdGlvbnMsIHN0YXRlLCB1cGRhdGVCb3VuZCkge1xuICAvLyBSZXNpemUgZXZlbnQgbGlzdGVuZXIgb24gd2luZG93XG4gIHN0YXRlLnVwZGF0ZUJvdW5kID0gdXBkYXRlQm91bmQ7XG4gIGdldFdpbmRvdyhyZWZlcmVuY2UpLmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHN0YXRlLnVwZGF0ZUJvdW5kLCB7IHBhc3NpdmU6IHRydWUgfSk7XG5cbiAgLy8gU2Nyb2xsIGV2ZW50IGxpc3RlbmVyIG9uIHNjcm9sbCBwYXJlbnRzXG4gIHZhciBzY3JvbGxFbGVtZW50ID0gZ2V0U2Nyb2xsUGFyZW50KHJlZmVyZW5jZSk7XG4gIGF0dGFjaFRvU2Nyb2xsUGFyZW50cyhzY3JvbGxFbGVtZW50LCAnc2Nyb2xsJywgc3RhdGUudXBkYXRlQm91bmQsIHN0YXRlLnNjcm9sbFBhcmVudHMpO1xuICBzdGF0ZS5zY3JvbGxFbGVtZW50ID0gc2Nyb2xsRWxlbWVudDtcbiAgc3RhdGUuZXZlbnRzRW5hYmxlZCA9IHRydWU7XG5cbiAgcmV0dXJuIHN0YXRlO1xufVxuXG4vKipcbiAqIEl0IHdpbGwgYWRkIHJlc2l6ZS9zY3JvbGwgZXZlbnRzIGFuZCBzdGFydCByZWNhbGN1bGF0aW5nXG4gKiBwb3NpdGlvbiBvZiB0aGUgcG9wcGVyIGVsZW1lbnQgd2hlbiB0aGV5IGFyZSB0cmlnZ2VyZWQuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbmZ1bmN0aW9uIGVuYWJsZUV2ZW50TGlzdGVuZXJzKCkge1xuICBpZiAoIXRoaXMuc3RhdGUuZXZlbnRzRW5hYmxlZCkge1xuICAgIHRoaXMuc3RhdGUgPSBzZXR1cEV2ZW50TGlzdGVuZXJzKHRoaXMucmVmZXJlbmNlLCB0aGlzLm9wdGlvbnMsIHRoaXMuc3RhdGUsIHRoaXMuc2NoZWR1bGVVcGRhdGUpO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGV2ZW50IGxpc3RlbmVycyB1c2VkIHRvIHVwZGF0ZSB0aGUgcG9wcGVyIHBvc2l0aW9uXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVycyhyZWZlcmVuY2UsIHN0YXRlKSB7XG4gIC8vIFJlbW92ZSByZXNpemUgZXZlbnQgbGlzdGVuZXIgb24gd2luZG93XG4gIGdldFdpbmRvdyhyZWZlcmVuY2UpLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHN0YXRlLnVwZGF0ZUJvdW5kKTtcblxuICAvLyBSZW1vdmUgc2Nyb2xsIGV2ZW50IGxpc3RlbmVyIG9uIHNjcm9sbCBwYXJlbnRzXG4gIHN0YXRlLnNjcm9sbFBhcmVudHMuZm9yRWFjaChmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHN0YXRlLnVwZGF0ZUJvdW5kKTtcbiAgfSk7XG5cbiAgLy8gUmVzZXQgc3RhdGVcbiAgc3RhdGUudXBkYXRlQm91bmQgPSBudWxsO1xuICBzdGF0ZS5zY3JvbGxQYXJlbnRzID0gW107XG4gIHN0YXRlLnNjcm9sbEVsZW1lbnQgPSBudWxsO1xuICBzdGF0ZS5ldmVudHNFbmFibGVkID0gZmFsc2U7XG4gIHJldHVybiBzdGF0ZTtcbn1cblxuLyoqXG4gKiBJdCB3aWxsIHJlbW92ZSByZXNpemUvc2Nyb2xsIGV2ZW50cyBhbmQgd29uJ3QgcmVjYWxjdWxhdGUgcG9wcGVyIHBvc2l0aW9uXG4gKiB3aGVuIHRoZXkgYXJlIHRyaWdnZXJlZC4gSXQgYWxzbyB3b24ndCB0cmlnZ2VyIG9uVXBkYXRlIGNhbGxiYWNrIGFueW1vcmUsXG4gKiB1bmxlc3MgeW91IGNhbGwgYHVwZGF0ZWAgbWV0aG9kIG1hbnVhbGx5LlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG5mdW5jdGlvbiBkaXNhYmxlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gIGlmICh0aGlzLnN0YXRlLmV2ZW50c0VuYWJsZWQpIHtcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnNjaGVkdWxlVXBkYXRlKTtcbiAgICB0aGlzLnN0YXRlID0gcmVtb3ZlRXZlbnRMaXN0ZW5lcnModGhpcy5yZWZlcmVuY2UsIHRoaXMuc3RhdGUpO1xuICB9XG59XG5cbi8qKlxuICogVGVsbHMgaWYgYSBnaXZlbiBpbnB1dCBpcyBhIG51bWJlclxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHsqfSBpbnB1dCB0byBjaGVja1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNOdW1lcmljKG4pIHtcbiAgcmV0dXJuIG4gIT09ICcnICYmICFpc05hTihwYXJzZUZsb2F0KG4pKSAmJiBpc0Zpbml0ZShuKTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIHN0eWxlIHRvIHRoZSBnaXZlbiBwb3BwZXJcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudCAtIEVsZW1lbnQgdG8gYXBwbHkgdGhlIHN0eWxlIHRvXG4gKiBAYXJndW1lbnQge09iamVjdH0gc3R5bGVzXG4gKiBPYmplY3Qgd2l0aCBhIGxpc3Qgb2YgcHJvcGVydGllcyBhbmQgdmFsdWVzIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgZWxlbWVudFxuICovXG5mdW5jdGlvbiBzZXRTdHlsZXMoZWxlbWVudCwgc3R5bGVzKSB7XG4gIE9iamVjdC5rZXlzKHN0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgIHZhciB1bml0ID0gJyc7XG4gICAgLy8gYWRkIHVuaXQgaWYgdGhlIHZhbHVlIGlzIG51bWVyaWMgYW5kIGlzIG9uZSBvZiB0aGUgZm9sbG93aW5nXG4gICAgaWYgKFsnd2lkdGgnLCAnaGVpZ2h0JywgJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddLmluZGV4T2YocHJvcCkgIT09IC0xICYmIGlzTnVtZXJpYyhzdHlsZXNbcHJvcF0pKSB7XG4gICAgICB1bml0ID0gJ3B4JztcbiAgICB9XG4gICAgZWxlbWVudC5zdHlsZVtwcm9wXSA9IHN0eWxlc1twcm9wXSArIHVuaXQ7XG4gIH0pO1xufVxuXG4vKipcbiAqIFNldCB0aGUgYXR0cmlidXRlcyB0byB0aGUgZ2l2ZW4gcG9wcGVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnQgLSBFbGVtZW50IHRvIGFwcGx5IHRoZSBhdHRyaWJ1dGVzIHRvXG4gKiBAYXJndW1lbnQge09iamVjdH0gc3R5bGVzXG4gKiBPYmplY3Qgd2l0aCBhIGxpc3Qgb2YgcHJvcGVydGllcyBhbmQgdmFsdWVzIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgZWxlbWVudFxuICovXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGVzKGVsZW1lbnQsIGF0dHJpYnV0ZXMpIHtcbiAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgIHZhciB2YWx1ZSA9IGF0dHJpYnV0ZXNbcHJvcF07XG4gICAgaWYgKHZhbHVlICE9PSBmYWxzZSkge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUocHJvcCwgYXR0cmlidXRlc1twcm9wXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKHByb3ApO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YS5zdHlsZXMgLSBMaXN0IG9mIHN0eWxlIHByb3BlcnRpZXMgLSB2YWx1ZXMgdG8gYXBwbHkgdG8gcG9wcGVyIGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhLmF0dHJpYnV0ZXMgLSBMaXN0IG9mIGF0dHJpYnV0ZSBwcm9wZXJ0aWVzIC0gdmFsdWVzIHRvIGFwcGx5IHRvIHBvcHBlciBlbGVtZW50XG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgc2FtZSBkYXRhIG9iamVjdFxuICovXG5mdW5jdGlvbiBhcHBseVN0eWxlKGRhdGEpIHtcbiAgLy8gYW55IHByb3BlcnR5IHByZXNlbnQgaW4gYGRhdGEuc3R5bGVzYCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlcixcbiAgLy8gaW4gdGhpcyB3YXkgd2UgY2FuIG1ha2UgdGhlIDNyZCBwYXJ0eSBtb2RpZmllcnMgYWRkIGN1c3RvbSBzdHlsZXMgdG8gaXRcbiAgLy8gQmUgYXdhcmUsIG1vZGlmaWVycyBjb3VsZCBvdmVycmlkZSB0aGUgcHJvcGVydGllcyBkZWZpbmVkIGluIHRoZSBwcmV2aW91c1xuICAvLyBsaW5lcyBvZiB0aGlzIG1vZGlmaWVyIVxuICBzZXRTdHlsZXMoZGF0YS5pbnN0YW5jZS5wb3BwZXIsIGRhdGEuc3R5bGVzKTtcblxuICAvLyBhbnkgcHJvcGVydHkgcHJlc2VudCBpbiBgZGF0YS5hdHRyaWJ1dGVzYCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlcixcbiAgLy8gdGhleSB3aWxsIGJlIHNldCBhcyBIVE1MIGF0dHJpYnV0ZXMgb2YgdGhlIGVsZW1lbnRcbiAgc2V0QXR0cmlidXRlcyhkYXRhLmluc3RhbmNlLnBvcHBlciwgZGF0YS5hdHRyaWJ1dGVzKTtcblxuICAvLyBpZiBhcnJvd0VsZW1lbnQgaXMgZGVmaW5lZCBhbmQgYXJyb3dTdHlsZXMgaGFzIHNvbWUgcHJvcGVydGllc1xuICBpZiAoZGF0YS5hcnJvd0VsZW1lbnQgJiYgT2JqZWN0LmtleXMoZGF0YS5hcnJvd1N0eWxlcykubGVuZ3RoKSB7XG4gICAgc2V0U3R5bGVzKGRhdGEuYXJyb3dFbGVtZW50LCBkYXRhLmFycm93U3R5bGVzKTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIFNldCB0aGUgeC1wbGFjZW1lbnQgYXR0cmlidXRlIGJlZm9yZSBldmVyeXRoaW5nIGVsc2UgYmVjYXVzZSBpdCBjb3VsZCBiZSB1c2VkXG4gKiB0byBhZGQgbWFyZ2lucyB0byB0aGUgcG9wcGVyIG1hcmdpbnMgbmVlZHMgdG8gYmUgY2FsY3VsYXRlZCB0byBnZXQgdGhlXG4gKiBjb3JyZWN0IHBvcHBlciBvZmZzZXRzLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5tb2RpZmllcnNcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHJlZmVyZW5jZSAtIFRoZSByZWZlcmVuY2UgZWxlbWVudCB1c2VkIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBvcHBlciAtIFRoZSBIVE1MIGVsZW1lbnQgdXNlZCBhcyBwb3BwZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gUG9wcGVyLmpzIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gYXBwbHlTdHlsZU9uTG9hZChyZWZlcmVuY2UsIHBvcHBlciwgb3B0aW9ucywgbW9kaWZpZXJPcHRpb25zLCBzdGF0ZSkge1xuICAvLyBjb21wdXRlIHJlZmVyZW5jZSBlbGVtZW50IG9mZnNldHNcbiAgdmFyIHJlZmVyZW5jZU9mZnNldHMgPSBnZXRSZWZlcmVuY2VPZmZzZXRzKHN0YXRlLCBwb3BwZXIsIHJlZmVyZW5jZSwgb3B0aW9ucy5wb3NpdGlvbkZpeGVkKTtcblxuICAvLyBjb21wdXRlIGF1dG8gcGxhY2VtZW50LCBzdG9yZSBwbGFjZW1lbnQgaW5zaWRlIHRoZSBkYXRhIG9iamVjdCxcbiAgLy8gbW9kaWZpZXJzIHdpbGwgYmUgYWJsZSB0byBlZGl0IGBwbGFjZW1lbnRgIGlmIG5lZWRlZFxuICAvLyBhbmQgcmVmZXIgdG8gb3JpZ2luYWxQbGFjZW1lbnQgdG8ga25vdyB0aGUgb3JpZ2luYWwgdmFsdWVcbiAgdmFyIHBsYWNlbWVudCA9IGNvbXB1dGVBdXRvUGxhY2VtZW50KG9wdGlvbnMucGxhY2VtZW50LCByZWZlcmVuY2VPZmZzZXRzLCBwb3BwZXIsIHJlZmVyZW5jZSwgb3B0aW9ucy5tb2RpZmllcnMuZmxpcC5ib3VuZGFyaWVzRWxlbWVudCwgb3B0aW9ucy5tb2RpZmllcnMuZmxpcC5wYWRkaW5nKTtcblxuICBwb3BwZXIuc2V0QXR0cmlidXRlKCd4LXBsYWNlbWVudCcsIHBsYWNlbWVudCk7XG5cbiAgLy8gQXBwbHkgYHBvc2l0aW9uYCB0byBwb3BwZXIgYmVmb3JlIGFueXRoaW5nIGVsc2UgYmVjYXVzZVxuICAvLyB3aXRob3V0IHRoZSBwb3NpdGlvbiBhcHBsaWVkIHdlIGNhbid0IGd1YXJhbnRlZSBjb3JyZWN0IGNvbXB1dGF0aW9uc1xuICBzZXRTdHlsZXMocG9wcGVyLCB7IHBvc2l0aW9uOiBvcHRpb25zLnBvc2l0aW9uRml4ZWQgPyAnZml4ZWQnIDogJ2Fic29sdXRlJyB9KTtcblxuICByZXR1cm4gb3B0aW9ucztcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZVN0eWxlKGRhdGEsIG9wdGlvbnMpIHtcbiAgdmFyIHggPSBvcHRpb25zLngsXG4gICAgICB5ID0gb3B0aW9ucy55O1xuICB2YXIgcG9wcGVyID0gZGF0YS5vZmZzZXRzLnBvcHBlcjtcblxuICAvLyBSZW1vdmUgdGhpcyBsZWdhY3kgc3VwcG9ydCBpbiBQb3BwZXIuanMgdjJcblxuICB2YXIgbGVnYWN5R3B1QWNjZWxlcmF0aW9uT3B0aW9uID0gZmluZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgcmV0dXJuIG1vZGlmaWVyLm5hbWUgPT09ICdhcHBseVN0eWxlJztcbiAgfSkuZ3B1QWNjZWxlcmF0aW9uO1xuICBpZiAobGVnYWN5R3B1QWNjZWxlcmF0aW9uT3B0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zb2xlLndhcm4oJ1dBUk5JTkc6IGBncHVBY2NlbGVyYXRpb25gIG9wdGlvbiBtb3ZlZCB0byBgY29tcHV0ZVN0eWxlYCBtb2RpZmllciBhbmQgd2lsbCBub3QgYmUgc3VwcG9ydGVkIGluIGZ1dHVyZSB2ZXJzaW9ucyBvZiBQb3BwZXIuanMhJyk7XG4gIH1cbiAgdmFyIGdwdUFjY2VsZXJhdGlvbiA9IGxlZ2FjeUdwdUFjY2VsZXJhdGlvbk9wdGlvbiAhPT0gdW5kZWZpbmVkID8gbGVnYWN5R3B1QWNjZWxlcmF0aW9uT3B0aW9uIDogb3B0aW9ucy5ncHVBY2NlbGVyYXRpb247XG5cbiAgdmFyIG9mZnNldFBhcmVudCA9IGdldE9mZnNldFBhcmVudChkYXRhLmluc3RhbmNlLnBvcHBlcik7XG4gIHZhciBvZmZzZXRQYXJlbnRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KG9mZnNldFBhcmVudCk7XG5cbiAgLy8gU3R5bGVzXG4gIHZhciBzdHlsZXMgPSB7XG4gICAgcG9zaXRpb246IHBvcHBlci5wb3NpdGlvblxuICB9O1xuXG4gIC8vIEF2b2lkIGJsdXJyeSB0ZXh0IGJ5IHVzaW5nIGZ1bGwgcGl4ZWwgaW50ZWdlcnMuXG4gIC8vIEZvciBwaXhlbC1wZXJmZWN0IHBvc2l0aW9uaW5nLCB0b3AvYm90dG9tIHByZWZlcnMgcm91bmRlZFxuICAvLyB2YWx1ZXMsIHdoaWxlIGxlZnQvcmlnaHQgcHJlZmVycyBmbG9vcmVkIHZhbHVlcy5cbiAgdmFyIG9mZnNldHMgPSB7XG4gICAgbGVmdDogTWF0aC5mbG9vcihwb3BwZXIubGVmdCksXG4gICAgdG9wOiBNYXRoLnJvdW5kKHBvcHBlci50b3ApLFxuICAgIGJvdHRvbTogTWF0aC5yb3VuZChwb3BwZXIuYm90dG9tKSxcbiAgICByaWdodDogTWF0aC5mbG9vcihwb3BwZXIucmlnaHQpXG4gIH07XG5cbiAgdmFyIHNpZGVBID0geCA9PT0gJ2JvdHRvbScgPyAndG9wJyA6ICdib3R0b20nO1xuICB2YXIgc2lkZUIgPSB5ID09PSAncmlnaHQnID8gJ2xlZnQnIDogJ3JpZ2h0JztcblxuICAvLyBpZiBncHVBY2NlbGVyYXRpb24gaXMgc2V0IHRvIGB0cnVlYCBhbmQgdHJhbnNmb3JtIGlzIHN1cHBvcnRlZCxcbiAgLy8gIHdlIHVzZSBgdHJhbnNsYXRlM2RgIHRvIGFwcGx5IHRoZSBwb3NpdGlvbiB0byB0aGUgcG9wcGVyIHdlXG4gIC8vIGF1dG9tYXRpY2FsbHkgdXNlIHRoZSBzdXBwb3J0ZWQgcHJlZml4ZWQgdmVyc2lvbiBpZiBuZWVkZWRcbiAgdmFyIHByZWZpeGVkUHJvcGVydHkgPSBnZXRTdXBwb3J0ZWRQcm9wZXJ0eU5hbWUoJ3RyYW5zZm9ybScpO1xuXG4gIC8vIG5vdywgbGV0J3MgbWFrZSBhIHN0ZXAgYmFjayBhbmQgbG9vayBhdCB0aGlzIGNvZGUgY2xvc2VseSAod3RmPylcbiAgLy8gSWYgdGhlIGNvbnRlbnQgb2YgdGhlIHBvcHBlciBncm93cyBvbmNlIGl0J3MgYmVlbiBwb3NpdGlvbmVkLCBpdFxuICAvLyBtYXkgaGFwcGVuIHRoYXQgdGhlIHBvcHBlciBnZXRzIG1pc3BsYWNlZCBiZWNhdXNlIG9mIHRoZSBuZXcgY29udGVudFxuICAvLyBvdmVyZmxvd2luZyBpdHMgcmVmZXJlbmNlIGVsZW1lbnRcbiAgLy8gVG8gYXZvaWQgdGhpcyBwcm9ibGVtLCB3ZSBwcm92aWRlIHR3byBvcHRpb25zICh4IGFuZCB5KSwgd2hpY2ggYWxsb3dcbiAgLy8gdGhlIGNvbnN1bWVyIHRvIGRlZmluZSB0aGUgb2Zmc2V0IG9yaWdpbi5cbiAgLy8gSWYgd2UgcG9zaXRpb24gYSBwb3BwZXIgb24gdG9wIG9mIGEgcmVmZXJlbmNlIGVsZW1lbnQsIHdlIGNhbiBzZXRcbiAgLy8gYHhgIHRvIGB0b3BgIHRvIG1ha2UgdGhlIHBvcHBlciBncm93IHRvd2FyZHMgaXRzIHRvcCBpbnN0ZWFkIG9mXG4gIC8vIGl0cyBib3R0b20uXG4gIHZhciBsZWZ0ID0gdm9pZCAwLFxuICAgICAgdG9wID0gdm9pZCAwO1xuICBpZiAoc2lkZUEgPT09ICdib3R0b20nKSB7XG4gICAgdG9wID0gLW9mZnNldFBhcmVudFJlY3QuaGVpZ2h0ICsgb2Zmc2V0cy5ib3R0b207XG4gIH0gZWxzZSB7XG4gICAgdG9wID0gb2Zmc2V0cy50b3A7XG4gIH1cbiAgaWYgKHNpZGVCID09PSAncmlnaHQnKSB7XG4gICAgbGVmdCA9IC1vZmZzZXRQYXJlbnRSZWN0LndpZHRoICsgb2Zmc2V0cy5yaWdodDtcbiAgfSBlbHNlIHtcbiAgICBsZWZ0ID0gb2Zmc2V0cy5sZWZ0O1xuICB9XG4gIGlmIChncHVBY2NlbGVyYXRpb24gJiYgcHJlZml4ZWRQcm9wZXJ0eSkge1xuICAgIHN0eWxlc1twcmVmaXhlZFByb3BlcnR5XSA9ICd0cmFuc2xhdGUzZCgnICsgbGVmdCArICdweCwgJyArIHRvcCArICdweCwgMCknO1xuICAgIHN0eWxlc1tzaWRlQV0gPSAwO1xuICAgIHN0eWxlc1tzaWRlQl0gPSAwO1xuICAgIHN0eWxlcy53aWxsQ2hhbmdlID0gJ3RyYW5zZm9ybSc7XG4gIH0gZWxzZSB7XG4gICAgLy8gb3Rod2VyaXNlLCB3ZSB1c2UgdGhlIHN0YW5kYXJkIGB0b3BgLCBgbGVmdGAsIGBib3R0b21gIGFuZCBgcmlnaHRgIHByb3BlcnRpZXNcbiAgICB2YXIgaW52ZXJ0VG9wID0gc2lkZUEgPT09ICdib3R0b20nID8gLTEgOiAxO1xuICAgIHZhciBpbnZlcnRMZWZ0ID0gc2lkZUIgPT09ICdyaWdodCcgPyAtMSA6IDE7XG4gICAgc3R5bGVzW3NpZGVBXSA9IHRvcCAqIGludmVydFRvcDtcbiAgICBzdHlsZXNbc2lkZUJdID0gbGVmdCAqIGludmVydExlZnQ7XG4gICAgc3R5bGVzLndpbGxDaGFuZ2UgPSBzaWRlQSArICcsICcgKyBzaWRlQjtcbiAgfVxuXG4gIC8vIEF0dHJpYnV0ZXNcbiAgdmFyIGF0dHJpYnV0ZXMgPSB7XG4gICAgJ3gtcGxhY2VtZW50JzogZGF0YS5wbGFjZW1lbnRcbiAgfTtcblxuICAvLyBVcGRhdGUgYGRhdGFgIGF0dHJpYnV0ZXMsIHN0eWxlcyBhbmQgYXJyb3dTdHlsZXNcbiAgZGF0YS5hdHRyaWJ1dGVzID0gX2V4dGVuZHMoe30sIGF0dHJpYnV0ZXMsIGRhdGEuYXR0cmlidXRlcyk7XG4gIGRhdGEuc3R5bGVzID0gX2V4dGVuZHMoe30sIHN0eWxlcywgZGF0YS5zdHlsZXMpO1xuICBkYXRhLmFycm93U3R5bGVzID0gX2V4dGVuZHMoe30sIGRhdGEub2Zmc2V0cy5hcnJvdywgZGF0YS5hcnJvd1N0eWxlcyk7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogSGVscGVyIHVzZWQgdG8ga25vdyBpZiB0aGUgZ2l2ZW4gbW9kaWZpZXIgZGVwZW5kcyBmcm9tIGFub3RoZXIgb25lLjxiciAvPlxuICogSXQgY2hlY2tzIGlmIHRoZSBuZWVkZWQgbW9kaWZpZXIgaXMgbGlzdGVkIGFuZCBlbmFibGVkLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtBcnJheX0gbW9kaWZpZXJzIC0gbGlzdCBvZiBtb2RpZmllcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0aW5nTmFtZSAtIG5hbWUgb2YgcmVxdWVzdGluZyBtb2RpZmllclxuICogQHBhcmFtIHtTdHJpbmd9IHJlcXVlc3RlZE5hbWUgLSBuYW1lIG9mIHJlcXVlc3RlZCBtb2RpZmllclxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzTW9kaWZpZXJSZXF1aXJlZChtb2RpZmllcnMsIHJlcXVlc3RpbmdOYW1lLCByZXF1ZXN0ZWROYW1lKSB7XG4gIHZhciByZXF1ZXN0aW5nID0gZmluZChtb2RpZmllcnMsIGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmLm5hbWU7XG4gICAgcmV0dXJuIG5hbWUgPT09IHJlcXVlc3RpbmdOYW1lO1xuICB9KTtcblxuICB2YXIgaXNSZXF1aXJlZCA9ICEhcmVxdWVzdGluZyAmJiBtb2RpZmllcnMuc29tZShmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICByZXR1cm4gbW9kaWZpZXIubmFtZSA9PT0gcmVxdWVzdGVkTmFtZSAmJiBtb2RpZmllci5lbmFibGVkICYmIG1vZGlmaWVyLm9yZGVyIDwgcmVxdWVzdGluZy5vcmRlcjtcbiAgfSk7XG5cbiAgaWYgKCFpc1JlcXVpcmVkKSB7XG4gICAgdmFyIF9yZXF1ZXN0aW5nID0gJ2AnICsgcmVxdWVzdGluZ05hbWUgKyAnYCc7XG4gICAgdmFyIHJlcXVlc3RlZCA9ICdgJyArIHJlcXVlc3RlZE5hbWUgKyAnYCc7XG4gICAgY29uc29sZS53YXJuKHJlcXVlc3RlZCArICcgbW9kaWZpZXIgaXMgcmVxdWlyZWQgYnkgJyArIF9yZXF1ZXN0aW5nICsgJyBtb2RpZmllciBpbiBvcmRlciB0byB3b3JrLCBiZSBzdXJlIHRvIGluY2x1ZGUgaXQgYmVmb3JlICcgKyBfcmVxdWVzdGluZyArICchJyk7XG4gIH1cbiAgcmV0dXJuIGlzUmVxdWlyZWQ7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBhcnJvdyhkYXRhLCBvcHRpb25zKSB7XG4gIHZhciBfZGF0YSRvZmZzZXRzJGFycm93O1xuXG4gIC8vIGFycm93IGRlcGVuZHMgb24ga2VlcFRvZ2V0aGVyIGluIG9yZGVyIHRvIHdvcmtcbiAgaWYgKCFpc01vZGlmaWVyUmVxdWlyZWQoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsICdhcnJvdycsICdrZWVwVG9nZXRoZXInKSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgdmFyIGFycm93RWxlbWVudCA9IG9wdGlvbnMuZWxlbWVudDtcblxuICAvLyBpZiBhcnJvd0VsZW1lbnQgaXMgYSBzdHJpbmcsIHN1cHBvc2UgaXQncyBhIENTUyBzZWxlY3RvclxuICBpZiAodHlwZW9mIGFycm93RWxlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICBhcnJvd0VsZW1lbnQgPSBkYXRhLmluc3RhbmNlLnBvcHBlci5xdWVyeVNlbGVjdG9yKGFycm93RWxlbWVudCk7XG5cbiAgICAvLyBpZiBhcnJvd0VsZW1lbnQgaXMgbm90IGZvdW5kLCBkb24ndCBydW4gdGhlIG1vZGlmaWVyXG4gICAgaWYgKCFhcnJvd0VsZW1lbnQpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBpZiB0aGUgYXJyb3dFbGVtZW50IGlzbid0IGEgcXVlcnkgc2VsZWN0b3Igd2UgbXVzdCBjaGVjayB0aGF0IHRoZVxuICAgIC8vIHByb3ZpZGVkIERPTSBub2RlIGlzIGNoaWxkIG9mIGl0cyBwb3BwZXIgbm9kZVxuICAgIGlmICghZGF0YS5pbnN0YW5jZS5wb3BwZXIuY29udGFpbnMoYXJyb3dFbGVtZW50KSkge1xuICAgICAgY29uc29sZS53YXJuKCdXQVJOSU5HOiBgYXJyb3cuZWxlbWVudGAgbXVzdCBiZSBjaGlsZCBvZiBpdHMgcG9wcGVyIGVsZW1lbnQhJyk7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gIH1cblxuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgdmFyIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlO1xuXG4gIHZhciBpc1ZlcnRpY2FsID0gWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMTtcblxuICB2YXIgbGVuID0gaXNWZXJ0aWNhbCA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgdmFyIHNpZGVDYXBpdGFsaXplZCA9IGlzVmVydGljYWwgPyAnVG9wJyA6ICdMZWZ0JztcbiAgdmFyIHNpZGUgPSBzaWRlQ2FwaXRhbGl6ZWQudG9Mb3dlckNhc2UoKTtcbiAgdmFyIGFsdFNpZGUgPSBpc1ZlcnRpY2FsID8gJ2xlZnQnIDogJ3RvcCc7XG4gIHZhciBvcFNpZGUgPSBpc1ZlcnRpY2FsID8gJ2JvdHRvbScgOiAncmlnaHQnO1xuICB2YXIgYXJyb3dFbGVtZW50U2l6ZSA9IGdldE91dGVyU2l6ZXMoYXJyb3dFbGVtZW50KVtsZW5dO1xuXG4gIC8vXG4gIC8vIGV4dGVuZHMga2VlcFRvZ2V0aGVyIGJlaGF2aW9yIG1ha2luZyBzdXJlIHRoZSBwb3BwZXIgYW5kIGl0c1xuICAvLyByZWZlcmVuY2UgaGF2ZSBlbm91Z2ggcGl4ZWxzIGluIGNvbmp1Y3Rpb25cbiAgLy9cblxuICAvLyB0b3AvbGVmdCBzaWRlXG4gIGlmIChyZWZlcmVuY2Vbb3BTaWRlXSAtIGFycm93RWxlbWVudFNpemUgPCBwb3BwZXJbc2lkZV0pIHtcbiAgICBkYXRhLm9mZnNldHMucG9wcGVyW3NpZGVdIC09IHBvcHBlcltzaWRlXSAtIChyZWZlcmVuY2Vbb3BTaWRlXSAtIGFycm93RWxlbWVudFNpemUpO1xuICB9XG4gIC8vIGJvdHRvbS9yaWdodCBzaWRlXG4gIGlmIChyZWZlcmVuY2Vbc2lkZV0gKyBhcnJvd0VsZW1lbnRTaXplID4gcG9wcGVyW29wU2lkZV0pIHtcbiAgICBkYXRhLm9mZnNldHMucG9wcGVyW3NpZGVdICs9IHJlZmVyZW5jZVtzaWRlXSArIGFycm93RWxlbWVudFNpemUgLSBwb3BwZXJbb3BTaWRlXTtcbiAgfVxuICBkYXRhLm9mZnNldHMucG9wcGVyID0gZ2V0Q2xpZW50UmVjdChkYXRhLm9mZnNldHMucG9wcGVyKTtcblxuICAvLyBjb21wdXRlIGNlbnRlciBvZiB0aGUgcG9wcGVyXG4gIHZhciBjZW50ZXIgPSByZWZlcmVuY2Vbc2lkZV0gKyByZWZlcmVuY2VbbGVuXSAvIDIgLSBhcnJvd0VsZW1lbnRTaXplIC8gMjtcblxuICAvLyBDb21wdXRlIHRoZSBzaWRlVmFsdWUgdXNpbmcgdGhlIHVwZGF0ZWQgcG9wcGVyIG9mZnNldHNcbiAgLy8gdGFrZSBwb3BwZXIgbWFyZ2luIGluIGFjY291bnQgYmVjYXVzZSB3ZSBkb24ndCBoYXZlIHRoaXMgaW5mbyBhdmFpbGFibGVcbiAgdmFyIGNzcyA9IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShkYXRhLmluc3RhbmNlLnBvcHBlcik7XG4gIHZhciBwb3BwZXJNYXJnaW5TaWRlID0gcGFyc2VGbG9hdChjc3NbJ21hcmdpbicgKyBzaWRlQ2FwaXRhbGl6ZWRdLCAxMCk7XG4gIHZhciBwb3BwZXJCb3JkZXJTaWRlID0gcGFyc2VGbG9hdChjc3NbJ2JvcmRlcicgKyBzaWRlQ2FwaXRhbGl6ZWQgKyAnV2lkdGgnXSwgMTApO1xuICB2YXIgc2lkZVZhbHVlID0gY2VudGVyIC0gZGF0YS5vZmZzZXRzLnBvcHBlcltzaWRlXSAtIHBvcHBlck1hcmdpblNpZGUgLSBwb3BwZXJCb3JkZXJTaWRlO1xuXG4gIC8vIHByZXZlbnQgYXJyb3dFbGVtZW50IGZyb20gYmVpbmcgcGxhY2VkIG5vdCBjb250aWd1b3VzbHkgdG8gaXRzIHBvcHBlclxuICBzaWRlVmFsdWUgPSBNYXRoLm1heChNYXRoLm1pbihwb3BwZXJbbGVuXSAtIGFycm93RWxlbWVudFNpemUsIHNpZGVWYWx1ZSksIDApO1xuXG4gIGRhdGEuYXJyb3dFbGVtZW50ID0gYXJyb3dFbGVtZW50O1xuICBkYXRhLm9mZnNldHMuYXJyb3cgPSAoX2RhdGEkb2Zmc2V0cyRhcnJvdyA9IHt9LCBkZWZpbmVQcm9wZXJ0eShfZGF0YSRvZmZzZXRzJGFycm93LCBzaWRlLCBNYXRoLnJvdW5kKHNpZGVWYWx1ZSkpLCBkZWZpbmVQcm9wZXJ0eShfZGF0YSRvZmZzZXRzJGFycm93LCBhbHRTaWRlLCAnJyksIF9kYXRhJG9mZnNldHMkYXJyb3cpO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEdldCB0aGUgb3Bwb3NpdGUgcGxhY2VtZW50IHZhcmlhdGlvbiBvZiB0aGUgZ2l2ZW4gb25lXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gcGxhY2VtZW50IHZhcmlhdGlvblxuICogQHJldHVybnMge1N0cmluZ30gZmxpcHBlZCBwbGFjZW1lbnQgdmFyaWF0aW9uXG4gKi9cbmZ1bmN0aW9uIGdldE9wcG9zaXRlVmFyaWF0aW9uKHZhcmlhdGlvbikge1xuICBpZiAodmFyaWF0aW9uID09PSAnZW5kJykge1xuICAgIHJldHVybiAnc3RhcnQnO1xuICB9IGVsc2UgaWYgKHZhcmlhdGlvbiA9PT0gJ3N0YXJ0Jykge1xuICAgIHJldHVybiAnZW5kJztcbiAgfVxuICByZXR1cm4gdmFyaWF0aW9uO1xufVxuXG4vKipcbiAqIExpc3Qgb2YgYWNjZXB0ZWQgcGxhY2VtZW50cyB0byB1c2UgYXMgdmFsdWVzIG9mIHRoZSBgcGxhY2VtZW50YCBvcHRpb24uPGJyIC8+XG4gKiBWYWxpZCBwbGFjZW1lbnRzIGFyZTpcbiAqIC0gYGF1dG9gXG4gKiAtIGB0b3BgXG4gKiAtIGByaWdodGBcbiAqIC0gYGJvdHRvbWBcbiAqIC0gYGxlZnRgXG4gKlxuICogRWFjaCBwbGFjZW1lbnQgY2FuIGhhdmUgYSB2YXJpYXRpb24gZnJvbSB0aGlzIGxpc3Q6XG4gKiAtIGAtc3RhcnRgXG4gKiAtIGAtZW5kYFxuICpcbiAqIFZhcmlhdGlvbnMgYXJlIGludGVycHJldGVkIGVhc2lseSBpZiB5b3UgdGhpbmsgb2YgdGhlbSBhcyB0aGUgbGVmdCB0byByaWdodFxuICogd3JpdHRlbiBsYW5ndWFnZXMuIEhvcml6b250YWxseSAoYHRvcGAgYW5kIGBib3R0b21gKSwgYHN0YXJ0YCBpcyBsZWZ0IGFuZCBgZW5kYFxuICogaXMgcmlnaHQuPGJyIC8+XG4gKiBWZXJ0aWNhbGx5IChgbGVmdGAgYW5kIGByaWdodGApLCBgc3RhcnRgIGlzIHRvcCBhbmQgYGVuZGAgaXMgYm90dG9tLlxuICpcbiAqIFNvbWUgdmFsaWQgZXhhbXBsZXMgYXJlOlxuICogLSBgdG9wLWVuZGAgKG9uIHRvcCBvZiByZWZlcmVuY2UsIHJpZ2h0IGFsaWduZWQpXG4gKiAtIGByaWdodC1zdGFydGAgKG9uIHJpZ2h0IG9mIHJlZmVyZW5jZSwgdG9wIGFsaWduZWQpXG4gKiAtIGBib3R0b21gIChvbiBib3R0b20sIGNlbnRlcmVkKVxuICogLSBgYXV0by1yaWdodGAgKG9uIHRoZSBzaWRlIHdpdGggbW9yZSBzcGFjZSBhdmFpbGFibGUsIGFsaWdubWVudCBkZXBlbmRzIGJ5IHBsYWNlbWVudClcbiAqXG4gKiBAc3RhdGljXG4gKiBAdHlwZSB7QXJyYXl9XG4gKiBAZW51bSB7U3RyaW5nfVxuICogQHJlYWRvbmx5XG4gKiBAbWV0aG9kIHBsYWNlbWVudHNcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xudmFyIHBsYWNlbWVudHMgPSBbJ2F1dG8tc3RhcnQnLCAnYXV0bycsICdhdXRvLWVuZCcsICd0b3Atc3RhcnQnLCAndG9wJywgJ3RvcC1lbmQnLCAncmlnaHQtc3RhcnQnLCAncmlnaHQnLCAncmlnaHQtZW5kJywgJ2JvdHRvbS1lbmQnLCAnYm90dG9tJywgJ2JvdHRvbS1zdGFydCcsICdsZWZ0LWVuZCcsICdsZWZ0JywgJ2xlZnQtc3RhcnQnXTtcblxuLy8gR2V0IHJpZCBvZiBgYXV0b2AgYGF1dG8tc3RhcnRgIGFuZCBgYXV0by1lbmRgXG52YXIgdmFsaWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cy5zbGljZSgzKTtcblxuLyoqXG4gKiBHaXZlbiBhbiBpbml0aWFsIHBsYWNlbWVudCwgcmV0dXJucyBhbGwgdGhlIHN1YnNlcXVlbnQgcGxhY2VtZW50c1xuICogY2xvY2t3aXNlIChvciBjb3VudGVyLWNsb2Nrd2lzZSkuXG4gKlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IHBsYWNlbWVudCAtIEEgdmFsaWQgcGxhY2VtZW50IChpdCBhY2NlcHRzIHZhcmlhdGlvbnMpXG4gKiBAYXJndW1lbnQge0Jvb2xlYW59IGNvdW50ZXIgLSBTZXQgdG8gdHJ1ZSB0byB3YWxrIHRoZSBwbGFjZW1lbnRzIGNvdW50ZXJjbG9ja3dpc2VcbiAqIEByZXR1cm5zIHtBcnJheX0gcGxhY2VtZW50cyBpbmNsdWRpbmcgdGhlaXIgdmFyaWF0aW9uc1xuICovXG5mdW5jdGlvbiBjbG9ja3dpc2UocGxhY2VtZW50KSB7XG4gIHZhciBjb3VudGVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICB2YXIgaW5kZXggPSB2YWxpZFBsYWNlbWVudHMuaW5kZXhPZihwbGFjZW1lbnQpO1xuICB2YXIgYXJyID0gdmFsaWRQbGFjZW1lbnRzLnNsaWNlKGluZGV4ICsgMSkuY29uY2F0KHZhbGlkUGxhY2VtZW50cy5zbGljZSgwLCBpbmRleCkpO1xuICByZXR1cm4gY291bnRlciA/IGFyci5yZXZlcnNlKCkgOiBhcnI7XG59XG5cbnZhciBCRUhBVklPUlMgPSB7XG4gIEZMSVA6ICdmbGlwJyxcbiAgQ0xPQ0tXSVNFOiAnY2xvY2t3aXNlJyxcbiAgQ09VTlRFUkNMT0NLV0lTRTogJ2NvdW50ZXJjbG9ja3dpc2UnXG59O1xuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gZmxpcChkYXRhLCBvcHRpb25zKSB7XG4gIC8vIGlmIGBpbm5lcmAgbW9kaWZpZXIgaXMgZW5hYmxlZCwgd2UgY2FuJ3QgdXNlIHRoZSBgZmxpcGAgbW9kaWZpZXJcbiAgaWYgKGlzTW9kaWZpZXJFbmFibGVkKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCAnaW5uZXInKSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgaWYgKGRhdGEuZmxpcHBlZCAmJiBkYXRhLnBsYWNlbWVudCA9PT0gZGF0YS5vcmlnaW5hbFBsYWNlbWVudCkge1xuICAgIC8vIHNlZW1zIGxpa2UgZmxpcCBpcyB0cnlpbmcgdG8gbG9vcCwgcHJvYmFibHkgdGhlcmUncyBub3QgZW5vdWdoIHNwYWNlIG9uIGFueSBvZiB0aGUgZmxpcHBhYmxlIHNpZGVzXG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICB2YXIgYm91bmRhcmllcyA9IGdldEJvdW5kYXJpZXMoZGF0YS5pbnN0YW5jZS5wb3BwZXIsIGRhdGEuaW5zdGFuY2UucmVmZXJlbmNlLCBvcHRpb25zLnBhZGRpbmcsIG9wdGlvbnMuYm91bmRhcmllc0VsZW1lbnQsIGRhdGEucG9zaXRpb25GaXhlZCk7XG5cbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIHZhciBwbGFjZW1lbnRPcHBvc2l0ZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIHZhciB2YXJpYXRpb24gPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzFdIHx8ICcnO1xuXG4gIHZhciBmbGlwT3JkZXIgPSBbXTtcblxuICBzd2l0Y2ggKG9wdGlvbnMuYmVoYXZpb3IpIHtcbiAgICBjYXNlIEJFSEFWSU9SUy5GTElQOlxuICAgICAgZmxpcE9yZGVyID0gW3BsYWNlbWVudCwgcGxhY2VtZW50T3Bwb3NpdGVdO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBCRUhBVklPUlMuQ0xPQ0tXSVNFOlxuICAgICAgZmxpcE9yZGVyID0gY2xvY2t3aXNlKHBsYWNlbWVudCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIEJFSEFWSU9SUy5DT1VOVEVSQ0xPQ0tXSVNFOlxuICAgICAgZmxpcE9yZGVyID0gY2xvY2t3aXNlKHBsYWNlbWVudCwgdHJ1ZSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgZmxpcE9yZGVyID0gb3B0aW9ucy5iZWhhdmlvcjtcbiAgfVxuXG4gIGZsaXBPcmRlci5mb3JFYWNoKGZ1bmN0aW9uIChzdGVwLCBpbmRleCkge1xuICAgIGlmIChwbGFjZW1lbnQgIT09IHN0ZXAgfHwgZmxpcE9yZGVyLmxlbmd0aCA9PT0gaW5kZXggKyAxKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICAgIHBsYWNlbWVudE9wcG9zaXRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcblxuICAgIHZhciBwb3BwZXJPZmZzZXRzID0gZGF0YS5vZmZzZXRzLnBvcHBlcjtcbiAgICB2YXIgcmVmT2Zmc2V0cyA9IGRhdGEub2Zmc2V0cy5yZWZlcmVuY2U7XG5cbiAgICAvLyB1c2luZyBmbG9vciBiZWNhdXNlIHRoZSByZWZlcmVuY2Ugb2Zmc2V0cyBtYXkgY29udGFpbiBkZWNpbWFscyB3ZSBhcmUgbm90IGdvaW5nIHRvIGNvbnNpZGVyIGhlcmVcbiAgICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuICAgIHZhciBvdmVybGFwc1JlZiA9IHBsYWNlbWVudCA9PT0gJ2xlZnQnICYmIGZsb29yKHBvcHBlck9mZnNldHMucmlnaHQpID4gZmxvb3IocmVmT2Zmc2V0cy5sZWZ0KSB8fCBwbGFjZW1lbnQgPT09ICdyaWdodCcgJiYgZmxvb3IocG9wcGVyT2Zmc2V0cy5sZWZ0KSA8IGZsb29yKHJlZk9mZnNldHMucmlnaHQpIHx8IHBsYWNlbWVudCA9PT0gJ3RvcCcgJiYgZmxvb3IocG9wcGVyT2Zmc2V0cy5ib3R0b20pID4gZmxvb3IocmVmT2Zmc2V0cy50b3ApIHx8IHBsYWNlbWVudCA9PT0gJ2JvdHRvbScgJiYgZmxvb3IocG9wcGVyT2Zmc2V0cy50b3ApIDwgZmxvb3IocmVmT2Zmc2V0cy5ib3R0b20pO1xuXG4gICAgdmFyIG92ZXJmbG93c0xlZnQgPSBmbG9vcihwb3BwZXJPZmZzZXRzLmxlZnQpIDwgZmxvb3IoYm91bmRhcmllcy5sZWZ0KTtcbiAgICB2YXIgb3ZlcmZsb3dzUmlnaHQgPSBmbG9vcihwb3BwZXJPZmZzZXRzLnJpZ2h0KSA+IGZsb29yKGJvdW5kYXJpZXMucmlnaHQpO1xuICAgIHZhciBvdmVyZmxvd3NUb3AgPSBmbG9vcihwb3BwZXJPZmZzZXRzLnRvcCkgPCBmbG9vcihib3VuZGFyaWVzLnRvcCk7XG4gICAgdmFyIG92ZXJmbG93c0JvdHRvbSA9IGZsb29yKHBvcHBlck9mZnNldHMuYm90dG9tKSA+IGZsb29yKGJvdW5kYXJpZXMuYm90dG9tKTtcblxuICAgIHZhciBvdmVyZmxvd3NCb3VuZGFyaWVzID0gcGxhY2VtZW50ID09PSAnbGVmdCcgJiYgb3ZlcmZsb3dzTGVmdCB8fCBwbGFjZW1lbnQgPT09ICdyaWdodCcgJiYgb3ZlcmZsb3dzUmlnaHQgfHwgcGxhY2VtZW50ID09PSAndG9wJyAmJiBvdmVyZmxvd3NUb3AgfHwgcGxhY2VtZW50ID09PSAnYm90dG9tJyAmJiBvdmVyZmxvd3NCb3R0b207XG5cbiAgICAvLyBmbGlwIHRoZSB2YXJpYXRpb24gaWYgcmVxdWlyZWRcbiAgICB2YXIgaXNWZXJ0aWNhbCA9IFsndG9wJywgJ2JvdHRvbSddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTE7XG4gICAgdmFyIGZsaXBwZWRWYXJpYXRpb24gPSAhIW9wdGlvbnMuZmxpcFZhcmlhdGlvbnMgJiYgKGlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnc3RhcnQnICYmIG92ZXJmbG93c0xlZnQgfHwgaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdlbmQnICYmIG92ZXJmbG93c1JpZ2h0IHx8ICFpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ3N0YXJ0JyAmJiBvdmVyZmxvd3NUb3AgfHwgIWlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnZW5kJyAmJiBvdmVyZmxvd3NCb3R0b20pO1xuXG4gICAgaWYgKG92ZXJsYXBzUmVmIHx8IG92ZXJmbG93c0JvdW5kYXJpZXMgfHwgZmxpcHBlZFZhcmlhdGlvbikge1xuICAgICAgLy8gdGhpcyBib29sZWFuIHRvIGRldGVjdCBhbnkgZmxpcCBsb29wXG4gICAgICBkYXRhLmZsaXBwZWQgPSB0cnVlO1xuXG4gICAgICBpZiAob3ZlcmxhcHNSZWYgfHwgb3ZlcmZsb3dzQm91bmRhcmllcykge1xuICAgICAgICBwbGFjZW1lbnQgPSBmbGlwT3JkZXJbaW5kZXggKyAxXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZsaXBwZWRWYXJpYXRpb24pIHtcbiAgICAgICAgdmFyaWF0aW9uID0gZ2V0T3Bwb3NpdGVWYXJpYXRpb24odmFyaWF0aW9uKTtcbiAgICAgIH1cblxuICAgICAgZGF0YS5wbGFjZW1lbnQgPSBwbGFjZW1lbnQgKyAodmFyaWF0aW9uID8gJy0nICsgdmFyaWF0aW9uIDogJycpO1xuXG4gICAgICAvLyB0aGlzIG9iamVjdCBjb250YWlucyBgcG9zaXRpb25gLCB3ZSB3YW50IHRvIHByZXNlcnZlIGl0IGFsb25nIHdpdGhcbiAgICAgIC8vIGFueSBhZGRpdGlvbmFsIHByb3BlcnR5IHdlIG1heSBhZGQgaW4gdGhlIGZ1dHVyZVxuICAgICAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IF9leHRlbmRzKHt9LCBkYXRhLm9mZnNldHMucG9wcGVyLCBnZXRQb3BwZXJPZmZzZXRzKGRhdGEuaW5zdGFuY2UucG9wcGVyLCBkYXRhLm9mZnNldHMucmVmZXJlbmNlLCBkYXRhLnBsYWNlbWVudCkpO1xuXG4gICAgICBkYXRhID0gcnVuTW9kaWZpZXJzKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCBkYXRhLCAnZmxpcCcpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24ga2VlcFRvZ2V0aGVyKGRhdGEpIHtcbiAgdmFyIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlO1xuXG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuICB2YXIgaXNWZXJ0aWNhbCA9IFsndG9wJywgJ2JvdHRvbSddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTE7XG4gIHZhciBzaWRlID0gaXNWZXJ0aWNhbCA/ICdyaWdodCcgOiAnYm90dG9tJztcbiAgdmFyIG9wU2lkZSA9IGlzVmVydGljYWwgPyAnbGVmdCcgOiAndG9wJztcbiAgdmFyIG1lYXN1cmVtZW50ID0gaXNWZXJ0aWNhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcblxuICBpZiAocG9wcGVyW3NpZGVdIDwgZmxvb3IocmVmZXJlbmNlW29wU2lkZV0pKSB7XG4gICAgZGF0YS5vZmZzZXRzLnBvcHBlcltvcFNpZGVdID0gZmxvb3IocmVmZXJlbmNlW29wU2lkZV0pIC0gcG9wcGVyW21lYXN1cmVtZW50XTtcbiAgfVxuICBpZiAocG9wcGVyW29wU2lkZV0gPiBmbG9vcihyZWZlcmVuY2Vbc2lkZV0pKSB7XG4gICAgZGF0YS5vZmZzZXRzLnBvcHBlcltvcFNpZGVdID0gZmxvb3IocmVmZXJlbmNlW3NpZGVdKTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgc3RyaW5nIGNvbnRhaW5pbmcgdmFsdWUgKyB1bml0IGludG8gYSBweCB2YWx1ZSBudW1iZXJcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIHttb2RpZmllcnN+b2Zmc2V0fVxuICogQHByaXZhdGVcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBzdHIgLSBWYWx1ZSArIHVuaXQgc3RyaW5nXG4gKiBAYXJndW1lbnQge1N0cmluZ30gbWVhc3VyZW1lbnQgLSBgaGVpZ2h0YCBvciBgd2lkdGhgXG4gKiBAYXJndW1lbnQge09iamVjdH0gcG9wcGVyT2Zmc2V0c1xuICogQGFyZ3VtZW50IHtPYmplY3R9IHJlZmVyZW5jZU9mZnNldHNcbiAqIEByZXR1cm5zIHtOdW1iZXJ8U3RyaW5nfVxuICogVmFsdWUgaW4gcGl4ZWxzLCBvciBvcmlnaW5hbCBzdHJpbmcgaWYgbm8gdmFsdWVzIHdlcmUgZXh0cmFjdGVkXG4gKi9cbmZ1bmN0aW9uIHRvVmFsdWUoc3RyLCBtZWFzdXJlbWVudCwgcG9wcGVyT2Zmc2V0cywgcmVmZXJlbmNlT2Zmc2V0cykge1xuICAvLyBzZXBhcmF0ZSB2YWx1ZSBmcm9tIHVuaXRcbiAgdmFyIHNwbGl0ID0gc3RyLm1hdGNoKC8oKD86XFwtfFxcKyk/XFxkKlxcLj9cXGQqKSguKikvKTtcbiAgdmFyIHZhbHVlID0gK3NwbGl0WzFdO1xuICB2YXIgdW5pdCA9IHNwbGl0WzJdO1xuXG4gIC8vIElmIGl0J3Mgbm90IGEgbnVtYmVyIGl0J3MgYW4gb3BlcmF0b3IsIEkgZ3Vlc3NcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICBpZiAodW5pdC5pbmRleE9mKCclJykgPT09IDApIHtcbiAgICB2YXIgZWxlbWVudCA9IHZvaWQgMDtcbiAgICBzd2l0Y2ggKHVuaXQpIHtcbiAgICAgIGNhc2UgJyVwJzpcbiAgICAgICAgZWxlbWVudCA9IHBvcHBlck9mZnNldHM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnJSc6XG4gICAgICBjYXNlICclcic6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBlbGVtZW50ID0gcmVmZXJlbmNlT2Zmc2V0cztcbiAgICB9XG5cbiAgICB2YXIgcmVjdCA9IGdldENsaWVudFJlY3QoZWxlbWVudCk7XG4gICAgcmV0dXJuIHJlY3RbbWVhc3VyZW1lbnRdIC8gMTAwICogdmFsdWU7XG4gIH0gZWxzZSBpZiAodW5pdCA9PT0gJ3ZoJyB8fCB1bml0ID09PSAndncnKSB7XG4gICAgLy8gaWYgaXMgYSB2aCBvciB2dywgd2UgY2FsY3VsYXRlIHRoZSBzaXplIGJhc2VkIG9uIHRoZSB2aWV3cG9ydFxuICAgIHZhciBzaXplID0gdm9pZCAwO1xuICAgIGlmICh1bml0ID09PSAndmgnKSB7XG4gICAgICBzaXplID0gTWF0aC5tYXgoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCwgd2luZG93LmlubmVySGVpZ2h0IHx8IDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaXplID0gTWF0aC5tYXgoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoLCB3aW5kb3cuaW5uZXJXaWR0aCB8fCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIHNpemUgLyAxMDAgKiB2YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBpZiBpcyBhbiBleHBsaWNpdCBwaXhlbCB1bml0LCB3ZSBnZXQgcmlkIG9mIHRoZSB1bml0IGFuZCBrZWVwIHRoZSB2YWx1ZVxuICAgIC8vIGlmIGlzIGFuIGltcGxpY2l0IHVuaXQsIGl0J3MgcHgsIGFuZCB3ZSByZXR1cm4ganVzdCB0aGUgdmFsdWVcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZSBhbiBgb2Zmc2V0YCBzdHJpbmcgdG8gZXh0cmFwb2xhdGUgYHhgIGFuZCBgeWAgbnVtZXJpYyBvZmZzZXRzLlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2Yge21vZGlmaWVyc35vZmZzZXR9XG4gKiBAcHJpdmF0ZVxuICogQGFyZ3VtZW50IHtTdHJpbmd9IG9mZnNldFxuICogQGFyZ3VtZW50IHtPYmplY3R9IHBvcHBlck9mZnNldHNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSByZWZlcmVuY2VPZmZzZXRzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gYmFzZVBsYWNlbWVudFxuICogQHJldHVybnMge0FycmF5fSBhIHR3byBjZWxscyBhcnJheSB3aXRoIHggYW5kIHkgb2Zmc2V0cyBpbiBudW1iZXJzXG4gKi9cbmZ1bmN0aW9uIHBhcnNlT2Zmc2V0KG9mZnNldCwgcG9wcGVyT2Zmc2V0cywgcmVmZXJlbmNlT2Zmc2V0cywgYmFzZVBsYWNlbWVudCkge1xuICB2YXIgb2Zmc2V0cyA9IFswLCAwXTtcblxuICAvLyBVc2UgaGVpZ2h0IGlmIHBsYWNlbWVudCBpcyBsZWZ0IG9yIHJpZ2h0IGFuZCBpbmRleCBpcyAwIG90aGVyd2lzZSB1c2Ugd2lkdGhcbiAgLy8gaW4gdGhpcyB3YXkgdGhlIGZpcnN0IG9mZnNldCB3aWxsIHVzZSBhbiBheGlzIGFuZCB0aGUgc2Vjb25kIG9uZVxuICAvLyB3aWxsIHVzZSB0aGUgb3RoZXIgb25lXG4gIHZhciB1c2VIZWlnaHQgPSBbJ3JpZ2h0JywgJ2xlZnQnXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpICE9PSAtMTtcblxuICAvLyBTcGxpdCB0aGUgb2Zmc2V0IHN0cmluZyB0byBvYnRhaW4gYSBsaXN0IG9mIHZhbHVlcyBhbmQgb3BlcmFuZHNcbiAgLy8gVGhlIHJlZ2V4IGFkZHJlc3NlcyB2YWx1ZXMgd2l0aCB0aGUgcGx1cyBvciBtaW51cyBzaWduIGluIGZyb250ICgrMTAsIC0yMCwgZXRjKVxuICB2YXIgZnJhZ21lbnRzID0gb2Zmc2V0LnNwbGl0KC8oXFwrfFxcLSkvKS5tYXAoZnVuY3Rpb24gKGZyYWcpIHtcbiAgICByZXR1cm4gZnJhZy50cmltKCk7XG4gIH0pO1xuXG4gIC8vIERldGVjdCBpZiB0aGUgb2Zmc2V0IHN0cmluZyBjb250YWlucyBhIHBhaXIgb2YgdmFsdWVzIG9yIGEgc2luZ2xlIG9uZVxuICAvLyB0aGV5IGNvdWxkIGJlIHNlcGFyYXRlZCBieSBjb21tYSBvciBzcGFjZVxuICB2YXIgZGl2aWRlciA9IGZyYWdtZW50cy5pbmRleE9mKGZpbmQoZnJhZ21lbnRzLCBmdW5jdGlvbiAoZnJhZykge1xuICAgIHJldHVybiBmcmFnLnNlYXJjaCgvLHxcXHMvKSAhPT0gLTE7XG4gIH0pKTtcblxuICBpZiAoZnJhZ21lbnRzW2RpdmlkZXJdICYmIGZyYWdtZW50c1tkaXZpZGVyXS5pbmRleE9mKCcsJykgPT09IC0xKSB7XG4gICAgY29uc29sZS53YXJuKCdPZmZzZXRzIHNlcGFyYXRlZCBieSB3aGl0ZSBzcGFjZShzKSBhcmUgZGVwcmVjYXRlZCwgdXNlIGEgY29tbWEgKCwpIGluc3RlYWQuJyk7XG4gIH1cblxuICAvLyBJZiBkaXZpZGVyIGlzIGZvdW5kLCB3ZSBkaXZpZGUgdGhlIGxpc3Qgb2YgdmFsdWVzIGFuZCBvcGVyYW5kcyB0byBkaXZpZGVcbiAgLy8gdGhlbSBieSBvZnNldCBYIGFuZCBZLlxuICB2YXIgc3BsaXRSZWdleCA9IC9cXHMqLFxccyp8XFxzKy87XG4gIHZhciBvcHMgPSBkaXZpZGVyICE9PSAtMSA/IFtmcmFnbWVudHMuc2xpY2UoMCwgZGl2aWRlcikuY29uY2F0KFtmcmFnbWVudHNbZGl2aWRlcl0uc3BsaXQoc3BsaXRSZWdleClbMF1dKSwgW2ZyYWdtZW50c1tkaXZpZGVyXS5zcGxpdChzcGxpdFJlZ2V4KVsxXV0uY29uY2F0KGZyYWdtZW50cy5zbGljZShkaXZpZGVyICsgMSkpXSA6IFtmcmFnbWVudHNdO1xuXG4gIC8vIENvbnZlcnQgdGhlIHZhbHVlcyB3aXRoIHVuaXRzIHRvIGFic29sdXRlIHBpeGVscyB0byBhbGxvdyBvdXIgY29tcHV0YXRpb25zXG4gIG9wcyA9IG9wcy5tYXAoZnVuY3Rpb24gKG9wLCBpbmRleCkge1xuICAgIC8vIE1vc3Qgb2YgdGhlIHVuaXRzIHJlbHkgb24gdGhlIG9yaWVudGF0aW9uIG9mIHRoZSBwb3BwZXJcbiAgICB2YXIgbWVhc3VyZW1lbnQgPSAoaW5kZXggPT09IDEgPyAhdXNlSGVpZ2h0IDogdXNlSGVpZ2h0KSA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgICB2YXIgbWVyZ2VXaXRoUHJldmlvdXMgPSBmYWxzZTtcbiAgICByZXR1cm4gb3BcbiAgICAvLyBUaGlzIGFnZ3JlZ2F0ZXMgYW55IGArYCBvciBgLWAgc2lnbiB0aGF0IGFyZW4ndCBjb25zaWRlcmVkIG9wZXJhdG9yc1xuICAgIC8vIGUuZy46IDEwICsgKzUgPT4gWzEwLCArLCArNV1cbiAgICAucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICBpZiAoYVthLmxlbmd0aCAtIDFdID09PSAnJyAmJiBbJysnLCAnLSddLmluZGV4T2YoYikgIT09IC0xKSB7XG4gICAgICAgIGFbYS5sZW5ndGggLSAxXSA9IGI7XG4gICAgICAgIG1lcmdlV2l0aFByZXZpb3VzID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9IGVsc2UgaWYgKG1lcmdlV2l0aFByZXZpb3VzKSB7XG4gICAgICAgIGFbYS5sZW5ndGggLSAxXSArPSBiO1xuICAgICAgICBtZXJnZVdpdGhQcmV2aW91cyA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBhLmNvbmNhdChiKTtcbiAgICAgIH1cbiAgICB9LCBbXSlcbiAgICAvLyBIZXJlIHdlIGNvbnZlcnQgdGhlIHN0cmluZyB2YWx1ZXMgaW50byBudW1iZXIgdmFsdWVzIChpbiBweClcbiAgICAubWFwKGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgIHJldHVybiB0b1ZhbHVlKHN0ciwgbWVhc3VyZW1lbnQsIHBvcHBlck9mZnNldHMsIHJlZmVyZW5jZU9mZnNldHMpO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBMb29wIHRyb3VnaCB0aGUgb2Zmc2V0cyBhcnJheXMgYW5kIGV4ZWN1dGUgdGhlIG9wZXJhdGlvbnNcbiAgb3BzLmZvckVhY2goZnVuY3Rpb24gKG9wLCBpbmRleCkge1xuICAgIG9wLmZvckVhY2goZnVuY3Rpb24gKGZyYWcsIGluZGV4Mikge1xuICAgICAgaWYgKGlzTnVtZXJpYyhmcmFnKSkge1xuICAgICAgICBvZmZzZXRzW2luZGV4XSArPSBmcmFnICogKG9wW2luZGV4MiAtIDFdID09PSAnLScgPyAtMSA6IDEpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIG9mZnNldHM7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQGFyZ3VtZW50IHtOdW1iZXJ8U3RyaW5nfSBvcHRpb25zLm9mZnNldD0wXG4gKiBUaGUgb2Zmc2V0IHZhbHVlIGFzIGRlc2NyaWJlZCBpbiB0aGUgbW9kaWZpZXIgZGVzY3JpcHRpb25cbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gb2Zmc2V0KGRhdGEsIF9yZWYpIHtcbiAgdmFyIG9mZnNldCA9IF9yZWYub2Zmc2V0O1xuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQsXG4gICAgICBfZGF0YSRvZmZzZXRzID0gZGF0YS5vZmZzZXRzLFxuICAgICAgcG9wcGVyID0gX2RhdGEkb2Zmc2V0cy5wb3BwZXIsXG4gICAgICByZWZlcmVuY2UgPSBfZGF0YSRvZmZzZXRzLnJlZmVyZW5jZTtcblxuICB2YXIgYmFzZVBsYWNlbWVudCA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuXG4gIHZhciBvZmZzZXRzID0gdm9pZCAwO1xuICBpZiAoaXNOdW1lcmljKCtvZmZzZXQpKSB7XG4gICAgb2Zmc2V0cyA9IFsrb2Zmc2V0LCAwXTtcbiAgfSBlbHNlIHtcbiAgICBvZmZzZXRzID0gcGFyc2VPZmZzZXQob2Zmc2V0LCBwb3BwZXIsIHJlZmVyZW5jZSwgYmFzZVBsYWNlbWVudCk7XG4gIH1cblxuICBpZiAoYmFzZVBsYWNlbWVudCA9PT0gJ2xlZnQnKSB7XG4gICAgcG9wcGVyLnRvcCArPSBvZmZzZXRzWzBdO1xuICAgIHBvcHBlci5sZWZ0IC09IG9mZnNldHNbMV07XG4gIH0gZWxzZSBpZiAoYmFzZVBsYWNlbWVudCA9PT0gJ3JpZ2h0Jykge1xuICAgIHBvcHBlci50b3AgKz0gb2Zmc2V0c1swXTtcbiAgICBwb3BwZXIubGVmdCArPSBvZmZzZXRzWzFdO1xuICB9IGVsc2UgaWYgKGJhc2VQbGFjZW1lbnQgPT09ICd0b3AnKSB7XG4gICAgcG9wcGVyLmxlZnQgKz0gb2Zmc2V0c1swXTtcbiAgICBwb3BwZXIudG9wIC09IG9mZnNldHNbMV07XG4gIH0gZWxzZSBpZiAoYmFzZVBsYWNlbWVudCA9PT0gJ2JvdHRvbScpIHtcbiAgICBwb3BwZXIubGVmdCArPSBvZmZzZXRzWzBdO1xuICAgIHBvcHBlci50b3AgKz0gb2Zmc2V0c1sxXTtcbiAgfVxuXG4gIGRhdGEucG9wcGVyID0gcG9wcGVyO1xuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gcHJldmVudE92ZXJmbG93KGRhdGEsIG9wdGlvbnMpIHtcbiAgdmFyIGJvdW5kYXJpZXNFbGVtZW50ID0gb3B0aW9ucy5ib3VuZGFyaWVzRWxlbWVudCB8fCBnZXRPZmZzZXRQYXJlbnQoZGF0YS5pbnN0YW5jZS5wb3BwZXIpO1xuXG4gIC8vIElmIG9mZnNldFBhcmVudCBpcyB0aGUgcmVmZXJlbmNlIGVsZW1lbnQsIHdlIHJlYWxseSB3YW50IHRvXG4gIC8vIGdvIG9uZSBzdGVwIHVwIGFuZCB1c2UgdGhlIG5leHQgb2Zmc2V0UGFyZW50IGFzIHJlZmVyZW5jZSB0b1xuICAvLyBhdm9pZCB0byBtYWtlIHRoaXMgbW9kaWZpZXIgY29tcGxldGVseSB1c2VsZXNzIGFuZCBsb29rIGxpa2UgYnJva2VuXG4gIGlmIChkYXRhLmluc3RhbmNlLnJlZmVyZW5jZSA9PT0gYm91bmRhcmllc0VsZW1lbnQpIHtcbiAgICBib3VuZGFyaWVzRWxlbWVudCA9IGdldE9mZnNldFBhcmVudChib3VuZGFyaWVzRWxlbWVudCk7XG4gIH1cblxuICAvLyBOT1RFOiBET00gYWNjZXNzIGhlcmVcbiAgLy8gcmVzZXRzIHRoZSBwb3BwZXIncyBwb3NpdGlvbiBzbyB0aGF0IHRoZSBkb2N1bWVudCBzaXplIGNhbiBiZSBjYWxjdWxhdGVkIGV4Y2x1ZGluZ1xuICAvLyB0aGUgc2l6ZSBvZiB0aGUgcG9wcGVyIGVsZW1lbnQgaXRzZWxmXG4gIHZhciB0cmFuc2Zvcm1Qcm9wID0gZ2V0U3VwcG9ydGVkUHJvcGVydHlOYW1lKCd0cmFuc2Zvcm0nKTtcbiAgdmFyIHBvcHBlclN0eWxlcyA9IGRhdGEuaW5zdGFuY2UucG9wcGVyLnN0eWxlOyAvLyBhc3NpZ25tZW50IHRvIGhlbHAgbWluaWZpY2F0aW9uXG4gIHZhciB0b3AgPSBwb3BwZXJTdHlsZXMudG9wLFxuICAgICAgbGVmdCA9IHBvcHBlclN0eWxlcy5sZWZ0LFxuICAgICAgdHJhbnNmb3JtID0gcG9wcGVyU3R5bGVzW3RyYW5zZm9ybVByb3BdO1xuXG4gIHBvcHBlclN0eWxlcy50b3AgPSAnJztcbiAgcG9wcGVyU3R5bGVzLmxlZnQgPSAnJztcbiAgcG9wcGVyU3R5bGVzW3RyYW5zZm9ybVByb3BdID0gJyc7XG5cbiAgdmFyIGJvdW5kYXJpZXMgPSBnZXRCb3VuZGFyaWVzKGRhdGEuaW5zdGFuY2UucG9wcGVyLCBkYXRhLmluc3RhbmNlLnJlZmVyZW5jZSwgb3B0aW9ucy5wYWRkaW5nLCBib3VuZGFyaWVzRWxlbWVudCwgZGF0YS5wb3NpdGlvbkZpeGVkKTtcblxuICAvLyBOT1RFOiBET00gYWNjZXNzIGhlcmVcbiAgLy8gcmVzdG9yZXMgdGhlIG9yaWdpbmFsIHN0eWxlIHByb3BlcnRpZXMgYWZ0ZXIgdGhlIG9mZnNldHMgaGF2ZSBiZWVuIGNvbXB1dGVkXG4gIHBvcHBlclN0eWxlcy50b3AgPSB0b3A7XG4gIHBvcHBlclN0eWxlcy5sZWZ0ID0gbGVmdDtcbiAgcG9wcGVyU3R5bGVzW3RyYW5zZm9ybVByb3BdID0gdHJhbnNmb3JtO1xuXG4gIG9wdGlvbnMuYm91bmRhcmllcyA9IGJvdW5kYXJpZXM7XG5cbiAgdmFyIG9yZGVyID0gb3B0aW9ucy5wcmlvcml0eTtcbiAgdmFyIHBvcHBlciA9IGRhdGEub2Zmc2V0cy5wb3BwZXI7XG5cbiAgdmFyIGNoZWNrID0ge1xuICAgIHByaW1hcnk6IGZ1bmN0aW9uIHByaW1hcnkocGxhY2VtZW50KSB7XG4gICAgICB2YXIgdmFsdWUgPSBwb3BwZXJbcGxhY2VtZW50XTtcbiAgICAgIGlmIChwb3BwZXJbcGxhY2VtZW50XSA8IGJvdW5kYXJpZXNbcGxhY2VtZW50XSAmJiAhb3B0aW9ucy5lc2NhcGVXaXRoUmVmZXJlbmNlKSB7XG4gICAgICAgIHZhbHVlID0gTWF0aC5tYXgocG9wcGVyW3BsYWNlbWVudF0sIGJvdW5kYXJpZXNbcGxhY2VtZW50XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVmaW5lUHJvcGVydHkoe30sIHBsYWNlbWVudCwgdmFsdWUpO1xuICAgIH0sXG4gICAgc2Vjb25kYXJ5OiBmdW5jdGlvbiBzZWNvbmRhcnkocGxhY2VtZW50KSB7XG4gICAgICB2YXIgbWFpblNpZGUgPSBwbGFjZW1lbnQgPT09ICdyaWdodCcgPyAnbGVmdCcgOiAndG9wJztcbiAgICAgIHZhciB2YWx1ZSA9IHBvcHBlclttYWluU2lkZV07XG4gICAgICBpZiAocG9wcGVyW3BsYWNlbWVudF0gPiBib3VuZGFyaWVzW3BsYWNlbWVudF0gJiYgIW9wdGlvbnMuZXNjYXBlV2l0aFJlZmVyZW5jZSkge1xuICAgICAgICB2YWx1ZSA9IE1hdGgubWluKHBvcHBlclttYWluU2lkZV0sIGJvdW5kYXJpZXNbcGxhY2VtZW50XSAtIChwbGFjZW1lbnQgPT09ICdyaWdodCcgPyBwb3BwZXIud2lkdGggOiBwb3BwZXIuaGVpZ2h0KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVmaW5lUHJvcGVydHkoe30sIG1haW5TaWRlLCB2YWx1ZSk7XG4gICAgfVxuICB9O1xuXG4gIG9yZGVyLmZvckVhY2goZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgIHZhciBzaWRlID0gWydsZWZ0JywgJ3RvcCddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTEgPyAncHJpbWFyeScgOiAnc2Vjb25kYXJ5JztcbiAgICBwb3BwZXIgPSBfZXh0ZW5kcyh7fSwgcG9wcGVyLCBjaGVja1tzaWRlXShwbGFjZW1lbnQpKTtcbiAgfSk7XG5cbiAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IHBvcHBlcjtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gc2hpZnQoZGF0YSkge1xuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQ7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIHZhciBzaGlmdHZhcmlhdGlvbiA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzFdO1xuXG4gIC8vIGlmIHNoaWZ0IHNoaWZ0dmFyaWF0aW9uIGlzIHNwZWNpZmllZCwgcnVuIHRoZSBtb2RpZmllclxuICBpZiAoc2hpZnR2YXJpYXRpb24pIHtcbiAgICB2YXIgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2UsXG4gICAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyO1xuXG4gICAgdmFyIGlzVmVydGljYWwgPSBbJ2JvdHRvbScsICd0b3AnXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpICE9PSAtMTtcbiAgICB2YXIgc2lkZSA9IGlzVmVydGljYWwgPyAnbGVmdCcgOiAndG9wJztcbiAgICB2YXIgbWVhc3VyZW1lbnQgPSBpc1ZlcnRpY2FsID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuXG4gICAgdmFyIHNoaWZ0T2Zmc2V0cyA9IHtcbiAgICAgIHN0YXJ0OiBkZWZpbmVQcm9wZXJ0eSh7fSwgc2lkZSwgcmVmZXJlbmNlW3NpZGVdKSxcbiAgICAgIGVuZDogZGVmaW5lUHJvcGVydHkoe30sIHNpZGUsIHJlZmVyZW5jZVtzaWRlXSArIHJlZmVyZW5jZVttZWFzdXJlbWVudF0gLSBwb3BwZXJbbWVhc3VyZW1lbnRdKVxuICAgIH07XG5cbiAgICBkYXRhLm9mZnNldHMucG9wcGVyID0gX2V4dGVuZHMoe30sIHBvcHBlciwgc2hpZnRPZmZzZXRzW3NoaWZ0dmFyaWF0aW9uXSk7XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGhpZGUoZGF0YSkge1xuICBpZiAoIWlzTW9kaWZpZXJSZXF1aXJlZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgJ2hpZGUnLCAncHJldmVudE92ZXJmbG93JykpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHZhciByZWZSZWN0ID0gZGF0YS5vZmZzZXRzLnJlZmVyZW5jZTtcbiAgdmFyIGJvdW5kID0gZmluZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgcmV0dXJuIG1vZGlmaWVyLm5hbWUgPT09ICdwcmV2ZW50T3ZlcmZsb3cnO1xuICB9KS5ib3VuZGFyaWVzO1xuXG4gIGlmIChyZWZSZWN0LmJvdHRvbSA8IGJvdW5kLnRvcCB8fCByZWZSZWN0LmxlZnQgPiBib3VuZC5yaWdodCB8fCByZWZSZWN0LnRvcCA+IGJvdW5kLmJvdHRvbSB8fCByZWZSZWN0LnJpZ2h0IDwgYm91bmQubGVmdCkge1xuICAgIC8vIEF2b2lkIHVubmVjZXNzYXJ5IERPTSBhY2Nlc3MgaWYgdmlzaWJpbGl0eSBoYXNuJ3QgY2hhbmdlZFxuICAgIGlmIChkYXRhLmhpZGUgPT09IHRydWUpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIGRhdGEuaGlkZSA9IHRydWU7XG4gICAgZGF0YS5hdHRyaWJ1dGVzWyd4LW91dC1vZi1ib3VuZGFyaWVzJ10gPSAnJztcbiAgfSBlbHNlIHtcbiAgICAvLyBBdm9pZCB1bm5lY2Vzc2FyeSBET00gYWNjZXNzIGlmIHZpc2liaWxpdHkgaGFzbid0IGNoYW5nZWRcbiAgICBpZiAoZGF0YS5oaWRlID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgZGF0YS5oaWRlID0gZmFsc2U7XG4gICAgZGF0YS5hdHRyaWJ1dGVzWyd4LW91dC1vZi1ib3VuZGFyaWVzJ10gPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBpbm5lcihkYXRhKSB7XG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudDtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgdmFyIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlO1xuXG4gIHZhciBpc0hvcml6ID0gWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihiYXNlUGxhY2VtZW50KSAhPT0gLTE7XG5cbiAgdmFyIHN1YnRyYWN0TGVuZ3RoID0gWyd0b3AnLCAnbGVmdCddLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPT09IC0xO1xuXG4gIHBvcHBlcltpc0hvcml6ID8gJ2xlZnQnIDogJ3RvcCddID0gcmVmZXJlbmNlW2Jhc2VQbGFjZW1lbnRdIC0gKHN1YnRyYWN0TGVuZ3RoID8gcG9wcGVyW2lzSG9yaXogPyAnd2lkdGgnIDogJ2hlaWdodCddIDogMCk7XG5cbiAgZGF0YS5wbGFjZW1lbnQgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICBkYXRhLm9mZnNldHMucG9wcGVyID0gZ2V0Q2xpZW50UmVjdChwb3BwZXIpO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIE1vZGlmaWVyIGZ1bmN0aW9uLCBlYWNoIG1vZGlmaWVyIGNhbiBoYXZlIGEgZnVuY3Rpb24gb2YgdGhpcyB0eXBlIGFzc2lnbmVkXG4gKiB0byBpdHMgYGZuYCBwcm9wZXJ0eS48YnIgLz5cbiAqIFRoZXNlIGZ1bmN0aW9ucyB3aWxsIGJlIGNhbGxlZCBvbiBlYWNoIHVwZGF0ZSwgdGhpcyBtZWFucyB0aGF0IHlvdSBtdXN0XG4gKiBtYWtlIHN1cmUgdGhleSBhcmUgcGVyZm9ybWFudCBlbm91Z2ggdG8gYXZvaWQgcGVyZm9ybWFuY2UgYm90dGxlbmVja3MuXG4gKlxuICogQGZ1bmN0aW9uIE1vZGlmaWVyRm5cbiAqIEBhcmd1bWVudCB7ZGF0YU9iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7ZGF0YU9iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5cbi8qKlxuICogTW9kaWZpZXJzIGFyZSBwbHVnaW5zIHVzZWQgdG8gYWx0ZXIgdGhlIGJlaGF2aW9yIG9mIHlvdXIgcG9wcGVycy48YnIgLz5cbiAqIFBvcHBlci5qcyB1c2VzIGEgc2V0IG9mIDkgbW9kaWZpZXJzIHRvIHByb3ZpZGUgYWxsIHRoZSBiYXNpYyBmdW5jdGlvbmFsaXRpZXNcbiAqIG5lZWRlZCBieSB0aGUgbGlicmFyeS5cbiAqXG4gKiBVc3VhbGx5IHlvdSBkb24ndCB3YW50IHRvIG92ZXJyaWRlIHRoZSBgb3JkZXJgLCBgZm5gIGFuZCBgb25Mb2FkYCBwcm9wcy5cbiAqIEFsbCB0aGUgb3RoZXIgcHJvcGVydGllcyBhcmUgY29uZmlndXJhdGlvbnMgdGhhdCBjb3VsZCBiZSB0d2Vha2VkLlxuICogQG5hbWVzcGFjZSBtb2RpZmllcnNcbiAqL1xudmFyIG1vZGlmaWVycyA9IHtcbiAgLyoqXG4gICAqIE1vZGlmaWVyIHVzZWQgdG8gc2hpZnQgdGhlIHBvcHBlciBvbiB0aGUgc3RhcnQgb3IgZW5kIG9mIGl0cyByZWZlcmVuY2VcbiAgICogZWxlbWVudC48YnIgLz5cbiAgICogSXQgd2lsbCByZWFkIHRoZSB2YXJpYXRpb24gb2YgdGhlIGBwbGFjZW1lbnRgIHByb3BlcnR5LjxiciAvPlxuICAgKiBJdCBjYW4gYmUgb25lIGVpdGhlciBgLWVuZGAgb3IgYC1zdGFydGAuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBzaGlmdDoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj0xMDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDEwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IHNoaWZ0XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoZSBgb2Zmc2V0YCBtb2RpZmllciBjYW4gc2hpZnQgeW91ciBwb3BwZXIgb24gYm90aCBpdHMgYXhpcy5cbiAgICpcbiAgICogSXQgYWNjZXB0cyB0aGUgZm9sbG93aW5nIHVuaXRzOlxuICAgKiAtIGBweGAgb3IgdW5pdGxlc3MsIGludGVycHJldGVkIGFzIHBpeGVsc1xuICAgKiAtIGAlYCBvciBgJXJgLCBwZXJjZW50YWdlIHJlbGF0aXZlIHRvIHRoZSBsZW5ndGggb2YgdGhlIHJlZmVyZW5jZSBlbGVtZW50XG4gICAqIC0gYCVwYCwgcGVyY2VudGFnZSByZWxhdGl2ZSB0byB0aGUgbGVuZ3RoIG9mIHRoZSBwb3BwZXIgZWxlbWVudFxuICAgKiAtIGB2d2AsIENTUyB2aWV3cG9ydCB3aWR0aCB1bml0XG4gICAqIC0gYHZoYCwgQ1NTIHZpZXdwb3J0IGhlaWdodCB1bml0XG4gICAqXG4gICAqIEZvciBsZW5ndGggaXMgaW50ZW5kZWQgdGhlIG1haW4gYXhpcyByZWxhdGl2ZSB0byB0aGUgcGxhY2VtZW50IG9mIHRoZSBwb3BwZXIuPGJyIC8+XG4gICAqIFRoaXMgbWVhbnMgdGhhdCBpZiB0aGUgcGxhY2VtZW50IGlzIGB0b3BgIG9yIGBib3R0b21gLCB0aGUgbGVuZ3RoIHdpbGwgYmUgdGhlXG4gICAqIGB3aWR0aGAuIEluIGNhc2Ugb2YgYGxlZnRgIG9yIGByaWdodGAsIGl0IHdpbGwgYmUgdGhlIGhlaWdodC5cbiAgICpcbiAgICogWW91IGNhbiBwcm92aWRlIGEgc2luZ2xlIHZhbHVlIChhcyBgTnVtYmVyYCBvciBgU3RyaW5nYCksIG9yIGEgcGFpciBvZiB2YWx1ZXNcbiAgICogYXMgYFN0cmluZ2AgZGl2aWRlZCBieSBhIGNvbW1hIG9yIG9uZSAob3IgbW9yZSkgd2hpdGUgc3BhY2VzLjxiciAvPlxuICAgKiBUaGUgbGF0dGVyIGlzIGEgZGVwcmVjYXRlZCBtZXRob2QgYmVjYXVzZSBpdCBsZWFkcyB0byBjb25mdXNpb24gYW5kIHdpbGwgYmVcbiAgICogcmVtb3ZlZCBpbiB2Mi48YnIgLz5cbiAgICogQWRkaXRpb25hbGx5LCBpdCBhY2NlcHRzIGFkZGl0aW9ucyBhbmQgc3VidHJhY3Rpb25zIGJldHdlZW4gZGlmZmVyZW50IHVuaXRzLlxuICAgKiBOb3RlIHRoYXQgbXVsdGlwbGljYXRpb25zIGFuZCBkaXZpc2lvbnMgYXJlbid0IHN1cHBvcnRlZC5cbiAgICpcbiAgICogVmFsaWQgZXhhbXBsZXMgYXJlOlxuICAgKiBgYGBcbiAgICogMTBcbiAgICogJzEwJSdcbiAgICogJzEwLCAxMCdcbiAgICogJzEwJSwgMTAnXG4gICAqICcxMCArIDEwJSdcbiAgICogJzEwIC0gNXZoICsgMyUnXG4gICAqICctMTBweCArIDV2aCwgNXB4IC0gNiUnXG4gICAqIGBgYFxuICAgKiA+ICoqTkIqKjogSWYgeW91IGRlc2lyZSB0byBhcHBseSBvZmZzZXRzIHRvIHlvdXIgcG9wcGVycyBpbiBhIHdheSB0aGF0IG1heSBtYWtlIHRoZW0gb3ZlcmxhcFxuICAgKiA+IHdpdGggdGhlaXIgcmVmZXJlbmNlIGVsZW1lbnQsIHVuZm9ydHVuYXRlbHksIHlvdSB3aWxsIGhhdmUgdG8gZGlzYWJsZSB0aGUgYGZsaXBgIG1vZGlmaWVyLlxuICAgKiA+IE1vcmUgb24gdGhpcyBbcmVhZGluZyB0aGlzIGlzc3VlXShodHRwczovL2dpdGh1Yi5jb20vRmV6VnJhc3RhL3BvcHBlci5qcy9pc3N1ZXMvMzczKVxuICAgKlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgb2Zmc2V0OiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTIwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogMjAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogb2Zmc2V0LFxuICAgIC8qKiBAcHJvcCB7TnVtYmVyfFN0cmluZ30gb2Zmc2V0PTBcbiAgICAgKiBUaGUgb2Zmc2V0IHZhbHVlIGFzIGRlc2NyaWJlZCBpbiB0aGUgbW9kaWZpZXIgZGVzY3JpcHRpb25cbiAgICAgKi9cbiAgICBvZmZzZXQ6IDBcbiAgfSxcblxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBwcmV2ZW50IHRoZSBwb3BwZXIgZnJvbSBiZWluZyBwb3NpdGlvbmVkIG91dHNpZGUgdGhlIGJvdW5kYXJ5LlxuICAgKlxuICAgKiBBbiBzY2VuYXJpbyBleGlzdHMgd2hlcmUgdGhlIHJlZmVyZW5jZSBpdHNlbGYgaXMgbm90IHdpdGhpbiB0aGUgYm91bmRhcmllcy48YnIgLz5cbiAgICogV2UgY2FuIHNheSBpdCBoYXMgXCJlc2NhcGVkIHRoZSBib3VuZGFyaWVzXCIg4oCUIG9yIGp1c3QgXCJlc2NhcGVkXCIuPGJyIC8+XG4gICAqIEluIHRoaXMgY2FzZSB3ZSBuZWVkIHRvIGRlY2lkZSB3aGV0aGVyIHRoZSBwb3BwZXIgc2hvdWxkIGVpdGhlcjpcbiAgICpcbiAgICogLSBkZXRhY2ggZnJvbSB0aGUgcmVmZXJlbmNlIGFuZCByZW1haW4gXCJ0cmFwcGVkXCIgaW4gdGhlIGJvdW5kYXJpZXMsIG9yXG4gICAqIC0gaWYgaXQgc2hvdWxkIGlnbm9yZSB0aGUgYm91bmRhcnkgYW5kIFwiZXNjYXBlIHdpdGggaXRzIHJlZmVyZW5jZVwiXG4gICAqXG4gICAqIFdoZW4gYGVzY2FwZVdpdGhSZWZlcmVuY2VgIGlzIHNldCB0b2B0cnVlYCBhbmQgcmVmZXJlbmNlIGlzIGNvbXBsZXRlbHlcbiAgICogb3V0c2lkZSBpdHMgYm91bmRhcmllcywgdGhlIHBvcHBlciB3aWxsIG92ZXJmbG93IChvciBjb21wbGV0ZWx5IGxlYXZlKVxuICAgKiB0aGUgYm91bmRhcmllcyBpbiBvcmRlciB0byByZW1haW4gYXR0YWNoZWQgdG8gdGhlIGVkZ2Ugb2YgdGhlIHJlZmVyZW5jZS5cbiAgICpcbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIHByZXZlbnRPdmVyZmxvdzoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj0zMDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDMwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IHByZXZlbnRPdmVyZmxvdyxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7QXJyYXl9IFtwcmlvcml0eT1bJ2xlZnQnLCdyaWdodCcsJ3RvcCcsJ2JvdHRvbSddXVxuICAgICAqIFBvcHBlciB3aWxsIHRyeSB0byBwcmV2ZW50IG92ZXJmbG93IGZvbGxvd2luZyB0aGVzZSBwcmlvcml0aWVzIGJ5IGRlZmF1bHQsXG4gICAgICogdGhlbiwgaXQgY291bGQgb3ZlcmZsb3cgb24gdGhlIGxlZnQgYW5kIG9uIHRvcCBvZiB0aGUgYGJvdW5kYXJpZXNFbGVtZW50YFxuICAgICAqL1xuICAgIHByaW9yaXR5OiBbJ2xlZnQnLCAncmlnaHQnLCAndG9wJywgJ2JvdHRvbSddLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtudW1iZXJ9IHBhZGRpbmc9NVxuICAgICAqIEFtb3VudCBvZiBwaXhlbCB1c2VkIHRvIGRlZmluZSBhIG1pbmltdW0gZGlzdGFuY2UgYmV0d2VlbiB0aGUgYm91bmRhcmllc1xuICAgICAqIGFuZCB0aGUgcG9wcGVyIHRoaXMgbWFrZXMgc3VyZSB0aGUgcG9wcGVyIGhhcyBhbHdheXMgYSBsaXR0bGUgcGFkZGluZ1xuICAgICAqIGJldHdlZW4gdGhlIGVkZ2VzIG9mIGl0cyBjb250YWluZXJcbiAgICAgKi9cbiAgICBwYWRkaW5nOiA1LFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtTdHJpbmd8SFRNTEVsZW1lbnR9IGJvdW5kYXJpZXNFbGVtZW50PSdzY3JvbGxQYXJlbnQnXG4gICAgICogQm91bmRhcmllcyB1c2VkIGJ5IHRoZSBtb2RpZmllciwgY2FuIGJlIGBzY3JvbGxQYXJlbnRgLCBgd2luZG93YCxcbiAgICAgKiBgdmlld3BvcnRgIG9yIGFueSBET00gZWxlbWVudC5cbiAgICAgKi9cbiAgICBib3VuZGFyaWVzRWxlbWVudDogJ3Njcm9sbFBhcmVudCdcbiAgfSxcblxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBtYWtlIHN1cmUgdGhlIHJlZmVyZW5jZSBhbmQgaXRzIHBvcHBlciBzdGF5IG5lYXIgZWFjaG90aGVyc1xuICAgKiB3aXRob3V0IGxlYXZpbmcgYW55IGdhcCBiZXR3ZWVuIHRoZSB0d28uIEV4cGVjaWFsbHkgdXNlZnVsIHdoZW4gdGhlIGFycm93IGlzXG4gICAqIGVuYWJsZWQgYW5kIHlvdSB3YW50IHRvIGFzc3VyZSBpdCB0byBwb2ludCB0byBpdHMgcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqIEl0IGNhcmVzIG9ubHkgYWJvdXQgdGhlIGZpcnN0IGF4aXMsIHlvdSBjYW4gc3RpbGwgaGF2ZSBwb3BwZXJzIHdpdGggbWFyZ2luXG4gICAqIGJldHdlZW4gdGhlIHBvcHBlciBhbmQgaXRzIHJlZmVyZW5jZSBlbGVtZW50LlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAga2VlcFRvZ2V0aGVyOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTQwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogNDAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjoga2VlcFRvZ2V0aGVyXG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoaXMgbW9kaWZpZXIgaXMgdXNlZCB0byBtb3ZlIHRoZSBgYXJyb3dFbGVtZW50YCBvZiB0aGUgcG9wcGVyIHRvIG1ha2VcbiAgICogc3VyZSBpdCBpcyBwb3NpdGlvbmVkIGJldHdlZW4gdGhlIHJlZmVyZW5jZSBlbGVtZW50IGFuZCBpdHMgcG9wcGVyIGVsZW1lbnQuXG4gICAqIEl0IHdpbGwgcmVhZCB0aGUgb3V0ZXIgc2l6ZSBvZiB0aGUgYGFycm93RWxlbWVudGAgbm9kZSB0byBkZXRlY3QgaG93IG1hbnlcbiAgICogcGl4ZWxzIG9mIGNvbmp1Y3Rpb24gYXJlIG5lZWRlZC5cbiAgICpcbiAgICogSXQgaGFzIG5vIGVmZmVjdCBpZiBubyBgYXJyb3dFbGVtZW50YCBpcyBwcm92aWRlZC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGFycm93OiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTUwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogNTAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogYXJyb3csXG4gICAgLyoqIEBwcm9wIHtTdHJpbmd8SFRNTEVsZW1lbnR9IGVsZW1lbnQ9J1t4LWFycm93XScgLSBTZWxlY3RvciBvciBub2RlIHVzZWQgYXMgYXJyb3cgKi9cbiAgICBlbGVtZW50OiAnW3gtYXJyb3ddJ1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIGZsaXAgdGhlIHBvcHBlcidzIHBsYWNlbWVudCB3aGVuIGl0IHN0YXJ0cyB0byBvdmVybGFwIGl0c1xuICAgKiByZWZlcmVuY2UgZWxlbWVudC5cbiAgICpcbiAgICogUmVxdWlyZXMgdGhlIGBwcmV2ZW50T3ZlcmZsb3dgIG1vZGlmaWVyIGJlZm9yZSBpdCBpbiBvcmRlciB0byB3b3JrLlxuICAgKlxuICAgKiAqKk5PVEU6KiogdGhpcyBtb2RpZmllciB3aWxsIGludGVycnVwdCB0aGUgY3VycmVudCB1cGRhdGUgY3ljbGUgYW5kIHdpbGxcbiAgICogcmVzdGFydCBpdCBpZiBpdCBkZXRlY3RzIHRoZSBuZWVkIHRvIGZsaXAgdGhlIHBsYWNlbWVudC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGZsaXA6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9NjAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA2MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBmbGlwLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtTdHJpbmd8QXJyYXl9IGJlaGF2aW9yPSdmbGlwJ1xuICAgICAqIFRoZSBiZWhhdmlvciB1c2VkIHRvIGNoYW5nZSB0aGUgcG9wcGVyJ3MgcGxhY2VtZW50LiBJdCBjYW4gYmUgb25lIG9mXG4gICAgICogYGZsaXBgLCBgY2xvY2t3aXNlYCwgYGNvdW50ZXJjbG9ja3dpc2VgIG9yIGFuIGFycmF5IHdpdGggYSBsaXN0IG9mIHZhbGlkXG4gICAgICogcGxhY2VtZW50cyAod2l0aCBvcHRpb25hbCB2YXJpYXRpb25zKS5cbiAgICAgKi9cbiAgICBiZWhhdmlvcjogJ2ZsaXAnLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtudW1iZXJ9IHBhZGRpbmc9NVxuICAgICAqIFRoZSBwb3BwZXIgd2lsbCBmbGlwIGlmIGl0IGhpdHMgdGhlIGVkZ2VzIG9mIHRoZSBgYm91bmRhcmllc0VsZW1lbnRgXG4gICAgICovXG4gICAgcGFkZGluZzogNSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7U3RyaW5nfEhUTUxFbGVtZW50fSBib3VuZGFyaWVzRWxlbWVudD0ndmlld3BvcnQnXG4gICAgICogVGhlIGVsZW1lbnQgd2hpY2ggd2lsbCBkZWZpbmUgdGhlIGJvdW5kYXJpZXMgb2YgdGhlIHBvcHBlciBwb3NpdGlvbixcbiAgICAgKiB0aGUgcG9wcGVyIHdpbGwgbmV2ZXIgYmUgcGxhY2VkIG91dHNpZGUgb2YgdGhlIGRlZmluZWQgYm91bmRhcmllc1xuICAgICAqIChleGNlcHQgaWYga2VlcFRvZ2V0aGVyIGlzIGVuYWJsZWQpXG4gICAgICovXG4gICAgYm91bmRhcmllc0VsZW1lbnQ6ICd2aWV3cG9ydCdcbiAgfSxcblxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBtYWtlIHRoZSBwb3BwZXIgZmxvdyB0b3dhcmQgdGhlIGlubmVyIG9mIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAgICogQnkgZGVmYXVsdCwgd2hlbiB0aGlzIG1vZGlmaWVyIGlzIGRpc2FibGVkLCB0aGUgcG9wcGVyIHdpbGwgYmUgcGxhY2VkIG91dHNpZGVcbiAgICogdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgaW5uZXI6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9NzAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA3MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPWZhbHNlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGlubmVyXG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vZGlmaWVyIHVzZWQgdG8gaGlkZSB0aGUgcG9wcGVyIHdoZW4gaXRzIHJlZmVyZW5jZSBlbGVtZW50IGlzIG91dHNpZGUgb2YgdGhlXG4gICAqIHBvcHBlciBib3VuZGFyaWVzLiBJdCB3aWxsIHNldCBhIGB4LW91dC1vZi1ib3VuZGFyaWVzYCBhdHRyaWJ1dGUgd2hpY2ggY2FuXG4gICAqIGJlIHVzZWQgdG8gaGlkZSB3aXRoIGEgQ1NTIHNlbGVjdG9yIHRoZSBwb3BwZXIgd2hlbiBpdHMgcmVmZXJlbmNlIGlzXG4gICAqIG91dCBvZiBib3VuZGFyaWVzLlxuICAgKlxuICAgKiBSZXF1aXJlcyB0aGUgYHByZXZlbnRPdmVyZmxvd2AgbW9kaWZpZXIgYmVmb3JlIGl0IGluIG9yZGVyIHRvIHdvcmsuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBoaWRlOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTgwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogODAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogaGlkZVxuICB9LFxuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGUgc3R5bGUgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlciBlbGVtZW50IHRvIGdldHNcbiAgICogcHJvcGVybHkgcG9zaXRpb25lZC5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoaXMgbW9kaWZpZXIgd2lsbCBub3QgdG91Y2ggdGhlIERPTSwgaXQganVzdCBwcmVwYXJlcyB0aGUgc3R5bGVzXG4gICAqIHNvIHRoYXQgYGFwcGx5U3R5bGVgIG1vZGlmaWVyIGNhbiBhcHBseSBpdC4gVGhpcyBzZXBhcmF0aW9uIGlzIHVzZWZ1bFxuICAgKiBpbiBjYXNlIHlvdSBuZWVkIHRvIHJlcGxhY2UgYGFwcGx5U3R5bGVgIHdpdGggYSBjdXN0b20gaW1wbGVtZW50YXRpb24uXG4gICAqXG4gICAqIFRoaXMgbW9kaWZpZXIgaGFzIGA4NTBgIGFzIGBvcmRlcmAgdmFsdWUgdG8gbWFpbnRhaW4gYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgKiB3aXRoIHByZXZpb3VzIHZlcnNpb25zIG9mIFBvcHBlci5qcy4gRXhwZWN0IHRoZSBtb2RpZmllcnMgb3JkZXJpbmcgbWV0aG9kXG4gICAqIHRvIGNoYW5nZSBpbiBmdXR1cmUgbWFqb3IgdmVyc2lvbnMgb2YgdGhlIGxpYnJhcnkuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBjb21wdXRlU3R5bGU6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9ODUwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA4NTAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBjb21wdXRlU3R5bGUsXG4gICAgLyoqXG4gICAgICogQHByb3Age0Jvb2xlYW59IGdwdUFjY2VsZXJhdGlvbj10cnVlXG4gICAgICogSWYgdHJ1ZSwgaXQgdXNlcyB0aGUgQ1NTIDNkIHRyYW5zZm9ybWF0aW9uIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXIuXG4gICAgICogT3RoZXJ3aXNlLCBpdCB3aWxsIHVzZSB0aGUgYHRvcGAgYW5kIGBsZWZ0YCBwcm9wZXJ0aWVzLlxuICAgICAqL1xuICAgIGdwdUFjY2VsZXJhdGlvbjogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7c3RyaW5nfSBbeD0nYm90dG9tJ11cbiAgICAgKiBXaGVyZSB0byBhbmNob3IgdGhlIFggYXhpcyAoYGJvdHRvbWAgb3IgYHRvcGApLiBBS0EgWCBvZmZzZXQgb3JpZ2luLlxuICAgICAqIENoYW5nZSB0aGlzIGlmIHlvdXIgcG9wcGVyIHNob3VsZCBncm93IGluIGEgZGlyZWN0aW9uIGRpZmZlcmVudCBmcm9tIGBib3R0b21gXG4gICAgICovXG4gICAgeDogJ2JvdHRvbScsXG4gICAgLyoqXG4gICAgICogQHByb3Age3N0cmluZ30gW3g9J2xlZnQnXVxuICAgICAqIFdoZXJlIHRvIGFuY2hvciB0aGUgWSBheGlzIChgbGVmdGAgb3IgYHJpZ2h0YCkuIEFLQSBZIG9mZnNldCBvcmlnaW4uXG4gICAgICogQ2hhbmdlIHRoaXMgaWYgeW91ciBwb3BwZXIgc2hvdWxkIGdyb3cgaW4gYSBkaXJlY3Rpb24gZGlmZmVyZW50IGZyb20gYHJpZ2h0YFxuICAgICAqL1xuICAgIHk6ICdyaWdodCdcbiAgfSxcblxuICAvKipcbiAgICogQXBwbGllcyB0aGUgY29tcHV0ZWQgc3R5bGVzIHRvIHRoZSBwb3BwZXIgZWxlbWVudC5cbiAgICpcbiAgICogQWxsIHRoZSBET00gbWFuaXB1bGF0aW9ucyBhcmUgbGltaXRlZCB0byB0aGlzIG1vZGlmaWVyLiBUaGlzIGlzIHVzZWZ1bCBpbiBjYXNlXG4gICAqIHlvdSB3YW50IHRvIGludGVncmF0ZSBQb3BwZXIuanMgaW5zaWRlIGEgZnJhbWV3b3JrIG9yIHZpZXcgbGlicmFyeSBhbmQgeW91XG4gICAqIHdhbnQgdG8gZGVsZWdhdGUgYWxsIHRoZSBET00gbWFuaXB1bGF0aW9ucyB0byBpdC5cbiAgICpcbiAgICogTm90ZSB0aGF0IGlmIHlvdSBkaXNhYmxlIHRoaXMgbW9kaWZpZXIsIHlvdSBtdXN0IG1ha2Ugc3VyZSB0aGUgcG9wcGVyIGVsZW1lbnRcbiAgICogaGFzIGl0cyBwb3NpdGlvbiBzZXQgdG8gYGFic29sdXRlYCBiZWZvcmUgUG9wcGVyLmpzIGNhbiBkbyBpdHMgd29yayFcbiAgICpcbiAgICogSnVzdCBkaXNhYmxlIHRoaXMgbW9kaWZpZXIgYW5kIGRlZmluZSB5b3Ugb3duIHRvIGFjaGlldmUgdGhlIGRlc2lyZWQgZWZmZWN0LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgYXBwbHlTdHlsZToge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj05MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDkwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGFwcGx5U3R5bGUsXG4gICAgLyoqIEBwcm9wIHtGdW5jdGlvbn0gKi9cbiAgICBvbkxvYWQ6IGFwcGx5U3R5bGVPbkxvYWQsXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAxLjEwLjAsIHRoZSBwcm9wZXJ0eSBtb3ZlZCB0byBgY29tcHV0ZVN0eWxlYCBtb2RpZmllclxuICAgICAqIEBwcm9wIHtCb29sZWFufSBncHVBY2NlbGVyYXRpb249dHJ1ZVxuICAgICAqIElmIHRydWUsIGl0IHVzZXMgdGhlIENTUyAzZCB0cmFuc2Zvcm1hdGlvbiB0byBwb3NpdGlvbiB0aGUgcG9wcGVyLlxuICAgICAqIE90aGVyd2lzZSwgaXQgd2lsbCB1c2UgdGhlIGB0b3BgIGFuZCBgbGVmdGAgcHJvcGVydGllcy5cbiAgICAgKi9cbiAgICBncHVBY2NlbGVyYXRpb246IHVuZGVmaW5lZFxuICB9XG59O1xuXG4vKipcbiAqIFRoZSBgZGF0YU9iamVjdGAgaXMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBpbmZvcm1hdGlvbnMgdXNlZCBieSBQb3BwZXIuanNcbiAqIHRoaXMgb2JqZWN0IGdldCBwYXNzZWQgdG8gbW9kaWZpZXJzIGFuZCB0byB0aGUgYG9uQ3JlYXRlYCBhbmQgYG9uVXBkYXRlYCBjYWxsYmFja3MuXG4gKiBAbmFtZSBkYXRhT2JqZWN0XG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5pbnN0YW5jZSBUaGUgUG9wcGVyLmpzIGluc3RhbmNlXG4gKiBAcHJvcGVydHkge1N0cmluZ30gZGF0YS5wbGFjZW1lbnQgUGxhY2VtZW50IGFwcGxpZWQgdG8gcG9wcGVyXG4gKiBAcHJvcGVydHkge1N0cmluZ30gZGF0YS5vcmlnaW5hbFBsYWNlbWVudCBQbGFjZW1lbnQgb3JpZ2luYWxseSBkZWZpbmVkIG9uIGluaXRcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZGF0YS5mbGlwcGVkIFRydWUgaWYgcG9wcGVyIGhhcyBiZWVuIGZsaXBwZWQgYnkgZmxpcCBtb2RpZmllclxuICogQHByb3BlcnR5IHtCb29sZWFufSBkYXRhLmhpZGUgVHJ1ZSBpZiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgaXMgb3V0IG9mIGJvdW5kYXJpZXMsIHVzZWZ1bCB0byBrbm93IHdoZW4gdG8gaGlkZSB0aGUgcG9wcGVyLlxuICogQHByb3BlcnR5IHtIVE1MRWxlbWVudH0gZGF0YS5hcnJvd0VsZW1lbnQgTm9kZSB1c2VkIGFzIGFycm93IGJ5IGFycm93IG1vZGlmaWVyXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5zdHlsZXMgQW55IENTUyBwcm9wZXJ0eSBkZWZpbmVkIGhlcmUgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIsIGl0IGV4cGVjdHMgdGhlIEphdmFTY3JpcHQgbm9tZW5jbGF0dXJlIChlZy4gYG1hcmdpbkJvdHRvbWApXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5hcnJvd1N0eWxlcyBBbnkgQ1NTIHByb3BlcnR5IGRlZmluZWQgaGVyZSB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlciBhcnJvdywgaXQgZXhwZWN0cyB0aGUgSmF2YVNjcmlwdCBub21lbmNsYXR1cmUgKGVnLiBgbWFyZ2luQm90dG9tYClcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLmJvdW5kYXJpZXMgT2Zmc2V0cyBvZiB0aGUgcG9wcGVyIGJvdW5kYXJpZXNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLm9mZnNldHMgVGhlIG1lYXN1cmVtZW50cyBvZiBwb3BwZXIsIHJlZmVyZW5jZSBhbmQgYXJyb3cgZWxlbWVudHMuXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5vZmZzZXRzLnBvcHBlciBgdG9wYCwgYGxlZnRgLCBgd2lkdGhgLCBgaGVpZ2h0YCB2YWx1ZXNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLm9mZnNldHMucmVmZXJlbmNlIGB0b3BgLCBgbGVmdGAsIGB3aWR0aGAsIGBoZWlnaHRgIHZhbHVlc1xuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEub2Zmc2V0cy5hcnJvd10gYHRvcGAgYW5kIGBsZWZ0YCBvZmZzZXRzLCBvbmx5IG9uZSBvZiB0aGVtIHdpbGwgYmUgZGlmZmVyZW50IGZyb20gMFxuICovXG5cbi8qKlxuICogRGVmYXVsdCBvcHRpb25zIHByb3ZpZGVkIHRvIFBvcHBlci5qcyBjb25zdHJ1Y3Rvci48YnIgLz5cbiAqIFRoZXNlIGNhbiBiZSBvdmVycmlkZW4gdXNpbmcgdGhlIGBvcHRpb25zYCBhcmd1bWVudCBvZiBQb3BwZXIuanMuPGJyIC8+XG4gKiBUbyBvdmVycmlkZSBhbiBvcHRpb24sIHNpbXBseSBwYXNzIGFzIDNyZCBhcmd1bWVudCBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZVxuICogc3RydWN0dXJlIG9mIHRoaXMgb2JqZWN0LCBleGFtcGxlOlxuICogYGBgXG4gKiBuZXcgUG9wcGVyKHJlZiwgcG9wLCB7XG4gKiAgIG1vZGlmaWVyczoge1xuICogICAgIHByZXZlbnRPdmVyZmxvdzogeyBlbmFibGVkOiBmYWxzZSB9XG4gKiAgIH1cbiAqIH0pXG4gKiBgYGBcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbnZhciBEZWZhdWx0cyA9IHtcbiAgLyoqXG4gICAqIFBvcHBlcidzIHBsYWNlbWVudFxuICAgKiBAcHJvcCB7UG9wcGVyLnBsYWNlbWVudHN9IHBsYWNlbWVudD0nYm90dG9tJ1xuICAgKi9cbiAgcGxhY2VtZW50OiAnYm90dG9tJyxcblxuICAvKipcbiAgICogU2V0IHRoaXMgdG8gdHJ1ZSBpZiB5b3Ugd2FudCBwb3BwZXIgdG8gcG9zaXRpb24gaXQgc2VsZiBpbiAnZml4ZWQnIG1vZGVcbiAgICogQHByb3Age0Jvb2xlYW59IHBvc2l0aW9uRml4ZWQ9ZmFsc2VcbiAgICovXG4gIHBvc2l0aW9uRml4ZWQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIGV2ZW50cyAocmVzaXplLCBzY3JvbGwpIGFyZSBpbml0aWFsbHkgZW5hYmxlZFxuICAgKiBAcHJvcCB7Qm9vbGVhbn0gZXZlbnRzRW5hYmxlZD10cnVlXG4gICAqL1xuICBldmVudHNFbmFibGVkOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBTZXQgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0byBhdXRvbWF0aWNhbGx5IHJlbW92ZSB0aGUgcG9wcGVyIHdoZW5cbiAgICogeW91IGNhbGwgdGhlIGBkZXN0cm95YCBtZXRob2QuXG4gICAqIEBwcm9wIHtCb29sZWFufSByZW1vdmVPbkRlc3Ryb3k9ZmFsc2VcbiAgICovXG4gIHJlbW92ZU9uRGVzdHJveTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGNhbGxlZCB3aGVuIHRoZSBwb3BwZXIgaXMgY3JlYXRlZC48YnIgLz5cbiAgICogQnkgZGVmYXVsdCwgaXMgc2V0IHRvIG5vLW9wLjxiciAvPlxuICAgKiBBY2Nlc3MgUG9wcGVyLmpzIGluc3RhbmNlIHdpdGggYGRhdGEuaW5zdGFuY2VgLlxuICAgKiBAcHJvcCB7b25DcmVhdGV9XG4gICAqL1xuICBvbkNyZWF0ZTogZnVuY3Rpb24gb25DcmVhdGUoKSB7fSxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgY2FsbGVkIHdoZW4gdGhlIHBvcHBlciBpcyB1cGRhdGVkLCB0aGlzIGNhbGxiYWNrIGlzIG5vdCBjYWxsZWRcbiAgICogb24gdGhlIGluaXRpYWxpemF0aW9uL2NyZWF0aW9uIG9mIHRoZSBwb3BwZXIsIGJ1dCBvbmx5IG9uIHN1YnNlcXVlbnRcbiAgICogdXBkYXRlcy48YnIgLz5cbiAgICogQnkgZGVmYXVsdCwgaXMgc2V0IHRvIG5vLW9wLjxiciAvPlxuICAgKiBBY2Nlc3MgUG9wcGVyLmpzIGluc3RhbmNlIHdpdGggYGRhdGEuaW5zdGFuY2VgLlxuICAgKiBAcHJvcCB7b25VcGRhdGV9XG4gICAqL1xuICBvblVwZGF0ZTogZnVuY3Rpb24gb25VcGRhdGUoKSB7fSxcblxuICAvKipcbiAgICogTGlzdCBvZiBtb2RpZmllcnMgdXNlZCB0byBtb2RpZnkgdGhlIG9mZnNldHMgYmVmb3JlIHRoZXkgYXJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlci5cbiAgICogVGhleSBwcm92aWRlIG1vc3Qgb2YgdGhlIGZ1bmN0aW9uYWxpdGllcyBvZiBQb3BwZXIuanNcbiAgICogQHByb3Age21vZGlmaWVyc31cbiAgICovXG4gIG1vZGlmaWVyczogbW9kaWZpZXJzXG59O1xuXG4vKipcbiAqIEBjYWxsYmFjayBvbkNyZWF0ZVxuICogQHBhcmFtIHtkYXRhT2JqZWN0fSBkYXRhXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgb25VcGRhdGVcbiAqIEBwYXJhbSB7ZGF0YU9iamVjdH0gZGF0YVxuICovXG5cbi8vIFV0aWxzXG4vLyBNZXRob2RzXG52YXIgUG9wcGVyID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IFBvcHBlci5qcyBpbnN0YW5jZVxuICAgKiBAY2xhc3MgUG9wcGVyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8cmVmZXJlbmNlT2JqZWN0fSByZWZlcmVuY2UgLSBUaGUgcmVmZXJlbmNlIGVsZW1lbnQgdXNlZCB0byBwb3NpdGlvbiB0aGUgcG9wcGVyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBvcHBlciAtIFRoZSBIVE1MIGVsZW1lbnQgdXNlZCBhcyBwb3BwZXIuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gWW91ciBjdXN0b20gb3B0aW9ucyB0byBvdmVycmlkZSB0aGUgb25lcyBkZWZpbmVkIGluIFtEZWZhdWx0c10oI2RlZmF1bHRzKVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGluc3RhbmNlIC0gVGhlIGdlbmVyYXRlZCBQb3BwZXIuanMgaW5zdGFuY2VcbiAgICovXG4gIGZ1bmN0aW9uIFBvcHBlcihyZWZlcmVuY2UsIHBvcHBlcikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgUG9wcGVyKTtcblxuICAgIHRoaXMuc2NoZWR1bGVVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKF90aGlzLnVwZGF0ZSk7XG4gICAgfTtcblxuICAgIC8vIG1ha2UgdXBkYXRlKCkgZGVib3VuY2VkLCBzbyB0aGF0IGl0IG9ubHkgcnVucyBhdCBtb3N0IG9uY2UtcGVyLXRpY2tcbiAgICB0aGlzLnVwZGF0ZSA9IGRlYm91bmNlKHRoaXMudXBkYXRlLmJpbmQodGhpcykpO1xuXG4gICAgLy8gd2l0aCB7fSB3ZSBjcmVhdGUgYSBuZXcgb2JqZWN0IHdpdGggdGhlIG9wdGlvbnMgaW5zaWRlIGl0XG4gICAgdGhpcy5vcHRpb25zID0gX2V4dGVuZHMoe30sIFBvcHBlci5EZWZhdWx0cywgb3B0aW9ucyk7XG5cbiAgICAvLyBpbml0IHN0YXRlXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGlzRGVzdHJveWVkOiBmYWxzZSxcbiAgICAgIGlzQ3JlYXRlZDogZmFsc2UsXG4gICAgICBzY3JvbGxQYXJlbnRzOiBbXVxuICAgIH07XG5cbiAgICAvLyBnZXQgcmVmZXJlbmNlIGFuZCBwb3BwZXIgZWxlbWVudHMgKGFsbG93IGpRdWVyeSB3cmFwcGVycylcbiAgICB0aGlzLnJlZmVyZW5jZSA9IHJlZmVyZW5jZSAmJiByZWZlcmVuY2UuanF1ZXJ5ID8gcmVmZXJlbmNlWzBdIDogcmVmZXJlbmNlO1xuICAgIHRoaXMucG9wcGVyID0gcG9wcGVyICYmIHBvcHBlci5qcXVlcnkgPyBwb3BwZXJbMF0gOiBwb3BwZXI7XG5cbiAgICAvLyBEZWVwIG1lcmdlIG1vZGlmaWVycyBvcHRpb25zXG4gICAgdGhpcy5vcHRpb25zLm1vZGlmaWVycyA9IHt9O1xuICAgIE9iamVjdC5rZXlzKF9leHRlbmRzKHt9LCBQb3BwZXIuRGVmYXVsdHMubW9kaWZpZXJzLCBvcHRpb25zLm1vZGlmaWVycykpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIF90aGlzLm9wdGlvbnMubW9kaWZpZXJzW25hbWVdID0gX2V4dGVuZHMoe30sIFBvcHBlci5EZWZhdWx0cy5tb2RpZmllcnNbbmFtZV0gfHwge30sIG9wdGlvbnMubW9kaWZpZXJzID8gb3B0aW9ucy5tb2RpZmllcnNbbmFtZV0gOiB7fSk7XG4gICAgfSk7XG5cbiAgICAvLyBSZWZhY3RvcmluZyBtb2RpZmllcnMnIGxpc3QgKE9iamVjdCA9PiBBcnJheSlcbiAgICB0aGlzLm1vZGlmaWVycyA9IE9iamVjdC5rZXlzKHRoaXMub3B0aW9ucy5tb2RpZmllcnMpLm1hcChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgICAgbmFtZTogbmFtZVxuICAgICAgfSwgX3RoaXMub3B0aW9ucy5tb2RpZmllcnNbbmFtZV0pO1xuICAgIH0pXG4gICAgLy8gc29ydCB0aGUgbW9kaWZpZXJzIGJ5IG9yZGVyXG4gICAgLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhLm9yZGVyIC0gYi5vcmRlcjtcbiAgICB9KTtcblxuICAgIC8vIG1vZGlmaWVycyBoYXZlIHRoZSBhYmlsaXR5IHRvIGV4ZWN1dGUgYXJiaXRyYXJ5IGNvZGUgd2hlbiBQb3BwZXIuanMgZ2V0IGluaXRlZFxuICAgIC8vIHN1Y2ggY29kZSBpcyBleGVjdXRlZCBpbiB0aGUgc2FtZSBvcmRlciBvZiBpdHMgbW9kaWZpZXJcbiAgICAvLyB0aGV5IGNvdWxkIGFkZCBuZXcgcHJvcGVydGllcyB0byB0aGVpciBvcHRpb25zIGNvbmZpZ3VyYXRpb25cbiAgICAvLyBCRSBBV0FSRTogZG9uJ3QgYWRkIG9wdGlvbnMgdG8gYG9wdGlvbnMubW9kaWZpZXJzLm5hbWVgIGJ1dCB0byBgbW9kaWZpZXJPcHRpb25zYCFcbiAgICB0aGlzLm1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllck9wdGlvbnMpIHtcbiAgICAgIGlmIChtb2RpZmllck9wdGlvbnMuZW5hYmxlZCAmJiBpc0Z1bmN0aW9uKG1vZGlmaWVyT3B0aW9ucy5vbkxvYWQpKSB7XG4gICAgICAgIG1vZGlmaWVyT3B0aW9ucy5vbkxvYWQoX3RoaXMucmVmZXJlbmNlLCBfdGhpcy5wb3BwZXIsIF90aGlzLm9wdGlvbnMsIG1vZGlmaWVyT3B0aW9ucywgX3RoaXMuc3RhdGUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gZmlyZSB0aGUgZmlyc3QgdXBkYXRlIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXIgaW4gdGhlIHJpZ2h0IHBsYWNlXG4gICAgdGhpcy51cGRhdGUoKTtcblxuICAgIHZhciBldmVudHNFbmFibGVkID0gdGhpcy5vcHRpb25zLmV2ZW50c0VuYWJsZWQ7XG4gICAgaWYgKGV2ZW50c0VuYWJsZWQpIHtcbiAgICAgIC8vIHNldHVwIGV2ZW50IGxpc3RlbmVycywgdGhleSB3aWxsIHRha2UgY2FyZSBvZiB1cGRhdGUgdGhlIHBvc2l0aW9uIGluIHNwZWNpZmljIHNpdHVhdGlvbnNcbiAgICAgIHRoaXMuZW5hYmxlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlLmV2ZW50c0VuYWJsZWQgPSBldmVudHNFbmFibGVkO1xuICB9XG5cbiAgLy8gV2UgY2FuJ3QgdXNlIGNsYXNzIHByb3BlcnRpZXMgYmVjYXVzZSB0aGV5IGRvbid0IGdldCBsaXN0ZWQgaW4gdGhlXG4gIC8vIGNsYXNzIHByb3RvdHlwZSBhbmQgYnJlYWsgc3R1ZmYgbGlrZSBTaW5vbiBzdHVic1xuXG5cbiAgY3JlYXRlQ2xhc3MoUG9wcGVyLCBbe1xuICAgIGtleTogJ3VwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZSQkMSgpIHtcbiAgICAgIHJldHVybiB1cGRhdGUuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkZXN0cm95JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSQkMSgpIHtcbiAgICAgIHJldHVybiBkZXN0cm95LmNhbGwodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZW5hYmxlRXZlbnRMaXN0ZW5lcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmFibGVFdmVudExpc3RlbmVycyQkMSgpIHtcbiAgICAgIHJldHVybiBlbmFibGVFdmVudExpc3RlbmVycy5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Rpc2FibGVFdmVudExpc3RlbmVycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2FibGVFdmVudExpc3RlbmVycyQkMSgpIHtcbiAgICAgIHJldHVybiBkaXNhYmxlRXZlbnRMaXN0ZW5lcnMuY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTY2hlZHVsZSBhbiB1cGRhdGUsIGl0IHdpbGwgcnVuIG9uIHRoZSBuZXh0IFVJIHVwZGF0ZSBhdmFpbGFibGVcbiAgICAgKiBAbWV0aG9kIHNjaGVkdWxlVXBkYXRlXG4gICAgICogQG1lbWJlcm9mIFBvcHBlclxuICAgICAqL1xuXG5cbiAgICAvKipcbiAgICAgKiBDb2xsZWN0aW9uIG9mIHV0aWxpdGllcyB1c2VmdWwgd2hlbiB3cml0aW5nIGN1c3RvbSBtb2RpZmllcnMuXG4gICAgICogU3RhcnRpbmcgZnJvbSB2ZXJzaW9uIDEuNywgdGhpcyBtZXRob2QgaXMgYXZhaWxhYmxlIG9ubHkgaWYgeW91XG4gICAgICogaW5jbHVkZSBgcG9wcGVyLXV0aWxzLmpzYCBiZWZvcmUgYHBvcHBlci5qc2AuXG4gICAgICpcbiAgICAgKiAqKkRFUFJFQ0FUSU9OKio6IFRoaXMgd2F5IHRvIGFjY2VzcyBQb3BwZXJVdGlscyBpcyBkZXByZWNhdGVkXG4gICAgICogYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB2MiEgVXNlIHRoZSBQb3BwZXJVdGlscyBtb2R1bGUgZGlyZWN0bHkgaW5zdGVhZC5cbiAgICAgKiBEdWUgdG8gdGhlIGhpZ2ggaW5zdGFiaWxpdHkgb2YgdGhlIG1ldGhvZHMgY29udGFpbmVkIGluIFV0aWxzLCB3ZSBjYW4ndFxuICAgICAqIGd1YXJhbnRlZSB0aGVtIHRvIGZvbGxvdyBzZW12ZXIuIFVzZSB0aGVtIGF0IHlvdXIgb3duIHJpc2shXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDEuOFxuICAgICAqIEBtZW1iZXIgVXRpbHNcbiAgICAgKiBAbWVtYmVyb2YgUG9wcGVyXG4gICAgICovXG5cbiAgfV0pO1xuICByZXR1cm4gUG9wcGVyO1xufSgpO1xuXG4vKipcbiAqIFRoZSBgcmVmZXJlbmNlT2JqZWN0YCBpcyBhbiBvYmplY3QgdGhhdCBwcm92aWRlcyBhbiBpbnRlcmZhY2UgY29tcGF0aWJsZSB3aXRoIFBvcHBlci5qc1xuICogYW5kIGxldHMgeW91IHVzZSBpdCBhcyByZXBsYWNlbWVudCBvZiBhIHJlYWwgRE9NIG5vZGUuPGJyIC8+XG4gKiBZb3UgY2FuIHVzZSB0aGlzIG1ldGhvZCB0byBwb3NpdGlvbiBhIHBvcHBlciByZWxhdGl2ZWx5IHRvIGEgc2V0IG9mIGNvb3JkaW5hdGVzXG4gKiBpbiBjYXNlIHlvdSBkb24ndCBoYXZlIGEgRE9NIG5vZGUgdG8gdXNlIGFzIHJlZmVyZW5jZS5cbiAqXG4gKiBgYGBcbiAqIG5ldyBQb3BwZXIocmVmZXJlbmNlT2JqZWN0LCBwb3BwZXJOb2RlKTtcbiAqIGBgYFxuICpcbiAqIE5COiBUaGlzIGZlYXR1cmUgaXNuJ3Qgc3VwcG9ydGVkIGluIEludGVybmV0IEV4cGxvcmVyIDEwXG4gKiBAbmFtZSByZWZlcmVuY2VPYmplY3RcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGRhdGEuZ2V0Qm91bmRpbmdDbGllbnRSZWN0XG4gKiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHNldCBvZiBjb29yZGluYXRlcyBjb21wYXRpYmxlIHdpdGggdGhlIG5hdGl2ZSBgZ2V0Qm91bmRpbmdDbGllbnRSZWN0YCBtZXRob2QuXG4gKiBAcHJvcGVydHkge251bWJlcn0gZGF0YS5jbGllbnRXaWR0aFxuICogQW4gRVM2IGdldHRlciB0aGF0IHdpbGwgcmV0dXJuIHRoZSB3aWR0aCBvZiB0aGUgdmlydHVhbCByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkYXRhLmNsaWVudEhlaWdodFxuICogQW4gRVM2IGdldHRlciB0aGF0IHdpbGwgcmV0dXJuIHRoZSBoZWlnaHQgb2YgdGhlIHZpcnR1YWwgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKi9cblxuXG5Qb3BwZXIuVXRpbHMgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiBnbG9iYWwpLlBvcHBlclV0aWxzO1xuUG9wcGVyLnBsYWNlbWVudHMgPSBwbGFjZW1lbnRzO1xuUG9wcGVyLkRlZmF1bHRzID0gRGVmYXVsdHM7XG5cbmV4cG9ydCBkZWZhdWx0IFBvcHBlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvcHBlci5qcy5tYXBcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYHVuZGVmaW5lZGAuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYHVuZGVmaW5lZGAsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1VuZGVmaW5lZCh2b2lkIDApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNVbmRlZmluZWQobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNVbmRlZmluZWQ7XG4iLCJpbXBvcnQgYmFzZUdldFRhZyBmcm9tICcuL19iYXNlR2V0VGFnLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYm9vbGVhbiBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYm9vbGVhbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQm9vbGVhbihmYWxzZSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Jvb2xlYW4obnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Jvb2xlYW4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB0cnVlIHx8IHZhbHVlID09PSBmYWxzZSB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGJvb2xUYWcpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0Jvb2xlYW47XG4iLCIvKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogQWRkcyBgdmFsdWVgIHRvIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgYWRkXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBhbGlhcyBwdXNoXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjYWNoZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUFkZCh2YWx1ZSkge1xuICB0aGlzLl9fZGF0YV9fLnNldCh2YWx1ZSwgSEFTSF9VTkRFRklORUQpO1xuICByZXR1cm4gdGhpcztcbn1cblxuZXhwb3J0IGRlZmF1bHQgc2V0Q2FjaGVBZGQ7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlSGFzKHZhbHVlKSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyh2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHNldENhY2hlSGFzO1xuIiwiaW1wb3J0IE1hcENhY2hlIGZyb20gJy4vX01hcENhY2hlLmpzJztcbmltcG9ydCBzZXRDYWNoZUFkZCBmcm9tICcuL19zZXRDYWNoZUFkZC5qcyc7XG5pbXBvcnQgc2V0Q2FjaGVIYXMgZnJvbSAnLi9fc2V0Q2FjaGVIYXMuanMnO1xuXG4vKipcbiAqXG4gKiBDcmVhdGVzIGFuIGFycmF5IGNhY2hlIG9iamVjdCB0byBzdG9yZSB1bmlxdWUgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFNldENhY2hlKHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcyA9PSBudWxsID8gMCA6IHZhbHVlcy5sZW5ndGg7XG5cbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB0aGlzLmFkZCh2YWx1ZXNbaW5kZXhdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU2V0Q2FjaGVgLlxuU2V0Q2FjaGUucHJvdG90eXBlLmFkZCA9IFNldENhY2hlLnByb3RvdHlwZS5wdXNoID0gc2V0Q2FjaGVBZGQ7XG5TZXRDYWNoZS5wcm90b3R5cGUuaGFzID0gc2V0Q2FjaGVIYXM7XG5cbmV4cG9ydCBkZWZhdWx0IFNldENhY2hlO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc29tZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5U29tZShhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXJyYXlTb21lO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYSBgY2FjaGVgIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBjYWNoZSBUaGUgY2FjaGUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gY2FjaGVIYXMoY2FjaGUsIGtleSkge1xuICByZXR1cm4gY2FjaGUuaGFzKGtleSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNhY2hlSGFzO1xuIiwiaW1wb3J0IFNldENhY2hlIGZyb20gJy4vX1NldENhY2hlLmpzJztcbmltcG9ydCBhcnJheVNvbWUgZnJvbSAnLi9fYXJyYXlTb21lLmpzJztcbmltcG9ydCBjYWNoZUhhcyBmcm9tICcuL19jYWNoZUhhcy5qcyc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGFycmF5cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtBcnJheX0gb3RoZXIgVGhlIG90aGVyIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBhcnJheWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJyYXlzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQXJyYXlzKGFycmF5LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuXG4gIGlmIChhcnJMZW5ndGggIT0gb3RoTGVuZ3RoICYmICEoaXNQYXJ0aWFsICYmIG90aExlbmd0aCA+IGFyckxlbmd0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChhcnJheSk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IHRydWUsXG4gICAgICBzZWVuID0gKGJpdG1hc2sgJiBDT01QQVJFX1VOT1JERVJFRF9GTEFHKSA/IG5ldyBTZXRDYWNoZSA6IHVuZGVmaW5lZDtcblxuICBzdGFjay5zZXQoYXJyYXksIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBhcnJheSk7XG5cbiAgLy8gSWdub3JlIG5vbi1pbmRleCBwcm9wZXJ0aWVzLlxuICB3aGlsZSAoKytpbmRleCA8IGFyckxlbmd0aCkge1xuICAgIHZhciBhcnJWYWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltpbmRleF07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgYXJyVmFsdWUsIGluZGV4LCBvdGhlciwgYXJyYXksIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIoYXJyVmFsdWUsIG90aFZhbHVlLCBpbmRleCwgYXJyYXksIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIGlmIChjb21wYXJlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoY29tcGFyZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmIChzZWVuKSB7XG4gICAgICBpZiAoIWFycmF5U29tZShvdGhlciwgZnVuY3Rpb24ob3RoVmFsdWUsIG90aEluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIWNhY2hlSGFzKHNlZW4sIG90aEluZGV4KSAmJlxuICAgICAgICAgICAgICAgIChhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKSkge1xuICAgICAgICAgICAgICByZXR1cm4gc2Vlbi5wdXNoKG90aEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSkge1xuICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghKFxuICAgICAgICAgIGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fFxuICAgICAgICAgICAgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHN0YWNrWydkZWxldGUnXShhcnJheSk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGVxdWFsQXJyYXlzO1xuIiwiLyoqXG4gKiBDb252ZXJ0cyBgbWFwYCB0byBpdHMga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICovXG5mdW5jdGlvbiBtYXBUb0FycmF5KG1hcCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG1hcC5zaXplKTtcblxuICBtYXAuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gW2tleSwgdmFsdWVdO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWFwVG9BcnJheTtcbiIsIi8qKlxuICogQ29udmVydHMgYHNldGAgdG8gYW4gYXJyYXkgb2YgaXRzIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gc2V0VG9BcnJheShzZXQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShzZXQuc2l6ZSk7XG5cbiAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHNldFRvQXJyYXk7XG4iLCJpbXBvcnQgU3ltYm9sIGZyb20gJy4vX1N5bWJvbC5qcyc7XG5pbXBvcnQgVWludDhBcnJheSBmcm9tICcuL19VaW50OEFycmF5LmpzJztcbmltcG9ydCBlcSBmcm9tICcuL2VxLmpzJztcbmltcG9ydCBlcXVhbEFycmF5cyBmcm9tICcuL19lcXVhbEFycmF5cy5qcyc7XG5pbXBvcnQgbWFwVG9BcnJheSBmcm9tICcuL19tYXBUb0FycmF5LmpzJztcbmltcG9ydCBzZXRUb0FycmF5IGZyb20gJy4vX3NldFRvQXJyYXkuanMnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJztcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBjb21wYXJpbmcgb2JqZWN0cyBvZlxuICogdGhlIHNhbWUgYHRvU3RyaW5nVGFnYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNvbXBhcmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBvciBgU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0cyB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgdGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAob2JqZWN0LmJ5dGVPZmZzZXQgIT0gb3RoZXIuYnl0ZU9mZnNldCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgb2JqZWN0ID0gb2JqZWN0LmJ1ZmZlcjtcbiAgICAgIG90aGVyID0gb3RoZXIuYnVmZmVyO1xuXG4gICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAhZXF1YWxGdW5jKG5ldyBVaW50OEFycmF5KG9iamVjdCksIG5ldyBVaW50OEFycmF5KG90aGVyKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICBjYXNlIGJvb2xUYWc6XG4gICAgY2FzZSBkYXRlVGFnOlxuICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgLy8gQ29lcmNlIGJvb2xlYW5zIHRvIGAxYCBvciBgMGAgYW5kIGRhdGVzIHRvIG1pbGxpc2Vjb25kcy5cbiAgICAgIC8vIEludmFsaWQgZGF0ZXMgYXJlIGNvZXJjZWQgdG8gYE5hTmAuXG4gICAgICByZXR1cm4gZXEoK29iamVjdCwgK290aGVyKTtcblxuICAgIGNhc2UgZXJyb3JUYWc6XG4gICAgICByZXR1cm4gb2JqZWN0Lm5hbWUgPT0gb3RoZXIubmFtZSAmJiBvYmplY3QubWVzc2FnZSA9PSBvdGhlci5tZXNzYWdlO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAvLyBDb2VyY2UgcmVnZXhlcyB0byBzdHJpbmdzIGFuZCB0cmVhdCBzdHJpbmdzLCBwcmltaXRpdmVzIGFuZCBvYmplY3RzLFxuICAgICAgLy8gYXMgZXF1YWwuIFNlZSBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcmVnZXhwLnByb3RvdHlwZS50b3N0cmluZ1xuICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIHJldHVybiBvYmplY3QgPT0gKG90aGVyICsgJycpO1xuXG4gICAgY2FzZSBtYXBUYWc6XG4gICAgICB2YXIgY29udmVydCA9IG1hcFRvQXJyYXk7XG5cbiAgICBjYXNlIHNldFRhZzpcbiAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUc7XG4gICAgICBjb252ZXJ0IHx8IChjb252ZXJ0ID0gc2V0VG9BcnJheSk7XG5cbiAgICAgIGlmIChvYmplY3Quc2l6ZSAhPSBvdGhlci5zaXplICYmICFpc1BhcnRpYWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgICAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICAgICAgfVxuICAgICAgYml0bWFzayB8PSBDT01QQVJFX1VOT1JERVJFRF9GTEFHO1xuXG4gICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgICAgIHZhciByZXN1bHQgPSBlcXVhbEFycmF5cyhjb252ZXJ0KG9iamVjdCksIGNvbnZlcnQob3RoZXIpLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICAgIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgaWYgKHN5bWJvbFZhbHVlT2YpIHtcbiAgICAgICAgcmV0dXJuIHN5bWJvbFZhbHVlT2YuY2FsbChvYmplY3QpID09IHN5bWJvbFZhbHVlT2YuY2FsbChvdGhlcik7XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBlcXVhbEJ5VGFnO1xuIiwiLyoqXG4gKiBBcHBlbmRzIHRoZSBlbGVtZW50cyBvZiBgdmFsdWVzYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYXBwZW5kLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5UHVzaChhcnJheSwgdmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIG9mZnNldCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W29mZnNldCArIGluZGV4XSA9IHZhbHVlc1tpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheVB1c2g7XG4iLCJpbXBvcnQgYXJyYXlQdXNoIGZyb20gJy4vX2FycmF5UHVzaC5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRBbGxLZXlzYCBhbmQgYGdldEFsbEtleXNJbmAgd2hpY2ggdXNlc1xuICogYGtleXNGdW5jYCBhbmQgYHN5bWJvbHNGdW5jYCB0byBnZXQgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3ltYm9sc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0Z1bmMsIHN5bWJvbHNGdW5jKSB7XG4gIHZhciByZXN1bHQgPSBrZXlzRnVuYyhvYmplY3QpO1xuICByZXR1cm4gaXNBcnJheShvYmplY3QpID8gcmVzdWx0IDogYXJyYXlQdXNoKHJlc3VsdCwgc3ltYm9sc0Z1bmMob2JqZWN0KSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VHZXRBbGxLZXlzO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZmlsdGVyYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RmlsdGVyKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheUZpbHRlcjtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBlbXB0eSBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGVtcHR5IGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgYXJyYXlzID0gXy50aW1lcygyLCBfLnN0dWJBcnJheSk7XG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzKTtcbiAqIC8vID0+IFtbXSwgW11dXG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzWzBdID09PSBhcnJheXNbMV0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gc3R1YkFycmF5KCkge1xuICByZXR1cm4gW107XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0dWJBcnJheTtcbiIsImltcG9ydCBhcnJheUZpbHRlciBmcm9tICcuL19hcnJheUZpbHRlci5qcyc7XG5pbXBvcnQgc3R1YkFycmF5IGZyb20gJy4vc3R1YkFycmF5LmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAqL1xudmFyIGdldFN5bWJvbHMgPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIHJldHVybiBhcnJheUZpbHRlcihuYXRpdmVHZXRTeW1ib2xzKG9iamVjdCksIGZ1bmN0aW9uKHN5bWJvbCkge1xuICAgIHJldHVybiBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgc3ltYm9sKTtcbiAgfSk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBnZXRTeW1ib2xzO1xuIiwiaW1wb3J0IGJhc2VHZXRBbGxLZXlzIGZyb20gJy4vX2Jhc2VHZXRBbGxLZXlzLmpzJztcbmltcG9ydCBnZXRTeW1ib2xzIGZyb20gJy4vX2dldFN5bWJvbHMuanMnO1xuaW1wb3J0IGtleXMgZnJvbSAnLi9rZXlzLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRBbGxLZXlzKG9iamVjdCkge1xuICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzLCBnZXRTeW1ib2xzKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0QWxsS2V5cztcbiIsImltcG9ydCBnZXRBbGxLZXlzIGZyb20gJy4vX2dldEFsbEtleXMuanMnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDE7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBvYmpQcm9wcyA9IGdldEFsbEtleXMob2JqZWN0KSxcbiAgICAgIG9iakxlbmd0aCA9IG9ialByb3BzLmxlbmd0aCxcbiAgICAgIG90aFByb3BzID0gZ2V0QWxsS2V5cyhvdGhlciksXG4gICAgICBvdGhMZW5ndGggPSBvdGhQcm9wcy5sZW5ndGg7XG5cbiAgaWYgKG9iakxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIWlzUGFydGlhbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaW5kZXggPSBvYmpMZW5ndGg7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICBpZiAoIShpc1BhcnRpYWwgPyBrZXkgaW4gb3RoZXIgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCBrZXkpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIG9iamVjdCk7XG5cbiAgdmFyIHNraXBDdG9yID0gaXNQYXJ0aWFsO1xuICB3aGlsZSAoKytpbmRleCA8IG9iakxlbmd0aCkge1xuICAgIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIG9ialZhbHVlLCBrZXksIG90aGVyLCBvYmplY3QsIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlLCBrZXksIG9iamVjdCwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKCEoY29tcGFyZWQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gKG9ialZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMob2JqVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpXG4gICAgICAgICAgOiBjb21wYXJlZFxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBza2lwQ3RvciB8fCAoc2tpcEN0b3IgPSBrZXkgPT0gJ2NvbnN0cnVjdG9yJyk7XG4gIH1cbiAgaWYgKHJlc3VsdCAmJiAhc2tpcEN0b3IpIHtcbiAgICB2YXIgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgLy8gTm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWwuXG4gICAgaWYgKG9iakN0b3IgIT0gb3RoQ3RvciAmJlxuICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcbiAgICAgICAgISh0eXBlb2Ygb2JqQ3RvciA9PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmXG4gICAgICAgICAgdHlwZW9mIG90aEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3RvcikpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZXF1YWxPYmplY3RzO1xuIiwiaW1wb3J0IGdldE5hdGl2ZSBmcm9tICcuL19nZXROYXRpdmUuanMnO1xuaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBEYXRhVmlldyA9IGdldE5hdGl2ZShyb290LCAnRGF0YVZpZXcnKTtcblxuZXhwb3J0IGRlZmF1bHQgRGF0YVZpZXc7XG4iLCJpbXBvcnQgZ2V0TmF0aXZlIGZyb20gJy4vX2dldE5hdGl2ZS5qcyc7XG5pbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFByb21pc2UgPSBnZXROYXRpdmUocm9vdCwgJ1Byb21pc2UnKTtcblxuZXhwb3J0IGRlZmF1bHQgUHJvbWlzZTtcbiIsImltcG9ydCBnZXROYXRpdmUgZnJvbSAnLi9fZ2V0TmF0aXZlLmpzJztcbmltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgU2V0ID0gZ2V0TmF0aXZlKHJvb3QsICdTZXQnKTtcblxuZXhwb3J0IGRlZmF1bHQgU2V0O1xuIiwiaW1wb3J0IGdldE5hdGl2ZSBmcm9tICcuL19nZXROYXRpdmUuanMnO1xuaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBXZWFrTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdXZWFrTWFwJyk7XG5cbmV4cG9ydCBkZWZhdWx0IFdlYWtNYXA7XG4iLCJpbXBvcnQgRGF0YVZpZXcgZnJvbSAnLi9fRGF0YVZpZXcuanMnO1xuaW1wb3J0IE1hcCBmcm9tICcuL19NYXAuanMnO1xuaW1wb3J0IFByb21pc2UgZnJvbSAnLi9fUHJvbWlzZS5qcyc7XG5pbXBvcnQgU2V0IGZyb20gJy4vX1NldC5qcyc7XG5pbXBvcnQgV2Vha01hcCBmcm9tICcuL19XZWFrTWFwLmpzJztcbmltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IHRvU291cmNlIGZyb20gJy4vX3RvU291cmNlLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHByb21pc2VUYWcgPSAnW29iamVjdCBQcm9taXNlXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1hcHMsIHNldHMsIGFuZCB3ZWFrbWFwcy4gKi9cbnZhciBkYXRhVmlld0N0b3JTdHJpbmcgPSB0b1NvdXJjZShEYXRhVmlldyksXG4gICAgbWFwQ3RvclN0cmluZyA9IHRvU291cmNlKE1hcCksXG4gICAgcHJvbWlzZUN0b3JTdHJpbmcgPSB0b1NvdXJjZShQcm9taXNlKSxcbiAgICBzZXRDdG9yU3RyaW5nID0gdG9Tb3VyY2UoU2V0KSxcbiAgICB3ZWFrTWFwQ3RvclN0cmluZyA9IHRvU291cmNlKFdlYWtNYXApO1xuXG4vKipcbiAqIEdldHMgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG52YXIgZ2V0VGFnID0gYmFzZUdldFRhZztcblxuLy8gRmFsbGJhY2sgZm9yIGRhdGEgdmlld3MsIG1hcHMsIHNldHMsIGFuZCB3ZWFrIG1hcHMgaW4gSUUgMTEgYW5kIHByb21pc2VzIGluIE5vZGUuanMgPCA2LlxuaWYgKChEYXRhVmlldyAmJiBnZXRUYWcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSkpICE9IGRhdGFWaWV3VGFnKSB8fFxuICAgIChNYXAgJiYgZ2V0VGFnKG5ldyBNYXApICE9IG1hcFRhZykgfHxcbiAgICAoUHJvbWlzZSAmJiBnZXRUYWcoUHJvbWlzZS5yZXNvbHZlKCkpICE9IHByb21pc2VUYWcpIHx8XG4gICAgKFNldCAmJiBnZXRUYWcobmV3IFNldCkgIT0gc2V0VGFnKSB8fFxuICAgIChXZWFrTWFwICYmIGdldFRhZyhuZXcgV2Vha01hcCkgIT0gd2Vha01hcFRhZykpIHtcbiAgZ2V0VGFnID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gYmFzZUdldFRhZyh2YWx1ZSksXG4gICAgICAgIEN0b3IgPSByZXN1bHQgPT0gb2JqZWN0VGFnID8gdmFsdWUuY29uc3RydWN0b3IgOiB1bmRlZmluZWQsXG4gICAgICAgIGN0b3JTdHJpbmcgPSBDdG9yID8gdG9Tb3VyY2UoQ3RvcikgOiAnJztcblxuICAgIGlmIChjdG9yU3RyaW5nKSB7XG4gICAgICBzd2l0Y2ggKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgY2FzZSBkYXRhVmlld0N0b3JTdHJpbmc6IHJldHVybiBkYXRhVmlld1RhZztcbiAgICAgICAgY2FzZSBtYXBDdG9yU3RyaW5nOiByZXR1cm4gbWFwVGFnO1xuICAgICAgICBjYXNlIHByb21pc2VDdG9yU3RyaW5nOiByZXR1cm4gcHJvbWlzZVRhZztcbiAgICAgICAgY2FzZSBzZXRDdG9yU3RyaW5nOiByZXR1cm4gc2V0VGFnO1xuICAgICAgICBjYXNlIHdlYWtNYXBDdG9yU3RyaW5nOiByZXR1cm4gd2Vha01hcFRhZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0VGFnO1xuIiwiaW1wb3J0IFN0YWNrIGZyb20gJy4vX1N0YWNrLmpzJztcbmltcG9ydCBlcXVhbEFycmF5cyBmcm9tICcuL19lcXVhbEFycmF5cy5qcyc7XG5pbXBvcnQgZXF1YWxCeVRhZyBmcm9tICcuL19lcXVhbEJ5VGFnLmpzJztcbmltcG9ydCBlcXVhbE9iamVjdHMgZnJvbSAnLi9fZXF1YWxPYmplY3RzLmpzJztcbmltcG9ydCBnZXRUYWcgZnJvbSAnLi9fZ2V0VGFnLmpzJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5pbXBvcnQgaXNCdWZmZXIgZnJvbSAnLi9pc0J1ZmZlci5qcyc7XG5pbXBvcnQgaXNUeXBlZEFycmF5IGZyb20gJy4vaXNUeXBlZEFycmF5LmpzJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gKiBkZWVwIGNvbXBhcmlzb25zIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gKiByZWZlcmVuY2VzIHRvIGJlIGNvbXBhcmVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbERlZXAob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgb2JqSXNBcnIgPSBpc0FycmF5KG9iamVjdCksXG4gICAgICBvdGhJc0FyciA9IGlzQXJyYXkob3RoZXIpLFxuICAgICAgb2JqVGFnID0gb2JqSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvYmplY3QpLFxuICAgICAgb3RoVGFnID0gb3RoSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvdGhlcik7XG5cbiAgb2JqVGFnID0gb2JqVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvYmpUYWc7XG4gIG90aFRhZyA9IG90aFRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb3RoVGFnO1xuXG4gIHZhciBvYmpJc09iaiA9IG9ialRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBvdGhJc09iaiA9IG90aFRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBpc1NhbWVUYWcgPSBvYmpUYWcgPT0gb3RoVGFnO1xuXG4gIGlmIChpc1NhbWVUYWcgJiYgaXNCdWZmZXIob2JqZWN0KSkge1xuICAgIGlmICghaXNCdWZmZXIob3RoZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG9iaklzQXJyID0gdHJ1ZTtcbiAgICBvYmpJc09iaiA9IGZhbHNlO1xuICB9XG4gIGlmIChpc1NhbWVUYWcgJiYgIW9iaklzT2JqKSB7XG4gICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICByZXR1cm4gKG9iaklzQXJyIHx8IGlzVHlwZWRBcnJheShvYmplY3QpKVxuICAgICAgPyBlcXVhbEFycmF5cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKVxuICAgICAgOiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIG9ialRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gIH1cbiAgaWYgKCEoYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHKSkge1xuICAgIHZhciBvYmpJc1dyYXBwZWQgPSBvYmpJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ19fd3JhcHBlZF9fJyksXG4gICAgICAgIG90aElzV3JhcHBlZCA9IG90aElzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsICdfX3dyYXBwZWRfXycpO1xuXG4gICAgaWYgKG9iaklzV3JhcHBlZCB8fCBvdGhJc1dyYXBwZWQpIHtcbiAgICAgIHZhciBvYmpVbndyYXBwZWQgPSBvYmpJc1dyYXBwZWQgPyBvYmplY3QudmFsdWUoKSA6IG9iamVjdCxcbiAgICAgICAgICBvdGhVbndyYXBwZWQgPSBvdGhJc1dyYXBwZWQgPyBvdGhlci52YWx1ZSgpIDogb3RoZXI7XG5cbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICByZXR1cm4gZXF1YWxGdW5jKG9ialVud3JhcHBlZCwgb3RoVW53cmFwcGVkLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgfVxuICB9XG4gIGlmICghaXNTYW1lVGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gIHJldHVybiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VJc0VxdWFsRGVlcDtcbiIsImltcG9ydCBiYXNlSXNFcXVhbERlZXAgZnJvbSAnLi9fYmFzZUlzRXF1YWxEZWVwLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRXF1YWxgIHdoaWNoIHN1cHBvcnRzIHBhcnRpYWwgY29tcGFyaXNvbnNcbiAqIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtib29sZWFufSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICogIDEgLSBVbm9yZGVyZWQgY29tcGFyaXNvblxuICogIDIgLSBQYXJ0aWFsIGNvbXBhcmlzb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgdmFsdWVgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIGlmICh2YWx1ZSA9PT0gb3RoZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCB8fCBvdGhlciA9PSBudWxsIHx8ICghaXNPYmplY3RMaWtlKHZhbHVlKSAmJiAhaXNPYmplY3RMaWtlKG90aGVyKSkpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcjtcbiAgfVxuICByZXR1cm4gYmFzZUlzRXF1YWxEZWVwKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgYmFzZUlzRXF1YWwsIHN0YWNrKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUlzRXF1YWw7XG4iLCJpbXBvcnQgU3RhY2sgZnJvbSAnLi9fU3RhY2suanMnO1xuaW1wb3J0IGJhc2VJc0VxdWFsIGZyb20gJy4vX2Jhc2VJc0VxdWFsLmpzJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWF0Y2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtBcnJheX0gbWF0Y2hEYXRhIFRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSwgY3VzdG9taXplcikge1xuICB2YXIgaW5kZXggPSBtYXRjaERhdGEubGVuZ3RoLFxuICAgICAgbGVuZ3RoID0gaW5kZXgsXG4gICAgICBub0N1c3RvbWl6ZXIgPSAhY3VzdG9taXplcjtcblxuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gIWxlbmd0aDtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgaWYgKChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSlcbiAgICAgICAgICA/IGRhdGFbMV0gIT09IG9iamVjdFtkYXRhWzBdXVxuICAgICAgICAgIDogIShkYXRhWzBdIGluIG9iamVjdClcbiAgICAgICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgdmFyIGtleSA9IGRhdGFbMF0sXG4gICAgICAgIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIHNyY1ZhbHVlID0gZGF0YVsxXTtcblxuICAgIGlmIChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSkge1xuICAgICAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzdGFjayA9IG5ldyBTdGFjaztcbiAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spO1xuICAgICAgfVxuICAgICAgaWYgKCEocmVzdWx0ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcsIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICAgICAgOiByZXN1bHRcbiAgICAgICAgICApKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VJc01hdGNoO1xuIiwiaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaWYgc3VpdGFibGUgZm9yIHN0cmljdFxuICogIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlICYmICFpc09iamVjdCh2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzU3RyaWN0Q29tcGFyYWJsZTtcbiIsImltcG9ydCBpc1N0cmljdENvbXBhcmFibGUgZnJvbSAnLi9faXNTdHJpY3RDb21wYXJhYmxlLmpzJztcbmltcG9ydCBrZXlzIGZyb20gJy4va2V5cy5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3Mgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbWF0Y2ggZGF0YSBvZiBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gZ2V0TWF0Y2hEYXRhKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0ga2V5cyhvYmplY3QpLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICB2YXIga2V5ID0gcmVzdWx0W2xlbmd0aF0sXG4gICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICByZXN1bHRbbGVuZ3RoXSA9IFtrZXksIHZhbHVlLCBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXRNYXRjaERhdGE7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgbWF0Y2hlc1Byb3BlcnR5YCBmb3Igc291cmNlIHZhbHVlcyBzdWl0YWJsZVxuICogZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKGtleSwgc3JjVmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0W2tleV0gPT09IHNyY1ZhbHVlICYmXG4gICAgICAoc3JjVmFsdWUgIT09IHVuZGVmaW5lZCB8fCAoa2V5IGluIE9iamVjdChvYmplY3QpKSk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlO1xuIiwiaW1wb3J0IGJhc2VJc01hdGNoIGZyb20gJy4vX2Jhc2VJc01hdGNoLmpzJztcbmltcG9ydCBnZXRNYXRjaERhdGEgZnJvbSAnLi9fZ2V0TWF0Y2hEYXRhLmpzJztcbmltcG9ydCBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSBmcm9tICcuL19tYXRjaGVzU3RyaWN0Q29tcGFyYWJsZS5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc2Agd2hpY2ggZG9lc24ndCBjbG9uZSBgc291cmNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzKHNvdXJjZSkge1xuICB2YXIgbWF0Y2hEYXRhID0gZ2V0TWF0Y2hEYXRhKHNvdXJjZSk7XG4gIGlmIChtYXRjaERhdGEubGVuZ3RoID09IDEgJiYgbWF0Y2hEYXRhWzBdWzJdKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKG1hdGNoRGF0YVswXVswXSwgbWF0Y2hEYXRhWzBdWzFdKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PT0gc291cmNlIHx8IGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlTWF0Y2hlcztcbiIsImltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5pbXBvcnQgaXNTeW1ib2wgZnJvbSAnLi9pc1N5bWJvbC5qcyc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUlzRGVlcFByb3AgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqP1xcMSlcXF0vLFxuICAgIHJlSXNQbGFpblByb3AgPSAvXlxcdyokLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUgYW5kIG5vdCBhIHByb3BlcnR5IHBhdGguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleSh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJyB8fFxuICAgICAgdmFsdWUgPT0gbnVsbCB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmVJc1BsYWluUHJvcC50ZXN0KHZhbHVlKSB8fCAhcmVJc0RlZXBQcm9wLnRlc3QodmFsdWUpIHx8XG4gICAgKG9iamVjdCAhPSBudWxsICYmIHZhbHVlIGluIE9iamVjdChvYmplY3QpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNLZXk7XG4iLCJpbXBvcnQgTWFwQ2FjaGUgZnJvbSAnLi9fTWFwQ2FjaGUuanMnO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gKiBwcm92aWRlZCwgaXQgZGV0ZXJtaW5lcyB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHQgYmFzZWQgb24gdGhlXG4gKiBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgYXJndW1lbnRcbiAqIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBtYXAgY2FjaGUga2V5LiBUaGUgYGZ1bmNgXG4gKiBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXG4gKiBmdW5jdGlvbi4gSXRzIGNyZWF0aW9uIG1heSBiZSBjdXN0b21pemVkIGJ5IHJlcGxhY2luZyB0aGUgYF8ubWVtb2l6ZS5DYWNoZWBcbiAqIGNvbnN0cnVjdG9yIHdpdGggb25lIHdob3NlIGluc3RhbmNlcyBpbXBsZW1lbnQgdGhlXG4gKiBbYE1hcGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLW1hcC1wcm90b3R5cGUtb2JqZWN0KVxuICogbWV0aG9kIGludGVyZmFjZSBvZiBgY2xlYXJgLCBgZGVsZXRlYCwgYGdldGAsIGBoYXNgLCBhbmQgYHNldGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2MnOiAzLCAnZCc6IDQgfTtcbiAqXG4gKiB2YXIgdmFsdWVzID0gXy5tZW1vaXplKF8udmFsdWVzKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogdmFsdWVzKG90aGVyKTtcbiAqIC8vID0+IFszLCA0XVxuICpcbiAqIG9iamVjdC5hID0gMjtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogLy8gTW9kaWZ5IHRoZSByZXN1bHQgY2FjaGUuXG4gKiB2YWx1ZXMuY2FjaGUuc2V0KG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsnYScsICdiJ11cbiAqXG4gKiAvLyBSZXBsYWNlIGBfLm1lbW9pemUuQ2FjaGVgLlxuICogXy5tZW1vaXplLkNhY2hlID0gV2Vha01hcDtcbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJyB8fCAocmVzb2x2ZXIgIT0gbnVsbCAmJiB0eXBlb2YgcmVzb2x2ZXIgIT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuICAgICAgICBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuXG4gICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KSB8fCBjYWNoZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBtZW1vaXplZC5jYWNoZSA9IG5ldyAobWVtb2l6ZS5DYWNoZSB8fCBNYXBDYWNoZSk7XG4gIHJldHVybiBtZW1vaXplZDtcbn1cblxuLy8gRXhwb3NlIGBNYXBDYWNoZWAuXG5tZW1vaXplLkNhY2hlID0gTWFwQ2FjaGU7XG5cbmV4cG9ydCBkZWZhdWx0IG1lbW9pemU7XG4iLCJpbXBvcnQgbWVtb2l6ZSBmcm9tICcuL21lbW9pemUuanMnO1xuXG4vKiogVXNlZCBhcyB0aGUgbWF4aW11bSBtZW1vaXplIGNhY2hlIHNpemUuICovXG52YXIgTUFYX01FTU9JWkVfU0laRSA9IDUwMDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWVtb2l6ZWAgd2hpY2ggY2xlYXJzIHRoZSBtZW1vaXplZCBmdW5jdGlvbidzXG4gKiBjYWNoZSB3aGVuIGl0IGV4Y2VlZHMgYE1BWF9NRU1PSVpFX1NJWkVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZUNhcHBlZChmdW5jKSB7XG4gIHZhciByZXN1bHQgPSBtZW1vaXplKGZ1bmMsIGZ1bmN0aW9uKGtleSkge1xuICAgIGlmIChjYWNoZS5zaXplID09PSBNQVhfTUVNT0laRV9TSVpFKSB7XG4gICAgICBjYWNoZS5jbGVhcigpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5O1xuICB9KTtcblxuICB2YXIgY2FjaGUgPSByZXN1bHQuY2FjaGU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1lbW9pemVDYXBwZWQ7XG4iLCJpbXBvcnQgbWVtb2l6ZUNhcHBlZCBmcm9tICcuL19tZW1vaXplQ2FwcGVkLmpzJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlUHJvcE5hbWUgPSAvW14uW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JCkpL2c7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nO1xuXG4vKipcbiAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGEgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbnZhciBzdHJpbmdUb1BhdGggPSBtZW1vaXplQ2FwcGVkKGZ1bmN0aW9uKHN0cmluZykge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChzdHJpbmcuY2hhckNvZGVBdCgwKSA9PT0gNDYgLyogLiAqLykge1xuICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgfVxuICBzdHJpbmcucmVwbGFjZShyZVByb3BOYW1lLCBmdW5jdGlvbihtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3ViU3RyaW5nKSB7XG4gICAgcmVzdWx0LnB1c2gocXVvdGUgPyBzdWJTdHJpbmcucmVwbGFjZShyZUVzY2FwZUNoYXIsICckMScpIDogKG51bWJlciB8fCBtYXRjaCkpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBzdHJpbmdUb1BhdGg7XG4iLCJpbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuaW1wb3J0IGlzS2V5IGZyb20gJy4vX2lzS2V5LmpzJztcbmltcG9ydCBzdHJpbmdUb1BhdGggZnJvbSAnLi9fc3RyaW5nVG9QYXRoLmpzJztcbmltcG9ydCB0b1N0cmluZyBmcm9tICcuL3RvU3RyaW5nLmpzJztcblxuLyoqXG4gKiBDYXN0cyBgdmFsdWVgIHRvIGEgcGF0aCBhcnJheSBpZiBpdCdzIG5vdCBvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNhc3RQYXRoKHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiBpc0tleSh2YWx1ZSwgb2JqZWN0KSA/IFt2YWx1ZV0gOiBzdHJpbmdUb1BhdGgodG9TdHJpbmcodmFsdWUpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2FzdFBhdGg7XG4iLCJpbXBvcnQgaXNTeW1ib2wgZnJvbSAnLi9pc1N5bWJvbC5qcyc7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAqL1xuZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCB0b0tleTtcbiIsImltcG9ydCBjYXN0UGF0aCBmcm9tICcuL19jYXN0UGF0aC5qcyc7XG5pbXBvcnQgdG9LZXkgZnJvbSAnLi9fdG9LZXkuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmdldGAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWZhdWx0IHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldChvYmplY3QsIHBhdGgpIHtcbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gMCxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gIHdoaWxlIChvYmplY3QgIT0gbnVsbCAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgIG9iamVjdCA9IG9iamVjdFt0b0tleShwYXRoW2luZGV4KytdKV07XG4gIH1cbiAgcmV0dXJuIChpbmRleCAmJiBpbmRleCA9PSBsZW5ndGgpID8gb2JqZWN0IDogdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlR2V0O1xuIiwiaW1wb3J0IGJhc2VHZXQgZnJvbSAnLi9fYmFzZUdldC5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXNcbiAqIGB1bmRlZmluZWRgLCB0aGUgYGRlZmF1bHRWYWx1ZWAgaXMgcmV0dXJuZWQgaW4gaXRzIHBsYWNlLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy43LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSByZXR1cm5lZCBmb3IgYHVuZGVmaW5lZGAgcmVzb2x2ZWQgdmFsdWVzLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2FbMF0uYi5jJyk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCBbJ2EnLCAnMCcsICdiJywgJ2MnXSk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCAnYS5iLmMnLCAnZGVmYXVsdCcpO1xuICogLy8gPT4gJ2RlZmF1bHQnXG4gKi9cbmZ1bmN0aW9uIGdldChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0O1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5oYXNJbmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUhhc0luKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBrZXkgaW4gT2JqZWN0KG9iamVjdCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VIYXNJbjtcbiIsImltcG9ydCBjYXN0UGF0aCBmcm9tICcuL19jYXN0UGF0aC5qcyc7XG5pbXBvcnQgaXNBcmd1bWVudHMgZnJvbSAnLi9pc0FyZ3VtZW50cy5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuaW1wb3J0IGlzSW5kZXggZnJvbSAnLi9faXNJbmRleC5qcyc7XG5pbXBvcnQgaXNMZW5ndGggZnJvbSAnLi9pc0xlbmd0aC5qcyc7XG5pbXBvcnQgdG9LZXkgZnJvbSAnLi9fdG9LZXkuanMnO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgZXhpc3RzIG9uIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrIHByb3BlcnRpZXMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgaGFzRnVuYykge1xuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gZmFsc2U7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gdG9LZXkocGF0aFtpbmRleF0pO1xuICAgIGlmICghKHJlc3VsdCA9IG9iamVjdCAhPSBudWxsICYmIGhhc0Z1bmMob2JqZWN0LCBrZXkpKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG9iamVjdCA9IG9iamVjdFtrZXldO1xuICB9XG4gIGlmIChyZXN1bHQgfHwgKytpbmRleCAhPSBsZW5ndGgpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGxlbmd0aCA9IG9iamVjdCA9PSBudWxsID8gMCA6IG9iamVjdC5sZW5ndGg7XG4gIHJldHVybiAhIWxlbmd0aCAmJiBpc0xlbmd0aChsZW5ndGgpICYmIGlzSW5kZXgoa2V5LCBsZW5ndGgpICYmXG4gICAgKGlzQXJyYXkob2JqZWN0KSB8fCBpc0FyZ3VtZW50cyhvYmplY3QpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaGFzUGF0aDtcbiIsImltcG9ydCBiYXNlSGFzSW4gZnJvbSAnLi9fYmFzZUhhc0luLmpzJztcbmltcG9ydCBoYXNQYXRoIGZyb20gJy4vX2hhc1BhdGguanMnO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgaXMgYSBkaXJlY3Qgb3IgaW5oZXJpdGVkIHByb3BlcnR5IG9mIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IF8uY3JlYXRlKHsgJ2EnOiBfLmNyZWF0ZSh7ICdiJzogMiB9KSB9KTtcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EuYicpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2InKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGhhc0luKG9iamVjdCwgcGF0aCkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzUGF0aChvYmplY3QsIHBhdGgsIGJhc2VIYXNJbik7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGhhc0luO1xuIiwiaW1wb3J0IGJhc2VJc0VxdWFsIGZyb20gJy4vX2Jhc2VJc0VxdWFsLmpzJztcbmltcG9ydCBnZXQgZnJvbSAnLi9nZXQuanMnO1xuaW1wb3J0IGhhc0luIGZyb20gJy4vaGFzSW4uanMnO1xuaW1wb3J0IGlzS2V5IGZyb20gJy4vX2lzS2V5LmpzJztcbmltcG9ydCBpc1N0cmljdENvbXBhcmFibGUgZnJvbSAnLi9faXNTdHJpY3RDb21wYXJhYmxlLmpzJztcbmltcG9ydCBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSBmcm9tICcuL19tYXRjaGVzU3RyaWN0Q29tcGFyYWJsZS5qcyc7XG5pbXBvcnQgdG9LZXkgZnJvbSAnLi9fdG9LZXkuanMnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc1Byb3BlcnR5YCB3aGljaCBkb2Vzbid0IGNsb25lIGBzcmNWYWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzUHJvcGVydHkocGF0aCwgc3JjVmFsdWUpIHtcbiAgaWYgKGlzS2V5KHBhdGgpICYmIGlzU3RyaWN0Q29tcGFyYWJsZShzcmNWYWx1ZSkpIHtcbiAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUodG9LZXkocGF0aCksIHNyY1ZhbHVlKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIG9ialZhbHVlID0gZ2V0KG9iamVjdCwgcGF0aCk7XG4gICAgcmV0dXJuIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmIG9ialZhbHVlID09PSBzcmNWYWx1ZSlcbiAgICAgID8gaGFzSW4ob2JqZWN0LCBwYXRoKVxuICAgICAgOiBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRyk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VNYXRjaGVzUHJvcGVydHk7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlUHJvcGVydHk7XG4iLCJpbXBvcnQgYmFzZUdldCBmcm9tICcuL19iYXNlR2V0LmpzJztcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VQcm9wZXJ0eWAgd2hpY2ggc3VwcG9ydHMgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VQcm9wZXJ0eURlZXA7XG4iLCJpbXBvcnQgYmFzZVByb3BlcnR5IGZyb20gJy4vX2Jhc2VQcm9wZXJ0eS5qcyc7XG5pbXBvcnQgYmFzZVByb3BlcnR5RGVlcCBmcm9tICcuL19iYXNlUHJvcGVydHlEZWVwLmpzJztcbmltcG9ydCBpc0tleSBmcm9tICcuL19pc0tleS5qcyc7XG5pbXBvcnQgdG9LZXkgZnJvbSAnLi9fdG9LZXkuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBhIGdpdmVuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IFtcbiAqICAgeyAnYSc6IHsgJ2InOiAyIH0gfSxcbiAqICAgeyAnYSc6IHsgJ2InOiAxIH0gfVxuICogXTtcbiAqXG4gKiBfLm1hcChvYmplY3RzLCBfLnByb3BlcnR5KCdhLmInKSk7XG4gKiAvLyA9PiBbMiwgMV1cbiAqXG4gKiBfLm1hcChfLnNvcnRCeShvYmplY3RzLCBfLnByb3BlcnR5KFsnYScsICdiJ10pKSwgJ2EuYicpO1xuICogLy8gPT4gWzEsIDJdXG4gKi9cbmZ1bmN0aW9uIHByb3BlcnR5KHBhdGgpIHtcbiAgcmV0dXJuIGlzS2V5KHBhdGgpID8gYmFzZVByb3BlcnR5KHRvS2V5KHBhdGgpKSA6IGJhc2VQcm9wZXJ0eURlZXAocGF0aCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHByb3BlcnR5O1xuIiwiaW1wb3J0IGJhc2VNYXRjaGVzIGZyb20gJy4vX2Jhc2VNYXRjaGVzLmpzJztcbmltcG9ydCBiYXNlTWF0Y2hlc1Byb3BlcnR5IGZyb20gJy4vX2Jhc2VNYXRjaGVzUHJvcGVydHkuanMnO1xuaW1wb3J0IGlkZW50aXR5IGZyb20gJy4vaWRlbnRpdHkuanMnO1xuaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5LmpzJztcbmltcG9ydCBwcm9wZXJ0eSBmcm9tICcuL3Byb3BlcnR5LmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pdGVyYXRlZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gW3ZhbHVlPV8uaWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGFuIGl0ZXJhdGVlLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBpdGVyYXRlZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUl0ZXJhdGVlKHZhbHVlKSB7XG4gIC8vIERvbid0IHN0b3JlIHRoZSBgdHlwZW9mYCByZXN1bHQgaW4gYSB2YXJpYWJsZSB0byBhdm9pZCBhIEpJVCBidWcgaW4gU2FmYXJpIDkuXG4gIC8vIFNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTU2MDM0IGZvciBtb3JlIGRldGFpbHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBpZGVudGl0eTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpXG4gICAgICA/IGJhc2VNYXRjaGVzUHJvcGVydHkodmFsdWVbMF0sIHZhbHVlWzFdKVxuICAgICAgOiBiYXNlTWF0Y2hlcyh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHByb3BlcnR5KHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUl0ZXJhdGVlO1xuIiwiaW1wb3J0IGJhc2VBc3NpZ25WYWx1ZSBmcm9tICcuL19iYXNlQXNzaWduVmFsdWUuanMnO1xuaW1wb3J0IGJhc2VGb3JPd24gZnJvbSAnLi9fYmFzZUZvck93bi5qcyc7XG5pbXBvcnQgYmFzZUl0ZXJhdGVlIGZyb20gJy4vX2Jhc2VJdGVyYXRlZS5qcyc7XG5cbi8qKlxuICogVGhlIG9wcG9zaXRlIG9mIGBfLm1hcFZhbHVlc2A7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYW4gb2JqZWN0IHdpdGggdGhlXG4gKiBzYW1lIHZhbHVlcyBhcyBgb2JqZWN0YCBhbmQga2V5cyBnZW5lcmF0ZWQgYnkgcnVubmluZyBlYWNoIG93biBlbnVtZXJhYmxlXG4gKiBzdHJpbmcga2V5ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAgdGhydSBgaXRlcmF0ZWVgLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZFxuICogd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwga2V5LCBvYmplY3QpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy44LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgb2JqZWN0LlxuICogQHNlZSBfLm1hcFZhbHVlc1xuICogQGV4YW1wbGVcbiAqXG4gKiBfLm1hcEtleXMoeyAnYSc6IDEsICdiJzogMiB9LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gKiAgIHJldHVybiBrZXkgKyB2YWx1ZTtcbiAqIH0pO1xuICogLy8gPT4geyAnYTEnOiAxLCAnYjInOiAyIH1cbiAqL1xuZnVuY3Rpb24gbWFwS2V5cyhvYmplY3QsIGl0ZXJhdGVlKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgaXRlcmF0ZWUgPSBiYXNlSXRlcmF0ZWUoaXRlcmF0ZWUsIDMpO1xuXG4gIGJhc2VGb3JPd24ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICBiYXNlQXNzaWduVmFsdWUocmVzdWx0LCBpdGVyYXRlZSh2YWx1ZSwga2V5LCBvYmplY3QpLCB2YWx1ZSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBtYXBLZXlzO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgbnVsbGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYG51bGxgLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNOdWxsKG51bGwpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNOdWxsKHZvaWQgMCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc051bGwodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBudWxsO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc051bGw7XG4iLCJpbXBvcnQgeyBpc051bGwgfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IHsgbWFwS2V5cyB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgeyBpc09iamVjdCB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgeyBpc0Jvb2xlYW4gfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IHsgaXNVbmRlZmluZWQgfSBmcm9tICdsb2Rhc2gtZXMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwcmVmaXgoc3ViamVjdCwgcHJlZml4LCBkZWxpbWV0ZXIgPSAnLScpIHtcbiAgICBjb25zdCBwcmVmaXhlciA9ICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIGNvbnN0IHN0cmluZyA9IGtleSB8fCB2YWx1ZTtcblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgcHJlZml4LFxuICAgICAgICAgICAgc3RyaW5nLnJlcGxhY2UobmV3IFJlZ0V4cChgXiR7cHJlZml4fSR7ZGVsaW1ldGVyfT9gKSwgJycpXG4gICAgICAgIF0uam9pbihkZWxpbWV0ZXIpO1xuICAgIH1cblxuICAgIGlmKGlzQm9vbGVhbihzdWJqZWN0KSB8fCBpc051bGwoc3ViamVjdCkgfHwgaXNVbmRlZmluZWQoc3ViamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIHN1YmplY3Q7XG4gICAgfVxuXG4gICAgaWYoaXNPYmplY3Qoc3ViamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIG1hcEtleXMoc3ViamVjdCwgcHJlZml4ZXIpO1xuICAgIH1cblxuICAgIHJldHVybiBwcmVmaXhlcihzdWJqZWN0KTtcbn1cbiIsIjx0ZW1wbGF0ZT5cbiAgICA8ZGl2IHYtc2hvdz1cImlzU2hvd2luZ1wiIGNsYXNzPVwicG9wb3ZlclwiIDpjbGFzcz1cImNsYXNzZXNcIiByb2xlPVwidG9vbHRpcFwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiYXJyb3dcIj48L2Rpdj5cbiAgICAgICAgPHBvcG92ZXItaGVhZGVyIHYtaWY9XCJ0aXRsZVwiIHYtaHRtbD1cInRpdGxlXCIvPlxuICAgICAgICA8cG9wb3Zlci1ib2R5PlxuICAgICAgICAgICAgPGNvbXBvbmVudCB2LWlmPVwiY29udGVudFwiIDppcz1cImNvbnRlbnQuJG9wdGlvbnNcIiB2LWJpbmQ9XCJjb250ZW50LiRvcHRpb25zLnByb3BzRGF0YVwiLz5cbiAgICAgICAgICAgIDxzbG90Lz5cbiAgICAgICAgPC9wb3BvdmVyLWJvZHk+XG4gICAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuLypcbkV2ZW50c1xuRXZlbnQgVHlwZVx0RGVzY3JpcHRpb25cbmNsb3NlLmJzLnBvcG92ZXJcdFRoaXMgZXZlbnQgZmlyZXMgaW1tZWRpYXRlbHkgd2hlbiB0aGUgY2xvc2UgaW5zdGFuY2UgbWV0aG9kIGlzIGNhbGxlZC5cbmNsb3Nlbi5icy5wb3BvdmVyXHRUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIHBvcG92ZXIgaGFzIGJlZW4gbWFkZSB2aXNpYmxlIHRvIHRoZSB1c2VyICh3aWxsIHdhaXQgZm9yIENTUyB0cmFuc2l0aW9ucyB0byBjb21wbGV0ZSkuXG5vcGVuLmJzLnBvcG92ZXJcdFRoaXMgZXZlbnQgaXMgZmlyZWQgaW1tZWRpYXRlbHkgd2hlbiB0aGUgb3BlbiBpbnN0YW5jZSBtZXRob2QgaGFzIGJlZW4gY2FsbGVkLlxuaGlkZGVuLmJzLnBvcG92ZXJcdFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgcG9wb3ZlciBoYXMgZmluaXNoZWQgYmVpbmcgaGlkZGVuIGZyb20gdGhlIHVzZXIgKHdpbGwgd2FpdCBmb3IgQ1NTIHRyYW5zaXRpb25zIHRvIGNvbXBsZXRlKS5cbmluc2VydGVkLmJzLnBvcG92ZXJcdFRoaXMgZXZlbnQgaXMgZmlyZWQgYWZ0ZXIgdGhlIGNsb3NlLmJzLnBvcG92ZXIgZXZlbnQgd2hlbiB0aGUgcG9wb3ZlciB0ZW1wbGF0ZSBoYXMgYmVlbiBhZGRlZCB0byB0aGUgRE9NLlxuJCgnI215UG9wb3ZlcicpLm9uKCdoaWRkZW4uYnMucG9wb3ZlcicsIGZ1bmN0aW9uICgpIHtcbiAgLy8gZG8gc29tZXRoaW5n4oCmXG59KVxuKi9cbmltcG9ydCB7IGVhY2ggfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IHsgaXNTdHJpbmcgfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IFBvcHBlciBmcm9tICdwb3BwZXIuanMnO1xuaW1wb3J0IHByZWZpeCBmcm9tICcuLi8uLi9IZWxwZXJzL1ByZWZpeCc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdwb3BvdmVyJyxcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFwcGx5IGEgQ1NTIGZhZGUgdHJhbnNpdGlvbiB0byB0aGUgcG9wb3ZlclxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGFuaW1hdGlvbjoge1xuICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogT3ZlcmZsb3cgY29uc3RyYWludCBib3VuZGFyeSBvZiB0aGUgcG9wb3Zlci4gQWNjZXB0cyB0aGUgdmFsdWVzIG9mXG4gICAgICAgICAqICd2aWV3cG9ydCcsICd3aW5kb3cnLCAnc2Nyb2xsUGFyZW50Jywgb3IgYW4gSFRNTEVsZW1lbnQgcmVmZXJlbmNlXG4gICAgICAgICAqIChKYXZhU2NyaXB0IG9ubHkpLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiByZWZlciB0byBQb3BwZXIuanMnc1xuICAgICAgICAgKiBwcmV2ZW50T3ZlcmZsb3cgZG9jcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIGJvdW5kYXJ5OiB7XG4gICAgICAgICAgICB0eXBlOiBbU3RyaW5nLCBBcnJheV0sXG4gICAgICAgICAgICBkZWZhdWx0OiAnc2Nyb2xsUGFyZW50JyxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsndmlld3BvcnQnLCAnd2luZG93JywgJ3ZpZXdwb3J0J10uaW5kZXhPZih2YWx1ZSkgIT09IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcHBlbmRzIHRoZSBwb3BvdmVyIHRvIGEgc3BlY2lmaWMgZWxlbWVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogRXhhbXBsZTogY29udGFpbmVyOiAnYm9keScuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgb3B0aW9uIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgaW4gdGhhdCBpdCBhbGxvd3MgeW91IHRvIHBvc2l0aW9uXG4gICAgICAgICAqIHRoZSBwb3BvdmVyIGluIHRoZSBmbG93IG9mIHRoZSBkb2N1bWVudCBuZWFyIHRoZSB0cmlnZ2VyaW5nIGVsZW1lbnQgLVxuICAgICAgICAgKiB3aGljaCB3aWxsIHByZXZlbnQgdGhlIHBvcG92ZXIgZnJvbSBmbG9hdGluZyBhd2F5IGZyb20gdGhldHJpZ2dlcmluZ1xuICAgICAgICAgKiBlbGVtZW50IGR1cmluZyBhIHdpbmRvdyByZXNpemUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd8RWxlbWVudHxCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgY29udGFpbmVyOiB7XG4gICAgICAgICAgICB0eXBlOiBbU3RyaW5nLCBFbGVtZW50LCBCb29sZWFuXSxcbiAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERvZXMgdGhlIHNhbWUgdGhpbmcgYXMgdGhlIGRlZmF1bHQgc2xvdCwgZXhjZXB0IGl0J3MgbWVhbnQgdG8gYmUgdXNlZFxuICAgICAgICAgKiB3aGVuIHVzaW5nIHRoZSAkcG9wb3ZlciBwbHVnaW4gb3IgcHJvZ3JhbW1hdGljYWxseSBpbnN0YW50aWF0ZWQgcG9wb3ZlcnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgICAgICovXG4gICAgICAgIGNvbnRlbnQ6IHtcbiAgICAgICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdWdWVDb21wb25lbnQnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWxheSBjbG9zZWluZyBhbmQgaGlkaW5nIHRoZSBwb3BvdmVyIChtcykgLSBkb2VzIG5vdCBhcHBseSB0byBtYW51YWwgdHJpZ2dlciB0eXBlXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIGEgbnVtYmVyIGlzIHN1cHBsaWVkLCBkZWxheSBpcyBhcHBsaWVkIHRvIGJvdGggb3Blbi9jbG9zZVxuICAgICAgICAgKlxuICAgICAgICAgKiBPYmplY3Qgc3RydWN0dXJlIGlzOiBkZWxheTogeyBcImNsb3NlXCI6IDUwMCwgXCJvcGVuXCI6IDEwMCB9XG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ8T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgZGVsYXk6IHtcbiAgICAgICAgICAgIHR5cGU6IFtOdW1iZXIsIE9iamVjdF0sXG4gICAgICAgICAgICBkZWZhdWx0OiAwXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsbG93IHRvIHNwZWNpZnkgd2hpY2ggcG9zaXRpb24gUG9wcGVyIHdpbGwgdXNlIG9uIGZhbGxiYWNrLiBGb3IgbW9yZVxuICAgICAgICAgKiBpbmZvcm1hdGlvbiByZWZlciB0byBQb3BwZXIuanMncyBiZWhhdmlvciBkb2NzXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd8QXJyYXl9XG4gICAgICAgICAqL1xuICAgICAgICBmYWxsYmFja1BsYWNlbWVudDoge1xuICAgICAgICAgICAgdHlwZTogW1N0cmluZywgQXJyYXldLFxuICAgICAgICAgICAgZGVmYXVsdDogJ2ZsaXAnXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9mZnNldCBvZiB0aGUgcG9wb3ZlciByZWxhdGl2ZSB0byBpdHMgdGFyZ2V0LiBGb3IgbW9yZSBpbmZvcm1hdGlvblxuICAgICAgICAgKiByZWZlciB0byBQb3BwZXIuanMncyBvZmZzZXQgZG9jcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge051bWJlcnxTdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBvZmZzZXQ6IHtcbiAgICAgICAgICAgIHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sXG4gICAgICAgICAgICBkZWZhdWx0OiAwXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhvdyB0byBwb3NpdGlvbiB0aGUgcG9wb3ZlciAtIGF1dG8gfCB0b3AgfCBib3R0b20gfCBsZWZ0IHwgcmlnaHQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFdoZW4gYXV0byBpcyBzcGVjaWZpZWQsIGl0IHdpbGwgZHluYW1pY2FsbHkgcmVvcmllbnQgdGhlIHBvcG92ZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIFdoZW4gYSBmdW5jdGlvbiBpcyB1c2VkIHRvIGRldGVybWluZSB0aGUgcGxhY2VtZW50LCBpdCBpcyBjYWxsZWQgd2l0aFxuICAgICAgICAgKiB0aGUgcG9wb3ZlciBET00gbm9kZSBhcyBpdHMgZmlyc3QgYXJndW1lbnQgYW5kIHRoZSB0cmlnZ2VyaW5nIGVsZW1lbnRcbiAgICAgICAgICogRE9NIG5vZGUgYXMgaXRzIHNlY29uZC4gVGhlIHRoaXMgY29udGV4dCBpcyBzZXQgdG8gdGhlIHBvcG92ZXJcbiAgICAgICAgICogaW5zdGFuY2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd8RnVuY3Rpb259XG4gICAgICAgICAqL1xuICAgICAgICBwbGFjZW1lbnQ6IHtcbiAgICAgICAgICAgIHR5cGU6IFtTdHJpbmcsIEZ1bmN0aW9uXSxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICd0b3AnLFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWydhdXRvJywgJ3RvcCcsICdib3R0b20nLCAnbGVmdCcsICdyaWdodCddLmluZGV4T2YodmFsdWUpICE9PSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhpcyBwcm9wZXJ0eSBpcyBwYXNzZWQsIGl0IHdpbGwgZm9yY2UgdGhlIHBvcG92ZXIgdG8gYmUgdmlzaWJsZVxuICAgICAgICAgKiBieSBkZWZhdWx0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHNob3c6IEJvb2xlYW4sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGEgc2VsZWN0b3IgaXMgcHJvdmlkZWQsIHBvcG92ZXIgb2JqZWN0cyB3aWxsIGJlIGRlbGVnYXRlZCB0byB0aGVcbiAgICAgICAgICogc3BlY2lmaWVkIHRhcmdldHMuIEluIHByYWN0aWNlLCB0aGlzIGlzIHVzZWQgdG8gZW5hYmxlIGR5bmFtaWMgSFRNTFxuICAgICAgICAgKiBjb250ZW50IHRvIGhhdmUgcG9wb3ZlcnMgYWRkZWQuIFNlZSB0aGlzIGFuZCBhbiBpbmZvcm1hdGl2ZSBleGFtcGxlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbnxTdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBzZWxlY3Rvcjoge1xuICAgICAgICAgICAgdHlwZTogW0Jvb2xlYW4sIFN0cmluZ10sXG4gICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGFyZ2V0IGVsZW1lbnQgdXNlZCB0byBwb3NpdGlvbiB0aGUgcG9wb3Zlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge1N0cmluZ3xFbGVtZW50fEJvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0YXJnZXQ6IHtcbiAgICAgICAgICAgIHR5cGU6IFtTdHJpbmcsIEVsZW1lbnQsIEJvb2xlYW5dLFxuICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHBvcG92ZXIgdGl0bGVcbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRpdGxlOiBTdHJpbmcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhvdyBwb3BvdmVyIGlzIHRyaWdnZXJlZCAtIGNsaWNrIHwgaG92ZXIgfCBmb2N1cyB8IG1hbnVhbC4gWW91IG1heVxuICAgICAgICAgKiBwYXNzIG11bHRpcGxlIHRyaWdnZXJzOyBzZXBhcmF0ZSB0aGVtIHdpdGggYSBzcGFjZS4gYG1hbnVhbGAgY2Fubm90XG4gICAgICAgICAqIGJlIGNvbWJpbmVkIHdpdGggYW55IG90aGVyIHRyaWdnZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0cmlnZ2VyOiB7XG4gICAgICAgICAgICB0eXBlOiBbU3RyaW5nLCBBcnJheV0sXG4gICAgICAgICAgICBkZWZhdWx0OiAnY2xpY2snXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBtZXRob2RzOiB7XG5cbiAgICAgICAgb3BlbigpIHtcbiAgICAgICAgICAgIHRoaXMuaXNTaG93aW5nID0gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xvc2UoKSB7XG4gICAgICAgICAgICB0aGlzLmlzU2hvd2luZyA9IHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdG9nZ2xlKCkge1xuICAgICAgICAgICAgaWYoIXRoaXMuaXNTaG93aW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlUG9wcGVyKGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvcHBlcihlbCwgdGhpcy4kZWwsIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgICAgIHBsYWNlbWVudDogdGhpcy5wbGFjZW1lbnQsXG4gICAgICAgICAgICAgICAgbW9kaWZpZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgIGZsaXA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kYXJpZXNFbGVtZW50OiB0aGlzLmNvbnRhaW5lcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlaGF2aW9yOiB0aGlzLmZhbGxiYWNrUGxhY2VtZW50XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlZDogISF0aGlzLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogdGhpcy5vZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgYXJyb3c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3IoJy5hcnJvdycpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRBcnJvd0VsZW1lbnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kZWwucXVlcnlTZWxlY3RvcignLmFycm93Jyk7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBjb21wdXRlZDoge1xuXG4gICAgICAgIGNsYXNzZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJlZml4KHtcbiAgICAgICAgICAgICAgICAndG9wJzogdGhpcy5wbGFjZW1lbnQgPT09ICd0b3AnLFxuICAgICAgICAgICAgICAgICdib3R0b20nOiB0aGlzLnBsYWNlbWVudCA9PT0gJ2JvdHRvbScsXG4gICAgICAgICAgICAgICAgJ2xlZnQnOiB0aGlzLnBsYWNlbWVudCA9PT0gJ2xlZnQnLFxuICAgICAgICAgICAgICAgICdyaWdodCc6IHRoaXMucGxhY2VtZW50ID09PSAncmlnaHQnXG4gICAgICAgICAgICB9LCAnYnMtcG9wb3ZlcicpXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNTaG93aW5nOiB0aGlzLnNob3cgfHwgIXRoaXMudGFyZ2V0XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgYmVmb3JlQ3JlYXRlKCkge1xuICAgICAgICBpZighdGhpcy4kcG9wcGVycykge1xuICAgICAgICAgICAgdGhpcy4kcG9wcGVycyA9IHt9O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1vdW50ZWQoKSB7XG4gICAgICAgIGNvbnN0IGluaXQgPSBlbCA9PiB7XG4gICAgICAgICAgICB0aGlzLiRwb3BwZXJzW2VsXSA9IHtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyOiBpc1N0cmluZyh0aGlzLnRyaWdnZXIpID8gdGhpcy50cmlnZ2VyLnNwbGl0KCcgJykgOiB0aGlzLnRyaWdnZXIsXG4gICAgICAgICAgICAgICAgcG9wcGVyOiB0aGlzLmNyZWF0ZVBvcHBlcihlbCksXG4gICAgICAgICAgICAgICAgZXZlbnQ6IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvZ2dsZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRwb3BwZXJzW2VsXS5wb3BwZXIudXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZWFjaCh0aGlzLiRwb3BwZXJzW2VsXS50cmlnZ2VyLCB0cmlnZ2VyID0+IHtcbiAgICAgICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKHRyaWdnZXIsIHRoaXMuJHBvcHBlcnNbZWxdLmV2ZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmKHRoaXMudGFyZ2V0KSB7XG4gICAgICAgICAgICBpZih0aGlzLnRhcmdldCBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBpbml0KHRoaXMudGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwodGhpcy50YXJnZXQpLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpbml0KGVsKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxufTtcbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICAgIDxkaXYgY2xhc3M9XCJwb3BvdmVyLWJvZHlcIj5cbiAgICAgICAgPHNsb3QvPlxuICAgIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdwb3BvdmVyLWJvZHknXG5cbn07XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgICA8Y29tcG9uZW50IDppcz1cInRhZ1wiIGNsYXNzPVwicG9wb3Zlci1oZWFkZXJcIj5cbiAgICAgICAgPHNsb3QvPlxuICAgIDwvY29tcG9uZW50PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdwb3BvdmVyLWhlYWRlcicsXG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY29tcG9uZW50IEhUTUwgZWxlbWVudFxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGFnOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAnaDMnXG4gICAgICAgIH1cblxuICAgIH1cblxufTtcbjwvc2NyaXB0PlxuIiwiaW1wb3J0IFBvcG92ZXIgZnJvbSAnLi9Qb3BvdmVyJztcbmltcG9ydCBQb3BvdmVyQm9keSBmcm9tICcuL1BvcG92ZXJCb2R5JztcbmltcG9ydCBQb3BvdmVySGVhZGVyIGZyb20gJy4vUG9wb3ZlckhlYWRlcic7XG5pbXBvcnQgVnVlSW5zdGFsbGVyIGZyb20gJy4uLy4uL0hlbHBlcnMvVnVlSW5zdGFsbGVyL1Z1ZUluc3RhbGxlcic7XG5cbmNvbnN0IHBsdWdpbiA9IFZ1ZUluc3RhbGxlci51c2Uoe1xuXG4gICAgaW5zdGFsbChWdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgVnVlSW5zdGFsbGVyLmNvbXBvbmVudHMoe1xuICAgICAgICAgICAgUG9wb3ZlcixcbiAgICAgICAgICAgIFBvcG92ZXJCb2R5LFxuICAgICAgICAgICAgUG9wb3ZlckhlYWRlclxuICAgICAgICB9KTtcbiAgICB9XG5cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBQb3BvdmVyO1xuIiwiaW1wb3J0IHsgaXNPYmplY3QgfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IHsgaXNGdW5jdGlvbiB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgeyBkZWZhdWx0c0RlZXAgfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IGluc3RhbmNlIGZyb20gJy4uLy4uL0hlbHBlcnMvSW5zdGFuY2UnO1xuaW1wb3J0IFBvcG92ZXIgZnJvbSAnLi4vLi4vQ29tcG9uZW50cy9Qb3BvdmVyJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oVnVlLCBvcHRpb25zKSB7XG4gICAgVnVlLnByb3RvdHlwZS4kcG9wb3ZlciA9IGZ1bmN0aW9uKHRhcmdldCwgQ29tcG9uZW50LCBvcHRpb25zKSB7XG4gICAgICAgIGlmKCFpc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIXRhcmdldC4kcG9wb3Zlcikge1xuICAgICAgICAgICAgdGFyZ2V0LiRwb3BvdmVyID0gaW5zdGFuY2UoVnVlLCBQb3BvdmVyLCBkZWZhdWx0c0RlZXAob3B0aW9ucy5wb3BvdmVyLCB7XG4gICAgICAgICAgICAgICAgcHJvcHNEYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBpbnN0YW5jZShWdWUsIENvbXBvbmVudCwgb3B0aW9ucy5jb250ZW50KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgdGFyZ2V0LiRwb3BvdmVyLiRtb3VudChcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH07XG59XG4iLCI8dGVtcGxhdGU+XG4gICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJjbG9zZVwiIGRhdGEtZGlzbWlzcz1cImFsZXJ0XCIgYXJpYS1sYWJlbD1cIkNsb3NlXCIgQGNsaWNrPVwib25DbGlja1wiPlxuICAgICAgICA8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj4mdGltZXM7PC9zcGFuPlxuICAgIDwvYnV0dG9uPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdhbGVydC1jbG9zZScsXG5cbiAgICBtZXRob2RzOiB7XG5cbiAgICAgICAgb25DbGljayhldmVudCkge1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgnY2xpY2snLCBldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgfVxuXG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgICA8aDQgY2xhc3M9XCJhbGVydC1oZWFkaW5nXCI+PHNsb3QvPjwvaDQ+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ2FsZXJ0LWhlYWRpbmcnXG5cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHByZWZpeCBmcm9tICcuLi8uLi9IZWxwZXJzL1ByZWZpeC9QcmVmaXgnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdmFyaWFudCBhdHRyaWJ1dGVcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgdmFyaWFudDoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJ3ByaW1hcnknXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBjb21wdXRlZDoge1xuXG4gICAgICAgIHZhcmlhbnRDbGFzc1ByZWZpeCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRvcHRpb25zLm5hbWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdmFyaWFudENsYXNzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHByZWZpeCh0aGlzLnZhcmlhbnQsIHRoaXMudmFyaWFudENsYXNzUHJlZml4KTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG59XG4iLCI8dGVtcGxhdGU+XG4gICAgPGRpdiBjbGFzcz1cInByb2dyZXNzXCIgOnN0eWxlPVwieydoZWlnaHQnOiBmb3JtYXR0ZWRIZWlnaHR9XCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJwcm9ncmVzcy1iYXJcIiByb2xlPVwicHJvZ3Jlc3NiYXJcIiA6c3R5bGU9XCJ7J3dpZHRoJzogb2Zmc2V0VmFsdWUgKyAnJSd9XCIgOmNsYXNzPVwiJG1lcmdlQ2xhc3Nlcyhwcm9ncmVzc0NsYXNzZXMsIHZhcmlhbnRDbGFzcylcIiA6YXJpYS12YWx1ZW5vdz1cIm9mZnNldFZhbHVlXCIgOmFyaWEtdmFsdWVtaW49XCJtaW5cIiA6YXJpYS12YWx1ZW1heD1cIm1heFwiPlxuICAgICAgICAgICAgPHNwYW4gdi1pZj1cImxhYmVsXCI+e3tvZmZzZXRWYWx1ZX19JTwvc3Bhbj5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IHsgaXNOdW1iZXIgfSBmcm9tICdsb2Rhc2gtZXMnXG5pbXBvcnQgdW5pdCBmcm9tICcuLi8uLi9IZWxwZXJzL1VuaXQnO1xuaW1wb3J0IFZhcmlhbnQgZnJvbSAnLi4vLi4vTWl4aW5zL1ZhcmlhbnQvVmFyaWFudCc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdwcm9ncmVzcy1iYXInLFxuXG4gICAgbWl4aW5zOiBbXG4gICAgICAgIFZhcmlhbnRcbiAgICBdLFxuXG4gICAgcHJvcHM6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHByb2dyZXNzIGJhciBwZXJjZW50YWdlIHZhbHVlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBwcm9ncmVzcyBiYXJcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgaGVpZ2h0OiBbTnVtYmVyLCBTdHJpbmddLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG93IHRoZSBwcm9ncmVzcyBiYXIgdmFsdWUgYXMgYSBsYWJlbCBpbnNpZGUgdGhlIGJhclxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBsYWJlbDogQm9vbGVhbixcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvdWxkIHRoZSBwcm9ncmVzcyBiYXIgYXBwZWFyIHdpdGggc3RyaXBlc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBzdHJpcGVkOiBCb29sZWFuLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG91bGQgdGhlIHByb2dyZXNzIGJhciBhcHBlYXIgd2l0aCBhbmltYXRlZCBzdHJpcGVzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGFuaW1hdGVkOiBCb29sZWFuLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWluaW11bSB2YWx1ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBtaW46IHtcbiAgICAgICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgICAgIGRlZmF1bHQ6IDBcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1heCB2YWx1ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBtYXg6IHtcbiAgICAgICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgICAgIGRlZmF1bHQ6IDEwMFxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgY29tcHV0ZWQ6IHtcblxuICAgICAgICB2YXJpYW50Q2xhc3NQcmVmaXgoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2JnJztcbiAgICAgICAgfSxcblxuICAgICAgICBvZmZzZXRWYWx1ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlIC8gdGhpcy5tYXggKiAxMDA7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZm9ybWF0dGVkSGVpZ2h0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGVpZ2h0ID8gdW5pdCh0aGlzLmhlaWdodCkgOiBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIHByb2dyZXNzQ2xhc3NlcygpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgJ3Byb2dyZXNzLWJhci1zdHJpcGVkJzogdGhpcy5zdHJpcGVkLFxuICAgICAgICAgICAgICAgICdwcm9ncmVzcy1iYXItYW5pbWF0ZWQnOiB0aGlzLmFuaW1hdGVkXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICB9XG5cbn1cblxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgUHJvZ3Jlc3NCYXIgZnJvbSAnLi9Qcm9ncmVzc0Jhcic7XG5pbXBvcnQgVnVlSW5zdGFsbGVyIGZyb20gJy4uLy4uL0hlbHBlcnMvVnVlSW5zdGFsbGVyL1Z1ZUluc3RhbGxlcic7XG5cbmNvbnN0IHBsdWdpbiA9IFZ1ZUluc3RhbGxlci51c2Uoe1xuXG4gICAgaW5zdGFsbChWdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgVnVlSW5zdGFsbGVyLmNvbXBvbmVudHMoe1xuICAgICAgICAgICAgUHJvZ3Jlc3NCYXJcbiAgICAgICAgfSk7XG4gICAgfVxuXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgUHJvZ3Jlc3NCYXI7XG4iLCI8dGVtcGxhdGU+XG4gICAgPGRpdiBjbGFzcz1cImFsZXJ0XCIgOmNsYXNzPVwiJG1lcmdlQ2xhc3Nlcyh2YXJpYW50Q2xhc3MsIHtzaG93OiBpc1Zpc2libGUsIGZhZGU6IGZhZGV9KVwiIHJvbGU9XCJhbGVydFwiPlxuICAgICAgICA8YWxlcnQtaGVhZGluZyB2LWlmPVwidGl0bGUgfHwgaGVhZGluZ1wiPnt7IHRpdGxlIHx8IGhlYWRpbmcgfX08L2FsZXJ0LWhlYWRpbmc+XG4gICAgICAgIDxzbG90Lz5cbiAgICAgICAgPGFsZXJ0LWNsb3NlIHYtaWY9XCJkaXNtaXNzaWJsZVwiIEBjbGljaz1cImRpc21pc3MoKVwiLz5cbiAgICAgICAgPHByb2dyZXNzLWJhciB2LWlmPVwidHlwZW9mIHNob3cgPT09ICdudW1iZXInXCIgOnZhcmlhbnQ9XCJ2YXJpYW50XCIgOmhlaWdodD1cIjVcIiA6dmFsdWU9XCJkaXNtaXNzQ291bnRcIiA6bWF4PVwic2hvd1wiIGNsYXNzPVwibXktM1wiLz5cbiAgICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgQWxlcnRDbG9zZSBmcm9tICcuL0FsZXJ0Q2xvc2UnO1xuaW1wb3J0IEFsZXJ0SGVhZGluZyBmcm9tICcuL0FsZXJ0SGVhZGluZyc7XG5pbXBvcnQgUHJvZ3Jlc3NCYXIgZnJvbSAnLi4vUHJvZ3Jlc3NCYXInO1xuaW1wb3J0IFZhcmlhbnQgZnJvbSAnLi4vLi4vTWl4aW5zL1ZhcmlhbnQvVmFyaWFudCc7XG5pbXBvcnQgdHJhbnNpdGlvbiBmcm9tICcuLi8uLi9IZWxwZXJzL1RyYW5zaXRpb24vVHJhbnNpdGlvbic7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdhbGVydCcsXG5cbiAgICBjb21wb25lbnRzOiB7XG4gICAgICAgIEFsZXJ0Q2xvc2UsXG4gICAgICAgIEFsZXJ0SGVhZGluZyxcbiAgICAgICAgUHJvZ3Jlc3NCYXJcbiAgICB9LFxuXG4gICAgbWl4aW5zOiBbXG4gICAgICAgIFZhcmlhbnRcbiAgICBdLFxuXG4gICAgcHJvcHM6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSXMgdGhlIGFsZXJ0IGRpc21pc3NpYmxlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBCb29sZWFuXG4gICAgICAgICAqL1xuICAgICAgICBkaXNtaXNzaWJsZTogQm9vbGVhbixcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGFsZXJ0J3MgdGl0bGUvaGVhZGluZ1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgQm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgaGVhZGluZzogU3RyaW5nLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYWxlcnQncyB0aXRsZS9oZWFkaW5nXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBCb29sZWFuXG4gICAgICAgICAqL1xuICAgICAgICB0aXRsZTogU3RyaW5nLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG91bGQgdGhlIGFsZXJ0IGZhZGUgd2hlbiBoaWRkZW5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IEJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIGZhZGU6IHtcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgICBkZWZhdWx0OiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3VsZCB0aGUgYWxlcnQgYmUgdmlzaWJsZSBieSBkZWZhdWx0LiBJZiBwYXNzZWQgYSBudW1iZXIsIGFsZXJ0XG4gICAgICAgICAqIHdpbGwgYmUgc2hvd24gZm9yIHRoZSBudW1iZXIgb2Ygc2Vjb25kcyB0aGF0IGFyZSBwYXNzZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBCb29sZWFuXG4gICAgICAgICAqL1xuICAgICAgICBzaG93OiB7XG4gICAgICAgICAgICB0eXBlOiBbTnVtYmVyLCBCb29sZWFuXSxcbiAgICAgICAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIG1ldGhvZHM6IHtcblxuICAgICAgICBkaXNtaXNzKCkge1xuICAgICAgICAgICAgdHJhbnNpdGlvbih0aGlzLiRlbCkudGhlbihkZWxheSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy4kZW1pdCgnZGlzbWlzc2VkJyk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy4kZW1pdCgndXBkYXRlOnZpc2libGUnLCB0aGlzLmlzVmlzaWJsZSA9IGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIG1vdW50ZWQoKSB7XG4gICAgICAgIGlmKHR5cGVvZiB0aGlzLnNob3cgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBjb25zdCBlbCA9IHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3IoJy5wcm9ncmVzcy1iYXInKTtcblxuICAgICAgICAgICAgdGhpcy4kZW1pdCgnZGlzbWlzcy1jb3VudGRvd24nLCB0aGlzLmRpc21pc3NDb3VudCA9IHRoaXMuc2hvdyk7XG5cbiAgICAgICAgICAgIGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2Rpc21pc3MtY291bnRkb3duJywgdGhpcy5kaXNtaXNzQ291bnQgLT0gMSk7XG5cbiAgICAgICAgICAgICAgICBpZighdGhpcy5kaXNtaXNzQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb24oZWwpLnRoZW4oZGVsYXkgPT4gdGhpcy5kaXNtaXNzKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIDEwMDApO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaXNtaXNzQ291bnQ6IHRoaXMuc2hvdyxcbiAgICAgICAgICAgIGlzVmlzaWJsZTogdGhpcy5zaG93XG4gICAgICAgIH1cbiAgICB9XG5cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICAgIDxhIGNsYXNzPVwiYWxlcnQtbGlua1wiPjxzbG90Lz48L2E+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ2FsZXJ0LWxpbmsnXG5cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IEFsZXJ0IGZyb20gJy4vQWxlcnQnO1xuaW1wb3J0IEFsZXJ0TGluayBmcm9tICcuL0FsZXJ0TGluayc7XG5pbXBvcnQgQWxlcnRDbG9zZSBmcm9tICcuL0FsZXJ0Q2xvc2UnO1xuaW1wb3J0IEFsZXJ0SGVhZGluZyBmcm9tICcuL0FsZXJ0SGVhZGluZyc7XG5pbXBvcnQgVnVlSW5zdGFsbGVyIGZyb20gJy4uLy4uL0hlbHBlcnMvVnVlSW5zdGFsbGVyL1Z1ZUluc3RhbGxlcic7XG5cbmNvbnN0IHBsdWdpbiA9IFZ1ZUluc3RhbGxlci51c2Uoe1xuXG4gICAgaW5zdGFsbChWdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgVnVlSW5zdGFsbGVyLmNvbXBvbmVudHMoe1xuICAgICAgICAgICAgQWxlcnQsXG4gICAgICAgICAgICBBbGVydExpbmssXG4gICAgICAgICAgICBBbGVydENsb3NlLFxuICAgICAgICAgICAgQWxlcnRIZWFkaW5nXG4gICAgICAgIH0pO1xuICAgIH1cblxufSk7XG5cbmV4cG9ydCAqIGZyb20gJy4vQWxlcnRMaW5rJztcbmV4cG9ydCAqIGZyb20gJy4vQWxlcnRDbG9zZSc7XG5leHBvcnQgKiBmcm9tICcuL0FsZXJ0SGVhZGluZyc7XG5leHBvcnQgZGVmYXVsdCBBbGVydDtcbiIsIjx0ZW1wbGF0ZT5cbiAgICA8YSB2LWlmPVwiaHJlZlwiIDpocmVmPVwiaHJlZlwiIGNsYXNzPVwiYmFkZ2VcIiA6Y2xhc3M9XCIkbWVyZ2VDbGFzc2VzKGNsYXNzZXMsIHZhcmlhbnRDbGFzcylcIj5cbiAgICAgICAgPHNsb3Q+e3tsYWJlbH19PC9zbG90PlxuICAgICAgICA8c3BhbiBjbGFzcz1cInNyLW9ubHlcIiB2LWh0bWw9XCJhY2Nlc3NpYmlsaXR5XCIvPlxuICAgIDwvYT5cbiAgICA8c3BhbiB2LWVsc2UgY2xhc3M9XCJiYWRnZVwiIDpjbGFzcz1cIiRtZXJnZUNsYXNzZXMoY2xhc3NlcywgdmFyaWFudENsYXNzKVwiPlxuICAgICAgICA8c2xvdD57e2xhYmVsfX08L3Nsb3Q+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwic3Itb25seVwiIHYtaHRtbD1cImFjY2Vzc2liaWxpdHlcIi8+XG4gICAgPC9zcGFuPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cblxuaW1wb3J0IHByZWZpeCBmcm9tICcuLi8uLi9IZWxwZXJzL1ByZWZpeC9QcmVmaXgnO1xuaW1wb3J0IFZhcmlhbnQgZnJvbSAnLi4vLi4vTWl4aW5zL1ZhcmlhbnQvVmFyaWFudCc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdiYWRnZScsXG5cbiAgICBtaXhpbnM6IFtcbiAgICAgICAgVmFyaWFudFxuICAgIF0sXG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc2NyZWVuIHJlYWRlciBhY2Nlc3NpYmlsaXR5IGxhYmVsLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBhY2Nlc3NpYmlsaXR5OiBTdHJpbmcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGFuIGhyZWYgYXR0cmlidXRlIGlzIHBhc3NlZCwgdGhlIGJhZGdlIGJlY29tZXMgYW4gYW5jaG9yLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBocmVmOiBTdHJpbmcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBiYWRnZSBhcHBlYXIgYXMgcGlsbCBzaGFwZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHBpbGw6IEJvb2xlYW4sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBiYWRnZSBsYWJlbC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgbGFiZWw6IFtOdW1iZXIsIFN0cmluZ10sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBiYWRnZSBhcHBlYXIgYXMgc2Vjb25kYXJ5IGluIHNpemUgdG8gdGhlIHBhcmVudCBlbGVtZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBzZWNvbmRhcnk6IEJvb2xlYW5cblxuICAgIH0sXG5cbiAgICBjb21wdXRlZDoge1xuXG4gICAgICAgIGNsYXNzZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJlZml4KHtcbiAgICAgICAgICAgICAgICAncGlsbCc6IHRoaXMucGlsbCxcbiAgICAgICAgICAgICAgICAnc2Vjb25kYXJ5JzogdGhpcy5zZWNvbmRhcnlcbiAgICAgICAgICAgIH0sIHRoaXMuJG9wdGlvbnMubmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IEJhZGdlIGZyb20gJy4vQmFkZ2UnO1xuaW1wb3J0IFZ1ZUluc3RhbGxlciBmcm9tICcuLi8uLi9IZWxwZXJzL1Z1ZUluc3RhbGxlci9WdWVJbnN0YWxsZXInO1xuXG5jb25zdCBwbHVnaW4gPSBWdWVJbnN0YWxsZXIudXNlKHtcblxuICAgIGluc3RhbGwoVnVlLCBvcHRpb25zKSB7XG4gICAgICAgIFZ1ZUluc3RhbGxlci5jb21wb25lbnRzKHtcbiAgICAgICAgICAgIEJhZGdlXG4gICAgICAgIH0pO1xuICAgIH1cblxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IEJhZGdlO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZWR1Y2VgIGFuZCBgXy5yZWR1Y2VSaWdodGAsIHdpdGhvdXQgc3VwcG9ydFxuICogZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMsIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYGNvbGxlY3Rpb25gIHVzaW5nIGBlYWNoRnVuY2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0geyp9IGFjY3VtdWxhdG9yIFRoZSBpbml0aWFsIHZhbHVlLlxuICogQHBhcmFtIHtib29sZWFufSBpbml0QWNjdW0gU3BlY2lmeSB1c2luZyB0aGUgZmlyc3Qgb3IgbGFzdCBlbGVtZW50IG9mXG4gKiAgYGNvbGxlY3Rpb25gIGFzIHRoZSBpbml0aWFsIHZhbHVlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBgY29sbGVjdGlvbmAuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VSZWR1Y2UoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0sIGVhY2hGdW5jKSB7XG4gIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgIGFjY3VtdWxhdG9yID0gaW5pdEFjY3VtXG4gICAgICA/IChpbml0QWNjdW0gPSBmYWxzZSwgdmFsdWUpXG4gICAgICA6IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICB9KTtcbiAgcmV0dXJuIGFjY3VtdWxhdG9yO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlUmVkdWNlO1xuIiwiaW1wb3J0IGFycmF5UmVkdWNlIGZyb20gJy4vX2FycmF5UmVkdWNlLmpzJztcbmltcG9ydCBiYXNlRWFjaCBmcm9tICcuL19iYXNlRWFjaC5qcyc7XG5pbXBvcnQgYmFzZUl0ZXJhdGVlIGZyb20gJy4vX2Jhc2VJdGVyYXRlZS5qcyc7XG5pbXBvcnQgYmFzZVJlZHVjZSBmcm9tICcuL19iYXNlUmVkdWNlLmpzJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5cbi8qKlxuICogUmVkdWNlcyBgY29sbGVjdGlvbmAgdG8gYSB2YWx1ZSB3aGljaCBpcyB0aGUgYWNjdW11bGF0ZWQgcmVzdWx0IG9mIHJ1bm5pbmdcbiAqIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAgdGhydSBgaXRlcmF0ZWVgLCB3aGVyZSBlYWNoIHN1Y2Nlc3NpdmVcbiAqIGludm9jYXRpb24gaXMgc3VwcGxpZWQgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgcHJldmlvdXMuIElmIGBhY2N1bXVsYXRvcmBcbiAqIGlzIG5vdCBnaXZlbiwgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gIGlzIHVzZWQgYXMgdGhlIGluaXRpYWxcbiAqIHZhbHVlLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIGZvdXIgYXJndW1lbnRzOlxuICogKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAqXG4gKiBNYW55IGxvZGFzaCBtZXRob2RzIGFyZSBndWFyZGVkIHRvIHdvcmsgYXMgaXRlcmF0ZWVzIGZvciBtZXRob2RzIGxpa2VcbiAqIGBfLnJlZHVjZWAsIGBfLnJlZHVjZVJpZ2h0YCwgYW5kIGBfLnRyYW5zZm9ybWAuXG4gKlxuICogVGhlIGd1YXJkZWQgbWV0aG9kcyBhcmU6XG4gKiBgYXNzaWduYCwgYGRlZmF1bHRzYCwgYGRlZmF1bHRzRGVlcGAsIGBpbmNsdWRlc2AsIGBtZXJnZWAsIGBvcmRlckJ5YCxcbiAqIGFuZCBgc29ydEJ5YFxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAqIEBzZWUgXy5yZWR1Y2VSaWdodFxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnJlZHVjZShbMSwgMl0sIGZ1bmN0aW9uKHN1bSwgbikge1xuICogICByZXR1cm4gc3VtICsgbjtcbiAqIH0sIDApO1xuICogLy8gPT4gM1xuICpcbiAqIF8ucmVkdWNlKHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMSB9LCBmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAqICAgKHJlc3VsdFt2YWx1ZV0gfHwgKHJlc3VsdFt2YWx1ZV0gPSBbXSkpLnB1c2goa2V5KTtcbiAqICAgcmV0dXJuIHJlc3VsdDtcbiAqIH0sIHt9KTtcbiAqIC8vID0+IHsgJzEnOiBbJ2EnLCAnYyddLCAnMic6IFsnYiddIH0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqL1xuZnVuY3Rpb24gcmVkdWNlKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVJlZHVjZSA6IGJhc2VSZWR1Y2UsXG4gICAgICBpbml0QWNjdW0gPSBhcmd1bWVudHMubGVuZ3RoIDwgMztcblxuICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBiYXNlSXRlcmF0ZWUoaXRlcmF0ZWUsIDQpLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtLCBiYXNlRWFjaCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHJlZHVjZTtcbiIsImltcG9ydCBhc3NpZ25WYWx1ZSBmcm9tICcuL19hc3NpZ25WYWx1ZS5qcyc7XG5pbXBvcnQgY2FzdFBhdGggZnJvbSAnLi9fY2FzdFBhdGguanMnO1xuaW1wb3J0IGlzSW5kZXggZnJvbSAnLi9faXNJbmRleC5qcyc7XG5pbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdC5qcyc7XG5pbXBvcnQgdG9LZXkgZnJvbSAnLi9fdG9LZXkuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNldGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgcGF0aCBjcmVhdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VTZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSwgY3VzdG9taXplcikge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICBsYXN0SW5kZXggPSBsZW5ndGggLSAxLFxuICAgICAgbmVzdGVkID0gb2JqZWN0O1xuXG4gIHdoaWxlIChuZXN0ZWQgIT0gbnVsbCAmJiArK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKSxcbiAgICAgICAgbmV3VmFsdWUgPSB2YWx1ZTtcblxuICAgIGlmIChpbmRleCAhPSBsYXN0SW5kZXgpIHtcbiAgICAgIHZhciBvYmpWYWx1ZSA9IG5lc3RlZFtrZXldO1xuICAgICAgbmV3VmFsdWUgPSBjdXN0b21pemVyID8gY3VzdG9taXplcihvYmpWYWx1ZSwga2V5LCBuZXN0ZWQpIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBpc09iamVjdChvYmpWYWx1ZSlcbiAgICAgICAgICA/IG9ialZhbHVlXG4gICAgICAgICAgOiAoaXNJbmRleChwYXRoW2luZGV4ICsgMV0pID8gW10gOiB7fSk7XG4gICAgICB9XG4gICAgfVxuICAgIGFzc2lnblZhbHVlKG5lc3RlZCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgbmVzdGVkID0gbmVzdGVkW2tleV07XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVNldDtcbiIsImltcG9ydCBiYXNlR2V0IGZyb20gJy4vX2Jhc2VHZXQuanMnO1xuaW1wb3J0IGJhc2VTZXQgZnJvbSAnLi9fYmFzZVNldC5qcyc7XG5pbXBvcnQgY2FzdFBhdGggZnJvbSAnLi9fY2FzdFBhdGguanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mICBgXy5waWNrQnlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7c3RyaW5nW119IHBhdGhzIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBwcm9wZXJ0eS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGJhc2VQaWNrQnkob2JqZWN0LCBwYXRocywgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcGF0aHMubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0ge307XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgcGF0aCA9IHBhdGhzW2luZGV4XSxcbiAgICAgICAgdmFsdWUgPSBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG5cbiAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBwYXRoKSkge1xuICAgICAgYmFzZVNldChyZXN1bHQsIGNhc3RQYXRoKHBhdGgsIG9iamVjdCksIHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVBpY2tCeTtcbiIsImltcG9ydCBhcnJheVB1c2ggZnJvbSAnLi9fYXJyYXlQdXNoLmpzJztcbmltcG9ydCBnZXRQcm90b3R5cGUgZnJvbSAnLi9fZ2V0UHJvdG90eXBlLmpzJztcbmltcG9ydCBnZXRTeW1ib2xzIGZyb20gJy4vX2dldFN5bWJvbHMuanMnO1xuaW1wb3J0IHN0dWJBcnJheSBmcm9tICcuL3N0dWJBcnJheS5qcyc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAqL1xudmFyIGdldFN5bWJvbHNJbiA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgd2hpbGUgKG9iamVjdCkge1xuICAgIGFycmF5UHVzaChyZXN1bHQsIGdldFN5bWJvbHMob2JqZWN0KSk7XG4gICAgb2JqZWN0ID0gZ2V0UHJvdG90eXBlKG9iamVjdCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGdldFN5bWJvbHNJbjtcbiIsImltcG9ydCBiYXNlR2V0QWxsS2V5cyBmcm9tICcuL19iYXNlR2V0QWxsS2V5cy5qcyc7XG5pbXBvcnQgZ2V0U3ltYm9sc0luIGZyb20gJy4vX2dldFN5bWJvbHNJbi5qcyc7XG5pbXBvcnQga2V5c0luIGZyb20gJy4va2V5c0luLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRBbGxLZXlzSW4ob2JqZWN0KSB7XG4gIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNJbiwgZ2V0U3ltYm9sc0luKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0QWxsS2V5c0luO1xuIiwiaW1wb3J0IGFycmF5TWFwIGZyb20gJy4vX2FycmF5TWFwLmpzJztcbmltcG9ydCBiYXNlSXRlcmF0ZWUgZnJvbSAnLi9fYmFzZUl0ZXJhdGVlLmpzJztcbmltcG9ydCBiYXNlUGlja0J5IGZyb20gJy4vX2Jhc2VQaWNrQnkuanMnO1xuaW1wb3J0IGdldEFsbEtleXNJbiBmcm9tICcuL19nZXRBbGxLZXlzSW4uanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBgb2JqZWN0YCBwcm9wZXJ0aWVzIGBwcmVkaWNhdGVgIHJldHVybnNcbiAqIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHR3byBhcmd1bWVudHM6ICh2YWx1ZSwga2V5KS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgcHJvcGVydHkuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogJzInLCAnYyc6IDMgfTtcbiAqXG4gKiBfLnBpY2tCeShvYmplY3QsIF8uaXNOdW1iZXIpO1xuICogLy8gPT4geyAnYSc6IDEsICdjJzogMyB9XG4gKi9cbmZ1bmN0aW9uIHBpY2tCeShvYmplY3QsIHByZWRpY2F0ZSkge1xuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgdmFyIHByb3BzID0gYXJyYXlNYXAoZ2V0QWxsS2V5c0luKG9iamVjdCksIGZ1bmN0aW9uKHByb3ApIHtcbiAgICByZXR1cm4gW3Byb3BdO1xuICB9KTtcbiAgcHJlZGljYXRlID0gYmFzZUl0ZXJhdGVlKHByZWRpY2F0ZSk7XG4gIHJldHVybiBiYXNlUGlja0J5KG9iamVjdCwgcHJvcHMsIGZ1bmN0aW9uKHZhbHVlLCBwYXRoKSB7XG4gICAgcmV0dXJuIHByZWRpY2F0ZSh2YWx1ZSwgcGF0aFswXSk7XG4gIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBwaWNrQnk7XG4iLCJpbXBvcnQgYmFzZUVhY2ggZnJvbSAnLi9fYmFzZUVhY2guanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbHRlcmAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlRmlsdGVyKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSkge1xuICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VGaWx0ZXI7XG4iLCJpbXBvcnQgYXJyYXlGaWx0ZXIgZnJvbSAnLi9fYXJyYXlGaWx0ZXIuanMnO1xuaW1wb3J0IGJhc2VGaWx0ZXIgZnJvbSAnLi9fYmFzZUZpbHRlci5qcyc7XG5pbXBvcnQgYmFzZUl0ZXJhdGVlIGZyb20gJy4vX2Jhc2VJdGVyYXRlZS5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuXG4vKipcbiAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gLCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgYWxsIGVsZW1lbnRzXG4gKiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHRocmVlXG4gKiBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAqXG4gKiAqKk5vdGU6KiogVW5saWtlIGBfLnJlbW92ZWAsIHRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICogQHNlZSBfLnJlamVjdFxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgdXNlcnMgPSBbXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAqIF07XG4gKlxuICogXy5maWx0ZXIodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XG4gKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnXVxuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbHRlcih1c2VycywgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0pO1xuICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmlsdGVyKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnXVxuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maWx0ZXIodXNlcnMsICdhY3RpdmUnKTtcbiAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAqL1xuZnVuY3Rpb24gZmlsdGVyKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUZpbHRlciA6IGJhc2VGaWx0ZXI7XG4gIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGJhc2VJdGVyYXRlZShwcmVkaWNhdGUsIDMpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZmlsdGVyO1xuIiwiaW1wb3J0IGJhc2VQcm9wZXJ0eSBmcm9tICcuL19iYXNlUHJvcGVydHkuanMnO1xuXG4vKipcbiAqIEdldHMgdGhlIHNpemUgb2YgYW4gQVNDSUkgYHN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyBpbnNwZWN0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3RyaW5nIHNpemUuXG4gKi9cbnZhciBhc2NpaVNpemUgPSBiYXNlUHJvcGVydHkoJ2xlbmd0aCcpO1xuXG5leHBvcnQgZGVmYXVsdCBhc2NpaVNpemU7XG4iLCIvKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2hhcmFjdGVyIGNsYXNzZXMuICovXG52YXIgcnNBc3RyYWxSYW5nZSA9ICdcXFxcdWQ4MDAtXFxcXHVkZmZmJyxcbiAgICByc0NvbWJvTWFya3NSYW5nZSA9ICdcXFxcdTAzMDAtXFxcXHUwMzZmJyxcbiAgICByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgPSAnXFxcXHVmZTIwLVxcXFx1ZmUyZicsXG4gICAgcnNDb21ib1N5bWJvbHNSYW5nZSA9ICdcXFxcdTIwZDAtXFxcXHUyMGZmJyxcbiAgICByc0NvbWJvUmFuZ2UgPSByc0NvbWJvTWFya3NSYW5nZSArIHJlQ29tYm9IYWxmTWFya3NSYW5nZSArIHJzQ29tYm9TeW1ib2xzUmFuZ2UsXG4gICAgcnNWYXJSYW5nZSA9ICdcXFxcdWZlMGVcXFxcdWZlMGYnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2FwdHVyZSBncm91cHMuICovXG52YXIgcnNaV0ogPSAnXFxcXHUyMDBkJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHN0cmluZ3Mgd2l0aCBbemVyby13aWR0aCBqb2luZXJzIG9yIGNvZGUgcG9pbnRzIGZyb20gdGhlIGFzdHJhbCBwbGFuZXNdKGh0dHA6Ly9lZXYuZWUvYmxvZy8yMDE1LzA5LzEyL2RhcmstY29ybmVycy1vZi11bmljb2RlLykuICovXG52YXIgcmVIYXNVbmljb2RlID0gUmVnRXhwKCdbJyArIHJzWldKICsgcnNBc3RyYWxSYW5nZSAgKyByc0NvbWJvUmFuZ2UgKyByc1ZhclJhbmdlICsgJ10nKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHN0cmluZ2AgY29udGFpbnMgVW5pY29kZSBzeW1ib2xzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhIHN5bWJvbCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNVbmljb2RlKHN0cmluZykge1xuICByZXR1cm4gcmVIYXNVbmljb2RlLnRlc3Qoc3RyaW5nKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaGFzVW5pY29kZTtcbiIsIi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjaGFyYWN0ZXIgY2xhc3Nlcy4gKi9cbnZhciByc0FzdHJhbFJhbmdlID0gJ1xcXFx1ZDgwMC1cXFxcdWRmZmYnLFxuICAgIHJzQ29tYm9NYXJrc1JhbmdlID0gJ1xcXFx1MDMwMC1cXFxcdTAzNmYnLFxuICAgIHJlQ29tYm9IYWxmTWFya3NSYW5nZSA9ICdcXFxcdWZlMjAtXFxcXHVmZTJmJyxcbiAgICByc0NvbWJvU3ltYm9sc1JhbmdlID0gJ1xcXFx1MjBkMC1cXFxcdTIwZmYnLFxuICAgIHJzQ29tYm9SYW5nZSA9IHJzQ29tYm9NYXJrc1JhbmdlICsgcmVDb21ib0hhbGZNYXJrc1JhbmdlICsgcnNDb21ib1N5bWJvbHNSYW5nZSxcbiAgICByc1ZhclJhbmdlID0gJ1xcXFx1ZmUwZVxcXFx1ZmUwZic7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjYXB0dXJlIGdyb3Vwcy4gKi9cbnZhciByc0FzdHJhbCA9ICdbJyArIHJzQXN0cmFsUmFuZ2UgKyAnXScsXG4gICAgcnNDb21ibyA9ICdbJyArIHJzQ29tYm9SYW5nZSArICddJyxcbiAgICByc0ZpdHogPSAnXFxcXHVkODNjW1xcXFx1ZGZmYi1cXFxcdWRmZmZdJyxcbiAgICByc01vZGlmaWVyID0gJyg/OicgKyByc0NvbWJvICsgJ3wnICsgcnNGaXR6ICsgJyknLFxuICAgIHJzTm9uQXN0cmFsID0gJ1teJyArIHJzQXN0cmFsUmFuZ2UgKyAnXScsXG4gICAgcnNSZWdpb25hbCA9ICcoPzpcXFxcdWQ4M2NbXFxcXHVkZGU2LVxcXFx1ZGRmZl0pezJ9JyxcbiAgICByc1N1cnJQYWlyID0gJ1tcXFxcdWQ4MDAtXFxcXHVkYmZmXVtcXFxcdWRjMDAtXFxcXHVkZmZmXScsXG4gICAgcnNaV0ogPSAnXFxcXHUyMDBkJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIHJlZ2V4ZXMuICovXG52YXIgcmVPcHRNb2QgPSByc01vZGlmaWVyICsgJz8nLFxuICAgIHJzT3B0VmFyID0gJ1snICsgcnNWYXJSYW5nZSArICddPycsXG4gICAgcnNPcHRKb2luID0gJyg/OicgKyByc1pXSiArICcoPzonICsgW3JzTm9uQXN0cmFsLCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyXS5qb2luKCd8JykgKyAnKScgKyByc09wdFZhciArIHJlT3B0TW9kICsgJykqJyxcbiAgICByc1NlcSA9IHJzT3B0VmFyICsgcmVPcHRNb2QgKyByc09wdEpvaW4sXG4gICAgcnNTeW1ib2wgPSAnKD86JyArIFtyc05vbkFzdHJhbCArIHJzQ29tYm8gKyAnPycsIHJzQ29tYm8sIHJzUmVnaW9uYWwsIHJzU3VyclBhaXIsIHJzQXN0cmFsXS5qb2luKCd8JykgKyAnKSc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIFtzdHJpbmcgc3ltYm9sc10oaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtdW5pY29kZSkuICovXG52YXIgcmVVbmljb2RlID0gUmVnRXhwKHJzRml0eiArICcoPz0nICsgcnNGaXR6ICsgJyl8JyArIHJzU3ltYm9sICsgcnNTZXEsICdnJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgc2l6ZSBvZiBhIFVuaWNvZGUgYHN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyBpbnNwZWN0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3RyaW5nIHNpemUuXG4gKi9cbmZ1bmN0aW9uIHVuaWNvZGVTaXplKHN0cmluZykge1xuICB2YXIgcmVzdWx0ID0gcmVVbmljb2RlLmxhc3RJbmRleCA9IDA7XG4gIHdoaWxlIChyZVVuaWNvZGUudGVzdChzdHJpbmcpKSB7XG4gICAgKytyZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdW5pY29kZVNpemU7XG4iLCJpbXBvcnQgYXNjaWlTaXplIGZyb20gJy4vX2FzY2lpU2l6ZS5qcyc7XG5pbXBvcnQgaGFzVW5pY29kZSBmcm9tICcuL19oYXNVbmljb2RlLmpzJztcbmltcG9ydCB1bmljb2RlU2l6ZSBmcm9tICcuL191bmljb2RlU2l6ZS5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgbnVtYmVyIG9mIHN5bWJvbHMgaW4gYHN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3RyaW5nIHNpemUuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1NpemUoc3RyaW5nKSB7XG4gIHJldHVybiBoYXNVbmljb2RlKHN0cmluZylcbiAgICA/IHVuaWNvZGVTaXplKHN0cmluZylcbiAgICA6IGFzY2lpU2l6ZShzdHJpbmcpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzdHJpbmdTaXplO1xuIiwiaW1wb3J0IGJhc2VLZXlzIGZyb20gJy4vX2Jhc2VLZXlzLmpzJztcbmltcG9ydCBnZXRUYWcgZnJvbSAnLi9fZ2V0VGFnLmpzJztcbmltcG9ydCBpc0FycmF5TGlrZSBmcm9tICcuL2lzQXJyYXlMaWtlLmpzJztcbmltcG9ydCBpc1N0cmluZyBmcm9tICcuL2lzU3RyaW5nLmpzJztcbmltcG9ydCBzdHJpbmdTaXplIGZyb20gJy4vX3N0cmluZ1NpemUuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XSc7XG5cbi8qKlxuICogR2V0cyB0aGUgc2l6ZSBvZiBgY29sbGVjdGlvbmAgYnkgcmV0dXJuaW5nIGl0cyBsZW5ndGggZm9yIGFycmF5LWxpa2VcbiAqIHZhbHVlcyBvciB0aGUgbnVtYmVyIG9mIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIGZvciBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbGxlY3Rpb24gc2l6ZS5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5zaXplKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5zaXplKHsgJ2EnOiAxLCAnYic6IDIgfSk7XG4gKiAvLyA9PiAyXG4gKlxuICogXy5zaXplKCdwZWJibGVzJyk7XG4gKiAvLyA9PiA3XG4gKi9cbmZ1bmN0aW9uIHNpemUoY29sbGVjdGlvbikge1xuICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgaWYgKGlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pKSB7XG4gICAgcmV0dXJuIGlzU3RyaW5nKGNvbGxlY3Rpb24pID8gc3RyaW5nU2l6ZShjb2xsZWN0aW9uKSA6IGNvbGxlY3Rpb24ubGVuZ3RoO1xuICB9XG4gIHZhciB0YWcgPSBnZXRUYWcoY29sbGVjdGlvbik7XG4gIGlmICh0YWcgPT0gbWFwVGFnIHx8IHRhZyA9PSBzZXRUYWcpIHtcbiAgICByZXR1cm4gY29sbGVjdGlvbi5zaXplO1xuICB9XG4gIHJldHVybiBiYXNlS2V5cyhjb2xsZWN0aW9uKS5sZW5ndGg7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHNpemU7XG4iLCJpbXBvcnQgYmFzZUVhY2ggZnJvbSAnLi9fYmFzZUVhY2guanMnO1xuaW1wb3J0IGlzQXJyYXlMaWtlIGZyb20gJy4vaXNBcnJheUxpa2UuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hcGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlTWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gaXNBcnJheUxpa2UoY29sbGVjdGlvbikgPyBBcnJheShjb2xsZWN0aW9uLmxlbmd0aCkgOiBbXTtcblxuICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gaXRlcmF0ZWUodmFsdWUsIGtleSwgY29sbGVjdGlvbik7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlTWFwO1xuIiwiaW1wb3J0IGFycmF5TWFwIGZyb20gJy4vX2FycmF5TWFwLmpzJztcbmltcG9ydCBiYXNlSXRlcmF0ZWUgZnJvbSAnLi9fYmFzZUl0ZXJhdGVlLmpzJztcbmltcG9ydCBiYXNlTWFwIGZyb20gJy4vX2Jhc2VNYXAuanMnO1xuaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5LmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHZhbHVlcyBieSBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAgdGhydVxuICogYGl0ZXJhdGVlYC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gKiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gKlxuICogTWFueSBsb2Rhc2ggbWV0aG9kcyBhcmUgZ3VhcmRlZCB0byB3b3JrIGFzIGl0ZXJhdGVlcyBmb3IgbWV0aG9kcyBsaWtlXG4gKiBgXy5ldmVyeWAsIGBfLmZpbHRlcmAsIGBfLm1hcGAsIGBfLm1hcFZhbHVlc2AsIGBfLnJlamVjdGAsIGFuZCBgXy5zb21lYC5cbiAqXG4gKiBUaGUgZ3VhcmRlZCBtZXRob2RzIGFyZTpcbiAqIGBhcnlgLCBgY2h1bmtgLCBgY3VycnlgLCBgY3VycnlSaWdodGAsIGBkcm9wYCwgYGRyb3BSaWdodGAsIGBldmVyeWAsXG4gKiBgZmlsbGAsIGBpbnZlcnRgLCBgcGFyc2VJbnRgLCBgcmFuZG9tYCwgYHJhbmdlYCwgYHJhbmdlUmlnaHRgLCBgcmVwZWF0YCxcbiAqIGBzYW1wbGVTaXplYCwgYHNsaWNlYCwgYHNvbWVgLCBgc29ydEJ5YCwgYHNwbGl0YCwgYHRha2VgLCBgdGFrZVJpZ2h0YCxcbiAqIGB0ZW1wbGF0ZWAsIGB0cmltYCwgYHRyaW1FbmRgLCBgdHJpbVN0YXJ0YCwgYW5kIGB3b3Jkc2BcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gKiAgIHJldHVybiBuICogbjtcbiAqIH1cbiAqXG4gKiBfLm1hcChbNCwgOF0sIHNxdWFyZSk7XG4gKiAvLyA9PiBbMTYsIDY0XVxuICpcbiAqIF8ubWFwKHsgJ2EnOiA0LCAnYic6IDggfSwgc3F1YXJlKTtcbiAqIC8vID0+IFsxNiwgNjRdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogdmFyIHVzZXJzID0gW1xuICogICB7ICd1c2VyJzogJ2Jhcm5leScgfSxcbiAqICAgeyAndXNlcic6ICdmcmVkJyB9XG4gKiBdO1xuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5tYXAodXNlcnMsICd1c2VyJyk7XG4gKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAqL1xuZnVuY3Rpb24gbWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5TWFwIDogYmFzZU1hcDtcbiAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgYmFzZUl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1hcDtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2xpY2VgIHdpdGhvdXQgYW4gaXRlcmF0ZWUgY2FsbCBndWFyZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNsaWNlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VTbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAtc3RhcnQgPiBsZW5ndGggPyAwIDogKGxlbmd0aCArIHN0YXJ0KTtcbiAgfVxuICBlbmQgPSBlbmQgPiBsZW5ndGggPyBsZW5ndGggOiBlbmQ7XG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlbmd0aDtcbiAgfVxuICBsZW5ndGggPSBzdGFydCA+IGVuZCA/IDAgOiAoKGVuZCAtIHN0YXJ0KSA+Pj4gMCk7XG4gIHN0YXJ0ID4+Pj0gMDtcblxuICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gYXJyYXlbaW5kZXggKyBzdGFydF07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVNsaWNlO1xuIiwiaW1wb3J0IGJhc2VTbGljZSBmcm9tICcuL19iYXNlU2xpY2UuanMnO1xuXG4vKipcbiAqIENhc3RzIGBhcnJheWAgdG8gYSBzbGljZSBpZiBpdCdzIG5lZWRlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IHNsaWNlLlxuICovXG5mdW5jdGlvbiBjYXN0U2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiBlbmQ7XG4gIHJldHVybiAoIXN0YXJ0ICYmIGVuZCA+PSBsZW5ndGgpID8gYXJyYXkgOiBiYXNlU2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjYXN0U2xpY2U7XG4iLCIvKipcbiAqIENvbnZlcnRzIGFuIEFTQ0lJIGBzdHJpbmdgIHRvIGFuIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhc2NpaVRvQXJyYXkoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcuc3BsaXQoJycpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBhc2NpaVRvQXJyYXk7XG4iLCIvKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2hhcmFjdGVyIGNsYXNzZXMuICovXG52YXIgcnNBc3RyYWxSYW5nZSA9ICdcXFxcdWQ4MDAtXFxcXHVkZmZmJyxcbiAgICByc0NvbWJvTWFya3NSYW5nZSA9ICdcXFxcdTAzMDAtXFxcXHUwMzZmJyxcbiAgICByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgPSAnXFxcXHVmZTIwLVxcXFx1ZmUyZicsXG4gICAgcnNDb21ib1N5bWJvbHNSYW5nZSA9ICdcXFxcdTIwZDAtXFxcXHUyMGZmJyxcbiAgICByc0NvbWJvUmFuZ2UgPSByc0NvbWJvTWFya3NSYW5nZSArIHJlQ29tYm9IYWxmTWFya3NSYW5nZSArIHJzQ29tYm9TeW1ib2xzUmFuZ2UsXG4gICAgcnNWYXJSYW5nZSA9ICdcXFxcdWZlMGVcXFxcdWZlMGYnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2FwdHVyZSBncm91cHMuICovXG52YXIgcnNBc3RyYWwgPSAnWycgKyByc0FzdHJhbFJhbmdlICsgJ10nLFxuICAgIHJzQ29tYm8gPSAnWycgKyByc0NvbWJvUmFuZ2UgKyAnXScsXG4gICAgcnNGaXR6ID0gJ1xcXFx1ZDgzY1tcXFxcdWRmZmItXFxcXHVkZmZmXScsXG4gICAgcnNNb2RpZmllciA9ICcoPzonICsgcnNDb21ibyArICd8JyArIHJzRml0eiArICcpJyxcbiAgICByc05vbkFzdHJhbCA9ICdbXicgKyByc0FzdHJhbFJhbmdlICsgJ10nLFxuICAgIHJzUmVnaW9uYWwgPSAnKD86XFxcXHVkODNjW1xcXFx1ZGRlNi1cXFxcdWRkZmZdKXsyfScsXG4gICAgcnNTdXJyUGFpciA9ICdbXFxcXHVkODAwLVxcXFx1ZGJmZl1bXFxcXHVkYzAwLVxcXFx1ZGZmZl0nLFxuICAgIHJzWldKID0gJ1xcXFx1MjAwZCc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSByZWdleGVzLiAqL1xudmFyIHJlT3B0TW9kID0gcnNNb2RpZmllciArICc/JyxcbiAgICByc09wdFZhciA9ICdbJyArIHJzVmFyUmFuZ2UgKyAnXT8nLFxuICAgIHJzT3B0Sm9pbiA9ICcoPzonICsgcnNaV0ogKyAnKD86JyArIFtyc05vbkFzdHJhbCwgcnNSZWdpb25hbCwgcnNTdXJyUGFpcl0uam9pbignfCcpICsgJyknICsgcnNPcHRWYXIgKyByZU9wdE1vZCArICcpKicsXG4gICAgcnNTZXEgPSByc09wdFZhciArIHJlT3B0TW9kICsgcnNPcHRKb2luLFxuICAgIHJzU3ltYm9sID0gJyg/OicgKyBbcnNOb25Bc3RyYWwgKyByc0NvbWJvICsgJz8nLCByc0NvbWJvLCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyLCByc0FzdHJhbF0uam9pbignfCcpICsgJyknO1xuXG4vKiogVXNlZCB0byBtYXRjaCBbc3RyaW5nIHN5bWJvbHNdKGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LXVuaWNvZGUpLiAqL1xudmFyIHJlVW5pY29kZSA9IFJlZ0V4cChyc0ZpdHogKyAnKD89JyArIHJzRml0eiArICcpfCcgKyByc1N5bWJvbCArIHJzU2VxLCAnZycpO1xuXG4vKipcbiAqIENvbnZlcnRzIGEgVW5pY29kZSBgc3RyaW5nYCB0byBhbiBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gdW5pY29kZVRvQXJyYXkoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcubWF0Y2gocmVVbmljb2RlKSB8fCBbXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdW5pY29kZVRvQXJyYXk7XG4iLCJpbXBvcnQgYXNjaWlUb0FycmF5IGZyb20gJy4vX2FzY2lpVG9BcnJheS5qcyc7XG5pbXBvcnQgaGFzVW5pY29kZSBmcm9tICcuL19oYXNVbmljb2RlLmpzJztcbmltcG9ydCB1bmljb2RlVG9BcnJheSBmcm9tICcuL191bmljb2RlVG9BcnJheS5qcyc7XG5cbi8qKlxuICogQ29udmVydHMgYHN0cmluZ2AgdG8gYW4gYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1RvQXJyYXkoc3RyaW5nKSB7XG4gIHJldHVybiBoYXNVbmljb2RlKHN0cmluZylcbiAgICA/IHVuaWNvZGVUb0FycmF5KHN0cmluZylcbiAgICA6IGFzY2lpVG9BcnJheShzdHJpbmcpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzdHJpbmdUb0FycmF5O1xuIiwiaW1wb3J0IGNhc3RTbGljZSBmcm9tICcuL19jYXN0U2xpY2UuanMnO1xuaW1wb3J0IGhhc1VuaWNvZGUgZnJvbSAnLi9faGFzVW5pY29kZS5qcyc7XG5pbXBvcnQgc3RyaW5nVG9BcnJheSBmcm9tICcuL19zdHJpbmdUb0FycmF5LmpzJztcbmltcG9ydCB0b1N0cmluZyBmcm9tICcuL3RvU3RyaW5nLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5sb3dlckZpcnN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWUgVGhlIG5hbWUgb2YgdGhlIGBTdHJpbmdgIGNhc2UgbWV0aG9kIHRvIHVzZS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhc2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNhc2VGaXJzdChtZXRob2ROYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuXG4gICAgdmFyIHN0clN5bWJvbHMgPSBoYXNVbmljb2RlKHN0cmluZylcbiAgICAgID8gc3RyaW5nVG9BcnJheShzdHJpbmcpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIHZhciBjaHIgPSBzdHJTeW1ib2xzXG4gICAgICA/IHN0clN5bWJvbHNbMF1cbiAgICAgIDogc3RyaW5nLmNoYXJBdCgwKTtcblxuICAgIHZhciB0cmFpbGluZyA9IHN0clN5bWJvbHNcbiAgICAgID8gY2FzdFNsaWNlKHN0clN5bWJvbHMsIDEpLmpvaW4oJycpXG4gICAgICA6IHN0cmluZy5zbGljZSgxKTtcblxuICAgIHJldHVybiBjaHJbbWV0aG9kTmFtZV0oKSArIHRyYWlsaW5nO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVDYXNlRmlyc3Q7XG4iLCJpbXBvcnQgY3JlYXRlQ2FzZUZpcnN0IGZyb20gJy4vX2NyZWF0ZUNhc2VGaXJzdC5qcyc7XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBgc3RyaW5nYCB0byB1cHBlciBjYXNlLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnVwcGVyRmlyc3QoJ2ZyZWQnKTtcbiAqIC8vID0+ICdGcmVkJ1xuICpcbiAqIF8udXBwZXJGaXJzdCgnRlJFRCcpO1xuICogLy8gPT4gJ0ZSRUQnXG4gKi9cbnZhciB1cHBlckZpcnN0ID0gY3JlYXRlQ2FzZUZpcnN0KCd0b1VwcGVyQ2FzZScpO1xuXG5leHBvcnQgZGVmYXVsdCB1cHBlckZpcnN0O1xuIiwiaW1wb3J0IHRvU3RyaW5nIGZyb20gJy4vdG9TdHJpbmcuanMnO1xuaW1wb3J0IHVwcGVyRmlyc3QgZnJvbSAnLi91cHBlckZpcnN0LmpzJztcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGBzdHJpbmdgIHRvIHVwcGVyIGNhc2UgYW5kIHRoZSByZW1haW5pbmdcbiAqIHRvIGxvd2VyIGNhc2UuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY2FwaXRhbGl6ZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNhcGl0YWxpemVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5jYXBpdGFsaXplKCdGUkVEJyk7XG4gKiAvLyA9PiAnRnJlZCdcbiAqL1xuZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHJpbmcpIHtcbiAgcmV0dXJuIHVwcGVyRmlyc3QodG9TdHJpbmcoc3RyaW5nKS50b0xvd2VyQ2FzZSgpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2FwaXRhbGl6ZTtcbiIsImltcG9ydCBjYXBpdGFsaXplIGZyb20gJy4vY2FwaXRhbGl6ZS5qcyc7XG5pbXBvcnQgY3JlYXRlQ29tcG91bmRlciBmcm9tICcuL19jcmVhdGVDb21wb3VuZGVyLmpzJztcblxuLyoqXG4gKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBbY2FtZWwgY2FzZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2FtZWxDYXNlKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY2FtZWwgY2FzZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmNhbWVsQ2FzZSgnRm9vIEJhcicpO1xuICogLy8gPT4gJ2Zvb0JhcidcbiAqXG4gKiBfLmNhbWVsQ2FzZSgnLS1mb28tYmFyLS0nKTtcbiAqIC8vID0+ICdmb29CYXInXG4gKlxuICogXy5jYW1lbENhc2UoJ19fRk9PX0JBUl9fJyk7XG4gKiAvLyA9PiAnZm9vQmFyJ1xuICovXG52YXIgY2FtZWxDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gIHdvcmQgPSB3b3JkLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyBjYXBpdGFsaXplKHdvcmQpIDogd29yZCk7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgY2FtZWxDYXNlO1xuIiwiaW1wb3J0IGNvcHlPYmplY3QgZnJvbSAnLi9fY29weU9iamVjdC5qcyc7XG5pbXBvcnQga2V5cyBmcm9tICcuL2tleXMuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbmAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzXG4gKiBvciBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnbihvYmplY3QsIHNvdXJjZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VBc3NpZ247XG4iLCJpbXBvcnQgY29weU9iamVjdCBmcm9tICcuL19jb3B5T2JqZWN0LmpzJztcbmltcG9ydCBrZXlzSW4gZnJvbSAnLi9rZXlzSW4uanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbkluYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXNcbiAqIG9yIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduSW4ob2JqZWN0LCBzb3VyY2UpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBjb3B5T2JqZWN0KHNvdXJjZSwga2V5c0luKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VBc3NpZ25JbjtcbiIsImltcG9ydCBjb3B5T2JqZWN0IGZyb20gJy4vX2NvcHlPYmplY3QuanMnO1xuaW1wb3J0IGdldFN5bWJvbHMgZnJvbSAnLi9fZ2V0U3ltYm9scy5qcyc7XG5cbi8qKlxuICogQ29waWVzIG93biBzeW1ib2xzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIGZyb20uXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgdG8uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5U3ltYm9scyhzb3VyY2UsIG9iamVjdCkge1xuICByZXR1cm4gY29weU9iamVjdChzb3VyY2UsIGdldFN5bWJvbHMoc291cmNlKSwgb2JqZWN0KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY29weVN5bWJvbHM7XG4iLCJpbXBvcnQgY29weU9iamVjdCBmcm9tICcuL19jb3B5T2JqZWN0LmpzJztcbmltcG9ydCBnZXRTeW1ib2xzSW4gZnJvbSAnLi9fZ2V0U3ltYm9sc0luLmpzJztcblxuLyoqXG4gKiBDb3BpZXMgb3duIGFuZCBpbmhlcml0ZWQgc3ltYm9scyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyBmcm9tLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIHRvLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weVN5bWJvbHNJbihzb3VyY2UsIG9iamVjdCkge1xuICByZXR1cm4gY29weU9iamVjdChzb3VyY2UsIGdldFN5bWJvbHNJbihzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjb3B5U3ltYm9sc0luO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBhcnJheSBjbG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNsb25lLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lQXJyYXkoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IG5ldyBhcnJheS5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gIC8vIEFkZCBwcm9wZXJ0aWVzIGFzc2lnbmVkIGJ5IGBSZWdFeHAjZXhlY2AuXG4gIGlmIChsZW5ndGggJiYgdHlwZW9mIGFycmF5WzBdID09ICdzdHJpbmcnICYmIGhhc093blByb3BlcnR5LmNhbGwoYXJyYXksICdpbmRleCcpKSB7XG4gICAgcmVzdWx0LmluZGV4ID0gYXJyYXkuaW5kZXg7XG4gICAgcmVzdWx0LmlucHV0ID0gYXJyYXkuaW5wdXQ7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaW5pdENsb25lQXJyYXk7XG4iLCJpbXBvcnQgY2xvbmVBcnJheUJ1ZmZlciBmcm9tICcuL19jbG9uZUFycmF5QnVmZmVyLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGRhdGFWaWV3YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFWaWV3IFRoZSBkYXRhIHZpZXcgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIGRhdGEgdmlldy5cbiAqL1xuZnVuY3Rpb24gY2xvbmVEYXRhVmlldyhkYXRhVmlldywgaXNEZWVwKSB7XG4gIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKGRhdGFWaWV3LmJ1ZmZlcikgOiBkYXRhVmlldy5idWZmZXI7XG4gIHJldHVybiBuZXcgZGF0YVZpZXcuY29uc3RydWN0b3IoYnVmZmVyLCBkYXRhVmlldy5ieXRlT2Zmc2V0LCBkYXRhVmlldy5ieXRlTGVuZ3RoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xvbmVEYXRhVmlldztcbiIsIi8qKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgIGZsYWdzIGZyb20gdGhlaXIgY29lcmNlZCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlRmxhZ3MgPSAvXFx3KiQvO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgcmVnZXhwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHJlZ2V4cCBUaGUgcmVnZXhwIHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHJlZ2V4cC5cbiAqL1xuZnVuY3Rpb24gY2xvbmVSZWdFeHAocmVnZXhwKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgcmVnZXhwLmNvbnN0cnVjdG9yKHJlZ2V4cC5zb3VyY2UsIHJlRmxhZ3MuZXhlYyhyZWdleHApKTtcbiAgcmVzdWx0Lmxhc3RJbmRleCA9IHJlZ2V4cC5sYXN0SW5kZXg7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsb25lUmVnRXhwO1xuIiwiaW1wb3J0IFN5bWJvbCBmcm9tICcuL19TeW1ib2wuanMnO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIGBzeW1ib2xgIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHN5bWJvbCBUaGUgc3ltYm9sIG9iamVjdCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBzeW1ib2wgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBjbG9uZVN5bWJvbChzeW1ib2wpIHtcbiAgcmV0dXJuIHN5bWJvbFZhbHVlT2YgPyBPYmplY3Qoc3ltYm9sVmFsdWVPZi5jYWxsKHN5bWJvbCkpIDoge307XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsb25lU3ltYm9sO1xuIiwiaW1wb3J0IGNsb25lQXJyYXlCdWZmZXIgZnJvbSAnLi9fY2xvbmVBcnJheUJ1ZmZlci5qcyc7XG5pbXBvcnQgY2xvbmVEYXRhVmlldyBmcm9tICcuL19jbG9uZURhdGFWaWV3LmpzJztcbmltcG9ydCBjbG9uZVJlZ0V4cCBmcm9tICcuL19jbG9uZVJlZ0V4cC5qcyc7XG5pbXBvcnQgY2xvbmVTeW1ib2wgZnJvbSAnLi9fY2xvbmVTeW1ib2wuanMnO1xuaW1wb3J0IGNsb25lVHlwZWRBcnJheSBmcm9tICcuL19jbG9uZVR5cGVkQXJyYXkuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUgYmFzZWQgb24gaXRzIGB0b1N0cmluZ1RhZ2AuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjbG9uaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTWFwYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBgU2V0YCwgb3IgYFN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lQnlUYWcob2JqZWN0LCB0YWcsIGlzRGVlcCkge1xuICB2YXIgQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgcmV0dXJuIGNsb25lQXJyYXlCdWZmZXIob2JqZWN0KTtcblxuICAgIGNhc2UgYm9vbFRhZzpcbiAgICBjYXNlIGRhdGVUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3IoK29iamVjdCk7XG5cbiAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgcmV0dXJuIGNsb25lRGF0YVZpZXcob2JqZWN0LCBpc0RlZXApO1xuXG4gICAgY2FzZSBmbG9hdDMyVGFnOiBjYXNlIGZsb2F0NjRUYWc6XG4gICAgY2FzZSBpbnQ4VGFnOiBjYXNlIGludDE2VGFnOiBjYXNlIGludDMyVGFnOlxuICAgIGNhc2UgdWludDhUYWc6IGNhc2UgdWludDhDbGFtcGVkVGFnOiBjYXNlIHVpbnQxNlRhZzogY2FzZSB1aW50MzJUYWc6XG4gICAgICByZXR1cm4gY2xvbmVUeXBlZEFycmF5KG9iamVjdCwgaXNEZWVwKTtcblxuICAgIGNhc2UgbWFwVGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yO1xuXG4gICAgY2FzZSBudW1iZXJUYWc6XG4gICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3Iob2JqZWN0KTtcblxuICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgICAgcmV0dXJuIGNsb25lUmVnRXhwKG9iamVjdCk7XG5cbiAgICBjYXNlIHNldFRhZzpcbiAgICAgIHJldHVybiBuZXcgQ3RvcjtcblxuICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgcmV0dXJuIGNsb25lU3ltYm9sKG9iamVjdCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgaW5pdENsb25lQnlUYWc7XG4iLCJpbXBvcnQgZ2V0VGFnIGZyb20gJy4vX2dldFRhZy5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWFwYCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG1hcCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNNYXAodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgZ2V0VGFnKHZhbHVlKSA9PSBtYXBUYWc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VJc01hcDtcbiIsImltcG9ydCBiYXNlSXNNYXAgZnJvbSAnLi9fYmFzZUlzTWFwLmpzJztcbmltcG9ydCBiYXNlVW5hcnkgZnJvbSAnLi9fYmFzZVVuYXJ5LmpzJztcbmltcG9ydCBub2RlVXRpbCBmcm9tICcuL19ub2RlVXRpbC5qcyc7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzTWFwID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNNYXA7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBNYXBgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG1hcCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTWFwKG5ldyBNYXApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNNYXAobmV3IFdlYWtNYXApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzTWFwID0gbm9kZUlzTWFwID8gYmFzZVVuYXJ5KG5vZGVJc01hcCkgOiBiYXNlSXNNYXA7XG5cbmV4cG9ydCBkZWZhdWx0IGlzTWFwO1xuIiwiaW1wb3J0IGdldFRhZyBmcm9tICcuL19nZXRUYWcuanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzZXRUYWcgPSAnW29iamVjdCBTZXRdJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1NldGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzZXQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzU2V0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gc2V0VGFnO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlSXNTZXQ7XG4iLCJpbXBvcnQgYmFzZUlzU2V0IGZyb20gJy4vX2Jhc2VJc1NldC5qcyc7XG5pbXBvcnQgYmFzZVVuYXJ5IGZyb20gJy4vX2Jhc2VVbmFyeS5qcyc7XG5pbXBvcnQgbm9kZVV0aWwgZnJvbSAnLi9fbm9kZVV0aWwuanMnO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1NldCA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzU2V0O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU2V0YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzZXQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1NldChuZXcgU2V0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU2V0KG5ldyBXZWFrU2V0KTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1NldCA9IG5vZGVJc1NldCA/IGJhc2VVbmFyeShub2RlSXNTZXQpIDogYmFzZUlzU2V0O1xuXG5leHBvcnQgZGVmYXVsdCBpc1NldDtcbiIsImltcG9ydCBTdGFjayBmcm9tICcuL19TdGFjay5qcyc7XG5pbXBvcnQgYXJyYXlFYWNoIGZyb20gJy4vX2FycmF5RWFjaC5qcyc7XG5pbXBvcnQgYXNzaWduVmFsdWUgZnJvbSAnLi9fYXNzaWduVmFsdWUuanMnO1xuaW1wb3J0IGJhc2VBc3NpZ24gZnJvbSAnLi9fYmFzZUFzc2lnbi5qcyc7XG5pbXBvcnQgYmFzZUFzc2lnbkluIGZyb20gJy4vX2Jhc2VBc3NpZ25Jbi5qcyc7XG5pbXBvcnQgY2xvbmVCdWZmZXIgZnJvbSAnLi9fY2xvbmVCdWZmZXIuanMnO1xuaW1wb3J0IGNvcHlBcnJheSBmcm9tICcuL19jb3B5QXJyYXkuanMnO1xuaW1wb3J0IGNvcHlTeW1ib2xzIGZyb20gJy4vX2NvcHlTeW1ib2xzLmpzJztcbmltcG9ydCBjb3B5U3ltYm9sc0luIGZyb20gJy4vX2NvcHlTeW1ib2xzSW4uanMnO1xuaW1wb3J0IGdldEFsbEtleXMgZnJvbSAnLi9fZ2V0QWxsS2V5cy5qcyc7XG5pbXBvcnQgZ2V0QWxsS2V5c0luIGZyb20gJy4vX2dldEFsbEtleXNJbi5qcyc7XG5pbXBvcnQgZ2V0VGFnIGZyb20gJy4vX2dldFRhZy5qcyc7XG5pbXBvcnQgaW5pdENsb25lQXJyYXkgZnJvbSAnLi9faW5pdENsb25lQXJyYXkuanMnO1xuaW1wb3J0IGluaXRDbG9uZUJ5VGFnIGZyb20gJy4vX2luaXRDbG9uZUJ5VGFnLmpzJztcbmltcG9ydCBpbml0Q2xvbmVPYmplY3QgZnJvbSAnLi9faW5pdENsb25lT2JqZWN0LmpzJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5pbXBvcnQgaXNCdWZmZXIgZnJvbSAnLi9pc0J1ZmZlci5qcyc7XG5pbXBvcnQgaXNNYXAgZnJvbSAnLi9pc01hcC5qcyc7XG5pbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdC5qcyc7XG5pbXBvcnQgaXNTZXQgZnJvbSAnLi9pc1NldC5qcyc7XG5pbXBvcnQga2V5cyBmcm9tICcuL2tleXMuanMnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xudmFyIENMT05FX0RFRVBfRkxBRyA9IDEsXG4gICAgQ0xPTkVfRkxBVF9GTEFHID0gMixcbiAgICBDTE9ORV9TWU1CT0xTX0ZMQUcgPSA0O1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIHN1cHBvcnRlZCBieSBgXy5jbG9uZWAuICovXG52YXIgY2xvbmVhYmxlVGFncyA9IHt9O1xuY2xvbmVhYmxlVGFnc1thcmdzVGFnXSA9IGNsb25lYWJsZVRhZ3NbYXJyYXlUYWddID1cbmNsb25lYWJsZVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gY2xvbmVhYmxlVGFnc1tkYXRhVmlld1RhZ10gPVxuY2xvbmVhYmxlVGFnc1tib29sVGFnXSA9IGNsb25lYWJsZVRhZ3NbZGF0ZVRhZ10gPVxuY2xvbmVhYmxlVGFnc1tmbG9hdDMyVGFnXSA9IGNsb25lYWJsZVRhZ3NbZmxvYXQ2NFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbaW50MTZUYWddID1cbmNsb25lYWJsZVRhZ3NbaW50MzJUYWddID0gY2xvbmVhYmxlVGFnc1ttYXBUYWddID1cbmNsb25lYWJsZVRhZ3NbbnVtYmVyVGFnXSA9IGNsb25lYWJsZVRhZ3Nbb2JqZWN0VGFnXSA9XG5jbG9uZWFibGVUYWdzW3JlZ2V4cFRhZ10gPSBjbG9uZWFibGVUYWdzW3NldFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tzdHJpbmdUYWddID0gY2xvbmVhYmxlVGFnc1tzeW1ib2xUYWddID1cbmNsb25lYWJsZVRhZ3NbdWludDhUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50OENsYW1wZWRUYWddID1cbmNsb25lYWJsZVRhZ3NbdWludDE2VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG5jbG9uZWFibGVUYWdzW2Vycm9yVGFnXSA9IGNsb25lYWJsZVRhZ3NbZnVuY1RhZ10gPVxuY2xvbmVhYmxlVGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNsb25lYCBhbmQgYF8uY2xvbmVEZWVwYCB3aGljaCB0cmFja3NcbiAqIHRyYXZlcnNlZCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAqICAxIC0gRGVlcCBjbG9uZVxuICogIDIgLSBGbGF0dGVuIGluaGVyaXRlZCBwcm9wZXJ0aWVzXG4gKiAgNCAtIENsb25lIHN5bWJvbHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2tleV0gVGhlIGtleSBvZiBgdmFsdWVgLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBwYXJlbnQgb2JqZWN0IG9mIGB2YWx1ZWAuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIG9iamVjdHMgYW5kIHRoZWlyIGNsb25lIGNvdW50ZXJwYXJ0cy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VDbG9uZSh2YWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCBvYmplY3QsIHN0YWNrKSB7XG4gIHZhciByZXN1bHQsXG4gICAgICBpc0RlZXAgPSBiaXRtYXNrICYgQ0xPTkVfREVFUF9GTEFHLFxuICAgICAgaXNGbGF0ID0gYml0bWFzayAmIENMT05FX0ZMQVRfRkxBRyxcbiAgICAgIGlzRnVsbCA9IGJpdG1hc2sgJiBDTE9ORV9TWU1CT0xTX0ZMQUc7XG5cbiAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICByZXN1bHQgPSBvYmplY3QgPyBjdXN0b21pemVyKHZhbHVlLCBrZXksIG9iamVjdCwgc3RhY2spIDogY3VzdG9taXplcih2YWx1ZSk7XG4gIH1cbiAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKTtcbiAgaWYgKGlzQXJyKSB7XG4gICAgcmVzdWx0ID0gaW5pdENsb25lQXJyYXkodmFsdWUpO1xuICAgIGlmICghaXNEZWVwKSB7XG4gICAgICByZXR1cm4gY29weUFycmF5KHZhbHVlLCByZXN1bHQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKSxcbiAgICAgICAgaXNGdW5jID0gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZztcblxuICAgIGlmIChpc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjbG9uZUJ1ZmZlcih2YWx1ZSwgaXNEZWVwKTtcbiAgICB9XG4gICAgaWYgKHRhZyA9PSBvYmplY3RUYWcgfHwgdGFnID09IGFyZ3NUYWcgfHwgKGlzRnVuYyAmJiAhb2JqZWN0KSkge1xuICAgICAgcmVzdWx0ID0gKGlzRmxhdCB8fCBpc0Z1bmMpID8ge30gOiBpbml0Q2xvbmVPYmplY3QodmFsdWUpO1xuICAgICAgaWYgKCFpc0RlZXApIHtcbiAgICAgICAgcmV0dXJuIGlzRmxhdFxuICAgICAgICAgID8gY29weVN5bWJvbHNJbih2YWx1ZSwgYmFzZUFzc2lnbkluKHJlc3VsdCwgdmFsdWUpKVxuICAgICAgICAgIDogY29weVN5bWJvbHModmFsdWUsIGJhc2VBc3NpZ24ocmVzdWx0LCB2YWx1ZSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWNsb25lYWJsZVRhZ3NbdGFnXSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0ID8gdmFsdWUgOiB7fTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGluaXRDbG9uZUJ5VGFnKHZhbHVlLCB0YWcsIGlzRGVlcCk7XG4gICAgfVxuICB9XG4gIC8vIENoZWNrIGZvciBjaXJjdWxhciByZWZlcmVuY2VzIGFuZCByZXR1cm4gaXRzIGNvcnJlc3BvbmRpbmcgY2xvbmUuXG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KHZhbHVlKTtcbiAgaWYgKHN0YWNrZWQpIHtcbiAgICByZXR1cm4gc3RhY2tlZDtcbiAgfVxuICBzdGFjay5zZXQodmFsdWUsIHJlc3VsdCk7XG5cbiAgaWYgKGlzU2V0KHZhbHVlKSkge1xuICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24oc3ViVmFsdWUpIHtcbiAgICAgIHJlc3VsdC5hZGQoYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdWJWYWx1ZSwgdmFsdWUsIHN0YWNrKSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKGlzTWFwKHZhbHVlKSkge1xuICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24oc3ViVmFsdWUsIGtleSkge1xuICAgICAgcmVzdWx0LnNldChrZXksIGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCB2YWx1ZSwgc3RhY2spKTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIga2V5c0Z1bmMgPSBpc0Z1bGxcbiAgICA/IChpc0ZsYXQgPyBnZXRBbGxLZXlzSW4gOiBnZXRBbGxLZXlzKVxuICAgIDogKGlzRmxhdCA/IGtleXNJbiA6IGtleXMpO1xuXG4gIHZhciBwcm9wcyA9IGlzQXJyID8gdW5kZWZpbmVkIDoga2V5c0Z1bmModmFsdWUpO1xuICBhcnJheUVhY2gocHJvcHMgfHwgdmFsdWUsIGZ1bmN0aW9uKHN1YlZhbHVlLCBrZXkpIHtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgIGtleSA9IHN1YlZhbHVlO1xuICAgICAgc3ViVmFsdWUgPSB2YWx1ZVtrZXldO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBwb3B1bGF0ZSBjbG9uZSAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCBiYXNlQ2xvbmUoc3ViVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGtleSwgdmFsdWUsIHN0YWNrKSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlQ2xvbmU7XG4iLCJpbXBvcnQgYmFzZUNsb25lIGZyb20gJy4vX2Jhc2VDbG9uZS5qcyc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGNsb25pbmcuICovXG52YXIgQ0xPTkVfREVFUF9GTEFHID0gMSxcbiAgICBDTE9ORV9TWU1CT0xTX0ZMQUcgPSA0O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uY2xvbmVgIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IGNsb25lcyBgdmFsdWVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMS4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZWN1cnNpdmVseSBjbG9uZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBkZWVwIGNsb25lZCB2YWx1ZS5cbiAqIEBzZWUgXy5jbG9uZVxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IFt7ICdhJzogMSB9LCB7ICdiJzogMiB9XTtcbiAqXG4gKiB2YXIgZGVlcCA9IF8uY2xvbmVEZWVwKG9iamVjdHMpO1xuICogY29uc29sZS5sb2coZGVlcFswXSA9PT0gb2JqZWN0c1swXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBjbG9uZURlZXAodmFsdWUpIHtcbiAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfREVFUF9GTEFHIHwgQ0xPTkVfU1lNQk9MU19GTEFHKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xvbmVEZWVwO1xuIiwiLyoqXG4gKiBHZXRzIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGFsaWFzIGZpcnN0XG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaGVhZChbMSwgMiwgM10pO1xuICogLy8gPT4gMVxuICpcbiAqIF8uaGVhZChbXSk7XG4gKiAvLyA9PiB1bmRlZmluZWRcbiAqL1xuZnVuY3Rpb24gaGVhZChhcnJheSkge1xuICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkgPyBhcnJheVswXSA6IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaGVhZDtcbiIsImltcG9ydCBXZWFrTWFwIGZyb20gJy4vX1dlYWtNYXAuanMnO1xuXG4vKiogVXNlZCB0byBzdG9yZSBmdW5jdGlvbiBtZXRhZGF0YS4gKi9cbnZhciBtZXRhTWFwID0gV2Vha01hcCAmJiBuZXcgV2Vha01hcDtcblxuZXhwb3J0IGRlZmF1bHQgbWV0YU1hcDtcbiIsImltcG9ydCBpZGVudGl0eSBmcm9tICcuL2lkZW50aXR5LmpzJztcbmltcG9ydCBtZXRhTWFwIGZyb20gJy4vX21ldGFNYXAuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBzZXREYXRhYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIHNob3J0aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhc3NvY2lhdGUgbWV0YWRhdGEgd2l0aC5cbiAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWV0YWRhdGEuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovXG52YXIgYmFzZVNldERhdGEgPSAhbWV0YU1hcCA/IGlkZW50aXR5IDogZnVuY3Rpb24oZnVuYywgZGF0YSkge1xuICBtZXRhTWFwLnNldChmdW5jLCBkYXRhKTtcbiAgcmV0dXJuIGZ1bmM7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBiYXNlU2V0RGF0YTtcbiIsImltcG9ydCBiYXNlQ3JlYXRlIGZyb20gJy4vX2Jhc2VDcmVhdGUuanMnO1xuaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHByb2R1Y2VzIGFuIGluc3RhbmNlIG9mIGBDdG9yYCByZWdhcmRsZXNzIG9mXG4gKiB3aGV0aGVyIGl0IHdhcyBpbnZva2VkIGFzIHBhcnQgb2YgYSBgbmV3YCBleHByZXNzaW9uIG9yIGJ5IGBjYWxsYCBvciBgYXBwbHlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBDdG9yIFRoZSBjb25zdHJ1Y3RvciB0byB3cmFwLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ3RvcihDdG9yKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAvLyBVc2UgYSBgc3dpdGNoYCBzdGF0ZW1lbnQgdG8gd29yayB3aXRoIGNsYXNzIGNvbnN0cnVjdG9ycy4gU2VlXG4gICAgLy8gaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1mdW5jdGlvbi1vYmplY3RzLWNhbGwtdGhpc2FyZ3VtZW50LWFyZ3VtZW50c2xpc3RcbiAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyBDdG9yO1xuICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSk7XG4gICAgICBjYXNlIDI6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgIGNhc2UgMzogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgY2FzZSA0OiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gICAgICBjYXNlIDU6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdKTtcbiAgICAgIGNhc2UgNjogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10sIGFyZ3NbNF0sIGFyZ3NbNV0pO1xuICAgICAgY2FzZSA3OiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSwgYXJnc1s0XSwgYXJnc1s1XSwgYXJnc1s2XSk7XG4gICAgfVxuICAgIHZhciB0aGlzQmluZGluZyA9IGJhc2VDcmVhdGUoQ3Rvci5wcm90b3R5cGUpLFxuICAgICAgICByZXN1bHQgPSBDdG9yLmFwcGx5KHRoaXNCaW5kaW5nLCBhcmdzKTtcblxuICAgIC8vIE1pbWljIHRoZSBjb25zdHJ1Y3RvcidzIGByZXR1cm5gIGJlaGF2aW9yLlxuICAgIC8vIFNlZSBodHRwczovL2VzNS5naXRodWIuaW8vI3gxMy4yLjIgZm9yIG1vcmUgZGV0YWlscy5cbiAgICByZXR1cm4gaXNPYmplY3QocmVzdWx0KSA/IHJlc3VsdCA6IHRoaXNCaW5kaW5nO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVDdG9yO1xuIiwiaW1wb3J0IGNyZWF0ZUN0b3IgZnJvbSAnLi9fY3JlYXRlQ3Rvci5qcyc7XG5pbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgZnVuY3Rpb24gbWV0YWRhdGEuICovXG52YXIgV1JBUF9CSU5EX0ZMQUcgPSAxO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCB0byBpbnZva2UgaXQgd2l0aCB0aGUgb3B0aW9uYWwgYHRoaXNgXG4gKiBiaW5kaW5nIG9mIGB0aGlzQXJnYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmluZChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnKSB7XG4gIHZhciBpc0JpbmQgPSBiaXRtYXNrICYgV1JBUF9CSU5EX0ZMQUcsXG4gICAgICBDdG9yID0gY3JlYXRlQ3RvcihmdW5jKTtcblxuICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgIHZhciBmbiA9ICh0aGlzICYmIHRoaXMgIT09IHJvb3QgJiYgdGhpcyBpbnN0YW5jZW9mIHdyYXBwZXIpID8gQ3RvciA6IGZ1bmM7XG4gICAgcmV0dXJuIGZuLmFwcGx5KGlzQmluZCA/IHRoaXNBcmcgOiB0aGlzLCBhcmd1bWVudHMpO1xuICB9XG4gIHJldHVybiB3cmFwcGVyO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVCaW5kO1xuIiwiLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgdGhhdCBpcyB0aGUgY29tcG9zaXRpb24gb2YgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLFxuICogcGxhY2Vob2xkZXJzLCBhbmQgcHJvdmlkZWQgYXJndW1lbnRzIGludG8gYSBzaW5nbGUgYXJyYXkgb2YgYXJndW1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBwcm92aWRlZCBhcmd1bWVudHMuXG4gKiBAcGFyYW0ge0FycmF5fSBwYXJ0aWFscyBUaGUgYXJndW1lbnRzIHRvIHByZXBlbmQgdG8gdGhvc2UgcHJvdmlkZWQuXG4gKiBAcGFyYW0ge0FycmF5fSBob2xkZXJzIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gKiBAcGFyYW1zIHtib29sZWFufSBbaXNDdXJyaWVkXSBTcGVjaWZ5IGNvbXBvc2luZyBmb3IgYSBjdXJyaWVkIGZ1bmN0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tcG9zZWQgYXJndW1lbnRzLlxuICovXG5mdW5jdGlvbiBjb21wb3NlQXJncyhhcmdzLCBwYXJ0aWFscywgaG9sZGVycywgaXNDdXJyaWVkKSB7XG4gIHZhciBhcmdzSW5kZXggPSAtMSxcbiAgICAgIGFyZ3NMZW5ndGggPSBhcmdzLmxlbmd0aCxcbiAgICAgIGhvbGRlcnNMZW5ndGggPSBob2xkZXJzLmxlbmd0aCxcbiAgICAgIGxlZnRJbmRleCA9IC0xLFxuICAgICAgbGVmdExlbmd0aCA9IHBhcnRpYWxzLmxlbmd0aCxcbiAgICAgIHJhbmdlTGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3NMZW5ndGggLSBob2xkZXJzTGVuZ3RoLCAwKSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlZnRMZW5ndGggKyByYW5nZUxlbmd0aCksXG4gICAgICBpc1VuY3VycmllZCA9ICFpc0N1cnJpZWQ7XG5cbiAgd2hpbGUgKCsrbGVmdEluZGV4IDwgbGVmdExlbmd0aCkge1xuICAgIHJlc3VsdFtsZWZ0SW5kZXhdID0gcGFydGlhbHNbbGVmdEluZGV4XTtcbiAgfVxuICB3aGlsZSAoKythcmdzSW5kZXggPCBob2xkZXJzTGVuZ3RoKSB7XG4gICAgaWYgKGlzVW5jdXJyaWVkIHx8IGFyZ3NJbmRleCA8IGFyZ3NMZW5ndGgpIHtcbiAgICAgIHJlc3VsdFtob2xkZXJzW2FyZ3NJbmRleF1dID0gYXJnc1thcmdzSW5kZXhdO1xuICAgIH1cbiAgfVxuICB3aGlsZSAocmFuZ2VMZW5ndGgtLSkge1xuICAgIHJlc3VsdFtsZWZ0SW5kZXgrK10gPSBhcmdzW2FyZ3NJbmRleCsrXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjb21wb3NlQXJncztcbiIsIi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGNvbXBvc2VBcmdzYCBleGNlcHQgdGhhdCB0aGUgYXJndW1lbnRzIGNvbXBvc2l0aW9uXG4gKiBpcyB0YWlsb3JlZCBmb3IgYF8ucGFydGlhbFJpZ2h0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgcHJvdmlkZWQgYXJndW1lbnRzLlxuICogQHBhcmFtIHtBcnJheX0gcGFydGlhbHMgVGhlIGFyZ3VtZW50cyB0byBhcHBlbmQgdG8gdGhvc2UgcHJvdmlkZWQuXG4gKiBAcGFyYW0ge0FycmF5fSBob2xkZXJzIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gKiBAcGFyYW1zIHtib29sZWFufSBbaXNDdXJyaWVkXSBTcGVjaWZ5IGNvbXBvc2luZyBmb3IgYSBjdXJyaWVkIGZ1bmN0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tcG9zZWQgYXJndW1lbnRzLlxuICovXG5mdW5jdGlvbiBjb21wb3NlQXJnc1JpZ2h0KGFyZ3MsIHBhcnRpYWxzLCBob2xkZXJzLCBpc0N1cnJpZWQpIHtcbiAgdmFyIGFyZ3NJbmRleCA9IC0xLFxuICAgICAgYXJnc0xlbmd0aCA9IGFyZ3MubGVuZ3RoLFxuICAgICAgaG9sZGVyc0luZGV4ID0gLTEsXG4gICAgICBob2xkZXJzTGVuZ3RoID0gaG9sZGVycy5sZW5ndGgsXG4gICAgICByaWdodEluZGV4ID0gLTEsXG4gICAgICByaWdodExlbmd0aCA9IHBhcnRpYWxzLmxlbmd0aCxcbiAgICAgIHJhbmdlTGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3NMZW5ndGggLSBob2xkZXJzTGVuZ3RoLCAwKSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KHJhbmdlTGVuZ3RoICsgcmlnaHRMZW5ndGgpLFxuICAgICAgaXNVbmN1cnJpZWQgPSAhaXNDdXJyaWVkO1xuXG4gIHdoaWxlICgrK2FyZ3NJbmRleCA8IHJhbmdlTGVuZ3RoKSB7XG4gICAgcmVzdWx0W2FyZ3NJbmRleF0gPSBhcmdzW2FyZ3NJbmRleF07XG4gIH1cbiAgdmFyIG9mZnNldCA9IGFyZ3NJbmRleDtcbiAgd2hpbGUgKCsrcmlnaHRJbmRleCA8IHJpZ2h0TGVuZ3RoKSB7XG4gICAgcmVzdWx0W29mZnNldCArIHJpZ2h0SW5kZXhdID0gcGFydGlhbHNbcmlnaHRJbmRleF07XG4gIH1cbiAgd2hpbGUgKCsraG9sZGVyc0luZGV4IDwgaG9sZGVyc0xlbmd0aCkge1xuICAgIGlmIChpc1VuY3VycmllZCB8fCBhcmdzSW5kZXggPCBhcmdzTGVuZ3RoKSB7XG4gICAgICByZXN1bHRbb2Zmc2V0ICsgaG9sZGVyc1tob2xkZXJzSW5kZXhdXSA9IGFyZ3NbYXJnc0luZGV4KytdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjb21wb3NlQXJnc1JpZ2h0O1xuIiwiLyoqXG4gKiBHZXRzIHRoZSBudW1iZXIgb2YgYHBsYWNlaG9sZGVyYCBvY2N1cnJlbmNlcyBpbiBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0gcGxhY2Vob2xkZXIgVGhlIHBsYWNlaG9sZGVyIHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBwbGFjZWhvbGRlciBjb3VudC5cbiAqL1xuZnVuY3Rpb24gY291bnRIb2xkZXJzKGFycmF5LCBwbGFjZWhvbGRlcikge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gMDtcblxuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoYXJyYXlbbGVuZ3RoXSA9PT0gcGxhY2Vob2xkZXIpIHtcbiAgICAgICsrcmVzdWx0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjb3VudEhvbGRlcnM7XG4iLCIvKipcbiAqIFRoZSBmdW5jdGlvbiB3aG9zZSBwcm90b3R5cGUgY2hhaW4gc2VxdWVuY2Ugd3JhcHBlcnMgaW5oZXJpdCBmcm9tLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGJhc2VMb2Rhc2goKSB7XG4gIC8vIE5vIG9wZXJhdGlvbiBwZXJmb3JtZWQuXG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VMb2Rhc2g7XG4iLCJpbXBvcnQgYmFzZUNyZWF0ZSBmcm9tICcuL19iYXNlQ3JlYXRlLmpzJztcbmltcG9ydCBiYXNlTG9kYXNoIGZyb20gJy4vX2Jhc2VMb2Rhc2guanMnO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB0aGUgbWF4aW11bSBsZW5ndGggYW5kIGluZGV4IG9mIGFuIGFycmF5LiAqL1xudmFyIE1BWF9BUlJBWV9MRU5HVEggPSA0Mjk0OTY3Mjk1O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBsYXp5IHdyYXBwZXIgb2JqZWN0IHdoaWNoIHdyYXBzIGB2YWx1ZWAgdG8gZW5hYmxlIGxhenkgZXZhbHVhdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICovXG5mdW5jdGlvbiBMYXp5V3JhcHBlcih2YWx1ZSkge1xuICB0aGlzLl9fd3JhcHBlZF9fID0gdmFsdWU7XG4gIHRoaXMuX19hY3Rpb25zX18gPSBbXTtcbiAgdGhpcy5fX2Rpcl9fID0gMTtcbiAgdGhpcy5fX2ZpbHRlcmVkX18gPSBmYWxzZTtcbiAgdGhpcy5fX2l0ZXJhdGVlc19fID0gW107XG4gIHRoaXMuX190YWtlQ291bnRfXyA9IE1BWF9BUlJBWV9MRU5HVEg7XG4gIHRoaXMuX192aWV3c19fID0gW107XG59XG5cbi8vIEVuc3VyZSBgTGF6eVdyYXBwZXJgIGlzIGFuIGluc3RhbmNlIG9mIGBiYXNlTG9kYXNoYC5cbkxhenlXcmFwcGVyLnByb3RvdHlwZSA9IGJhc2VDcmVhdGUoYmFzZUxvZGFzaC5wcm90b3R5cGUpO1xuTGF6eVdyYXBwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGF6eVdyYXBwZXI7XG5cbmV4cG9ydCBkZWZhdWx0IExhenlXcmFwcGVyO1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGB1bmRlZmluZWRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi4zLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5ub29wKTtcbiAqIC8vID0+IFt1bmRlZmluZWQsIHVuZGVmaW5lZF1cbiAqL1xuZnVuY3Rpb24gbm9vcCgpIHtcbiAgLy8gTm8gb3BlcmF0aW9uIHBlcmZvcm1lZC5cbn1cblxuZXhwb3J0IGRlZmF1bHQgbm9vcDtcbiIsImltcG9ydCBtZXRhTWFwIGZyb20gJy4vX21ldGFNYXAuanMnO1xuaW1wb3J0IG5vb3AgZnJvbSAnLi9ub29wLmpzJztcblxuLyoqXG4gKiBHZXRzIG1ldGFkYXRhIGZvciBgZnVuY2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHF1ZXJ5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1ldGFkYXRhIGZvciBgZnVuY2AuXG4gKi9cbnZhciBnZXREYXRhID0gIW1ldGFNYXAgPyBub29wIDogZnVuY3Rpb24oZnVuYykge1xuICByZXR1cm4gbWV0YU1hcC5nZXQoZnVuYyk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBnZXREYXRhO1xuIiwiLyoqIFVzZWQgdG8gbG9va3VwIHVubWluaWZpZWQgZnVuY3Rpb24gbmFtZXMuICovXG52YXIgcmVhbE5hbWVzID0ge307XG5cbmV4cG9ydCBkZWZhdWx0IHJlYWxOYW1lcztcbiIsImltcG9ydCByZWFsTmFtZXMgZnJvbSAnLi9fcmVhbE5hbWVzLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBHZXRzIHRoZSBuYW1lIG9mIGBmdW5jYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBuYW1lLlxuICovXG5mdW5jdGlvbiBnZXRGdW5jTmFtZShmdW5jKSB7XG4gIHZhciByZXN1bHQgPSAoZnVuYy5uYW1lICsgJycpLFxuICAgICAgYXJyYXkgPSByZWFsTmFtZXNbcmVzdWx0XSxcbiAgICAgIGxlbmd0aCA9IGhhc093blByb3BlcnR5LmNhbGwocmVhbE5hbWVzLCByZXN1bHQpID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICB2YXIgZGF0YSA9IGFycmF5W2xlbmd0aF0sXG4gICAgICAgIG90aGVyRnVuYyA9IGRhdGEuZnVuYztcbiAgICBpZiAob3RoZXJGdW5jID09IG51bGwgfHwgb3RoZXJGdW5jID09IGZ1bmMpIHtcbiAgICAgIHJldHVybiBkYXRhLm5hbWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldEZ1bmNOYW1lO1xuIiwiaW1wb3J0IGJhc2VDcmVhdGUgZnJvbSAnLi9fYmFzZUNyZWF0ZS5qcyc7XG5pbXBvcnQgYmFzZUxvZGFzaCBmcm9tICcuL19iYXNlTG9kYXNoLmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBjb25zdHJ1Y3RvciBmb3IgY3JlYXRpbmcgYGxvZGFzaGAgd3JhcHBlciBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICogQHBhcmFtIHtib29sZWFufSBbY2hhaW5BbGxdIEVuYWJsZSBleHBsaWNpdCBtZXRob2QgY2hhaW4gc2VxdWVuY2VzLlxuICovXG5mdW5jdGlvbiBMb2Rhc2hXcmFwcGVyKHZhbHVlLCBjaGFpbkFsbCkge1xuICB0aGlzLl9fd3JhcHBlZF9fID0gdmFsdWU7XG4gIHRoaXMuX19hY3Rpb25zX18gPSBbXTtcbiAgdGhpcy5fX2NoYWluX18gPSAhIWNoYWluQWxsO1xuICB0aGlzLl9faW5kZXhfXyA9IDA7XG4gIHRoaXMuX192YWx1ZXNfXyA9IHVuZGVmaW5lZDtcbn1cblxuTG9kYXNoV3JhcHBlci5wcm90b3R5cGUgPSBiYXNlQ3JlYXRlKGJhc2VMb2Rhc2gucHJvdG90eXBlKTtcbkxvZGFzaFdyYXBwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTG9kYXNoV3JhcHBlcjtcblxuZXhwb3J0IGRlZmF1bHQgTG9kYXNoV3JhcHBlcjtcbiIsImltcG9ydCBMYXp5V3JhcHBlciBmcm9tICcuL19MYXp5V3JhcHBlci5qcyc7XG5pbXBvcnQgTG9kYXNoV3JhcHBlciBmcm9tICcuL19Mb2Rhc2hXcmFwcGVyLmpzJztcbmltcG9ydCBjb3B5QXJyYXkgZnJvbSAnLi9fY29weUFycmF5LmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHdyYXBwZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gd3JhcHBlciBUaGUgd3JhcHBlciB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCB3cmFwcGVyLlxuICovXG5mdW5jdGlvbiB3cmFwcGVyQ2xvbmUod3JhcHBlcikge1xuICBpZiAod3JhcHBlciBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSB7XG4gICAgcmV0dXJuIHdyYXBwZXIuY2xvbmUoKTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gbmV3IExvZGFzaFdyYXBwZXIod3JhcHBlci5fX3dyYXBwZWRfXywgd3JhcHBlci5fX2NoYWluX18pO1xuICByZXN1bHQuX19hY3Rpb25zX18gPSBjb3B5QXJyYXkod3JhcHBlci5fX2FjdGlvbnNfXyk7XG4gIHJlc3VsdC5fX2luZGV4X18gID0gd3JhcHBlci5fX2luZGV4X187XG4gIHJlc3VsdC5fX3ZhbHVlc19fID0gd3JhcHBlci5fX3ZhbHVlc19fO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCB3cmFwcGVyQ2xvbmU7XG4iLCJpbXBvcnQgTGF6eVdyYXBwZXIgZnJvbSAnLi9fTGF6eVdyYXBwZXIuanMnO1xuaW1wb3J0IExvZGFzaFdyYXBwZXIgZnJvbSAnLi9fTG9kYXNoV3JhcHBlci5qcyc7XG5pbXBvcnQgYmFzZUxvZGFzaCBmcm9tICcuL19iYXNlTG9kYXNoLmpzJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcbmltcG9ydCB3cmFwcGVyQ2xvbmUgZnJvbSAnLi9fd3JhcHBlckNsb25lLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgYGxvZGFzaGAgb2JqZWN0IHdoaWNoIHdyYXBzIGB2YWx1ZWAgdG8gZW5hYmxlIGltcGxpY2l0IG1ldGhvZFxuICogY2hhaW4gc2VxdWVuY2VzLiBNZXRob2RzIHRoYXQgb3BlcmF0ZSBvbiBhbmQgcmV0dXJuIGFycmF5cywgY29sbGVjdGlvbnMsXG4gKiBhbmQgZnVuY3Rpb25zIGNhbiBiZSBjaGFpbmVkIHRvZ2V0aGVyLiBNZXRob2RzIHRoYXQgcmV0cmlldmUgYSBzaW5nbGUgdmFsdWVcbiAqIG9yIG1heSByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUgd2lsbCBhdXRvbWF0aWNhbGx5IGVuZCB0aGUgY2hhaW4gc2VxdWVuY2VcbiAqIGFuZCByZXR1cm4gdGhlIHVud3JhcHBlZCB2YWx1ZS4gT3RoZXJ3aXNlLCB0aGUgdmFsdWUgbXVzdCBiZSB1bndyYXBwZWRcbiAqIHdpdGggYF8jdmFsdWVgLlxuICpcbiAqIEV4cGxpY2l0IGNoYWluIHNlcXVlbmNlcywgd2hpY2ggbXVzdCBiZSB1bndyYXBwZWQgd2l0aCBgXyN2YWx1ZWAsIG1heSBiZVxuICogZW5hYmxlZCB1c2luZyBgXy5jaGFpbmAuXG4gKlxuICogVGhlIGV4ZWN1dGlvbiBvZiBjaGFpbmVkIG1ldGhvZHMgaXMgbGF6eSwgdGhhdCBpcywgaXQncyBkZWZlcnJlZCB1bnRpbFxuICogYF8jdmFsdWVgIGlzIGltcGxpY2l0bHkgb3IgZXhwbGljaXRseSBjYWxsZWQuXG4gKlxuICogTGF6eSBldmFsdWF0aW9uIGFsbG93cyBzZXZlcmFsIG1ldGhvZHMgdG8gc3VwcG9ydCBzaG9ydGN1dCBmdXNpb24uXG4gKiBTaG9ydGN1dCBmdXNpb24gaXMgYW4gb3B0aW1pemF0aW9uIHRvIG1lcmdlIGl0ZXJhdGVlIGNhbGxzOyB0aGlzIGF2b2lkc1xuICogdGhlIGNyZWF0aW9uIG9mIGludGVybWVkaWF0ZSBhcnJheXMgYW5kIGNhbiBncmVhdGx5IHJlZHVjZSB0aGUgbnVtYmVyIG9mXG4gKiBpdGVyYXRlZSBleGVjdXRpb25zLiBTZWN0aW9ucyBvZiBhIGNoYWluIHNlcXVlbmNlIHF1YWxpZnkgZm9yIHNob3J0Y3V0XG4gKiBmdXNpb24gaWYgdGhlIHNlY3Rpb24gaXMgYXBwbGllZCB0byBhbiBhcnJheSBhbmQgaXRlcmF0ZWVzIGFjY2VwdCBvbmx5XG4gKiBvbmUgYXJndW1lbnQuIFRoZSBoZXVyaXN0aWMgZm9yIHdoZXRoZXIgYSBzZWN0aW9uIHF1YWxpZmllcyBmb3Igc2hvcnRjdXRcbiAqIGZ1c2lvbiBpcyBzdWJqZWN0IHRvIGNoYW5nZS5cbiAqXG4gKiBDaGFpbmluZyBpcyBzdXBwb3J0ZWQgaW4gY3VzdG9tIGJ1aWxkcyBhcyBsb25nIGFzIHRoZSBgXyN2YWx1ZWAgbWV0aG9kIGlzXG4gKiBkaXJlY3RseSBvciBpbmRpcmVjdGx5IGluY2x1ZGVkIGluIHRoZSBidWlsZC5cbiAqXG4gKiBJbiBhZGRpdGlvbiB0byBsb2Rhc2ggbWV0aG9kcywgd3JhcHBlcnMgaGF2ZSBgQXJyYXlgIGFuZCBgU3RyaW5nYCBtZXRob2RzLlxuICpcbiAqIFRoZSB3cmFwcGVyIGBBcnJheWAgbWV0aG9kcyBhcmU6XG4gKiBgY29uY2F0YCwgYGpvaW5gLCBgcG9wYCwgYHB1c2hgLCBgc2hpZnRgLCBgc29ydGAsIGBzcGxpY2VgLCBhbmQgYHVuc2hpZnRgXG4gKlxuICogVGhlIHdyYXBwZXIgYFN0cmluZ2AgbWV0aG9kcyBhcmU6XG4gKiBgcmVwbGFjZWAgYW5kIGBzcGxpdGBcbiAqXG4gKiBUaGUgd3JhcHBlciBtZXRob2RzIHRoYXQgc3VwcG9ydCBzaG9ydGN1dCBmdXNpb24gYXJlOlxuICogYGF0YCwgYGNvbXBhY3RgLCBgZHJvcGAsIGBkcm9wUmlnaHRgLCBgZHJvcFdoaWxlYCwgYGZpbHRlcmAsIGBmaW5kYCxcbiAqIGBmaW5kTGFzdGAsIGBoZWFkYCwgYGluaXRpYWxgLCBgbGFzdGAsIGBtYXBgLCBgcmVqZWN0YCwgYHJldmVyc2VgLCBgc2xpY2VgLFxuICogYHRhaWxgLCBgdGFrZWAsIGB0YWtlUmlnaHRgLCBgdGFrZVJpZ2h0V2hpbGVgLCBgdGFrZVdoaWxlYCwgYW5kIGB0b0FycmF5YFxuICpcbiAqIFRoZSBjaGFpbmFibGUgd3JhcHBlciBtZXRob2RzIGFyZTpcbiAqIGBhZnRlcmAsIGBhcnlgLCBgYXNzaWduYCwgYGFzc2lnbkluYCwgYGFzc2lnbkluV2l0aGAsIGBhc3NpZ25XaXRoYCwgYGF0YCxcbiAqIGBiZWZvcmVgLCBgYmluZGAsIGBiaW5kQWxsYCwgYGJpbmRLZXlgLCBgY2FzdEFycmF5YCwgYGNoYWluYCwgYGNodW5rYCxcbiAqIGBjb21taXRgLCBgY29tcGFjdGAsIGBjb25jYXRgLCBgY29uZm9ybXNgLCBgY29uc3RhbnRgLCBgY291bnRCeWAsIGBjcmVhdGVgLFxuICogYGN1cnJ5YCwgYGRlYm91bmNlYCwgYGRlZmF1bHRzYCwgYGRlZmF1bHRzRGVlcGAsIGBkZWZlcmAsIGBkZWxheWAsXG4gKiBgZGlmZmVyZW5jZWAsIGBkaWZmZXJlbmNlQnlgLCBgZGlmZmVyZW5jZVdpdGhgLCBgZHJvcGAsIGBkcm9wUmlnaHRgLFxuICogYGRyb3BSaWdodFdoaWxlYCwgYGRyb3BXaGlsZWAsIGBleHRlbmRgLCBgZXh0ZW5kV2l0aGAsIGBmaWxsYCwgYGZpbHRlcmAsXG4gKiBgZmxhdE1hcGAsIGBmbGF0TWFwRGVlcGAsIGBmbGF0TWFwRGVwdGhgLCBgZmxhdHRlbmAsIGBmbGF0dGVuRGVlcGAsXG4gKiBgZmxhdHRlbkRlcHRoYCwgYGZsaXBgLCBgZmxvd2AsIGBmbG93UmlnaHRgLCBgZnJvbVBhaXJzYCwgYGZ1bmN0aW9uc2AsXG4gKiBgZnVuY3Rpb25zSW5gLCBgZ3JvdXBCeWAsIGBpbml0aWFsYCwgYGludGVyc2VjdGlvbmAsIGBpbnRlcnNlY3Rpb25CeWAsXG4gKiBgaW50ZXJzZWN0aW9uV2l0aGAsIGBpbnZlcnRgLCBgaW52ZXJ0QnlgLCBgaW52b2tlTWFwYCwgYGl0ZXJhdGVlYCwgYGtleUJ5YCxcbiAqIGBrZXlzYCwgYGtleXNJbmAsIGBtYXBgLCBgbWFwS2V5c2AsIGBtYXBWYWx1ZXNgLCBgbWF0Y2hlc2AsIGBtYXRjaGVzUHJvcGVydHlgLFxuICogYG1lbW9pemVgLCBgbWVyZ2VgLCBgbWVyZ2VXaXRoYCwgYG1ldGhvZGAsIGBtZXRob2RPZmAsIGBtaXhpbmAsIGBuZWdhdGVgLFxuICogYG50aEFyZ2AsIGBvbWl0YCwgYG9taXRCeWAsIGBvbmNlYCwgYG9yZGVyQnlgLCBgb3ZlcmAsIGBvdmVyQXJnc2AsXG4gKiBgb3ZlckV2ZXJ5YCwgYG92ZXJTb21lYCwgYHBhcnRpYWxgLCBgcGFydGlhbFJpZ2h0YCwgYHBhcnRpdGlvbmAsIGBwaWNrYCxcbiAqIGBwaWNrQnlgLCBgcGxhbnRgLCBgcHJvcGVydHlgLCBgcHJvcGVydHlPZmAsIGBwdWxsYCwgYHB1bGxBbGxgLCBgcHVsbEFsbEJ5YCxcbiAqIGBwdWxsQWxsV2l0aGAsIGBwdWxsQXRgLCBgcHVzaGAsIGByYW5nZWAsIGByYW5nZVJpZ2h0YCwgYHJlYXJnYCwgYHJlamVjdGAsXG4gKiBgcmVtb3ZlYCwgYHJlc3RgLCBgcmV2ZXJzZWAsIGBzYW1wbGVTaXplYCwgYHNldGAsIGBzZXRXaXRoYCwgYHNodWZmbGVgLFxuICogYHNsaWNlYCwgYHNvcnRgLCBgc29ydEJ5YCwgYHNwbGljZWAsIGBzcHJlYWRgLCBgdGFpbGAsIGB0YWtlYCwgYHRha2VSaWdodGAsXG4gKiBgdGFrZVJpZ2h0V2hpbGVgLCBgdGFrZVdoaWxlYCwgYHRhcGAsIGB0aHJvdHRsZWAsIGB0aHJ1YCwgYHRvQXJyYXlgLFxuICogYHRvUGFpcnNgLCBgdG9QYWlyc0luYCwgYHRvUGF0aGAsIGB0b1BsYWluT2JqZWN0YCwgYHRyYW5zZm9ybWAsIGB1bmFyeWAsXG4gKiBgdW5pb25gLCBgdW5pb25CeWAsIGB1bmlvbldpdGhgLCBgdW5pcWAsIGB1bmlxQnlgLCBgdW5pcVdpdGhgLCBgdW5zZXRgLFxuICogYHVuc2hpZnRgLCBgdW56aXBgLCBgdW56aXBXaXRoYCwgYHVwZGF0ZWAsIGB1cGRhdGVXaXRoYCwgYHZhbHVlc2AsXG4gKiBgdmFsdWVzSW5gLCBgd2l0aG91dGAsIGB3cmFwYCwgYHhvcmAsIGB4b3JCeWAsIGB4b3JXaXRoYCwgYHppcGAsXG4gKiBgemlwT2JqZWN0YCwgYHppcE9iamVjdERlZXBgLCBhbmQgYHppcFdpdGhgXG4gKlxuICogVGhlIHdyYXBwZXIgbWV0aG9kcyB0aGF0IGFyZSAqKm5vdCoqIGNoYWluYWJsZSBieSBkZWZhdWx0IGFyZTpcbiAqIGBhZGRgLCBgYXR0ZW1wdGAsIGBjYW1lbENhc2VgLCBgY2FwaXRhbGl6ZWAsIGBjZWlsYCwgYGNsYW1wYCwgYGNsb25lYCxcbiAqIGBjbG9uZURlZXBgLCBgY2xvbmVEZWVwV2l0aGAsIGBjbG9uZVdpdGhgLCBgY29uZm9ybXNUb2AsIGBkZWJ1cnJgLFxuICogYGRlZmF1bHRUb2AsIGBkaXZpZGVgLCBgZWFjaGAsIGBlYWNoUmlnaHRgLCBgZW5kc1dpdGhgLCBgZXFgLCBgZXNjYXBlYCxcbiAqIGBlc2NhcGVSZWdFeHBgLCBgZXZlcnlgLCBgZmluZGAsIGBmaW5kSW5kZXhgLCBgZmluZEtleWAsIGBmaW5kTGFzdGAsXG4gKiBgZmluZExhc3RJbmRleGAsIGBmaW5kTGFzdEtleWAsIGBmaXJzdGAsIGBmbG9vcmAsIGBmb3JFYWNoYCwgYGZvckVhY2hSaWdodGAsXG4gKiBgZm9ySW5gLCBgZm9ySW5SaWdodGAsIGBmb3JPd25gLCBgZm9yT3duUmlnaHRgLCBgZ2V0YCwgYGd0YCwgYGd0ZWAsIGBoYXNgLFxuICogYGhhc0luYCwgYGhlYWRgLCBgaWRlbnRpdHlgLCBgaW5jbHVkZXNgLCBgaW5kZXhPZmAsIGBpblJhbmdlYCwgYGludm9rZWAsXG4gKiBgaXNBcmd1bWVudHNgLCBgaXNBcnJheWAsIGBpc0FycmF5QnVmZmVyYCwgYGlzQXJyYXlMaWtlYCwgYGlzQXJyYXlMaWtlT2JqZWN0YCxcbiAqIGBpc0Jvb2xlYW5gLCBgaXNCdWZmZXJgLCBgaXNEYXRlYCwgYGlzRWxlbWVudGAsIGBpc0VtcHR5YCwgYGlzRXF1YWxgLFxuICogYGlzRXF1YWxXaXRoYCwgYGlzRXJyb3JgLCBgaXNGaW5pdGVgLCBgaXNGdW5jdGlvbmAsIGBpc0ludGVnZXJgLCBgaXNMZW5ndGhgLFxuICogYGlzTWFwYCwgYGlzTWF0Y2hgLCBgaXNNYXRjaFdpdGhgLCBgaXNOYU5gLCBgaXNOYXRpdmVgLCBgaXNOaWxgLCBgaXNOdWxsYCxcbiAqIGBpc051bWJlcmAsIGBpc09iamVjdGAsIGBpc09iamVjdExpa2VgLCBgaXNQbGFpbk9iamVjdGAsIGBpc1JlZ0V4cGAsXG4gKiBgaXNTYWZlSW50ZWdlcmAsIGBpc1NldGAsIGBpc1N0cmluZ2AsIGBpc1VuZGVmaW5lZGAsIGBpc1R5cGVkQXJyYXlgLFxuICogYGlzV2Vha01hcGAsIGBpc1dlYWtTZXRgLCBgam9pbmAsIGBrZWJhYkNhc2VgLCBgbGFzdGAsIGBsYXN0SW5kZXhPZmAsXG4gKiBgbG93ZXJDYXNlYCwgYGxvd2VyRmlyc3RgLCBgbHRgLCBgbHRlYCwgYG1heGAsIGBtYXhCeWAsIGBtZWFuYCwgYG1lYW5CeWAsXG4gKiBgbWluYCwgYG1pbkJ5YCwgYG11bHRpcGx5YCwgYG5vQ29uZmxpY3RgLCBgbm9vcGAsIGBub3dgLCBgbnRoYCwgYHBhZGAsXG4gKiBgcGFkRW5kYCwgYHBhZFN0YXJ0YCwgYHBhcnNlSW50YCwgYHBvcGAsIGByYW5kb21gLCBgcmVkdWNlYCwgYHJlZHVjZVJpZ2h0YCxcbiAqIGByZXBlYXRgLCBgcmVzdWx0YCwgYHJvdW5kYCwgYHJ1bkluQ29udGV4dGAsIGBzYW1wbGVgLCBgc2hpZnRgLCBgc2l6ZWAsXG4gKiBgc25ha2VDYXNlYCwgYHNvbWVgLCBgc29ydGVkSW5kZXhgLCBgc29ydGVkSW5kZXhCeWAsIGBzb3J0ZWRMYXN0SW5kZXhgLFxuICogYHNvcnRlZExhc3RJbmRleEJ5YCwgYHN0YXJ0Q2FzZWAsIGBzdGFydHNXaXRoYCwgYHN0dWJBcnJheWAsIGBzdHViRmFsc2VgLFxuICogYHN0dWJPYmplY3RgLCBgc3R1YlN0cmluZ2AsIGBzdHViVHJ1ZWAsIGBzdWJ0cmFjdGAsIGBzdW1gLCBgc3VtQnlgLFxuICogYHRlbXBsYXRlYCwgYHRpbWVzYCwgYHRvRmluaXRlYCwgYHRvSW50ZWdlcmAsIGB0b0pTT05gLCBgdG9MZW5ndGhgLFxuICogYHRvTG93ZXJgLCBgdG9OdW1iZXJgLCBgdG9TYWZlSW50ZWdlcmAsIGB0b1N0cmluZ2AsIGB0b1VwcGVyYCwgYHRyaW1gLFxuICogYHRyaW1FbmRgLCBgdHJpbVN0YXJ0YCwgYHRydW5jYXRlYCwgYHVuZXNjYXBlYCwgYHVuaXF1ZUlkYCwgYHVwcGVyQ2FzZWAsXG4gKiBgdXBwZXJGaXJzdGAsIGB2YWx1ZWAsIGFuZCBgd29yZHNgXG4gKlxuICogQG5hbWUgX1xuICogQGNvbnN0cnVjdG9yXG4gKiBAY2F0ZWdvcnkgU2VxXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwIGluIGEgYGxvZGFzaGAgaW5zdGFuY2UuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAqICAgcmV0dXJuIG4gKiBuO1xuICogfVxuICpcbiAqIHZhciB3cmFwcGVkID0gXyhbMSwgMiwgM10pO1xuICpcbiAqIC8vIFJldHVybnMgYW4gdW53cmFwcGVkIHZhbHVlLlxuICogd3JhcHBlZC5yZWR1Y2UoXy5hZGQpO1xuICogLy8gPT4gNlxuICpcbiAqIC8vIFJldHVybnMgYSB3cmFwcGVkIHZhbHVlLlxuICogdmFyIHNxdWFyZXMgPSB3cmFwcGVkLm1hcChzcXVhcmUpO1xuICpcbiAqIF8uaXNBcnJheShzcXVhcmVzKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KHNxdWFyZXMudmFsdWUoKSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGxvZGFzaCh2YWx1ZSkge1xuICBpZiAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiAhaXNBcnJheSh2YWx1ZSkgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExvZGFzaFdyYXBwZXIpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdfX3dyYXBwZWRfXycpKSB7XG4gICAgICByZXR1cm4gd3JhcHBlckNsb25lKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHZhbHVlKTtcbn1cblxuLy8gRW5zdXJlIHdyYXBwZXJzIGFyZSBpbnN0YW5jZXMgb2YgYGJhc2VMb2Rhc2hgLlxubG9kYXNoLnByb3RvdHlwZSA9IGJhc2VMb2Rhc2gucHJvdG90eXBlO1xubG9kYXNoLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGxvZGFzaDtcblxuZXhwb3J0IGRlZmF1bHQgbG9kYXNoO1xuIiwiaW1wb3J0IExhenlXcmFwcGVyIGZyb20gJy4vX0xhenlXcmFwcGVyLmpzJztcbmltcG9ydCBnZXREYXRhIGZyb20gJy4vX2dldERhdGEuanMnO1xuaW1wb3J0IGdldEZ1bmNOYW1lIGZyb20gJy4vX2dldEZ1bmNOYW1lLmpzJztcbmltcG9ydCBsb2Rhc2ggZnJvbSAnLi93cmFwcGVyTG9kYXNoLmpzJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBhIGxhenkgY291bnRlcnBhcnQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBoYXMgYSBsYXp5IGNvdW50ZXJwYXJ0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNMYXppYWJsZShmdW5jKSB7XG4gIHZhciBmdW5jTmFtZSA9IGdldEZ1bmNOYW1lKGZ1bmMpLFxuICAgICAgb3RoZXIgPSBsb2Rhc2hbZnVuY05hbWVdO1xuXG4gIGlmICh0eXBlb2Ygb3RoZXIgIT0gJ2Z1bmN0aW9uJyB8fCAhKGZ1bmNOYW1lIGluIExhenlXcmFwcGVyLnByb3RvdHlwZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGZ1bmMgPT09IG90aGVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIGRhdGEgPSBnZXREYXRhKG90aGVyKTtcbiAgcmV0dXJuICEhZGF0YSAmJiBmdW5jID09PSBkYXRhWzBdO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0xhemlhYmxlO1xuIiwiaW1wb3J0IGJhc2VTZXREYXRhIGZyb20gJy4vX2Jhc2VTZXREYXRhLmpzJztcbmltcG9ydCBzaG9ydE91dCBmcm9tICcuL19zaG9ydE91dC5qcyc7XG5cbi8qKlxuICogU2V0cyBtZXRhZGF0YSBmb3IgYGZ1bmNgLlxuICpcbiAqICoqTm90ZToqKiBJZiB0aGlzIGZ1bmN0aW9uIGJlY29tZXMgaG90LCBpLmUuIGlzIGludm9rZWQgYSBsb3QgaW4gYSBzaG9ydFxuICogcGVyaW9kIG9mIHRpbWUsIGl0IHdpbGwgdHJpcCBpdHMgYnJlYWtlciBhbmQgdHJhbnNpdGlvbiB0byBhbiBpZGVudGl0eVxuICogZnVuY3Rpb24gdG8gYXZvaWQgZ2FyYmFnZSBjb2xsZWN0aW9uIHBhdXNlcyBpbiBWOC4gU2VlXG4gKiBbVjggaXNzdWUgMjA3MF0oaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MjA3MClcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFzc29jaWF0ZSBtZXRhZGF0YSB3aXRoLlxuICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXRhZGF0YS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gKi9cbnZhciBzZXREYXRhID0gc2hvcnRPdXQoYmFzZVNldERhdGEpO1xuXG5leHBvcnQgZGVmYXVsdCBzZXREYXRhO1xuIiwiLyoqIFVzZWQgdG8gbWF0Y2ggd3JhcCBkZXRhaWwgY29tbWVudHMuICovXG52YXIgcmVXcmFwRGV0YWlscyA9IC9cXHtcXG5cXC9cXCogXFxbd3JhcHBlZCB3aXRoICguKylcXF0gXFwqLyxcbiAgICByZVNwbGl0RGV0YWlscyA9IC8sPyAmIC87XG5cbi8qKlxuICogRXh0cmFjdHMgd3JhcHBlciBkZXRhaWxzIGZyb20gdGhlIGBzb3VyY2VgIGJvZHkgY29tbWVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSBUaGUgc291cmNlIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdyYXBwZXIgZGV0YWlscy5cbiAqL1xuZnVuY3Rpb24gZ2V0V3JhcERldGFpbHMoc291cmNlKSB7XG4gIHZhciBtYXRjaCA9IHNvdXJjZS5tYXRjaChyZVdyYXBEZXRhaWxzKTtcbiAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0uc3BsaXQocmVTcGxpdERldGFpbHMpIDogW107XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldFdyYXBEZXRhaWxzO1xuIiwiLyoqIFVzZWQgdG8gbWF0Y2ggd3JhcCBkZXRhaWwgY29tbWVudHMuICovXG52YXIgcmVXcmFwQ29tbWVudCA9IC9cXHsoPzpcXG5cXC9cXCogXFxbd3JhcHBlZCB3aXRoIC4rXFxdIFxcKlxcLyk/XFxuPy87XG5cbi8qKlxuICogSW5zZXJ0cyB3cmFwcGVyIGBkZXRhaWxzYCBpbiBhIGNvbW1lbnQgYXQgdGhlIHRvcCBvZiB0aGUgYHNvdXJjZWAgYm9keS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSBUaGUgc291cmNlIHRvIG1vZGlmeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gZGV0YWlscyBUaGUgZGV0YWlscyB0byBpbnNlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBtb2RpZmllZCBzb3VyY2UuXG4gKi9cbmZ1bmN0aW9uIGluc2VydFdyYXBEZXRhaWxzKHNvdXJjZSwgZGV0YWlscykge1xuICB2YXIgbGVuZ3RoID0gZGV0YWlscy5sZW5ndGg7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTtcbiAgZGV0YWlsc1tsYXN0SW5kZXhdID0gKGxlbmd0aCA+IDEgPyAnJiAnIDogJycpICsgZGV0YWlsc1tsYXN0SW5kZXhdO1xuICBkZXRhaWxzID0gZGV0YWlscy5qb2luKGxlbmd0aCA+IDIgPyAnLCAnIDogJyAnKTtcbiAgcmV0dXJuIHNvdXJjZS5yZXBsYWNlKHJlV3JhcENvbW1lbnQsICd7XFxuLyogW3dyYXBwZWQgd2l0aCAnICsgZGV0YWlscyArICddICovXFxuJyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGluc2VydFdyYXBEZXRhaWxzO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maW5kSW5kZXhgIGFuZCBgXy5maW5kTGFzdEluZGV4YCB3aXRob3V0XG4gKiBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4LCBmcm9tUmlnaHQpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIGluZGV4ID0gZnJvbUluZGV4ICsgKGZyb21SaWdodCA/IDEgOiAtMSk7XG5cbiAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VGaW5kSW5kZXg7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmFOYCB3aXRob3V0IHN1cHBvcnQgZm9yIG51bWJlciBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGBOYU5gLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hTih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlSXNOYU47XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5pbmRleE9mYCB3aGljaCBwZXJmb3JtcyBzdHJpY3QgZXF1YWxpdHlcbiAqIGNvbXBhcmlzb25zIG9mIHZhbHVlcywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBzdHJpY3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gIHZhciBpbmRleCA9IGZyb21JbmRleCAtIDEsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoYXJyYXlbaW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0cmljdEluZGV4T2Y7XG4iLCJpbXBvcnQgYmFzZUZpbmRJbmRleCBmcm9tICcuL19iYXNlRmluZEluZGV4LmpzJztcbmltcG9ydCBiYXNlSXNOYU4gZnJvbSAnLi9fYmFzZUlzTmFOLmpzJztcbmltcG9ydCBzdHJpY3RJbmRleE9mIGZyb20gJy4vX3N0cmljdEluZGV4T2YuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmluZGV4T2ZgIHdpdGhvdXQgYGZyb21JbmRleGAgYm91bmRzIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlXG4gICAgPyBzdHJpY3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KVxuICAgIDogYmFzZUZpbmRJbmRleChhcnJheSwgYmFzZUlzTmFOLCBmcm9tSW5kZXgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlSW5kZXhPZjtcbiIsImltcG9ydCBiYXNlSW5kZXhPZiBmcm9tICcuL19iYXNlSW5kZXhPZi5qcyc7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmluY2x1ZGVzYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIHNwZWNpZnlpbmcgYW4gaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHRhcmdldCBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdGFyZ2V0YCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheUluY2x1ZGVzKGFycmF5LCB2YWx1ZSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gIHJldHVybiAhIWxlbmd0aCAmJiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIDApID4gLTE7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFycmF5SW5jbHVkZXM7XG4iLCJpbXBvcnQgYXJyYXlFYWNoIGZyb20gJy4vX2FycmF5RWFjaC5qcyc7XG5pbXBvcnQgYXJyYXlJbmNsdWRlcyBmcm9tICcuL19hcnJheUluY2x1ZGVzLmpzJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgZnVuY3Rpb24gbWV0YWRhdGEuICovXG52YXIgV1JBUF9CSU5EX0ZMQUcgPSAxLFxuICAgIFdSQVBfQklORF9LRVlfRkxBRyA9IDIsXG4gICAgV1JBUF9DVVJSWV9GTEFHID0gOCxcbiAgICBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcgPSAxNixcbiAgICBXUkFQX1BBUlRJQUxfRkxBRyA9IDMyLFxuICAgIFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHID0gNjQsXG4gICAgV1JBUF9BUllfRkxBRyA9IDEyOCxcbiAgICBXUkFQX1JFQVJHX0ZMQUcgPSAyNTYsXG4gICAgV1JBUF9GTElQX0ZMQUcgPSA1MTI7XG5cbi8qKiBVc2VkIHRvIGFzc29jaWF0ZSB3cmFwIG1ldGhvZHMgd2l0aCB0aGVpciBiaXQgZmxhZ3MuICovXG52YXIgd3JhcEZsYWdzID0gW1xuICBbJ2FyeScsIFdSQVBfQVJZX0ZMQUddLFxuICBbJ2JpbmQnLCBXUkFQX0JJTkRfRkxBR10sXG4gIFsnYmluZEtleScsIFdSQVBfQklORF9LRVlfRkxBR10sXG4gIFsnY3VycnknLCBXUkFQX0NVUlJZX0ZMQUddLFxuICBbJ2N1cnJ5UmlnaHQnLCBXUkFQX0NVUlJZX1JJR0hUX0ZMQUddLFxuICBbJ2ZsaXAnLCBXUkFQX0ZMSVBfRkxBR10sXG4gIFsncGFydGlhbCcsIFdSQVBfUEFSVElBTF9GTEFHXSxcbiAgWydwYXJ0aWFsUmlnaHQnLCBXUkFQX1BBUlRJQUxfUklHSFRfRkxBR10sXG4gIFsncmVhcmcnLCBXUkFQX1JFQVJHX0ZMQUddXG5dO1xuXG4vKipcbiAqIFVwZGF0ZXMgd3JhcHBlciBgZGV0YWlsc2AgYmFzZWQgb24gYGJpdG1hc2tgIGZsYWdzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcmV0dXJucyB7QXJyYXl9IGRldGFpbHMgVGhlIGRldGFpbHMgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgZGV0YWlsc2AuXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZVdyYXBEZXRhaWxzKGRldGFpbHMsIGJpdG1hc2spIHtcbiAgYXJyYXlFYWNoKHdyYXBGbGFncywgZnVuY3Rpb24ocGFpcikge1xuICAgIHZhciB2YWx1ZSA9ICdfLicgKyBwYWlyWzBdO1xuICAgIGlmICgoYml0bWFzayAmIHBhaXJbMV0pICYmICFhcnJheUluY2x1ZGVzKGRldGFpbHMsIHZhbHVlKSkge1xuICAgICAgZGV0YWlscy5wdXNoKHZhbHVlKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZGV0YWlscy5zb3J0KCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHVwZGF0ZVdyYXBEZXRhaWxzO1xuIiwiaW1wb3J0IGdldFdyYXBEZXRhaWxzIGZyb20gJy4vX2dldFdyYXBEZXRhaWxzLmpzJztcbmltcG9ydCBpbnNlcnRXcmFwRGV0YWlscyBmcm9tICcuL19pbnNlcnRXcmFwRGV0YWlscy5qcyc7XG5pbXBvcnQgc2V0VG9TdHJpbmcgZnJvbSAnLi9fc2V0VG9TdHJpbmcuanMnO1xuaW1wb3J0IHVwZGF0ZVdyYXBEZXRhaWxzIGZyb20gJy4vX3VwZGF0ZVdyYXBEZXRhaWxzLmpzJztcblxuLyoqXG4gKiBTZXRzIHRoZSBgdG9TdHJpbmdgIG1ldGhvZCBvZiBgd3JhcHBlcmAgdG8gbWltaWMgdGhlIHNvdXJjZSBvZiBgcmVmZXJlbmNlYFxuICogd2l0aCB3cmFwcGVyIGRldGFpbHMgaW4gYSBjb21tZW50IGF0IHRoZSB0b3Agb2YgdGhlIHNvdXJjZSBib2R5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB3cmFwcGVyIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWZlcmVuY2UgVGhlIHJlZmVyZW5jZSBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYHdyYXBwZXJgLlxuICovXG5mdW5jdGlvbiBzZXRXcmFwVG9TdHJpbmcod3JhcHBlciwgcmVmZXJlbmNlLCBiaXRtYXNrKSB7XG4gIHZhciBzb3VyY2UgPSAocmVmZXJlbmNlICsgJycpO1xuICByZXR1cm4gc2V0VG9TdHJpbmcod3JhcHBlciwgaW5zZXJ0V3JhcERldGFpbHMoc291cmNlLCB1cGRhdGVXcmFwRGV0YWlscyhnZXRXcmFwRGV0YWlscyhzb3VyY2UpLCBiaXRtYXNrKSkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzZXRXcmFwVG9TdHJpbmc7XG4iLCJpbXBvcnQgaXNMYXppYWJsZSBmcm9tICcuL19pc0xhemlhYmxlLmpzJztcbmltcG9ydCBzZXREYXRhIGZyb20gJy4vX3NldERhdGEuanMnO1xuaW1wb3J0IHNldFdyYXBUb1N0cmluZyBmcm9tICcuL19zZXRXcmFwVG9TdHJpbmcuanMnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBmdW5jdGlvbiBtZXRhZGF0YS4gKi9cbnZhciBXUkFQX0JJTkRfRkxBRyA9IDEsXG4gICAgV1JBUF9CSU5EX0tFWV9GTEFHID0gMixcbiAgICBXUkFQX0NVUlJZX0JPVU5EX0ZMQUcgPSA0LFxuICAgIFdSQVBfQ1VSUllfRkxBRyA9IDgsXG4gICAgV1JBUF9QQVJUSUFMX0ZMQUcgPSAzMixcbiAgICBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRyA9IDY0O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCB0byBjb250aW51ZSBjdXJyeWluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB3cmFwRnVuYyBUaGUgZnVuY3Rpb24gdG8gY3JlYXRlIHRoZSBgZnVuY2Agd3JhcHBlci5cbiAqIEBwYXJhbSB7Kn0gcGxhY2Vob2xkZXIgVGhlIHBsYWNlaG9sZGVyIHZhbHVlLlxuICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBwcmVwZW5kIHRvIHRob3NlIHByb3ZpZGVkIHRvXG4gKiAgdGhlIG5ldyBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7QXJyYXl9IFtob2xkZXJzXSBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICogQHBhcmFtIHtBcnJheX0gW2FyZ1Bvc10gVGhlIGFyZ3VtZW50IHBvc2l0aW9ucyBvZiB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFthcnldIFRoZSBhcml0eSBjYXAgb2YgYGZ1bmNgLlxuICogQHBhcmFtIHtudW1iZXJ9IFthcml0eV0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJlY3VycnkoZnVuYywgYml0bWFzaywgd3JhcEZ1bmMsIHBsYWNlaG9sZGVyLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycywgYXJnUG9zLCBhcnksIGFyaXR5KSB7XG4gIHZhciBpc0N1cnJ5ID0gYml0bWFzayAmIFdSQVBfQ1VSUllfRkxBRyxcbiAgICAgIG5ld0hvbGRlcnMgPSBpc0N1cnJ5ID8gaG9sZGVycyA6IHVuZGVmaW5lZCxcbiAgICAgIG5ld0hvbGRlcnNSaWdodCA9IGlzQ3VycnkgPyB1bmRlZmluZWQgOiBob2xkZXJzLFxuICAgICAgbmV3UGFydGlhbHMgPSBpc0N1cnJ5ID8gcGFydGlhbHMgOiB1bmRlZmluZWQsXG4gICAgICBuZXdQYXJ0aWFsc1JpZ2h0ID0gaXNDdXJyeSA/IHVuZGVmaW5lZCA6IHBhcnRpYWxzO1xuXG4gIGJpdG1hc2sgfD0gKGlzQ3VycnkgPyBXUkFQX1BBUlRJQUxfRkxBRyA6IFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHKTtcbiAgYml0bWFzayAmPSB+KGlzQ3VycnkgPyBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRyA6IFdSQVBfUEFSVElBTF9GTEFHKTtcblxuICBpZiAoIShiaXRtYXNrICYgV1JBUF9DVVJSWV9CT1VORF9GTEFHKSkge1xuICAgIGJpdG1hc2sgJj0gfihXUkFQX0JJTkRfRkxBRyB8IFdSQVBfQklORF9LRVlfRkxBRyk7XG4gIH1cbiAgdmFyIG5ld0RhdGEgPSBbXG4gICAgZnVuYywgYml0bWFzaywgdGhpc0FyZywgbmV3UGFydGlhbHMsIG5ld0hvbGRlcnMsIG5ld1BhcnRpYWxzUmlnaHQsXG4gICAgbmV3SG9sZGVyc1JpZ2h0LCBhcmdQb3MsIGFyeSwgYXJpdHlcbiAgXTtcblxuICB2YXIgcmVzdWx0ID0gd3JhcEZ1bmMuYXBwbHkodW5kZWZpbmVkLCBuZXdEYXRhKTtcbiAgaWYgKGlzTGF6aWFibGUoZnVuYykpIHtcbiAgICBzZXREYXRhKHJlc3VsdCwgbmV3RGF0YSk7XG4gIH1cbiAgcmVzdWx0LnBsYWNlaG9sZGVyID0gcGxhY2Vob2xkZXI7XG4gIHJldHVybiBzZXRXcmFwVG9TdHJpbmcocmVzdWx0LCBmdW5jLCBiaXRtYXNrKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlUmVjdXJyeTtcbiIsIi8qKlxuICogR2V0cyB0aGUgYXJndW1lbnQgcGxhY2Vob2xkZXIgdmFsdWUgZm9yIGBmdW5jYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwbGFjZWhvbGRlciB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0SG9sZGVyKGZ1bmMpIHtcbiAgdmFyIG9iamVjdCA9IGZ1bmM7XG4gIHJldHVybiBvYmplY3QucGxhY2Vob2xkZXI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldEhvbGRlcjtcbiIsImltcG9ydCBjb3B5QXJyYXkgZnJvbSAnLi9fY29weUFycmF5LmpzJztcbmltcG9ydCBpc0luZGV4IGZyb20gJy4vX2lzSW5kZXguanMnO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWluID0gTWF0aC5taW47XG5cbi8qKlxuICogUmVvcmRlciBgYXJyYXlgIGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWVkIGluZGV4ZXMgd2hlcmUgdGhlIGVsZW1lbnQgYXRcbiAqIHRoZSBmaXJzdCBpbmRleCBpcyBhc3NpZ25lZCBhcyB0aGUgZmlyc3QgZWxlbWVudCwgdGhlIGVsZW1lbnQgYXRcbiAqIHRoZSBzZWNvbmQgaW5kZXggaXMgYXNzaWduZWQgYXMgdGhlIHNlY29uZCBlbGVtZW50LCBhbmQgc28gb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byByZW9yZGVyLlxuICogQHBhcmFtIHtBcnJheX0gaW5kZXhlcyBUaGUgYXJyYW5nZWQgYXJyYXkgaW5kZXhlcy5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiByZW9yZGVyKGFycmF5LCBpbmRleGVzKSB7XG4gIHZhciBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBsZW5ndGggPSBuYXRpdmVNaW4oaW5kZXhlcy5sZW5ndGgsIGFyckxlbmd0aCksXG4gICAgICBvbGRBcnJheSA9IGNvcHlBcnJheShhcnJheSk7XG5cbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgdmFyIGluZGV4ID0gaW5kZXhlc1tsZW5ndGhdO1xuICAgIGFycmF5W2xlbmd0aF0gPSBpc0luZGV4KGluZGV4LCBhcnJMZW5ndGgpID8gb2xkQXJyYXlbaW5kZXhdIDogdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgcmVvcmRlcjtcbiIsIi8qKiBVc2VkIGFzIHRoZSBpbnRlcm5hbCBhcmd1bWVudCBwbGFjZWhvbGRlci4gKi9cbnZhciBQTEFDRUhPTERFUiA9ICdfX2xvZGFzaF9wbGFjZWhvbGRlcl9fJztcblxuLyoqXG4gKiBSZXBsYWNlcyBhbGwgYHBsYWNlaG9sZGVyYCBlbGVtZW50cyBpbiBgYXJyYXlgIHdpdGggYW4gaW50ZXJuYWwgcGxhY2Vob2xkZXJcbiAqIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIHRoZWlyIGluZGV4ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0geyp9IHBsYWNlaG9sZGVyIFRoZSBwbGFjZWhvbGRlciB0byByZXBsYWNlLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAqL1xuZnVuY3Rpb24gcmVwbGFjZUhvbGRlcnMoYXJyYXksIHBsYWNlaG9sZGVyKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgaWYgKHZhbHVlID09PSBwbGFjZWhvbGRlciB8fCB2YWx1ZSA9PT0gUExBQ0VIT0xERVIpIHtcbiAgICAgIGFycmF5W2luZGV4XSA9IFBMQUNFSE9MREVSO1xuICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gaW5kZXg7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHJlcGxhY2VIb2xkZXJzO1xuIiwiaW1wb3J0IGNvbXBvc2VBcmdzIGZyb20gJy4vX2NvbXBvc2VBcmdzLmpzJztcbmltcG9ydCBjb21wb3NlQXJnc1JpZ2h0IGZyb20gJy4vX2NvbXBvc2VBcmdzUmlnaHQuanMnO1xuaW1wb3J0IGNvdW50SG9sZGVycyBmcm9tICcuL19jb3VudEhvbGRlcnMuanMnO1xuaW1wb3J0IGNyZWF0ZUN0b3IgZnJvbSAnLi9fY3JlYXRlQ3Rvci5qcyc7XG5pbXBvcnQgY3JlYXRlUmVjdXJyeSBmcm9tICcuL19jcmVhdGVSZWN1cnJ5LmpzJztcbmltcG9ydCBnZXRIb2xkZXIgZnJvbSAnLi9fZ2V0SG9sZGVyLmpzJztcbmltcG9ydCByZW9yZGVyIGZyb20gJy4vX3Jlb3JkZXIuanMnO1xuaW1wb3J0IHJlcGxhY2VIb2xkZXJzIGZyb20gJy4vX3JlcGxhY2VIb2xkZXJzLmpzJztcbmltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBmdW5jdGlvbiBtZXRhZGF0YS4gKi9cbnZhciBXUkFQX0JJTkRfRkxBRyA9IDEsXG4gICAgV1JBUF9CSU5EX0tFWV9GTEFHID0gMixcbiAgICBXUkFQX0NVUlJZX0ZMQUcgPSA4LFxuICAgIFdSQVBfQ1VSUllfUklHSFRfRkxBRyA9IDE2LFxuICAgIFdSQVBfQVJZX0ZMQUcgPSAxMjgsXG4gICAgV1JBUF9GTElQX0ZMQUcgPSA1MTI7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIHRvIGludm9rZSBpdCB3aXRoIG9wdGlvbmFsIGB0aGlzYFxuICogYmluZGluZyBvZiBgdGhpc0FyZ2AsIHBhcnRpYWwgYXBwbGljYXRpb24sIGFuZCBjdXJyeWluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbnxzdHJpbmd9IGZ1bmMgVGhlIGZ1bmN0aW9uIG9yIG1ldGhvZCBuYW1lIHRvIHdyYXAuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBwcmVwZW5kIHRvIHRob3NlIHByb3ZpZGVkIHRvXG4gKiAgdGhlIG5ldyBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7QXJyYXl9IFtob2xkZXJzXSBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxzUmlnaHRdIFRoZSBhcmd1bWVudHMgdG8gYXBwZW5kIHRvIHRob3NlIHByb3ZpZGVkXG4gKiAgdG8gdGhlIG5ldyBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7QXJyYXl9IFtob2xkZXJzUmlnaHRdIFRoZSBgcGFydGlhbHNSaWdodGAgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAqIEBwYXJhbSB7QXJyYXl9IFthcmdQb3NdIFRoZSBhcmd1bWVudCBwb3NpdGlvbnMgb2YgdGhlIG5ldyBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbYXJ5XSBUaGUgYXJpdHkgY2FwIG9mIGBmdW5jYC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHldIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVIeWJyaWQoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMsIHBhcnRpYWxzUmlnaHQsIGhvbGRlcnNSaWdodCwgYXJnUG9zLCBhcnksIGFyaXR5KSB7XG4gIHZhciBpc0FyeSA9IGJpdG1hc2sgJiBXUkFQX0FSWV9GTEFHLFxuICAgICAgaXNCaW5kID0gYml0bWFzayAmIFdSQVBfQklORF9GTEFHLFxuICAgICAgaXNCaW5kS2V5ID0gYml0bWFzayAmIFdSQVBfQklORF9LRVlfRkxBRyxcbiAgICAgIGlzQ3VycmllZCA9IGJpdG1hc2sgJiAoV1JBUF9DVVJSWV9GTEFHIHwgV1JBUF9DVVJSWV9SSUdIVF9GTEFHKSxcbiAgICAgIGlzRmxpcCA9IGJpdG1hc2sgJiBXUkFQX0ZMSVBfRkxBRyxcbiAgICAgIEN0b3IgPSBpc0JpbmRLZXkgPyB1bmRlZmluZWQgOiBjcmVhdGVDdG9yKGZ1bmMpO1xuXG4gIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgIGFyZ3MgPSBBcnJheShsZW5ndGgpLFxuICAgICAgICBpbmRleCA9IGxlbmd0aDtcblxuICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICBhcmdzW2luZGV4XSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgfVxuICAgIGlmIChpc0N1cnJpZWQpIHtcbiAgICAgIHZhciBwbGFjZWhvbGRlciA9IGdldEhvbGRlcih3cmFwcGVyKSxcbiAgICAgICAgICBob2xkZXJzQ291bnQgPSBjb3VudEhvbGRlcnMoYXJncywgcGxhY2Vob2xkZXIpO1xuICAgIH1cbiAgICBpZiAocGFydGlhbHMpIHtcbiAgICAgIGFyZ3MgPSBjb21wb3NlQXJncyhhcmdzLCBwYXJ0aWFscywgaG9sZGVycywgaXNDdXJyaWVkKTtcbiAgICB9XG4gICAgaWYgKHBhcnRpYWxzUmlnaHQpIHtcbiAgICAgIGFyZ3MgPSBjb21wb3NlQXJnc1JpZ2h0KGFyZ3MsIHBhcnRpYWxzUmlnaHQsIGhvbGRlcnNSaWdodCwgaXNDdXJyaWVkKTtcbiAgICB9XG4gICAgbGVuZ3RoIC09IGhvbGRlcnNDb3VudDtcbiAgICBpZiAoaXNDdXJyaWVkICYmIGxlbmd0aCA8IGFyaXR5KSB7XG4gICAgICB2YXIgbmV3SG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKGFyZ3MsIHBsYWNlaG9sZGVyKTtcbiAgICAgIHJldHVybiBjcmVhdGVSZWN1cnJ5KFxuICAgICAgICBmdW5jLCBiaXRtYXNrLCBjcmVhdGVIeWJyaWQsIHdyYXBwZXIucGxhY2Vob2xkZXIsIHRoaXNBcmcsXG4gICAgICAgIGFyZ3MsIG5ld0hvbGRlcnMsIGFyZ1BvcywgYXJ5LCBhcml0eSAtIGxlbmd0aFxuICAgICAgKTtcbiAgICB9XG4gICAgdmFyIHRoaXNCaW5kaW5nID0gaXNCaW5kID8gdGhpc0FyZyA6IHRoaXMsXG4gICAgICAgIGZuID0gaXNCaW5kS2V5ID8gdGhpc0JpbmRpbmdbZnVuY10gOiBmdW5jO1xuXG4gICAgbGVuZ3RoID0gYXJncy5sZW5ndGg7XG4gICAgaWYgKGFyZ1Bvcykge1xuICAgICAgYXJncyA9IHJlb3JkZXIoYXJncywgYXJnUG9zKTtcbiAgICB9IGVsc2UgaWYgKGlzRmxpcCAmJiBsZW5ndGggPiAxKSB7XG4gICAgICBhcmdzLnJldmVyc2UoKTtcbiAgICB9XG4gICAgaWYgKGlzQXJ5ICYmIGFyeSA8IGxlbmd0aCkge1xuICAgICAgYXJncy5sZW5ndGggPSBhcnk7XG4gICAgfVxuICAgIGlmICh0aGlzICYmIHRoaXMgIT09IHJvb3QgJiYgdGhpcyBpbnN0YW5jZW9mIHdyYXBwZXIpIHtcbiAgICAgIGZuID0gQ3RvciB8fCBjcmVhdGVDdG9yKGZuKTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNCaW5kaW5nLCBhcmdzKTtcbiAgfVxuICByZXR1cm4gd3JhcHBlcjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlSHlicmlkO1xuIiwiaW1wb3J0IGFwcGx5IGZyb20gJy4vX2FwcGx5LmpzJztcbmltcG9ydCBjcmVhdGVDdG9yIGZyb20gJy4vX2NyZWF0ZUN0b3IuanMnO1xuaW1wb3J0IGNyZWF0ZUh5YnJpZCBmcm9tICcuL19jcmVhdGVIeWJyaWQuanMnO1xuaW1wb3J0IGNyZWF0ZVJlY3VycnkgZnJvbSAnLi9fY3JlYXRlUmVjdXJyeS5qcyc7XG5pbXBvcnQgZ2V0SG9sZGVyIGZyb20gJy4vX2dldEhvbGRlci5qcyc7XG5pbXBvcnQgcmVwbGFjZUhvbGRlcnMgZnJvbSAnLi9fcmVwbGFjZUhvbGRlcnMuanMnO1xuaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIHRvIGVuYWJsZSBjdXJyeWluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge251bWJlcn0gYXJpdHkgVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUN1cnJ5KGZ1bmMsIGJpdG1hc2ssIGFyaXR5KSB7XG4gIHZhciBDdG9yID0gY3JlYXRlQ3RvcihmdW5jKTtcblxuICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICBhcmdzID0gQXJyYXkobGVuZ3RoKSxcbiAgICAgICAgaW5kZXggPSBsZW5ndGgsXG4gICAgICAgIHBsYWNlaG9sZGVyID0gZ2V0SG9sZGVyKHdyYXBwZXIpO1xuXG4gICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgIGFyZ3NbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICB9XG4gICAgdmFyIGhvbGRlcnMgPSAobGVuZ3RoIDwgMyAmJiBhcmdzWzBdICE9PSBwbGFjZWhvbGRlciAmJiBhcmdzW2xlbmd0aCAtIDFdICE9PSBwbGFjZWhvbGRlcilcbiAgICAgID8gW11cbiAgICAgIDogcmVwbGFjZUhvbGRlcnMoYXJncywgcGxhY2Vob2xkZXIpO1xuXG4gICAgbGVuZ3RoIC09IGhvbGRlcnMubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPCBhcml0eSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVJlY3VycnkoXG4gICAgICAgIGZ1bmMsIGJpdG1hc2ssIGNyZWF0ZUh5YnJpZCwgd3JhcHBlci5wbGFjZWhvbGRlciwgdW5kZWZpbmVkLFxuICAgICAgICBhcmdzLCBob2xkZXJzLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgYXJpdHkgLSBsZW5ndGgpO1xuICAgIH1cbiAgICB2YXIgZm4gPSAodGhpcyAmJiB0aGlzICE9PSByb290ICYmIHRoaXMgaW5zdGFuY2VvZiB3cmFwcGVyKSA/IEN0b3IgOiBmdW5jO1xuICAgIHJldHVybiBhcHBseShmbiwgdGhpcywgYXJncyk7XG4gIH1cbiAgcmV0dXJuIHdyYXBwZXI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZUN1cnJ5O1xuIiwiaW1wb3J0IGFwcGx5IGZyb20gJy4vX2FwcGx5LmpzJztcbmltcG9ydCBjcmVhdGVDdG9yIGZyb20gJy4vX2NyZWF0ZUN0b3IuanMnO1xuaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGZ1bmN0aW9uIG1ldGFkYXRhLiAqL1xudmFyIFdSQVBfQklORF9GTEFHID0gMTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgdG8gaW52b2tlIGl0IHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nXG4gKiBvZiBgdGhpc0FyZ2AgYW5kIGBwYXJ0aWFsc2AgcHJlcGVuZGVkIHRvIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge0FycmF5fSBwYXJ0aWFscyBUaGUgYXJndW1lbnRzIHRvIHByZXBlbmQgdG8gdGhvc2UgcHJvdmlkZWQgdG9cbiAqICB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUGFydGlhbChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscykge1xuICB2YXIgaXNCaW5kID0gYml0bWFzayAmIFdSQVBfQklORF9GTEFHLFxuICAgICAgQ3RvciA9IGNyZWF0ZUN0b3IoZnVuYyk7XG5cbiAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICB2YXIgYXJnc0luZGV4ID0gLTEsXG4gICAgICAgIGFyZ3NMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICBsZWZ0SW5kZXggPSAtMSxcbiAgICAgICAgbGVmdExlbmd0aCA9IHBhcnRpYWxzLmxlbmd0aCxcbiAgICAgICAgYXJncyA9IEFycmF5KGxlZnRMZW5ndGggKyBhcmdzTGVuZ3RoKSxcbiAgICAgICAgZm4gPSAodGhpcyAmJiB0aGlzICE9PSByb290ICYmIHRoaXMgaW5zdGFuY2VvZiB3cmFwcGVyKSA/IEN0b3IgOiBmdW5jO1xuXG4gICAgd2hpbGUgKCsrbGVmdEluZGV4IDwgbGVmdExlbmd0aCkge1xuICAgICAgYXJnc1tsZWZ0SW5kZXhdID0gcGFydGlhbHNbbGVmdEluZGV4XTtcbiAgICB9XG4gICAgd2hpbGUgKGFyZ3NMZW5ndGgtLSkge1xuICAgICAgYXJnc1tsZWZ0SW5kZXgrK10gPSBhcmd1bWVudHNbKythcmdzSW5kZXhdO1xuICAgIH1cbiAgICByZXR1cm4gYXBwbHkoZm4sIGlzQmluZCA/IHRoaXNBcmcgOiB0aGlzLCBhcmdzKTtcbiAgfVxuICByZXR1cm4gd3JhcHBlcjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlUGFydGlhbDtcbiIsImltcG9ydCBjb21wb3NlQXJncyBmcm9tICcuL19jb21wb3NlQXJncy5qcyc7XG5pbXBvcnQgY29tcG9zZUFyZ3NSaWdodCBmcm9tICcuL19jb21wb3NlQXJnc1JpZ2h0LmpzJztcbmltcG9ydCByZXBsYWNlSG9sZGVycyBmcm9tICcuL19yZXBsYWNlSG9sZGVycy5qcyc7XG5cbi8qKiBVc2VkIGFzIHRoZSBpbnRlcm5hbCBhcmd1bWVudCBwbGFjZWhvbGRlci4gKi9cbnZhciBQTEFDRUhPTERFUiA9ICdfX2xvZGFzaF9wbGFjZWhvbGRlcl9fJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgZnVuY3Rpb24gbWV0YWRhdGEuICovXG52YXIgV1JBUF9CSU5EX0ZMQUcgPSAxLFxuICAgIFdSQVBfQklORF9LRVlfRkxBRyA9IDIsXG4gICAgV1JBUF9DVVJSWV9CT1VORF9GTEFHID0gNCxcbiAgICBXUkFQX0NVUlJZX0ZMQUcgPSA4LFxuICAgIFdSQVBfQVJZX0ZMQUcgPSAxMjgsXG4gICAgV1JBUF9SRUFSR19GTEFHID0gMjU2O1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWluID0gTWF0aC5taW47XG5cbi8qKlxuICogTWVyZ2VzIHRoZSBmdW5jdGlvbiBtZXRhZGF0YSBvZiBgc291cmNlYCBpbnRvIGBkYXRhYC5cbiAqXG4gKiBNZXJnaW5nIG1ldGFkYXRhIHJlZHVjZXMgdGhlIG51bWJlciBvZiB3cmFwcGVycyB1c2VkIHRvIGludm9rZSBhIGZ1bmN0aW9uLlxuICogVGhpcyBpcyBwb3NzaWJsZSBiZWNhdXNlIG1ldGhvZHMgbGlrZSBgXy5iaW5kYCwgYF8uY3VycnlgLCBhbmQgYF8ucGFydGlhbGBcbiAqIG1heSBiZSBhcHBsaWVkIHJlZ2FyZGxlc3Mgb2YgZXhlY3V0aW9uIG9yZGVyLiBNZXRob2RzIGxpa2UgYF8uYXJ5YCBhbmRcbiAqIGBfLnJlYXJnYCBtb2RpZnkgZnVuY3Rpb24gYXJndW1lbnRzLCBtYWtpbmcgdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgYXJlXG4gKiBleGVjdXRlZCBpbXBvcnRhbnQsIHByZXZlbnRpbmcgdGhlIG1lcmdpbmcgb2YgbWV0YWRhdGEuIEhvd2V2ZXIsIHdlIG1ha2VcbiAqIGFuIGV4Y2VwdGlvbiBmb3IgYSBzYWZlIGNvbWJpbmVkIGNhc2Ugd2hlcmUgY3VycmllZCBmdW5jdGlvbnMgaGF2ZSBgXy5hcnlgXG4gKiBhbmQgb3IgYF8ucmVhcmdgIGFwcGxpZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgVGhlIGRlc3RpbmF0aW9uIG1ldGFkYXRhLlxuICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBzb3VyY2UgbWV0YWRhdGEuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGRhdGFgLlxuICovXG5mdW5jdGlvbiBtZXJnZURhdGEoZGF0YSwgc291cmNlKSB7XG4gIHZhciBiaXRtYXNrID0gZGF0YVsxXSxcbiAgICAgIHNyY0JpdG1hc2sgPSBzb3VyY2VbMV0sXG4gICAgICBuZXdCaXRtYXNrID0gYml0bWFzayB8IHNyY0JpdG1hc2ssXG4gICAgICBpc0NvbW1vbiA9IG5ld0JpdG1hc2sgPCAoV1JBUF9CSU5EX0ZMQUcgfCBXUkFQX0JJTkRfS0VZX0ZMQUcgfCBXUkFQX0FSWV9GTEFHKTtcblxuICB2YXIgaXNDb21ibyA9XG4gICAgKChzcmNCaXRtYXNrID09IFdSQVBfQVJZX0ZMQUcpICYmIChiaXRtYXNrID09IFdSQVBfQ1VSUllfRkxBRykpIHx8XG4gICAgKChzcmNCaXRtYXNrID09IFdSQVBfQVJZX0ZMQUcpICYmIChiaXRtYXNrID09IFdSQVBfUkVBUkdfRkxBRykgJiYgKGRhdGFbN10ubGVuZ3RoIDw9IHNvdXJjZVs4XSkpIHx8XG4gICAgKChzcmNCaXRtYXNrID09IChXUkFQX0FSWV9GTEFHIHwgV1JBUF9SRUFSR19GTEFHKSkgJiYgKHNvdXJjZVs3XS5sZW5ndGggPD0gc291cmNlWzhdKSAmJiAoYml0bWFzayA9PSBXUkFQX0NVUlJZX0ZMQUcpKTtcblxuICAvLyBFeGl0IGVhcmx5IGlmIG1ldGFkYXRhIGNhbid0IGJlIG1lcmdlZC5cbiAgaWYgKCEoaXNDb21tb24gfHwgaXNDb21ibykpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICAvLyBVc2Ugc291cmNlIGB0aGlzQXJnYCBpZiBhdmFpbGFibGUuXG4gIGlmIChzcmNCaXRtYXNrICYgV1JBUF9CSU5EX0ZMQUcpIHtcbiAgICBkYXRhWzJdID0gc291cmNlWzJdO1xuICAgIC8vIFNldCB3aGVuIGN1cnJ5aW5nIGEgYm91bmQgZnVuY3Rpb24uXG4gICAgbmV3Qml0bWFzayB8PSBiaXRtYXNrICYgV1JBUF9CSU5EX0ZMQUcgPyAwIDogV1JBUF9DVVJSWV9CT1VORF9GTEFHO1xuICB9XG4gIC8vIENvbXBvc2UgcGFydGlhbCBhcmd1bWVudHMuXG4gIHZhciB2YWx1ZSA9IHNvdXJjZVszXTtcbiAgaWYgKHZhbHVlKSB7XG4gICAgdmFyIHBhcnRpYWxzID0gZGF0YVszXTtcbiAgICBkYXRhWzNdID0gcGFydGlhbHMgPyBjb21wb3NlQXJncyhwYXJ0aWFscywgdmFsdWUsIHNvdXJjZVs0XSkgOiB2YWx1ZTtcbiAgICBkYXRhWzRdID0gcGFydGlhbHMgPyByZXBsYWNlSG9sZGVycyhkYXRhWzNdLCBQTEFDRUhPTERFUikgOiBzb3VyY2VbNF07XG4gIH1cbiAgLy8gQ29tcG9zZSBwYXJ0aWFsIHJpZ2h0IGFyZ3VtZW50cy5cbiAgdmFsdWUgPSBzb3VyY2VbNV07XG4gIGlmICh2YWx1ZSkge1xuICAgIHBhcnRpYWxzID0gZGF0YVs1XTtcbiAgICBkYXRhWzVdID0gcGFydGlhbHMgPyBjb21wb3NlQXJnc1JpZ2h0KHBhcnRpYWxzLCB2YWx1ZSwgc291cmNlWzZdKSA6IHZhbHVlO1xuICAgIGRhdGFbNl0gPSBwYXJ0aWFscyA/IHJlcGxhY2VIb2xkZXJzKGRhdGFbNV0sIFBMQUNFSE9MREVSKSA6IHNvdXJjZVs2XTtcbiAgfVxuICAvLyBVc2Ugc291cmNlIGBhcmdQb3NgIGlmIGF2YWlsYWJsZS5cbiAgdmFsdWUgPSBzb3VyY2VbN107XG4gIGlmICh2YWx1ZSkge1xuICAgIGRhdGFbN10gPSB2YWx1ZTtcbiAgfVxuICAvLyBVc2Ugc291cmNlIGBhcnlgIGlmIGl0J3Mgc21hbGxlci5cbiAgaWYgKHNyY0JpdG1hc2sgJiBXUkFQX0FSWV9GTEFHKSB7XG4gICAgZGF0YVs4XSA9IGRhdGFbOF0gPT0gbnVsbCA/IHNvdXJjZVs4XSA6IG5hdGl2ZU1pbihkYXRhWzhdLCBzb3VyY2VbOF0pO1xuICB9XG4gIC8vIFVzZSBzb3VyY2UgYGFyaXR5YCBpZiBvbmUgaXMgbm90IHByb3ZpZGVkLlxuICBpZiAoZGF0YVs5XSA9PSBudWxsKSB7XG4gICAgZGF0YVs5XSA9IHNvdXJjZVs5XTtcbiAgfVxuICAvLyBVc2Ugc291cmNlIGBmdW5jYCBhbmQgbWVyZ2UgYml0bWFza3MuXG4gIGRhdGFbMF0gPSBzb3VyY2VbMF07XG4gIGRhdGFbMV0gPSBuZXdCaXRtYXNrO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG5leHBvcnQgZGVmYXVsdCBtZXJnZURhdGE7XG4iLCJpbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdC5qcyc7XG5pbXBvcnQgaXNTeW1ib2wgZnJvbSAnLi9pc1N5bWJvbC5qcyc7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE5BTiA9IDAgLyAwO1xuXG4vKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlLiAqL1xudmFyIHJlVHJpbSA9IC9eXFxzK3xcXHMrJC9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmFkIHNpZ25lZCBoZXhhZGVjaW1hbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCYWRIZXggPSAvXlstK10weFswLTlhLWZdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJpbmFyeSBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCaW5hcnkgPSAvXjBiWzAxXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvY3RhbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNPY3RhbCA9IC9eMG9bMC03XSskL2k7XG5cbi8qKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB3aXRob3V0IGEgZGVwZW5kZW5jeSBvbiBgcm9vdGAuICovXG52YXIgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b051bWJlcigzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xuICogLy8gPT4gSW5maW5pdHlcbiAqXG4gKiBfLnRvTnVtYmVyKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gTkFOO1xuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgdmFsdWUgPSBpc09iamVjdChvdGhlcikgPyAob3RoZXIgKyAnJykgOiBvdGhlcjtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiArdmFsdWU7XG4gIH1cbiAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHJlVHJpbSwgJycpO1xuICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpO1xuICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcbiAgICA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOClcbiAgICA6IChyZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdG9OdW1iZXI7XG4iLCJpbXBvcnQgdG9OdW1iZXIgZnJvbSAnLi90b051bWJlci5qcyc7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDAsXG4gICAgTUFYX0lOVEVHRVIgPSAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwODtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgZmluaXRlIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTIuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgbnVtYmVyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvRmluaXRlKDMuMik7XG4gKiAvLyA9PiAzLjJcbiAqXG4gKiBfLnRvRmluaXRlKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gNWUtMzI0XG4gKlxuICogXy50b0Zpbml0ZShJbmZpbml0eSk7XG4gKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICpcbiAqIF8udG9GaW5pdGUoJzMuMicpO1xuICogLy8gPT4gMy4yXG4gKi9cbmZ1bmN0aW9uIHRvRmluaXRlKHZhbHVlKSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6IDA7XG4gIH1cbiAgdmFsdWUgPSB0b051bWJlcih2YWx1ZSk7XG4gIGlmICh2YWx1ZSA9PT0gSU5GSU5JVFkgfHwgdmFsdWUgPT09IC1JTkZJTklUWSkge1xuICAgIHZhciBzaWduID0gKHZhbHVlIDwgMCA/IC0xIDogMSk7XG4gICAgcmV0dXJuIHNpZ24gKiBNQVhfSU5URUdFUjtcbiAgfVxuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlID8gdmFsdWUgOiAwO1xufVxuXG5leHBvcnQgZGVmYXVsdCB0b0Zpbml0ZTtcbiIsImltcG9ydCB0b0Zpbml0ZSBmcm9tICcuL3RvRmluaXRlLmpzJztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGludGVnZXIuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9JbnRlZ2VyYF0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvaW50ZWdlcikuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b0ludGVnZXIoMy4yKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLnRvSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDBcbiAqXG4gKiBfLnRvSW50ZWdlcihJbmZpbml0eSk7XG4gKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICpcbiAqIF8udG9JbnRlZ2VyKCczLjInKTtcbiAqIC8vID0+IDNcbiAqL1xuZnVuY3Rpb24gdG9JbnRlZ2VyKHZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSB0b0Zpbml0ZSh2YWx1ZSksXG4gICAgICByZW1haW5kZXIgPSByZXN1bHQgJSAxO1xuXG4gIHJldHVybiByZXN1bHQgPT09IHJlc3VsdCA/IChyZW1haW5kZXIgPyByZXN1bHQgLSByZW1haW5kZXIgOiByZXN1bHQpIDogMDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdG9JbnRlZ2VyO1xuIiwiaW1wb3J0IGJhc2VTZXREYXRhIGZyb20gJy4vX2Jhc2VTZXREYXRhLmpzJztcbmltcG9ydCBjcmVhdGVCaW5kIGZyb20gJy4vX2NyZWF0ZUJpbmQuanMnO1xuaW1wb3J0IGNyZWF0ZUN1cnJ5IGZyb20gJy4vX2NyZWF0ZUN1cnJ5LmpzJztcbmltcG9ydCBjcmVhdGVIeWJyaWQgZnJvbSAnLi9fY3JlYXRlSHlicmlkLmpzJztcbmltcG9ydCBjcmVhdGVQYXJ0aWFsIGZyb20gJy4vX2NyZWF0ZVBhcnRpYWwuanMnO1xuaW1wb3J0IGdldERhdGEgZnJvbSAnLi9fZ2V0RGF0YS5qcyc7XG5pbXBvcnQgbWVyZ2VEYXRhIGZyb20gJy4vX21lcmdlRGF0YS5qcyc7XG5pbXBvcnQgc2V0RGF0YSBmcm9tICcuL19zZXREYXRhLmpzJztcbmltcG9ydCBzZXRXcmFwVG9TdHJpbmcgZnJvbSAnLi9fc2V0V3JhcFRvU3RyaW5nLmpzJztcbmltcG9ydCB0b0ludGVnZXIgZnJvbSAnLi90b0ludGVnZXIuanMnO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBmdW5jdGlvbiBtZXRhZGF0YS4gKi9cbnZhciBXUkFQX0JJTkRfRkxBRyA9IDEsXG4gICAgV1JBUF9CSU5EX0tFWV9GTEFHID0gMixcbiAgICBXUkFQX0NVUlJZX0ZMQUcgPSA4LFxuICAgIFdSQVBfQ1VSUllfUklHSFRfRkxBRyA9IDE2LFxuICAgIFdSQVBfUEFSVElBTF9GTEFHID0gMzIsXG4gICAgV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcgPSA2NDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGVpdGhlciBjdXJyaWVzIG9yIGludm9rZXMgYGZ1bmNgIHdpdGggb3B0aW9uYWxcbiAqIGB0aGlzYCBiaW5kaW5nIGFuZCBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb258c3RyaW5nfSBmdW5jIFRoZSBmdW5jdGlvbiBvciBtZXRob2QgbmFtZSB0byB3cmFwLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gKiAgICAxIC0gYF8uYmluZGBcbiAqICAgIDIgLSBgXy5iaW5kS2V5YFxuICogICAgNCAtIGBfLmN1cnJ5YCBvciBgXy5jdXJyeVJpZ2h0YCBvZiBhIGJvdW5kIGZ1bmN0aW9uXG4gKiAgICA4IC0gYF8uY3VycnlgXG4gKiAgIDE2IC0gYF8uY3VycnlSaWdodGBcbiAqICAgMzIgLSBgXy5wYXJ0aWFsYFxuICogICA2NCAtIGBfLnBhcnRpYWxSaWdodGBcbiAqICAxMjggLSBgXy5yZWFyZ2BcbiAqICAyNTYgLSBgXy5hcnlgXG4gKiAgNTEyIC0gYF8uZmxpcGBcbiAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gKiBAcGFyYW0ge0FycmF5fSBbaG9sZGVyc10gVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAqIEBwYXJhbSB7QXJyYXl9IFthcmdQb3NdIFRoZSBhcmd1bWVudCBwb3NpdGlvbnMgb2YgdGhlIG5ldyBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbYXJ5XSBUaGUgYXJpdHkgY2FwIG9mIGBmdW5jYC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHldIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVXcmFwKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzLCBhcmdQb3MsIGFyeSwgYXJpdHkpIHtcbiAgdmFyIGlzQmluZEtleSA9IGJpdG1hc2sgJiBXUkFQX0JJTkRfS0VZX0ZMQUc7XG4gIGlmICghaXNCaW5kS2V5ICYmIHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgdmFyIGxlbmd0aCA9IHBhcnRpYWxzID8gcGFydGlhbHMubGVuZ3RoIDogMDtcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBiaXRtYXNrICY9IH4oV1JBUF9QQVJUSUFMX0ZMQUcgfCBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRyk7XG4gICAgcGFydGlhbHMgPSBob2xkZXJzID0gdW5kZWZpbmVkO1xuICB9XG4gIGFyeSA9IGFyeSA9PT0gdW5kZWZpbmVkID8gYXJ5IDogbmF0aXZlTWF4KHRvSW50ZWdlcihhcnkpLCAwKTtcbiAgYXJpdHkgPSBhcml0eSA9PT0gdW5kZWZpbmVkID8gYXJpdHkgOiB0b0ludGVnZXIoYXJpdHkpO1xuICBsZW5ndGggLT0gaG9sZGVycyA/IGhvbGRlcnMubGVuZ3RoIDogMDtcblxuICBpZiAoYml0bWFzayAmIFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHKSB7XG4gICAgdmFyIHBhcnRpYWxzUmlnaHQgPSBwYXJ0aWFscyxcbiAgICAgICAgaG9sZGVyc1JpZ2h0ID0gaG9sZGVycztcblxuICAgIHBhcnRpYWxzID0gaG9sZGVycyA9IHVuZGVmaW5lZDtcbiAgfVxuICB2YXIgZGF0YSA9IGlzQmluZEtleSA/IHVuZGVmaW5lZCA6IGdldERhdGEoZnVuYyk7XG5cbiAgdmFyIG5ld0RhdGEgPSBbXG4gICAgZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMsIHBhcnRpYWxzUmlnaHQsIGhvbGRlcnNSaWdodCxcbiAgICBhcmdQb3MsIGFyeSwgYXJpdHlcbiAgXTtcblxuICBpZiAoZGF0YSkge1xuICAgIG1lcmdlRGF0YShuZXdEYXRhLCBkYXRhKTtcbiAgfVxuICBmdW5jID0gbmV3RGF0YVswXTtcbiAgYml0bWFzayA9IG5ld0RhdGFbMV07XG4gIHRoaXNBcmcgPSBuZXdEYXRhWzJdO1xuICBwYXJ0aWFscyA9IG5ld0RhdGFbM107XG4gIGhvbGRlcnMgPSBuZXdEYXRhWzRdO1xuICBhcml0eSA9IG5ld0RhdGFbOV0gPSBuZXdEYXRhWzldID09PSB1bmRlZmluZWRcbiAgICA/IChpc0JpbmRLZXkgPyAwIDogZnVuYy5sZW5ndGgpXG4gICAgOiBuYXRpdmVNYXgobmV3RGF0YVs5XSAtIGxlbmd0aCwgMCk7XG5cbiAgaWYgKCFhcml0eSAmJiBiaXRtYXNrICYgKFdSQVBfQ1VSUllfRkxBRyB8IFdSQVBfQ1VSUllfUklHSFRfRkxBRykpIHtcbiAgICBiaXRtYXNrICY9IH4oV1JBUF9DVVJSWV9GTEFHIHwgV1JBUF9DVVJSWV9SSUdIVF9GTEFHKTtcbiAgfVxuICBpZiAoIWJpdG1hc2sgfHwgYml0bWFzayA9PSBXUkFQX0JJTkRfRkxBRykge1xuICAgIHZhciByZXN1bHQgPSBjcmVhdGVCaW5kKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcpO1xuICB9IGVsc2UgaWYgKGJpdG1hc2sgPT0gV1JBUF9DVVJSWV9GTEFHIHx8IGJpdG1hc2sgPT0gV1JBUF9DVVJSWV9SSUdIVF9GTEFHKSB7XG4gICAgcmVzdWx0ID0gY3JlYXRlQ3VycnkoZnVuYywgYml0bWFzaywgYXJpdHkpO1xuICB9IGVsc2UgaWYgKChiaXRtYXNrID09IFdSQVBfUEFSVElBTF9GTEFHIHx8IGJpdG1hc2sgPT0gKFdSQVBfQklORF9GTEFHIHwgV1JBUF9QQVJUSUFMX0ZMQUcpKSAmJiAhaG9sZGVycy5sZW5ndGgpIHtcbiAgICByZXN1bHQgPSBjcmVhdGVQYXJ0aWFsKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSBjcmVhdGVIeWJyaWQuYXBwbHkodW5kZWZpbmVkLCBuZXdEYXRhKTtcbiAgfVxuICB2YXIgc2V0dGVyID0gZGF0YSA/IGJhc2VTZXREYXRhIDogc2V0RGF0YTtcbiAgcmV0dXJuIHNldFdyYXBUb1N0cmluZyhzZXR0ZXIocmVzdWx0LCBuZXdEYXRhKSwgZnVuYywgYml0bWFzayk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZVdyYXA7XG4iLCJpbXBvcnQgYmFzZVJlc3QgZnJvbSAnLi9fYmFzZVJlc3QuanMnO1xuaW1wb3J0IGNyZWF0ZVdyYXAgZnJvbSAnLi9fY3JlYXRlV3JhcC5qcyc7XG5pbXBvcnQgZ2V0SG9sZGVyIGZyb20gJy4vX2dldEhvbGRlci5qcyc7XG5pbXBvcnQgcmVwbGFjZUhvbGRlcnMgZnJvbSAnLi9fcmVwbGFjZUhvbGRlcnMuanMnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBmdW5jdGlvbiBtZXRhZGF0YS4gKi9cbnZhciBXUkFQX0JJTkRfRkxBRyA9IDEsXG4gICAgV1JBUF9QQVJUSUFMX0ZMQUcgPSAzMjtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2BcbiAqIGFuZCBgcGFydGlhbHNgIHByZXBlbmRlZCB0byB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxuICpcbiAqIFRoZSBgXy5iaW5kLnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWMgYnVpbGRzLFxuICogbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICpcbiAqICoqTm90ZToqKiBVbmxpa2UgbmF0aXZlIGBGdW5jdGlvbiNiaW5kYCwgdGhpcyBtZXRob2QgZG9lc24ndCBzZXQgdGhlIFwibGVuZ3RoXCJcbiAqIHByb3BlcnR5IG9mIGJvdW5kIGZ1bmN0aW9ucy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGJpbmQuXG4gKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAqIEBwYXJhbSB7Li4uKn0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYm91bmQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIGdyZWV0KGdyZWV0aW5nLCBwdW5jdHVhdGlvbikge1xuICogICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyB0aGlzLnVzZXIgKyBwdW5jdHVhdGlvbjtcbiAqIH1cbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAndXNlcic6ICdmcmVkJyB9O1xuICpcbiAqIHZhciBib3VuZCA9IF8uYmluZChncmVldCwgb2JqZWN0LCAnaGknKTtcbiAqIGJvdW5kKCchJyk7XG4gKiAvLyA9PiAnaGkgZnJlZCEnXG4gKlxuICogLy8gQm91bmQgd2l0aCBwbGFjZWhvbGRlcnMuXG4gKiB2YXIgYm91bmQgPSBfLmJpbmQoZ3JlZXQsIG9iamVjdCwgXywgJyEnKTtcbiAqIGJvdW5kKCdoaScpO1xuICogLy8gPT4gJ2hpIGZyZWQhJ1xuICovXG52YXIgYmluZCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIHRoaXNBcmcsIHBhcnRpYWxzKSB7XG4gIHZhciBiaXRtYXNrID0gV1JBUF9CSU5EX0ZMQUc7XG4gIGlmIChwYXJ0aWFscy5sZW5ndGgpIHtcbiAgICB2YXIgaG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKHBhcnRpYWxzLCBnZXRIb2xkZXIoYmluZCkpO1xuICAgIGJpdG1hc2sgfD0gV1JBUF9QQVJUSUFMX0ZMQUc7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMpO1xufSk7XG5cbi8vIEFzc2lnbiBkZWZhdWx0IHBsYWNlaG9sZGVycy5cbmJpbmQucGxhY2Vob2xkZXIgPSB7fTtcblxuZXhwb3J0IGRlZmF1bHQgYmluZDtcbiIsImV4cG9ydCBkZWZhdWx0IHtcblxuICAgIC8vIGByZXNwb25zZVR5cGVgIGluZGljYXRlcyB0aGUgdHlwZSBvZiBkYXRhIHRoYXQgdGhlIHNlcnZlciB3aWxsIHJlc3BvbmQgd2l0aFxuICAgIC8vIG9wdGlvbnMgYXJlICdhcnJheWJ1ZmZlcicsICdibG9iJywgJ2RvY3VtZW50JywgJ2pzb24nLCAndGV4dCcsICdzdHJlYW0nXG4gICAgcmVzcG9uc2VUeXBlOiAnanNvbicsIC8vIGRlZmF1bHRcblxuICAgIC8vIGB0cmFuc2Zvcm1SZXF1ZXN0YCBhbGxvd3MgY2hhbmdlcyB0byB0aGUgcmVxdWVzdCBkYXRhIGJlZm9yZSBpdCBpcyBzZW50IHRvIHRoZSBzZXJ2ZXJcbiAgICAvLyBUaGlzIGlzIG9ubHkgYXBwbGljYWJsZSBmb3IgcmVxdWVzdCBtZXRob2RzICdQVVQnLCAnUE9TVCcsIGFuZCAnUEFUQ0gnXG4gICAgLy8gVGhlIGxhc3QgZnVuY3Rpb24gaW4gdGhlIGFycmF5IG11c3QgcmV0dXJuIGEgc3RyaW5nIG9yIGFuIGluc3RhbmNlIG9mIEJ1ZmZlciwgQXJyYXlCdWZmZXIsXG4gICAgLy8gRm9ybURhdGEgb3IgU3RyZWFtXG4gICAgLy8gWW91IG1heSBtb2RpZnkgdGhlIGhlYWRlcnMgb2JqZWN0LlxuICAgIHRyYW5zZm9ybVJlcXVlc3Q6IFtdLFxuXG4gICAgLy8gYHRyYW5zZm9ybVJlc3BvbnNlYCBhbGxvd3MgY2hhbmdlcyB0byB0aGUgcmVzcG9uc2UgZGF0YSB0byBiZSBtYWRlIGJlZm9yZVxuICAgIC8vIGl0IGlzIHBhc3NlZCB0byB0aGVuL2NhdGNoXG4gICAgdHJhbnNmb3JtUmVzcG9uc2U6IFtdXG5cbiAgICAvKlxuICAgIC8vIGB1cmxgIGlzIHRoZSBzZXJ2ZXIgVVJMIHRoYXQgd2lsbCBiZSB1c2VkIGZvciB0aGUgcmVxdWVzdFxuXG5cbiAgICAvLyBgbWV0aG9kYCBpcyB0aGUgcmVxdWVzdCBtZXRob2QgdG8gYmUgdXNlZCB3aGVuIG1ha2luZyB0aGUgcmVxdWVzdFxuICAgIG1ldGhvZDogJ2dldCcsIC8vIGRlZmF1bHRcblxuICAgIC8vIGBiYXNlVVJMYCB3aWxsIGJlIHByZXBlbmRlZCB0byBgdXJsYCB1bmxlc3MgYHVybGAgaXMgYWJzb2x1dGUuXG4gICAgLy8gSXQgY2FuIGJlIGNvbnZlbmllbnQgdG8gc2V0IGBiYXNlVVJMYCBmb3IgYW4gaW5zdGFuY2Ugb2YgYXhpb3MgdG8gcGFzcyByZWxhdGl2ZSBVUkxzXG4gICAgLy8gdG8gbWV0aG9kcyBvZiB0aGF0IGluc3RhbmNlLlxuICAgIGJhc2VVUkw6ICdodHRwczovL3NvbWUtZG9tYWluLmNvbS9hcGkvJyxcblxuICAgIC8vIGBoZWFkZXJzYCBhcmUgY3VzdG9tIGhlYWRlcnMgdG8gYmUgc2VudFxuICAgIGhlYWRlcnM6IHsnWC1SZXF1ZXN0ZWQtV2l0aCc6ICdYTUxIdHRwUmVxdWVzdCd9LFxuXG4gICAgLy8gYHBhcmFtc2AgYXJlIHRoZSBVUkwgcGFyYW1ldGVycyB0byBiZSBzZW50IHdpdGggdGhlIHJlcXVlc3RcbiAgICAvLyBNdXN0IGJlIGEgcGxhaW4gb2JqZWN0IG9yIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdFxuICAgIHBhcmFtczoge1xuICAgICAgICBJRDogMTIzNDVcbiAgICB9LFxuXG4gICAgLy8gYHBhcmFtc1NlcmlhbGl6ZXJgIGlzIGFuIG9wdGlvbmFsIGZ1bmN0aW9uIGluIGNoYXJnZSBvZiBzZXJpYWxpemluZyBgcGFyYW1zYFxuICAgIC8vIChlLmcuIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL3FzLCBodHRwOi8vYXBpLmpxdWVyeS5jb20vanF1ZXJ5LnBhcmFtLylcbiAgICBwYXJhbXNTZXJpYWxpemVyOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIFFzLnN0cmluZ2lmeShwYXJhbXMsIHthcnJheUZvcm1hdDogJ2JyYWNrZXRzJ30pXG4gICAgfSxcblxuICAgIC8vIGBkYXRhYCBpcyB0aGUgZGF0YSB0byBiZSBzZW50IGFzIHRoZSByZXF1ZXN0IGJvZHlcbiAgICAvLyBPbmx5IGFwcGxpY2FibGUgZm9yIHJlcXVlc3QgbWV0aG9kcyAnUFVUJywgJ1BPU1QnLCBhbmQgJ1BBVENIJ1xuICAgIC8vIFdoZW4gbm8gYHRyYW5zZm9ybVJlcXVlc3RgIGlzIHNldCwgbXVzdCBiZSBvZiBvbmUgb2YgdGhlIGZvbGxvd2luZyB0eXBlczpcbiAgICAvLyAtIHN0cmluZywgcGxhaW4gb2JqZWN0LCBBcnJheUJ1ZmZlciwgQXJyYXlCdWZmZXJWaWV3LCBVUkxTZWFyY2hQYXJhbXNcbiAgICAvLyAtIEJyb3dzZXIgb25seTogRm9ybURhdGEsIEZpbGUsIEJsb2JcbiAgICAvLyAtIE5vZGUgb25seTogU3RyZWFtLCBCdWZmZXJcbiAgICBkYXRhOiB7XG4gICAgICAgIGZpcnN0TmFtZTogJ0ZyZWQnXG4gICAgfSxcblxuICAgIC8vIGB0aW1lb3V0YCBzcGVjaWZpZXMgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgYmVmb3JlIHRoZSByZXF1ZXN0IHRpbWVzIG91dC5cbiAgICAvLyBJZiB0aGUgcmVxdWVzdCB0YWtlcyBsb25nZXIgdGhhbiBgdGltZW91dGAsIHRoZSByZXF1ZXN0IHdpbGwgYmUgYWJvcnRlZC5cbiAgICB0aW1lb3V0OiAxMDAwLFxuXG4gICAgLy8gYHdpdGhDcmVkZW50aWFsc2AgaW5kaWNhdGVzIHdoZXRoZXIgb3Igbm90IGNyb3NzLXNpdGUgQWNjZXNzLUNvbnRyb2wgcmVxdWVzdHNcbiAgICAvLyBzaG91bGQgYmUgbWFkZSB1c2luZyBjcmVkZW50aWFsc1xuICAgIHdpdGhDcmVkZW50aWFsczogZmFsc2UsIC8vIGRlZmF1bHRcblxuICAgIC8vIGBhZGFwdGVyYCBhbGxvd3MgY3VzdG9tIGhhbmRsaW5nIG9mIHJlcXVlc3RzIHdoaWNoIG1ha2VzIHRlc3RpbmcgZWFzaWVyLlxuICAgIC8vIFJldHVybiBhIHByb21pc2UgYW5kIHN1cHBseSBhIHZhbGlkIHJlc3BvbnNlIChzZWUgbGliL2FkYXB0ZXJzL1JFQURNRS5tZCkuXG4gICAgYWRhcHRlcjogZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICAvL1xuICAgIH0sXG5cbiAgICAvLyBgYXV0aGAgaW5kaWNhdGVzIHRoYXQgSFRUUCBCYXNpYyBhdXRoIHNob3VsZCBiZSB1c2VkLCBhbmQgc3VwcGxpZXMgY3JlZGVudGlhbHMuXG4gICAgLy8gVGhpcyB3aWxsIHNldCBhbiBgQXV0aG9yaXphdGlvbmAgaGVhZGVyLCBvdmVyd3JpdGluZyBhbnkgZXhpc3RpbmdcbiAgICAvLyBgQXV0aG9yaXphdGlvbmAgY3VzdG9tIGhlYWRlcnMgeW91IGhhdmUgc2V0IHVzaW5nIGBoZWFkZXJzYC5cbiAgICBhdXRoOiB7XG4gICAgICAgIHVzZXJuYW1lOiAnamFuZWRvZScsXG4gICAgICAgIHBhc3N3b3JkOiAnczAwcGVyczNjcmV0J1xuICAgIH0sXG5cbiAgICAvLyBgcmVzcG9uc2VFbmNvZGluZ2AgaW5kaWNhdGVzIGVuY29kaW5nIHRvIHVzZSBmb3IgZGVjb2RpbmcgcmVzcG9uc2VzXG4gICAgLy8gTm90ZTogSWdub3JlZCBmb3IgYHJlc3BvbnNlVHlwZWAgb2YgJ3N0cmVhbScgb3IgY2xpZW50LXNpZGUgcmVxdWVzdHNcbiAgICByZXNwb25zZUVuY29kaW5nOiAndXRmOCcsIC8vIGRlZmF1bHRcblxuICAgIC8vIGB4c3JmQ29va2llTmFtZWAgaXMgdGhlIG5hbWUgb2YgdGhlIGNvb2tpZSB0byB1c2UgYXMgYSB2YWx1ZSBmb3IgeHNyZiB0b2tlblxuICAgIHhzcmZDb29raWVOYW1lOiAnWFNSRi1UT0tFTicsIC8vIGRlZmF1bHRcblxuICAgIC8vIGB4c3JmSGVhZGVyTmFtZWAgaXMgdGhlIG5hbWUgb2YgdGhlIGh0dHAgaGVhZGVyIHRoYXQgY2FycmllcyB0aGUgeHNyZiB0b2tlbiB2YWx1ZVxuICAgIHhzcmZIZWFkZXJOYW1lOiAnWC1YU1JGLVRPS0VOJywgLy8gZGVmYXVsdFxuXG4gICAgLy8gYG9uVXBsb2FkUHJvZ3Jlc3NgIGFsbG93cyBoYW5kbGluZyBvZiBwcm9ncmVzcyBldmVudHMgZm9yIHVwbG9hZHNcbiAgICBvblVwbG9hZFByb2dyZXNzOiBmdW5jdGlvbiAocHJvZ3Jlc3NFdmVudCkge1xuICAgICAgICAvLyBEbyB3aGF0ZXZlciB5b3Ugd2FudCB3aXRoIHRoZSBuYXRpdmUgcHJvZ3Jlc3MgZXZlbnRcbiAgICB9LFxuXG4gICAgLy8gYG9uRG93bmxvYWRQcm9ncmVzc2AgYWxsb3dzIGhhbmRsaW5nIG9mIHByb2dyZXNzIGV2ZW50cyBmb3IgZG93bmxvYWRzXG4gICAgb25Eb3dubG9hZFByb2dyZXNzOiBmdW5jdGlvbiAocHJvZ3Jlc3NFdmVudCkge1xuICAgICAgICAvLyBEbyB3aGF0ZXZlciB5b3Ugd2FudCB3aXRoIHRoZSBuYXRpdmUgcHJvZ3Jlc3MgZXZlbnRcbiAgICB9LFxuXG4gICAgLy8gYG1heENvbnRlbnRMZW5ndGhgIGRlZmluZXMgdGhlIG1heCBzaXplIG9mIHRoZSBodHRwIHJlc3BvbnNlIGNvbnRlbnQgaW4gYnl0ZXMgYWxsb3dlZFxuICAgIG1heENvbnRlbnRMZW5ndGg6IDIwMDAsXG5cbiAgICAvLyBgdmFsaWRhdGVTdGF0dXNgIGRlZmluZXMgd2hldGhlciB0byByZXNvbHZlIG9yIHJlamVjdCB0aGUgcHJvbWlzZSBmb3IgYSBnaXZlblxuICAgIC8vIEhUVFAgcmVzcG9uc2Ugc3RhdHVzIGNvZGUuIElmIGB2YWxpZGF0ZVN0YXR1c2AgcmV0dXJucyBgdHJ1ZWAgKG9yIGlzIHNldCB0byBgbnVsbGBcbiAgICAvLyBvciBgdW5kZWZpbmVkYCksIHRoZSBwcm9taXNlIHdpbGwgYmUgcmVzb2x2ZWQ7IG90aGVyd2lzZSwgdGhlIHByb21pc2Ugd2lsbCBiZVxuICAgIC8vIHJlamVjdGVkLlxuICAgIHZhbGlkYXRlU3RhdHVzOiBmdW5jdGlvbiAoc3RhdHVzKSB7XG4gICAgICAgIHJldHVybiBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMDsgLy8gZGVmYXVsdFxuICAgIH0sXG5cbiAgICAvLyBgbWF4UmVkaXJlY3RzYCBkZWZpbmVzIHRoZSBtYXhpbXVtIG51bWJlciBvZiByZWRpcmVjdHMgdG8gZm9sbG93IGluIG5vZGUuanMuXG4gICAgLy8gSWYgc2V0IHRvIDAsIG5vIHJlZGlyZWN0cyB3aWxsIGJlIGZvbGxvd2VkLlxuICAgIG1heFJlZGlyZWN0czogNSwgLy8gZGVmYXVsdFxuXG4gICAgLy8gYHNvY2tldFBhdGhgIGRlZmluZXMgYSBVTklYIFNvY2tldCB0byBiZSB1c2VkIGluIG5vZGUuanMuXG4gICAgLy8gZS5nLiAnL3Zhci9ydW4vZG9ja2VyLnNvY2snIHRvIHNlbmQgcmVxdWVzdHMgdG8gdGhlIGRvY2tlciBkYWVtb24uXG4gICAgLy8gT25seSBlaXRoZXIgYHNvY2tldFBhdGhgIG9yIGBwcm94eWAgY2FuIGJlIHNwZWNpZmllZC5cbiAgICAvLyBJZiBib3RoIGFyZSBzcGVjaWZpZWQsIGBzb2NrZXRQYXRoYCBpcyB1c2VkLlxuICAgIHNvY2tldFBhdGg6IG51bGwsIC8vIGRlZmF1bHRcblxuICAgIC8vIGBodHRwQWdlbnRgIGFuZCBgaHR0cHNBZ2VudGAgZGVmaW5lIGEgY3VzdG9tIGFnZW50IHRvIGJlIHVzZWQgd2hlbiBwZXJmb3JtaW5nIGh0dHBcbiAgICAvLyBhbmQgaHR0cHMgcmVxdWVzdHMsIHJlc3BlY3RpdmVseSwgaW4gbm9kZS5qcy4gVGhpcyBhbGxvd3Mgb3B0aW9ucyB0byBiZSBhZGRlZCBsaWtlXG4gICAgLy8gYGtlZXBBbGl2ZWAgdGhhdCBhcmUgbm90IGVuYWJsZWQgYnkgZGVmYXVsdC5cbiAgICBodHRwQWdlbnQ6IG5ldyBodHRwLkFnZW50KHsga2VlcEFsaXZlOiB0cnVlIH0pLFxuICAgIGh0dHBzQWdlbnQ6IG5ldyBodHRwcy5BZ2VudCh7IGtlZXBBbGl2ZTogdHJ1ZSB9KSxcblxuICAgIC8vICdwcm94eScgZGVmaW5lcyB0aGUgaG9zdG5hbWUgYW5kIHBvcnQgb2YgdGhlIHByb3h5IHNlcnZlclxuICAgIC8vIFVzZSBgZmFsc2VgIHRvIGRpc2FibGUgcHJveGllcywgaWdub3JpbmcgZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuICAgIC8vIGBhdXRoYCBpbmRpY2F0ZXMgdGhhdCBIVFRQIEJhc2ljIGF1dGggc2hvdWxkIGJlIHVzZWQgdG8gY29ubmVjdCB0byB0aGUgcHJveHksIGFuZFxuICAgIC8vIHN1cHBsaWVzIGNyZWRlbnRpYWxzLlxuICAgIC8vIFRoaXMgd2lsbCBzZXQgYW4gYFByb3h5LUF1dGhvcml6YXRpb25gIGhlYWRlciwgb3ZlcndyaXRpbmcgYW55IGV4aXN0aW5nXG4gICAgLy8gYFByb3h5LUF1dGhvcml6YXRpb25gIGN1c3RvbSBoZWFkZXJzIHlvdSBoYXZlIHNldCB1c2luZyBgaGVhZGVyc2AuXG4gICAgcHJveHk6IHtcbiAgICAgICAgaG9zdDogJzEyNy4wLjAuMScsXG4gICAgICAgIHBvcnQ6IDkwMDAsXG4gICAgICAgIGF1dGg6IHtcbiAgICAgICAgICAgIHVzZXJuYW1lOiAnbWlrZXltaWtlJyxcbiAgICAgICAgICAgIHBhc3N3b3JkOiAncmFwdW56M2wnXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gYGNhbmNlbFRva2VuYCBzcGVjaWZpZXMgYSBjYW5jZWwgdG9rZW4gdGhhdCBjYW4gYmUgdXNlZCB0byBjYW5jZWwgdGhlIHJlcXVlc3RcbiAgICAvLyAoc2VlIENhbmNlbGxhdGlvbiBzZWN0aW9uIGJlbG93IGZvciBkZXRhaWxzKVxuICAgIGNhbmNlbFRva2VuOiBuZXcgQ2FuY2VsVG9rZW4oZnVuY3Rpb24gKGNhbmNlbCkge1xuXG4gICAgfSlcbiAgICAqL1xuXG59O1xuIiwiaW1wb3J0IHsgaXNGdW5jdGlvbiB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgUmVxdWVzdE9wdGlvbnMgZnJvbSAnLi9SZXF1ZXN0T3B0aW9ucyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRyYW5zZm9ybVJlcXVlc3QodHJhbnNmb3JtZXIsIGNvbnRleHQpIHtcbiAgICBpZighaXNGdW5jdGlvbih0cmFuc2Zvcm1lcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgdHJhbnNmb3JtZXIgbXVzdCBiZSBhIGRlZmluZWQgYXMgYSBmdW5jdGlvbiB3aXRoIHR3byBhcmd1bWVudHM6IFtkYXRhLCBoZWFkZXJzXS4nKTtcbiAgICB9XG5cbiAgICAoY29udGV4dCB8fCBSZXF1ZXN0T3B0aW9ucy50cmFuc2Zvcm1SZXF1ZXN0KS5wdXNoKHRyYW5zZm9ybWVyKTtcbn1cbiIsImltcG9ydCB7IGlzRnVuY3Rpb24gfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IFJlcXVlc3RPcHRpb25zIGZyb20gJy4vUmVxdWVzdE9wdGlvbnMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0cmFuc2Zvcm1SZXNwb25zZSh0cmFuc2Zvcm1lciwgY29udGV4dCkge1xuICAgIGlmKCFpc0Z1bmN0aW9uKHRyYW5zZm9ybWVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSB0cmFuc2Zvcm1lciBtdXN0IGJlIGEgZGVmaW5lZCBhcyBhIGZ1bmN0aW9uIHdpdGggb25lIGFyZ3VtZW50czogW2RhdGFdLicpO1xuICAgIH1cblxuICAgIChjb250ZXh0IHx8IFJlcXVlc3RPcHRpb25zLnRyYW5zZm9ybVJlc3BvbnNlKS5wdXNoKHRyYW5zZm9ybWVyKTtcbn1cbiIsImltcG9ydCBheGlvcyBmcm9tICdheGlvcyc7XG5pbXBvcnQgbW9tZW50IGZyb20gJ21vbWVudCc7XG5pbXBvcnQgeyBiaW5kIH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCB7IGVhY2ggfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IHsgZmlyc3QgfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IHsgZXh0ZW5kIH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCB7IGlzQXJyYXkgfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IHsgaXNPYmplY3QgfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCB7IGNhbWVsQ2FzZSB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgeyBtZXJnZVdpdGggfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IFJlcXVlc3RPcHRpb25zIGZyb20gJy4vUmVxdWVzdE9wdGlvbnMnO1xuaW1wb3J0IHRyYW5zZm9ybVJlcXVlc3QgZnJvbSAnLi9UcmFuc2Zvcm1SZXF1ZXN0JztcbmltcG9ydCB0cmFuc2Zvcm1SZXNwb25zZSBmcm9tICcuL1RyYW5zZm9ybVJlc3BvbnNlJztcblxuY29uc3QgUFJPWFlfT1BUSU9OX1BST1BFUlRJRVMgPSBbXG4gICAgJ2hlYWRlcnMnLFxuICAgICdwYXJhbXMnLFxuICAgICdkYXRhJ1xuXTtcblxuY29uc3QgUFJPWFlfT1BUSU9OX01FVEhPRFMgPSB7XG4gICAgZ2V0KHByb3AsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0W3Byb3BdO1xuICAgICAgICB9O1xuICAgIH0sXG4gICAgc2V0KHByb3AsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgY29udGV4dFtwcm9wXSA9IHZhbHVlO1xuICAgICAgICB9O1xuICAgIH0sXG4gICAgYWRkKHByb3AsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBjb250ZXh0W3Byb3BdW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHJlbW92ZShwcm9wLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiAoa2V5KSA9PiB7XG4gICAgICAgICAgICBkZWxldGUgY29udGV4dFtwcm9wXVtrZXldO1xuICAgICAgICB9O1xuICAgIH0sXG4gICAgbWVyZ2UocHJvcCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gKGtleSwgdmFsdWVzKSA9PiB7XG4gICAgICAgICAgICBleHRlbmQoY29udGV4dFtwcm9wXSwga2V5KTtcbiAgICAgICAgfTtcbiAgICB9XG59O1xuXG5jb25zdCBtZXRob2QgPSBmdW5jdGlvbihhY3Rpb24sIHByb3ApIHtcbiAgICByZXR1cm4gY2FtZWxDYXNlKFthY3Rpb24sIHByb3BdLmpvaW4oJyAnKSk7XG59O1xuXG5jb25zdCBjaGFpbmFibGUgPSBmdW5jdGlvbihwcm9wKSB7XG4gICAgcmV0dXJuIChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgIGlmKGtleSBpbnN0YW5jZW9mIEZvcm1EYXRhKSB7XG4gICAgICAgICAgICB0aGlzW21ldGhvZCgnc2V0JywgcHJvcCldKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihpc09iamVjdChrZXkpKSB7XG4gICAgICAgICAgICB0aGlzW21ldGhvZCgnbWVyZ2UnLCBwcm9wKV0oa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXNbbWV0aG9kKCdhZGQnLCBwcm9wKV0oa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xufTtcblxuZnVuY3Rpb24gbWVyZ2UoKSB7XG4gICAgY29uc3QgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICBjb25zdCBpdGVtcyA9IGFyZ3Muc3BsaWNlKDEpO1xuICAgIGxldCBzdWJqZWN0ID0gZmlyc3QoYXJncyk7XG5cbiAgICBmb3IobGV0IGkgaW4gaXRlbXMpIHtcbiAgICAgICAgc3ViamVjdCA9IG1lcmdlV2l0aChzdWJqZWN0LCBpdGVtc1tpXSwgKHN1YmplY3QsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZihpc0FycmF5KHN1YmplY3QpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1YmplY3QuY29uY2F0KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYoaXNPYmplY3Qoc3ViamVjdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXh0ZW5kKHN1YmplY3QsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3ViamVjdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVxdWVzdCB7XG5cbiAgICBjb25zdHJ1Y3Rvcih1cmwsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0aGlzLiRvcHRpb25zID0gbWVyZ2Uoe1xuICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICBkYXRhOiB7fSxcbiAgICAgICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgICAgICAgcGFyYW1zOiB7fSxcbiAgICAgICAgfSwgY2xvbmVEZWVwKFJlcXVlc3RPcHRpb25zKSwgb3B0aW9ucyk7XG5cbiAgICAgICAgZWFjaChQUk9YWV9PUFRJT05fTUVUSE9EUywgKGNhbGxiYWNrLCBrZXkpID0+IHtcbiAgICAgICAgICAgIHRoaXNbbWV0aG9kKGtleSwgJ29wdGlvbicpXSA9IGJpbmQoY2FsbGJhY2spKCckb3B0aW9ucycsIHRoaXMpO1xuICAgICAgICB9KTtcblxuICAgICAgICBlYWNoKFBST1hZX09QVElPTl9QUk9QRVJUSUVTLCAocHJvcCkgPT4ge1xuICAgICAgICAgICAgZWFjaChQUk9YWV9PUFRJT05fTUVUSE9EUywgKGNhbGxiYWNrLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzW21ldGhvZChrZXksIHByb3ApXSA9IGJpbmQoY2FsbGJhY2spKHByb3AsIHRoaXMuJG9wdGlvbnMpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXNbcHJvcF0gPSBiaW5kKGNoYWluYWJsZSwgdGhpcykocHJvcCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9XG5cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy4kZXJyb3IgPSBudWxsO1xuICAgICAgICB0aGlzLiRzdGF0dXMgPSBudWxsO1xuICAgICAgICB0aGlzLiRzdGF0dXNUZXh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy4kcmVzcG9uc2UgPSBudWxsO1xuICAgICAgICB0aGlzLiRyZXF1ZXN0U2VudEF0ID0gbnVsbDtcbiAgICAgICAgdGhpcy4kcmVzcG9uc2VSZWNlaXZlZEF0ID0gbnVsbDtcbiAgICB9XG5cbiAgICBoYXNTZW50KCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLiRyZXF1ZXN0U2VudEF0O1xuICAgIH1cblxuICAgIGhhc1Jlc3BvbnNlKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLiRyZXNwb25zZVJlY2VpdmVkQXQ7XG4gICAgfVxuXG4gICAgcGFzc2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNSZXNwb25zZSgpICYmICF0aGlzLiRlcnJvcjtcbiAgICB9XG5cbiAgICBmYWlsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc1Jlc3BvbnNlKCkgJiYgISF0aGlzLiRlcnJvcjtcbiAgICB9XG5cbiAgICBnZXQocGFyYW1zID0ge30sIGhlYWRlcnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJhbXMocGFyYW1zKS5oZWFkZXJzKGhlYWRlcnMpLnNlbmQoJ2dldCcpO1xuICAgIH1cblxuICAgIHBvc3QoZGF0YSA9IHt9LCBoZWFkZXJzID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YShkYXRhKS5oZWFkZXJzKGhlYWRlcnMpLnNlbmQoJ3Bvc3QnKTtcbiAgICB9XG5cbiAgICBwdXQoZGF0YSA9IHt9LCBoZWFkZXJzID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YShkYXRhKS5oZWFkZXJzKGhlYWRlcnMpLnNlbmQoJ3B1dCcpO1xuICAgIH1cblxuICAgIGRlbGV0ZShoZWFkZXJzID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVhZGVycyhoZWFkZXJzKS5zZW5kKCdkZWxldGUnKTtcbiAgICB9XG5cbiAgICBzZW5kKG1ldGhvZCkge1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIHRoaXMuJHJlcXVlc3RTZW50QXQgPSBtb21lbnQoKTtcbiAgICAgICAgdGhpcy5hZGRPcHRpb24oJ21ldGhvZCcsIG1ldGhvZCk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGF4aW9zKHRoaXMuJG9wdGlvbnMpLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuJHJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgdGhpcy4kcmVzcG9uc2VSZWNlaXZlZEF0ID0gbW9tZW50KCk7XG4gICAgICAgICAgICAgICAgdGhpcy4kc3RhdHVzID0gcmVzcG9uc2Uuc3RhdHVzO1xuICAgICAgICAgICAgICAgIHRoaXMuJHN0YXR1c1RleHQgPSByZXNwb25zZS5zdGF0dXNUZXh0O1xuXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZS5kYXRhKTtcbiAgICAgICAgICAgIH0sIGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLiRlcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgIHRoaXMuJHJlc3BvbnNlID0gZXJyb3IucmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgdGhpcy4kcmVzcG9uc2VSZWNlaXZlZEF0ID0gbW9tZW50KCk7XG4gICAgICAgICAgICAgICAgdGhpcy4kc3RhdHVzID0gZXJyb3IucmVzcG9uc2UgPyBlcnJvci5yZXNwb25zZS5zdGF0dXMgOiBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuJHN0YXR1c1RleHQgPSBlcnJvci5yZXNwb25zZSA/IGVycm9yLnJlc3BvbnNlLnN0YXR1c1RleHQgOiBudWxsO1xuXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yLnJlc3BvbnNlIHx8IGVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB0cmFuc2Zvcm1SZXF1ZXN0KHRyYW5zZm9ybWVyKSB7XG4gICAgICAgIGlmKCF0aGlzLiRvcHRpb25zLnRyYW5zZm9ybVJlcXVlc3QpIHtcbiAgICAgICAgICAgIHRoaXMuJG9wdGlvbnMudHJhbnNmb3JtUmVxdWVzdCA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJhbnNmb3JtUmVxdWVzdCh0cmFuc2Zvcm1lciwgdGhpcy4kb3B0aW9ucy50cmFuc2Zvcm1SZXF1ZXN0KTtcbiAgICB9XG5cbiAgICB0cmFuc2Zvcm1SZXNwb25zZSh0cmFuc2Zvcm1lcikge1xuICAgICAgICBpZih0aGlzLiRvcHRpb25zLnRyYW5zZm9ybVJlc3BvbnNlKSB7XG4gICAgICAgICAgICB0aGlzLiRvcHRpb25zLnRyYW5zZm9ybVJlc3BvbnNlID0gW107XG4gICAgICAgIH1cblxuICAgICAgICB0cmFuc2Zvcm1SZXNwb25zZSh0cmFuc2Zvcm1lciwgdGhpcy4kb3B0aW9ucy50cmFuc2Zvcm1SZXNwb25zZSk7XG4gICAgfVxuXG4gICAgc3RhdGljIGludGVyY2VwdFJlcXVlc3Qoc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgdGhpcy5pbnRlcmNlcHRvcnMoKS5yZXF1ZXN0LnVzZShzdWNjZXNzLCBlcnJvcik7XG4gICAgfVxuXG4gICAgc3RhdGljIGludGVyY2VwdFJlc3BvbnNlKHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgIHRoaXMuaW50ZXJjZXB0b3JzKCkucmVzcG9uc2UudXNlKHN1Y2Nlc3MsIGVycm9yKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgaW50ZXJjZXB0b3JzKCkge1xuICAgICAgICByZXR1cm4gYXhpb3MuaW50ZXJjZXB0b3JzO1xuICAgIH1cblxuICAgIHN0YXRpYyBvcHRpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZihpc09iamVjdChrZXkpKSB7XG4gICAgICAgICAgICBtZXJnZShSZXF1ZXN0T3B0aW9ucywga2V5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbiA9IHt9O1xuICAgICAgICAgICAgb3B0aW9uW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIG1lcmdlKFJlcXVlc3RPcHRpb25zLCBvcHRpb24pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIG1ha2UodXJsLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICByZXR1cm4gbmV3IHRoaXModXJsLCBwYXJhbXMpO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IG1hcCB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgeyBlYWNoIH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCB7IGtleXMgfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IHsgc2l6ZSB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgeyBleHRlbmQgfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IHsgZmlsdGVyIH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCB7IGlzTnVsbCB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgeyBwaWNrQnkgfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IHsgcmVkdWNlIH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCB7IGlzQXJyYXkgfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IHsgaXNPYmplY3QgfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IHsgaXNVbmRlZmluZWQgfSBmcm9tICdsb2Rhc2gtZXMnXG5pbXBvcnQgUmVxdWVzdCBmcm9tICcuLi9SZXF1ZXN0JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTW9kZWwge1xuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IHRoZSBtb2RlbCBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGEgb2JqZWN0XG4gICAgICogQHJldHVybiB2b2lkXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZGF0YSA9IHt9LCBwYXJhbXMgPSB7fSkge1xuICAgICAgICB0aGlzLiRrZXkgPSB0aGlzLmtleSgpO1xuICAgICAgICB0aGlzLiRwcm9wZXJ0aWVzID0gdGhpcy5wcm9wZXJ0aWVzKCk7XG4gICAgICAgIHRoaXMuJGZpbGVzID0gdGhpcy5maWxlcygpO1xuXG4gICAgICAgIGVhY2gocGFyYW1zLCAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgdGhpc1trZXldID0gdmFsdWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZShkYXRhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIHRoZSBtb2RlbCB3aXRoIHRoZSBnaXZlbiBkYXRhIHdpdGhvdXQgY29uc2lkZXJpbmcgdGhlIGRhdGFcbiAgICAgKiBhcyBcImNoYW5nZWRcIi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRhIG9iamVjdFxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIGluaXRpYWxpemUoZGF0YSkge1xuICAgICAgICB0aGlzLiRleGlzdHMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4kY2hhbmdlZCA9IHt9O1xuICAgICAgICB0aGlzLiRhdHRyaWJ1dGVzID0ge307XG4gICAgICAgIHRoaXMuZmlsbChkYXRhKTtcbiAgICAgICAgdGhpcy4kaW5pdGlhbGl6ZWQgPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlZmluZSB0aGUgY29ycmVzcG9uZGluZyBBUEkgZW5kcG9pbnQgc2x1Z1xuICAgICAqXG4gICAgICogQHJldHVybiBzdHJpbmdcbiAgICAgKi9cbiAgICBlbmRwb2ludCgpIHtcbiAgICAgICAgLy9cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWZpbmUgdGhlIGNvcnJlc3BvbmRpbmcgdXJpIHNjaGVtYS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gc3RyaW5nXG4gICAgICovXG4gICAgdXJpKCkge1xuICAgICAgICByZXR1cm4gZmlsdGVyKFtcbiAgICAgICAgICAgICh0aGlzLmVuZHBvaW50KCkgfHwgJycpLFxuICAgICAgICAgICAgKHRoaXMuZXhpc3RzKCkgPyB0aGlzLmlkKCkgOiBudWxsKVxuICAgICAgICBdLmNvbmNhdChbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpKVxuICAgICAgICAuam9pbignLycpXG4gICAgICAgIC5yZXBsYWNlKC9eXFwvLywgJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgcHJpbWFyeSBrZXkgdmFsdWUgZm9yIHRoZSBtb2RlbFxuICAgICAqXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIGlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXQodGhpcy5rZXkoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVmaW5lIGEgcHJpbWFyeSBrZXkuIFRoaXMgaXMgdXNlZCB0byBkZXRlcm1pbmUgaWYgdGhlIG1vZGVsIGV4aXN0cyBhbmRcbiAgICAgKiB3aGljaCBlbmRwb2ludCB0byB1c2UuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHN0cmluZ1xuICAgICAqL1xuICAgIGtleSgpIHtcbiAgICAgICAgcmV0dXJuICdpZCc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGFuIGFycmF5IG9mIHByb3BlcnRpZXMgdGhhdCBhcmUgc2VudCB0byB0aGUgQVBJLiBJZiBubyBwcm9wZXJ0aWVzXG4gICAgICogYXJlIGRlZmluZWQsIHRoZW4gYWxsIHRoZSBhdHRyaWJ1dGVzIHdpbGwgYmUgaW5jbHVkZWQgaW4gdGhlIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIGFycmF5XG4gICAgICovXG4gICAgcHJvcGVydGllcygpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhbiBhcnJheSBvZiBmaWxlIHByb3BlcnRpZXMgdGhhdCBhcmUgc2VudCB0byB0aGUgQVBJLiBJZiBubyBmaWVzXG4gICAgICogYXJlIGRlZmluZWQsIHRoZW4gcmVxdWVzdCB3aWxsIGFsd2F5cyBiZSBzZW50IHdpdGggSlNPTiB2cy4gbXVsdGlwYXJ0LlxuICAgICAqXG4gICAgICogQHJldHVybiBhcnJheVxuICAgICAqL1xuICAgIGZpbGVzKCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBhdHRyaWJ1dGVzIGluIHRoZSBtb2RlbCB3aXRoIHRoZSBkYXRhIGdpdmVuLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGEgb2JqZWN0XG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgZmlsbChkYXRhKSB7XG4gICAgICAgIHRoaXMuc2V0QXR0cmlidXRlcyhkYXRhKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgb25lIG9yIG1vcmUgYXR0cmlidXRlcyBmcm9tIHRoZSBtb2RlbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRhIHN0cmluZ3xhcnJheVxuICAgICAqIEByZXR1cm4gYXJyYXl8bWl4ZWRcbiAgICAgKi9cbiAgICBnZXQoa2V5KSB7XG4gICAgICAgIGlmKGlzQXJyYXkoa2V5KSB8fCBpc09iamVjdChrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGVzKCkuZmlsdGVyKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLmluZGV4T2YodmFsdWUpICE9PSAtMTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKGtleSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbGlhcyBmb3Igc2V0QXR0cmlidXRlcygpIGV4Y2VwdCB0aGlzIG1ldGhvZCByZXR1cm5zIGB0aGlzYC4gVGhpcyBtZXRob2RcbiAgICAgKiBhbHNvIGFjY2VwdHMgYW4gYXJyYXkgb2YgdmFsdWVzIG9yIGtleS92YWx1ZSBwYWlyLlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgc2V0KGtleSwgdmFsdWUgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYoaXNBcnJheShrZXkpIHx8IGlzT2JqZWN0KGtleSkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlcyhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIHRoZSBkZWZpbmVkIGF0dHJpYnV0ZXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIGFycmF5XG4gICAgICovXG4gICAgZ2V0QXR0cmlidXRlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGF0dHJpYnV0ZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjaGFuZ2VkIGF0dHJpYnV0ZXNcbiAgICAgKlxuICAgICAqIEByZXR1cm4gYXJyYXlcbiAgICAgKi9cbiAgICBnZXRDaGFuZ2VkQXR0cmlidXRlcygpIHtcbiAgICAgICAgcmV0dXJuIGtleXModGhpcy4kY2hhbmdlZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjaGFuZ2VkIGF0dHJpYnV0ZXNcbiAgICAgKlxuICAgICAqIEByZXR1cm4gYXJyYXlcbiAgICAgKi9cbiAgICBnZXRPcmlnaW5hbFZhbHVlKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy4kY2hhbmdlZFtrZXldIHx8IHRoaXMuJGF0dHJpYnV0ZXNba2V5XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHVuY2hhbmdlZCBhdHRyaWJ1dGVzXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIGFycmF5XG4gICAgICovXG4gICAgZ2V0VW5jaGFuZ2VkQXR0cmlidXRlcygpIHtcbiAgICAgICAgcmV0dXJuIGZpbHRlcihrZXlzKHRoaXMuJGF0dHJpYnV0ZXMpLCBrZXkgPT4gIShrZXkgaW4gdGhpcy4kY2hhbmdlZCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBhbiBhdHRyaWJ1dGUgd2l0aCBhIGdpdmVuIGtleS4gSWYgbm8ga2V5IGlzIGRlZmluZWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBrZXkgc3RyaW5nXG4gICAgICogQHBhcmFtIGRlZmF1bHQgdW5kZWZpbmVkfG1peGVkXG4gICAgICogQHJldHVybiBhcnJheVxuICAgICAqL1xuICAgIGdldEF0dHJpYnV0ZShrZXksIHZhbHVlID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRhdHRyaWJ1dGVzW2tleV0gfHwgdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IGFuIGFycmF5IG9yIG9iamVjdCBvZiBkYXRhIGFzIGF0dHJpYnV0ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXR0cmlidXRlcyBhcnJheXxvYmplY3RcbiAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgKi9cbiAgICBzZXRBdHRyaWJ1dGVzKGRhdGEpIHtcbiAgICAgICAgaWYoaXNBcnJheShkYXRhKSB8fCBpc09iamVjdChkYXRhKSkge1xuICAgICAgICAgICAgZWFjaChkYXRhLCAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgYW4gYXR0cmlidXRlIHdpdGggYSBnaXZlbiBrZXkvdmFsdWUgcGFpci4gVGhpcyB3aWxsIHRyYWNrIHRoZSBjaGFuZ2VzXG4gICAgICogaW4gdGhlIG1vZGVsIHdpdGhpbiB0aGUgYHRoaXMuJGNoYW5nZWRgIHByb3BlcnR5LiBJZiB0aGUgcHJpbWFyeSBrZXlcbiAgICAgKiBpcyBzZXQsIGl0IHdpbGwgYWxzbyBjaGFuZ2UgdGhlIGB0aGlzLiRleGlzdHNgIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGtleSBzdHJpbmdcbiAgICAgKiBAcGFyYW0gdmFsdWUgbWl4ZWRcbiAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgKi9cbiAgICBzZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZih0aGlzLmdldEF0dHJpYnV0ZShrZXkpICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVBdHRyaWJ1dGVDaGFuZ2Uoa2V5LCB2YWx1ZSk7XG5cbiAgICAgICAgICAgIGlmKGlzVW5kZWZpbmVkKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLiRhdHRyaWJ1dGVzW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRhdHRyaWJ1dGVzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldmVydCB0aGUgbW9kZWwgdG8gaXRzIG9yaWdpbmFsIHN0YXRlLlxuICAgICAqXG4gICAgICogQHJldHVybiBib29sXG4gICAgICovXG4gICAgcmV2ZXJ0KCkge1xuICAgICAgICBlYWNoKHRoaXMuJGNoYW5nZWQsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICBpZighaXNVbmRlZmluZWQodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kYXR0cmlidXRlc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy4kYXR0cmlidXRlc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLiRjaGFuZ2VkID0ge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpZiB0aGUgbW9kZWwgaGFzIGEgcHJpbWFyeSBrZXkgc2V0LlxuICAgICAqXG4gICAgICogQHJldHVybiBib29sXG4gICAgICovXG4gICAgZXhpc3RzKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLiRleGlzdHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbW9kZWwgYmVlbiBjaGFuZ2VkIG9yIG5vdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gYm9vbFxuICAgICAqL1xuICAgIGhhc0NoYW5nZWQoa2V5KSB7XG4gICAgICAgIHJldHVybiAha2V5ID8gc2l6ZSh0aGlzLiRjaGFuZ2VkKSA+IDAgOiAhaXNVbmRlZmluZWQodGhpcy4kY2hhbmdlZFtrZXldKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEb2VzIHRoZSBtb2RlbCBoYXZlIGFueSBGaWxlIG9iamVjdHMuIElmIHNvLCBuZWVkIHRvIHNlbmQgYXMgbXVsdGlwYXJ0LlxuICAgICAqXG4gICAgICogQHJldHVybiBib29sXG4gICAgICovXG4gICAgaGFzRmlsZXMoKSB7XG4gICAgICAgIGZ1bmN0aW9uIGNvdW50KGZpbGVzLCB0b3RhbCA9IDApIHtcbiAgICAgICAgICAgIHJldHVybiByZWR1Y2UoZmlsZXMsIChjYXJyeSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICBpZihpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FycnkgKyBjb3VudCh2YWx1ZSwgdG90YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmKHZhbHVlIGluc3RhbmNlb2YgRmlsZSB8fCB2YWx1ZSBpbnN0YW5jZW9mIEZpbGVMaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYXJyeSArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2Fycnk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdG90YWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvdW50KHRoaXMudG9KU09OKCkpICE9PSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBzZXR0aW5ncyB0aGUgJGNoYW5nZWQgYXR0cmlidXRlcyB3aGVuIGFuIGF0dHJpYnV0ZSB2YWx1ZSBpcyBzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ga2V5IHN0cmluZ1xuICAgICAqIEBwYXJhbSB2YWx1ZSBtaXhlZFxuICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAqL1xuICAgIGhhbmRsZUF0dHJpYnV0ZUNoYW5nZShrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmKHRoaXMuJGluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICBpZih0aGlzLiRjaGFuZ2VkW2tleV0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuJGNoYW5nZWRba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYoIShrZXkgaW4gdGhpcy4kY2hhbmdlZCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRjaGFuZ2VkW2tleV0gPSB0aGlzLmdldEF0dHJpYnV0ZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5oYW5kbGVQcmltYXJ5S2V5Q2hhbmdlKGtleSwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCBhbiBhcnJheSBvciBvYmplY3Qgb2YgZGF0YSBhcyBhdHRyaWJ1dGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGtleSBzdHJpbmdcbiAgICAgKiBAcGFyYW0gdmFsdWUgbWl4ZWRcbiAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgKi9cbiAgICBoYW5kbGVQcmltYXJ5S2V5Q2hhbmdlKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYodGhpcy4ka2V5ID09PSBrZXkpIHtcbiAgICAgICAgICAgIHRoaXMuJGV4aXN0cyA9ICFpc1VuZGVmaW5lZCh2YWx1ZSkgJiYgIWlzTnVsbCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTYXZlIHRoZSBtb2RlbCB0byB0aGUgZGF0YWJhc2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRhIG9iamVjdFxuICAgICAqIEByZXR1cm4gYm9vbFxuICAgICAqL1xuICAgIHNhdmUoZGF0YSA9IHt9LCBjb25maWcgPSB7fSkge1xuICAgICAgICByZXR1cm4gIXRoaXMuZXhpc3RzKCkgPyB0aGlzLmNyZWF0ZShkYXRhLCBjb25maWcpIDogdGhpcy51cGRhdGUoZGF0YSwgY29uZmlnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgbW9kZWxcbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRhIG9iamVjdFxuICAgICAqIEByZXR1cm4gYm9vbFxuICAgICAqL1xuICAgIGNyZWF0ZShkYXRhID0ge30sIGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHRoaXMuZmlsbChkYXRhKTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuY29uc3RydWN0b3IucmVxdWVzdCh0aGlzLnVyaSgpLCBleHRlbmQoe30sIGNvbmZpZykpO1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9ICF0aGlzLmhhc0ZpbGVzKCkgPyB0aGlzLnRvSnNvbigpIDogdGhpcy50b0Zvcm1EYXRhKCk7XG5cbiAgICAgICAgICAgIHJlcXVlc3QucG9zdChkYXRhKS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMuZmlsbChyZXNwb25zZSkpO1xuICAgICAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIGFuIGV4aXN0aW5nIG1vZGVsXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGF0YSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIGJvb2xcbiAgICAgKi9cbiAgICB1cGRhdGUoZGF0YSA9IHt9LCBjb25maWcgPSB7fSkge1xuICAgICAgICB0aGlzLmZpbGwoZGF0YSk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLmNvbnN0cnVjdG9yLnJlcXVlc3QodGhpcy51cmkoKSwgY29uZmlnKTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSAhdGhpcy5oYXNGaWxlcygpID8gdGhpcy50b0pzb24oKSA6IHRoaXMudG9Gb3JtRGF0YSgpO1xuXG4gICAgICAgICAgICByZXF1ZXN0Wyh0aGlzLmhhc0ZpbGVzKCkgPyAncG9zdCcgOiAncHV0JyldKGRhdGEpLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICAgICAgICAgIHJlc29sdmUodGhpcy5maWxsKHJlc3BvbnNlKSk7XG4gICAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYW4gZXhpc3RpbmcgbW9kZWxcbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRhIG9iamVjdFxuICAgICAqIEByZXR1cm4gYm9vbFxuICAgICAqL1xuICAgIGRlbGV0ZShjb25maWcgPSB7fSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgaWYoIXRoaXMuZXhpc3RzKCkpIHtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdUaGUgbW9kZWwgbXVzdCBoYXZlIGEgcHJpbWFyeSBrZXkgYmVmb3JlIGl0IGNhbiBiZSBkZWxldGUuJykpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5jb25zdHJ1Y3Rvci5yZXF1ZXN0KHRoaXMudXJpKCksIGNvbmZpZyk7XG5cbiAgICAgICAgICAgIHJlcXVlc3QuZGVsZXRlKCkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgLy9yZXNvbHZlKHRoaXMuZmlsbChyZXNwb25zZSkpO1xuICAgICAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydCB0aGUgTW9kZWwgaW5zdGFuY2UgdG8gYSBGb3JtRGF0YSBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQHJldHVybiBvYmplY3RcbiAgICAgKi9cbiAgICB0b0Zvcm1EYXRhKCkge1xuICAgICAgICBjb25zdCBmb3JtID0gbmV3IEZvcm1EYXRhKCk7XG5cbiAgICAgICAgZWFjaCh0aGlzLnRvSlNPTigpLCAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgaWYoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBlYWNoKHZhbHVlLCBpdGVtID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYoIShpdGVtIGluc3RhbmNlb2YgRmlsZSkgJiYgKGlzT2JqZWN0KGl0ZW0pIHx8IGlzQXJyYXkoaXRlbSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtID0gSlNPTi5zdHJpbmdpZnkoaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmb3JtLmFwcGVuZChrZXkucmVwbGFjZSgvKC4rKShcXFsuK1xcXT8pJC8sICckMScpKydbXScsIGl0ZW0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZighKHZhbHVlIGluc3RhbmNlb2YgRmlsZSkgJiYgaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZm9ybS5hcHBlbmQoa2V5LCBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZighaXNOdWxsKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGZvcm0uYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZm9ybTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRoZSBpbnN0YW5jZSB0byBKU09OIHBheWxvYWRcbiAgICAgKlxuICAgICAqIEByZXR1cm4gb2JqZWN0XG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gcGlja0J5KHRoaXMuJGF0dHJpYnV0ZXMsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gIXRoaXMuJHByb3BlcnRpZXMubGVuZ3RoIHx8IChcbiAgICAgICAgICAgICAgICBrZXkgPT09IHRoaXMua2V5KCkgfHwgdGhpcy4kcHJvcGVydGllcy5pbmRleE9mKGtleSkgIT09IC0xXG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbGlhcyBmb3IgdG9KU09OXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIG9iamVjdFxuICAgICAqL1xuICAgIHRvSnNvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9KU09OKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VhcmNoIGZvciBhIGNvbGxlY3Rpb24gb2YgbW9kZWxzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGF0YSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIGJvb2xcbiAgICAgKi9cbiAgICBzdGF0aWMgc2VhcmNoKHVyaSwgcGFyYW1zID0ge30sIGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IG1vZGVsID0gbmV3IHRoaXM7XG5cbiAgICAgICAgaWYoIXVyaSkge1xuICAgICAgICAgICAgdXJpID0gbW9kZWwudXJpKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMucmVxdWVzdCh1cmksIGNvbmZpZyk7XG5cbiAgICAgICAgICAgIHJlcXVlc3QuZ2V0KHBhcmFtcykudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShtYXAocmVzcG9uc2UuZGF0YSwgZGF0YSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdGhpcyhkYXRhKTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9LCBlcnJvcnMgPT4ge1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcnMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmQgYW4gZXhpc3RpbmcgbW9kZWwgYnkgaWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRhIG9iamVjdFxuICAgICAqIEByZXR1cm4gYm9vbFxuICAgICAqL1xuICAgIHN0YXRpYyBmaW5kKGlkLCBjb25maWcgPSB7fSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbW9kZWwgPSBuZXcgdGhpcztcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdChtb2RlbC51cmkoaWQpLCBjb25maWcpLmdldCgpLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICAgICAgICAgIHJlc29sdmUobW9kZWwuaW5pdGlhbGl6ZShyZXNwb25zZSkpO1xuICAgICAgICAgICAgfSwgZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgcmVxdWVzdCBmcm9tIHRoZSBtb2RlbCBkYXRhXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGF0YSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIGJvb2xcbiAgICAgKi9cbiAgICBzdGF0aWMgcmVxdWVzdCh1cmwsIGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVxdWVzdCh1cmwsIGNvbmZpZyk7XG4gICAgfVxuXG59XG4iLCI8dGVtcGxhdGU+XG4gICAgPGZvcm0gQHN1Ym1pdC5wcmV2ZW50PVwib25TdWJtaXRcIiA6Y2xhc3M9XCJ7J2Zvcm0taW5saW5lJzogaW5saW5lfVwiIDpub3ZhbGlkYXRlPVwibm92YWxpZGF0ZVwiPlxuICAgICAgICA8c2xvdD48L3Nsb3Q+XG4gICAgPC9mb3JtPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBNb2RlbCBmcm9tICcuLi8uLi9IdHRwL01vZGVsL01vZGVsJztcbmltcG9ydCB7IGlzRnVuY3Rpb24gfSBmcm9tICdsb2Rhc2gtZXMnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgTW9kZWwgbWV0aG9kIHVzZWQgdG8gc2VuZCB0aGUgcmVxdWVzdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IEJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIG1ldGhvZDoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJ3NhdmUnLFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tb2RlbCAmJiBpc0Z1bmN0aW9uKHRoaXMubW9kZWxbdmFsdWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gb2JqZWN0IG9mIGZvcm0gZGF0YVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgT2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgICAgICBkZWZhdWx0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwbGF5IHRoZSBmb3JtIGZpZWxkcyBpbmxpbmVcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IE9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgbW9kZWw6IHtcbiAgICAgICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgTW9kZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc3BsYXkgdGhlIGZvcm0gZmllbGRzIGlubGluZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgQm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgaW5saW5lOiBCb29sZWFuLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGNhbGxiYWNrIGZ1bmN0aW9uIGZvciB0aGUgYHN1Ym1pdGAgZXZlbnRcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IEJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIG5vdmFsaWRhdGU6IHtcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgICBkZWZhdWx0OiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgVVJJIG9yIFVSTCB1c2VkIHRvIHJlZGlyZWN0IHVzZXIgYWZ0ZXIgZm9ybSBzdWJtaXRzIHN1Y2Nlc3NmdWxseS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IEZ1bmN0aW9ufFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgcmVkaXJlY3Q6IFtPYmplY3QsIFN0cmluZywgRnVuY3Rpb25dLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGNhbGxiYWNrIGZ1bmN0aW9uIGZvciB0aGUgYHN1Ym1pdGAgZXZlbnRcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IEZ1bmN0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBvblN1Ym1pdDoge1xuICAgICAgICAgICAgdHlwZTogRnVuY3Rpb24sXG4gICAgICAgICAgICBkZWZhdWx0KGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbCAmJiB0aGlzLnN1Ym1pdChldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIHRoZSBgc3VibWl0OnN1Y2Nlc3NgIGV2ZW50XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBGdW5jdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgb25TdWJtaXRTdWNjZXNzOiB7XG4gICAgICAgICAgICB0eXBlOiBGdW5jdGlvbixcbiAgICAgICAgICAgIGRlZmF1bHQoZXZlbnQsIGRhdGEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdzdWJtaXQ6c3VjY2VzcycsIGV2ZW50LCBkYXRhKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdzdWJtaXQ6Y29tcGxldGUnLCBldmVudCwgdHJ1ZSwgZGF0YSk7XG5cbiAgICAgICAgICAgICAgICBpZih0aGlzLnJlZGlyZWN0ICYmIGlzRnVuY3Rpb24odGhpcy5yZWRpcmVjdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWRpcmVjdCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZih0aGlzLnJlZGlyZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJHJvdXRlci5wdXNoKHRoaXMucmVkaXJlY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBjYWxsYmFjayBmdW5jdGlvbiBmb3IgdGhlIGBzdWJtaXQ6c3VjY2Vzc2AgZXZlbnRcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IEZ1bmN0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBvblN1Ym1pdEZhaWxlZDoge1xuICAgICAgICAgICAgdHlwZTogRnVuY3Rpb24sXG4gICAgICAgICAgICBkZWZhdWx0KGV2ZW50LCBlcnJvcnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdzdWJtaXQ6ZmFpbGVkJywgZXZlbnQsIGVycm9ycyk7XG4gICAgICAgICAgICAgICAgdGhpcy4kZW1pdCgnc3VibWl0OmNvbXBsZXRlJywgZXZlbnQsIGZhbHNlLCBlcnJvcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgbWV0aG9kczoge1xuXG4gICAgICAgIHN1Ym1pdChldmVudCkge1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgnc3VibWl0JywgZXZlbnQpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tb2RlbFt0aGlzLm1ldGhvZF0odGhpcy5kYXRhLCB7XG4gICAgICAgICAgICAgICAgb25VcGxvYWRQcm9ncmVzczogZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdzdWJtaXQ6cHJvZ3Jlc3MnLCBldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMub25TdWJtaXRTdWNjZXNzKGV2ZW50LCBkYXRhKTtcbiAgICAgICAgICAgIH0sIChlcnJvcnMpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uU3VibWl0RmFpbGVkKGV2ZW50LCBlcnJvcnMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZXJyb3JzOiB7fVxuICAgICAgICB9XG4gICAgfVxuXG59XG5cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IEJhc2VGb3JtIGZyb20gJy4vQmFzZUZvcm0nO1xuaW1wb3J0IFZ1ZUluc3RhbGxlciBmcm9tICcuLi8uLi9IZWxwZXJzL1Z1ZUluc3RhbGxlci9WdWVJbnN0YWxsZXInO1xuXG5jb25zdCBwbHVnaW4gPSBWdWVJbnN0YWxsZXIudXNlKHtcblxuICAgIGluc3RhbGwoVnVlLCBvcHRpb25zKSB7XG4gICAgICAgIFZ1ZUluc3RhbGxlci5jb21wb25lbnRzKHtcbiAgICAgICAgICAgIEJhc2VGb3JtXG4gICAgICAgIH0pO1xuICAgIH1cblxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VGb3JtO1xuIiwiPHRlbXBsYXRlPlxuICAgIDxsaSBjbGFzcz1cImJyZWFkY3J1bWItaXRlbVwiIDpjbGFzcz1cInsnYWN0aXZlJzogYWN0aXZlfVwiIDphcmlhLWN1cnJlbnQ9XCJhY3RpdmUgPyAncGFnZScgOiBmYWxzZVwiPlxuICAgICAgICA8YSB2LWlmPVwiIWFjdGl2ZSAmJiBocmVmXCIgOmhyZWY9XCJocmVmXCI+XG4gICAgICAgICAgICA8c2xvdD57e2xhYmVsfX08L3Nsb3Q+XG4gICAgICAgIDwvYT5cbiAgICAgICAgPHRlbXBsYXRlIHYtZWxzZT5cbiAgICAgICAgICAgIDxzbG90Pnt7bGFiZWx9fTwvc2xvdD5cbiAgICAgICAgPC90ZW1wbGF0ZT5cbiAgICA8L2xpPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdicmVhZGNydW1iLWl0ZW0nLFxuXG4gICAgcHJvcHM6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSXMgdGhlIGl0ZW0gYWN0aXZlP1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcCB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGFjdGl2ZTogQm9vbGVhbixcblxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gaHJlZiBhdHRyaWJ1dGVcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3Age1N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIGhyZWY6IFN0cmluZyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gYnJlYWRjcnVtYiBsYWJlbFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcCB7U3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgbGFiZWw6IFN0cmluZ1xuXG4gICAgfVxuXG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgICA8bmF2IGFyaWEtbGFiZWw9XCJicmVhZGNydW1iXCI+XG4gICAgICAgIDxvbCBjbGFzcz1cImJyZWFkY3J1bWJcIj5cbiAgICAgICAgICAgIDxicmVhZGNydW1iLWl0ZW1cbiAgICAgICAgICAgICAgICB2LWlmPVwiaXRlbXMubGVuZ3RoXCJcbiAgICAgICAgICAgICAgICB2LWZvcj1cIihpdGVtLCBpKSBpbiBpdGVtc1wiXG4gICAgICAgICAgICAgICAgdi1iaW5kPVwiaXRlbVwiXG4gICAgICAgICAgICAgICAgOmtleT1cImlcIlxuICAgICAgICAgICAgICAgIDpjdXJyZW50PVwiaSA9PT0gaXRlbS5sZW5ndGggLSAxXCJcbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8c2xvdC8+XG4gICAgICAgIDwvb2w+XG4gICAgPC9uYXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IEJyZWFkY3J1bWJJdGVtIGZyb20gJy4vQnJlYWRjcnVtYkl0ZW0nO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAnYnJlYWRjcnVtYicsXG5cbiAgICBjb21wb25lbnRzOiB7XG4gICAgICAgIEJyZWFkY3J1bWJJdGVtXG4gICAgfSxcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGFycmF5IG9mIGJyZWFkY3J1bWJzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wIHtBcnJheX1cbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1zOiBBcnJheVxuXG4gICAgfVxuXG59XG48L3NjcmlwdD5cbiIsImltcG9ydCBCcmVhZGNydW1iIGZyb20gJy4vQnJlYWRjcnVtYic7XG5pbXBvcnQgQnJlYWRjcnVtYkl0ZW0gZnJvbSAnLi9CcmVhZGNydW1iSXRlbSc7XG5pbXBvcnQgVnVlSW5zdGFsbGVyIGZyb20gJy4uLy4uL0hlbHBlcnMvVnVlSW5zdGFsbGVyL1Z1ZUluc3RhbGxlcic7XG5cbmNvbnN0IHBsdWdpbiA9IFZ1ZUluc3RhbGxlci51c2Uoe1xuXG4gICAgaW5zdGFsbChWdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgVnVlSW5zdGFsbGVyLmNvbXBvbmVudHMoe1xuICAgICAgICAgICAgQnJlYWRjcnVtYixcbiAgICAgICAgICAgIEJyZWFkY3J1bWJJdGVtXG4gICAgICAgIH0pO1xuICAgIH1cblxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IEJyZWFkY3J1bWI7XG4iLCJpbXBvcnQgcHJlZml4IGZyb20gJy4uLy4uL0hlbHBlcnMvUHJlZml4L1ByZWZpeCc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzaXplIG9mIHRoZSBmb3JtIGNvbnRyb2xcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgc2l6ZToge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJ21kJyxcbiAgICAgICAgICAgIHZhbGlkYXRlOiB2YWx1ZSA9PiBbJ3NtJywgJ21kJywgJ2xnJ10uaW5kZXhPZih2YWx1ZSkgIT09IC0xXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBjb21wdXRlZDoge1xuXG4gICAgICAgIHNpemVhYmxlQ2xhc3NQcmVmaXgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kb3B0aW9ucy5uYW1lO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNpemVhYmxlQ2xhc3MoKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJlZml4KHRoaXMuc2l6ZSwgdGhpcy5zaXplYWJsZUNsYXNzUHJlZml4KTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG59XG4iLCIvKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG5lZ2F0ZXMgdGhlIHJlc3VsdCBvZiB0aGUgcHJlZGljYXRlIGBmdW5jYC4gVGhlXG4gKiBgZnVuY2AgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgYW5kIGFyZ3VtZW50cyBvZiB0aGVcbiAqIGNyZWF0ZWQgZnVuY3Rpb24uXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIHByZWRpY2F0ZSB0byBuZWdhdGUuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBuZWdhdGVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBpc0V2ZW4obikge1xuICogICByZXR1cm4gbiAlIDIgPT0gMDtcbiAqIH1cbiAqXG4gKiBfLmZpbHRlcihbMSwgMiwgMywgNCwgNSwgNl0sIF8ubmVnYXRlKGlzRXZlbikpO1xuICogLy8gPT4gWzEsIDMsIDVdXG4gKi9cbmZ1bmN0aW9uIG5lZ2F0ZShwcmVkaWNhdGUpIHtcbiAgaWYgKHR5cGVvZiBwcmVkaWNhdGUgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOiByZXR1cm4gIXByZWRpY2F0ZS5jYWxsKHRoaXMpO1xuICAgICAgY2FzZSAxOiByZXR1cm4gIXByZWRpY2F0ZS5jYWxsKHRoaXMsIGFyZ3NbMF0pO1xuICAgICAgY2FzZSAyOiByZXR1cm4gIXByZWRpY2F0ZS5jYWxsKHRoaXMsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgY2FzZSAzOiByZXR1cm4gIXByZWRpY2F0ZS5jYWxsKHRoaXMsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgIH1cbiAgICByZXR1cm4gIXByZWRpY2F0ZS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbmVnYXRlO1xuIiwiaW1wb3J0IGJhc2VJdGVyYXRlZSBmcm9tICcuL19iYXNlSXRlcmF0ZWUuanMnO1xuaW1wb3J0IG5lZ2F0ZSBmcm9tICcuL25lZ2F0ZS5qcyc7XG5pbXBvcnQgcGlja0J5IGZyb20gJy4vcGlja0J5LmpzJztcblxuLyoqXG4gKiBUaGUgb3Bwb3NpdGUgb2YgYF8ucGlja0J5YDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2ZcbiAqIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIGBvYmplY3RgIHRoYXRcbiAqIGBwcmVkaWNhdGVgIGRvZXNuJ3QgcmV0dXJuIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHR3b1xuICogYXJndW1lbnRzOiAodmFsdWUsIGtleSkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIHByb3BlcnR5LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gKlxuICogXy5vbWl0Qnkob2JqZWN0LCBfLmlzTnVtYmVyKTtcbiAqIC8vID0+IHsgJ2InOiAnMicgfVxuICovXG5mdW5jdGlvbiBvbWl0Qnkob2JqZWN0LCBwcmVkaWNhdGUpIHtcbiAgcmV0dXJuIHBpY2tCeShvYmplY3QsIG5lZ2F0ZShiYXNlSXRlcmF0ZWUocHJlZGljYXRlKSkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBvbWl0Qnk7XG4iLCJpbXBvcnQgeyBtYXAgfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IHsgZWFjaCB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgeyBmaWx0ZXIgfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IHsgb21pdEJ5IH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCB7IGNhbWVsQ2FzZSB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgcHJlZml4IGZyb20gJy4uLy4uL0hlbHBlcnMvUHJlZml4L1ByZWZpeCc7XG5cbmNvbnN0IENPTE9SUyA9IFtcbiAgICAncHJpbWFyeScsXG4gICAgJ3NlY29uZGFyeScsXG4gICAgJ3N1Y2Nlc3MnLFxuICAgICdkYW5nZXInLFxuICAgICd3YXJuaW5nJyxcbiAgICAnaW5mbycsXG4gICAgJ2xpZ2h0JyxcbiAgICAnZGFyaycsXG4gICAgJ3doaXRlJyxcbiAgICAnbXV0ZWQnXG5dO1xuXG5jb25zdCBwcm9wcyA9IHt9O1xuXG5lYWNoKFsnYm9yZGVyJywgJ3RleHQnLCAnYmcnLCAnYmctZ3JhZGllbnQnXSwgbmFtZXNwYWNlID0+IHtcbiAgICBlYWNoKENPTE9SUywgY29sb3IgPT4ge1xuICAgICAgICBwcm9wc1tjYW1lbENhc2UocHJlZml4KGNvbG9yLCBuYW1lc3BhY2UpKV0gPSBCb29sZWFuO1xuICAgIH0pO1xufSk7XG5cbmZ1bmN0aW9uIGNsYXNzZXMoaW5zdGFuY2UsIG5hbWVzcGFjZSkge1xuICAgIHJldHVybiBmaWx0ZXIobWFwKENPTE9SUywgY29sb3IgPT4ge1xuICAgICAgICByZXR1cm4gaW5zdGFuY2VbY2FtZWxDYXNlKGNvbG9yID0gcHJlZml4KGNvbG9yLCBuYW1lc3BhY2UpKV0gPyBjb2xvciA6IG51bGw7XG4gICAgfSkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBwcm9wczogcHJvcHMsXG5cbiAgICBtZXRob2RzOiB7XG5cbiAgICAgICAgdGV4dENvbG9yKCkge1xuICAgICAgICAgICAgcmV0dXJuIGNsYXNzZXModGhpcywgJ3RleHQnKTtcbiAgICAgICAgfSxcblxuICAgICAgICBiZ0NvbG9yKCkge1xuICAgICAgICAgICAgcmV0dXJuIGNsYXNzZXModGhpcywgJ2JnJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYm9yZGVyQ29sb3IoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2xhc3Nlcyh0aGlzLCAnYm9yZGVyJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYmdHcmFkaWVudENvbG9yKCkge1xuICAgICAgICAgICAgcmV0dXJuIGNsYXNzZXModGhpcywgJ2JnLWdyYWRpZW50Jyk7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBjb21wdXRlZDoge1xuXG4gICAgICAgIHRleHRDb2xvckNsYXNzZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50ZXh0Q29sb3IoKS5qb2luKCcgJykudHJpbSgpIHx8IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYm9yZGVyQ29sb3JDbGFzc2VzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYm9yZGVyQ29sb3IoKS5qb2luKCcgJykudHJpbSgpIHx8IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYmdDb2xvckNsYXNzZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iZ0NvbG9yKCkuam9pbignICcpLnRyaW0oKSB8fCBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIGJnR3JhZGllbnRDb2xvckNsYXNzZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iZ0dyYWRpZW50Q29sb3IoKS5qb2luKCcgJykudHJpbSgpIHx8IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29sb3JhYmxlQ2xhc3NlcygpIHtcbiAgICAgICAgICAgIGNvbnN0IGNsYXNzZXMgPSB7fTtcblxuICAgICAgICAgICAgY2xhc3Nlc1t0aGlzLnRleHRDb2xvckNsYXNzZXNdID0gISF0aGlzLnRleHRDb2xvckNsYXNzZXM7XG4gICAgICAgICAgICBjbGFzc2VzW3RoaXMuYm9yZGVyQ29sb3JDbGFzc2VzXSA9ICEhdGhpcy5ib3JkZXJDb2xvckNsYXNzZXM7XG4gICAgICAgICAgICBjbGFzc2VzW3RoaXMuYmdDb2xvckNsYXNzZXNdID0gISF0aGlzLmJnQ29sb3JDbGFzc2VzO1xuICAgICAgICAgICAgY2xhc3Nlc1t0aGlzLmJnR3JhZGllbnRDb2xvckNsYXNzZXNdID0gISF0aGlzLmJnR3JhZGllbnRDb2xvckNsYXNzZXM7XG5cbiAgICAgICAgICAgIHJldHVybiBvbWl0QnkoY2xhc3NlcywgKGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIWtleSB8fCAhdmFsdWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG59XG4iLCI8dGVtcGxhdGU+XG4gICAgPHJvdXRlci1saW5rIHYtaWY9XCJ0b1wiIDp0bz1cInRvXCIgOmRpc2FibGVkPVwiZGlzYWJsZWRcIiA6Y2xhc3M9XCJjbGFzc2VzXCIgQGNsaWNrPVwib25DbGlja1wiIHJvbGU9XCJidXR0b25cIj5cbiAgICAgICAgPHNsb3QvPlxuICAgIDwvcm91dGVyLWxpbms+XG4gICAgPGEgdi1lbHNlLWlmPVwiaHJlZlwiIDpocmVmPVwiaHJlZlwiIDpkaXNhYmxlZD1cImRpc2FibGVkXCIgOmNsYXNzPVwiY2xhc3Nlc1wiIEBjbGljaz1cIm9uQ2xpY2tcIiByb2xlPVwiYnV0dG9uXCI+XG4gICAgICAgIDxzbG90Lz5cbiAgICA8L2E+XG4gICAgPGxhYmVsIHYtZWxzZS1pZj1cImxhYmVsXCIgOmRpc2FibGVkPVwiZGlzYWJsZWRcIiA6Y2xhc3M9XCJjbGFzc2VzXCIgQGNsaWNrPVwib25DbGlja1wiIHJvbGU9XCJidXR0b25cIj5cbiAgICAgICAgPHNsb3QvPlxuICAgIDwvbGFiZWw+XG4gICAgPGJ1dHRvbiB2LWVsc2UgOnR5cGU9XCJ0eXBlXCIgOmRpc2FibGVkPVwiZGlzYWJsZWRcIiA6Y2xhc3M9XCJjbGFzc2VzXCIgQGNsaWNrPVwib25DbGlja1wiPlxuICAgICAgICA8c2xvdC8+XG4gICAgPC9idXR0b24+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IFZhcmlhbnQgZnJvbSAnLi4vLi4vTWl4aW5zL1ZhcmlhbnQnO1xuaW1wb3J0IFNpemVhYmxlIGZyb20gJy4uLy4uL01peGlucy9TaXplYWJsZSc7XG5pbXBvcnQgQ29sb3JhYmxlIGZyb20gJy4uLy4uL01peGlucy9Db2xvcmFibGUnO1xuaW1wb3J0IHRyYW5zaXRpb24gZnJvbSAnLi4vLi4vSGVscGVycy9UcmFuc2l0aW9uL1RyYW5zaXRpb24nO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAnYnRuJyxcblxuICAgIG1peGluczogW1xuICAgICAgICBWYXJpYW50LFxuICAgICAgICBTaXplYWJsZSxcbiAgICAgICAgQ29sb3JhYmxlXG4gICAgXSxcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc3BsYXkgYnV0dG9uIHdpdGggYWN0aXZlIHN0YXRlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGFjdGl2ZTogQm9vbGVhbixcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzcGxheSBidXR0b24gd2l0aCBibG9ja2VkIHN0YXRlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGJsb2NrOiBCb29sZWFuLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwbGF5IGJ1dHRvbiB3aXRoIGRpc2FibGVkIHN0YXRlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGRpc2FibGVkOiBCb29sZWFuLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBhbiBocmVmIGlzIHBhc3NlZCwgYnV0dG9uIGlzIGFuIHJvdXRlci1saW5rIGVsZW1lbnRcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IEJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIGhyZWY6IFN0cmluZyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvdWxkIHVzZSA8bGFiZWw+IGFzIHRoZSBlbGVtZW50IGZvciB0aGUgYnV0dG9uLiBVc2VkIGZvciBpbnB1dHNcbiAgICAgICAgICogd3JhcHBlcnMgKHRvZ2dsZXMpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgQm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgbGFiZWw6IEJvb2xlYW4sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc3BsYXkgYXMgYW4gb3V0bGluZSBidXR0b25cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgb3V0bGluZTogQm9vbGVhbixcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgYW4gdG8gaXMgcGFzc2VkLCBidXR0b24gaXMgYW4gcm91dGVyLWxpbmsgZWxlbWVudFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgQm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgdG86IFtPYmplY3QsIFN0cmluZ10sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0eXBlIGF0dHJpYnV0ZSBmb3IgdGhlIGJ1dHRvbi4gTm90IGFwcGxpZWQgaWYgYW4gYW5jaG9yXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHR5cGU6IFN0cmluZ1xuXG4gICAgfSxcblxuICAgIG1ldGhvZHM6IHtcblxuICAgICAgICBvbkNsaWNrKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCdjbGljaycsIGV2ZW50LCB0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGNvbXB1dGVkOiB7XG5cbiAgICAgICAgdmFyaWFudENsYXNzUHJlZml4KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJG9wdGlvbnMubmFtZSArICh0aGlzLm91dGxpbmUgPyAnLW91dGxpbmUnIDogJycpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsYXNzZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kbWVyZ2VDbGFzc2VzKFxuICAgICAgICAgICAgICAgICdidG4nLFxuICAgICAgICAgICAgICAgIHRoaXMudmFyaWFudENsYXNzLFxuICAgICAgICAgICAgICAgIHRoaXMuc2l6ZWFibGVDbGFzcyxcbiAgICAgICAgICAgICAgICB0aGlzLmNvbG9yYWJsZUNsYXNzZXMsXG4gICAgICAgICAgICAgICAgdGhpcy5ibG9jayA/ICdidG4tYmxvY2snIDogJycsXG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmUgPyAnYWN0aXZlJyA6ICcnXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICB9XG5cbn1cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cInNjc3NcIj5cbkBpbXBvcnQgJy4vbm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC9zY3NzL21peGlucy5zY3NzJztcbkBpbXBvcnQgJy4vbm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC9zY3NzL2Z1bmN0aW9ucy5zY3NzJztcbkBpbXBvcnQgJy4vbm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC9zY3NzL3ZhcmlhYmxlcy5zY3NzJztcblxuQG1peGluIGJ1dHRvbi1ibG9jaygkc2l6ZSkge1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGRpc3BsYXk6IGJsb2NrO1xufVxuXG5AaW5jbHVkZSBtZWRpYS1icmVha3BvaW50LWRvd24oeHMpIHtcbiAgICAuYnRuLXhzLWJsb2NrIHtcbiAgICAgICAgQGluY2x1ZGUgYnV0dG9uLWJsb2NrKHhzKTtcblxuICAgICAgICArIC5idG4teHMtYmxvY2sge1xuICAgICAgICAgICAgbWFyZ2luLXRvcDogJGJ0bi1ibG9jay1zcGFjaW5nLXk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbkBpbmNsdWRlIG1lZGlhLWJyZWFrcG9pbnQtZG93bihzbSkge1xuICAgIC5idG4tc20tYmxvY2sge1xuICAgICAgICBAaW5jbHVkZSBidXR0b24tYmxvY2soc20pO1xuXG4gICAgICAgICsgLmJ0bi14cy1ibG9jayxcbiAgICAgICAgKyAuYnRuLXNtLWJsb2NrIHtcbiAgICAgICAgICAgIG1hcmdpbi10b3A6ICRidG4tYmxvY2stc3BhY2luZy15O1xuICAgICAgICB9XG4gICAgfVxufVxuXG5AaW5jbHVkZSBtZWRpYS1icmVha3BvaW50LWRvd24obWQpIHtcbiAgICAuYnRuLW1kLWJsb2NrIHtcbiAgICAgICAgQGluY2x1ZGUgYnV0dG9uLWJsb2NrKG1kKTtcblxuICAgICAgICArIC5idG4teHMtYmxvY2ssXG4gICAgICAgICsgLmJ0bi1zbS1ibG9jayxcbiAgICAgICAgKyAuYnRuLW1kLWJsb2NrIHtcbiAgICAgICAgICAgIG1hcmdpbi10b3A6ICRidG4tYmxvY2stc3BhY2luZy15O1xuICAgICAgICB9XG4gICAgfVxufVxuXG5AaW5jbHVkZSBtZWRpYS1icmVha3BvaW50LWRvd24obGcpIHtcbiAgICAuYnRuLWxnLWJsb2NrIHtcbiAgICAgICAgQGluY2x1ZGUgYnV0dG9uLWJsb2NrKGxnKTtcblxuICAgICAgICArIC5idG4teHMtYmxvY2ssXG4gICAgICAgICsgLmJ0bi1zbS1ibG9jayxcbiAgICAgICAgKyAuYnRuLW1kLWJsb2NrLFxuICAgICAgICArIC5idG4tbGctYmxvY2sge1xuICAgICAgICAgICAgbWFyZ2luLXRvcDogJGJ0bi1ibG9jay1zcGFjaW5nLXk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbkBpbmNsdWRlIG1lZGlhLWJyZWFrcG9pbnQtZG93bih4bCkge1xuICAgIC5idG4teGwtYmxvY2sge1xuICAgICAgICBAaW5jbHVkZSBidXR0b24tYmxvY2soeGwpO1xuXG4gICAgICAgICsgLmJ0bi14cy1ibG9jayxcbiAgICAgICAgKyAuYnRuLXNtLWJsb2NrLFxuICAgICAgICArIC5idG4tbWQtYmxvY2ssXG4gICAgICAgICsgLmJ0bi1sZy1ibG9jayxcbiAgICAgICAgKyAuYnRuLXhsLWJsb2NrIHtcbiAgICAgICAgICAgIG1hcmdpbi10b3A6ICRidG4tYmxvY2stc3BhY2luZy15O1xuICAgICAgICB9XG4gICAgfVxufVxuXG48L3N0eWxlPlxuIiwiaW1wb3J0IEJ0biBmcm9tICcuL0J0bic7XG5pbXBvcnQgVnVlSW5zdGFsbGVyIGZyb20gJy4uLy4uL0hlbHBlcnMvVnVlSW5zdGFsbGVyL1Z1ZUluc3RhbGxlcic7XG5cbmNvbnN0IHBsdWdpbiA9IFZ1ZUluc3RhbGxlci51c2Uoe1xuXG4gICAgaW5zdGFsbChWdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgVnVlSW5zdGFsbGVyLmNvbXBvbmVudHMoe1xuICAgICAgICAgICAgQnRuXG4gICAgICAgIH0pO1xuICAgIH1cblxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IEJ0bjtcbiIsImV4cG9ydCBkZWZhdWx0IHtcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3VsZCBzaG93IG9ubHkgZm9yIHNjcmVlbnJlYWRlcnNcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IEJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIHNyT25seTogQm9vbGVhbixcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvdWxkIGJlIGZvY3VzYWJsZSBmb3Igc2NyZWVucmVhZGVyc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgQm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgc3JPbmx5Rm9jdXNhYmxlOiBCb29sZWFuXG5cbiAgICB9LFxuXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgc2NyZWVucmVhZGVyQ2xhc3NlcygpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgJ3NyLW9ubHknOiB0aGlzLnNyT25seSxcbiAgICAgICAgICAgICAgICAnc3Itb25seS1mb2N1c2FibGUnOiB0aGlzLnNyT25seUZvY3VzYWJsZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbn1cbiIsIjx0ZW1wbGF0ZT5cblxuICAgIDxzbWFsbCBjbGFzcz1cImZvcm0tdGV4dFwiIDpjbGFzcz1cImNsYXNzZXNcIj48c2xvdCAvPjwvc21hbGw+XG5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5cbmltcG9ydCB7IGV4dGVuZCB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgQ29sb3JhYmxlIGZyb20gJy4uLy4uL01peGlucy9Db2xvcmFibGUvQ29sb3JhYmxlJztcbmltcG9ydCBTY3JlZW5yZWFkZXJzIGZyb20gJy4uLy4uL01peGlucy9TY3JlZW5yZWFkZXJzL1NjcmVlbnJlYWRlcnMnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAnaGVscC10ZXh0JyxcblxuICAgIG1peGluczogW1xuICAgICAgICBDb2xvcmFibGUsXG4gICAgICAgIFNjcmVlbnJlYWRlcnNcbiAgICBdLFxuXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgY2xhc3NlcygpIHtcbiAgICAgICAgICAgIHJldHVybiBleHRlbmQoe30sIHRoaXMuc2NyZWVucmVhZGVyQ2xhc3NlcywgdGhpcy5jb2xvcmFibGVDbGFzc2VzKTtcbiAgICAgICAgfVxuICAgIH1cblxufVxuXG48L3NjcmlwdD5cbiIsImltcG9ydCBIZWxwVGV4dCBmcm9tICcuL0hlbHBUZXh0JztcbmltcG9ydCBWdWVJbnN0YWxsZXIgZnJvbSAnLi4vLi4vSGVscGVycy9WdWVJbnN0YWxsZXIvVnVlSW5zdGFsbGVyJztcblxuY29uc3QgcGx1Z2luID0gVnVlSW5zdGFsbGVyLnVzZSh7XG5cbiAgICBpbnN0YWxsKFZ1ZSwgb3B0aW9ucykge1xuICAgICAgICBWdWVJbnN0YWxsZXIuY29tcG9uZW50cyh7XG4gICAgICAgICAgICBIZWxwVGV4dFxuICAgICAgICB9KTtcbiAgICB9XG5cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBIZWxwVGV4dDtcbiIsIjx0ZW1wbGF0ZT5cblxuICAgIDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwXCI+PHNsb3QvPjwvZGl2PlxuXG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuXG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdmb3JtLWdyb3VwJ1xuICAgIFxufVxuXG48L3NjcmlwdD5cbiIsImltcG9ydCBGb3JtR3JvdXAgZnJvbSAnLi9Gb3JtR3JvdXAnO1xuaW1wb3J0IFZ1ZUluc3RhbGxlciBmcm9tICcuLi8uLi9IZWxwZXJzL1Z1ZUluc3RhbGxlci9WdWVJbnN0YWxsZXInO1xuXG5jb25zdCBwbHVnaW4gPSBWdWVJbnN0YWxsZXIudXNlKHtcblxuICAgIGluc3RhbGwoVnVlLCBvcHRpb25zKSB7XG4gICAgICAgIFZ1ZUluc3RhbGxlci5jb21wb25lbnRzKHtcbiAgICAgICAgICAgIEZvcm1Hcm91cFxuICAgICAgICB9KTtcbiAgICB9XG5cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBGb3JtR3JvdXA7XG4iLCI8dGVtcGxhdGU+XG5cbiAgICA8bGFiZWwgOmNsYXNzPVwiY2xhc3Nlc1wiPjxzbG90Lz48L2xhYmVsPlxuXG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuXG5pbXBvcnQgeyBleHRlbmQgfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IENvbG9yYWJsZSBmcm9tICcuLi8uLi9NaXhpbnMvQ29sb3JhYmxlL0NvbG9yYWJsZSc7XG5pbXBvcnQgU2NyZWVucmVhZGVycyBmcm9tICcuLi8uLi9NaXhpbnMvU2NyZWVucmVhZGVycy9TY3JlZW5yZWFkZXJzJztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ2Zvcm0tbGFiZWwnLFxuXG4gICAgbWl4aW5zOiBbXG4gICAgICAgIENvbG9yYWJsZSxcbiAgICAgICAgU2NyZWVucmVhZGVyc1xuICAgIF0sXG5cbiAgICBjb21wdXRlZDoge1xuICAgICAgICBjbGFzc2VzKCkge1xuICAgICAgICAgICAgcmV0dXJuIGV4dGVuZCh7fSwgdGhpcy5zY3JlZW5yZWFkZXJDbGFzc2VzLCB0aGlzLmNvbG9yYWJsZUNsYXNzZXMpO1xuICAgICAgICB9XG4gICAgfVxuXG59XG5cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IEZvcm1MYWJlbCBmcm9tICcuL0Zvcm1MYWJlbCc7XG5pbXBvcnQgVnVlSW5zdGFsbGVyIGZyb20gJy4uLy4uL0hlbHBlcnMvVnVlSW5zdGFsbGVyL1Z1ZUluc3RhbGxlcic7XG5cbmNvbnN0IHBsdWdpbiA9IFZ1ZUluc3RhbGxlci51c2Uoe1xuXG4gICAgaW5zdGFsbChWdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgVnVlSW5zdGFsbGVyLmNvbXBvbmVudHMoe1xuICAgICAgICAgICAgRm9ybUxhYmVsXG4gICAgICAgIH0pO1xuICAgIH1cblxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IEZvcm1MYWJlbDtcbiIsIjx0ZW1wbGF0ZT5cblxuICAgIDxkaXYgOmNsYXNzPVwieydpbnZhbGlkLWZlZWRiYWNrJzogaW52YWxpZCwgJ3ZhbGlkLWZlZWRiYWNrJzogdmFsaWQgJiYgIWludmFsaWR9XCI+XG4gICAgICAgIDxzbG90Pnt7bGFiZWx9fTwvc2xvdD5cbiAgICA8L2Rpdj5cblxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cblxuaW1wb3J0IENvbG9yYWJsZSBmcm9tICcuLi8uLi9NaXhpbnMvQ29sb3JhYmxlL0NvbG9yYWJsZSc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdmb3JtLWZlZWRiYWNrJyxcblxuICAgIG1peGluczogW1xuICAgICAgICBDb2xvcmFibGVcbiAgICBdLFxuXG4gICAgcHJvcHM6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHZhbHVlIG9mIGxhYmVsIGVsZW1lbnQuIElmIG5vIHZhbHVlLCBubyBsYWJlbCB3aWxsIGFwcGVhci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgbGFiZWw6IFN0cmluZyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvdWxkIHRoZSBmZWVkYmFjayBtYXJrZWQgYXMgaW52YWxpZFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBpbnZhbGlkOiBCb29sZWFuLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG91bGQgdGhlIGZlZWRiYWNrIG1hcmtlZCBhcyBpbnZhbGlkXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHZhbGlkOiBCb29sZWFuXG5cbiAgICB9XG5cbn1cblxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgRm9ybUZlZWRiYWNrIGZyb20gJy4vRm9ybUZlZWRiYWNrJztcbmltcG9ydCBWdWVJbnN0YWxsZXIgZnJvbSAnLi4vLi4vSGVscGVycy9WdWVJbnN0YWxsZXIvVnVlSW5zdGFsbGVyJztcblxuY29uc3QgcGx1Z2luID0gVnVlSW5zdGFsbGVyLnVzZSh7XG5cbiAgICBpbnN0YWxsKFZ1ZSwgb3B0aW9ucykge1xuICAgICAgICBWdWVJbnN0YWxsZXIuY29tcG9uZW50cyh7XG4gICAgICAgICAgICBGb3JtRmVlZGJhY2tcbiAgICAgICAgfSk7XG4gICAgfVxuXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgRm9ybUZlZWRiYWNrO1xuIiwiaW1wb3J0IHsgZWFjaCB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgeyBpc0FycmF5IH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCB7IGlzT2JqZWN0IH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCB7IGNhbWVsQ2FzZSB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgeyBpc1VuZGVmaW5lZCB9IGZyb20gJ2xvZGFzaC1lcydcbmltcG9ydCBwcmVmaXggZnJvbSAnLi4vLi4vSGVscGVycy9QcmVmaXgvUHJlZml4JztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgcHJvcHM6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGF1dG9jb21wbGV0ZSBhdHRyaWJ1dGUgdmFsdWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGF1dG9jb21wbGV0ZTogU3RyaW5nLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZmllbGQgaWQgYXR0cmlidXRlIHZhbHVlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBpZDogW051bWJlciwgU3RyaW5nXSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHZhbHVlIG9mIGxhYmVsIGVsZW1lbnQuIElmIG5vIHZhbHVlLCBubyBsYWJlbCB3aWxsIGFwcGVhci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgbGFiZWw6IFtOdW1iZXIsIFN0cmluZ10sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBmaWVsZCBuYW1lIGF0dHJpYnV0ZSB2YWx1ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgbmFtZTogU3RyaW5nLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZmllbGQgaWQgYXR0cmlidXRlIHZhbHVlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgZGVmYXVsdDogbnVsbFxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcGxhY2Vob2xkZXIgYXR0cmlidXRlIHZhbHVlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBwbGFjZWhvbGRlcjogU3RyaW5nLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJcyB0aGUgZmllbGQgcmVxdWlyZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHJlcXVpcmVkOiBCb29sZWFuLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgZm9ybS1ncm91cCB3cmFwcGVyIHRvIGlucHV0XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGdyb3VwOiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHJlZ2V4IHBhdHRlcm4gZm9yIHZhbGlkYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHBhdHRlcm46IFN0cmluZyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gaW5saW5lIGZpZWxkIHZhbGlkYXRpb24gZXJyb3IuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmd8Qm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgZXJyb3I6IFN0cmluZyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gaW5saW5lIGZpZWxkIHZhbGlkYXRpb24gZXJyb3JzIHBhc3NlZCBhcyBvYmplY3Qgd2l0aCBrZXkvdmFsdWVcbiAgICAgICAgICogcGFpcnMuIElmIGVycm9ycyBwYXNzZWQgYXMgYW4gb2JqZWN0LCB0aGUgZm9ybSBuYW1lIHdpbGwgYmUgdXNlZCBmb3JcbiAgICAgICAgICogdGhlIGtleS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IE9iamVjdHxCb29sZWFuXG4gICAgICAgICAqL1xuICAgICAgICBlcnJvcnM6IHtcbiAgICAgICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgICAgIGRlZmF1bHQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHt9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNvbWUgZmVlZGJhY2sgdG8gYWRkIHRvIHRoZSBmaWVsZCBvbmNlIHRoZSBmaWVsZCBpcyBzdWNjZXNzZnVsbHlcbiAgICAgICAgICogdmFsaWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGZlZWRiYWNrOiBbU3RyaW5nLCBBcnJheV0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGFycmF5IG9mIGV2ZW50IG5hbWVzIHRoYXQgY29ycmVsYXRlIHdpdGggY2FsbGJhY2sgZnVuY3Rpb25zXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBGdW5jdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgYmluZEV2ZW50czoge1xuICAgICAgICAgICAgdHlwZTogQXJyYXksXG4gICAgICAgICAgICBkZWZhdWx0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbJ2ZvY3VzJywgJ2JsdXInLCAnY2hhbmdlJywgJ2NsaWNrJywgJ2tleXVwJywgJ2tleWRvd24nLCAncHJvZ3Jlc3MnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRlZmF1bHQgY2xhc3MgbmFtZSBhc3NpZ25lZCB0byB0aGUgY29udHJvbCBlbGVtZW50XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGRlZmF1bHRDb250cm9sQ2xhc3M6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdmb3JtLWNvbnRyb2wnXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhpZGUgdGhlIGxhYmVsIGZvciBicm93c2VycywgYnV0IGxlYXZlIGl0IGZvciBzY3JlZW4gcmVhZGVycy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgaGlkZUxhYmVsOiBCb29sZWFuLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRpdGlvbmFsIG1hcmdpbi9wYWRkaW5nIGNsYXNzZXMgZm9yIGZpbmUgY29udHJvbCBvZiBzcGFjaW5nXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHNwYWNpbmc6IFN0cmluZyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNpemUgb2YgdGhlIGZvcm0gY29udHJvbFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBzaXplOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAnbWQnLFxuICAgICAgICAgICAgdmFsaWRhdGU6IHZhbHVlID0+IFsnc20nLCAnbWQnLCAnbGcnXS5pbmRleE9mKHZhbHVlKSAhPT0gLTFcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzcGxheSB0aGUgZm9ybSBmaWVsZCBpbmxpbmVcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgaW5saW5lOiBCb29sZWFuLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGUgZm9ybSBjb250cm9sIGlzIHJlYWRvbmx5LCBkaXNwbGF5IG9ubHkgYXMgdGV4dD9cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgcGxhaW50ZXh0OiBCb29sZWFuLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJcyB0aGUgZm9ybSBjb250cm9sIHJlYWRvbmx5P1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICByZWFkb25seTogQm9vbGVhbixcblxuICAgICAgICAvKipcbiAgICAgICAgICogSXMgdGhlIGZvcm0gY29udHJvbCBkaXNhYmxlZD9cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgZGlzYWJsZWQ6IEJvb2xlYW4sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNvbWUgaW5zdHJ1Y3Rpb25zIHRvIGFwcGVhciB1bmRlciB0aGUgZmllbGQgbGFiZWxcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgaGVscFRleHQ6IFN0cmluZyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1heGxlbmd0aCBhdHRyaWJ1dGVcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgbWF4bGVuZ3RoOiBbTnVtYmVyLCBTdHJpbmddXG5cbiAgICB9LFxuXG4gICAgZGlyZWN0aXZlczoge1xuICAgICAgICBiaW5kRXZlbnRzOiB7XG4gICAgICAgICAgICBiaW5kKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50cyA9IGJpbmRpbmcudmFsdWUgfHwgdm5vZGUuY29udGV4dC5iaW5kRXZlbnRzO1xuXG4gICAgICAgICAgICAgICAgZWFjaChldmVudHMsIG5hbWUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZub2RlLmNvbnRleHQuJGVtaXQobmFtZSwgZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtZXRob2RzOiB7XG5cbiAgICAgICAgZ2V0SW5wdXRGaWVsZCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yKCcuZm9ybS1jb250cm9sLCBpbnB1dCwgc2VsZWN0LCB0ZXh0YXJlYScpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEZpZWxkRXJyb3JzKCkge1xuICAgICAgICAgICAgbGV0IGVycm9ycyA9IHRoaXMuZXJyb3IgfHwgdGhpcy5lcnJvcnM7XG5cbiAgICAgICAgICAgIGlmKGlzT2JqZWN0KHRoaXMuZXJyb3JzKSkge1xuICAgICAgICAgICAgICAgIGVycm9ycyA9IHRoaXMuZXJyb3JzW3RoaXMubmFtZSB8fCB0aGlzLmlkXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuICFlcnJvcnMgfHwgaXNBcnJheShlcnJvcnMpIHx8IGlzT2JqZWN0KGVycm9ycykgPyBlcnJvcnMgOiBbZXJyb3JzXTtcbiAgICAgICAgfSxcblxuICAgICAgICB1cGRhdGVkKHZhbHVlLCBldmVudCkge1xuICAgICAgICAgICAgdGhpcy4kZW1pdChldmVudCB8fCAnaW5wdXQnLCB2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBjb21wdXRlZDoge1xuXG4gICAgICAgIGNhbGxiYWNrcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJpbmRFdmVudHMubWFwKGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IHRoaXNbY2FtZWxDYXNlKFsnb24nLCBldmVudF0uam9pbignICcpKV1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KS5maWx0ZXIoZXZlbnQgPT4gIWlzVW5kZWZpbmVkKGV2ZW50LmNhbGxiYWNrKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaW52YWxpZEZlZWRiYWNrKCkge1xuICAgICAgICAgICAgaWYodGhpcy5lcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBlcnJvcnMgPSB0aGlzLmdldEZpZWxkRXJyb3JzKCk7XG5cbiAgICAgICAgICAgIHJldHVybiBpc0FycmF5KGVycm9ycykgPyBlcnJvcnMuam9pbignPGJyPicpIDogZXJyb3JzO1xuICAgICAgICB9LFxuXG4gICAgICAgIHZhbGlkRmVlZGJhY2soKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNBcnJheSh0aGlzLmZlZWRiYWNrKSA/IHRoaXMuZmVlZGJhY2suam9pbignPGJyPicpIDogdGhpcy5mZWVkYmFjaztcbiAgICAgICAgfSxcblxuICAgICAgICBjb250cm9sQ2xhc3MoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWZhdWx0Q29udHJvbENsYXNzICsgKHRoaXMucGxhaW50ZXh0ID8gJy1wbGFpbnRleHQnIDogJycpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNvbnRyb2xTaXplQ2xhc3MoKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJlZml4KHRoaXMuc2l6ZSwgdGhpcy5jb250cm9sQ2xhc3MpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNvbnRyb2xDbGFzc2VzKCkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRyb2xDbGFzcyxcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRyb2xTaXplQ2xhc3MsXG4gICAgICAgICAgICAgICAgKHRoaXMuc3BhY2luZyB8fCAnJyksXG4gICAgICAgICAgICAgICAgKHRoaXMuaW52YWxpZEZlZWRiYWNrID8gJ2lzLWludmFsaWQnIDogJycpXG4gICAgICAgICAgICBdLmpvaW4oJyAnKTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYXNEZWZhdWx0U2xvdCAoKSB7XG4gICAgICAgICAgICByZXR1cm4gISF0aGlzLiRzbG90cy5kZWZhdWx0XG4gICAgICAgIH1cblxuICAgIH1cblxufVxuIiwiPHRlbXBsYXRlPlxuXG4gICAgPGZvcm0tZ3JvdXA+XG5cbiAgICAgICAgPHNsb3QgbmFtZT1cImxhYmVsXCI+XG4gICAgICAgICAgICA8Zm9ybS1sYWJlbCB2LWlmPVwibGFiZWwgfHwgaGFzRGVmYXVsdFNsb3RcIiA6Zm9yPVwiaWRcIiB2LWh0bWw9XCJsYWJlbFwiLz5cbiAgICAgICAgPC9zbG90PlxuXG4gICAgICAgIDxzbG90IG5hbWU9XCJjb250cm9sXCI+XG4gICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICA6aWQ9XCJpZFwiXG4gICAgICAgICAgICAgICAgOnR5cGU9XCJ0eXBlXCJcbiAgICAgICAgICAgICAgICA6bmFtZT1cIm5hbWVcIlxuICAgICAgICAgICAgICAgIDp2YWx1ZT1cInZhbHVlXCJcbiAgICAgICAgICAgICAgICA6cGF0dGVybj1cInBhdHRlcm5cIlxuICAgICAgICAgICAgICAgIDpyZWFkb25seT1cInJlYWRvbmx5XCJcbiAgICAgICAgICAgICAgICA6cmVxdWlyZWQ9XCJyZXF1aXJlZFwiXG4gICAgICAgICAgICAgICAgOm1heGxlbmd0aD1cIm1heGxlbmd0aFwiXG4gICAgICAgICAgICAgICAgOnBsYWNlaG9sZGVyPVwicGxhY2Vob2xkZXJcIlxuICAgICAgICAgICAgICAgIDpkaXNhYmxlZD1cImRpc2FibGVkIHx8IHJlYWRvbmx5XCJcbiAgICAgICAgICAgICAgICA6Y2xhc3M9XCIkbWVyZ2VDbGFzc2VzKGNvbnRyb2xDbGFzc2VzLCBjb2xvcmFibGVDbGFzc2VzKVwiXG4gICAgICAgICAgICAgICAgOmFyaWEtbGFiZWw9XCJsYWJlbFwiXG4gICAgICAgICAgICAgICAgOmFyaWEtZGVzY3JpYmVkYnk9XCJpZFwiXG4gICAgICAgICAgICAgICAgOmF1dG9jb21wbGV0ZT1cImF1dG9jb21wbGV0ZVwiXG4gICAgICAgICAgICAgICAgdi1iaW5kLWV2ZW50cz1cImJpbmRFdmVudHNcIlxuICAgICAgICAgICAgICAgIHYtb246aW5wdXQ9XCJ1cGRhdGVkKCRldmVudC50YXJnZXQudmFsdWUpXCJcbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvc2xvdD5cblxuICAgICAgICA8c2xvdC8+XG5cbiAgICAgICAgPHNsb3QgbmFtZT1cImhlbHBcIj5cbiAgICAgICAgICAgIDxoZWxwLXRleHQgdi1pZj1cImhlbHBUZXh0XCIgdi1odG1sPVwiaGVscFRleHRcIiAvPlxuICAgICAgICA8L3Nsb3Q+XG5cbiAgICAgICAgPHNsb3QgbmFtZT1cImZlZWRiYWNrXCI+XG4gICAgICAgICAgICA8Zm9ybS1mZWVkYmFjayB2LWlmPVwidmFsaWRGZWVkYmFja1wiIHYtaHRtbD1cInZhbGlkRmVlZGJhY2tcIiB2YWxpZCAvPlxuICAgICAgICAgICAgPGZvcm0tZmVlZGJhY2sgdi1pZj1cImludmFsaWRGZWVkYmFja1wiIHYtaHRtbD1cImludmFsaWRGZWVkYmFja1wiIGludmFsaWQgLz5cbiAgICAgICAgPC9zbG90PlxuXG4gICAgPC9mb3JtLWdyb3VwPlxuXG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuXG5pbXBvcnQgSGVscFRleHQgZnJvbSAnLi4vSGVscFRleHQnO1xuaW1wb3J0IEZvcm1Hcm91cCBmcm9tICcuLi9Gb3JtR3JvdXAnO1xuaW1wb3J0IEZvcm1MYWJlbCBmcm9tICcuLi9Gb3JtTGFiZWwnO1xuaW1wb3J0IEZvcm1GZWVkYmFjayBmcm9tICcuLi9Gb3JtRmVlZGJhY2snO1xuaW1wb3J0IENvbG9yYWJsZSBmcm9tICcuLi8uLi9NaXhpbnMvQ29sb3JhYmxlJztcbmltcG9ydCBGb3JtQ29udHJvbCBmcm9tICcuLi8uLi9NaXhpbnMvRm9ybUNvbnRyb2wnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAnaW5wdXQtZmllbGQnLFxuXG4gICAgbWl4aW5zOiBbXG4gICAgICAgIENvbG9yYWJsZSxcbiAgICAgICAgRm9ybUNvbnRyb2xcbiAgICBdLFxuXG4gICAgY29tcG9uZW50czoge1xuICAgICAgICBIZWxwVGV4dCxcbiAgICAgICAgRm9ybUdyb3VwLFxuICAgICAgICBGb3JtTGFiZWwsXG4gICAgICAgIEZvcm1GZWVkYmFja1xuICAgIH0sXG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdHlwZSBhdHRyaWJ1dGVcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJ3RleHQnXG4gICAgICAgIH1cblxuICAgIH1cblxufVxuXG48L3NjcmlwdD5cbiIsImltcG9ydCBJbnB1dEZpZWxkIGZyb20gJy4vSW5wdXRGaWVsZCc7XG5pbXBvcnQgVnVlSW5zdGFsbGVyIGZyb20gJy4uLy4uL0hlbHBlcnMvVnVlSW5zdGFsbGVyL1Z1ZUluc3RhbGxlcic7XG5cbmNvbnN0IHBsdWdpbiA9IFZ1ZUluc3RhbGxlci51c2Uoe1xuXG4gICAgaW5zdGFsbChWdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgVnVlSW5zdGFsbGVyLmNvbXBvbmVudHMoe1xuICAgICAgICAgICAgSW5wdXRGaWVsZFxuICAgICAgICB9KTtcbiAgICB9XG5cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBJbnB1dEZpZWxkO1xuIiwiPHRlbXBsYXRlPlxuXG4gICAgPGZvcm0tZ3JvdXA+XG5cbiAgICAgICAgPHNsb3QgbmFtZT1cImxhYmVsXCI+XG4gICAgICAgICAgICA8Zm9ybS1sYWJlbCB2LWlmPVwibGFiZWwgfHwgaGFzRGVmYXVsdFNsb3RcIiA6Zm9yPVwiaWRcIj5cbiAgICAgICAgICAgICAgICA8c2xvdD57e2xhYmVsfX08L3Nsb3Q+XG4gICAgICAgICAgICA8L2Zvcm0tbGFiZWw+XG4gICAgICAgIDwvc2xvdD5cblxuICAgICAgICA8ZGl2IGNsYXNzPVwiY3VzdG9tLWZpbGVcIj5cblxuICAgICAgICAgICAgPHNsb3QgbmFtZT1cInBsYWNlaG9sZGVyXCI+XG4gICAgICAgICAgICAgICAgPGZvcm0tbGFiZWwgOmNsYXNzPVwiJG1lcmdlQ2xhc3Nlcyhjb2xvcmFibGVDbGFzc2VzLCAnY3VzdG9tLWZpbGUtbGFiZWwnKVwiIDpmb3I9XCJpZFwiIHYtaHRtbD1cInBsYWNlaG9sZGVyIHx8ICdDaG9vc2UgZmlsZSdcIiAvPlxuICAgICAgICAgICAgPC9zbG90PlxuXG4gICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICB2LWJpbmQtZXZlbnRzXG4gICAgICAgICAgICAgICAgdHlwZT1cImZpbGVcIlxuICAgICAgICAgICAgICAgIDpjbGFzcz1cImNvbnRyb2xDbGFzc2VzXCJcbiAgICAgICAgICAgICAgICA6aWQ9XCJpZFwiXG4gICAgICAgICAgICAgICAgOndpZHRoPVwid2lkdGhcIlxuICAgICAgICAgICAgICAgIDpoZWlnaHQ9XCJoZWlnaHRcIlxuICAgICAgICAgICAgICAgIDpyZXF1aXJlZD1cInJlcXVpcmVkXCJcbiAgICAgICAgICAgICAgICA6bXVsdGlwbGU9XCJtdWx0aXBsZVwiXG4gICAgICAgICAgICAgICAgOnJlYWRvbmx5PVwicmVhZG9ubHlcIlxuICAgICAgICAgICAgICAgIEBjaGFuZ2U9XCJ1cGRhdGVkKCRldmVudC50YXJnZXQuZmlsZXMsICdjaGFuZ2UnKVwiPlxuXG4gICAgICAgICAgICA8c2xvdCBuYW1lPVwiaGVscFwiPlxuICAgICAgICAgICAgICAgIDxoZWxwLXRleHQgdi1pZj1cImhlbHBUZXh0XCIgdi1odG1sPVwiaGVscFRleHRcIiAvPlxuICAgICAgICAgICAgPC9zbG90PlxuXG4gICAgICAgICAgICA8c2xvdCBuYW1lPVwiZmVlZGJhY2tcIj5cbiAgICAgICAgICAgICAgICA8Zm9ybS1mZWVkYmFjayB2LWlmPVwidmFsaWRGZWVkYmFja1wiIHYtaHRtbD1cInZhbGlkRmVlZGJhY2tcIiB2YWxpZCAvPlxuICAgICAgICAgICAgICAgIDxmb3JtLWZlZWRiYWNrIHYtaWY9XCJpbnZhbGlkRmVlZGJhY2tcIiB2LWh0bWw9XCJpbnZhbGlkRmVlZGJhY2tcIiBpbnZhbGlkIC8+XG4gICAgICAgICAgICA8L3Nsb3Q+XG5cbiAgICAgICAgPC9kaXY+XG5cbiAgICA8L2Zvcm0tZ3JvdXA+XG5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgSGVscFRleHQgZnJvbSAnLi4vSGVscFRleHQnO1xuaW1wb3J0IEZvcm1Hcm91cCBmcm9tICcuLi9Gb3JtR3JvdXAnO1xuaW1wb3J0IEZvcm1MYWJlbCBmcm9tICcuLi9Gb3JtTGFiZWwnO1xuaW1wb3J0IEZvcm1GZWVkYmFjayBmcm9tICcuLi9Gb3JtRmVlZGJhY2snO1xuaW1wb3J0IElucHV0RmllbGQgZnJvbSAnLi4vSW5wdXRGaWVsZCc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdmaWxlLWZpZWxkJyxcblxuICAgIGV4dGVuZHM6IElucHV0RmllbGQsXG5cbiAgICBjb21wb25lbnRzOiB7XG4gICAgICAgIEhlbHBUZXh0LFxuICAgICAgICBGb3JtR3JvdXAsXG4gICAgICAgIEZvcm1MYWJlbCxcbiAgICAgICAgRm9ybUZlZWRiYWNrXG4gICAgfSxcblxuICAgIG1vZGVsOiB7XG4gICAgICAgIGV2ZW50OiAnY2hhbmdlJ1xuICAgIH0sXG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBhcnJheSBvZiBldmVudCBuYW1lcyB0aGF0IGNvcnJlbGF0ZSB3aXRoIGNhbGxiYWNrIGZ1bmN0aW9uc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgRnVuY3Rpb25cbiAgICAgICAgICovXG4gICAgICAgIGJpbmRFdmVudHM6IHtcbiAgICAgICAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgICAgICAgZGVmYXVsdCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWydmb2N1cycsICdibHVyJywgJ2lucHV0JywgJ2NsaWNrJywgJ2tleXVwJywgJ2tleWRvd24nLCAncHJvZ3Jlc3MnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNsYXNzIG5hbWUgYXNzaWduZWQgdG8gdGhlIGNvbnRyb2wgZWxlbWVudFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBkZWZhdWx0Q29udHJvbENsYXNzOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAnY3VzdG9tLWZpbGUtaW5wdXQnXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGFycmF5IG9mIHZhbGlkIGV4dGVuc2lvbnNcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgZXh0ZW5zaW9uczogQXJyYXksXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0eXBlIGF0dHJpYnV0ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBtdWx0aXBsZTogQm9vbGVhbixcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGhlaWdodCBhdHRyaWJ1dGUgZm9yIHRoZSBjb250cm9sIGVsZW1lbnRcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgaGVpZ2h0OiBbTnVtYmVyLCBTdHJpbmddLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgd2lkdGggYXR0cmlidXRlIGZvciB0aGUgY29udHJvbCBlbGVtZW50XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHdpZHRoOiBbTnVtYmVyLCBTdHJpbmddXG5cbiAgICB9XG5cbn1cblxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG5cbiAgICA8YnRuIGNsYXNzPVwiYnRuLWZpbGVcIiA6dHlwZT1cInR5cGVcIiA6dmFyaWFudD1cInZhcmlhbnRcIiA6YmxvY2s9XCJibG9ja1wiIDpzaXplPVwic2l6ZVwiIDpkaXNhYmxlZD1cImRpc2FibGVkXCIgOmFjdGl2ZT1cImFjdGl2ZVwiPlxuICAgICAgICA8c2xvdC8+XG5cbiAgICAgICAgPGlucHV0XG4gICAgICAgICAgICB2LWJpbmQtZXZlbnRzXG4gICAgICAgICAgICB0eXBlPVwiZmlsZVwiXG4gICAgICAgICAgICA6Y2xhc3M9XCJjb250cm9sQ2xhc3Nlc1wiXG4gICAgICAgICAgICA6aWQ9XCJpZFwiXG4gICAgICAgICAgICA6d2lkdGg9XCJ3aWR0aFwiXG4gICAgICAgICAgICA6aGVpZ2h0PVwiaGVpZ2h0XCJcbiAgICAgICAgICAgIDpyZXF1aXJlZD1cInJlcXVpcmVkXCJcbiAgICAgICAgICAgIDptdWx0aXBsZT1cIm11bHRpcGxlXCJcbiAgICAgICAgICAgIDpyZWFkb25seT1cInJlYWRvbmx5XCJcbiAgICAgICAgICAgIHYtb246Y2hhbmdlPVwidXBkYXRlZCgkZXZlbnQudGFyZ2V0LmZpbGVzLCAnY2hhbmdlJylcIj5cbiAgICA8L2J0bj5cblxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cblxuaW1wb3J0IEJ0biBmcm9tICcuLi9CdG4vQnRuJztcbmltcG9ydCBGaWxlRmllbGQgZnJvbSAnLi4vRmlsZUZpZWxkL0ZpbGVGaWVsZCc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdidG4tZmlsZScsXG5cbiAgICBtaXhpbnM6IFtcbiAgICAgICAgQnRuLFxuICAgICAgICBGaWxlRmllbGRcbiAgICBdLFxuXG4gICAgbW9kZWw6IHtcbiAgICAgICAgZXZlbnQ6ICdjaGFuZ2UnXG4gICAgfSxcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0eXBlIGF0dHJpYnV0ZSBmb3IgdGhlIGJ1dHRvbi4gTm90IGFwcGxpZWQgaWYgYW4gYW5jaG9yXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdidXR0b24nXG4gICAgICAgIH1cblxuICAgIH1cblxufVxuXG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJzY3NzXCI+XG4uYnRuLWZpbGUge1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG5cbiAgICBpbnB1dCB7XG4gICAgICAgIHotaW5kZXg6IDE7XG4gICAgICAgIG9wYWNpdHk6IDA7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgdG9wOiAwO1xuICAgICAgICBsZWZ0OiAwO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgIH1cbn1cbjwvc3R5bGU+XG4iLCJpbXBvcnQgQnRuRmlsZSBmcm9tICcuL0J0bkZpbGUnO1xuaW1wb3J0IFZ1ZUluc3RhbGxlciBmcm9tICcuLi8uLi9IZWxwZXJzL1Z1ZUluc3RhbGxlci9WdWVJbnN0YWxsZXInO1xuXG5jb25zdCBwbHVnaW4gPSBWdWVJbnN0YWxsZXIudXNlKHtcblxuICAgIGluc3RhbGwoVnVlLCBvcHRpb25zKSB7XG4gICAgICAgIFZ1ZUluc3RhbGxlci5jb21wb25lbnRzKHtcbiAgICAgICAgICAgIEJ0bkZpbGVcbiAgICAgICAgfSk7XG4gICAgfVxuXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgQnRuRmlsZTtcbiIsIjx0ZW1wbGF0ZT5cbiAgICA8ZGl2IDpjbGFzcz1cImNsYXNzZXNcIiA6ZGF0YS10b2dnbGU9XCJ0b2dnbGUgPyAnYnV0dG9ucycgOiBmYWxzZVwiIHJvbGU9XCJncm91cFwiPlxuICAgICAgICA8YnRuIHYtaWY9XCJidXR0b25zXCIgdi1mb3I9XCIoYnV0dG9uLCBpKSBpbiBidXR0b25zXCIgOmtleT1cImlcIiB2LWJpbmQ9XCJidXR0b25cIiAvPlxuICAgICAgICA8c2xvdC8+XG4gICAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IEJ0biBmcm9tICcuLi9CdG4nO1xuaW1wb3J0IENvbG9yYWJsZSBmcm9tICcuLi8uLi9NaXhpbnMvQ29sb3JhYmxlL0NvbG9yYWJsZSc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdidG4tZ3JvdXAnLFxuXG4gICAgY29tcG9uZW50czoge1xuICAgICAgICBCdG5cbiAgICB9LFxuXG4gICAgbWl4aW5zOiBbXG4gICAgICAgIENvbG9yYWJsZVxuICAgIF0sXG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBhcnJheSBvZiBidXR0b25zXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgICAgICovXG4gICAgICAgIGJ1dHRvbnM6IEFycmF5LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZW5vdGUgdGhlIGJ1dHRvbiBncm91cCBhcyB0b2dnbGUgYnV0dG9uc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRvZ2dsZTogQm9vbGVhbixcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzcGxheSB0aGUgYnV0dG9ucyB2ZXJ0aWNhbGx5XG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdmVydGljYWw6IEJvb2xlYW5cblxuICAgIH0sXG5cbiAgICBjb21wdXRlZDoge1xuXG4gICAgICAgIGNsYXNzZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kbWVyZ2VDbGFzc2VzKFxuICAgICAgICAgICAgICAgIHRoaXMuY29sb3JhYmxlQ2xhc3Nlcywge1xuICAgICAgICAgICAgICAgICAgICAnYnRuLWdyb3VwJzogIXRoaXMudmVydGljYWwsXG4gICAgICAgICAgICAgICAgICAgICdidG4tZ3JvdXAtdG9nZ2xlJzogdGhpcy50b2dnbGUsXG4gICAgICAgICAgICAgICAgICAgICdidG4tZ3JvdXAtdmVydGljYWwnOiB0aGlzLnZlcnRpY2FsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgICA8ZGl2IGNsYXNzPVwiYnRuLWdyb3VwLXRvZ2dsZVwiIGRhdGEtdG9nZ2xlPVwiYnV0dG9uc1wiPlxuICAgICAgICA8c2xvdC8+XG4gICAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ2J0bi1ncm91cC10b2dnbGUnXG5cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICAgIDxkaXYgY2xhc3M9XCJidG4tdG9vbGJhclwiIHJvbGU9XCJ0b29sYmFyXCI+XG4gICAgICAgIDxzbG90Lz5cbiAgICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAnYnRuLXRvb2xiYXInXG5cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IEJ0bkdyb3VwIGZyb20gJy4vQnRuR3JvdXAnO1xuaW1wb3J0IEJ0bkdyb3VwVG9nZ2xlIGZyb20gJy4vQnRuR3JvdXBUb2dnbGUnO1xuaW1wb3J0IEJ0blRvb2xiYXIgZnJvbSAnLi9CdG5Ub29sYmFyJztcbmltcG9ydCBWdWVJbnN0YWxsZXIgZnJvbSAnLi4vLi4vSGVscGVycy9WdWVJbnN0YWxsZXIvVnVlSW5zdGFsbGVyJztcblxuY29uc3QgcGx1Z2luID0gVnVlSW5zdGFsbGVyLnVzZSh7XG5cbiAgICBpbnN0YWxsKFZ1ZSwgb3B0aW9ucykge1xuICAgICAgICBWdWVJbnN0YWxsZXIuY29tcG9uZW50cyh7XG4gICAgICAgICAgICBCdG5Hcm91cCxcbiAgICAgICAgICAgIEJ0bkdyb3VwVG9nZ2xlLFxuICAgICAgICAgICAgQnRuVG9vbGJhclxuICAgICAgICB9KTtcbiAgICB9XG5cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBCdG5Hcm91cDtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHV1aWQoKSB7XG4gICAgcmV0dXJuICd4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZywgYyA9PiB7XG4gICAgICAgIHZhciByID0gTWF0aC5yYW5kb20oKSAqIDE2IHwgMCwgdiA9IGMgPT0gJ3gnID8gciA6IChyICYgMHgzIHwgMHg4KTtcbiAgICAgICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuICAgIH0pO1xufVxuIiwiaW1wb3J0IHsgaXNGdW5jdGlvbiB9IGZyb20gJ2xvZGFzaC1lcyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgcHJveHkoY2FsbGJhY2ssIGV2ZW50KSB7XG4gICAgICAgICAgICBpZihpc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHRoaXMsIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5zcGxpY2UoMSkpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbn1cbiIsIjx0ZW1wbGF0ZT5cbiAgICA8Y29tcG9uZW50XG4gICAgICAgIDppcz1cImNvbXBvbmVudFwiXG4gICAgICAgIDpocmVmPVwiaHJlZiB8fCAoY29tcG9uZW50ID09PSAnYScgPyAnIycgOiBmYWxzZSlcIlxuICAgICAgICBjbGFzcz1cImRyb3Bkb3duLWl0ZW1cIlxuICAgICAgICA6Y2xhc3M9XCJ7J2FjdGl2ZSc6IGFjdGl2ZX1cIlxuICAgICAgICA6dHlwZT1cImNvbXBvbmVudCA9PT0gJ2J1dHRvbicgPyAnYnV0dG9uJyA6IGZhbHNlXCJcbiAgICAgICAgQGNsaWNrPVwib25DbGlja1wiPlxuICAgICAgICA8aSB2LWlmPVwiaWNvblwiIDpjbGFzcz1cImljb25cIi8+XG4gICAgICAgIDxzbG90Pnt7bGFiZWx9fTwvc2xvdD5cbiAgICA8L2NvbXBvbmVudD5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgeyBpc0Z1bmN0aW9uIH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCBQcm94eSBmcm9tICcuLi8uLi9NaXhpbnMvUHJveHkvUHJveHknO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBtaXhpbnM6IFtQcm94eV0sXG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJcyB0aGUgbWVudSBpdGVtIGFjdGl2ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IE9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgYWN0aXZlOiBCb29sZWFuLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJcyB0aGUgbWVudSBpdGVtIGEgYnV0dG9uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBPYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIGJ1dHRvbjogQm9vbGVhbixcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGBlbGVtZW50YCBhdHRyaWJ1dGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBPYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIGVsZW1lbnQ6IFN0cmluZyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGBocmVmYCBhdHRyaWJ1dGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBPYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIGhyZWY6IFN0cmluZyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGljb24gb2YgdGhlIGRyb3Bkb3duIG1lbnUgaXRlbS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IE9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgaWNvbjogU3RyaW5nLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbGFiZWwgb2YgdGhlIGRyb3Bkb3duIG1lbnUgaXRlbS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IE9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgbGFiZWw6IFN0cmluZ1xuXG4gICAgfSxcblxuICAgIGNvbXB1dGVkOiB7XG5cbiAgICAgICAgY29tcG9uZW50KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudCB8fCAodGhpcy5idXR0b24gPyAnYnV0dG9uJyA6ICdhJyk7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBtZXRob2RzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIHRoZSBgY2xpY2tgIGV2ZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgT2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBvbkNsaWNrKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCdjbGljaycsIGV2ZW50LCB0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG59XG5cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICAgIDxoNSBjbGFzcz1cImRyb3Bkb3duLWhlYWRlclwiPlxuICAgICAgICA8c2xvdD57e2hlYWRlcn19PC9zbG90PlxuICAgIDwvaDU+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAnZHJvcGRvd24tbWVudS1oZWFkZXInLFxuXG4gICAgcHJvcHM6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHZhbHVlIG9mIHRoZSBoZWFkZXJcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IE9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgaGVhZGVyOiBTdHJpbmdcblxuICAgIH1cblxufVxuXG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgICA8ZGl2IGNsYXNzPVwiZHJvcGRvd24tZGl2aWRlclwiPjwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ2Ryb3Bkb3duLW1lbnUtZGl2aWRlcidcblxufVxuXG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgICA8ZGl2IGNsYXNzPVwiZHJvcGRvd24tbWVudVwiIDpjbGFzcz1cInsnZHJvcGRvd24tbWVudS1yaWdodCc6IGFsaWduID09PSAncmlnaHQnLCAnc2hvdyc6IHNob3d9XCIgOmFyaWEtbGFiZWxsZWRieT1cImlkXCIgdGFiaW5kZXg9XCItMVwiIEBjbGljaz1cIm9uQ2xpY2tcIj5cbiAgICAgICAgPHRlbXBsYXRlIHYtZm9yPVwiaXRlbSBpbiBpdGVtc1wiPlxuICAgICAgICAgICAgPGNvbXBvbmVudCA6aXM9XCJwcmVmaXgoaXRlbS50eXBlIHx8ICdpdGVtJywgJ2Ryb3Bkb3duLW1lbnUnKVwiIHYtYmluZD1cIml0ZW1cIi8+XG4gICAgICAgIDwvdGVtcGxhdGU+XG4gICAgICAgIDxzbG90Lz5cbiAgICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgeyBlYWNoIH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCB1dWlkIGZyb20gJy4uLy4uL0hlbHBlcnMvVXVpZC9VdWlkJztcbmltcG9ydCBwcmVmaXggZnJvbSAnLi4vLi4vSGVscGVycy9QcmVmaXgvUHJlZml4JztcbmltcG9ydCBEcm9wZG93bk1lbnVJdGVtIGZyb20gJy4vRHJvcGRvd25NZW51SXRlbSc7XG5pbXBvcnQgRHJvcGRvd25NZW51SGVhZGVyIGZyb20gJy4vRHJvcGRvd25NZW51SGVhZGVyJztcbmltcG9ydCBEcm9wZG93bk1lbnVEaXZpZGVyIGZyb20gJy4vRHJvcGRvd25NZW51RGl2aWRlcic7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgICAgRHJvcGRvd25NZW51SXRlbSxcbiAgICAgICAgRHJvcGRvd25NZW51SGVhZGVyLFxuICAgICAgICBEcm9wZG93bk1lbnVEaXZpZGVyXG4gICAgfSxcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBgaWRgIGF0dHJpYnV0ZSBvbiB0aGUgdG9nZ2xlIGJ1dHRvbiBhbmQgYXJpYSBsYWJlbC4gSWYgbm8gYGlkYCBpc1xuICAgICAgICAgKiBkZWZpbmVkLCB0aGVuIGEgVVVJRCB3aWxsIGJlIGdlbmVyYXRlZCBpbnN0ZWFkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgT2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBpZDoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogdXVpZFxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwbGF5IHRoZSBkcm9wZG93biBtZW51IGFsaWduZWQgbGVmdCBvciByaWdodFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBhbGlnbjoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJ2xlZnQnLFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZih2YWx1ZS50b0xvd2VyQ2FzZSgpKSAhPT0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkZWZhdWx0IHZpc2liaWxpdHkgb2YgdGhlIGRyb3Bkb3duIG1lbnUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBPYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIHNob3c6IEJvb2xlYW4sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGFycmF5IG9mIGRyb3Bkb3duIGl0ZW1zLiBJZiBhbiBrZXkvdmFsdWUgcGFpciBpc24ndCBkZWZpbmVkLCB0aGVcbiAgICAgICAgICogZGVmYXVsdCB2YWx1ZSB3aWxsIGJlIHVzZWQuIElmIG5vIGl0ZW1zIGFyZSBkZWZpbmVkLCB0aGVuIHRoZSBzbG90XG4gICAgICAgICAqIG5hbWVkIFwiaXRlbXNcIiBjYW4gYmUgdXNlZCB0byBkZWZpbmUgdGhlIG9wdGlvbnMgd2l0aCBIVE1MLlxuICAgICAgICAgKlxuICAgICAgICAgKiBbe1xuICAgICAgICAgKiAgICAgIHR5cGU6ICdpdGVtJywgLy8gU3RyaW5nIFtpdGVtfGhlYWRlcnxkaXZpZGVyXVxuICAgICAgICAgKiAgICAgIGhyZWY6ICcjJywgLy8gU3RyaW5nXG4gICAgICAgICAqICAgICAgbGFiZWw6ICdTb21lIGxhYmVsJywgLy8gU3RyaW5nXG4gICAgICAgICAqICAgICAgb25DbGljazogKGV2ZW50KSA9PiB7fSAvLyBGdW5jdGlvblxuICAgICAgICAgKiB9XVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgQXJyYXlcbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1zOiBBcnJheVxuXG4gICAgfSxcblxuICAgIG1ldGhvZHM6IHtcblxuICAgICAgICBwcmVmaXg6IHByZWZpeCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBjYWxsYmFjayBmdW5jdGlvbiBmb3IgdGhlIGBjbGlja2AgZXZlbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBPYmplY3QgZXZlbnRcbiAgICAgICAgICogQHBhcmFtIE9iamVjdCBpdGVtXG4gICAgICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAgICAgKi9cbiAgICAgICAgb25DbGljayhldmVudCkge1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgnY2xpY2snLCBldmVudCwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIHRoZSBgY2xpY2tgIGV2ZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gT2JqZWN0IGV2ZW50XG4gICAgICAgICAqIEBwYXJhbSBPYmplY3QgaXRlbVxuICAgICAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgICAgICovXG4gICAgICAgIG9uSXRlbUNsaWNrKGV2ZW50LCBpdGVtKSB7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCdpdGVtOmNsaWNrJywgZXZlbnQsIGl0ZW0pO1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgbW91bnRlZCgpIHtcbiAgICAgICAgZWFjaCh0aGlzLiRjaGlsZHJlbiwgY2hpbGQgPT4ge1xuICAgICAgICAgICAgY2hpbGQuJG9uKCdjbGljaycsIGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uSXRlbUNsaWNrKGV2ZW50LCBjaGlsZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG59XG5cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IERyb3Bkb3duTWVudSBmcm9tICcuL0Ryb3Bkb3duTWVudSc7XG5pbXBvcnQgRHJvcGRvd25NZW51RGl2aWRlciBmcm9tICcuL0Ryb3Bkb3duTWVudURpdmlkZXInO1xuaW1wb3J0IERyb3Bkb3duTWVudUhlYWRlciBmcm9tICcuL0Ryb3Bkb3duTWVudUhlYWRlcic7XG5pbXBvcnQgRHJvcGRvd25NZW51SXRlbSBmcm9tICcuL0Ryb3Bkb3duTWVudUl0ZW0nO1xuaW1wb3J0IFZ1ZUluc3RhbGxlciBmcm9tICcuLi8uLi9IZWxwZXJzL1Z1ZUluc3RhbGxlci9WdWVJbnN0YWxsZXInO1xuXG5jb25zdCBwbHVnaW4gPSBWdWVJbnN0YWxsZXIudXNlKHtcblxuICAgIGluc3RhbGwoVnVlLCBvcHRpb25zKSB7XG4gICAgICAgIFZ1ZUluc3RhbGxlci5jb21wb25lbnRzKHtcbiAgICAgICAgICAgIERyb3Bkb3duTWVudSxcbiAgICAgICAgICAgIERyb3Bkb3duTWVudURpdmlkZXIsXG4gICAgICAgICAgICBEcm9wZG93bk1lbnVIZWFkZXIsXG4gICAgICAgICAgICBEcm9wZG93bk1lbnVJdGVtXG4gICAgICAgIH0pO1xuICAgIH1cblxufSk7XG5cbmV4cG9ydCAqIGZyb20gJy4vRHJvcGRvd25NZW51RGl2aWRlcic7XG5leHBvcnQgKiBmcm9tICcuL0Ryb3Bkb3duTWVudUhlYWRlcic7XG5leHBvcnQgKiBmcm9tICcuL0Ryb3Bkb3duTWVudUl0ZW0nO1xuZXhwb3J0IGRlZmF1bHQgRHJvcGRvd25NZW51O1xuIiwiPHRlbXBsYXRlPlxuXG4gICAgPGJ0bi1ncm91cCB2LWlmPVwic3BsaXRcIj5cbiAgICAgICAgPHRlbXBsYXRlIHYtaWY9XCIhZHJvcGxlZnRcIj5cbiAgICAgICAgICAgIDxhIHYtaWY9XCJocmVmXCIgOmhyZWY9XCJocmVmXCIgOmNsYXNzPVwiYWN0aW9uQ2xhc3Nlc1wiIEBjbGljaz1cIm9uQ2xpY2tcIj5cbiAgICAgICAgICAgICAgICA8c2xvdCBuYW1lPVwibGFiZWxcIj48aSB2LWlmPVwiaWNvblwiIDpjbGFzcz1cImljb25cIj48L2k+IHt7bGFiZWx9fTwvc2xvdD5cbiAgICAgICAgICAgIDwvYT5cbiAgICAgICAgICAgIDxidXR0b24gdi1lbHNlIDp0eXBlPVwidHlwZVwiIDpjbGFzcz1cImFjdGlvbkNsYXNzZXNcIiBAY2xpY2s9XCJvbkNsaWNrXCI+XG4gICAgICAgICAgICAgICAgPHNsb3QgbmFtZT1cImxhYmVsLXdyYXBwZXJcIj48aSB2LWlmPVwiaWNvblwiIDpjbGFzcz1cImljb25cIj48L2k+IDxzbG90IG5hbWU9XCJsYWJlbFwiPnt7bGFiZWx9fTwvc2xvdD48L3Nsb3Q+XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPC90ZW1wbGF0ZT5cbiAgICAgICAgPGJ0bi1ncm91cCA6Y2xhc3M9XCJ7J2Ryb3B1cCc6IGRyb3B1cCwgJ2Ryb3ByaWdodCc6IGRyb3ByaWdodCwgJ2Ryb3BsZWZ0JzogZHJvcGxlZnR9XCI+XG4gICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBhcmlhLWhhc3BvcHVwPVwidHJ1ZVwiIDphcmlhLWV4cGFuZGVkPVwiaXNEcm9wZG93blNob3dpbmdcIiA6aWQ9XCJpZFwiIDpjbGFzcz1cInRvZ2dsZUNsYXNzZXNcIiBAY2xpY2sucHJldmVudD1cIiFpc0Ryb3Bkb3duU2hvd2luZyA/IHNob3coKSA6IGhpZGUoKVwiIEBibHVyPVwib25CbHVyXCI+PC9idXR0b24+XG4gICAgICAgICAgICA8ZHJvcGRvd24tbWVudVxuICAgICAgICAgICAgICAgIDppZD1cImlkXCJcbiAgICAgICAgICAgICAgICA6YWxpZ249XCJhbGlnblwiXG4gICAgICAgICAgICAgICAgOnNob3cuc3luYz1cImlzRHJvcGRvd25TaG93aW5nXCJcbiAgICAgICAgICAgICAgICBAY2xpY2s9XCJvbk1lbnVDbGlja1wiXG4gICAgICAgICAgICAgICAgQGl0ZW06Y2xpY2s9XCJvbkl0ZW1DbGlja1wiPlxuICAgICAgICAgICAgICAgIDxzbG90Lz5cbiAgICAgICAgICAgIDwvZHJvcGRvd24tbWVudT5cbiAgICAgICAgPC9idG4tZ3JvdXA+XG4gICAgICAgIDx0ZW1wbGF0ZSB2LWlmPVwiZHJvcGxlZnRcIj5cbiAgICAgICAgICAgIDxhIHYtaWY9XCJocmVmXCIgOmhyZWY9XCJocmVmXCIgOmNsYXNzPVwiYWN0aW9uQ2xhc3Nlc1wiIEBjbGljaz1cIm9uQ2xpY2tcIj5cbiAgICAgICAgICAgICAgICA8c2xvdCBuYW1lPVwibGFiZWxcIj48aSB2LWlmPVwiaWNvblwiIDpjbGFzcz1cImljb25cIj48L2k+IHt7bGFiZWx9fTwvc2xvdD5cbiAgICAgICAgICAgIDwvYT5cbiAgICAgICAgICAgIDxidXR0b24gdi1lbHNlIDp0eXBlPVwidHlwZVwiIDpjbGFzcz1cImFjdGlvbkNsYXNzZXNcIiBAY2xpY2s9XCJvbkNsaWNrXCI+XG4gICAgICAgICAgICAgICAgPHNsb3QgbmFtZT1cImxhYmVsLXdyYXBwZXJcIj48aSB2LWlmPVwiaWNvblwiIDpjbGFzcz1cImljb25cIj48L2k+IDxzbG90IG5hbWU9XCJsYWJlbFwiPnt7bGFiZWx9fTwvc2xvdD48L3Nsb3Q+XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPC90ZW1wbGF0ZT5cbiAgICA8L2J0bi1ncm91cD5cblxuICAgIDxidG4tZ3JvdXAgdi1lbHNlIDpjbGFzcz1cInsnZHJvcHVwJzogZHJvcHVwLCAnZHJvcHJpZ2h0JzogZHJvcHJpZ2h0LCAnZHJvcGxlZnQnOiBkcm9wbGVmdH1cIiBAY2xpY2s9XCJvbkNsaWNrXCI+XG4gICAgICAgIDxidXR0b24gYXJpYS1oYXNwb3B1cD1cInRydWVcIiA6YXJpYS1leHBhbmRlZD1cImlzRHJvcGRvd25TaG93aW5nXCIgOnR5cGU9XCJ0eXBlXCIgOmlkPVwiaWRcIiA6Y2xhc3M9XCJ0b2dnbGVDbGFzc2VzXCIgQGNsaWNrLnByZXZlbnQ9XCIhaXNEcm9wZG93blNob3dpbmcgPyBzaG93KCkgOiBoaWRlKClcIiBAYmx1cj1cIm9uQmx1clwiPlxuICAgICAgICAgICAgPHNsb3QgbmFtZT1cImxhYmVsXCI+PGkgdi1pZj1cImljb25cIiA6Y2xhc3M9XCJpY29uXCI+PC9pPiB7e2xhYmVsfX08L3Nsb3Q+XG4gICAgICAgIDwvYnV0dG9uPlxuXG4gICAgICAgIDxkcm9wZG93bi1tZW51XG4gICAgICAgICAgICA6aWQ9XCJpZFwiXG4gICAgICAgICAgICA6YWxpZ249XCJhbGlnblwiXG4gICAgICAgICAgICA6c2hvdy5zeW5jPVwiaXNEcm9wZG93blNob3dpbmdcIlxuICAgICAgICAgICAgQGNsaWNrPVwib25NZW51Q2xpY2tcIlxuICAgICAgICAgICAgQGl0ZW06Y2xpY2s9XCJvbkl0ZW1DbGlja1wiPlxuICAgICAgICAgICAgPHNsb3QvPlxuICAgICAgICA8L2Ryb3Bkb3duLW1lbnU+XG4gICAgPC9idG4tZ3JvdXA+XG5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5cbmltcG9ydCB7IGVhY2ggfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IHV1aWQgZnJvbSAnLi4vLi4vSGVscGVycy9VdWlkL1V1aWQnO1xuaW1wb3J0IHByZWZpeCBmcm9tICcuLi8uLi9IZWxwZXJzL1ByZWZpeC9QcmVmaXgnO1xuaW1wb3J0IEJ0biBmcm9tICcuLi9CdG4nO1xuaW1wb3J0IEJ0bkdyb3VwIGZyb20gJy4uL0J0bkdyb3VwJztcbmltcG9ydCBEcm9wZG93bk1lbnUgZnJvbSAnLi4vRHJvcGRvd25NZW51JztcbmltcG9ydCBQb3BwZXIgZnJvbSAncG9wcGVyLmpzJztcblxuY29uc3QgVEFCX0tFWUNPREUgPSA5O1xuY29uc3QgTEVGVF9BUlJPV19LRVlDT0RFID0gMzc7XG5jb25zdCBSSUdIVF9BUlJPV19LRVlDT0RFID0gMzk7XG5jb25zdCBVUF9BUlJPV19LRVlDT0RFID0gMzg7XG5jb25zdCBET1dOX0FSUk9XX0tFWUNPREUgPSA0MDtcblxubGV0IGlnbm9yZUJsdXJFdmVudCA9IGZhbHNlO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAnYnRuLWRyb3Bkb3duJyxcblxuICAgIGV4dGVuZHM6IEJ0bixcblxuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgICAgQnRuR3JvdXAsXG4gICAgICAgIERyb3Bkb3duTWVudVxuICAgIH0sXG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYnV0dG9uIGljb24gdGhhdCBhcHBlYXJzIGJlZm9yZSB0aGUgbGFiZWwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGF1dG9jbG9zZTogQm9vbGVhbixcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGJ1dHRvbiBpY29uIHRoYXQgYXBwZWFycyBiZWZvcmUgdGhlIGxhYmVsLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBpY29uOiBTdHJpbmcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0b2dnbGUgYnV0dG9uJ3MgbGFiZWwuIElmIG5vdCBkZWZpbmVkIGFzIGFuIGF0dHJpYnV0ZSxcbiAgICAgICAgICogeW91IGNhbiBvdmVycmlkZSB3aXRoIHRoZSBjb21wb25lbnQncyBzbG90IChpbm5lciBodG1sKS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgbGFiZWw6IFN0cmluZyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGBpZGAgYXR0cmlidXRlIG9uIHRoZSB0b2dnbGUgYnV0dG9uIGFuZCBhcmlhIGxhYmVsLiBJZiBubyBgaWRgIGlzXG4gICAgICAgICAqIGRlZmluZWQsIHRoZW4gYSBVVUlEIHdpbGwgYmUgZ2VuZXJhdGVkIGluc3RlYWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGlkOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiB1dWlkXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBidXR0b24gdHlwZSBhdHRyaWJ1dGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdidXR0b24nXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc3BsYXkgdGhlIGRyb3Bkb3duIG1lbnUgYWxpZ25lZCBsZWZ0IG9yIHJpZ2h0XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGFsaWduOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAnbGVmdCcsXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbJ2xlZnQnLCAncmlnaHQnXS5pbmRleE9mKHZhbHVlLnRvTG93ZXJDYXNlKCkpICE9PSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzcGxheSB0aGUgZHJvcGRvd24gYnV0dG9uIHdpdGggYSBzcGxpdCB0b2dnbGUgYnV0dG9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgQm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgc3BsaXQ6IHtcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwbGF5IGFzIGEgZHJvcHVwIGluc3RlYWQgb2YgYSBkcm9wZG93bi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IEJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIGRyb3B1cDoge1xuICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc3BsYXkgYXMgYSBkcm9wcmlnaHQgaW5zdGVhZCBvZiBhIGRyb3Bkb3duLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgQm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgZHJvcHJpZ2h0OiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzcGxheSBhcyBhIGRyb3BsZWZ0IGluc3RlYWQgb2YgYSBkcm9wZG93bi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IEJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIGRyb3BsZWZ0OiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIG1ldGhvZHM6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRm9jdXMgb24gdGhlIHRoZSBkcm9wZG93biB0b2dnbGUgYnV0dG9uXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAgICAgKi9cbiAgICAgICAgZm9jdXMoKSB7XG4gICAgICAgICAgICB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yKCcuZHJvcGRvd24tdG9nZ2xlJykuZm9jdXMoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRm9jdXMgb24gdGhlIHRoZSBkcm9wZG93biB0b2dnbGUgYnV0dG9uXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAgICAgKi9cbiAgICAgICAgcXVlcnlGb2N1c2FibGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kZWwucXVlcnlTZWxlY3RvcignLmRyb3Bkb3duLW1lbnUnKS5xdWVyeVNlbGVjdG9yQWxsKCdsYWJlbCwgaW5wdXQsIHNlbGVjdCwgdGV4dGFyZWEsIFt0YWJpbmRleF06bm90KFt0YWJpbmRleD1cIi0xXCJdKScpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXRob2QgdG8gY2hlY2sgaWYgdGhlIGdpdmVuIGVsZW1lbnQgaXMgZm9jdXNhYmxlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgICAgICovXG4gICAgICAgIGlzRm9jdXNhYmxlKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVzID0gdGhpcy5xdWVyeUZvY3VzYWJsZSgpO1xuXG4gICAgICAgICAgICBmb3IobGV0IGkgaW4gbm9kZXMpIHtcbiAgICAgICAgICAgICAgICBpZihlbGVtZW50ID09PSBub2Rlc1tpXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVG9nZ2xlIHRoZSBkcm9wZG93biBtZW51XG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAgICAgKi9cbiAgICAgICAgdG9nZ2xlKCkge1xuICAgICAgICAgICAgIXRoaXMuaXNEcm9wZG93blNob3dpbmcgPyB0aGlzLnNob3coKSA6IHRoaXMuaGlkZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG93IHRoZSBkcm9wZG93biBtZW51XG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAgICAgKi9cbiAgICAgICAgc2hvdygpIHtcbiAgICAgICAgICAgIHRoaXMuaXNEcm9wZG93blNob3dpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICB0aGlzLiRuZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHNpZGUgPSAnYm90dG9tJztcblxuICAgICAgICAgICAgICAgIGlmKHRoaXMuZHJvcHVwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpZGUgPSAndG9wJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmKHRoaXMuZHJvcGxlZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2lkZSA9ICdsZWZ0J1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmKHRoaXMuZHJvcHJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHNpZGUgPSAncmlnaHQnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IG1lbnUgPSB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yKCcuZHJvcGRvd24tbWVudScpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvZ2dsZSA9IHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3IoJy5kcm9wZG93bi10b2dnbGUnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwb3NpdGlvbiA9IFtzaWRlLCB0aGlzLmFsaWduID09PSAnbGVmdCcgPyAnc3RhcnQnIDogJ2VuZCddO1xuXG4gICAgICAgICAgICAgICAgbmV3IFBvcHBlcih0b2dnbGUsIG1lbnUsIHtcbiAgICAgICAgICAgICAgICAgICAgcGxhY2VtZW50OiBwb3NpdGlvbi5qb2luKCctJylcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmKHRoaXMucXVlcnlGb2N1c2FibGUoKS5pdGVtKDApKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0LCBzZWxlY3QsIHRleHRhcmVhJykuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdzaG93Jyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSGlkZSB0aGUgZHJvcGRvd24gbWVudVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgICAgICovXG4gICAgICAgIGhpZGUoKSB7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCd0b2dnbGUnLCB0aGlzLmlzRHJvcGRvd25TaG93aW5nID0gZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgnaGlkZScpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGNhbGxiYWNrIGZ1bmN0aW9uIGZvciB0aGUgYGNsaWNrYCBldmVudCBmb3IgdGhlIGFjdGlvbiBidXR0b25cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB2b2lkXG4gICAgICAgICAqL1xuICAgICAgICBvbkNsaWNrKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2NsaWNrJywgZXZlbnQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGNhbGxiYWNrIGZ1bmN0aW9uIGZvciB0aGUgYGJsdXJgIGV2ZW50IGZvciB0aGUgYWN0aW9uIGJ1dHRvblxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgICAgICovXG4gICAgICAgIG9uQmx1cihldmVudCkge1xuICAgICAgICAgICAgaWYoIXRoaXMuJGVsLmNvbnRhaW5zKGV2ZW50LnJlbGF0ZWRUYXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIHRoZSBgaXRlbTpjbGlja2AgZXZlbnQgZm9yIHRoZSBhY3Rpb24gYnV0dG9uXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAgICAgKi9cbiAgICAgICAgb25NZW51Q2xpY2soZXZlbnQsIGl0ZW0pIHtcbiAgICAgICAgICAgIGlmKGV2ZW50LnRhcmdldCA9PT0gdGhpcy4kZWwucXVlcnlTZWxlY3RvcignLmRyb3Bkb3duLW1lbnUnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBjYWxsYmFjayBmdW5jdGlvbiBmb3IgdGhlIGBpdGVtOmNsaWNrYCBldmVudCBmb3IgdGhlIGFjdGlvbiBidXR0b25cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB2b2lkXG4gICAgICAgICAqL1xuICAgICAgICBvbkl0ZW1DbGljayhldmVudCwgaXRlbSkge1xuICAgICAgICAgICAgaWYoIXRoaXMuaXNGb2N1c2FibGUoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLiRlbWl0KCdpdGVtOmNsaWNrJywgZXZlbnQsIGl0ZW0pO1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgY29tcHV0ZWQ6IHtcblxuICAgICAgICB2YXJpYW50Q2xhc3NQcmVmaXgoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2J0bicgKyAodGhpcy5vdXRsaW5lID8gJy1vdXRsaW5lJyA6ICcnKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzaXplYWJsZUNsYXNzUHJlZml4KCkge1xuICAgICAgICAgICAgcmV0dXJuICdidG4nO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFjdGlvbkNsYXNzZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICdidG4nLFxuICAgICAgICAgICAgICAgIHByZWZpeCh0aGlzLnNpemUsICdidG4nKSxcbiAgICAgICAgICAgICAgICBwcmVmaXgodGhpcy52YXJpYW50LCAnYnRuJylcbiAgICAgICAgICAgIF0uam9pbignICcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRvZ2dsZUNsYXNzZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICdidG4nLFxuICAgICAgICAgICAgICAgICdkcm9wZG93bi10b2dnbGUnLFxuICAgICAgICAgICAgICAgIHRoaXMudmFyaWFudENsYXNzLFxuICAgICAgICAgICAgICAgIHRoaXMuc2l6ZWFibGVDbGFzcyxcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZSA/ICdhY3RpdmUnIDogJycsXG4gICAgICAgICAgICAgICAgdGhpcy5ibG9jayA/ICdidG4tYmxvY2snIDogJycsXG4gICAgICAgICAgICAgICAgKHRoaXMuc3BsaXQgPyAnZHJvcGRvd24tdG9nZ2xlLXNwbGl0JyA6ICcnKSxcbiAgICAgICAgICAgIF0uam9pbignICcpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpc0Ryb3Bkb3duU2hvd2luZzogZmFsc2VcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgbW91bnRlZCgpIHtcbiAgICAgICAgZWFjaCh0aGlzLiRlbC5xdWVyeVNlbGVjdG9yQWxsKCdbdHlwZT1zdWJtaXRdLCBpbnB1dCwgc2VsZWN0LCB0ZXh0YXJlYSwgW3RhYmluZGV4XTpub3QoW3RhYmluZGV4PVwiLTFcIl0nKSwgZWwgPT4ge1xuICAgICAgICAgICAgY29uc3Qga2V5ZG93biA9IGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpZ25vcmUgPSBbXG4gICAgICAgICAgICAgICAgICAgIExFRlRfQVJST1dfS0VZQ09ERSxcbiAgICAgICAgICAgICAgICAgICAgUklHSFRfQVJST1dfS0VZQ09ERSxcbiAgICAgICAgICAgICAgICAgICAgVVBfQVJST1dfS0VZQ09ERSxcbiAgICAgICAgICAgICAgICAgICAgRE9XTl9BUlJPV19LRVlDT0RFLFxuICAgICAgICAgICAgICAgICAgICBUQUJfS0VZQ09ERVxuICAgICAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgICAgICBpZihpZ25vcmUuaW5kZXhPZihldmVudC5rZXlDb2RlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWdub3JlQmx1ckV2ZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBjb25zdCBibHVyID0gZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgIGlmKCFpZ25vcmVCbHVyRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mb2N1cygpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlnbm9yZUJsdXJFdmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY29uc3QgZm9jdXMgPSBldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgaWdub3JlQmx1ckV2ZW50ID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBjb25zdCBtb3VzZWRvd24gPSBldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgaWdub3JlQmx1ckV2ZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBibHVyKTtcbiAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgZm9jdXMpO1xuICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGtleWRvd24pO1xuICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgbW91c2Vkb3duKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG59XG5cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IEJ0bkRyb3Bkb3duIGZyb20gJy4vQnRuRHJvcGRvd24nO1xuaW1wb3J0IFZ1ZUluc3RhbGxlciBmcm9tICcuLi8uLi9IZWxwZXJzL1Z1ZUluc3RhbGxlci9WdWVJbnN0YWxsZXInO1xuXG5jb25zdCBwbHVnaW4gPSBWdWVJbnN0YWxsZXIudXNlKHtcblxuICAgIGluc3RhbGwoVnVlLCBvcHRpb25zKSB7XG4gICAgICAgIFZ1ZUluc3RhbGxlci5jb21wb25lbnRzKHtcbiAgICAgICAgICAgIEJ0bkRyb3Bkb3duXG4gICAgICAgIH0pO1xuICAgIH1cblxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IEJ0bkRyb3Bkb3duO1xuIiwiZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbWV0aG9kczoge1xuXG4gICAgICAgIGdldFNsb3Qoc2xvdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHNsb3RzW3Nsb3RdO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhc1Nsb3Qoc2xvdCkge1xuICAgICAgICAgICAgcmV0dXJuICEhdGhpcy4kc2xvdHNbc2xvdF07XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFzU2xvdHMoc2xvdHMpIHtcbiAgICAgICAgICAgIGZvcihsZXQgaSBpbiBzbG90cykge1xuICAgICAgICAgICAgICAgIGlmKCF0aGlzLmhhc1Nsb3Qoc2xvdHNbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBjb21wdXRlZDoge1xuXG4gICAgICAgIGhhc0RlZmF1bHRTbG90KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFzU2xvdCgnZGVmYXVsdCcpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbn1cbiIsIjx0ZW1wbGF0ZT5cblxuICAgIDxkaXYgOmNsYXNzPVwiJG1lcmdlQ2xhc3NlcyhjbGFzc05hbWUsIGNvbG9yYWJsZUNsYXNzZXMpXCI+XG4gICAgICAgIDxzbG90Lz5cbiAgICA8L2Rpdj5cblxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBIYXNTbG90cyBmcm9tICcuLi8uLi9NaXhpbnMvSGFzU2xvdHMvSGFzU2xvdHMnO1xuaW1wb3J0IENvbG9yYWJsZSBmcm9tICcuLi8uLi9NaXhpbnMvQ29sb3JhYmxlL0NvbG9yYWJsZSc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdjYXJkJyxcblxuICAgIG1peGluczogW1xuICAgICAgICBIYXNTbG90cyxcbiAgICAgICAgQ29sb3JhYmxlXG4gICAgXSxcblxuICAgIGNvbXB1dGVkOiB7XG5cbiAgICAgICAgY2xhc3NOYW1lKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJG9wdGlvbnMubmFtZVxuICAgICAgICB9XG5cbiAgICB9XG5cbn1cblxuPC9zY3JpcHQ+XG4iLCI8c2NyaXB0PlxuaW1wb3J0IENhcmQgZnJvbSAnLi9DYXJkJztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ2NhcmQtYm9keScsXG5cbiAgICBleHRlbmRzOiBDYXJkXG5cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuXG4gICAgPGJ0bi1ncm91cCBjbGFzcz1cImNhcmQtYnRuLWdyb3VwXCI+XG4gICAgICAgIDxzbG90Lz5cbiAgICA8L2J0bi1ncm91cD5cblxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBDYXJkIGZyb20gJy4vQ2FyZCc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdjYXJkLWJ0bi1ncm91cCcsXG5cbiAgICBleHRlbmRzOiBDYXJkXG5cbn1cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cInNjc3NcIj5cbkBpbXBvcnQgJy4vbm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC9zY3NzL2Z1bmN0aW9ucy5zY3NzJztcbkBpbXBvcnQgJy4vbm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC9zY3NzL3ZhcmlhYmxlcy5zY3NzJztcblxuLmNhcmQge1xuICAgIC5jYXJkLWJ0bi1ncm91cCxcbiAgICAuYnRuLWdyb3VwLmNhcmQtYnRuLWdyb3VwIHtcbiAgICAgICAgZmxleDogMTtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuXG4gICAgICAgICYgPiAuYnRuIHtcbiAgICAgICAgICAgIGZsZXg6IDE7XG4gICAgICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDA7XG5cbiAgICAgICAgICAgICY6bm90KDpsYXN0LWNoaWxkKTo6YWZ0ZXIge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICcnO1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgICAgICAgICB0b3A6IDUwJTtcbiAgICAgICAgICAgICAgICByaWdodDogMDtcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiAkZm9udC1zaXplLWJhc2U7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC01MCUpO1xuICAgICAgICAgICAgICAgIGJvcmRlci1yaWdodDogMXB4IHNvbGlkICRjYXJkLWJvcmRlci1jb2xvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbjwvc3R5bGU+XG4iLCI8dGVtcGxhdGU+XG5cbiAgICA8ZGl2IGNsYXNzPVwiY2FyZC1kZWNrXCI+XG4gICAgICAgIDxzbG90Lz5cbiAgICA8L2Rpdj5cblxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdjYXJkLWRlY2snXG5cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuXG4gICAgPGNvbXBvbmVudCA6aXM9XCJ0YWdcIiA6Y2xhc3M9XCIkbWVyZ2VDbGFzc2VzKGNsYXNzTmFtZSwgY29sb3JhYmxlQ2xhc3NlcylcIj5cbiAgICAgICAgPHNsb3QvPlxuICAgIDwvY29tcG9uZW50PlxuXG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IENhcmQgZnJvbSAnLi9DYXJkJztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ2NhcmQtaGVhZGVyJyxcblxuICAgIGV4dGVuZHM6IENhcmQsXG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY29tcG9uZW50J3MgSFRNTCB0YWcgbmFtZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICB0YWc6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdoNSdcbiAgICAgICAgfVxuXG4gICAgfVxuXG59XG5cbjwvc2NyaXB0PlxuIiwiPHNjcmlwdD5cbmltcG9ydCBDYXJkSGVhZGVyIGZyb20gJy4vQ2FyZEhlYWRlcic7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdjYXJkLWZvb3RlcicsXG5cbiAgICBleHRlbmRzOiBDYXJkSGVhZGVyLFxuXG4gICAgcHJvcHM6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNvbXBvbmVudCdzIEhUTUwgdGFnIG5hbWVcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgdGFnOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAnZGl2J1xuICAgICAgICB9XG5cbiAgICB9XG5cbn1cblxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG5cbiAgICA8ZGl2IDpjbGFzcz1cIiRtZXJnZUNsYXNzZXMoY2xhc3NOYW1lKVwiIGNsYXNzPVwiZC1mbGV4IGp1c3RpZnktY29udGVudC1jZW50ZXIgYWxpZ24taXRlbXMtY2VudGVyXCIgOnN0eWxlPVwie2hlaWdodDogdW5pdChoZWlnaHQpfVwiPlxuICAgICAgICA8ZGl2IHYtaWY9XCJiYWNrZ3JvdW5kXCIgY2xhc3M9XCJjYXJkLWltZy1iZ1wiIDpzdHlsZT1cIntiYWNrZ3JvdW5kOiBiYWNrZ3JvdW5kID8gYHVybCgke3RoaXMuc3JjfSlgIDogbnVsbCwgb3ZlcmZsb3c6IGJsdXIgPyAnaGlkZGVuJyA6ICdpbmhlcml0JywgZmlsdGVyOiBibHVyID8gYGJsdXIoJHt1bml0KGJsdXIpfSlgIDogbnVsbH1cIi8+XG4gICAgICAgIDxpbWcgdi1pZj1cIiFiYWNrZ3JvdW5kICYmIHNyY1wiIDpzcmM9XCJzcmNcIiA6YWx0PVwiYWx0XCIgY2xhc3M9XCJpbWctZmx1aWRcIi8+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJjYXJkLWltZy1jb250ZW50XCIgOmNsYXNzPVwieyd0ZXh0LXRydW5jYXRlJzogdGV4dFRydW5jYXRlfVwiPlxuICAgICAgICAgICAgPHNsb3QvPlxuICAgICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cblxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBDYXJkIGZyb20gJy4vQ2FyZCc7XG5pbXBvcnQgdW5pdCBmcm9tICcuLi8uLi9IZWxwZXJzL1VuaXQnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAnY2FyZC1pbWcnLFxuXG4gICAgZXh0ZW5kczogQ2FyZCxcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhbHQgYXR0cmlidXRlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGFsdDogU3RyaW5nLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwbGF5IHRoZSBpbWFnZSBhcyBhIGJhY2tncm91bmQgaW1hZ2UgZml0IHdpdGggQ1NTIGNvdmVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBiYWNrZ3JvdW5kOiBCb29sZWFuLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYW1vdW50IHRvIGJsdXIgdGhlIGJhY2tncm91bmQgaW1hZ2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGJsdXI6IFtOdW1iZXIsIFN0cmluZ10sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBoZWlnaHQgYXR0cmlidXRlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGhlaWdodDogW051bWJlciwgU3RyaW5nXSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVHJ1bmNhdGUgdGhlIHRleHQgaW4gdGhlIGNvbnRlbnRcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgdGV4dFRydW5jYXRlOiBCb29sZWFuLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc3JjIGF0dHJpYnV0ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBzcmM6IFN0cmluZ1xuXG4gICAgfSxcblxuICAgIG1ldGhvZHM6IHtcblxuICAgICAgICB1bml0KHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5pdCh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgIH1cblxufVxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwic2Nzc1wiPlxuLmNhcmQtaW1nLFxuLmNhcmQtaW1nLXRvcCxcbi5jYXJkLWltZy1ib3R0b20ge1xuICAgIGNvbG9yOiB3aGl0ZTtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgdGV4dC1zaGFkb3c6IDAgMCAyMHB4IHJnYmEoMCwgMCwgMCwgLjUpO1xuXG4gICAgLmNhcmQtaW1nLWJnIHtcbiAgICAgICAgei1pbmRleDogMDtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IDA7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICAgIGJhY2tncm91bmQtc2l6ZTogY292ZXIgIWltcG9ydGFudDtcbiAgICAgICAgYmFja2dyb3VuZC1wb3NpdGlvbjogY2VudGVyICFpbXBvcnRhbnQ7XG4gICAgICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQgIWltcG9ydGFudDtcblxuICAgICAgICAmID4gaW1nOmZpcnN0LWNoaWxkIHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC5jYXJkLWltZy1jb250ZW50IHtcbiAgICAgICAgZmxleDogMTtcbiAgICAgICAgei1pbmRleDogMTtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIH1cblxuICAgIC8qXG4gICAgJiA+IDpub3QoaW1nKSB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB9XG4gICAgKi9cbn1cbjwvc3R5bGU+XG4iLCI8c2NyaXB0PlxuaW1wb3J0IENhcmRJbWcgZnJvbSAnLi9DYXJkSW1nJztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ2NhcmQtaW1nLXRvcCcsXG5cbiAgICBleHRlbmRzOiBDYXJkSW1nXG59XG5cbjwvc2NyaXB0PlxuIiwiPHNjcmlwdD5cbmltcG9ydCBDYXJkSW1nIGZyb20gJy4vQ2FyZEltZyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdjYXJkLWltZy1ib3R0b20nLFxuXG4gICAgZXh0ZW5kczogQ2FyZEltZ1xuXG59XG48L3NjcmlwdD5cbiIsIjxzY3JpcHQ+XG5pbXBvcnQgQ2FyZCBmcm9tICcuL0NhcmQnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAnY2FyZC1pbWctb3ZlcmxheScsXG5cbiAgICBleHRlbmRzOiBDYXJkXG5cbn1cblxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG5cbiAgICA8cm91dGVyLWxpbmsgOnRvPVwiaHJlZlwiIDpjbGFzcz1cIiRtZXJnZUNsYXNzZXMoY2xhc3NOYW1lLCBjb2xvcmFibGVDbGFzc2VzKVwiIEBjbGljaz1cIm9uQ2xpY2tcIj5cbiAgICAgICAgPHNsb3QvPlxuICAgIDwvcm91dGVyLWxpbms+XG5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgQ2FyZCBmcm9tICcuL0NhcmQnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAnY2FyZC1saW5rJyxcblxuICAgIGV4dGVuZHM6IENhcmQsXG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYWx0IGF0dHJpYnV0ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBhbHQ6IFN0cmluZyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGhyZWYgYXR0cmlidXRlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGhyZWY6IFN0cmluZyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRvIGF0dHJpYnV0ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICB0bzogW09iamVjdCwgU3RyaW5nXVxuXG4gICAgfSxcblxuICAgIG1ldGhvZHM6IHtcblxuICAgICAgICBvbkNsaWNrKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCdjbGljaycsIGV2ZW50LCB0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG59XG5cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuXG4gICAgPGg2IDpjbGFzcz1cIiRtZXJnZUNsYXNzZXMoY2xhc3NOYW1lLCBjb2xvcmFibGVDbGFzc2VzKVwiPlxuICAgICAgICA8c2xvdC8+XG4gICAgPC9oNj5cblxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBDYXJkIGZyb20gJy4vQ2FyZCc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdjYXJkLXN1YnRpdGxlJyxcblxuICAgIGV4dGVuZHM6IENhcmRcblxufVxuXG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cblxuICAgIDxoNSA6Y2xhc3M9XCIkbWVyZ2VDbGFzc2VzKGNsYXNzTmFtZSwgY29sb3JhYmxlQ2xhc3NlcylcIj5cbiAgICAgICAgPHNsb3QvPlxuICAgIDwvaDU+XG5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgQ2FyZCBmcm9tICcuL0NhcmQnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAnY2FyZC10aXRsZScsXG5cbiAgICBtaXhpbnM6IFtcbiAgICAgICAgQ2FyZFxuICAgIF1cblxufVxuXG48L3NjcmlwdD5cbiIsImltcG9ydCBDYXJkIGZyb20gJy4vQ2FyZCc7XG5pbXBvcnQgQ2FyZEJvZHkgZnJvbSAnLi9DYXJkQm9keSc7XG5pbXBvcnQgQ2FyZEJ0bkdyb3VwIGZyb20gJy4vQ2FyZEJ0bkdyb3VwJztcbmltcG9ydCBDYXJkRGVjayBmcm9tICcuL0NhcmREZWNrJztcbmltcG9ydCBDYXJkRm9vdGVyIGZyb20gJy4vQ2FyZEZvb3Rlcic7XG5pbXBvcnQgQ2FyZEhlYWRlciBmcm9tICcuL0NhcmRIZWFkZXInO1xuaW1wb3J0IENhcmRJbWcgZnJvbSAnLi9DYXJkSW1nJztcbmltcG9ydCBDYXJkSW1nVG9wIGZyb20gJy4vQ2FyZEltZ1RvcCc7XG5pbXBvcnQgQ2FyZEltZ0JvdHRvbSBmcm9tICcuL0NhcmRJbWdCb3R0b20nO1xuaW1wb3J0IENhcmRJbWdPdmVybGF5IGZyb20gJy4vQ2FyZEltZ092ZXJsYXknO1xuaW1wb3J0IENhcmRMaW5rIGZyb20gJy4vQ2FyZExpbmsnO1xuaW1wb3J0IENhcmRTdWJ0aXRsZSBmcm9tICcuL0NhcmRTdWJ0aXRsZSc7XG5pbXBvcnQgQ2FyZFRpdGxlIGZyb20gJy4vQ2FyZFRpdGxlJztcbmltcG9ydCBWdWVJbnN0YWxsZXIgZnJvbSAnLi4vLi4vSGVscGVycy9WdWVJbnN0YWxsZXIvVnVlSW5zdGFsbGVyJztcblxuY29uc3QgcGx1Z2luID0gVnVlSW5zdGFsbGVyLnVzZSh7XG5cbiAgICBpbnN0YWxsKFZ1ZSwgb3B0aW9ucykge1xuICAgICAgICBWdWVJbnN0YWxsZXIuY29tcG9uZW50cyh7XG4gICAgICAgICAgICBDYXJkLFxuICAgICAgICAgICAgQ2FyZEJvZHksXG4gICAgICAgICAgICBDYXJkQnRuR3JvdXAsXG4gICAgICAgICAgICBDYXJkRGVjayxcbiAgICAgICAgICAgIENhcmRGb290ZXIsXG4gICAgICAgICAgICBDYXJkSGVhZGVyLFxuICAgICAgICAgICAgQ2FyZEltZyxcbiAgICAgICAgICAgIENhcmRJbWdUb3AsXG4gICAgICAgICAgICBDYXJkSW1nQm90dG9tLFxuICAgICAgICAgICAgQ2FyZEltZ092ZXJsYXksXG4gICAgICAgICAgICBDYXJkTGluayxcbiAgICAgICAgICAgIENhcmRTdWJ0aXRsZSxcbiAgICAgICAgICAgIENhcmRUaXRsZVxuICAgICAgICB9KTtcbiAgICB9XG5cbn0pO1xuXG5leHBvcnQgKiBmcm9tICcuL0NhcmRCb2R5JztcbmV4cG9ydCAqIGZyb20gJy4vQ2FyZEJ0bkdyb3VwJztcbmV4cG9ydCAqIGZyb20gJy4vQ2FyZERlY2snO1xuZXhwb3J0ICogZnJvbSAnLi9DYXJkRm9vdGVyJztcbmV4cG9ydCAqIGZyb20gJy4vQ2FyZEhlYWRlcic7XG5leHBvcnQgKiBmcm9tICcuL0NhcmRJbWcnO1xuZXhwb3J0ICogZnJvbSAnLi9DYXJkSW1nVG9wJztcbmV4cG9ydCAqIGZyb20gJy4vQ2FyZEltZ0JvdHRvbSc7XG5leHBvcnQgKiBmcm9tICcuL0NhcmRJbWdPdmVybGF5JztcbmV4cG9ydCAqIGZyb20gJy4vQ2FyZExpbmsnO1xuZXhwb3J0ICogZnJvbSAnLi9DYXJkU3VidGl0bGUnO1xuZXhwb3J0ICogZnJvbSAnLi9DYXJkVGl0bGUnO1xuZXhwb3J0IGRlZmF1bHQgQ2FyZDtcbiIsIjx0ZW1wbGF0ZT5cblxuICAgIDxkaXYgOmNsYXNzPVwiJG1lcmdlQ2xhc3Nlcyhjb250cm9sQ2xhc3MsIGN1c3RvbUNvbnRyb2xDbGFzcywgc2l6ZWFibGVDbGFzcywgaW5saW5lID8gaW5saW5lQ2xhc3MgOiAnJylcIj5cblxuICAgICAgICA8dGVtcGxhdGUgdi1pZj1cImN1c3RvbSAmJiBpZFwiPlxuICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgdi1iaW5kLWV2ZW50c1xuICAgICAgICAgICAgICAgIHR5cGU9XCJyYWRpb1wiXG4gICAgICAgICAgICAgICAgOm5hbWU9XCJuYW1lXCJcbiAgICAgICAgICAgICAgICA6aWQ9XCJpZFwiXG4gICAgICAgICAgICAgICAgOnZhbHVlPVwidmFsdWVcIlxuICAgICAgICAgICAgICAgIDpyZXF1aXJlZD1cInJlcXVpcmVkXCJcbiAgICAgICAgICAgICAgICA6ZGlzYWJsZWQ9XCJkaXNhYmxlZCB8fCByZWFkb25seVwiXG4gICAgICAgICAgICAgICAgOnJlYWRvbmx5PVwicmVhZG9ubHlcIlxuICAgICAgICAgICAgICAgIDpwYXR0ZXJuPVwicGF0dGVyblwiXG4gICAgICAgICAgICAgICAgOmNoZWNrZWQ9XCJjaGVja2VkVmFsdWUgPT09IHZhbHVlIHx8IGNoZWNrZWRcIlxuICAgICAgICAgICAgICAgIDpjbGFzcz1cIiRtZXJnZUNsYXNzZXMoaW5wdXRDbGFzcywgKGludmFsaWRGZWVkYmFjayA/ICdpcy1pbnZhbGlkJyA6ICcnKSlcIlxuICAgICAgICAgICAgICAgIEBjaGFuZ2U9XCJ1cGRhdGVkKCRldmVudC50YXJnZXQudmFsdWUsICdjaGFuZ2UnKVwiPlxuXG4gICAgICAgICAgICA8bGFiZWwgOmZvcj1cImlkXCIgOmNsYXNzPVwiJG1lcmdlQ2xhc3NlcyhsYWJlbENsYXNzLCBjb2xvcmFibGVDbGFzc2VzKVwiPlxuICAgICAgICAgICAgICAgIDxzbG90Pnt7bGFiZWx9fTwvc2xvdD5cbiAgICAgICAgICAgICAgICA8c2xvdCBuYW1lPVwiZmVlZGJhY2tcIj5cbiAgICAgICAgICAgICAgICAgICAgPGZvcm0tZmVlZGJhY2sgdi1pZj1cInZhbGlkRmVlZGJhY2tcIiB2LWh0bWw9XCJ2YWxpZEZlZWRiYWNrXCIgdmFsaWQgLz5cbiAgICAgICAgICAgICAgICAgICAgPGZvcm0tZmVlZGJhY2sgdi1pZj1cImludmFsaWRGZWVkYmFja1wiIHYtaHRtbD1cImludmFsaWRGZWVkYmFja1wiIGludmFsaWQgLz5cbiAgICAgICAgICAgICAgICA8L3Nsb3Q+XG4gICAgICAgICAgICA8L2xhYmVsPlxuXG4gICAgICAgIDwvdGVtcGxhdGU+XG4gICAgICAgIDx0ZW1wbGF0ZSB2LWVsc2U+XG4gICAgICAgICAgICA8bGFiZWwgOmZvcj1cImlkXCIgOmNsYXNzPVwiJG1lcmdlQ2xhc3NlcyhsYWJlbENsYXNzLCBjb2xvcmFibGVDbGFzc2VzKVwiPlxuICAgICAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgICAgICB2LWJpbmQtZXZlbnRzXG4gICAgICAgICAgICAgICAgICAgIHR5cGU9XCJyYWRpb1wiXG4gICAgICAgICAgICAgICAgICAgIDpuYW1lPVwibmFtZVwiXG4gICAgICAgICAgICAgICAgICAgIDppZD1cImlkXCJcbiAgICAgICAgICAgICAgICAgICAgOnZhbHVlPVwidmFsdWVcIlxuICAgICAgICAgICAgICAgICAgICA6cmVxdWlyZWQ9XCJyZXF1aXJlZFwiXG4gICAgICAgICAgICAgICAgICAgIDpkaXNhYmxlZD1cImRpc2FibGVkIHx8IHJlYWRvbmx5XCJcbiAgICAgICAgICAgICAgICAgICAgOnJlYWRvbmx5PVwicmVhZG9ubHlcIlxuICAgICAgICAgICAgICAgICAgICA6cGF0dGVybj1cInBhdHRlcm5cIlxuICAgICAgICAgICAgICAgICAgICA6Y2hlY2tlZD1cImNoZWNrZWRWYWx1ZSA9PT0gdmFsdWUgfHwgY2hlY2tlZFwiXG4gICAgICAgICAgICAgICAgICAgIDpjbGFzcz1cIiRtZXJnZUNsYXNzZXMoaW5wdXRDbGFzcywgKGludmFsaWRGZWVkYmFjayA/ICdpcy1pbnZhbGlkJyA6ICcnKSlcIlxuICAgICAgICAgICAgICAgICAgICBAY2hhbmdlPVwidXBkYXRlZCgkZXZlbnQudGFyZ2V0LnZhbHVlLCAnY2hhbmdlJylcIj5cblxuICAgICAgICAgICAgICAgIDxzbG90Pnt7bGFiZWx9fTwvc2xvdD5cblxuICAgICAgICAgICAgICAgIDxzbG90IG5hbWU9XCJmZWVkYmFja1wiPlxuICAgICAgICAgICAgICAgICAgICA8Zm9ybS1mZWVkYmFjayB2LWlmPVwidmFsaWRGZWVkYmFja1wiIHYtaHRtbD1cInZhbGlkRmVlZGJhY2tcIiB2YWxpZCAvPlxuICAgICAgICAgICAgICAgICAgICA8Zm9ybS1mZWVkYmFjayB2LWlmPVwiaW52YWxpZEZlZWRiYWNrXCIgdi1odG1sPVwiaW52YWxpZEZlZWRiYWNrXCIgaW52YWxpZCAvPlxuICAgICAgICAgICAgICAgIDwvc2xvdD5cbiAgICAgICAgICAgIDwvbGFiZWw+XG4gICAgICAgIDwvdGVtcGxhdGU+XG5cbiAgICAgICAgPHNsb3QgbmFtZT1cImhlbHBcIj5cbiAgICAgICAgICAgIDxoZWxwLXRleHQgdi1pZj1cImhlbHBUZXh0XCIgdi1odG1sPVwiaGVscFRleHRcIiAvPlxuICAgICAgICA8L3Nsb3Q+XG4gICAgPC9kaXY+XG5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgSGVscFRleHQgZnJvbSAnLi4vSGVscFRleHQnO1xuaW1wb3J0IEZvcm1GZWVkYmFjayBmcm9tICcuLi9Gb3JtRmVlZGJhY2snO1xuaW1wb3J0IHByZWZpeCBmcm9tICcuLi8uLi9IZWxwZXJzL1ByZWZpeC9QcmVmaXgnO1xuaW1wb3J0IENvbG9yYWJsZSBmcm9tICcuLi8uLi9NaXhpbnMvQ29sb3JhYmxlL0NvbG9yYWJsZSc7XG5pbXBvcnQgRm9ybUNvbnRyb2wgZnJvbSAnLi4vLi4vTWl4aW5zL0Zvcm1Db250cm9sL0Zvcm1Db250cm9sJztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ3JhZGlvLWZpZWxkJyxcblxuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgICAgSGVscFRleHQsXG4gICAgICAgIEZvcm1GZWVkYmFja1xuICAgIH0sXG5cbiAgICBtaXhpbnM6IFtcbiAgICAgICAgQ29sb3JhYmxlLFxuICAgICAgICBGb3JtQ29udHJvbFxuICAgIF0sXG5cbiAgICBtb2RlbDoge1xuICAgICAgICBldmVudDogJ2NoYW5nZScsXG4gICAgICAgIHByb3A6ICdjaGVja2VkVmFsdWUnXG4gICAgfSxcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGFycmF5IG9mIGV2ZW50IG5hbWVzIHRoYXQgY29ycmVsYXRlIHdpdGggY2FsbGJhY2sgZnVuY3Rpb25zXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBGdW5jdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgYmluZEV2ZW50czoge1xuICAgICAgICAgICAgdHlwZTogQXJyYXksXG4gICAgICAgICAgICBkZWZhdWx0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbJ2ZvY3VzJywgJ2JsdXInLCAnaW5wdXQnLCAnY2xpY2snLCAna2V5dXAnLCAna2V5ZG93bicsICdwcm9ncmVzcyddO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJcyB0aGlzIGEgY3VzdG9tIGVsZW1lbnRcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgY3VzdG9tOiBCb29sZWFuLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwbGF5IHRoZSBmb3JtIGZpZWxkIGFuZCBsYWJlbCBpbmxpbmVcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IEZ1bmN0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBpbmxpbmU6IEJvb2xlYW4sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjaGVja2VkIHZhbHVlc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBjaGVja2VkOiBCb29sZWFuLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY2hlY2tlZCB2YWx1ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBjaGVja2VkVmFsdWU6IFtCb29sZWFuLCBOdW1iZXIsIFN0cmluZywgT2JqZWN0XSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNsYXNzIG5hbWUgYXNzaWduZWQgdG8gdGhlIGNvbnRyb2wgZWxlbWVudFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBkZWZhdWx0Q29udHJvbENsYXNzOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAnZm9ybS1jaGVjaydcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGNvbXB1dGVkOiB7XG5cbiAgICAgICAgbGFiZWxDbGFzcygpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmVmaXgoJ2xhYmVsJywgdGhpcy5jb250cm9sQ2xhc3MpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGlucHV0Q2xhc3MoKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJlZml4KCdpbnB1dCcsIHRoaXMuY29udHJvbENsYXNzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpbmxpbmVDbGFzcygpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmVmaXgoJ2lubGluZScsIHRoaXMuY29udHJvbENsYXNzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjb250cm9sQ2xhc3MoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jdXN0b20gPyAnY3VzdG9tLWNvbnRyb2wnIDogdGhpcy5kZWZhdWx0Q29udHJvbENsYXNzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGN1c3RvbUNvbnRyb2xDbGFzcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmN1c3RvbSA/IHByZWZpeCh0aGlzLiRvcHRpb25zLm5hbWUucmVwbGFjZSgnLWZpZWxkJywgJycpLCAnY3VzdG9tJykgOiAnJztcbiAgICAgICAgfSxcblxuICAgICAgICBzaXplYWJsZUNsYXNzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHByZWZpeCh0aGlzLnNpemUsICdmb3JtLWNvbnRyb2wnKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG59XG5cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuXG4gICAgPGRpdiA6Y2xhc3M9XCIkbWVyZ2VDbGFzc2VzKGNvbnRyb2xDbGFzcywgY3VzdG9tQ29udHJvbENsYXNzLCBzaXplYWJsZUNsYXNzLCBpbmxpbmUgPyBpbmxpbmVDbGFzcyA6ICcnKVwiPlxuXG4gICAgICAgIDx0ZW1wbGF0ZSB2LWlmPVwiY3VzdG9tICYmIGlkXCI+XG4gICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICB2LWJpbmQtZXZlbnRzXG4gICAgICAgICAgICAgICAgdHlwZT1cImNoZWNrYm94XCJcbiAgICAgICAgICAgICAgICA6bmFtZT1cIm5hbWVcIlxuICAgICAgICAgICAgICAgIDppZD1cImlkXCJcbiAgICAgICAgICAgICAgICA6dmFsdWU9XCJ2YWx1ZVwiXG4gICAgICAgICAgICAgICAgOnJlcXVpcmVkPVwicmVxdWlyZWRcIlxuICAgICAgICAgICAgICAgIDpkaXNhYmxlZD1cImRpc2FibGVkIHx8IHJlYWRvbmx5XCJcbiAgICAgICAgICAgICAgICA6cmVhZG9ubHk9XCJyZWFkb25seVwiXG4gICAgICAgICAgICAgICAgOnBhdHRlcm49XCJwYXR0ZXJuXCJcbiAgICAgICAgICAgICAgICA6Y2hlY2tlZD1cImNoZWNrZWRWYWx1ZXMuaW5kZXhPZih2YWx1ZSkgIT09IC0xIHx8IGNoZWNrZWRcIlxuICAgICAgICAgICAgICAgIDpjbGFzcz1cIiRtZXJnZUNsYXNzZXMoaW5wdXRDbGFzcywgKGludmFsaWRGZWVkYmFjayA/ICdpcy1pbnZhbGlkJyA6ICcnKSlcIlxuICAgICAgICAgICAgICAgIEBjaGFuZ2U9XCJ1cGRhdGVkKCRldmVudC50YXJnZXQudmFsdWUsICdjaGFuZ2UnKVwiPlxuXG4gICAgICAgICAgICA8bGFiZWwgOmZvcj1cImlkXCIgOmNsYXNzPVwiJG1lcmdlQ2xhc3NlcyhsYWJlbENsYXNzLCBjb2xvcmFibGVDbGFzc2VzKVwiPlxuICAgICAgICAgICAgICAgIDxzbG90Pnt7bGFiZWx9fTwvc2xvdD5cbiAgICAgICAgICAgICAgICA8c2xvdCBuYW1lPVwiZmVlZGJhY2tcIj5cbiAgICAgICAgICAgICAgICAgICAgPGZvcm0tZmVlZGJhY2sgdi1pZj1cInZhbGlkRmVlZGJhY2tcIiB2LWh0bWw9XCJ2YWxpZEZlZWRiYWNrXCIgdmFsaWQgLz5cbiAgICAgICAgICAgICAgICAgICAgPGZvcm0tZmVlZGJhY2sgdi1pZj1cImludmFsaWRGZWVkYmFja1wiIHYtaHRtbD1cImludmFsaWRGZWVkYmFja1wiIGludmFsaWQgLz5cbiAgICAgICAgICAgICAgICA8L3Nsb3Q+XG4gICAgICAgICAgICA8L2xhYmVsPlxuXG4gICAgICAgIDwvdGVtcGxhdGU+XG5cbiAgICAgICAgPHRlbXBsYXRlIHYtZWxzZT5cbiAgICAgICAgICAgIDxsYWJlbCA6Zm9yPVwiaWRcIiA6Y2xhc3M9XCIkbWVyZ2VDbGFzc2VzKGxhYmVsQ2xhc3MsIGNvbG9yYWJsZUNsYXNzZXMpXCI+XG4gICAgICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgICAgIHYtYmluZC1ldmVudHNcbiAgICAgICAgICAgICAgICAgICAgdHlwZT1cImNoZWNrYm94XCJcbiAgICAgICAgICAgICAgICAgICAgOm5hbWU9XCJuYW1lXCJcbiAgICAgICAgICAgICAgICAgICAgOmlkPVwiaWRcIlxuICAgICAgICAgICAgICAgICAgICA6dmFsdWU9XCJ2YWx1ZVwiXG4gICAgICAgICAgICAgICAgICAgIDpyZXF1aXJlZD1cInJlcXVpcmVkXCJcbiAgICAgICAgICAgICAgICAgICAgOmRpc2FibGVkPVwiZGlzYWJsZWQgfHwgcmVhZG9ubHlcIlxuICAgICAgICAgICAgICAgICAgICA6cmVhZG9ubHk9XCJyZWFkb25seVwiXG4gICAgICAgICAgICAgICAgICAgIDpwYXR0ZXJuPVwicGF0dGVyblwiXG4gICAgICAgICAgICAgICAgICAgIDpjaGVja2VkPVwiY2hlY2tlZFZhbHVlcy5pbmRleE9mKHZhbHVlKSAhPT0gLTEgfHwgY2hlY2tlZFwiXG4gICAgICAgICAgICAgICAgICAgIDpjbGFzcz1cIiRtZXJnZUNsYXNzZXMoaW5wdXRDbGFzcywgKGludmFsaWRGZWVkYmFjayA/ICdpcy1pbnZhbGlkJyA6ICcnKSlcIlxuICAgICAgICAgICAgICAgICAgICBAY2hhbmdlPVwidXBkYXRlZCgkZXZlbnQudGFyZ2V0LnZhbHVlLCAnY2hhbmdlJylcIj5cblxuICAgICAgICAgICAgICAgIDxzbG90Pnt7bGFiZWx9fTwvc2xvdD5cblxuICAgICAgICAgICAgICAgIDxzbG90IG5hbWU9XCJmZWVkYmFja1wiPlxuICAgICAgICAgICAgICAgICAgICA8Zm9ybS1mZWVkYmFjayB2LWlmPVwidmFsaWRGZWVkYmFja1wiIHYtaHRtbD1cInZhbGlkRmVlZGJhY2tcIiB2YWxpZCAvPlxuICAgICAgICAgICAgICAgICAgICA8Zm9ybS1mZWVkYmFjayB2LWlmPVwiaW52YWxpZEZlZWRiYWNrXCIgdi1odG1sPVwiaW52YWxpZEZlZWRiYWNrXCIgaW52YWxpZCAvPlxuICAgICAgICAgICAgICAgIDwvc2xvdD5cbiAgICAgICAgICAgIDwvbGFiZWw+XG4gICAgICAgIDwvdGVtcGxhdGU+XG5cbiAgICAgICAgPHNsb3QgbmFtZT1cImhlbHBcIj5cbiAgICAgICAgICAgIDxoZWxwLXRleHQgdi1pZj1cImhlbHBUZXh0XCIgdi1odG1sPVwiaGVscFRleHRcIiAvPlxuICAgICAgICA8L3Nsb3Q+XG4gICAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuXG5pbXBvcnQgUmFkaW9GaWVsZCBmcm9tICcuLi9SYWRpb0ZpZWxkL1JhZGlvRmllbGQnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAnY2hlY2tib3gtZmllbGQnLFxuXG4gICAgZXh0ZW5kczogUmFkaW9GaWVsZCxcblxuICAgIG1vZGVsOiB7XG4gICAgICAgIGV2ZW50OiAnY2hhbmdlJyxcbiAgICAgICAgcHJvcDogJ2NoZWNrZWRWYWx1ZXMnXG4gICAgfSxcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjaGVja2VkIHZhbHVlc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBjaGVja2VkVmFsdWVzOiB7XG4gICAgICAgICAgICB0eXBlOiBBcnJheSxcbiAgICAgICAgICAgIGRlZmF1bHQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgbWV0aG9kczoge1xuXG4gICAgICAgIHVwZGF0ZWQodmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrZWQgPSB0aGlzLmNoZWNrZWRWYWx1ZXMuc2xpY2UoMCk7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuY2hlY2tlZFZhbHVlcy5pbmRleE9mKHZhbHVlKTtcblxuICAgICAgICAgICAgaWYoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgY2hlY2tlZC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoZWNrZWQuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgY2hlY2tlZCk7XG4gICAgICAgIH1cblxuICAgIH1cbn1cblxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgQ2hlY2tib3hGaWVsZCBmcm9tICcuL0NoZWNrYm94RmllbGQnO1xuaW1wb3J0IFZ1ZUluc3RhbGxlciBmcm9tICcuLi8uLi9IZWxwZXJzL1Z1ZUluc3RhbGxlci9WdWVJbnN0YWxsZXInO1xuXG5jb25zdCBwbHVnaW4gPSBWdWVJbnN0YWxsZXIudXNlKHtcblxuICAgIGluc3RhbGwoVnVlLCBvcHRpb25zKSB7XG4gICAgICAgIFZ1ZUluc3RhbGxlci5jb21wb25lbnRzKHtcbiAgICAgICAgICAgIENoZWNrYm94RmllbGRcbiAgICAgICAgfSk7XG4gICAgfVxuXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgQ2hlY2tib3hGaWVsZDtcbiIsIjx0ZW1wbGF0ZT5cblxuICAgIDxkaXYgY2xhc3M9XCJkcm9wem9uZVwiIDpjbGFzcz1cInsnaXMtZHJhZ2dpbmcnOiBpc0RyYWdnaW5nfVwiIEBkcm9wLnByZXZlbnQ9XCJvbkRyb3BcIiBAZHJhZ292ZXIucHJldmVudD1cIm9uRHJhZ292ZXJcIiBAZHJhZ2VudGVyLnByZXZlbnQ9XCJvbkRyYWdlbnRlclwiIEBkcmFnbGVhdmUucHJldmVudD1cIm9uRHJhZ2xlYXZlXCI+XG4gICAgICAgIDxzbG90IG5hbWU9XCJwbGFjZWhvbGRlclwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImRyb3B6b25lLXBsYWNlaG9sZGVyIHRleHQtY2VudGVyXCI+XG4gICAgICAgICAgICAgICAgPGNhcmQ+XG4gICAgICAgICAgICAgICAgICAgIDxjYXJkLWJvZHk+XG4gICAgICAgICAgICAgICAgICAgICAgICA8aDEgY2xhc3M9XCJtdC00XCI+RHJhZyAmIERyb3A8L2gxPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHA+RHJhZyBhbmQgZHJvcCB5b3VyIGZpbGVzIGhlcmUgdG8gdXBsb2FkIHRoZW0hPC9wPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm10LTMgbWItNFwiPjxpIGNsYXNzPVwiZmEgZmEtaW1hZ2VcIi8+PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDwvY2FyZC1ib2R5PlxuICAgICAgICAgICAgICAgIDwvY2FyZD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L3Nsb3Q+XG4gICAgICAgIDxzbG90Lz5cbiAgICA8L2Rpdj5cblxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBDYXJkIGZyb20gJy4uL0NhcmQnO1xuaW1wb3J0IENhcmRCb2R5IGZyb20gJy4uL0NhcmQvQ2FyZEJvZHknO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAnZHJvcHpvbmUnLFxuXG4gICAgY29tcG9uZW50czoge1xuICAgICAgICBDYXJkLFxuICAgICAgICBDYXJkQm9keVxuICAgIH0sXG5cbiAgICBtZXRob2RzOiB7XG5cbiAgICAgICAgb25Ecm9wKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2Ryb3AnLCBldmVudCwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25EcmFnb3ZlcihldmVudCkge1xuICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2RyYWdvdmVyJywgZXZlbnQsIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uRHJhZ2VudGVyKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgnZHJhZ2VudGVyJywgZXZlbnQsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5vbkRyYWdvdmVyKGV2ZW50KTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbkRyYWdsZWF2ZShldmVudCkge1xuICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCdkcmFnbGVhdmUnLCBldmVudCwgdGhpcyk7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZmlsZXM6IG51bGwsXG4gICAgICAgICAgICBpc0RyYWdnaW5nOiBmYWxzZVxuICAgICAgICB9XG4gICAgfVxuXG59XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJzY3NzXCIgc2NvcGVkPlxuLmRyb3B6b25lIHtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG5cbiAgICBwIHtcbiAgICAgICAgZm9udC1zaXplOiAxOHB4O1xuICAgIH1cblxuICAgIC5mYS1pbWFnZSB7XG4gICAgICAgIGZvbnQtc2l6ZTogMTAwcHg7XG4gICAgfVxuXG4gICAgLmRyb3B6b25lLXBsYWNlaG9sZGVyIHtcbiAgICAgICAgZGlzcGxheTogbm9uZTtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IDA7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIHotaW5kZXg6IDI7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICAgIGJhY2tncm91bmQ6IHdoaXRlO1xuICAgIH1cblxuICAgICYuaXMtZHJhZ2dpbmcgLmRyb3B6b25lLXBsYWNlaG9sZGVyIHtcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgfVxufVxuPC9zdHlsZT5cbiIsImltcG9ydCBEcm9wem9uZSBmcm9tICcuL0Ryb3B6b25lJztcbmltcG9ydCBWdWVJbnN0YWxsZXIgZnJvbSAnLi4vLi4vSGVscGVycy9WdWVJbnN0YWxsZXIvVnVlSW5zdGFsbGVyJztcblxuY29uc3QgcGx1Z2luID0gVnVlSW5zdGFsbGVyLnVzZSh7XG5cbiAgICBpbnN0YWxsKFZ1ZSwgb3B0aW9ucykge1xuICAgICAgICBWdWVJbnN0YWxsZXIuY29tcG9uZW50cyh7XG4gICAgICAgICAgICBEcm9wem9uZVxuICAgICAgICB9KTtcbiAgICB9XG5cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBEcm9wem9uZTtcbiIsImltcG9ydCBGaWxlRmllbGQgZnJvbSAnLi9GaWxlRmllbGQnO1xuaW1wb3J0IFZ1ZUluc3RhbGxlciBmcm9tICcuLi8uLi9IZWxwZXJzL1Z1ZUluc3RhbGxlci9WdWVJbnN0YWxsZXInO1xuXG5jb25zdCBwbHVnaW4gPSBWdWVJbnN0YWxsZXIudXNlKHtcblxuICAgIGluc3RhbGwoVnVlLCBvcHRpb25zKSB7XG4gICAgICAgIFZ1ZUluc3RhbGxlci5jb21wb25lbnRzKHtcbiAgICAgICAgICAgIEZpbGVGaWVsZFxuICAgICAgICB9KTtcbiAgICB9XG5cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBGaWxlRmllbGQ7XG4iLCJpbXBvcnQgeyBpc0Z1bmN0aW9uIH0gZnJvbSAnbG9kYXNoLWVzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmVhZEZpbGUoZmlsZSwgcHJvZ3Jlc3MpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcjtcbiAgICAgICAgcmVhZGVyLm9ubG9hZCA9IGUgPT4gcmVzb2x2ZShlKTtcbiAgICAgICAgcmVhZGVyLm9uZXJyb3IgPSBlID0+IHJlamVjdChlKTtcbiAgICAgICAgcmVhZGVyLm9uYWJvcnQgPSBlID0+IHJlamVjdChlKTtcbiAgICAgICAgcmVhZGVyLm9ucHJvZ3Jlc3MgPSBlID0+IHByb2dyZXNzKGUsIHJlYWRlcik7XG4gICAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGZpbGUpO1xuICAgIH0pO1xufVxuIiwiPHRlbXBsYXRlPlxuXG4gICAgPGRpdiBjbGFzcz1cImZpbGUtcHJldmlld1wiIDpjbGFzcz1cInsnaXMtaW1hZ2UnOiBpc0ltYWdlfVwiPlxuXG4gICAgICAgIDxkaXYgY2xhc3M9XCJmaWxlLXByZXZpZXctaW5uZXJcIj5cblxuICAgICAgICAgICAgPGEgdi1pZj1cIiFoaWRlQ2xvc2UgJiYgKCFpc0ltYWdlIHx8IGltYWdlKVwiIGhyZWY9XCIjXCIgY2xhc3M9XCJmaWxlLXByZXZpZXctY2xvc2VcIiBAY2xpY2sucHJldmVudD1cIiRlbWl0KCdjbG9zZScsIGZpbGUpXCI+XG4gICAgICAgICAgICAgICAgPGkgY2xhc3M9XCJmYSBmYS10aW1lcy1jaXJjbGVcIj48L2k+XG4gICAgICAgICAgICA8L2E+XG5cbiAgICAgICAgICAgIDxkaXYgdi1pZj1cImlzSW1hZ2VcIiBjbGFzcz1cImZpbGUtcHJldmlldy1pbWFnZVwiPlxuICAgICAgICAgICAgICAgIDxpbWcgdi1pZj1cImltYWdlXCIgOnNyYz1cImltYWdlXCIgY2xhc3M9XCJmaWxlLXByZXZpZXctdGh1bWJuYWlsXCI+XG4gICAgICAgICAgICAgICAgPHByb2dyZXNzLWJhciB2LWVsc2Ugdi1yZWFkeT1cInJlYWRGaWxlXCIgOnZhbHVlPVwibG9hZGVkXCIgOmhlaWdodD1cIjEwXCIgLz5cbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICA8ZGl2IHYtZWxzZSBjbGFzcz1cImZpbGUtcHJldmlldy1pY29uXCI+XG4gICAgICAgICAgICAgICAgPGkgY2xhc3M9XCJmYSBmYS1maWxlLW9cIj48L2k+XG4gICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZpbGUtcHJldmlldy1maWxlbmFtZVwiIHYtaHRtbD1cIm5hbWVcIj48L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmaWxlLXByZXZpZXctZmlsZXNpemVcIj4oe3tzaXplfX0pPC9kaXY+XG5cbiAgICAgICAgPGRpdj5cblxuICAgIDwvZGl2PlxuXG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IG1vbWVudCBmcm9tICdtb21lbnQnO1xuaW1wb3J0IHsgaXNGdW5jdGlvbiB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgcmVhZEZpbGUgZnJvbSAnLi4vLi4vSGVscGVycy9SZWFkRmlsZS9SZWFkRmlsZSc7XG5pbXBvcnQgUHJvZ3Jlc3NCYXIgZnJvbSAnLi4vUHJvZ3Jlc3NCYXInO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAnZmlsZS1wcmV2aWV3JyxcblxuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgICAgUHJvZ3Jlc3NCYXJcbiAgICB9LFxuXG4gICAgZGlyZWN0aXZlczoge1xuICAgICAgICByZWFkeToge1xuICAgICAgICAgICAgaW5zZXJ0ZWQoZWwsIGJpbmRpbmcpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYoaXNGdW5jdGlvbihiaW5kaW5nLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmluZGluZy52YWx1ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgNTApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhpZGUgdGhlIGNsb3NlIGJ1dHRvbiBmb3IgdGhlIHByZXZpZXdcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IE9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgaGlkZUNsb3NlOiBCb29sZWFuLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdXBsb2FkZWQgRmlsZSBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IE9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgZmlsZToge1xuICAgICAgICAgICAgdHlwZTogW09iamVjdCwgRmlsZV0sXG4gICAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBhcnJheSBvZiBtaW1lIHR5cGVzIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIHRoZVxuICAgICAgICAgKiBmaWxlIGlzIGFuIGltYWdlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgQXJyYXlcbiAgICAgICAgICovXG4gICAgICAgIGltYWdlTWltZXM6IHtcbiAgICAgICAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgICAgICAgZGVmYXVsdCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWydpbWFnZS9naWYnLCAnaW1hZ2UvcG5nJywgJ2ltYWdlL2pwZWcnLCAnaW1hZ2UvYm1wJywgJ2ltYWdlL3dlYnAnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGNvbXB1dGVkOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgZmlsZSBuYW1lXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIG5hbWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maWxlIGluc3RhbmNlb2YgRmlsZSA/IHRoaXMuZmlsZS5uYW1lIDogdGhpcy5maWxlLm9yaWdfZmlsZW5hbWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgZmlsZSBleHRlbnNpb25cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgZXh0ZW5zaW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsZSBpbnN0YW5jZW9mIEZpbGUgPyB0aGlzLmZpbGUubmFtZS5zcGxpdCgnLicpLnBvcCgpLnRvTG93ZXJDYXNlKCkgOiB0aGlzLmZpbGUuZXh0ZW5zaW9uO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGZpbGUgZm9ybWF0dGVkIHNpemVcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgc2l6ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ5dGVzVG9TaXplKHRoaXMuZmlsZSBpbnN0YW5jZW9mIEZpbGUgPyB0aGlzLmZpbGUuc2l6ZSA6IHRoaXMuZmlsZS5ieXRlcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgZmlsZSB0eXBlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHR5cGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maWxlIGluc3RhbmNlb2YgRmlsZSA/IHRoaXMuZmlsZS50eXBlIDogdGhpcy5maWxlLm1pbWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoZSBmaWxlIGFuIGltYWdlP1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBpc0ltYWdlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW1hZ2VNaW1lcy5pbmRleE9mKHRoaXMudHlwZSkgIT09IC0xO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGxhc3QgdGltZSB0aGUgZmlsZSB3YXMgbW9kaWZpZWQgKGFzIHRpbWVzdGFtcClcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgbGFzdE1vZGlmaWVkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsZSBpbnN0YW5jZW9mIEZpbGUgPyB0aGlzLmZpbGUubGFzdE1vZGlmaWVkIDogbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBsYXN0IHRpbWUgdGhlIGZpbGUgd2FzIG1vZGlmaWVkIChhcyBEYXRlKVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBsYXN0TW9kaWZpZWREYXRlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsZSBpbnN0YW5jZW9mIEZpbGUgPyB0aGlzLmZpbGUubGFzdE1vZGlmaWVkRGF0ZSA6IG51bGw7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBtZXRob2RzOiB7XG4gICAgICAgIHJlYWRGaWxlKCkge1xuICAgICAgICAgICAgaWYodGhpcy5maWxlIGluc3RhbmNlb2YgRmlsZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gbW9tZW50KCk7XG5cbiAgICAgICAgICAgICAgICByZWFkRmlsZSh0aGlzLmZpbGUsIGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZihlLmxlbmd0aENvbXB1dGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9hZGVkID0gcGFyc2VJbnQoKGUubG9hZGVkIC8gZS50b3RhbCkgKiAxMDAsIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLnRoZW4oZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW1hZ2UgPSBldmVudC50YXJnZXQucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kZW1pdCgnbG9hZGVkJywgZXZlbnQsIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9LCA2MDAgLSBtb21lbnQoKS5kaWZmKHN0YXJ0KSk7XG4gICAgICAgICAgICAgICAgfSwgZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgIFx0Ynl0ZXNUb1NpemU6IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgXHRcdHZhciBzaXplcyA9IFsnQnl0ZXMnLCAnS0InLCAnTUInLCAnR0InLCAnVEInXTtcbiAgICBcdFx0aWYgKGJ5dGVzID09IDApIHJldHVybiAnMCBCeXRlJztcbiAgICBcdFx0dmFyIGkgPSBwYXJzZUludChNYXRoLmZsb29yKE1hdGgubG9nKGJ5dGVzKSAvIE1hdGgubG9nKDEwMjQpKSk7XG4gICAgXHRcdHJldHVybiBNYXRoLnJvdW5kKGJ5dGVzIC8gTWF0aC5wb3coMTAyNCwgaSksIDIpICsgJyAnICsgc2l6ZXNbaV07XG4gICAgXHR9XG5cbiAgICB9LFxuXG4gICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxvYWRlZDogMCxcbiAgICAgICAgICAgIGltYWdlOiB0aGlzLmZpbGUudXJsXG4gICAgICAgIH07XG4gICAgfVxuXG59XG5cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cInNjc3NcIj5cbiRmaWxlLXByZXZpZXctY2xvc2Utd2lkdGg6IDFyZW0gKiAyO1xuJGZpbGUtcHJldmlldy1jbG9zZS1oZWlnaHQ6IDFyZW0gKiAyO1xuXG4uZmlsZS1wcmV2aWV3IHtcbiAgICB3aWR0aDogMTAwJTtcblxuICAgIC5maWxlLXByZXZpZXctaW5uZXIge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgfVxuXG4gICAgLmZpbGUtcHJldmlldy1jbG9zZSB7XG4gICAgICAgIHRvcDogMDtcbiAgICAgICAgcmlnaHQ6IDA7XG4gICAgICAgIHBhZGRpbmc6IDA7XG4gICAgICAgIHdpZHRoOiAyNHB4O1xuICAgICAgICBoZWlnaHQ6IDI0cHg7XG4gICAgICAgIGJhY2tncm91bmQ6IHdoaXRlO1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDEwMCU7XG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKDMzJSwgLTMzJSk7XG5cbiAgICAgICAgaSB7XG4gICAgICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgICAgICB0b3A6IDA7XG4gICAgICAgICAgICBsZWZ0OiAwO1xuICAgICAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgICAgICBmb250LXNpemU6IDI0cHg7XG4gICAgICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAuZmlsZS1wcmV2aWV3LWljb24ge1xuICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgICAgIGZvbnQtc2l6ZTogNjBweDtcbiAgICAgICAgcGFkZGluZzogMXJlbTtcbiAgICB9XG5cbiAgICAuZmlsZS1wcmV2aWV3LXRodW1ibmFpbCB7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBtYXgtd2lkdGg6IDEwMCU7XG4gICAgfVxuXG4gICAgLmZpbGUtcHJldmlldy1maWxlbmFtZSB7XG4gICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcbiAgICAgICAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XG4gICAgfVxuXG4gICAgLmZpbGUtcHJldmlldy1maWxlbmFtZSxcbiAgICAuZmlsZS1wcmV2aWV3LWZpbGVzaXplIHtcbiAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgIH1cblxufVxuXG48L3N0eWxlPlxuIiwiaW1wb3J0IEZpbGVQcmV2aWV3IGZyb20gJy4vRmlsZVByZXZpZXcnO1xuaW1wb3J0IFZ1ZUluc3RhbGxlciBmcm9tICcuLi8uLi9IZWxwZXJzL1Z1ZUluc3RhbGxlci9WdWVJbnN0YWxsZXInO1xuXG5jb25zdCBwbHVnaW4gPSBWdWVJbnN0YWxsZXIudXNlKHtcblxuICAgIGluc3RhbGwoVnVlLCBvcHRpb25zKSB7XG4gICAgICAgIFZ1ZUluc3RhbGxlci5jb21wb25lbnRzKHtcbiAgICAgICAgICAgIEZpbGVQcmV2aWV3XG4gICAgICAgIH0pO1xuICAgIH1cblxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IEZpbGVQcmV2aWV3O1xuIiwiPHRlbXBsYXRlPlxuXG4gICAgPGNvbXBvbmVudFxuICAgICAgICA6bmFtZT1cIm5hbWVcIlxuICAgICAgICA6aWQ9XCJpZFwiXG4gICAgICAgIDppcz1cIiFzZWxlY3QgPyAnaW5wdXQnIDogJ3NlbGVjdCdcIlxuICAgICAgICA6dHlwZT1cIiFzZWxlY3QgPyB0eXBlIDogZmFsc2VcIlxuICAgICAgICA6dmFsdWU9XCJ2YWx1ZVwiXG4gICAgICAgIDpwYXR0ZXJuPVwicGF0dGVyblwiXG4gICAgICAgIDpyZXF1aXJlZD1cInJlcXVpcmVkXCJcbiAgICAgICAgOnJlYWRvbmx5PVwicmVhZG9ubHlcIlxuICAgICAgICA6cGxhY2Vob2xkZXI9XCJwbGFjZWhvbGRlclwiXG4gICAgICAgIDpkaXNhYmxlZD1cImRpc2FibGVkIHx8IHJlYWRvbmx5XCJcbiAgICAgICAgOmNsYXNzPVwiJG1lcmdlQ2xhc3Nlcyhjb250cm9sQ2xhc3NlcywgY29sb3JhYmxlQ2xhc3NlcylcIlxuICAgICAgICA6YXJpYS1sYWJlbD1cImxhYmVsXCJcbiAgICAgICAgOmFyaWEtZGVzY3JpYmVkYnk9XCJpZFwiXG4gICAgICAgIHYtYmluZC1ldmVudHM9XCJiaW5kRXZlbnRzXCJcbiAgICAgICAgdi1vbjppbnB1dD1cInVwZGF0ZWRcIi8+XG5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5cbmltcG9ydCBDb2xvcmFibGUgZnJvbSAnLi4vLi4vTWl4aW5zL0NvbG9yYWJsZS9Db2xvcmFibGUnO1xuaW1wb3J0IEZvcm1Db250cm9sIGZyb20gJy4uLy4uL01peGlucy9Gb3JtQ29udHJvbC9Gb3JtQ29udHJvbCc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdmb3JtLWNvbnRyb2wnLFxuXG4gICAgbWl4aW5zOiBbXG4gICAgICAgIENvbG9yYWJsZSxcbiAgICAgICAgRm9ybUNvbnRyb2xcbiAgICBdLFxuXG4gICAgcHJvcHM6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSXMgdGhlIGVsZW1lbnQgYSBzZWxlY3Q/XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHNlbGVjdDogQm9vbGVhbixcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHR5cGUgYXR0cmlidXRlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICd0ZXh0J1xuICAgICAgICB9XG5cbiAgICB9XG5cbn1cblxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgRm9ybUNvbnRyb2wgZnJvbSAnLi9Gb3JtQ29udHJvbCc7XG5pbXBvcnQgVnVlSW5zdGFsbGVyIGZyb20gJy4uLy4uL0hlbHBlcnMvVnVlSW5zdGFsbGVyL1Z1ZUluc3RhbGxlcic7XG5cbmNvbnN0IHBsdWdpbiA9IFZ1ZUluc3RhbGxlci51c2Uoe1xuXG4gICAgaW5zdGFsbChWdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgVnVlSW5zdGFsbGVyLmNvbXBvbmVudHMoe1xuICAgICAgICAgICAgRm9ybUNvbnRyb2xcbiAgICAgICAgfSk7XG4gICAgfVxuXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgRm9ybUNvbnRyb2w7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIFczQyBTT0ZUV0FSRSBBTkQgRE9DVU1FTlQgTk9USUNFIEFORCBMSUNFTlNFLlxuICpcbiAqICBodHRwczovL3d3dy53My5vcmcvQ29uc29ydGl1bS9MZWdhbC8yMDE1L2NvcHlyaWdodC1zb2Z0d2FyZS1hbmQtZG9jdW1lbnRcbiAqXG4gKi9cblxuKGZ1bmN0aW9uKHdpbmRvdywgZG9jdW1lbnQpIHtcbid1c2Ugc3RyaWN0JztcblxuXG4vLyBFeGl0cyBlYXJseSBpZiBhbGwgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgYW5kIEludGVyc2VjdGlvbk9ic2VydmVyRW50cnlcbi8vIGZlYXR1cmVzIGFyZSBuYXRpdmVseSBzdXBwb3J0ZWQuXG5pZiAoJ0ludGVyc2VjdGlvbk9ic2VydmVyJyBpbiB3aW5kb3cgJiZcbiAgICAnSW50ZXJzZWN0aW9uT2JzZXJ2ZXJFbnRyeScgaW4gd2luZG93ICYmXG4gICAgJ2ludGVyc2VjdGlvblJhdGlvJyBpbiB3aW5kb3cuSW50ZXJzZWN0aW9uT2JzZXJ2ZXJFbnRyeS5wcm90b3R5cGUpIHtcblxuICAvLyBNaW5pbWFsIHBvbHlmaWxsIGZvciBFZGdlIDE1J3MgbGFjayBvZiBgaXNJbnRlcnNlY3RpbmdgXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL3czYy9JbnRlcnNlY3Rpb25PYnNlcnZlci9pc3N1ZXMvMjExXG4gIGlmICghKCdpc0ludGVyc2VjdGluZycgaW4gd2luZG93LkludGVyc2VjdGlvbk9ic2VydmVyRW50cnkucHJvdG90eXBlKSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuSW50ZXJzZWN0aW9uT2JzZXJ2ZXJFbnRyeS5wcm90b3R5cGUsXG4gICAgICAnaXNJbnRlcnNlY3RpbmcnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJzZWN0aW9uUmF0aW8gPiAwO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybjtcbn1cblxuXG4vKipcbiAqIEFuIEludGVyc2VjdGlvbk9ic2VydmVyIHJlZ2lzdHJ5LiBUaGlzIHJlZ2lzdHJ5IGV4aXN0cyB0byBob2xkIGEgc3Ryb25nXG4gKiByZWZlcmVuY2UgdG8gSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgaW5zdGFuY2VzIGN1cnJlbnRseSBvYnNlcnZlcmluZyBhIHRhcmdldFxuICogZWxlbWVudC4gV2l0aG91dCB0aGlzIHJlZ2lzdHJ5LCBpbnN0YW5jZXMgd2l0aG91dCBhbm90aGVyIHJlZmVyZW5jZSBtYXkgYmVcbiAqIGdhcmJhZ2UgY29sbGVjdGVkLlxuICovXG52YXIgcmVnaXN0cnkgPSBbXTtcblxuXG4vKipcbiAqIENyZWF0ZXMgdGhlIGdsb2JhbCBJbnRlcnNlY3Rpb25PYnNlcnZlckVudHJ5IGNvbnN0cnVjdG9yLlxuICogaHR0cHM6Ly93M2MuZ2l0aHViLmlvL0ludGVyc2VjdGlvbk9ic2VydmVyLyNpbnRlcnNlY3Rpb24tb2JzZXJ2ZXItZW50cnlcbiAqIEBwYXJhbSB7T2JqZWN0fSBlbnRyeSBBIGRpY3Rpb25hcnkgb2YgaW5zdGFuY2UgcHJvcGVydGllcy5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBJbnRlcnNlY3Rpb25PYnNlcnZlckVudHJ5KGVudHJ5KSB7XG4gIHRoaXMudGltZSA9IGVudHJ5LnRpbWU7XG4gIHRoaXMudGFyZ2V0ID0gZW50cnkudGFyZ2V0O1xuICB0aGlzLnJvb3RCb3VuZHMgPSBlbnRyeS5yb290Qm91bmRzO1xuICB0aGlzLmJvdW5kaW5nQ2xpZW50UmVjdCA9IGVudHJ5LmJvdW5kaW5nQ2xpZW50UmVjdDtcbiAgdGhpcy5pbnRlcnNlY3Rpb25SZWN0ID0gZW50cnkuaW50ZXJzZWN0aW9uUmVjdCB8fCBnZXRFbXB0eVJlY3QoKTtcbiAgdGhpcy5pc0ludGVyc2VjdGluZyA9ICEhZW50cnkuaW50ZXJzZWN0aW9uUmVjdDtcblxuICAvLyBDYWxjdWxhdGVzIHRoZSBpbnRlcnNlY3Rpb24gcmF0aW8uXG4gIHZhciB0YXJnZXRSZWN0ID0gdGhpcy5ib3VuZGluZ0NsaWVudFJlY3Q7XG4gIHZhciB0YXJnZXRBcmVhID0gdGFyZ2V0UmVjdC53aWR0aCAqIHRhcmdldFJlY3QuaGVpZ2h0O1xuICB2YXIgaW50ZXJzZWN0aW9uUmVjdCA9IHRoaXMuaW50ZXJzZWN0aW9uUmVjdDtcbiAgdmFyIGludGVyc2VjdGlvbkFyZWEgPSBpbnRlcnNlY3Rpb25SZWN0LndpZHRoICogaW50ZXJzZWN0aW9uUmVjdC5oZWlnaHQ7XG5cbiAgLy8gU2V0cyBpbnRlcnNlY3Rpb24gcmF0aW8uXG4gIGlmICh0YXJnZXRBcmVhKSB7XG4gICAgdGhpcy5pbnRlcnNlY3Rpb25SYXRpbyA9IGludGVyc2VjdGlvbkFyZWEgLyB0YXJnZXRBcmVhO1xuICB9IGVsc2Uge1xuICAgIC8vIElmIGFyZWEgaXMgemVybyBhbmQgaXMgaW50ZXJzZWN0aW5nLCBzZXRzIHRvIDEsIG90aGVyd2lzZSB0byAwXG4gICAgdGhpcy5pbnRlcnNlY3Rpb25SYXRpbyA9IHRoaXMuaXNJbnRlcnNlY3RpbmcgPyAxIDogMDtcbiAgfVxufVxuXG5cbi8qKlxuICogQ3JlYXRlcyB0aGUgZ2xvYmFsIEludGVyc2VjdGlvbk9ic2VydmVyIGNvbnN0cnVjdG9yLlxuICogaHR0cHM6Ly93M2MuZ2l0aHViLmlvL0ludGVyc2VjdGlvbk9ic2VydmVyLyNpbnRlcnNlY3Rpb24tb2JzZXJ2ZXItaW50ZXJmYWNlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gYmUgaW52b2tlZCBhZnRlciBpbnRlcnNlY3Rpb25cbiAqICAgICBjaGFuZ2VzIGhhdmUgcXVldWVkLiBUaGUgZnVuY3Rpb24gaXMgbm90IGludm9rZWQgaWYgdGhlIHF1ZXVlIGhhc1xuICogICAgIGJlZW4gZW1wdGllZCBieSBjYWxsaW5nIHRoZSBgdGFrZVJlY29yZHNgIG1ldGhvZC5cbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0X29wdGlvbnMgT3B0aW9uYWwgY29uZmlndXJhdGlvbiBvcHRpb25zLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEludGVyc2VjdGlvbk9ic2VydmVyKGNhbGxiYWNrLCBvcHRfb3B0aW9ucykge1xuXG4gIHZhciBvcHRpb25zID0gb3B0X29wdGlvbnMgfHwge307XG5cbiAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLnJvb3QgJiYgb3B0aW9ucy5yb290Lm5vZGVUeXBlICE9IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Jvb3QgbXVzdCBiZSBhbiBFbGVtZW50Jyk7XG4gIH1cblxuICAvLyBCaW5kcyBhbmQgdGhyb3R0bGVzIGB0aGlzLl9jaGVja0ZvckludGVyc2VjdGlvbnNgLlxuICB0aGlzLl9jaGVja0ZvckludGVyc2VjdGlvbnMgPSB0aHJvdHRsZShcbiAgICAgIHRoaXMuX2NoZWNrRm9ySW50ZXJzZWN0aW9ucy5iaW5kKHRoaXMpLCB0aGlzLlRIUk9UVExFX1RJTUVPVVQpO1xuXG4gIC8vIFByaXZhdGUgcHJvcGVydGllcy5cbiAgdGhpcy5fY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgdGhpcy5fb2JzZXJ2YXRpb25UYXJnZXRzID0gW107XG4gIHRoaXMuX3F1ZXVlZEVudHJpZXMgPSBbXTtcbiAgdGhpcy5fcm9vdE1hcmdpblZhbHVlcyA9IHRoaXMuX3BhcnNlUm9vdE1hcmdpbihvcHRpb25zLnJvb3RNYXJnaW4pO1xuXG4gIC8vIFB1YmxpYyBwcm9wZXJ0aWVzLlxuICB0aGlzLnRocmVzaG9sZHMgPSB0aGlzLl9pbml0VGhyZXNob2xkcyhvcHRpb25zLnRocmVzaG9sZCk7XG4gIHRoaXMucm9vdCA9IG9wdGlvbnMucm9vdCB8fCBudWxsO1xuICB0aGlzLnJvb3RNYXJnaW4gPSB0aGlzLl9yb290TWFyZ2luVmFsdWVzLm1hcChmdW5jdGlvbihtYXJnaW4pIHtcbiAgICByZXR1cm4gbWFyZ2luLnZhbHVlICsgbWFyZ2luLnVuaXQ7XG4gIH0pLmpvaW4oJyAnKTtcbn1cblxuXG4vKipcbiAqIFRoZSBtaW5pbXVtIGludGVydmFsIHdpdGhpbiB3aGljaCB0aGUgZG9jdW1lbnQgd2lsbCBiZSBjaGVja2VkIGZvclxuICogaW50ZXJzZWN0aW9uIGNoYW5nZXMuXG4gKi9cbkludGVyc2VjdGlvbk9ic2VydmVyLnByb3RvdHlwZS5USFJPVFRMRV9USU1FT1VUID0gMTAwO1xuXG5cbi8qKlxuICogVGhlIGZyZXF1ZW5jeSBpbiB3aGljaCB0aGUgcG9seWZpbGwgcG9sbHMgZm9yIGludGVyc2VjdGlvbiBjaGFuZ2VzLlxuICogdGhpcyBjYW4gYmUgdXBkYXRlZCBvbiBhIHBlciBpbnN0YW5jZSBiYXNpcyBhbmQgbXVzdCBiZSBzZXQgcHJpb3IgdG9cbiAqIGNhbGxpbmcgYG9ic2VydmVgIG9uIHRoZSBmaXJzdCB0YXJnZXQuXG4gKi9cbkludGVyc2VjdGlvbk9ic2VydmVyLnByb3RvdHlwZS5QT0xMX0lOVEVSVkFMID0gbnVsbDtcblxuLyoqXG4gKiBVc2UgYSBtdXRhdGlvbiBvYnNlcnZlciBvbiB0aGUgcm9vdCBlbGVtZW50XG4gKiB0byBkZXRlY3QgaW50ZXJzZWN0aW9uIGNoYW5nZXMuXG4gKi9cbkludGVyc2VjdGlvbk9ic2VydmVyLnByb3RvdHlwZS5VU0VfTVVUQVRJT05fT0JTRVJWRVIgPSB0cnVlO1xuXG5cbi8qKlxuICogU3RhcnRzIG9ic2VydmluZyBhIHRhcmdldCBlbGVtZW50IGZvciBpbnRlcnNlY3Rpb24gY2hhbmdlcyBiYXNlZCBvblxuICogdGhlIHRocmVzaG9sZHMgdmFsdWVzLlxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgVGhlIERPTSBlbGVtZW50IHRvIG9ic2VydmUuXG4gKi9cbkludGVyc2VjdGlvbk9ic2VydmVyLnByb3RvdHlwZS5vYnNlcnZlID0gZnVuY3Rpb24odGFyZ2V0KSB7XG4gIHZhciBpc1RhcmdldEFscmVhZHlPYnNlcnZlZCA9IHRoaXMuX29ic2VydmF0aW9uVGFyZ2V0cy5zb21lKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICByZXR1cm4gaXRlbS5lbGVtZW50ID09IHRhcmdldDtcbiAgfSk7XG5cbiAgaWYgKGlzVGFyZ2V0QWxyZWFkeU9ic2VydmVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCEodGFyZ2V0ICYmIHRhcmdldC5ub2RlVHlwZSA9PSAxKSkge1xuICAgIHRocm93IG5ldyBFcnJvcigndGFyZ2V0IG11c3QgYmUgYW4gRWxlbWVudCcpO1xuICB9XG5cbiAgdGhpcy5fcmVnaXN0ZXJJbnN0YW5jZSgpO1xuICB0aGlzLl9vYnNlcnZhdGlvblRhcmdldHMucHVzaCh7ZWxlbWVudDogdGFyZ2V0LCBlbnRyeTogbnVsbH0pO1xuICB0aGlzLl9tb25pdG9ySW50ZXJzZWN0aW9ucygpO1xuICB0aGlzLl9jaGVja0ZvckludGVyc2VjdGlvbnMoKTtcbn07XG5cblxuLyoqXG4gKiBTdG9wcyBvYnNlcnZpbmcgYSB0YXJnZXQgZWxlbWVudCBmb3IgaW50ZXJzZWN0aW9uIGNoYW5nZXMuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCBUaGUgRE9NIGVsZW1lbnQgdG8gb2JzZXJ2ZS5cbiAqL1xuSW50ZXJzZWN0aW9uT2JzZXJ2ZXIucHJvdG90eXBlLnVub2JzZXJ2ZSA9IGZ1bmN0aW9uKHRhcmdldCkge1xuICB0aGlzLl9vYnNlcnZhdGlvblRhcmdldHMgPVxuICAgICAgdGhpcy5fb2JzZXJ2YXRpb25UYXJnZXRzLmZpbHRlcihmdW5jdGlvbihpdGVtKSB7XG5cbiAgICByZXR1cm4gaXRlbS5lbGVtZW50ICE9IHRhcmdldDtcbiAgfSk7XG4gIGlmICghdGhpcy5fb2JzZXJ2YXRpb25UYXJnZXRzLmxlbmd0aCkge1xuICAgIHRoaXMuX3VubW9uaXRvckludGVyc2VjdGlvbnMoKTtcbiAgICB0aGlzLl91bnJlZ2lzdGVySW5zdGFuY2UoKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIFN0b3BzIG9ic2VydmluZyBhbGwgdGFyZ2V0IGVsZW1lbnRzIGZvciBpbnRlcnNlY3Rpb24gY2hhbmdlcy5cbiAqL1xuSW50ZXJzZWN0aW9uT2JzZXJ2ZXIucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fb2JzZXJ2YXRpb25UYXJnZXRzID0gW107XG4gIHRoaXMuX3VubW9uaXRvckludGVyc2VjdGlvbnMoKTtcbiAgdGhpcy5fdW5yZWdpc3Rlckluc3RhbmNlKCk7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyBhbnkgcXVldWUgZW50cmllcyB0aGF0IGhhdmUgbm90IHlldCBiZWVuIHJlcG9ydGVkIHRvIHRoZVxuICogY2FsbGJhY2sgYW5kIGNsZWFycyB0aGUgcXVldWUuIFRoaXMgY2FuIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCB0aGVcbiAqIGNhbGxiYWNrIHRvIG9idGFpbiB0aGUgYWJzb2x1dGUgbW9zdCB1cC10by1kYXRlIGludGVyc2VjdGlvbiBpbmZvcm1hdGlvbi5cbiAqIEByZXR1cm4ge0FycmF5fSBUaGUgY3VycmVudGx5IHF1ZXVlZCBlbnRyaWVzLlxuICovXG5JbnRlcnNlY3Rpb25PYnNlcnZlci5wcm90b3R5cGUudGFrZVJlY29yZHMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlY29yZHMgPSB0aGlzLl9xdWV1ZWRFbnRyaWVzLnNsaWNlKCk7XG4gIHRoaXMuX3F1ZXVlZEVudHJpZXMgPSBbXTtcbiAgcmV0dXJuIHJlY29yZHM7XG59O1xuXG5cbi8qKlxuICogQWNjZXB0cyB0aGUgdGhyZXNob2xkIHZhbHVlIGZyb20gdGhlIHVzZXIgY29uZmlndXJhdGlvbiBvYmplY3QgYW5kXG4gKiByZXR1cm5zIGEgc29ydGVkIGFycmF5IG9mIHVuaXF1ZSB0aHJlc2hvbGQgdmFsdWVzLiBJZiBhIHZhbHVlIGlzIG5vdFxuICogYmV0d2VlbiAwIGFuZCAxIGFuZCBlcnJvciBpcyB0aHJvd24uXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxudW1iZXI9fSBvcHRfdGhyZXNob2xkIEFuIG9wdGlvbmFsIHRocmVzaG9sZCB2YWx1ZSBvclxuICogICAgIGEgbGlzdCBvZiB0aHJlc2hvbGQgdmFsdWVzLCBkZWZhdWx0aW5nIHRvIFswXS5cbiAqIEByZXR1cm4ge0FycmF5fSBBIHNvcnRlZCBsaXN0IG9mIHVuaXF1ZSBhbmQgdmFsaWQgdGhyZXNob2xkIHZhbHVlcy5cbiAqL1xuSW50ZXJzZWN0aW9uT2JzZXJ2ZXIucHJvdG90eXBlLl9pbml0VGhyZXNob2xkcyA9IGZ1bmN0aW9uKG9wdF90aHJlc2hvbGQpIHtcbiAgdmFyIHRocmVzaG9sZCA9IG9wdF90aHJlc2hvbGQgfHwgWzBdO1xuICBpZiAoIUFycmF5LmlzQXJyYXkodGhyZXNob2xkKSkgdGhyZXNob2xkID0gW3RocmVzaG9sZF07XG5cbiAgcmV0dXJuIHRocmVzaG9sZC5zb3J0KCkuZmlsdGVyKGZ1bmN0aW9uKHQsIGksIGEpIHtcbiAgICBpZiAodHlwZW9mIHQgIT0gJ251bWJlcicgfHwgaXNOYU4odCkgfHwgdCA8IDAgfHwgdCA+IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndGhyZXNob2xkIG11c3QgYmUgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxIGluY2x1c2l2ZWx5Jyk7XG4gICAgfVxuICAgIHJldHVybiB0ICE9PSBhW2kgLSAxXTtcbiAgfSk7XG59O1xuXG5cbi8qKlxuICogQWNjZXB0cyB0aGUgcm9vdE1hcmdpbiB2YWx1ZSBmcm9tIHRoZSB1c2VyIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gKiBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiB0aGUgZm91ciBtYXJnaW4gdmFsdWVzIGFzIGFuIG9iamVjdCBjb250YWluaW5nXG4gKiB0aGUgdmFsdWUgYW5kIHVuaXQgcHJvcGVydGllcy4gSWYgYW55IG9mIHRoZSB2YWx1ZXMgYXJlIG5vdCBwcm9wZXJseVxuICogZm9ybWF0dGVkIG9yIHVzZSBhIHVuaXQgb3RoZXIgdGhhbiBweCBvciAlLCBhbmQgZXJyb3IgaXMgdGhyb3duLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X3Jvb3RNYXJnaW4gQW4gb3B0aW9uYWwgcm9vdE1hcmdpbiB2YWx1ZSxcbiAqICAgICBkZWZhdWx0aW5nIHRvICcwcHgnLlxuICogQHJldHVybiB7QXJyYXk8T2JqZWN0Pn0gQW4gYXJyYXkgb2YgbWFyZ2luIG9iamVjdHMgd2l0aCB0aGUga2V5c1xuICogICAgIHZhbHVlIGFuZCB1bml0LlxuICovXG5JbnRlcnNlY3Rpb25PYnNlcnZlci5wcm90b3R5cGUuX3BhcnNlUm9vdE1hcmdpbiA9IGZ1bmN0aW9uKG9wdF9yb290TWFyZ2luKSB7XG4gIHZhciBtYXJnaW5TdHJpbmcgPSBvcHRfcm9vdE1hcmdpbiB8fCAnMHB4JztcbiAgdmFyIG1hcmdpbnMgPSBtYXJnaW5TdHJpbmcuc3BsaXQoL1xccysvKS5tYXAoZnVuY3Rpb24obWFyZ2luKSB7XG4gICAgdmFyIHBhcnRzID0gL14oLT9cXGQqXFwuP1xcZCspKHB4fCUpJC8uZXhlYyhtYXJnaW4pO1xuICAgIGlmICghcGFydHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncm9vdE1hcmdpbiBtdXN0IGJlIHNwZWNpZmllZCBpbiBwaXhlbHMgb3IgcGVyY2VudCcpO1xuICAgIH1cbiAgICByZXR1cm4ge3ZhbHVlOiBwYXJzZUZsb2F0KHBhcnRzWzFdKSwgdW5pdDogcGFydHNbMl19O1xuICB9KTtcblxuICAvLyBIYW5kbGVzIHNob3J0aGFuZC5cbiAgbWFyZ2luc1sxXSA9IG1hcmdpbnNbMV0gfHwgbWFyZ2luc1swXTtcbiAgbWFyZ2luc1syXSA9IG1hcmdpbnNbMl0gfHwgbWFyZ2luc1swXTtcbiAgbWFyZ2luc1szXSA9IG1hcmdpbnNbM10gfHwgbWFyZ2luc1sxXTtcblxuICByZXR1cm4gbWFyZ2lucztcbn07XG5cblxuLyoqXG4gKiBTdGFydHMgcG9sbGluZyBmb3IgaW50ZXJzZWN0aW9uIGNoYW5nZXMgaWYgdGhlIHBvbGxpbmcgaXMgbm90IGFscmVhZHlcbiAqIGhhcHBlbmluZywgYW5kIGlmIHRoZSBwYWdlJ3MgdmlzaWJpbHR5IHN0YXRlIGlzIHZpc2libGUuXG4gKiBAcHJpdmF0ZVxuICovXG5JbnRlcnNlY3Rpb25PYnNlcnZlci5wcm90b3R5cGUuX21vbml0b3JJbnRlcnNlY3Rpb25zID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5fbW9uaXRvcmluZ0ludGVyc2VjdGlvbnMpIHtcbiAgICB0aGlzLl9tb25pdG9yaW5nSW50ZXJzZWN0aW9ucyA9IHRydWU7XG5cbiAgICAvLyBJZiBhIHBvbGwgaW50ZXJ2YWwgaXMgc2V0LCB1c2UgcG9sbGluZyBpbnN0ZWFkIG9mIGxpc3RlbmluZyB0b1xuICAgIC8vIHJlc2l6ZSBhbmQgc2Nyb2xsIGV2ZW50cyBvciBET00gbXV0YXRpb25zLlxuICAgIGlmICh0aGlzLlBPTExfSU5URVJWQUwpIHtcbiAgICAgIHRoaXMuX21vbml0b3JpbmdJbnRlcnZhbCA9IHNldEludGVydmFsKFxuICAgICAgICAgIHRoaXMuX2NoZWNrRm9ySW50ZXJzZWN0aW9ucywgdGhpcy5QT0xMX0lOVEVSVkFMKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBhZGRFdmVudCh3aW5kb3csICdyZXNpemUnLCB0aGlzLl9jaGVja0ZvckludGVyc2VjdGlvbnMsIHRydWUpO1xuICAgICAgYWRkRXZlbnQoZG9jdW1lbnQsICdzY3JvbGwnLCB0aGlzLl9jaGVja0ZvckludGVyc2VjdGlvbnMsIHRydWUpO1xuXG4gICAgICBpZiAodGhpcy5VU0VfTVVUQVRJT05fT0JTRVJWRVIgJiYgJ011dGF0aW9uT2JzZXJ2ZXInIGluIHdpbmRvdykge1xuICAgICAgICB0aGlzLl9kb21PYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHRoaXMuX2NoZWNrRm9ySW50ZXJzZWN0aW9ucyk7XG4gICAgICAgIHRoaXMuX2RvbU9ic2VydmVyLm9ic2VydmUoZG9jdW1lbnQsIHtcbiAgICAgICAgICBhdHRyaWJ1dGVzOiB0cnVlLFxuICAgICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlLFxuICAgICAgICAgIHN1YnRyZWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5cbi8qKlxuICogU3RvcHMgcG9sbGluZyBmb3IgaW50ZXJzZWN0aW9uIGNoYW5nZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5JbnRlcnNlY3Rpb25PYnNlcnZlci5wcm90b3R5cGUuX3VubW9uaXRvckludGVyc2VjdGlvbnMgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX21vbml0b3JpbmdJbnRlcnNlY3Rpb25zKSB7XG4gICAgdGhpcy5fbW9uaXRvcmluZ0ludGVyc2VjdGlvbnMgPSBmYWxzZTtcblxuICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fbW9uaXRvcmluZ0ludGVydmFsKTtcbiAgICB0aGlzLl9tb25pdG9yaW5nSW50ZXJ2YWwgPSBudWxsO1xuXG4gICAgcmVtb3ZlRXZlbnQod2luZG93LCAncmVzaXplJywgdGhpcy5fY2hlY2tGb3JJbnRlcnNlY3Rpb25zLCB0cnVlKTtcbiAgICByZW1vdmVFdmVudChkb2N1bWVudCwgJ3Njcm9sbCcsIHRoaXMuX2NoZWNrRm9ySW50ZXJzZWN0aW9ucywgdHJ1ZSk7XG5cbiAgICBpZiAodGhpcy5fZG9tT2JzZXJ2ZXIpIHtcbiAgICAgIHRoaXMuX2RvbU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgIHRoaXMuX2RvbU9ic2VydmVyID0gbnVsbDtcbiAgICB9XG4gIH1cbn07XG5cblxuLyoqXG4gKiBTY2FucyBlYWNoIG9ic2VydmF0aW9uIHRhcmdldCBmb3IgaW50ZXJzZWN0aW9uIGNoYW5nZXMgYW5kIGFkZHMgdGhlbVxuICogdG8gdGhlIGludGVybmFsIGVudHJpZXMgcXVldWUuIElmIG5ldyBlbnRyaWVzIGFyZSBmb3VuZCwgaXRcbiAqIHNjaGVkdWxlcyB0aGUgY2FsbGJhY2sgdG8gYmUgaW52b2tlZC5cbiAqIEBwcml2YXRlXG4gKi9cbkludGVyc2VjdGlvbk9ic2VydmVyLnByb3RvdHlwZS5fY2hlY2tGb3JJbnRlcnNlY3Rpb25zID0gZnVuY3Rpb24oKSB7XG4gIHZhciByb290SXNJbkRvbSA9IHRoaXMuX3Jvb3RJc0luRG9tKCk7XG4gIHZhciByb290UmVjdCA9IHJvb3RJc0luRG9tID8gdGhpcy5fZ2V0Um9vdFJlY3QoKSA6IGdldEVtcHR5UmVjdCgpO1xuXG4gIHRoaXMuX29ic2VydmF0aW9uVGFyZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICB2YXIgdGFyZ2V0ID0gaXRlbS5lbGVtZW50O1xuICAgIHZhciB0YXJnZXRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHRhcmdldCk7XG4gICAgdmFyIHJvb3RDb250YWluc1RhcmdldCA9IHRoaXMuX3Jvb3RDb250YWluc1RhcmdldCh0YXJnZXQpO1xuICAgIHZhciBvbGRFbnRyeSA9IGl0ZW0uZW50cnk7XG4gICAgdmFyIGludGVyc2VjdGlvblJlY3QgPSByb290SXNJbkRvbSAmJiByb290Q29udGFpbnNUYXJnZXQgJiZcbiAgICAgICAgdGhpcy5fY29tcHV0ZVRhcmdldEFuZFJvb3RJbnRlcnNlY3Rpb24odGFyZ2V0LCByb290UmVjdCk7XG5cbiAgICB2YXIgbmV3RW50cnkgPSBpdGVtLmVudHJ5ID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyRW50cnkoe1xuICAgICAgdGltZTogbm93KCksXG4gICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgIGJvdW5kaW5nQ2xpZW50UmVjdDogdGFyZ2V0UmVjdCxcbiAgICAgIHJvb3RCb3VuZHM6IHJvb3RSZWN0LFxuICAgICAgaW50ZXJzZWN0aW9uUmVjdDogaW50ZXJzZWN0aW9uUmVjdFxuICAgIH0pO1xuXG4gICAgaWYgKCFvbGRFbnRyeSkge1xuICAgICAgdGhpcy5fcXVldWVkRW50cmllcy5wdXNoKG5ld0VudHJ5KTtcbiAgICB9IGVsc2UgaWYgKHJvb3RJc0luRG9tICYmIHJvb3RDb250YWluc1RhcmdldCkge1xuICAgICAgLy8gSWYgdGhlIG5ldyBlbnRyeSBpbnRlcnNlY3Rpb24gcmF0aW8gaGFzIGNyb3NzZWQgYW55IG9mIHRoZVxuICAgICAgLy8gdGhyZXNob2xkcywgYWRkIGEgbmV3IGVudHJ5LlxuICAgICAgaWYgKHRoaXMuX2hhc0Nyb3NzZWRUaHJlc2hvbGQob2xkRW50cnksIG5ld0VudHJ5KSkge1xuICAgICAgICB0aGlzLl9xdWV1ZWRFbnRyaWVzLnB1c2gobmV3RW50cnkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB0aGUgcm9vdCBpcyBub3QgaW4gdGhlIERPTSBvciB0YXJnZXQgaXMgbm90IGNvbnRhaW5lZCB3aXRoaW5cbiAgICAgIC8vIHJvb3QgYnV0IHRoZSBwcmV2aW91cyBlbnRyeSBmb3IgdGhpcyB0YXJnZXQgaGFkIGFuIGludGVyc2VjdGlvbixcbiAgICAgIC8vIGFkZCBhIG5ldyByZWNvcmQgaW5kaWNhdGluZyByZW1vdmFsLlxuICAgICAgaWYgKG9sZEVudHJ5ICYmIG9sZEVudHJ5LmlzSW50ZXJzZWN0aW5nKSB7XG4gICAgICAgIHRoaXMuX3F1ZXVlZEVudHJpZXMucHVzaChuZXdFbnRyeSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB0aGlzKTtcblxuICBpZiAodGhpcy5fcXVldWVkRW50cmllcy5sZW5ndGgpIHtcbiAgICB0aGlzLl9jYWxsYmFjayh0aGlzLnRha2VSZWNvcmRzKCksIHRoaXMpO1xuICB9XG59O1xuXG5cbi8qKlxuICogQWNjZXB0cyBhIHRhcmdldCBhbmQgcm9vdCByZWN0IGNvbXB1dGVzIHRoZSBpbnRlcnNlY3Rpb24gYmV0d2VlbiB0aGVuXG4gKiBmb2xsb3dpbmcgdGhlIGFsZ29yaXRobSBpbiB0aGUgc3BlYy5cbiAqIFRPRE8ocGhpbGlwd2FsdG9uKTogYXQgdGhpcyB0aW1lIGNsaXAtcGF0aCBpcyBub3QgY29uc2lkZXJlZC5cbiAqIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9JbnRlcnNlY3Rpb25PYnNlcnZlci8jY2FsY3VsYXRlLWludGVyc2VjdGlvbi1yZWN0LWFsZ29cbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IFRoZSB0YXJnZXQgRE9NIGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSByb290UmVjdCBUaGUgYm91bmRpbmcgcmVjdCBvZiB0aGUgcm9vdCBhZnRlciBiZWluZ1xuICogICAgIGV4cGFuZGVkIGJ5IHRoZSByb290TWFyZ2luIHZhbHVlLlxuICogQHJldHVybiB7P09iamVjdH0gVGhlIGZpbmFsIGludGVyc2VjdGlvbiByZWN0IG9iamVjdCBvciB1bmRlZmluZWQgaWYgbm9cbiAqICAgICBpbnRlcnNlY3Rpb24gaXMgZm91bmQuXG4gKiBAcHJpdmF0ZVxuICovXG5JbnRlcnNlY3Rpb25PYnNlcnZlci5wcm90b3R5cGUuX2NvbXB1dGVUYXJnZXRBbmRSb290SW50ZXJzZWN0aW9uID1cbiAgICBmdW5jdGlvbih0YXJnZXQsIHJvb3RSZWN0KSB7XG5cbiAgLy8gSWYgdGhlIGVsZW1lbnQgaXNuJ3QgZGlzcGxheWVkLCBhbiBpbnRlcnNlY3Rpb24gY2FuJ3QgaGFwcGVuLlxuICBpZiAod2luZG93LmdldENvbXB1dGVkU3R5bGUodGFyZ2V0KS5kaXNwbGF5ID09ICdub25lJykgcmV0dXJuO1xuXG4gIHZhciB0YXJnZXRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHRhcmdldCk7XG4gIHZhciBpbnRlcnNlY3Rpb25SZWN0ID0gdGFyZ2V0UmVjdDtcbiAgdmFyIHBhcmVudCA9IGdldFBhcmVudE5vZGUodGFyZ2V0KTtcbiAgdmFyIGF0Um9vdCA9IGZhbHNlO1xuXG4gIHdoaWxlICghYXRSb290KSB7XG4gICAgdmFyIHBhcmVudFJlY3QgPSBudWxsO1xuICAgIHZhciBwYXJlbnRDb21wdXRlZFN0eWxlID0gcGFyZW50Lm5vZGVUeXBlID09IDEgP1xuICAgICAgICB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShwYXJlbnQpIDoge307XG5cbiAgICAvLyBJZiB0aGUgcGFyZW50IGlzbid0IGRpc3BsYXllZCwgYW4gaW50ZXJzZWN0aW9uIGNhbid0IGhhcHBlbi5cbiAgICBpZiAocGFyZW50Q29tcHV0ZWRTdHlsZS5kaXNwbGF5ID09ICdub25lJykgcmV0dXJuO1xuXG4gICAgaWYgKHBhcmVudCA9PSB0aGlzLnJvb3QgfHwgcGFyZW50ID09IGRvY3VtZW50KSB7XG4gICAgICBhdFJvb3QgPSB0cnVlO1xuICAgICAgcGFyZW50UmVjdCA9IHJvb3RSZWN0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB0aGUgZWxlbWVudCBoYXMgYSBub24tdmlzaWJsZSBvdmVyZmxvdywgYW5kIGl0J3Mgbm90IHRoZSA8Ym9keT5cbiAgICAgIC8vIG9yIDxodG1sPiBlbGVtZW50LCB1cGRhdGUgdGhlIGludGVyc2VjdGlvbiByZWN0LlxuICAgICAgLy8gTm90ZTogPGJvZHk+IGFuZCA8aHRtbD4gY2Fubm90IGJlIGNsaXBwZWQgdG8gYSByZWN0IHRoYXQncyBub3QgYWxzb1xuICAgICAgLy8gdGhlIGRvY3VtZW50IHJlY3QsIHNvIG5vIG5lZWQgdG8gY29tcHV0ZSBhIG5ldyBpbnRlcnNlY3Rpb24uXG4gICAgICBpZiAocGFyZW50ICE9IGRvY3VtZW50LmJvZHkgJiZcbiAgICAgICAgICBwYXJlbnQgIT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmXG4gICAgICAgICAgcGFyZW50Q29tcHV0ZWRTdHlsZS5vdmVyZmxvdyAhPSAndmlzaWJsZScpIHtcbiAgICAgICAgcGFyZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChwYXJlbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIGVpdGhlciBvZiB0aGUgYWJvdmUgY29uZGl0aW9uYWxzIHNldCBhIG5ldyBwYXJlbnRSZWN0LFxuICAgIC8vIGNhbGN1bGF0ZSBuZXcgaW50ZXJzZWN0aW9uIGRhdGEuXG4gICAgaWYgKHBhcmVudFJlY3QpIHtcbiAgICAgIGludGVyc2VjdGlvblJlY3QgPSBjb21wdXRlUmVjdEludGVyc2VjdGlvbihwYXJlbnRSZWN0LCBpbnRlcnNlY3Rpb25SZWN0KTtcblxuICAgICAgaWYgKCFpbnRlcnNlY3Rpb25SZWN0KSBicmVhaztcbiAgICB9XG4gICAgcGFyZW50ID0gZ2V0UGFyZW50Tm9kZShwYXJlbnQpO1xuICB9XG4gIHJldHVybiBpbnRlcnNlY3Rpb25SZWN0O1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIHJvb3QgcmVjdCBhZnRlciBiZWluZyBleHBhbmRlZCBieSB0aGUgcm9vdE1hcmdpbiB2YWx1ZS5cbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIGV4cGFuZGVkIHJvb3QgcmVjdC5cbiAqIEBwcml2YXRlXG4gKi9cbkludGVyc2VjdGlvbk9ic2VydmVyLnByb3RvdHlwZS5fZ2V0Um9vdFJlY3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJvb3RSZWN0O1xuICBpZiAodGhpcy5yb290KSB7XG4gICAgcm9vdFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QodGhpcy5yb290KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBVc2UgPGh0bWw+Lzxib2R5PiBpbnN0ZWFkIG9mIHdpbmRvdyBzaW5jZSBzY3JvbGwgYmFycyBhZmZlY3Qgc2l6ZS5cbiAgICB2YXIgaHRtbCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICB2YXIgYm9keSA9IGRvY3VtZW50LmJvZHk7XG4gICAgcm9vdFJlY3QgPSB7XG4gICAgICB0b3A6IDAsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgcmlnaHQ6IGh0bWwuY2xpZW50V2lkdGggfHwgYm9keS5jbGllbnRXaWR0aCxcbiAgICAgIHdpZHRoOiBodG1sLmNsaWVudFdpZHRoIHx8IGJvZHkuY2xpZW50V2lkdGgsXG4gICAgICBib3R0b206IGh0bWwuY2xpZW50SGVpZ2h0IHx8IGJvZHkuY2xpZW50SGVpZ2h0LFxuICAgICAgaGVpZ2h0OiBodG1sLmNsaWVudEhlaWdodCB8fCBib2R5LmNsaWVudEhlaWdodFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2V4cGFuZFJlY3RCeVJvb3RNYXJnaW4ocm9vdFJlY3QpO1xufTtcblxuXG4vKipcbiAqIEFjY2VwdHMgYSByZWN0IGFuZCBleHBhbmRzIGl0IGJ5IHRoZSByb290TWFyZ2luIHZhbHVlLlxuICogQHBhcmFtIHtPYmplY3R9IHJlY3QgVGhlIHJlY3Qgb2JqZWN0IHRvIGV4cGFuZC5cbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIGV4cGFuZGVkIHJlY3QuXG4gKiBAcHJpdmF0ZVxuICovXG5JbnRlcnNlY3Rpb25PYnNlcnZlci5wcm90b3R5cGUuX2V4cGFuZFJlY3RCeVJvb3RNYXJnaW4gPSBmdW5jdGlvbihyZWN0KSB7XG4gIHZhciBtYXJnaW5zID0gdGhpcy5fcm9vdE1hcmdpblZhbHVlcy5tYXAoZnVuY3Rpb24obWFyZ2luLCBpKSB7XG4gICAgcmV0dXJuIG1hcmdpbi51bml0ID09ICdweCcgPyBtYXJnaW4udmFsdWUgOlxuICAgICAgICBtYXJnaW4udmFsdWUgKiAoaSAlIDIgPyByZWN0LndpZHRoIDogcmVjdC5oZWlnaHQpIC8gMTAwO1xuICB9KTtcbiAgdmFyIG5ld1JlY3QgPSB7XG4gICAgdG9wOiByZWN0LnRvcCAtIG1hcmdpbnNbMF0sXG4gICAgcmlnaHQ6IHJlY3QucmlnaHQgKyBtYXJnaW5zWzFdLFxuICAgIGJvdHRvbTogcmVjdC5ib3R0b20gKyBtYXJnaW5zWzJdLFxuICAgIGxlZnQ6IHJlY3QubGVmdCAtIG1hcmdpbnNbM11cbiAgfTtcbiAgbmV3UmVjdC53aWR0aCA9IG5ld1JlY3QucmlnaHQgLSBuZXdSZWN0LmxlZnQ7XG4gIG5ld1JlY3QuaGVpZ2h0ID0gbmV3UmVjdC5ib3R0b20gLSBuZXdSZWN0LnRvcDtcblxuICByZXR1cm4gbmV3UmVjdDtcbn07XG5cblxuLyoqXG4gKiBBY2NlcHRzIGFuIG9sZCBhbmQgbmV3IGVudHJ5IGFuZCByZXR1cm5zIHRydWUgaWYgYXQgbGVhc3Qgb25lIG9mIHRoZVxuICogdGhyZXNob2xkIHZhbHVlcyBoYXMgYmVlbiBjcm9zc2VkLlxuICogQHBhcmFtIHs/SW50ZXJzZWN0aW9uT2JzZXJ2ZXJFbnRyeX0gb2xkRW50cnkgVGhlIHByZXZpb3VzIGVudHJ5IGZvciBhXG4gKiAgICBwYXJ0aWN1bGFyIHRhcmdldCBlbGVtZW50IG9yIG51bGwgaWYgbm8gcHJldmlvdXMgZW50cnkgZXhpc3RzLlxuICogQHBhcmFtIHtJbnRlcnNlY3Rpb25PYnNlcnZlckVudHJ5fSBuZXdFbnRyeSBUaGUgY3VycmVudCBlbnRyeSBmb3IgYVxuICogICAgcGFydGljdWxhciB0YXJnZXQgZWxlbWVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBhIGFueSB0aHJlc2hvbGQgaGFzIGJlZW4gY3Jvc3NlZC5cbiAqIEBwcml2YXRlXG4gKi9cbkludGVyc2VjdGlvbk9ic2VydmVyLnByb3RvdHlwZS5faGFzQ3Jvc3NlZFRocmVzaG9sZCA9XG4gICAgZnVuY3Rpb24ob2xkRW50cnksIG5ld0VudHJ5KSB7XG5cbiAgLy8gVG8gbWFrZSBjb21wYXJpbmcgZWFzaWVyLCBhbiBlbnRyeSB0aGF0IGhhcyBhIHJhdGlvIG9mIDBcbiAgLy8gYnV0IGRvZXMgbm90IGFjdHVhbGx5IGludGVyc2VjdCBpcyBnaXZlbiBhIHZhbHVlIG9mIC0xXG4gIHZhciBvbGRSYXRpbyA9IG9sZEVudHJ5ICYmIG9sZEVudHJ5LmlzSW50ZXJzZWN0aW5nID9cbiAgICAgIG9sZEVudHJ5LmludGVyc2VjdGlvblJhdGlvIHx8IDAgOiAtMTtcbiAgdmFyIG5ld1JhdGlvID0gbmV3RW50cnkuaXNJbnRlcnNlY3RpbmcgP1xuICAgICAgbmV3RW50cnkuaW50ZXJzZWN0aW9uUmF0aW8gfHwgMCA6IC0xO1xuXG4gIC8vIElnbm9yZSB1bmNoYW5nZWQgcmF0aW9zXG4gIGlmIChvbGRSYXRpbyA9PT0gbmV3UmF0aW8pIHJldHVybjtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudGhyZXNob2xkcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0aHJlc2hvbGQgPSB0aGlzLnRocmVzaG9sZHNbaV07XG5cbiAgICAvLyBSZXR1cm4gdHJ1ZSBpZiBhbiBlbnRyeSBtYXRjaGVzIGEgdGhyZXNob2xkIG9yIGlmIHRoZSBuZXcgcmF0aW9cbiAgICAvLyBhbmQgdGhlIG9sZCByYXRpbyBhcmUgb24gdGhlIG9wcG9zaXRlIHNpZGVzIG9mIGEgdGhyZXNob2xkLlxuICAgIGlmICh0aHJlc2hvbGQgPT0gb2xkUmF0aW8gfHwgdGhyZXNob2xkID09IG5ld1JhdGlvIHx8XG4gICAgICAgIHRocmVzaG9sZCA8IG9sZFJhdGlvICE9PSB0aHJlc2hvbGQgPCBuZXdSYXRpbykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgcm9vdCBlbGVtZW50IGlzIGFuIGVsZW1lbnQgYW5kIGlzIGluIHRoZSBET00uXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSByb290IGVsZW1lbnQgaXMgYW4gZWxlbWVudCBhbmQgaXMgaW4gdGhlIERPTS5cbiAqIEBwcml2YXRlXG4gKi9cbkludGVyc2VjdGlvbk9ic2VydmVyLnByb3RvdHlwZS5fcm9vdElzSW5Eb20gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICF0aGlzLnJvb3QgfHwgY29udGFpbnNEZWVwKGRvY3VtZW50LCB0aGlzLnJvb3QpO1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHRhcmdldCBlbGVtZW50IGlzIGEgY2hpbGQgb2Ygcm9vdC5cbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IFRoZSB0YXJnZXQgZWxlbWVudCB0byBjaGVjay5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHRhcmdldCBlbGVtZW50IGlzIGEgY2hpbGQgb2Ygcm9vdC5cbiAqIEBwcml2YXRlXG4gKi9cbkludGVyc2VjdGlvbk9ic2VydmVyLnByb3RvdHlwZS5fcm9vdENvbnRhaW5zVGFyZ2V0ID0gZnVuY3Rpb24odGFyZ2V0KSB7XG4gIHJldHVybiBjb250YWluc0RlZXAodGhpcy5yb290IHx8IGRvY3VtZW50LCB0YXJnZXQpO1xufTtcblxuXG4vKipcbiAqIEFkZHMgdGhlIGluc3RhbmNlIHRvIHRoZSBnbG9iYWwgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgcmVnaXN0cnkgaWYgaXQgaXNuJ3RcbiAqIGFscmVhZHkgcHJlc2VudC5cbiAqIEBwcml2YXRlXG4gKi9cbkludGVyc2VjdGlvbk9ic2VydmVyLnByb3RvdHlwZS5fcmVnaXN0ZXJJbnN0YW5jZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAocmVnaXN0cnkuaW5kZXhPZih0aGlzKSA8IDApIHtcbiAgICByZWdpc3RyeS5wdXNoKHRoaXMpO1xuICB9XG59O1xuXG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgaW5zdGFuY2UgZnJvbSB0aGUgZ2xvYmFsIEludGVyc2VjdGlvbk9ic2VydmVyIHJlZ2lzdHJ5LlxuICogQHByaXZhdGVcbiAqL1xuSW50ZXJzZWN0aW9uT2JzZXJ2ZXIucHJvdG90eXBlLl91bnJlZ2lzdGVySW5zdGFuY2UgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGluZGV4ID0gcmVnaXN0cnkuaW5kZXhPZih0aGlzKTtcbiAgaWYgKGluZGV4ICE9IC0xKSByZWdpc3RyeS5zcGxpY2UoaW5kZXgsIDEpO1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIHJlc3VsdCBvZiB0aGUgcGVyZm9ybWFuY2Uubm93KCkgbWV0aG9kIG9yIG51bGwgaW4gYnJvd3NlcnNcbiAqIHRoYXQgZG9uJ3Qgc3VwcG9ydCB0aGUgQVBJLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgZWxhcHNlZCB0aW1lIHNpbmNlIHRoZSBwYWdlIHdhcyByZXF1ZXN0ZWQuXG4gKi9cbmZ1bmN0aW9uIG5vdygpIHtcbiAgcmV0dXJuIHdpbmRvdy5wZXJmb3JtYW5jZSAmJiBwZXJmb3JtYW5jZS5ub3cgJiYgcGVyZm9ybWFuY2Uubm93KCk7XG59XG5cblxuLyoqXG4gKiBUaHJvdHRsZXMgYSBmdW5jdGlvbiBhbmQgZGVsYXlzIGl0cyBleGVjdXRpb25nLCBzbyBpdCdzIG9ubHkgY2FsbGVkIGF0IG1vc3RcbiAqIG9uY2Ugd2l0aGluIGEgZ2l2ZW4gdGltZSBwZXJpb2QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gdGhyb3R0bGUuXG4gKiBAcGFyYW0ge251bWJlcn0gdGltZW91dCBUaGUgYW1vdW50IG9mIHRpbWUgdGhhdCBtdXN0IHBhc3MgYmVmb3JlIHRoZVxuICogICAgIGZ1bmN0aW9uIGNhbiBiZSBjYWxsZWQgYWdhaW4uXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIHRocm90dGxlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gdGhyb3R0bGUoZm4sIHRpbWVvdXQpIHtcbiAgdmFyIHRpbWVyID0gbnVsbDtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRpbWVyKSB7XG4gICAgICB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIGZuKCk7XG4gICAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgIH0sIHRpbWVvdXQpO1xuICAgIH1cbiAgfTtcbn1cblxuXG4vKipcbiAqIEFkZHMgYW4gZXZlbnQgaGFuZGxlciB0byBhIERPTSBub2RlIGVuc3VyaW5nIGNyb3NzLWJyb3dzZXIgY29tcGF0aWJpbGl0eS5cbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBUaGUgRE9NIG5vZGUgdG8gYWRkIHRoZSBldmVudCBoYW5kbGVyIHRvLlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGV2ZW50IGhhbmRsZXIgdG8gYWRkLlxuICogQHBhcmFtIHtib29sZWFufSBvcHRfdXNlQ2FwdHVyZSBPcHRpb25hbGx5IGFkZHMgdGhlIGV2ZW4gdG8gdGhlIGNhcHR1cmVcbiAqICAgICBwaGFzZS4gTm90ZTogdGhpcyBvbmx5IHdvcmtzIGluIG1vZGVybiBicm93c2Vycy5cbiAqL1xuZnVuY3Rpb24gYWRkRXZlbnQobm9kZSwgZXZlbnQsIGZuLCBvcHRfdXNlQ2FwdHVyZSkge1xuICBpZiAodHlwZW9mIG5vZGUuYWRkRXZlbnRMaXN0ZW5lciA9PSAnZnVuY3Rpb24nKSB7XG4gICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBmbiwgb3B0X3VzZUNhcHR1cmUgfHwgZmFsc2UpO1xuICB9XG4gIGVsc2UgaWYgKHR5cGVvZiBub2RlLmF0dGFjaEV2ZW50ID09ICdmdW5jdGlvbicpIHtcbiAgICBub2RlLmF0dGFjaEV2ZW50KCdvbicgKyBldmVudCwgZm4pO1xuICB9XG59XG5cblxuLyoqXG4gKiBSZW1vdmVzIGEgcHJldmlvdXNseSBhZGRlZCBldmVudCBoYW5kbGVyIGZyb20gYSBET00gbm9kZS5cbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBUaGUgRE9NIG5vZGUgdG8gcmVtb3ZlIHRoZSBldmVudCBoYW5kbGVyIGZyb20uXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZXZlbnQgaGFuZGxlciB0byByZW1vdmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdF91c2VDYXB0dXJlIElmIHRoZSBldmVudCBoYW5kbGVyIHdhcyBhZGRlZCB3aXRoIHRoaXNcbiAqICAgICBmbGFnIHNldCB0byB0cnVlLCBpdCBzaG91bGQgYmUgc2V0IHRvIHRydWUgaGVyZSBpbiBvcmRlciB0byByZW1vdmUgaXQuXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUV2ZW50KG5vZGUsIGV2ZW50LCBmbiwgb3B0X3VzZUNhcHR1cmUpIHtcbiAgaWYgKHR5cGVvZiBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPT0gJ2Z1bmN0aW9uJykge1xuICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgZm4sIG9wdF91c2VDYXB0dXJlIHx8IGZhbHNlKTtcbiAgfVxuICBlbHNlIGlmICh0eXBlb2Ygbm9kZS5kZXRhdGNoRXZlbnQgPT0gJ2Z1bmN0aW9uJykge1xuICAgIG5vZGUuZGV0YXRjaEV2ZW50KCdvbicgKyBldmVudCwgZm4pO1xuICB9XG59XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbnRlcnNlY3Rpb24gYmV0d2VlbiB0d28gcmVjdCBvYmplY3RzLlxuICogQHBhcmFtIHtPYmplY3R9IHJlY3QxIFRoZSBmaXJzdCByZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHJlY3QyIFRoZSBzZWNvbmQgcmVjdC5cbiAqIEByZXR1cm4gez9PYmplY3R9IFRoZSBpbnRlcnNlY3Rpb24gcmVjdCBvciB1bmRlZmluZWQgaWYgbm8gaW50ZXJzZWN0aW9uXG4gKiAgICAgaXMgZm91bmQuXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVSZWN0SW50ZXJzZWN0aW9uKHJlY3QxLCByZWN0Mikge1xuICB2YXIgdG9wID0gTWF0aC5tYXgocmVjdDEudG9wLCByZWN0Mi50b3ApO1xuICB2YXIgYm90dG9tID0gTWF0aC5taW4ocmVjdDEuYm90dG9tLCByZWN0Mi5ib3R0b20pO1xuICB2YXIgbGVmdCA9IE1hdGgubWF4KHJlY3QxLmxlZnQsIHJlY3QyLmxlZnQpO1xuICB2YXIgcmlnaHQgPSBNYXRoLm1pbihyZWN0MS5yaWdodCwgcmVjdDIucmlnaHQpO1xuICB2YXIgd2lkdGggPSByaWdodCAtIGxlZnQ7XG4gIHZhciBoZWlnaHQgPSBib3R0b20gLSB0b3A7XG5cbiAgcmV0dXJuICh3aWR0aCA+PSAwICYmIGhlaWdodCA+PSAwKSAmJiB7XG4gICAgdG9wOiB0b3AsXG4gICAgYm90dG9tOiBib3R0b20sXG4gICAgbGVmdDogbGVmdCxcbiAgICByaWdodDogcmlnaHQsXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0XG4gIH07XG59XG5cblxuLyoqXG4gKiBTaGltcyB0aGUgbmF0aXZlIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG9sZGVyIElFLlxuICogQHBhcmFtIHtFbGVtZW50fSBlbCBUaGUgZWxlbWVudCB3aG9zZSBib3VuZGluZyByZWN0IHRvIGdldC5cbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIChwb3NzaWJseSBzaGltbWVkKSByZWN0IG9mIHRoZSBlbGVtZW50LlxuICovXG5mdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWwpIHtcbiAgdmFyIHJlY3Q7XG5cbiAgdHJ5IHtcbiAgICByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIElnbm9yZSBXaW5kb3dzIDcgSUUxMSBcIlVuc3BlY2lmaWVkIGVycm9yXCJcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdzNjL0ludGVyc2VjdGlvbk9ic2VydmVyL3B1bGwvMjA1XG4gIH1cblxuICBpZiAoIXJlY3QpIHJldHVybiBnZXRFbXB0eVJlY3QoKTtcblxuICAvLyBPbGRlciBJRVxuICBpZiAoIShyZWN0LndpZHRoICYmIHJlY3QuaGVpZ2h0KSkge1xuICAgIHJlY3QgPSB7XG4gICAgICB0b3A6IHJlY3QudG9wLFxuICAgICAgcmlnaHQ6IHJlY3QucmlnaHQsXG4gICAgICBib3R0b206IHJlY3QuYm90dG9tLFxuICAgICAgbGVmdDogcmVjdC5sZWZ0LFxuICAgICAgd2lkdGg6IHJlY3QucmlnaHQgLSByZWN0LmxlZnQsXG4gICAgICBoZWlnaHQ6IHJlY3QuYm90dG9tIC0gcmVjdC50b3BcbiAgICB9O1xuICB9XG4gIHJldHVybiByZWN0O1xufVxuXG5cbi8qKlxuICogUmV0dXJucyBhbiBlbXB0eSByZWN0IG9iamVjdC4gQW4gZW1wdHkgcmVjdCBpcyByZXR1cm5lZCB3aGVuIGFuIGVsZW1lbnRcbiAqIGlzIG5vdCBpbiB0aGUgRE9NLlxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgZW1wdHkgcmVjdC5cbiAqL1xuZnVuY3Rpb24gZ2V0RW1wdHlSZWN0KCkge1xuICByZXR1cm4ge1xuICAgIHRvcDogMCxcbiAgICBib3R0b206IDAsXG4gICAgbGVmdDogMCxcbiAgICByaWdodDogMCxcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IDBcbiAgfTtcbn1cblxuLyoqXG4gKiBDaGVja3MgdG8gc2VlIGlmIGEgcGFyZW50IGVsZW1lbnQgY29udGFpbnMgYSBjaGlsZCBlbGVtbnQgKGluY2x1ZGluZyBpbnNpZGVcbiAqIHNoYWRvdyBET00pLlxuICogQHBhcmFtIHtOb2RlfSBwYXJlbnQgVGhlIHBhcmVudCBlbGVtZW50LlxuICogQHBhcmFtIHtOb2RlfSBjaGlsZCBUaGUgY2hpbGQgZWxlbWVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHBhcmVudCBub2RlIGNvbnRhaW5zIHRoZSBjaGlsZCBub2RlLlxuICovXG5mdW5jdGlvbiBjb250YWluc0RlZXAocGFyZW50LCBjaGlsZCkge1xuICB2YXIgbm9kZSA9IGNoaWxkO1xuICB3aGlsZSAobm9kZSkge1xuICAgIGlmIChub2RlID09IHBhcmVudCkgcmV0dXJuIHRydWU7XG5cbiAgICBub2RlID0gZ2V0UGFyZW50Tm9kZShub2RlKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cblxuLyoqXG4gKiBHZXRzIHRoZSBwYXJlbnQgbm9kZSBvZiBhbiBlbGVtZW50IG9yIGl0cyBob3N0IGVsZW1lbnQgaWYgdGhlIHBhcmVudCBub2RlXG4gKiBpcyBhIHNoYWRvdyByb290LlxuICogQHBhcmFtIHtOb2RlfSBub2RlIFRoZSBub2RlIHdob3NlIHBhcmVudCB0byBnZXQuXG4gKiBAcmV0dXJuIHtOb2RlfG51bGx9IFRoZSBwYXJlbnQgbm9kZSBvciBudWxsIGlmIG5vIHBhcmVudCBleGlzdHMuXG4gKi9cbmZ1bmN0aW9uIGdldFBhcmVudE5vZGUobm9kZSkge1xuICB2YXIgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xuXG4gIGlmIChwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlID09IDExICYmIHBhcmVudC5ob3N0KSB7XG4gICAgLy8gSWYgdGhlIHBhcmVudCBpcyBhIHNoYWRvdyByb290LCByZXR1cm4gdGhlIGhvc3QgZWxlbWVudC5cbiAgICByZXR1cm4gcGFyZW50Lmhvc3Q7XG4gIH1cbiAgcmV0dXJuIHBhcmVudDtcbn1cblxuXG4vLyBFeHBvc2VzIHRoZSBjb25zdHJ1Y3RvcnMgZ2xvYmFsbHkuXG53aW5kb3cuSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPSBJbnRlcnNlY3Rpb25PYnNlcnZlcjtcbndpbmRvdy5JbnRlcnNlY3Rpb25PYnNlcnZlckVudHJ5ID0gSW50ZXJzZWN0aW9uT2JzZXJ2ZXJFbnRyeTtcblxufSh3aW5kb3csIGRvY3VtZW50KSk7XG4iLCI8dGVtcGxhdGU+XG4gICAgPGRpdiBjbGFzcz1cImluZmluaXRlLXNjcm9sbGluZ1wiIDpzdHlsZT1cIntoZWlnaHQ6IGhlaWdodFVuaXQsIGJhY2tncm91bmQ6IGJhY2tncm91bmR9XCI+XG4gICAgICAgIDxhY3Rpdml0eS1pbmRpY2F0b3Igdi1pZj1cImFjdGl2aXR5XCIgOnNpemU9XCJzaXplXCIgOnR5cGU9XCJ0eXBlXCIgY2VudGVyLz5cbiAgICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgJ2ludGVyc2VjdGlvbi1vYnNlcnZlcic7XG5pbXBvcnQgdW5pdCBmcm9tICcuLi8uLi9IZWxwZXJzL1VuaXQnO1xuaW1wb3J0IEFjdGl2aXR5SW5kaWNhdG9yIGZyb20gJy4uL0FjdGl2aXR5SW5kaWNhdG9yJztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ2luZmluaXRlLXNjcm9sbGluZycsXG5cbiAgICBjb21wb25lbnRzOiB7XG4gICAgICAgIEFjdGl2aXR5SW5kaWNhdG9yXG4gICAgfSxcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElzIHRoZSBhY3Rpdml0eSBpbmRpY2F0b3Igc2hvd2luZ1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBhY3Rpdml0eTogQm9vbGVhbixcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGFjdGl2aXR5IGluZGljYXRvciBiYWNrZ3JvdW5kIHN0eWxlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGJhY2tncm91bmQ6IFN0cmluZyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGFjdGl2aXR5IGluZGljYXRvciBzaXplXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGhlaWdodDoge1xuICAgICAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICAgICAgZGVmYXVsdDogMTAwXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhY3Rpdml0eSBpbmRpY2F0b3Igc2l6ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBzaXplOiBTdHJpbmcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhY3Rpdml0eSBpbmRpY2F0b3IgdHlwZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzY3JvbGwgb2JzZXJ2ZXIgdGhyZXNob2xkIGZvciB3aGVuIGFuIGVsZW1lbnQgaXMgY29uc2lkZXJlZFxuICAgICAgICAgKiBpbnRvIHZpZXcuIE11c3QgYmUgYSB2YWxpZGF0ZSBiZXR3ZWVuIDAgYW5kIDEsIGFuZCBpcyBhIHBlcmNlbnRhZ2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBOdW1iZXJcbiAgICAgICAgICovXG4gICAgICAgIHRocmVzaG9sZDoge1xuICAgICAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICAgICAgZGVmYXVsdDogLjc1LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgPj0gMCAmJiB2YWx1ZSA8PSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgbWV0aG9kczoge1xuXG4gICAgICAgIHNjcm9sbEludG9WaWV3cG9ydChlbnRyeSkge1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgnc2Nyb2xsOmluJywgZW50cnkpO1xuXG4gICAgICAgICAgICBpZighdGhpcy5hY3Rpdml0eSkge1xuICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2xvYWQnLCBlbnRyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2Nyb2xsT3V0Vmlld3BvcnQoZW50cnkpIHtcbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ3Njcm9sbDpvdXQnLCBlbnRyeSk7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBjb21wdXRlZDoge1xuXG4gICAgICAgIGhlaWdodFVuaXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5pdCh0aGlzLmhlaWdodCk7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBtb3VudGVkKCkge1xuICAgICAgICB0aGlzLiRuZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoKGVudHJpZXMsIG9ic2VydmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgZW50cmllcy5mb3JFYWNoKGVudHJ5ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYoZW50cnkuaXNJbnRlcnNlY3RpbmcgJiYgIXRoaXMuaGFzU2Nyb2xsZWRJbnRvVmlld3BvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsSW50b1ZpZXdwb3J0KGVudHJ5LCBvYnNlcnZlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhc1Njcm9sbGVkSW50b1ZpZXdwb3J0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKHRoaXMuaGFzU2Nyb2xsZWRJbnRvVmlld3BvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsT3V0Vmlld3BvcnQoZW50cnksIG9ic2VydmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFzU2Nyb2xsZWRJbnRvVmlld3BvcnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHRocmVzaG9sZDogdGhpcy50aHJlc2hvbGRcbiAgICAgICAgICAgIH0pLm9ic2VydmUodGhpcy4kZWwpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhhc1Njcm9sbGVkSW50b1ZpZXdwb3J0OiBmYWxzZVxuICAgICAgICB9XG4gICAgfVxuXG59XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJzY3NzXCI+XG4uaW5maW5pdGUtc2Nyb2xsaW5nIHtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG5cbn1cbjwvc3R5bGU+XG4iLCI8dGVtcGxhdGU+XG5cbiAgICA8c3BhbiBjbGFzcz1cImlucHV0LWdyb3VwLXRleHRcIiA6aWQ9XCJpZFwiPlxuICAgICAgICA8c2xvdD57eyB0ZXh0IH19PC9zbG90PlxuICAgIDwvc3Bhbj5cblxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ2lucHV0LWdyb3VwLXRleHQnLFxuXG4gICAgcHJvcHM6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGlkIGF0dHJpYnV0ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBpZDogU3RyaW5nLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdHlwZSBhdHRyaWJ1dGVcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgdGV4dDogW0FycmF5LCBOdW1iZXIsIFN0cmluZ11cblxuICAgIH1cblxufVxuXG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cblxuICAgIDxkaXYgY2xhc3M9XCJpbnB1dC1ncm91cC1hcHBlbmRcIj5cbiAgICAgICAgPGlucHV0LWdyb3VwLXRleHQgdi1pZj1cInRleHRcIj5cbiAgICAgICAgICAgIDxzbG90Lz5cbiAgICAgICAgPC9pbnB1dC1ncm91cC10ZXh0PlxuICAgICAgICA8c2xvdCB2LWVsc2UvPlxuICAgIDwvZGl2PlxuXG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAnaW5wdXQtZ3JvdXAtYXBwZW5kJyxcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0eXBlIGF0dHJpYnV0ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICB0ZXh0OiBCb29sZWFuXG5cbiAgICB9XG5cbn1cblxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG5cbiAgICA8ZGl2IGNsYXNzPVwiaW5wdXQtZ3JvdXAtcHJlcGVuZFwiPlxuICAgICAgICA8aW5wdXQtZ3JvdXAtdGV4dCB2LWlmPVwidGV4dFwiPlxuICAgICAgICAgICAgPHNsb3QvPlxuICAgICAgICA8L2lucHV0LWdyb3VwLXRleHQ+XG4gICAgICAgIDxzbG90IHYtZWxzZS8+XG4gICAgPC9kaXY+XG5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdpbnB1dC1ncm91cC1wcmVwZW5kJyxcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0eXBlIGF0dHJpYnV0ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICB0ZXh0OiBCb29sZWFuXG5cbiAgICB9XG5cbn1cblxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG5cbiAgICA8ZGl2IGNsYXNzPVwiaW5wdXQtZ3JvdXBcIiA6Y2xhc3M9XCIkbWVyZ2VDbGFzc2VzKGNvbG9yYWJsZUNsYXNzZXMsIHNpemVhYmxlQ2xhc3MpXCI+XG5cbiAgICAgICAgPHNsb3QgbmFtZT1cInByZXBlbmRcIj5cbiAgICAgICAgICAgIDx0ZW1wbGF0ZSB2LWlmPVwicHJlcGVuZCBpbnN0YW5jZW9mIEFycmF5XCI+XG4gICAgICAgICAgICAgICAgPGlucHV0LWdyb3VwLXByZXBlbmQ+XG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dC1ncm91cC10ZXh0IHYtZm9yPVwidmFsdWUgaW4gcHJlcGVuZFwiIDp0ZXh0PVwidmFsdWVcIi8+XG4gICAgICAgICAgICAgICAgPC9pbnB1dC1ncm91cC1wcmVwZW5kPlxuICAgICAgICAgICAgPC90ZW1wbGF0ZT5cbiAgICAgICAgICAgIDx0ZW1wbGF0ZSB2LWVsc2UtaWY9XCJwcmVwZW5kXCI+XG4gICAgICAgICAgICAgICAgPGlucHV0LWdyb3VwLXByZXBlbmQgdGV4dD57e3ByZXBlbmR9fTwvaW5wdXQtZ3JvdXAtcHJlcGVuZD5cbiAgICAgICAgICAgIDwvdGVtcGxhdGU+XG4gICAgICAgIDwvc2xvdD5cblxuICAgICAgICA8c2xvdC8+XG5cbiAgICAgICAgPHNsb3QgbmFtZT1cImFwcGVuZFwiPlxuICAgICAgICAgICAgPHRlbXBsYXRlIHYtaWY9XCJhcHBlbmQgaW5zdGFuY2VvZiBBcnJheVwiPlxuICAgICAgICAgICAgICAgIDxpbnB1dC1ncm91cC1hcHBlbmQ+XG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dC1ncm91cC10ZXh0IHYtZm9yPVwidmFsdWUgaW4gYXBwZW5kXCIgOnRleHQ9XCJ2YWx1ZVwiLz5cbiAgICAgICAgICAgICAgICA8L2lucHV0LWdyb3VwLWFwcGVuZD5cbiAgICAgICAgICAgIDwvdGVtcGxhdGU+XG4gICAgICAgICAgICA8dGVtcGxhdGUgdi1lbHNlLWlmPVwiYXBwZW5kXCI+XG4gICAgICAgICAgICAgICAgPGlucHV0LWdyb3VwLWFwcGVuZCB0ZXh0Pnt7YXBwZW5kfX08L2lucHV0LWdyb3VwLWFwcGVuZD5cbiAgICAgICAgICAgIDwvdGVtcGxhdGU+XG4gICAgICAgIDwvc2xvdD5cbiAgICA8L2Rpdj5cblxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBJbnB1dEdyb3VwVGV4dCBmcm9tICcuL0lucHV0R3JvdXBUZXh0JztcbmltcG9ydCBJbnB1dEdyb3VwQXBwZW5kIGZyb20gJy4vSW5wdXRHcm91cEFwcGVuZCc7XG5pbXBvcnQgSW5wdXRHcm91cFByZXBlbmQgZnJvbSAnLi9JbnB1dEdyb3VwUHJlcGVuZCc7XG5pbXBvcnQgSGFzU2xvdHMgZnJvbSAnLi4vLi4vTWl4aW5zL0hhc1Nsb3RzL0hhc1Nsb3RzJztcbmltcG9ydCBTaXplYWJsZSBmcm9tICcuLi8uLi9NaXhpbnMvU2l6ZWFibGUvU2l6ZWFibGUnO1xuaW1wb3J0IENvbG9yYWJsZSBmcm9tICcuLi8uLi9NaXhpbnMvQ29sb3JhYmxlL0NvbG9yYWJsZSc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdpbnB1dC1ncm91cCcsXG5cbiAgICBjb21wb25lbnRzOiB7XG4gICAgICAgIElucHV0R3JvdXBUZXh0LFxuICAgICAgICBJbnB1dEdyb3VwQXBwZW5kLFxuICAgICAgICBJbnB1dEdyb3VwUHJlcGVuZFxuICAgIH0sXG5cbiAgICBtaXhpbnM6IFtcbiAgICAgICAgSGFzU2xvdHMsXG4gICAgICAgIFNpemVhYmxlLFxuICAgICAgICBDb2xvcmFibGVcbiAgICBdLFxuXG4gICAgcHJvcHM6IHtcblxuICAgICAgICBhcHBlbmQ6IFtBcnJheSwgTnVtYmVyLCBTdHJpbmddLFxuXG4gICAgICAgIHByZXBlbmQ6IFtBcnJheSwgTnVtYmVyLCBTdHJpbmddXG5cbiAgICB9XG5cbn1cblxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgSW5wdXRHcm91cCBmcm9tICcuL0lucHV0R3JvdXAnO1xuaW1wb3J0IElucHV0R3JvdXBBcHBlbmQgZnJvbSAnLi9JbnB1dEdyb3VwQXBwZW5kJztcbmltcG9ydCBJbnB1dEdyb3VwUHJlcGVuZCBmcm9tICcuL0lucHV0R3JvdXBQcmVwZW5kJztcbmltcG9ydCBJbnB1dEdyb3VwVGV4dCBmcm9tICcuL0lucHV0R3JvdXBUZXh0JztcbmltcG9ydCBWdWVJbnN0YWxsZXIgZnJvbSAnLi4vLi4vSGVscGVycy9WdWVJbnN0YWxsZXIvVnVlSW5zdGFsbGVyJztcblxuY29uc3QgcGx1Z2luID0gVnVlSW5zdGFsbGVyLnVzZSh7XG5cbiAgICBpbnN0YWxsKFZ1ZSwgb3B0aW9ucykge1xuICAgICAgICBWdWVJbnN0YWxsZXIuY29tcG9uZW50cyh7XG4gICAgICAgICAgICBJbnB1dEdyb3VwLFxuICAgICAgICAgICAgSW5wdXRHcm91cEFwcGVuZCxcbiAgICAgICAgICAgIElucHV0R3JvdXBQcmVwZW5kLFxuICAgICAgICAgICAgSW5wdXRHcm91cFRleHRcbiAgICAgICAgfSk7XG4gICAgfVxuXG59KTtcblxuZXhwb3J0ICogZnJvbSAnLi9JbnB1dEdyb3VwQXBwZW5kJztcbmV4cG9ydCAqIGZyb20gJy4vSW5wdXRHcm91cFByZXBlbmQnO1xuZXhwb3J0ICogZnJvbSAnLi9JbnB1dEdyb3VwVGV4dCc7XG5leHBvcnQgZGVmYXVsdCBJbnB1dEdyb3VwO1xuIiwiPHRlbXBsYXRlPlxuXG4gICAgPGZvcm0tZ3JvdXA+XG5cbiAgICAgICAgPHNsb3QgbmFtZT1cImxhYmVsXCI+XG4gICAgICAgICAgICA8Zm9ybS1sYWJlbCB2LWlmPVwibGFiZWxcIiA6Zm9yPVwiaWRcIiB2LWh0bWw9XCJsYWJlbFwiIC8+XG4gICAgICAgIDwvc2xvdD5cblxuICAgICAgICA8ZGl2IDpjbGFzcz1cImNvbnRyb2xDbGFzc2VzXCIgdGFiaW5kZXg9XCIwXCIgQGNsaWNrPVwidG9nZ2xlKClcIiBAa2V5dXAuMzI9XCJ0b2dnbGUoKVwiIEBrZXl1cC4zNz1cInRvZ2dsZShvZmZWYWx1ZSlcIiBAa2V5dXAuMzk9XCJ0b2dnbGUob25WYWx1ZSlcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJsaWdodC1zd2l0Y2gtaGFuZGxlXCI+PC9kaXY+XG4gICAgICAgIFx0PGRpdiBjbGFzcz1cImxpZ2h0LXN3aXRjaC1jb250YWluZXJcIj5cbiAgICAgICAgXHRcdDxkaXYgY2xhc3M9XCJsaWdodC1zd2l0Y2gtbGFiZWwgb24tdmFsdWVcIj48L2Rpdj5cbiAgICAgICAgXHRcdDxkaXYgY2xhc3M9XCJsaWdodC1zd2l0Y2gtbGFiZWwgb2ZmLXZhbHVlXCI+PC9kaXY+XG4gICAgICAgIFx0PC9kaXY+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIDxmb3JtLWNvbnRyb2wgOm5hbWU9XCJuYW1lXCIgOnZhbHVlPVwidmFsdWVcIiA6aWQ9XCJpZFwiIGNsYXNzPVwiZC1ub25lXCIvPlxuXG4gICAgICAgIDxzbG90IG5hbWU9XCJmZWVkYmFja1wiPlxuICAgICAgICAgICAgPGZvcm0tZmVlZGJhY2sgdi1pZj1cInZhbGlkRmVlZGJhY2tcIiB2LWh0bWw9XCJ2YWxpZEZlZWRiYWNrXCIgdmFsaWQgLz5cbiAgICAgICAgICAgIDxmb3JtLWZlZWRiYWNrIHYtaWY9XCJpbnZhbGlkRmVlZGJhY2tcIiB2LWh0bWw9XCJpbnZhbGlkRmVlZGJhY2tcIiBpbnZhbGlkIC8+XG4gICAgICAgIDwvc2xvdD5cblxuICAgICAgICA8c2xvdCBuYW1lPVwiaGVscFwiPlxuICAgICAgICAgICAgPGhlbHAtdGV4dCB2LWlmPVwiaGVscFRleHRcIiB2LWh0bWw9XCJoZWxwVGV4dFwiIC8+XG4gICAgICAgIDwvc2xvdD5cblxuICAgIDwvZm9ybS1ncm91cD5cblxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBIZWxwVGV4dCBmcm9tICcuLi9IZWxwVGV4dCc7XG5pbXBvcnQgRm9ybUdyb3VwIGZyb20gJy4uL0Zvcm1Hcm91cCc7XG5pbXBvcnQgRm9ybUxhYmVsIGZyb20gJy4uL0Zvcm1MYWJlbCc7XG5pbXBvcnQgRm9ybUZlZWRiYWNrIGZyb20gJy4uL0Zvcm1GZWVkYmFjayc7XG5pbXBvcnQgeyBpc1VuZGVmaW5lZCB9IGZyb20gJ2xvZGFzaC1lcydcbmltcG9ydCBGb3JtQ29udHJvbCBmcm9tICcuLi8uLi9NaXhpbnMvRm9ybUNvbnRyb2wvRm9ybUNvbnRyb2wnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAnbGlnaHQtc3dpdGNoLWZpZWxkJyxcblxuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgICAgSGVscFRleHQsXG4gICAgICAgIEZvcm1Hcm91cCxcbiAgICAgICAgRm9ybUxhYmVsLFxuICAgICAgICBGb3JtRmVlZGJhY2tcbiAgICB9LFxuXG4gICAgbWl4aW5zOiBbXG4gICAgICAgIEZvcm1Db250cm9sXG4gICAgXSxcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjbGFzcyBuYW1lIGFzc2lnbmVkIHRvIHRoZSBjb250cm9sIGVsZW1lbnRcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgZGVmYXVsdENvbnRyb2xDbGFzczoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJ2Zvcm0tY29udHJvbCBsaWdodC1zd2l0Y2gnXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjbGFzcyBuYW1lIGFzc2lnbmVkIHRvIHRoZSBjb250cm9sIGVsZW1lbnRcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgYWN0aXZlQ2xhc3M6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdvbidcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNsYXNzIG5hbWUgYXNzaWduZWQgdG8gdGhlIGNvbnRyb2wgZWxlbWVudFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBvblZhbHVlOiB7XG4gICAgICAgICAgICBkZWZhdWx0OiAxXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjbGFzcyBuYW1lIGFzc2lnbmVkIHRvIHRoZSBjb250cm9sIGVsZW1lbnRcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgb2ZmVmFsdWU6IHtcbiAgICAgICAgICAgIGRlZmF1bHQ6IDBcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGNvbXB1dGVkOiB7XG5cbiAgICAgICAgaXNBY3RpdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUgPT09IHRoaXMub25WYWx1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICBjb250cm9sQ2xhc3NlcygpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgdGhpcy5jb250cm9sQ2xhc3MsXG4gICAgICAgICAgICAgICAgdGhpcy5jb250cm9sU2l6ZUNsYXNzLFxuICAgICAgICAgICAgICAgICh0aGlzLnNwYWNpbmcgfHwgJycpLFxuICAgICAgICAgICAgICAgICh0aGlzLmludmFsaWRGZWVkYmFjayA/ICdpcy1pbnZhbGlkJyA6ICcnKSxcbiAgICAgICAgICAgICAgICAodGhpcy5kcmFnZ2luZyA/ICdpcy1kcmFnZ2luZycgOiAnJyksXG4gICAgICAgICAgICAgICAgKHRoaXMuaXNBY3RpdmUgPyAnaXMtYWN0aXZlJyA6ICcnKVxuICAgICAgICAgICAgXS5qb2luKCcgJyk7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBtZXRob2RzOiB7XG5cbiAgICAgICAgZ2V0VHJhbnNpdGlvbkluTWlsbGlzZWNvbmRzKCkge1xuICAgICAgICAgICAgY29uc3QgZHVyYXRpb24gPSBnZXRDb21wdXRlZFN0eWxlKHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3IoJy5saWdodC1zd2l0Y2gtaGFuZGxlJykpLnRyYW5zaXRpb25EdXJhdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IG51bWVyaWMgPSBwYXJzZUZsb2F0KGR1cmF0aW9uLCAxMCk7XG4gICAgICAgICAgICBjb25zdCB1bml0ID0gZHVyYXRpb24ubWF0Y2goL20/cy8pO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKHVuaXRbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bWVyaWMgKiAxMDAwO1xuICAgICAgICAgICAgICAgIGNhc2UgJ21zJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bWVyaWM7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7dW5pdFswXX1cIiBpcyBub3QgYSB2YWxpZCB1bml0IG9mIG1lYXN1cmUuIFVuaXQgbXVzdCBiZSBcInNcIiAoc2Vjb25kcykgb3IgXCJtc1wiIChtaWxsaXNlY29uZHMpLmApO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRvZ2dsZSh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgnaW5wdXQnLCAhaXNVbmRlZmluZWQodmFsdWUpID8gdmFsdWUgOiAodGhpcy5pc0FjdGl2ZSA/IHRoaXMub2ZmVmFsdWUgOiB0aGlzLm9uVmFsdWUpKTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIHdhdGNoOiB7XG4gICAgICAgIHZhbHVlKCkge1xuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZyA9IHRydWU7XG5cbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH0sIHRoaXMuZ2V0VHJhbnNpdGlvbkluTWlsbGlzZWNvbmRzKCkpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkcmFnZ2luZzogZmFsc2VcbiAgICAgICAgfTtcbiAgICB9XG5cbn1cblxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwic2Nzc1wiPlxuQGltcG9ydCAnLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwL3Njc3MvZnVuY3Rpb25zLnNjc3MnO1xuQGltcG9ydCAnLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwL3Njc3MvdmFyaWFibGVzLnNjc3MnO1xuQGltcG9ydCAnLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwL3Njc3MvbWl4aW5zLnNjc3MnO1xuXG4kbGlnaHQtc3dpdGNoLWFuaW1hdGlvbi1lYXNpbmc6IGVhc2U7XG4kbGlnaHQtc3dpdGNoLWFuaW1hdGlvbi1sZW5ndGg6IDFzIC8gMztcbiRsaWdodC1zd2l0Y2gtaGFuZGxlLXdpZHRoOiAkZm9udC1zaXplLWJhc2UgKiAyO1xuJGxpZ2h0LXN3aXRjaC1oYW5kbGUtaGVpZ2h0OiAkbGlnaHQtc3dpdGNoLWhhbmRsZS13aWR0aDtcbiRsaWdodC1zd2l0Y2gtc2l6ZS13aWR0aDogJGxpZ2h0LXN3aXRjaC1oYW5kbGUtd2lkdGggKiAxLjU7XG4kbGlnaHQtc3dpdGNoLXNpemUtaGVpZ2h0OiAkbGlnaHQtc3dpdGNoLWhhbmRsZS1oZWlnaHQ7XG4kbGlnaHQtc3dpdGNoLWxhYmVsLXdpZHRoOiAkbGlnaHQtc3dpdGNoLWhhbmRsZS13aWR0aDtcbiRsaWdodC1zd2l0Y2gtbGFiZWwtaGVpZ2h0OiAkbGlnaHQtc3dpdGNoLWhhbmRsZS1oZWlnaHQ7XG5cbkBtaXhpbiBsaWdodC1zd2l0Y2gtc2l6ZSgkc2l6ZSwgJG1vZGlmaWVyKSB7XG4gICAgJGhhbmRsZS13aWR0aDogJGxpZ2h0LXN3aXRjaC1oYW5kbGUtd2lkdGggKiAkbW9kaWZpZXI7XG4gICAgJGhhbmRsZS1oZWlnaHQ6ICRoYW5kbGUtd2lkdGg7XG4gICAgJHNpemUtd2lkdGg6ICRoYW5kbGUtd2lkdGggKiAxLjU7XG4gICAgJHNpemUtaGVpZ2h0OiAkaGFuZGxlLWhlaWdodDtcbiAgICAkbGFiZWwtd2lkdGg6ICRoYW5kbGUtd2lkdGg7XG4gICAgJGxhYmVsLWhlaWdodDogJGhhbmRsZS1oZWlnaHQ7XG5cbiAgICAmLmxpZ2h0LXN3aXRjaC0jeyRzaXplfSB7XG4gICAgICAgIHBhZGRpbmc6IDA7XG4gICAgXHR3aWR0aDogJHNpemUtd2lkdGg7XG4gICAgXHRoZWlnaHQ6ICRoYW5kbGUtaGVpZ2h0O1xuICAgIFx0Ym9yZGVyLXJhZGl1czogJGhhbmRsZS13aWR0aDtcblxuICAgICAgICAubGlnaHQtc3dpdGNoLWhhbmRsZSB7XG4gICAgICAgICAgICB3aWR0aDogJGhhbmRsZS13aWR0aDtcbiAgICAgICAgICAgIGhlaWdodDogJGhhbmRsZS1oZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICAubGlnaHQtc3dpdGNoLWNvbnRhaW5lciB7XG4gICAgICAgICAgICBsZWZ0OiAtJGhhbmRsZS13aWR0aCAvIDI7XG4gICAgICAgICAgICB3aWR0aDogJGxhYmVsLXdpZHRoICogMjtcbiAgICAgICAgICAgIGhlaWdodDogJGxhYmVsLWhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgICYuaXMtYWN0aXZlIHtcbiAgICAgICAgICAgIC5saWdodC1zd2l0Y2gtaGFuZGxlIHtcbiAgICAgICAgICAgICAgICBsZWZ0OiAkaGFuZGxlLXdpZHRoIC8gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC5saWdodC1zd2l0Y2gtbGFiZWwge1xuICAgICAgICAgICAgd2lkdGg6ICRsYWJlbC13aWR0aDtcbiAgICAgICAgICAgIGhlaWdodDogJGxhYmVsLWhlaWdodDtcblxuICAgICAgICAgICAgJi5vbi12YWx1ZSB7XG4gICAgICAgICAgICAgICAgLy9ib3JkZXItcmFkaXVzOiAkaGFuZGxlLXdpZHRoIDAgMCAkaGFuZGxlLXdpZHRoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAmLm9mZi12YWx1ZSB7XG4gICAgICAgICAgICAgICAgLy9ib3JkZXItcmFkaXVzOiAwICRoYW5kbGUtd2lkdGggJGhhbmRsZS13aWR0aCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG4ubGlnaHQtc3dpdGNoIHtcbiAgICBwYWRkaW5nOiAwO1xuXHRwb3NpdGlvbjogcmVsYXRpdmU7XG5cdGJvcmRlcjogbm9uZTtcblx0d2lkdGg6ICRsaWdodC1zd2l0Y2gtc2l6ZS13aWR0aDtcblx0aGVpZ2h0OiAkbGlnaHQtc3dpdGNoLWhhbmRsZS1oZWlnaHQ7XG5cdGJvcmRlci1yYWRpdXM6ICRsaWdodC1zd2l0Y2gtaGFuZGxlLXdpZHRoO1xuXHRvdmVyZmxvdzogaGlkZGVuO1xuXHRjdXJzb3I6IHBvaW50ZXI7XG5cdC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XG5cdC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XG5cdC1tcy11c2VyLXNlbGVjdDogbm9uZTtcblx0b3ZlcmZsb3c6IGhpZGRlbjtcblxuICAgIEBpbmNsdWRlIGxpZ2h0LXN3aXRjaC1zaXplKCd4cycsIC41KTtcbiAgICBAaW5jbHVkZSBsaWdodC1zd2l0Y2gtc2l6ZSgnc20nLCAuNzUpO1xuICAgIEBpbmNsdWRlIGxpZ2h0LXN3aXRjaC1zaXplKCdtZCcsIDEpO1xuICAgIEBpbmNsdWRlIGxpZ2h0LXN3aXRjaC1zaXplKCdsZycsIDEuNSk7XG4gICAgQGluY2x1ZGUgbGlnaHQtc3dpdGNoLXNpemUoJ3hsJywgMik7XG5cbiAgICBAaW5jbHVkZSBmb3JtLXZhbGlkYXRpb24tc3RhdGUoXCJ2YWxpZFwiLCAkZm9ybS1mZWVkYmFjay12YWxpZC1jb2xvcik7XG4gICAgQGluY2x1ZGUgZm9ybS12YWxpZGF0aW9uLXN0YXRlKFwiaW52YWxpZFwiLCAkZm9ybS1mZWVkYmFjay1pbnZhbGlkLWNvbG9yKTtcblxuICAgICYuaXMtaW52YWxpZCB7XG4gICAgICAgIGJvcmRlcjogMXB4IHNvbGlkICRmb3JtLWZlZWRiYWNrLWludmFsaWQtY29sb3I7XG5cbiAgICAgICAgJiAubGlnaHQtc3dpdGNoLWhhbmRsZSB7XG5cblxuICAgICAgICB9XG5cbiAgICAgICAgJjpub3QoLmlzLWFjdGl2ZSkgLmxpZ2h0LXN3aXRjaC1oYW5kbGUge1xuICAgICAgICAgICAgYmFja2dyb3VuZDogJGZvcm0tZmVlZGJhY2staW52YWxpZC1jb2xvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIC5saWdodC1zd2l0Y2gtbGFiZWwge1xuICAgICAgICAgICAgJi5vbi12YWx1ZSB7XG4gICAgICAgICAgICAgICAgbGVmdDogMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICYub2ZmLXZhbHVlIHtcbiAgICAgICAgICAgICAgICByaWdodDogMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC5saWdodC1zd2l0Y2gtaGFuZGxlIHtcbiAgICAgICAgdG9wOiAwO1xuICAgICAgICBsZWZ0OiAwO1xuICAgICAgICB6LWluZGV4OiAxO1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDEwMCU7XG4gICAgICAgIHRyYW5zaXRpb246IGxlZnQgJGxpZ2h0LXN3aXRjaC1hbmltYXRpb24tbGVuZ3RoICRsaWdodC1zd2l0Y2gtYW5pbWF0aW9uLWVhc2luZztcbiAgICAgICAgd2lkdGg6ICRsaWdodC1zd2l0Y2gtaGFuZGxlLXdpZHRoO1xuICAgICAgICBoZWlnaHQ6ICRsaWdodC1zd2l0Y2gtaGFuZGxlLWhlaWdodDtcbiAgICAgICAgYmFja2dyb3VuZDogd2hpdGU7XG4gICAgICAgIGJhY2tncm91bmQtaW1hZ2U6IHJhZGlhbC1ncmFkaWVudCh3aGl0ZSwgcmdiKDI1MCwgMjUwLCAyNTApIDUwJSwgd2hpdGUgNzUlKTtcbiAgICAgICAgYm94LXNoYWRvdzogaW5zZXQgMCAwIDAgMXB4IHJnYmEoMCwgMCwgMCwgMC4xKSwgMCAwIDAgMXB4IHJnYmEoMCwgMCwgMCwgMC4xKTtcbiAgICB9XG5cbiAgICAubGlnaHQtc3dpdGNoLWNvbnRhaW5lciB7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgbGVmdDogLSRsaWdodC1zd2l0Y2gtaGFuZGxlLXdpZHRoIC8gMjtcbiAgICAgICAgdG9wOiAoJGxpZ2h0LXN3aXRjaC1oYW5kbGUtaGVpZ2h0IC0gICRsaWdodC1zd2l0Y2gtbGFiZWwtaGVpZ2h0KSAvIDI7XG4gICAgICAgIHdpZHRoOiAkbGlnaHQtc3dpdGNoLWxhYmVsLXdpZHRoICogMjtcbiAgICAgICAgaGVpZ2h0OiAkbGlnaHQtc3dpdGNoLWxhYmVsLWhlaWdodDtcbiAgICAgICAgdHJhbnNpdGlvbjogbGVmdCAkbGlnaHQtc3dpdGNoLWFuaW1hdGlvbi1sZW5ndGggJGxpZ2h0LXN3aXRjaC1hbmltYXRpb24tZWFzaW5nO1xuICAgIH1cblxuICAgICY6bm90KC5pcy1hY3RpdmUpIHtcbiAgICAgICAgJjpub3QoLmlzLWRyYWdnaW5nKSAub24tdmFsdWUge1xuICAgICAgICAgICAgdmlzaWJpbGl0eTogaGlkZGVuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgJi5pcy1hY3RpdmUge1xuICAgICAgICAmOm5vdCguaXMtZHJhZ2dpbmcpIC5vZmYtdmFsdWUge1xuICAgICAgICAgICAgdmlzaWJpbGl0eTogaGlkZGVuO1xuICAgICAgICB9XG5cbiAgICAgICAgLmxpZ2h0LXN3aXRjaC1oYW5kbGUge1xuICAgICAgICAgICAgbGVmdDogJGxpZ2h0LXN3aXRjaC1oYW5kbGUtd2lkdGggLyAyO1xuICAgICAgICB9XG5cbiAgICAgICAgLmxpZ2h0LXN3aXRjaC1jb250YWluZXIge1xuICAgICAgICAgICAgbGVmdDogMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC5saWdodC1zd2l0Y2gtbGFiZWwge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHdpZHRoOiAkbGlnaHQtc3dpdGNoLWxhYmVsLXdpZHRoO1xuICAgICAgICBoZWlnaHQ6ICRsaWdodC1zd2l0Y2gtbGFiZWwtaGVpZ2h0O1xuICAgICAgICAvL2JveC1zaGFkb3c6IGluc2V0IDAgMCAwIDFweCByZ2JhKDAsIDAsIDAsIDAuMSk7XG5cbiAgICAgICAgJi5vbi12YWx1ZSB7XG4gICAgICAgICAgICBsZWZ0OiAwO1xuICAgICAgICAgICAgYmFja2dyb3VuZDogIzAwYjAwNztcbiAgICAgICAgICAgIC8vYm9yZGVyLXJhZGl1czogJGxpZ2h0LXN3aXRjaC1oYW5kbGUtd2lkdGggMCAwICRsaWdodC1zd2l0Y2gtaGFuZGxlLXdpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgJi5vZmYtdmFsdWUge1xuICAgICAgICAgICAgcmlnaHQ6IDA7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiAjZWJlZGVmO1xuICAgICAgICAgICAgLy9ib3JkZXItcmFkaXVzOiAwICRsaWdodC1zd2l0Y2gtaGFuZGxlLXdpZHRoICRsaWdodC1zd2l0Y2gtaGFuZGxlLXdpZHRoIDA7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuXG48L3N0eWxlPlxuIiwiaW1wb3J0IExpZ2h0U3dpdGNoRmllbGQgZnJvbSAnLi9MaWdodFN3aXRjaEZpZWxkJztcbmltcG9ydCBWdWVJbnN0YWxsZXIgZnJvbSAnLi4vLi4vSGVscGVycy9WdWVJbnN0YWxsZXIvVnVlSW5zdGFsbGVyJztcblxuY29uc3QgcGx1Z2luID0gVnVlSW5zdGFsbGVyLnVzZSh7XG5cbiAgICBpbnN0YWxsKFZ1ZSwgb3B0aW9ucykge1xuICAgICAgICBWdWVJbnN0YWxsZXIuY29tcG9uZW50cyh7XG4gICAgICAgICAgICBMaWdodFN3aXRjaEZpZWxkXG4gICAgICAgIH0pO1xuICAgIH1cblxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IExpZ2h0U3dpdGNoRmllbGQ7XG4iLCI8dGVtcGxhdGU+XG4gICAgPHJvdXRlci1saW5rIHYtaWY9XCJ0b1wiIDp0bz1cInRvXCIgOmNsYXNzPVwiY2xhc3Nlc1wiIEBjbGljaz1cIm9uQ2xpY2tcIj5cbiAgICAgICAgPHNsb3Q+e3tsYWJlbH19PC9zbG90PiA8YmFkZ2Ugdi1pZj1cImJhZGdlXCIgdi1iaW5kPVwiYmFkZ2VPcHRpb25zXCI+PC9iYWRnZT5cbiAgICA8L3JvdXRlci1saW5rPlxuICAgIDxhIHYtZWxzZWlmPVwiaHJlZlwiIDpocmVmPVwiaHJlZlwiIDpjbGFzcz1cImNsYXNzZXNcIiBAY2xpY2s9XCJvbkNsaWNrXCI+XG4gICAgICAgIDxzbG90Pnt7bGFiZWx9fTwvc2xvdD4gPGJhZGdlIHYtaWY9XCJiYWRnZVwiIHYtYmluZD1cImJhZGdlT3B0aW9uc1wiPjwvYmFkZ2U+XG4gICAgPC9hPlxuICAgIDxidXR0b24gdi1lbHNlLWlmPVwiYWN0aW9uXCIgdHlwZT1cImJ1dHRvblwiIDpjbGFzcz1cImNsYXNzZXNcIiBAY2xpY2sucHJldmVudD1cIm9uQ2xpY2tcIj5cbiAgICAgICAgPHNsb3Q+e3tsYWJlbH19PC9zbG90PiA8YmFkZ2Ugdi1pZj1cImJhZGdlXCIgdi1iaW5kPVwiYmFkZ2VPcHRpb25zXCI+PC9iYWRnZT5cbiAgICA8L2J1dHRvbj5cbiAgICA8ZGl2IHYtZWxzZSA6Y2xhc3M9XCJjbGFzc2VzXCIgQGNsaWNrPVwib25DbGlja1wiPlxuICAgICAgICA8c2xvdD57e2xhYmVsfX08L3Nsb3Q+IDxiYWRnZSB2LWlmPVwiYmFkZ2VcIiB2LWJpbmQ9XCJiYWRnZU9wdGlvbnNcIj48L2JhZGdlPlxuICAgIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cblxuaW1wb3J0IHsgaXNPYmplY3QgfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IEJhZGdlIGZyb20gJy4uL0JhZGdlJztcbmltcG9ydCBwcmVmaXggZnJvbSAnLi4vLi4vSGVscGVycy9QcmVmaXgvUHJlZml4JztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgY29tcG9uZW50czoge1xuICAgICAgICBCYWRnZVxuICAgIH0sXG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYmFkZ2UgbGFiZWwgKGlmIG51bWJlciBvciBzdHJpbmcpIG9yIG9iamVjdCBvZiBvcHRpb25zIHRvIHBhc3MgdG9cbiAgICAgICAgICogdGhlIGNvbXBvbmVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ3xPYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIGJhZGdlOiBbTnVtYmVyLCBTdHJpbmcsIE9iamVjdF0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsaXN0IGdyb3VwIGl0ZW0gaHJlZiBhdHRyaWJ1dGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGhyZWY6IFN0cmluZyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGxpc3QgZ3JvdXAgaXRlbSB2YXJpYW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICB2YXJpYW50OiBTdHJpbmcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9wdGlvbmFsbHkgcGFzcyB0aGUgaXRlbSBhcyBhIG9iamVjdCB0byB1c2UgcHJvZ3JhbW1hdGljYWxseSBsYXRlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgaXRlbTogT2JqZWN0LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbGlzdCBncm91cCBpdGVtIGFuIGFjdGlvbiwgb3IgY2xpY2thYmxlIGl0ZW0uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBCb29sZWFuXG4gICAgICAgICAqL1xuICAgICAgICBhY3Rpb246IHtcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbGlzdCBncm91cCBpdGVtIGFjdGl2ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IEJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIGFjdGl2ZToge1xuICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsaXN0IGdyb3VwIGl0ZW0gZGlzYWJsZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBCb29sZWFuXG4gICAgICAgICAqL1xuICAgICAgICBkaXNhYmxlZDoge1xuICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsaXN0IGl0ZW0gbGFiZWwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBPYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgICB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLFxuICAgICAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRvIGF0dHJpYnV0ZSB0byBiZSBwYXNzZWQgdG8gYSA8cm91dGVyLWxpbms+IGNvbXBvbmVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgdG86IFtTdHJpbmcsIE9iamVjdF1cblxuICAgIH0sXG5cbiAgICBjb21wdXRlZDoge1xuXG4gICAgICAgIGNsYXNzZXMoKSB7XG4gICAgICAgICAgICBjb25zdCBjbGFzc2VzID0gcHJlZml4KHtcbiAgICAgICAgICAgICAgICAnYWN0aW9uJzogdGhpcy5hY3Rpb24sXG4gICAgICAgICAgICB9LCAnbGlzdC1ncm91cC1pdGVtJyk7XG5cbiAgICAgICAgICAgIGNsYXNzZXNbJ2xpc3QtZ3JvdXAtaXRlbSddID0gdHJ1ZTtcbiAgICAgICAgICAgIGNsYXNzZXNbJ2FjdGl2ZSddID0gdGhpcy5pc0FjdGl2ZTtcbiAgICAgICAgICAgIGNsYXNzZXNbJ2Rpc2FibGVkJ10gPSB0aGlzLmlzRGlzYWJsZWQ7XG5cbiAgICAgICAgICAgIGlmKHRoaXMudmFyaWFudCkge1xuICAgICAgICAgICAgICAgIGNsYXNzZXNbcHJlZml4KHRoaXMudmFyaWFudCwgJ2xpc3QtZ3JvdXAtaXRlbScpXSA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjbGFzc2VzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGJhZGdlT3B0aW9ucygpIHtcbiAgICAgICAgICAgIHJldHVybiBpc09iamVjdCh0aGlzLmJhZGdlKSA/IHRoaXMuYmFkZ2UgOiB7XG4gICAgICAgICAgICAgICAgbGFiZWw6IHRoaXMuYmFkZ2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBtZXRob2RzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRvZ2dsZSB0aGUgbGlzdCBpdGVtJ3MgYWN0aXZlIGNsYXNzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgICAgICovXG4gICAgICAgIHRvZ2dsZSgpIHtcbiAgICAgICAgICAgIHRoaXMuaXNBY3RpdmUgPSAhdGhpcy5pc0FjdGl2ZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWN0aXZhdGUgdGhlIGxpc3QgaXRlbS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB2b2lkXG4gICAgICAgICAqL1xuICAgICAgICBhY3RpdmF0ZSgpIHtcbiAgICAgICAgICAgIHRoaXMuaXNBY3RpdmUgPSB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWFjdGl2YXRlIHRoZSBsaXN0IGl0ZW0uXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAgICAgKi9cbiAgICAgICAgZGVhY3RpdmF0ZSgpIHtcbiAgICAgICAgICAgIHRoaXMuaXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWN0aXZhdGUgdGhlIGxpc3QgaXRlbS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB2b2lkXG4gICAgICAgICAqL1xuICAgICAgICBkaXNhYmxlKCkge1xuICAgICAgICAgICAgdGhpcy5pc0Rpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlYWN0aXZhdGUgdGhlIGxpc3QgaXRlbS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB2b2lkXG4gICAgICAgICAqL1xuICAgICAgICBlbmFibGUoKSB7XG4gICAgICAgICAgICB0aGlzLmlzRGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGZvciB0aGUgYGNsaWNrYCBldmVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB2b2lkXG4gICAgICAgICAqL1xuICAgICAgICBvbkNsaWNrKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCdjbGljaycsIGV2ZW50LCB0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIHdhdGNoOiB7XG5cbiAgICAgICAgaXNBY3RpdmUodmFsdWUsIHByZXZWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgndXBkYXRlOmFjdGl2ZScsIHRoaXMuaXNBY3RpdmUpO1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgndG9nZ2xlJywgdGhpcy5pc0FjdGl2ZSwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KHZhbHVlID8gJ2FjdGl2YXRlJyA6ICdkZWFjdGl2YXRlJywgdGhpcyk7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNBY3RpdmU6IHRoaXMuYWN0aXZlLFxuICAgICAgICAgICAgaXNEaXNhYmxlZDogdGhpcy5kaXNhYmxlZFxuICAgICAgICB9O1xuICAgIH1cblxufVxuXG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgICA8ZGl2IGNsYXNzPVwibGlzdC1ncm91cFwiIDpjbGFzcz1cImNsYXNzZXNcIj5cbiAgICAgICAgPHNsb3Q+XG4gICAgICAgICAgICA8bGlzdC1ncm91cC1pdGVtIHYtZm9yPVwiKGl0ZW0sIGtleSkgaW4gaXRlbXNcIiA6a2V5PVwia2V5XCIgdi1iaW5kPVwiaXRlbVwiLz5cbiAgICAgICAgPC9zbG90PlxuICAgIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cblxuaW1wb3J0IHsgZWFjaCB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgTGlzdEdyb3VwSXRlbSBmcm9tICcuL0xpc3RHcm91cEl0ZW0nO1xuaW1wb3J0IHByZWZpeCBmcm9tICcuLi8uLi9IZWxwZXJzL1ByZWZpeC9QcmVmaXgnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBjb21wb25lbnRzOiB7XG4gICAgICAgIExpc3RHcm91cEl0ZW1cbiAgICB9LFxuXG4gICAgcHJvcHM6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gYXJyYXkgb2YgbGlzdCBpdGVtIG9iamVjdHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFt7bGFiZWw6ICdTb21lIExhYmVsJywgYmFkZ2U6IDF9XVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgT2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBpdGVtczogQXJyYXksXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbiB0aGUgbGlzdCBpdGVtcyBiZSBhY3RpdmF0ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBCb29sZWFuXG4gICAgICAgICAqL1xuICAgICAgICBhY3RpdmF0ZWFibGU6IHtcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbGlzdCBncm91cCBhcHBlYXIgZmx1c2ggKHdpdGhvdXQgc29tZSBib3JkZXJzKS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IEJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIGZsdXNoOiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FuIGFjdGl2YXRlIG11bHRpcGxlIGxpc3QgaXRlbXNcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IEJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIG11bHRpcGxlOiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIGNsYXNzZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJlZml4KHtcbiAgICAgICAgICAgICAgICAnZmx1c2gnOiB0aGlzLmZsdXNoXG4gICAgICAgICAgICB9LCAnbGlzdC1ncm91cCcpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1ldGhvZHM6IHtcblxuICAgICAgICBiaW5kRXZlbnRzVG9DaGlsZHJlbigpIHtcbiAgICAgICAgICAgIGVhY2godGhpcy4kY2hpbGRyZW4sIGNoaWxkID0+IHtcbiAgICAgICAgICAgICAgICBjaGlsZC4kb2ZmKCdjbGljaycsIHRoaXMub25DbGlja0l0ZW0pO1xuICAgICAgICAgICAgICAgIGNoaWxkLiRvbignY2xpY2snLCB0aGlzLm9uQ2xpY2tJdGVtKTtcbiAgICAgICAgICAgICAgICBjaGlsZC4kb2ZmKCdhY3RpdmF0ZScsIHRoaXMub25BY3RpdmF0ZSk7XG4gICAgICAgICAgICAgICAgY2hpbGQuJG9uKCdhY3RpdmF0ZScsIHRoaXMub25BY3RpdmF0ZSk7XG4gICAgICAgICAgICAgICAgY2hpbGQuJG9mZignZGVhY3RpdmF0ZScsIHRoaXMub25EZWFjdGl2YXRlKTtcbiAgICAgICAgICAgICAgICBjaGlsZC4kb24oJ2RlYWN0aXZhdGUnLCB0aGlzLm9uRGVhY3RpdmF0ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbkNsaWNrSXRlbShldmVudCwgY2hpbGQpIHtcbiAgICAgICAgICAgIGlmKHRoaXMuYWN0aXZhdGVhYmxlKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQudG9nZ2xlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2l0ZW06Y2xpY2snLCBldmVudCwgY2hpbGQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uQWN0aXZhdGUoaXRlbSkge1xuICAgICAgICAgICAgaWYoIXRoaXMubXVsdGlwbGUgJiYgdGhpcy5hY3RpdmVJdGVtICE9PSBpdGVtKSB7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5hY3RpdmVJdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlSXRlbS5kZWFjdGl2YXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVJdGVtID0gaXRlbTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy4kZW1pdCgnaXRlbTphY3RpdmF0ZScsIGV2ZW50LCBpdGVtKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbkRlYWN0aXZhdGUoaXRlbSkge1xuICAgICAgICAgICAgaWYoIXRoaXMubXVsdGlwbGUgJiYgdGhpcy5hY3RpdmVJdGVtID09PSBpdGVtKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVJdGVtID0gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy4kZW1pdCgnaXRlbTpkZWFjdGl2YXRlJywgZXZlbnQsIGl0ZW0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhY3RpdmVJdGVtOiBudWxsXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbW91bnRlZCgpIHtcbiAgICAgICAgdGhpcy5iaW5kRXZlbnRzVG9DaGlsZHJlbigpO1xuICAgIH0sXG5cbiAgICB1cGRhdGVkKCkge1xuICAgICAgICB0aGlzLmJpbmRFdmVudHNUb0NoaWxkcmVuKCk7XG4gICAgfVxuXG59XG5cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IExpc3RHcm91cCBmcm9tICcuL0xpc3RHcm91cCc7XG5pbXBvcnQgVnVlSW5zdGFsbGVyIGZyb20gJy4uLy4uL0hlbHBlcnMvVnVlSW5zdGFsbGVyL1Z1ZUluc3RhbGxlcic7XG5cbmNvbnN0IHBsdWdpbiA9IFZ1ZUluc3RhbGxlci51c2Uoe1xuXG4gICAgaW5zdGFsbChWdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgVnVlSW5zdGFsbGVyLmNvbXBvbmVudHMoe1xuICAgICAgICAgICAgTGlzdEdyb3VwXG4gICAgICAgIH0pO1xuICAgIH1cblxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IExpc3RHcm91cDtcbiIsImltcG9ydCBNb2RhbCBmcm9tICcuL01vZGFsJztcbmltcG9ydCBNb2RhbEJhY2tkcm9wIGZyb20gJy4vTW9kYWxCYWNrZHJvcCc7XG5pbXBvcnQgTW9kYWxCb2R5IGZyb20gJy4vTW9kYWxCb2R5JztcbmltcG9ydCBNb2RhbENvbnRlbnQgZnJvbSAnLi9Nb2RhbENvbnRlbnQnO1xuaW1wb3J0IE1vZGFsRGlhbG9nIGZyb20gJy4vTW9kYWxEaWFsb2cnO1xuaW1wb3J0IE1vZGFsRm9vdGVyIGZyb20gJy4vTW9kYWxGb290ZXInO1xuaW1wb3J0IE1vZGFsSGVhZGVyIGZyb20gJy4vTW9kYWxIZWFkZXInO1xuaW1wb3J0IFZ1ZUluc3RhbGxlciBmcm9tICcuLi8uLi9IZWxwZXJzL1Z1ZUluc3RhbGxlci9WdWVJbnN0YWxsZXInO1xuXG5jb25zdCBwbHVnaW4gPSBWdWVJbnN0YWxsZXIudXNlKHtcblxuICAgIGluc3RhbGwoVnVlLCBvcHRpb25zKSB7XG4gICAgICAgIFZ1ZUluc3RhbGxlci5jb21wb25lbnRzKHtcbiAgICAgICAgICAgIE1vZGFsXG4gICAgICAgIH0pO1xuICAgIH1cblxufSk7XG5cbmV4cG9ydCB7XG4gICAgTW9kYWxCYWNrZHJvcCxcbiAgICBNb2RhbEJvZHksXG4gICAgTW9kYWxDb250ZW50LFxuICAgIE1vZGFsRGlhbG9nLFxuICAgIE1vZGFsRm9vdGVyLFxuICAgIE1vZGFsSGVhZGVyXG59XG5cbmV4cG9ydCBkZWZhdWx0IE1vZGFsO1xuIiwiPHRlbXBsYXRlPlxuICAgIDxjb21wb25lbnQgY2xhc3M9XCJuYXZiYXItYnJhbmRcIiA6Y2xhc3M9XCJ7J2gxJzogaDF9XCIgOmlzPVwiY29tcG9uZW50XCIgOnRvPVwidG9cIiA6aHJlZj1cImhyZWZcIj5cbiAgICAgICAgPGltZyB2LWlmPVwic3JjXCIgY2xhc3M9XCJkLWlubGluZS1ibG9jayBhbGlnbi1jZW50ZXJcIiA6c3JjPVwic3JjXCIgOndpZHRoPVwidW5pdCh3aWR0aClcIiA6aGVpZ2h0PVwidW5pdChoZWlnaHQpXCIgOmFsdD1cImFsdFwiLz5cbiAgICAgICAgPHNsb3QvPlxuICAgIDwvY29tcG9uZW50PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCB1bml0IGZyb20gJy4uLy4uL0hlbHBlcnMvVW5pdCc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBpbWcgYGFsdGAgYXR0cmlidXRlLiBgc3JjYCBtdXN0IGJlIGRlZmluZSBiZWZvcmUgdGhpcyBwcm9wIGhhc1xuICAgICAgICAgKiBhbnkgYWZmZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgT2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBhbHQ6IFN0cmluZyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIEhUTUwgd3JhcHBpbmcgdGFnLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgT2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICB0YWc6IFN0cmluZyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGltZyBgd2lkdGhgIGF0dHJpYnV0ZS4gYHNyY2AgbXVzdCBiZSBkZWZpbmUgYmVmb3JlIHRoaXMgcHJvcCBoYXNcbiAgICAgICAgICogYW55IGFmZmVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IE9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgd2lkdGg6IFtOdW1iZXIsIFN0cmluZ10sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBpbWcgYGhlaWdodGAgYXR0cmlidXRlLiBgc3JjYCBtdXN0IGJlIGRlZmluZSBiZWZvcmUgdGhpcyBwcm9wIGhhc1xuICAgICAgICAgKiBhbnkgYWZmZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgT2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBoZWlnaHQ6IFtOdW1iZXIsIFN0cmluZ10sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBgdG9gIGF0dHJpYnV0ZSB0aGF0IGlzIHBhc3NlZCB0byB0aGUgY29tcG9uZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgT2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICB0bzogW09iamVjdCwgU3RyaW5nXSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGBocmVmYCBhdHRyaWJ1dGUgdGhhdCBpcyBwYXNzZWQgdG8gdGhlIGNvbXBvbmVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IE9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgaHJlZjogU3RyaW5nLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcHBlbmQgdGhlIGBoMWAgY2xhc3MgdG8gaW5jcmVhc2UgdGhlIGRpc3BsYXkgc2l6ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgT2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBoMTogQm9vbGVhbixcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgYSBgc3JjYCBhdHRyaWJ1dGUgaXMgcGFzc2VkLCB0aGVuIHVzZSBpdCB0byBhZGQgYW4gaW1nIHRhZ1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgT2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBzcmM6IFN0cmluZyxcblxuICAgIH0sXG5cbiAgICBjb21wdXRlZDoge1xuXG4gICAgICAgIGNvbXBvbmVudCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRhZyB8fCAodGhpcy50byA/ICdyb3V0ZXItbGluaycgOiAodGhpcy5ocmVmID8gJ2EnIDogJ3NwYW4nKSk7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBtZXRob2RzOiB7XG4gICAgICAgIHVuaXQodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB1bml0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cblxufVxuXG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgICA8ZGl2IGNsYXNzPVwibmF2YmFyLWNvbGxhcHNlXCIgaWQ9XCJuYXZiYXJDb2xsYXBzZVwiIDpjbGFzcz1cInsnY29sbGFwc2UnOiBjb2xsYXBzZX1cIj5cbiAgICAgICAgPHNsb3QvPlxuICAgIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICduYXZiYXItY29sbGFwc2UnLFxuXG4gICAgcHJvcHM6IHtcblxuICAgICAgICBjb2xsYXBzZToge1xuICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICAgICAgfVxuXG4gICAgfVxuXG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgICA8c3BhbiBjbGFzcz1cIm5hdmJhci10ZXh0XCI+XG4gICAgICAgIDxzbG90Lz5cbiAgICA8L3NwYW4+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ25hdmJhci10ZXh0J1xuXG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgICA8c3BhbiBjbGFzcz1cIm5hdmJhci10b2dnbGVyLWljb25cIj5cbiAgICAgICAgPHNsb3QvPlxuICAgIDwvc3Bhbj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAnbmF2YmFyLXRvZ2dsZXItaWNvbidcblxufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gICAgPGJ1dHRvblxuICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgY2xhc3M9XCJuYXZiYXItdG9nZ2xlclwiXG4gICAgICAgIGRhdGEtdG9nZ2xlPVwiY29sbGFwc2VcIlxuICAgICAgICA6ZGF0YS10YXJnZXQ9XCJ0YXJnZXRcIlxuICAgICAgICA6YXJpYS1jb250cm9scz1cInRhcmdldFwiXG4gICAgICAgIDphcmlhLWV4cGFuZGVkPVwiZXhwYW5kZWRcIlxuICAgICAgICA6YXJpYS1sYWJlbD1cImxhYmVsXCJcbiAgICAgICAgQGNsaWNrPVwib25DbGlja1wiPlxuICAgICAgICA8c2xvdD48bmF2YmFyLXRvZ2dsZXItaWNvbi8+PC9zbG90PlxuICAgIDwvYnV0dG9uPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBOYXZiYXJUb2dnbGVySWNvbiBmcm9tICcuL05hdmJhclRvZ2dsZXJJY29uJztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ25hdmJhci10b2dnbGVyJyxcblxuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgICAgTmF2YmFyVG9nZ2xlckljb25cbiAgICB9LFxuXG4gICAgcHJvcHM6IHtcblxuICAgICAgICBleHBhbmRlZDogQm9vbGVhbixcblxuICAgICAgICBsYWJlbDoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJ1RvZ2dsZSBuYXZpZ2F0aW9uJ1xuICAgICAgICB9LFxuXG4gICAgICAgIHRhcmdldDoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJy5uYXZiYXItY29sbGFwc2UnXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBtZXRob2RzOiB7XG5cbiAgICAgICAgb25DbGljayhldmVudCkge1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgnY2xpY2snLCBldmVudCwgdGhpcyk7XG4gICAgICAgIH1cblxuICAgIH1cblxufVxuXG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgICA8bmF2IDpjbGFzcz1cImNsYXNzZXNcIj5cbiAgICAgICAgPHNsb3QvPlxuICAgIDwvbmF2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCB7IGVhY2ggfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IHsgaXNCb29sZWFuIH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCBwcmVmaXggZnJvbSAnLi4vLi4vSGVscGVycy9QcmVmaXgnO1xuaW1wb3J0IFZhcmlhbnQgZnJvbSAnLi4vLi4vTWl4aW5zL1ZhcmlhbnQnO1xuaW1wb3J0IENvbG9yYWJsZSBmcm9tICcuLi8uLi9NaXhpbnMvQ29sb3JhYmxlJztcbmltcG9ydCBOYXZiYXJCcmFuZCBmcm9tICcuL05hdmJhckJyYW5kJztcbmltcG9ydCBOYXZiYXJDb2xsYXBzZSBmcm9tICcuL05hdmJhckNvbGxhcHNlJztcbmltcG9ydCBOYXZiYXJUZXh0IGZyb20gJy4vTmF2YmFyVGV4dCc7XG5pbXBvcnQgTmF2YmFyVG9nZ2xlciBmcm9tICcuL05hdmJhclRvZ2dsZXInO1xuaW1wb3J0IE5hdmJhclRvZ2dsZXJJY29uIGZyb20gJy4vTmF2YmFyVG9nZ2xlckljb24nO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAnbmF2YmFyJyxcblxuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgICAgTmF2YmFyQnJhbmQsXG4gICAgICAgIE5hdmJhckNvbGxhcHNlLFxuICAgICAgICBOYXZiYXJUZXh0LFxuICAgICAgICBOYXZiYXJUb2dnbGVyLFxuICAgICAgICBOYXZiYXJUb2dnbGVySWNvblxuICAgIH0sXG5cbiAgICBtaXhpbnM6IFtcbiAgICAgICAgVmFyaWFudCxcbiAgICAgICAgQ29sb3JhYmxlXG4gICAgXSxcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV4cGFuZCB0aGUgbmF2YmFyLiBJZiB0cnVlLCBhcHBsaWVzIHRvIGFsbCBzaXplLCBvdGhlcndpc2UgcGFzcyBhIHN0cmluZy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IE9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgZXhwYW5kOiB7XG4gICAgICAgICAgICB0eXBlOiBbQm9vbGVhbiwgU3RyaW5nXSxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdsZycsXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIFsneHMnLCAnc20nLCAnbWQnLCAnbGcnLCAneGwnXS5pbmRleE9mKHZhbHVlKSAhPT0gLTEgfHwgaXNCb29sZWFuKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNob3VsZCB0aGUgbmF2YmFyIGJlIGZpeGVkIGF0IHRoZSB0b3AuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGZpeGVkOiB7XG4gICAgICAgICAgICB0eXBlOiBbU3RyaW5nLCBCb29sZWFuXSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgWyd0b3AnLCAnYm90dG9tJ10uaW5kZXhPZih2YWx1ZSkgIT09IC0xIHx8IGlzQm9vbGVhbih2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzaG91bGQgdGhlIG5hdmJhciBiZSBzdGlja2llZCBhdCB0aGUgdG9wLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBzdGlja3k6IHtcbiAgICAgICAgICAgIHR5cGU6IFtTdHJpbmcsIEJvb2xlYW5dLFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBbJ3RvcCcsICdib3R0b20nXS5pbmRleE9mKHZhbHVlKSAhPT0gLTEgfHwgaXNCb29sZWFuKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHZhcmlhbnQgYXR0cmlidXRlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHZhcmlhbnQ6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdsaWdodCcsXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbJ2xpZ2h0JywgJ2RhcmsnXS5pbmRleE9mKHZhbHVlKSAhPT0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBjb21wdXRlZDoge1xuXG4gICAgICAgIGV4cGFuZGVkQ2xhc3MoKSB7XG4gICAgICAgICAgICBpZihpc0Jvb2xlYW4odGhpcy5leHBhbmQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhwYW5kO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcHJlZml4KHByZWZpeCh0aGlzLmV4cGFuZCwgJ2V4cGFuZCcpLCAnbmF2YmFyJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xhc3NlcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRtZXJnZUNsYXNzZXMoXG4gICAgICAgICAgICAgICAgJ25hdmJhcicsXG4gICAgICAgICAgICAgICAgcHJlZml4KHRoaXMuc3RpY2t5ID09PSB0cnVlID8gJ3RvcCcgOiB0aGlzLnN0aWNreSwgJ3N0aWNreScpLFxuICAgICAgICAgICAgICAgIHByZWZpeCh0aGlzLmZpeGVkID09PSB0cnVlID8gJ3RvcCcgOiB0aGlzLmZpeGVkLCAnZml4ZWQnKSxcbiAgICAgICAgICAgICAgICB0aGlzLmV4cGFuZGVkQ2xhc3MsXG4gICAgICAgICAgICAgICAgdGhpcy52YXJpYW50Q2xhc3MsXG4gICAgICAgICAgICAgICAgdGhpcy5jb2xvcmFibGVDbGFzc2VzXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7fVxuICAgIH1cblxufVxuXG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgICA8Y29tcG9uZW50IDppcz1cImNvbXBvbmVudFwiIDpocmVmPVwiaHJlZlwiIDp0bz1cInRvXCIgOmNsYXNzPVwiY2xhc3Nlc1wiPlxuICAgICAgICA8c2xvdCAvPlxuICAgIDwvY29tcG9uZW50PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICduYXZpZ2F0aW9uLWxpbmsnLFxuXG4gICAgcHJvcHM6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSXMgdGhlIG5hdmlnYXRpb24gaXRlbSBhY3RpdmVcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3Age0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBhY3RpdmU6IEJvb2xlYW4sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElzIHRoZSBuYXZpZ2F0aW9uIGl0ZW0gZGlzYWJsZWRcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3Age0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBkaXNhYmxlZDogQm9vbGVhbixcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGhyZWYgYXR0cmlidXRlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wIHtTdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBocmVmOiBTdHJpbmcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjb21wb25lbnQgSFRNTCB0YWdcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3Age1N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRhZzogU3RyaW5nLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdG8gYXR0cmlidXRlLCB3aWxsIGJlIHBhc3NlZCB0byByb3V0ZXItbGluay5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3Age1N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRvOiBbT2JqZWN0LCBTdHJpbmddLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgdGhlIG5hdi1pdGVtIGNsYXNzIHRvIHRoZSBsaW5rXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wIHtCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgaXRlbToge1xuICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGNvbXB1dGVkOiB7XG5cbiAgICAgICAgY29tcG9uZW50KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGFnIHx8ICh0aGlzLnRvID8gJ3JvdXRlci1saW5rJyA6ICdhJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xhc3NlcygpIHtcbiAgICAgICAgICAgIHRoaXMuJG5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZighdGhpcy5pc0l0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0l0ZW0gPSAhdGhpcy4kcGFyZW50LiRlbC5jbGFzc0xpc3QuY29udGFpbnMoJ25hdi1pdGVtJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgJ25hdi1saW5rJzogdGhpcy5ocmVmLFxuICAgICAgICAgICAgICAgICduYXYtaXRlbSc6IHRoaXMuaXRlbSxcbiAgICAgICAgICAgICAgICAnYWN0aXZlJzogdGhpcy5hY3RpdmUsXG4gICAgICAgICAgICAgICAgJ2Rpc2FibGVkJzogdGhpcy5kaXNhYmxlZFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG5cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICAgIDxjb21wb25lbnQgOmlzPVwiY29tcG9uZW50XCIgOmNsYXNzPVwiY2xhc3Nlc1wiPlxuICAgICAgICA8c2xvdCAvPlxuICAgIDwvY29tcG9uZW50PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBOYXZpZ2F0aW9uTGluayBmcm9tICcuL05hdmlnYXRpb25MaW5rJztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ25hdmlnYXRpb24taXRlbScsXG5cbiAgICBleHRlbmRzOiBOYXZpZ2F0aW9uTGluayxcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBIVE1MIGVsZW1lbnRcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3Age1N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIGVsZW1lbnQ6IFN0cmluZyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSXMgdGhlIGNvbXBvbmVudCBhIGxpc3QgZWxlbWVudFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcCB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGxpc3Q6IEJvb2xlYW4sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCB0aGUgbmF2LWl0ZW0gY2xhc3MgdG8gdGhlIGxpbmtcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3Age0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBpdGVtOiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgICB9XG5cbiAgICB9LFxuXG5cbiAgICBjb21wdXRlZDoge1xuXG4gICAgICAgIGNvbXBvbmVudCgpIHtcbiAgICAgICAgICAgIGlmKHRoaXMuZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKHRoaXMuaHJlZikge1xuICAgICAgICAgICAgICAgIHJldHVybiAnYSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKHRoaXMubGlzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnbGknO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gJ2Rpdic7XG4gICAgICAgIH1cblxuICAgIH1cblxufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gICAgPG5hdiBjbGFzcz1cIm5hdlwiIDpjbGFzcz1cImNsYXNzZXNcIiA6cm9sZT1cInJvbGVcIj5cbiAgICAgICAgPHNsb3QvPlxuICAgIDwvbmF2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBOYXZpZ2F0aW9uSXRlbSBmcm9tICcuL05hdmlnYXRpb25JdGVtJztcbmltcG9ydCBwcmVmaXggZnJvbSAnLi4vLi4vSGVscGVycy9QcmVmaXgvUHJlZml4JztcbmltcG9ydCBDb2xvcmFibGUgZnJvbSAnLi4vLi4vTWl4aW5zL0NvbG9yYWJsZS9Db2xvcmFibGUnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBuYW1lOiAnbmF2aWdhdGlvbicsXG5cbiAgICBjb21wb25lbnRzOiB7XG4gICAgICAgIE5hdmlnYXRpb25JdGVtXG4gICAgfSxcblxuICAgIG1peGluczogW1xuICAgICAgICBDb2xvcmFibGVcbiAgICBdLFxuXG4gICAgcHJvcHM6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSGVscGVyIHRvIGFkZCB0aGUganVzdGlmeS1jb250ZW50LVggY2xhc3MuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wIHtBcnJheX1cbiAgICAgICAgICovXG4gICAgICAgIGFsaWduOiBTdHJpbmcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGFycmF5IG9mIGJ1dHRvbnNcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3Age0FycmF5fVxuICAgICAgICAgKi9cbiAgICAgICAgYnV0dG9uczogQXJyYXksXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBuYXZpZ2F0aW9uIGluc2lkZSBhIGNhcmRcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3Age0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBjYXJkOiBCb29sZWFuLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBKdXN0aWZ5IG5hdiBpdGVtcyB0byBmaWxsIHRoZSB3aWR0aCBlcXVhbGx5ICh1c2luZyBmbGV4KS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3Age0FycmF5fVxuICAgICAgICAgKi9cbiAgICAgICAgZmlsbDogQm9vbGVhbixcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkIGBuYXYtanVzdGlmaWVkYCBjbGFzcyB0byB0aGUgY29tcG9uZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcCB7QXJyYXl9XG4gICAgICAgICAqL1xuICAgICAgICBqdXN0aWZpZWQ6IEJvb2xlYW4sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc3BsYXkgaXRlbXMgYXMgcGlsbCBzaGFwZXNcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3Age0FycmF5fVxuICAgICAgICAgKi9cbiAgICAgICAgcGlsbHM6IEJvb2xlYW4sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc3BsYXkgaXRlbXMgYXMgdGFiIHNoYXBlc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcCB7QXJyYXl9XG4gICAgICAgICAqL1xuICAgICAgICB0YWJzOiBCb29sZWFuLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwbGF5IHRoZSBidXR0b25zIHZlcnRpY2FsbHlcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3Age0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB2ZXJ0aWNhbDogQm9vbGVhbixcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHJvbGUgYXR0cmlidXRlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wIHtTdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICByb2xlOiBTdHJpbmdcblxuICAgIH0sXG5cbiAgICBjb21wdXRlZDoge1xuXG4gICAgICAgIGNsYXNzZXMoKSB7XG4gICAgICAgICAgICB0aGlzLiRuZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYoIXRoaXMuaXNDYXJkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNDYXJkID0gdGhpcy4kcGFyZW50LiRlbC5jbGFzc0xpc3QuY29udGFpbnMoJ2NhcmQtaGVhZGVyJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRtZXJnZUNsYXNzZXMoXG4gICAgICAgICAgICAgICAgcHJlZml4KHRoaXMuYWxpZ24sICdqdXN0aWZ5LWNvbnRlbnQnKSxcbiAgICAgICAgICAgICAgICB0aGlzLmNvbG9yYWJsZUNsYXNzZXMsIHtcbiAgICAgICAgICAgICAgICAgICAgJ2NhcmQtaGVhZGVyLXRhYnMnOiB0aGlzLmlzQ2FyZCAmJiB0aGlzLnRhYnMsXG4gICAgICAgICAgICAgICAgICAgICdjYXJkLWhlYWRlci1waWxscyc6IHRoaXMuaXNDYXJkICYmIHRoaXMucGlsbHMsXG4gICAgICAgICAgICAgICAgICAgICduYXYtanVzdGlmaWVkJzogdGhpcy5qdXN0aWZpZWQsXG4gICAgICAgICAgICAgICAgICAgICduYXYtZmlsbCc6IHRoaXMuZmlsbCxcbiAgICAgICAgICAgICAgICAgICAgJ25hdi1waWxscyc6IHRoaXMucGlsbHMsXG4gICAgICAgICAgICAgICAgICAgICduYXYtdGFicyc6IHRoaXMudGFicyxcbiAgICAgICAgICAgICAgICAgICAgJ2ZsZXgtY29sdW1uJzogdGhpcy52ZXJ0aWNhbFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNDYXJkOiB0aGlzLmNhcmRcbiAgICAgICAgfTtcbiAgICB9XG5cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuXG4gICAgPG5hdmlnYXRpb24taXRlbSBjbGFzcz1cImRyb3Bkb3duXCI+XG5cbiAgICAgICAgPHNsb3QgbmFtZT1cInRvZ2dsZS1idXR0b25cIj5cbiAgICAgICAgICAgIDxuYXZpZ2F0aW9uLWxpbmtcbiAgICAgICAgICAgICAgICBocmVmPVwiI1wiXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJkcm9wZG93bi10b2dnbGVcIlxuICAgICAgICAgICAgICAgIGRhdGEtdG9nZ2xlPVwiZHJvcGRvd25cIlxuICAgICAgICAgICAgICAgIHJvbGU9XCJidXR0b25cIlxuICAgICAgICAgICAgICAgIGFyaWEtaGFzcG9wdXA9XCJ0cnVlXCJcbiAgICAgICAgICAgICAgICA6YXJpYS1leHBhbmRlZD1cImlzRHJvcGRvd25TaG93aW5nXCJcbiAgICAgICAgICAgICAgICBAY2xpY2submF0aXZlLnByZXZlbnQ9XCJ0b2dnbGUoKVwiXG4gICAgICAgICAgICAgICAgQGJsdXI9XCJvbkJsdXJcIj5cbiAgICAgICAgICAgICAgICB7e2xhYmVsfX1cbiAgICAgICAgICAgIDwvbmF2aWdhdGlvbi1saW5rPlxuICAgICAgICA8L3Nsb3Q+XG5cbiAgICAgICAgPHNsb3QgbmFtZT1cImRyb3Bkb3duLW1lbnVcIj5cbiAgICAgICAgICAgIDxkcm9wZG93bi1tZW51XG4gICAgICAgICAgICAgICAgOmlkPVwiaWRcIlxuICAgICAgICAgICAgICAgIDppdGVtcz1cIml0ZW1zXCJcbiAgICAgICAgICAgICAgICA6YWxpZ249XCJhbGlnblwiXG4gICAgICAgICAgICAgICAgOnNob3cuc3luYz1cImlzRHJvcGRvd25TaG93aW5nXCJcbiAgICAgICAgICAgICAgICBAaXRlbTpjbGljaz1cIm9uSXRlbUNsaWNrXCI+XG4gICAgICAgICAgICAgICAgPHNsb3QvPlxuICAgICAgICAgICAgPC9kcm9wZG93bi1tZW51PlxuICAgICAgICA8L3Nsb3Q+XG5cbiAgICA8L25hdmlnYXRpb24taXRlbT5cblxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBOYXZpZ2F0aW9uSXRlbSBmcm9tICcuL05hdmlnYXRpb25JdGVtJztcbmltcG9ydCBOYXZpZ2F0aW9uTGluayBmcm9tICcuL05hdmlnYXRpb25MaW5rJztcbmltcG9ydCBEcm9wZG93bk1lbnUgZnJvbSAnLi4vRHJvcGRvd25NZW51JztcbmltcG9ydCBCdG5Ecm9wZG93biBmcm9tICcuLi9CdG5Ecm9wZG93bic7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICduYXZpZ2F0aW9uLWRyb3Bkb3duJyxcblxuICAgIGV4dGVuZHM6IEJ0bkRyb3Bkb3duLFxuXG4gICAgY29tcG9uZW50czoge1xuICAgICAgICBCdG5Ecm9wZG93bixcbiAgICAgICAgRHJvcGRvd25NZW51LFxuICAgICAgICBOYXZpZ2F0aW9uSXRlbSxcbiAgICAgICAgTmF2aWdhdGlvbkxpbmtcbiAgICB9XG5cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IE5hdmlnYXRpb24gZnJvbSAnLi9OYXZpZ2F0aW9uJztcbmltcG9ydCBOYXZpZ2F0aW9uSXRlbSBmcm9tICcuL05hdmlnYXRpb25JdGVtJztcbmltcG9ydCBOYXZpZ2F0aW9uTGluayBmcm9tICcuL05hdmlnYXRpb25MaW5rJztcbmltcG9ydCBOYXZpZ2F0aW9uRHJvcGRvd24gZnJvbSAnLi9OYXZpZ2F0aW9uRHJvcGRvd24nO1xuaW1wb3J0IFZ1ZUluc3RhbGxlciBmcm9tICcuLi8uLi9IZWxwZXJzL1Z1ZUluc3RhbGxlci9WdWVJbnN0YWxsZXInO1xuXG5jb25zdCBwbHVnaW4gPSBWdWVJbnN0YWxsZXIudXNlKHtcblxuICAgIGluc3RhbGwoVnVlLCBvcHRpb25zKSB7XG4gICAgICAgIFZ1ZUluc3RhbGxlci5jb21wb25lbnRzKHtcbiAgICAgICAgICAgIE5hdmlnYXRpb24sXG4gICAgICAgICAgICBOYXZpZ2F0aW9uSXRlbSxcbiAgICAgICAgICAgIE5hdmlnYXRpb25MaW5rLFxuICAgICAgICAgICAgTmF2aWdhdGlvbkRyb3Bkb3duXG4gICAgICAgIH0pO1xuICAgIH1cblxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IE5hdmlnYXRpb247XG4iLCI8dGVtcGxhdGU+XG4gICAgPHVsIGNsYXNzPVwibmF2YmFyLW5hdlwiIDpjbGFzcz1cImNsYXNzZXNcIiA6cm9sZT1cInJvbGVcIj5cbiAgICAgICAgPHNsb3QvPlxuICAgIDwvdWw+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IE5hdmlnYXRpb24gZnJvbSAnLi4vTmF2aWdhdGlvbic7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICduYXZiYXItbmF2JyxcblxuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgICAgTmF2aWdhdGlvblxuICAgIH1cblxufVxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgTmF2YmFyIGZyb20gJy4vTmF2YmFyJztcbmltcG9ydCBOYXZiYXJCcmFuZCBmcm9tICcuL05hdmJhckJyYW5kJztcbmltcG9ydCBOYXZiYXJDb2xsYXBzZSBmcm9tICcuL05hdmJhckNvbGxhcHNlJztcbmltcG9ydCBOYXZiYXJOYXYgZnJvbSAnLi9OYXZiYXJOYXYnO1xuaW1wb3J0IE5hdmJhclRleHQgZnJvbSAnLi9OYXZiYXJUZXh0JztcbmltcG9ydCBOYXZiYXJUb2dnbGVyIGZyb20gJy4vTmF2YmFyVG9nZ2xlcic7XG5pbXBvcnQgTmF2YmFyVG9nZ2xlckljb24gZnJvbSAnLi9OYXZiYXJUb2dnbGVySWNvbic7XG5pbXBvcnQgVnVlSW5zdGFsbGVyIGZyb20gJy4uLy4uL0hlbHBlcnMvVnVlSW5zdGFsbGVyL1Z1ZUluc3RhbGxlcic7XG5cbmNvbnN0IHBsdWdpbiA9IFZ1ZUluc3RhbGxlci51c2Uoe1xuXG4gICAgaW5zdGFsbChWdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgVnVlSW5zdGFsbGVyLmNvbXBvbmVudHMoe1xuICAgICAgICAgICAgTmF2YmFyLFxuICAgICAgICAgICAgTmF2YmFyQnJhbmQsXG4gICAgICAgICAgICBOYXZiYXJDb2xsYXBzZSxcbiAgICAgICAgICAgIE5hdmJhck5hdixcbiAgICAgICAgICAgIE5hdmJhclRleHQsXG4gICAgICAgICAgICBOYXZiYXJUb2dnbGVyLFxuICAgICAgICAgICAgTmF2YmFyVG9nZ2xlckljb25cbiAgICAgICAgfSk7XG4gICAgfVxuXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgTmF2YmFyO1xuIiwiaW1wb3J0IE92ZXJsYXkgZnJvbSAnLi9PdmVybGF5JztcbmltcG9ydCBWdWVJbnN0YWxsZXIgZnJvbSAnLi4vLi4vSGVscGVycy9WdWVJbnN0YWxsZXIvVnVlSW5zdGFsbGVyJztcblxuY29uc3QgcGx1Z2luID0gVnVlSW5zdGFsbGVyLnVzZSh7XG5cbiAgICBpbnN0YWxsKFZ1ZSwgb3B0aW9ucykge1xuICAgICAgICBWdWVJbnN0YWxsZXIuY29tcG9uZW50cyh7XG4gICAgICAgICAgICBPdmVybGF5XG4gICAgICAgIH0pO1xuICAgIH1cblxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IE92ZXJsYXk7XG4iLCI8dGVtcGxhdGU+XG4gICAgPG5hdiBhcmlhLWxhYmVsPVwiUGFnZSBuYXZpZ2F0aW9uIGV4YW1wbGVcIj5cbiAgICAgICAgPHVsIGNsYXNzPVwicGFnaW5hdGlvblwiIDpjbGFzcz1cImNsYXNzZXNcIj5cbiAgICAgICAgXHQ8bGkgY2xhc3M9XCJwYWdlLWl0ZW1cIiA6Y2xhc3M9XCJ7J2Rpc2FibGVkJzogY3VycmVudFBhZ2UgPT09IDF9XCI+XG4gICAgICAgIFx0XHQ8YSBocmVmPVwiI1wiIGNsYXNzPVwicGFnZS1saW5rXCIgYXJpYS1sYWJlbD1cIlByZXZpb3VzXCIgQGNsaWNrLnByZXZlbnQ9XCJwcmV2KCRldmVudClcIj5cbiAgICAgICAgXHRcdFx0PHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCI+JmxhcXVvOzwvc3Bhbj5cbiAgICAgICAgXHRcdDwvYT5cbiAgICAgICAgXHQ8L2xpPlxuICAgICAgICAgICAgPGxpIHYtZm9yPVwiaXRlbSBpbiBwYWdlc1wiIDpkYXRhLXBhZ2U9XCJpdGVtLnBhZ2VcIiBjbGFzcz1cInBhZ2UtaXRlbVwiIDpjbGFzcz1cInsnYWN0aXZlJzogaXRlbS5wYWdlID09PSBjdXJyZW50UGFnZSwgJ2Rpc2FibGVkJzogISFpdGVtLmRpdmlkZXJ9XCI+XG4gICAgICAgICAgICAgICAgPHNsb3QgOml0ZW09XCJpdGVtXCI+XG4gICAgICAgICAgICAgICAgICAgIDxhIHYtaWY9XCJpdGVtLmRpdmlkZXJcIiBjbGFzcz1cInBhZ2UtbGlua1wiPiZoZWxsaXA7PC9hPlxuICAgICAgICAgICAgICAgIFx0PGEgdi1lbHNlIGhyZWY9XCIjXCIgY2xhc3M9XCJwYWdlLWxpbmtcIiA6Y2xhc3M9XCJpdGVtLmNsYXNzXCIgOmRhdGEtbGFiZWw9XCJpdGVtLmxhYmVsXCIgQGNsaWNrLnByZXZlbnQ9XCJwYWdpbmF0ZShpdGVtLnBhZ2UsICRldmVudClcIj5cbiAgICAgICAgICAgICAgICBcdFx0PHNwYW4gdi1pZj1cIml0ZW0ubGFiZWxcIiBhcmlhLWhpZGRlbj1cInRydWVcIiB2LWh0bWw9XCJpdGVtLmxhYmVsXCI+PC9zcGFuPlxuICAgICAgICAgICAgICAgIFx0XHQ8c3BhbiB2LWlmPVwiaXRlbS5wYWdlXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCIgdi1odG1sPVwiaXRlbS5wYWdlXCI+PC9zcGFuPlxuICAgICAgICAgICAgICAgIFx0PC9hPlxuICAgICAgICAgICAgICAgIDwvc2xvdD5cbiAgICAgICAgICAgIDwvbGk+XG4gICAgICAgIFx0PGxpIGNsYXNzPVwicGFnZS1pdGVtXCIgOmNsYXNzPVwieydkaXNhYmxlZCc6IGN1cnJlbnRQYWdlID49IHRvdGFsUGFnZXN9XCI+XG4gICAgICAgIFx0XHQ8YSBocmVmPVwiI1wiIGNsYXNzPVwicGFnZS1saW5rXCIgYXJpYS1sYWJlbD1cIk5leHRcIiBAY2xpY2sucHJldmVudD1cIm5leHQoJGV2ZW50KVwiPlxuICAgICAgICBcdFx0XHQ8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj4mcmFxdW87PC9zcGFuPlxuICAgICAgICBcdFx0PC9hPlxuICAgICAgICAgICAgPC9saT5cbiAgICAgICAgPC91bD5cbiAgICA8L25hdj5cblxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdwYWdpbmF0aW9uJyxcblxuICAgIHByb3BzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYWxpZ25tZW50IG9mIHRoZSBwYWdpbmF0aW9uIGNvbXBvbmVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3AgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBhbGlnbjoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgdmFsaWRhdGU6IHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWydzdGFydCcsICdlbmQnLCAnY2VudGVyJ10uaW5kZXhPZih2YWx1ZSkgIT09IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcGFnZSBvbiB3aGljaCB0aGUgcGFnaW5hdG9yIHNob3VsZCBzdGFydC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3AgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBwYWdlOiB7XG4gICAgICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgICAgICBkZWZhdWx0OiAxXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0b3RhbCBudW1iZXIgb2YgcGFnZXMgaW4gdGhlIHBhZ2luYXRvci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3AgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICB0b3RhbFBhZ2VzOiB7XG4gICAgICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgICAgICBkZWZhdWx0OiAxXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBudW1iZXIgb2YgcGFnZXMgdG8gc2hvdyB3aGVuIHRoZSB0b3RhbCBudW1iZXIgb2YgcGFnZXMgaXNcbiAgICAgICAgICogZ3JlYXRlciB0aGFuIHRoZSBudW1iZXIgb2YgcGFnZXMgdGhhdCBzaG91bGQgYmUgc2hvd24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wIFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgc2hvd1BhZ2VzOiB7XG4gICAgICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgICAgICBkZWZhdWx0OiA2XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25QYWdpbmF0ZTogRnVuY3Rpb25cbiAgICB9LFxuXG4gICAgbWV0aG9kczoge1xuXG4gICAgICAgIG5leHQoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMucGFnaW5hdGUodGhpcy5jdXJyZW50UGFnZSA+PSB0aGlzLnRvdGFsUGFnZXMgPyB0aGlzLmN1cnJlbnRQYWdlIDogdGhpcy5jdXJyZW50UGFnZSArIDEsIGV2ZW50KTtcbiAgICAgICAgfSxcblxuICAgICAgICBwcmV2KGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLnBhZ2luYXRlKHRoaXMuY3VycmVudFBhZ2UgPD0gMSA/IHRoaXMuY3VycmVudFBhZ2UgOiB0aGlzLmN1cnJlbnRQYWdlIC0gMSwgZXZlbnQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBhZ2luYXRlKHBhZ2UsIGV2ZW50KSB7XG4gICAgICAgICAgICBpZihldmVudC5jdXJyZW50VGFyZ2V0LnBhcmVudE5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKCdkaXNhYmxlZCcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG5cdFx0XHR0aGlzLnNldEFjdGl2ZVBhZ2UocGFnZSk7XG5cbiAgICAgICAgICAgIGlmKHRoaXMub25QYWdpbmF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMub25QYWdpbmF0ZShwYWdlLCBldmVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ3BhZ2luYXRlJywgcGFnZSwgZXZlbnQpO1xuICAgICAgICB9LFxuXG5cdFx0c2V0QWN0aXZlUGFnZShwYWdlKSB7XG5cdFx0XHRpZih0aGlzLmN1cnJlbnRQYWdlICE9PSBwYWdlKSB7XG5cdFx0XHRcdHRoaXMuY3VycmVudFBhZ2UgPSBwYWdlO1xuXHRcdFx0fVxuXHRcdH0sXG5cbiAgICAgICAgZ2VuZXJhdGUoKSB7XG4gICAgICAgICAgICBjb25zdCBwYWdlcyA9IFtdO1xuICAgICAgICAgICAgY29uc3Qgc2hvd1BhZ2VzID0gdGhpcy5zaG93UGFnZXMgJSAyID8gdGhpcy5zaG93UGFnZXMgKyAxOiB0aGlzLnNob3dQYWdlcztcblxuICAgICAgICAgICAgbGV0IHN0YXJ0UGFnZSA9ICh0aGlzLmN1cnJlbnRQYWdlID49IHNob3dQYWdlcykgPyB0aGlzLmN1cnJlbnRQYWdlIC0gKHNob3dQYWdlcyAvIDIpIDogMTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gc2hvd1BhZ2VzICsgc3RhcnRQYWdlO1xuICAgICAgICAgICAgY29uc3QgZW5kUGFnZSA9ICh0aGlzLnRvdGFsUGFnZXMgPCBzdGFydE9mZnNldCkgPyB0aGlzLnRvdGFsUGFnZXMgOiBzdGFydE9mZnNldDtcbiAgICAgICAgICAgIGNvbnN0IGRpZmYgPSBzdGFydFBhZ2UgLSBlbmRQYWdlICsgc2hvd1BhZ2VzO1xuXG4gICAgICAgICAgICBzdGFydFBhZ2UgLT0gKHN0YXJ0UGFnZSAtIGRpZmYgPiAwKSA/IGRpZmYgOiAwO1xuXG4gICAgICAgICAgICBpZiAoc3RhcnRQYWdlID4gMSkge1xuICAgICAgICAgICAgICAgIHBhZ2VzLnB1c2goe3BhZ2U6IDF9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoc3RhcnRQYWdlID4gMikge1xuICAgICAgICAgICAgICAgIHBhZ2VzLnB1c2goe2RpdmlkZXI6IHRydWV9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yKGxldCBpID0gc3RhcnRQYWdlOyBpIDwgZW5kUGFnZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcGFnZXMucHVzaCh7cGFnZTogaX0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZW5kUGFnZSA8PSB0aGlzLnRvdGFsUGFnZXMpIHtcbiAgICAgICAgICAgICAgICBpZih0aGlzLnRvdGFsUGFnZXMgLSAxID4gZW5kUGFnZSkge1xuICAgICAgICAgICAgICAgICAgICBwYWdlcy5wdXNoKHtkaXZpZGVyOiB0cnVlfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcGFnZXMucHVzaCh7cGFnZTogdGhpcy50b3RhbFBhZ2VzfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBwYWdlcztcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGNvbXB1dGVkOiB7XG5cbiAgICAgICAgcGFnZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsYXNzZXMoKSB7XG4gICAgICAgICAgICBjb25zdCBjbGFzc2VzID0ge307XG5cbiAgICAgICAgICAgIGNsYXNzZXNbJ2p1c3RpZnktY29udGVudC0nICsgdGhpcy5hbGlnbl0gPSB0cnVlO1xuXG4gICAgICAgICAgICByZXR1cm4gY2xhc3NlcztcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiAge1xuICAgICAgICAgICAgY3VycmVudFBhZ2U6IHRoaXMucGFnZVxuICAgICAgICB9O1xuICAgIH1cblxufTtcbjwvc2NyaXB0PlxuIiwiaW1wb3J0IFBhZ2luYXRpb24gZnJvbSAnLi9QYWdpbmF0aW9uJztcbmltcG9ydCBWdWVJbnN0YWxsZXIgZnJvbSAnLi4vLi4vSGVscGVycy9WdWVJbnN0YWxsZXIvVnVlSW5zdGFsbGVyJztcblxuY29uc3QgcGx1Z2luID0gVnVlSW5zdGFsbGVyLnVzZSh7XG5cbiAgICBpbnN0YWxsKFZ1ZSwgb3B0aW9ucykge1xuICAgICAgICBWdWVJbnN0YWxsZXIuY29tcG9uZW50cyh7XG4gICAgICAgICAgICBQYWdpbmF0aW9uXG4gICAgICAgIH0pO1xuICAgIH1cblxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IFBhZ2luYXRpb247XG4iLCJpbXBvcnQgUmFkaW9GaWVsZCBmcm9tICcuL1JhZGlvRmllbGQnO1xuaW1wb3J0IFZ1ZUluc3RhbGxlciBmcm9tICcuLi8uLi9IZWxwZXJzL1Z1ZUluc3RhbGxlci9WdWVJbnN0YWxsZXInO1xuXG5jb25zdCBwbHVnaW4gPSBWdWVJbnN0YWxsZXIudXNlKHtcblxuICAgIGluc3RhbGwoVnVlLCBvcHRpb25zKSB7XG4gICAgICAgIFZ1ZUluc3RhbGxlci5jb21wb25lbnRzKHtcbiAgICAgICAgICAgIFJhZGlvRmllbGRcbiAgICAgICAgfSk7XG4gICAgfVxuXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgUmFkaW9GaWVsZDtcbiIsIjx0ZW1wbGF0ZT5cblxuICAgIDxmb3JtLWdyb3VwPlxuXG4gICAgICAgIDxzbG90IG5hbWU9XCJsYWJlbFwiPlxuICAgICAgICAgICAgPGZvcm0tbGFiZWwgdi1pZj1cImxhYmVsXCIgOmZvcj1cImlkXCIgdi1odG1sPVwibGFiZWxcIi8+XG4gICAgICAgIDwvc2xvdD5cblxuICAgICAgICA8c2xvdCBuYW1lPVwiY29udHJvbFwiPlxuICAgICAgICAgICAgPHNlbGVjdFxuICAgICAgICAgICAgICAgIDppZD1cImlkXCJcbiAgICAgICAgICAgICAgICA6bmFtZT1cIm5hbWVcIlxuICAgICAgICAgICAgICAgIDp2YWx1ZT1cInZhbHVlXCJcbiAgICAgICAgICAgICAgICA6cmVxdWlyZWQ9XCJyZXF1aXJlZFwiXG4gICAgICAgICAgICAgICAgOmRpc2FibGVkPVwiZGlzYWJsZWQgfHwgcmVhZG9ubHlcIlxuICAgICAgICAgICAgICAgIDpyZWFkb25seT1cInJlYWRvbmx5XCJcbiAgICAgICAgICAgICAgICA6cGF0dGVybj1cInBhdHRlcm5cIlxuICAgICAgICAgICAgICAgIDpjbGFzcz1cIiRtZXJnZUNsYXNzZXMoY29udHJvbENsYXNzZXMsIGNvbG9yYWJsZUNsYXNzZXMpXCJcbiAgICAgICAgICAgICAgICB2LW9uOmlucHV0PVwidXBkYXRlZCgkZXZlbnQudGFyZ2V0LnZhbHVlKVwiPlxuICAgICAgICAgICAgICAgIDxzbG90IC8+XG4gICAgICAgICAgICA8L3NlbGVjdD5cbiAgICAgICAgPC9zbG90PlxuXG4gICAgICAgIDxzbG90IG5hbWU9XCJoZWxwXCI+XG4gICAgICAgICAgICA8aGVscC10ZXh0IHYtaWY9XCJoZWxwVGV4dFwiIHYtaHRtbD1cImhlbHBUZXh0XCIgLz5cbiAgICAgICAgPC9zbG90PlxuXG4gICAgICAgIDxzbG90IG5hbWU9XCJmZWVkYmFja1wiPlxuICAgICAgICAgICAgPGZvcm0tZmVlZGJhY2sgdi1pZj1cInZhbGlkRmVlZGJhY2tcIiB2LWh0bWw9XCJ2YWxpZEZlZWRiYWNrXCIgdmFsaWQgLz5cbiAgICAgICAgICAgIDxmb3JtLWZlZWRiYWNrIHYtaWY9XCJpbnZhbGlkRmVlZGJhY2tcIiB2LWh0bWw9XCJpbnZhbGlkRmVlZGJhY2tcIiBpbnZhbGlkIC8+XG4gICAgICAgIDwvc2xvdD5cblxuICAgIDwvZm9ybS1ncm91cD5cblxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBIZWxwVGV4dCBmcm9tICcuLi9IZWxwVGV4dCc7XG5pbXBvcnQgRm9ybUdyb3VwIGZyb20gJy4uL0Zvcm1Hcm91cCc7XG5pbXBvcnQgRm9ybUxhYmVsIGZyb20gJy4uL0Zvcm1MYWJlbCc7XG5pbXBvcnQgRm9ybUZlZWRiYWNrIGZyb20gJy4uL0Zvcm1GZWVkYmFjayc7XG5pbXBvcnQgQ29sb3JhYmxlIGZyb20gJy4uLy4uL01peGlucy9Db2xvcmFibGUvQ29sb3JhYmxlJztcbmltcG9ydCBGb3JtQ29udHJvbCBmcm9tICcuLi8uLi9NaXhpbnMvRm9ybUNvbnRyb2wvRm9ybUNvbnRyb2wnO1xuXG5jb25zdCBDVVNUT01fU0VMRUNUX1BSRUZJWCA9ICdjdXN0b20tc2VsZWN0LSdcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ3NlbGVjdC1maWVsZCcsXG5cbiAgICBjb21wb25lbnRzOiB7XG4gICAgICAgIEhlbHBUZXh0LFxuICAgICAgICBGb3JtR3JvdXAsXG4gICAgICAgIEZvcm1MYWJlbCxcbiAgICAgICAgRm9ybUZlZWRiYWNrXG4gICAgfSxcblxuICAgIGV4dGVuZHM6IEZvcm1Db250cm9sLFxuXG4gICAgbWl4aW5zOiBbXG4gICAgICAgIEZvcm1Db250cm9sLFxuICAgICAgICBDb2xvcmFibGVcbiAgICBdLFxuXG4gICAgcHJvcHM6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkIGBjdXN0b20tc2VsZWN0YCB0byB0aGUgZm9ybSBjb250cm9sIGlmIHRydWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGN1c3RvbTogQm9vbGVhblxuXG4gICAgfSxcblxuICAgIGNvbXB1dGVkOiB7XG5cbiAgICAgICAgY29udHJvbENsYXNzKCkge1xuICAgICAgICAgICAgY29uc3QgY29udHJvbENsYXNzID0gdGhpcy5jdXN0b20gPyAnY3VzdG9tLXNlbGVjdCcgOiB0aGlzLmRlZmF1bHRDb250cm9sQ2xhc3M7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wbGFpbnRleHQgPyBgJHtjb250cm9sQ2xhc3N9LXBsYWludGV4dGAgOiBjb250cm9sQ2xhc3M7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3VzdG9tU2VsZWN0Q2xhc3NlcygpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgQ1VTVE9NX1NFTEVDVF9QUkVGSVgucmVwbGFjZSgvXFwtJC8sICcnKSArICh0aGlzLnBsYWludGV4dCA/ICctcGxhaW50ZXh0JyA6ICcnKSxcbiAgICAgICAgICAgICAgICB0aGlzLmN1c3RvbVNlbGVjdFNpemVDbGFzcyxcbiAgICAgICAgICAgICAgICAodGhpcy5zcGFjaW5nIHx8ICcnKVxuICAgICAgICAgICAgXS5qb2luKCcgJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IFNlbGVjdEZpZWxkIGZyb20gJy4vU2VsZWN0RmllbGQnO1xuaW1wb3J0IFZ1ZUluc3RhbGxlciBmcm9tICcuLi8uLi9IZWxwZXJzL1Z1ZUluc3RhbGxlci9WdWVJbnN0YWxsZXInO1xuXG5jb25zdCBwbHVnaW4gPSBWdWVJbnN0YWxsZXIudXNlKHtcblxuICAgIGluc3RhbGwoVnVlLCBvcHRpb25zKSB7XG4gICAgICAgIFZ1ZUluc3RhbGxlci5jb21wb25lbnRzKHtcbiAgICAgICAgICAgIFNlbGVjdEZpZWxkXG4gICAgICAgIH0pO1xuICAgIH1cblxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IFNlbGVjdEZpZWxkO1xuIiwiPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdzbGlkZScsXG5cbiAgICBmdW5jdGlvbmFsOiB0cnVlLFxuXG4gICAgcHJvcHM6IHtcbiAgICAgICAgdm5vZGU6IHtcbiAgICAgICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudGFnICYmIHZhbHVlLmVsbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZW5kZXIoaCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gY29udGV4dC5wcm9wcy52bm9kZTtcbiAgICB9XG5cbn07XG48L3NjcmlwdD5cbiIsImltcG9ydCBiYXNlRmluZEluZGV4IGZyb20gJy4vX2Jhc2VGaW5kSW5kZXguanMnO1xuaW1wb3J0IGJhc2VJdGVyYXRlZSBmcm9tICcuL19iYXNlSXRlcmF0ZWUuanMnO1xuaW1wb3J0IHRvSW50ZWdlciBmcm9tICcuL3RvSW50ZWdlci5qcyc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdFxuICogZWxlbWVudCBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgaW5zdGVhZCBvZiB0aGUgZWxlbWVudCBpdHNlbGYuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAxLjEuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGAtMWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciB1c2VycyA9IFtcbiAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogdHJ1ZSB9XG4gKiBdO1xuICpcbiAqIF8uZmluZEluZGV4KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLnVzZXIgPT0gJ2Jhcm5leSc7IH0pO1xuICogLy8gPT4gMFxuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbmRJbmRleCh1c2VycywgeyAndXNlcic6ICdmcmVkJywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICogLy8gPT4gMVxuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmluZEluZGV4KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gKiAvLyA9PiAwXG4gKlxuICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbmRJbmRleCh1c2VycywgJ2FjdGl2ZScpO1xuICogLy8gPT4gMlxuICovXG5mdW5jdGlvbiBmaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgdmFyIGluZGV4ID0gZnJvbUluZGV4ID09IG51bGwgPyAwIDogdG9JbnRlZ2VyKGZyb21JbmRleCk7XG4gIGlmIChpbmRleCA8IDApIHtcbiAgICBpbmRleCA9IG5hdGl2ZU1heChsZW5ndGggKyBpbmRleCwgMCk7XG4gIH1cbiAgcmV0dXJuIGJhc2VGaW5kSW5kZXgoYXJyYXksIGJhc2VJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCBpbmRleCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZpbmRJbmRleDtcbiIsIjx0ZW1wbGF0ZT5cbiAgICA8IS0tIFRPRE86IEFkZCB0b29sdGlwIHdpdGggc2xpZGUgbmFtZS9rZXkgdG8gdGhlIGNvbnRyb2wgb25jZSB0aGUgdG9vbHRpcCBkaXJlY3RpdmUgaGFzIGJlZW4gd3JpdHRlbi4gLS0+XG4gICAgPGRpdiBjbGFzcz1cInNsaWRlLWRlY2stY29udHJvbHNcIj5cbiAgICAgICAgPGEgdi1mb3I9XCJzbGlkZSBpbiBzbGlkZXNcIiBocmVmPVwiI1wiIEBjbGljay5wcmV2ZW50PVwib25DbGljaygkZXZlbnQsIHNsaWRlKVwiIGNsYXNzPVwic2xpZGUtZGVjay1jb250cm9sLWljb25cIiA6Y2xhc3M9XCJ7J2lzLWFjdGl2ZSc6IChzbGlkZS5kYXRhID8gc2xpZGUuZGF0YS5rZXkgOiBzbGlkZS5rZXkpID09PSBhY3RpdmV9XCI+XG4gICAgICAgICAgICA8aSBjbGFzcz1cImZhIGZhLWNpcmNsZVwiLz5cbiAgICAgICAgPC9hPlxuICAgIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCB7IG1hcCB9IGZyb20gJ2xvZGFzaC1lcyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICdzbGlkZS1kZWNrLWNvbnRyb2xzJyxcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzbGlkZSBrZXkgb3IgaW5kZXggdGhhdCBzaG91bGQgc2hvdy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGFjdGl2ZToge1xuICAgICAgICAgICAgdHlwZTogW1N0cmluZywgTnVtYmVyXSxcbiAgICAgICAgICAgIGRlZmF1bHQ6IDBcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gYXJyYXkgb2Ygc2xpZGUgdm5vZGVzXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBzbGlkZXM6IHtcbiAgICAgICAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIG1ldGhvZHM6IHtcblxuICAgICAgICBvbkNsaWNrKGV2ZW50LCBzbGlkZSkge1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgnY2xpY2snLCBldmVudCwgc2xpZGUpXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBjb21wdXRlZDoge1xuXG4gICAgfSxcblxuICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7fVxuICAgIH1cblxufTtcbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cInNjc3NcIj5cbkBpbXBvcnQgJy4vbm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC9zY3NzL2Z1bmN0aW9ucy5zY3NzJztcbkBpbXBvcnQgJy4vbm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC9zY3NzL3ZhcmlhYmxlcy5zY3NzJztcblxuLnNsaWRlLWRlY2stY29udHJvbHMge1xuICAgIC5zbGlkZS1kZWNrLWNvbnRyb2wtaWNvbiB7XG4gICAgICAgIGNvbG9yOiAkd2hpdGU7XG4gICAgICAgIGZvbnQtc2l6ZTogJGZvbnQtc2l6ZS1iYXNlO1xuXG4gICAgICAgICY6bm90KDpsYXN0LWNoaWxkKSB7XG4gICAgICAgICAgICBtYXJnaW4tcmlnaHQ6ICRmb250LXNpemUtYmFzZSAvIDI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAuc2xpZGUtZGVjay1jb250cm9sLWljb24uaXMtYWN0aXZlIHtcbiAgICAgICAgY29sb3I6ICRwcmltYXJ5O1xuICAgIH1cbn1cbjwvc3R5bGU+XG4iLCI8dGVtcGxhdGU+XG4gICAgPGRpdiBjbGFzcz1cInNsaWRlLWRlY2tcIiA6Y2xhc3M9XCJ7J3NsaWRlLWRlY2stZmxleCc6IGNlbnRlcn1cIiA6c3R5bGU9XCJ7aGVpZ2h0OiBoZWlnaHQsIHdpZHRoOiB3aWR0aH1cIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInNsaWRlLWRlY2stY29udGVudFwiPlxuICAgICAgICAgICAgPGtlZXAtYWxpdmU+XG4gICAgICAgICAgICAgICAgPHRyYW5zaXRpb24gOm5hbWU9XCJgc2xpZGUtJHtkaXJlY3Rpb259YFwiIEBlbnRlcj1cIm9uU2xpZGVFbnRlclwiIEBsZWF2ZT1cIm9uU2xpZGVMZWF2ZVwiPlxuICAgICAgICAgICAgICAgICAgICA8c2xpZGUgOnZub2RlPVwiY29tcG9uZW50XCIvPlxuICAgICAgICAgICAgICAgIDwvdHJhbnNpdGlvbj5cbiAgICAgICAgICAgIDwva2VlcC1hbGl2ZT5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxzbG90IG5hbWU9XCJjb250cm9sc1wiPlxuICAgICAgICAgICAgPHNsaWRlLWRlY2stY29udHJvbHMgdi1pZj1cImNvbnRyb2xzXCIgOnNsaWRlcz1cInNsaWRlc1wiIDphY3RpdmU9XCJjdXJyZW50U2xpZGVcIiBAY2xpY2s9XCJvbkNsaWNrQ29udHJvbFwiIC8+XG4gICAgICAgIDwvc2xvdD5cbiAgICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgeyBtYXAgfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IHsgZmlyc3QgfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IHsgZmlsdGVyIH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCB7IGV4dGVuZCB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgeyBmaW5kSW5kZXggfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IHsgaXNGdW5jdGlvbiB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgdW5pdCBmcm9tICcuLi8uLi9IZWxwZXJzL1VuaXQnO1xuaW1wb3J0IHRyYW5zaXRpb24gZnJvbSAnLi4vLi4vSGVscGVycy9UcmFuc2l0aW9uJztcbmltcG9ydCBTbGlkZSBmcm9tICcuL1NsaWRlJztcbmltcG9ydCBTbGlkZURlY2tDb250cm9scyBmcm9tICcuL1NsaWRlRGVja0NvbnRyb2xzJztcblxuY29uc3QgUkVTSVpFX01PREVTID0ge1xuICAgIGF1dG8oZWwpIHtcbiAgICAgICAgaWYoZWwuY2xpZW50SGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IGVsLnN0eWxlLmhlaWdodCA9IHVuaXQoZWwuY2xpZW50SGVpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGVsLmNsaWVudFdpZHRoKSB7XG4gICAgICAgICAgICB0aGlzLndpZHRoID0gZWwuc3R5bGUud2lkdGggPSB1bml0KGVsLmNsaWVudFdpZHRoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgaW5pdGlhbChlbCkge1xuICAgICAgICBpZighdGhpcy5oZWlnaHQgJiYgdGhpcy4kZWwuY2xpZW50SGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IHVuaXQodGhpcy4kZWwuY2xpZW50SGVpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsLnN0eWxlLmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuXG4gICAgICAgIGlmKCF0aGlzLndpZHRoICYmIHRoaXMuJGVsLmNsaWVudFdpZHRoKSB7XG4gICAgICAgICAgICB0aGlzLndpZHRoID0gdW5pdCh0aGlzLiRlbC5jbGllbnRXaWR0aCk7XG4gICAgICAgIH1cblxuICAgICAgICBlbC5zdHlsZS53aWR0aCA9IHRoaXMud2lkdGg7XG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgbmFtZTogJ3NsaWRlLWRlY2snLFxuXG4gICAgY29tcG9uZW50czoge1xuICAgICAgICBTbGlkZSxcbiAgICAgICAgU2xpZGVEZWNrQ29udHJvbHMsXG4gICAgfSxcblxuICAgIHByb3BzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzbGlkZSBrZXkgb3IgaW5kZXggdGhhdCBzaG91bGQgc2hvdy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGFjdGl2ZToge1xuICAgICAgICAgICAgdHlwZTogW1N0cmluZywgTnVtYmVyXSxcbiAgICAgICAgICAgIGRlZmF1bHQ6IDBcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRmxleCB0aGUgY29udGVudCB3aXRoaW4gdGhlIHBvcG92ZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIGZsZXg6IHtcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgICBkZWZhdWx0OiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3cgdGhlIHNsaWRlLWRlY2sgY29udHJvbHMgdG8gY2hhbmdlIHRoZSBzbGlkZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUgQm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgY29udHJvbHM6IEJvb2xlYW4sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtb2RlIGRldGVybWluZXMgaG93IHRoZSBwb3BvdmVyIGNvbnRlbnQgd2lsbCBmbGV4IGJhc2VkIG9uIHRoZVxuICAgICAgICAgKiB2YXJ5aW5nIGhlaWdodHMgb2YgdGhlIHNsaWRlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUgQm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgcmVzaXplTW9kZToge1xuICAgICAgICAgICAgdHlwZTogW0Z1bmN0aW9uLCBCb29sZWFuLCBTdHJpbmddLFxuICAgICAgICAgICAgZGVmYXVsdDogJ2F1dG8nLFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWydhdXRvJywgJ2luaXRpYWwnLCAnaW5oZXJpdCddLmluZGV4T2YodmFsdWUpICE9PSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgd2F0Y2g6IHtcblxuICAgICAgICBhY3RpdmUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTbGlkZSA9IHZhbHVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGN1cnJlbnRTbGlkZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uID0gdGhpcy5maW5kU2xpZGVJbmRleChvbGRWYWx1ZSkgPiB0aGlzLmZpbmRTbGlkZUluZGV4KHZhbHVlKSA/ICdiYWNrd2FyZCcgOiAnZm9yd2FyZCc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGVpZ2h0KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICAgICAgLy90aGlzLiRlbWl0KCdyZXNpemUnLCB0aGlzLCB2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBtZXRob2RzOiB7XG5cbiAgICAgICAgZmluZFNsaWRlQnlLZXkoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gZmlyc3QoZmlsdGVyKHRoaXMuc2xpZGVzLCAodm5vZGUsIGkpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdm5vZGUuZGF0YSA/IHZub2RlLmRhdGEua2V5ID09PSBrZXkgOiBpID09PSBrZXk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluZFNsaWRlQnlJbmRleChpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2xpZGVzW2luZGV4XSB8fCBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmRTbGlkZUluZGV4KGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGZpbmRJbmRleCh0aGlzLnNsaWRlcywgKHZub2RlLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZub2RlLmRhdGEgPyB2bm9kZS5kYXRhLmtleSA9PT0ga2V5IDogaSA9PT0ga2V5O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVzaXplKGVsKSB7XG4gICAgICAgICAgICBpZihpc0Z1bmN0aW9uKHRoaXMucmVzaXplTW9kZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2l6ZU1vZGUuY2FsbCh0aGlzLCBlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKGlzRnVuY3Rpb24oUkVTSVpFX01PREVTW3RoaXMucmVzaXplTW9kZV0pKSB7XG4gICAgICAgICAgICAgICAgUkVTSVpFX01PREVTW3RoaXMucmVzaXplTW9kZV0uY2FsbCh0aGlzLCBlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25DbGlja0NvbnRyb2woZXZlbnQsIHZub2RlKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTbGlkZSA9IHZub2RlLmRhdGEgPyB2bm9kZS5kYXRhLmtleSA6IHZub2RlLmtleTtcbiAgICAgICAgfSxcblxuICAgICAgICBvblNsaWRlRW50ZXIoZWwsIGRvbmUpIHtcbiAgICAgICAgICAgIHRoaXMucmVzaXplKGVsKTtcblxuICAgICAgICAgICAgdHJhbnNpdGlvbihlbCkudGhlbihkZWxheSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy4kbmV4dFRpY2soZG9uZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBvblNsaWRlTGVhdmUoZWwsIGRvbmUpIHtcbiAgICAgICAgICAgIHRoaXMucmVzaXplKGVsKTtcblxuICAgICAgICAgICAgdHJhbnNpdGlvbihlbCkudGhlbihkZWxheSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy4kbmV4dFRpY2soZG9uZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGNvbXB1dGVkOiB7XG5cbiAgICAgICAgc2xpZGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIG1hcChmaWx0ZXIodGhpcy4kc2xvdHMuZGVmYXVsdCwgKHZub2RlLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhdm5vZGUudGFnO1xuICAgICAgICAgICAgfSksICh2bm9kZSwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmKCF2bm9kZS5rZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdm5vZGUuZGF0YSA9IGV4dGVuZCh2bm9kZS5kYXRhLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IHZub2RlLmtleSA9IGlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZub2RlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29tcG9uZW50KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluZFNsaWRlQnlLZXkodGhpcy5jdXJyZW50U2xpZGUpIHx8IHRoaXMuZmluZFNsaWRlQnlJbmRleCh0aGlzLmN1cnJlbnRTbGlkZSkgfHwgZmlyc3QodGhpcy5zbGlkZXMpO1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgbW91bnRlZCgpIHtcbiAgICAgICAgdGhpcy4kZWwucGFyZW50RWxlbWVudC5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgICAgICB0aGlzLnJlc2l6ZSh0aGlzLiRlbCk7XG4gICAgfSxcblxuICAgIHVwZGF0ZWQoKSB7XG4gICAgfSxcblxuICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBoZWlnaHQ6IG51bGwsXG4gICAgICAgICAgICB3aWR0aDogbnVsbCxcbiAgICAgICAgICAgIGN1cnJlbnRTbGlkZTogdGhpcy5hY3RpdmUsXG4gICAgICAgICAgICBkaXJlY3Rpb246ICdmb3J3YXJkJ1xuICAgICAgICB9XG4gICAgfVxuXG59O1xuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwic2Nzc1wiPlxuLnNsaWRlLWRlY2sge1xuICAgIGhlaWdodDogYXV0bztcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgdHJhbnNpdGlvbjogYWxsIC41cyBlYXNlO1xuXG4gICAgJi5zbGlkZS1kZWNrLWZsZXgge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcblxuICAgICAgICAuc2xpZGUtZGVjay1jb250ZW50IHtcbiAgICAgICAgICAgIGZsZXg6IDE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAuc2xpZGUtZGVjay1jb250ZW50IHtcbiAgICAgICAgb3ZlcmZsb3cteTogYXV0bztcbiAgICB9XG5cbiAgICAvKlxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAqL1xuXG4gICAgLnNsaWRlLWRlY2stY29udHJvbHMge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIGxlZnQ6IDUwJTtcbiAgICAgICAgYm90dG9tOiAxcmVtO1xuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwJSk7XG4gICAgfVxuXG4gICAgLnNsaWRlLWZvcndhcmQtZW50ZXItYWN0aXZlLFxuICAgIC5zbGlkZS1mb3J3YXJkLWxlYXZlLWFjdGl2ZSxcbiAgICAuc2xpZGUtYmFja3dhcmQtZW50ZXItYWN0aXZlLFxuICAgIC5zbGlkZS1iYWNrd2FyZC1sZWF2ZS1hY3RpdmUge1xuICAgICAgICBvcGFjaXR5OiAwO1xuICAgICAgICB0cmFuc2l0aW9uOiBhbGwgLjVzIGVhc2U7XG4gICAgfVxuXG4gICAgLnNsaWRlLWZvcndhcmQtZW50ZXItYWN0aXZlLFxuICAgIC5zbGlkZS1iYWNrd2FyZC1lbnRlci1hY3RpdmUge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogMDtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgfVxuXG4gICAgLnNsaWRlLWZvcndhcmQtZW50ZXItYWN0aXZlIHtcbiAgICAgICAgbGVmdDogMDtcbiAgICB9XG5cbiAgICAuc2xpZGUtYmFja3dhcmQtZW50ZXItYWN0aXZlIHtcbiAgICAgICAgcmlnaHQ6IDA7XG4gICAgfVxuXG4gICAgLnNsaWRlLWZvcndhcmQtZW50ZXItYWN0aXZlLFxuICAgIC5zbGlkZS1iYWNrd2FyZC1sZWF2ZS10byB7XG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgxMDAlKTtcbiAgICB9XG5cbiAgICAuc2xpZGUtZm9yd2FyZC1sZWF2ZS10byxcbiAgICAuc2xpZGUtYmFja3dhcmQtZW50ZXItYWN0aXZlIHtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC0xMDAlKTtcbiAgICB9XG5cbiAgICAuc2xpZGUtZm9yd2FyZC1lbnRlci10byxcbiAgICAuc2xpZGUtYmFja3dhcmQtZW50ZXItdG8ge1xuICAgICAgICBvcGFjaXR5OiAxO1xuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMCk7XG4gICAgfVxuXG5cblxuICAgIC8qXG4gICAgLnNsaWRlLWZhZGUtZm9yd2FyZC1sZWF2ZS1hY3RpdmUsXG4gICAgLnNsaWRlLWZhZGUtZm9yd2FyZC1sZWF2ZS10byB7XG4gICAgICAgIHotaW5kZXg6IDE7XG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtMTAwJSk7XG4gICAgfVxuXG4gICAgLnNsaWRlLWZhZGUtZm9yd2FyZC1lbnRlci1hY3RpdmUsXG4gICAgLnNsaWRlLWZhZGUtYmFja3dhcmQtZW50ZXItYWN0aXZlIHtcbiAgICAgICAgei1pbmRleDogMjtcbiAgICAgICAgdHJhbnNpdGlvbjogYWxsIDJzIGVhc2Utb3V0O1xuICAgIH1cbiAgICAuc2xpZGUtZmFkZS1mb3J3YXJkLWxlYXZlLWFjdGl2ZSxcbiAgICAuc2xpZGUtZmFkZS1iYWNrd2FyZC1sZWF2ZS1hY3RpdmUge1xuICAgICAgICB6LWluZGV4OiAxO1xuICAgICAgICB0cmFuc2l0aW9uOiBhbGwgMnMgY3ViaWMtYmV6aWVyKDEuMCwgMC41LCAwLjgsIDEuMCk7XG4gICAgfVxuXG4gICAgLnNsaWRlLWZhZGUtZm9yd2FyZC1lbnRlcixcbiAgICAuc2xpZGUtZmFkZS1mb3J3YXJkLWxlYXZlLXRvLFxuICAgIC5zbGlkZS1mYWRlLWJhY2t3YXJkLWVudGVyLFxuICAgIC5zbGlkZS1mYWRlLWJhY2t3YXJkLWxlYXZlLXRvIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlICFpbXBvcnRhbnQ7XG4gICAgICAgIHRvcDogMDtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIG9wYWNpdHk6IDA7XG4gICAgfVxuXG4gICAgLnNsaWRlLWZhZGUtZm9yd2FyZC1lbnRlcixcbiAgICAuc2xpZGUtZmFkZS1mb3J3YXJkLWxlYXZlLXRvIHtcbiAgICAgICAgcmlnaHQ6IDA7XG4gICAgfVxuXG4gICAgLnNsaWRlLWZhZGUtZm9yd2FyZC1lbnRlcixcbiAgICAuc2xpZGUtZmFkZS1mb3J3YXJkLWxlYXZlLXRvIHtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDEwMCUpO1xuICAgIH1cblxuICAgIC5zbGlkZS1mYWRlLWJhY2t3YXJkLWVudGVyLFxuICAgIC5zbGlkZS1mYWRlLWJhY2t3YXJkLWxlYXZlLXRvIHtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDEwMCUpO1xuICAgIH1cbiAgICAqL1xufVxuPC9zdHlsZT5cbiIsImltcG9ydCBTbGlkZSBmcm9tICcuL1NsaWRlJztcbmltcG9ydCBTbGlkZURlY2sgZnJvbSAnLi9TbGlkZURlY2snO1xuaW1wb3J0IFZ1ZUluc3RhbGxlciBmcm9tICcuLi8uLi9IZWxwZXJzL1Z1ZUluc3RhbGxlci9WdWVJbnN0YWxsZXInO1xuXG5jb25zdCBwbHVnaW4gPSBWdWVJbnN0YWxsZXIudXNlKHtcblxuICAgIGluc3RhbGwoVnVlLCBvcHRpb25zKSB7XG4gICAgICAgIFZ1ZUluc3RhbGxlci5jb21wb25lbnRzKHtcbiAgICAgICAgICAgIFNsaWRlLFxuICAgICAgICAgICAgU2xpZGVEZWNrXG4gICAgICAgIH0pO1xuICAgIH1cblxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IFNsaWRlRGVjaztcbiIsImltcG9ydCB7IGVhY2ggfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IHsgaXNBcnJheSB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgeyBpc09iamVjdCB9IGZyb20gJ2xvZGFzaC1lcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRyYW5zZm9ybWVyIHtcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgdGhlIHRyYW5zZm9ybWVyIGluc3RhbmNlIHVzaW5nIGFuIEhUVFAgcmVzcG9uc2Ugb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGEgb2JqZWN0XG4gICAgICogQHJldHVybiB2b2lkXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocmVzcG9uc2UpIHtcbiAgICAgICAgaWYoIWlzT2JqZWN0KHRoaXMuJG9yaWdpbmFsUmVzcG9uc2UgPSByZXNwb25zZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHRyYW5zZm9ybWVyIG11c3QgYmUgaW5zdGFudGlhdGVkIHdpdGggYSByZXNwb25zZSBvYmplY3QuJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmKCFpc0FycmF5KHRoaXMuJHJlcXVpcmVkID0gdGhpcy5yZXF1aXJlZCgpKSB8fCAhdGhpcy4kcmVxdWlyZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgdHJhbnNmb3JtZXIgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSByZXF1aXJlZCBwcm9wZXJ0eS4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuJHRyYW5zZm9ybWVkUmVzcG9uc2UgPSB0aGlzLnRyYW5zZm9ybShyZXNwb25zZSk7XG4gICAgICAgIHRoaXMudmFsaWRhdGUoKTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBtZXRob2QgdG8gb3ZlcnJpZGUgdG8gcGVyZm9ybSBsb2dpYyB0byBmaW5pc2hlZCBpbml0aWFsaXppbmcuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgKi9cbiAgICBpbml0aWFsaXplKCkge1xuICAgICAgICAvL1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlZmluZSBhbiBhcnJheSBvZiByZXF1aXJlZCBwcm9wZXJ0aWVzIHdpdGggYXQgbGVhc3Qgb25lIHZhbHVlLlxuICAgICAqXG4gICAgICogQHJldHVybiB2b2lkXG4gICAgICovXG4gICAgcmVxdWlyZWQoKSB7XG4gICAgICAgIC8vXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJhbmZvcm0gdGhlIHJlc3BvbnNlIG9iamVjdFxuICAgICAqXG4gICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAqL1xuICAgIHRyYW5zZm9ybShyZXNwb25zZSkge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB0cmFuZm9ybWVkIHJlc3BvbnNlXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICovXG4gICAgcmVzcG9uc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiR0cmFuc2Zvcm1lZFJlc3BvbnNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlIHRoZSB0cmFuZm9ybWVkIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogQHJldHVybiB2b2lkXG4gICAgICovXG4gICAgdmFsaWRhdGUoKSB7XG4gICAgICAgIGlmKCFpc09iamVjdCh0aGlzLiR0cmFuc2Zvcm1lZFJlc3BvbnNlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgdHJhbnNmb3JtZWQgcmVzcG9uc2UgbXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBlYWNoKHRoaXMuJHJlcXVpcmVkLCBrZXkgPT4ge1xuICAgICAgICAgICAgaWYoIShrZXkgaW4gdGhpcy4kdHJhbnNmb3JtZWRSZXNwb25zZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHtrZXl9XCIgaXMgYSByZXF1aXJlZCBwcm9wZXJ0eSBhbmQgZG9lcyBub3QgZXhpc3QgaW4gdGhlIHRyYW5mb3JtZWQgcmVzcG9uc2UuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxufVxuIiwiaW1wb3J0IHsgaXNBcnJheSB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgVHJhbnNmb3JtZXIgZnJvbSAnLi4vVHJhbnNmb3JtZXInO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUYWJsZVZpZXdUcmFuc2Zvcm1lciBleHRlbmRzIFRyYW5zZm9ybWVyIHtcblxuICAgIHJlcXVpcmVkKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgLy8gVGhlIGVuZCBvZiB0aGUgY291bnQgb2YgdGhlIHBhZ2luYXRlZCBsaXN0LlxuICAgICAgICAgICAgJ3RvJyxcblxuICAgICAgICAgICAgLy8gVGhlIHN0YXJ0IG9mIHRoZSBjb3VudCBvZiB0aGUgcGFnaW5hdGVkIGxpc3QuXG4gICAgICAgICAgICAnZnJvbScsXG5cbiAgICAgICAgICAgIC8vIFRoZSB0b3RhbCBudW1iZXIgb2YgaXRlbXMgKG5vdCBqdXN0IGluY2x1ZGVkIGluIHRoZSBwYWdpbmF0aW9uKVxuICAgICAgICAgICAgJ3RvdGFsJyxcblxuICAgICAgICAgICAgLy8gVGhlIG51bWJlciBvZiBpdGVtcyBwZXIgcGFnZVxuICAgICAgICAgICAgJ3Blcl9wYWdlJyxcblxuICAgICAgICAgICAgLy8gVGhlIGxhc3QgcGFnZSBudW1iZXIgKG9yIHRvdGFsIHBhZ2VzKVxuICAgICAgICAgICAgJ2xhc3RfcGFnZScsXG5cbiAgICAgICAgICAgIC8vIFRoZSBjdXJyZW50IHBhZ2UgbnVtYmVyXG4gICAgICAgICAgICAnY3VycmVudF9wYWdlJyxcblxuICAgICAgICAgICAgLy8gVGhlIGFjdHVhbCByZXNwb25zZSBkYXRhIHRvIGFwcGVhciBpbiB0aGUgdGFibGVcbiAgICAgICAgICAgICdkYXRhJ1xuICAgICAgICBdO1xuICAgIH1cblxuICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiR0cmFuc2Zvcm1lZFJlc3BvbnNlLmRhdGE7XG4gICAgfVxuXG4gICAgaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgaWYoIWlzQXJyYXkodGhpcy5kYXRhKCkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBkYXRhIHByb3BlcnR5IG11c3QgYmUgYW4gYXJyYXkuJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbn1cbiIsIjx0ZW1wbGF0ZT5cblxuICAgIDxkaXYgY2xhc3M9XCJ0YWJsZS12aWV3XCI+XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cImQtZmxleCBqdXN0aWZ5LWNvbnRlbnQtYmV0d2VlbiBhbGlnbi1pdGVtcy1jZW50ZXJcIj5cbiAgICAgICAgICAgIDxzbG90IG5hbWU9XCJoZWFkZXJcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidGFibGUtdmlldy1oZWFkZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgPHNsb3QgbmFtZT1cImhlYWRpbmdcIj48aDMgdi1pZj1cImhlYWRpbmdcIiB2LWh0bWw9XCJoZWFkaW5nXCI+PC9oMz48L3Nsb3Q+XG4gICAgICAgICAgICAgICAgICAgIDxzbG90IG5hbWU9XCJkZXNjcmlwdGlvblwiPjxwIHYtaWY9XCJkZXNjcmlwdGlvblwiIHYtaHRtbD1cImRlc2NyaXB0aW9uXCI+PC9wPjwvc2xvdD5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvc2xvdD5cblxuICAgICAgICAgICAgPHNsb3QgbmFtZT1cImJ1dHRvbnNcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IHYtaWY9XCJidXR0b25zLmxlbmd0aFwiIGNsYXNzPVwiYnV0dG9ucy13cmFwcGVyIG15LTNcIj5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4+XG4gICAgICAgICAgICAgICAgXHRcdDxhIHYtZm9yPVwiKGJ1dHRvbiwga2V5KSBpbiBidXR0b25zXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6aHJlZj1cImJ1dHRvbi5ocmVmIHx8ICcjJ1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOmNsYXNzPVwiYnV0dG9uLmNsYXNzTmFtZSB8fCAnYnRuIGJ0bi1wcmltYXJ5J1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQGNsaWNrPVwicHJveHkoYnV0dG9uLm9uQ2xpY2ssICRldmVudClcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aSB2LWlmPVwiYnV0dG9uLmljb25cIiA6Y2xhc3M9XCJidXR0b24uaWNvblwiPjwvaT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiB2LWh0bWw9XCJidXR0b24ubGFiZWxcIj48L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2E+XG4gICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvc2xvdD5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPHRhYmxlIGNsYXNzPVwidGFibGVcIiA6Y2xhc3M9XCJ7J3RhYmxlLWhvdmVyJzogaG92ZXIgJiYgIWxvYWRpbmcgJiYgZGF0YS5sZW5ndGh9XCI+XG5cbiAgICAgICAgICAgIDxzbG90IG5hbWU9XCJ0aGVhZFwiPlxuICAgICAgICAgICAgXHQ8dGhlYWQ+XG4gICAgICAgICAgICBcdFx0PHRyPlxuICAgICAgICAgICAgXHRcdFx0PHRoIHNjb3BlPVwiY29sXCIgOndpZHRoPVwiY29sdW1uLndpZHRoXCIgdi1mb3I9XCJjb2x1bW4gaW4gdGFibGVDb2x1bW5zXCI+XG4gICAgICAgICAgICBcdFx0XHQgICAgPGRpdiB2LWlmPVwiY29sdW1uLmlkXCI+XG4gICAgICAgICAgICBcdFx0XHRcdFx0PGEgaHJlZj1cIiNcIiBjbGFzcz1cInNvcnRcIiA6ZGF0YS1pZD1cImNvbHVtbi5pZFwiIEBjbGljay5wcmV2ZW50PVwib3JkZXJCeShjb2x1bW4uaWQpXCIgdi1odG1sPVwiY29sdW1uLm5hbWUgfHwgY29sdW1uLmlkXCI+PC9hPlxuICAgICAgICAgICAgXHRcdFx0XHRcdDxpIHYtaWY9XCJyZXF1ZXN0LnBhcmFtcy5vcmRlciA9PT0gY29sdW1uLmlkICYmIHJlcXVlc3QucGFyYW1zLnNvcnQgPT09ICdhc2MnXCIgY2xhc3M9XCJzb3J0LWljb24gZmEgZmEtc29ydC1hc2NcIj48L2k+XG4gICAgICAgICAgICBcdFx0XHRcdFx0PGkgdi1pZj1cInJlcXVlc3QucGFyYW1zLm9yZGVyID09PSBjb2x1bW4uaWQgJiYgcmVxdWVzdC5wYXJhbXMuc29ydCA9PT0gJ2Rlc2MnXCIgY2xhc3M9XCJzb3J0LWljb24gZmEgZmEtc29ydC1kZXNjXCI+PC9pPlxuICAgICAgICAgICAgXHRcdFx0XHQ8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IHYtZWxzZSB2LWh0bWw9XCJjb2x1bW4ubmFtZVwiPjwvZGl2PlxuICAgICAgICAgICAgXHRcdFx0PC90aD5cbiAgICAgICAgICAgIFx0XHQ8L3RyPlxuICAgICAgICAgICAgXHQ8L3RoZWFkPlxuICAgICAgICAgICAgPC9zbG90PlxuXG4gICAgICAgICAgICA8c2xvdCBuYW1lPVwidGJvZHlcIj5cbiAgICAgICAgICAgICAgICA8dGJvZHk+XG4gICAgICAgICAgICAgICAgICAgIDx0ciB2LWlmPVwibG9hZGluZ1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHRkIDpjb2xzcGFuPVwidGFibGVDb2x1bW5zLmxlbmd0aFwiIGNsYXNzPVwicG9zaXRpb24tcmVsYXRpdmVcIiA6c3R5bGU9XCJ7J2hlaWdodCc6IGhlaWdodChtaW5IZWlnaHQpfVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhY3Rpdml0eS1pbmRpY2F0b3IgOmNlbnRlcj1cInRydWVcIj48L2FjdGl2aXR5LWluZGljYXRvcj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICAgICAgICAgIDwvdHI+XG5cbiAgICAgICAgICAgICAgICAgICAgPHRyIHYtZWxzZS1pZj1cIiFkYXRhLmxlbmd0aFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHRkIDpjb2xzcGFuPVwidGFibGVDb2x1bW5zLmxlbmd0aFwiIGNsYXNzPVwicG9zaXRpb24tcmVsYXRpdmVcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YWxlcnQgdmFyaWFudD1cIndhcm5pbmdcIiBjbGFzcz1cIm15LTNcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XCJmYSBmYS13YXJuaW5nXCIvPiBUaGVyZSBhcmUgbm8gcmVzdWx0cyBmb3VuZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2FsZXJ0PlxuICAgICAgICAgICAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgICAgICAgICAgPC90cj5cblxuICAgICAgICAgICAgICAgICAgICA8c2xvdCB2LWVsc2UgOmRhdGE9XCJkYXRhXCIgOmNvbHVtbnM9XCJ0YWJsZUNvbHVtbnNcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx0ciB2LWZvcj1cIihyb3csIGkpIGluIGRhdGFcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgdi1mb3I9XCJjb2x1bW4gaW4gdGFibGVDb2x1bW5zXCIgdi1odG1sPVwicm93W2NvbHVtbi5pZF0gfHwgcm93W2NvbHVtbi5uYW1lXVwiPjwvdGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxuICAgICAgICAgICAgICAgICAgICA8L3Nsb3Q+XG4gICAgICAgICAgICAgICAgPC90Ym9keT5cbiAgICAgICAgICAgIDwvc2xvdD5cblxuICAgICAgICAgICAgPHNsb3QgbmFtZT1cInRmb290XCI+XG4gICAgICAgICAgICBcdDx0Zm9vdD5cbiAgICAgICAgICAgIFx0XHQ8dGQgOmNvbHNwYW49XCJ0YWJsZUNvbHVtbnMubGVuZ3RoXCIgY2xhc3M9XCJ0YWJsZS12aWV3LWZvb3RlclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHNsb3QgbmFtZT1cInBhZ2luYXRpb25cIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cGFnaW5hdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2LWlmPVwicGFnaW5hdGUgJiYgcmVzcG9uc2VcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGlnbj1cImNlbnRlclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDpwYWdlPVwicmVzcG9uc2UuY3VycmVudF9wYWdlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOnRvdGFsLXBhZ2VzPVwicmVzcG9uc2UubGFzdF9wYWdlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOm9uLXBhZ2luYXRlPVwib25QYWdpbmF0ZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvc2xvdD5cbiAgICAgICAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgIFx0PC90Zm9vdD5cbiAgICAgICAgICAgIDwvc2xvdD5cblxuICAgICAgICA8L3RhYmxlPlxuXG4gICAgPC9kaXY+XG5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgeyBrZXlzIH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCB7IGVhY2ggfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IHsgZXh0ZW5kIH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCB7IGlzT2JqZWN0IH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCBQYWdpbmF0aW9uIGZyb20gJy4uL1BhZ2luYXRpb24nO1xuaW1wb3J0IEFjdGl2aXR5SW5kaWNhdG9yIGZyb20gJy4uL0FjdGl2aXR5SW5kaWNhdG9yJztcbmltcG9ydCB1bml0IGZyb20gJy4uLy4uL0hlbHBlcnMvVW5pdCc7XG5pbXBvcnQgUHJveHkgZnJvbSAnLi4vLi4vTWl4aW5zL1Byb3h5JztcbmltcG9ydCBSZXF1ZXN0IGZyb20gJy4uLy4uL0h0dHAvUmVxdWVzdCc7XG5pbXBvcnQgVGFibGVWaWV3VHJhbnNmb3JtZXIgZnJvbSAnLi4vLi4vSHR0cC9UYWJsZVZpZXdUcmFuc2Zvcm1lci9UYWJsZVZpZXdUcmFuc2Zvcm1lcic7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBuYW1lOiAndGFibGUtdmlldycsXG5cbiAgICBtaXhpbnM6IFtQcm94eV0sXG5cbiAgICBjb21wb25lbnRzOiB7XG4gICAgICAgIFBhZ2luYXRpb24sXG4gICAgICAgIEFjdGl2aXR5SW5kaWNhdG9yXG4gICAgfSxcblxuICAgIHByb3BzOiB7XG4gICAgICAgIC8vIChzdHJpbmcpIEEgcmVsYXRpdmUgb3IgYWJzb2x1dGUgZW5kcG9pbnQgVVJMIHVzZWQgdG8gZmV0Y2ggZGF0YVxuICAgICAgICB1cmw6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gKGludGVnZXIpIFRoZSBzdGFydGluZyBwYWdlIG9mIHRoZSB0YWJsZVxuICAgICAgICBwYWdlOiB7XG4gICAgICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgICAgICBkZWZhdWx0OiAxXG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gKGludGVnZXIpIFRoZSB0b3RhbCBudW1iZXIgb2YgcmVzdWx0cyBwZXIgcGFnZVxuICAgICAgICBsaW1pdDoge1xuICAgICAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICAgICAgZGVmYXVsdDogMjBcbiAgICAgICAgfSxcblxuICAgICAgICAvLyAoc3RyaW5nKSBUaGUgY29sdW1uIHVzZWQgdG8gb3JkZXIgdGhlIGRhdGFcbiAgICAgICAgb3JkZXI6IFN0cmluZyxcblxuICAgICAgICAvLyAoc3RyaW5nKSBUaGUgc29ydCBkaXJlY3Rpb24gKGFzY3xkZXNjKVxuICAgICAgICBzb3J0OiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICB2YWxpZGF0ZTogKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsnYXNjJywgJ2Rlc2MnXS5pbmRleE9mKHZhbHVlKSAhPT0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gKGludGVnZXIpIFRoZSBtaW5pbXVtIGhlaWdodCBvZiB0aGUgcm93IHdoZW4gbG9hZGluZyBkYXRhXG4gICAgICAgIG1pbkhlaWdodDoge1xuICAgICAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICAgICAgZGVmYXVsdDogNDAwXG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gKGFycmF5KSBBbiBhcnJheSBvZiBidXR0b24gb2JqZWN0c1xuICAgICAgICAvLyBbe2hyZWY6ICd0ZXN0LTEyMycsIGxhYmVsOiAnVGVzdCAxMjMnfV1cbiAgICAgICAgYnV0dG9uczoge1xuICAgICAgICAgICAgdHlwZTogQXJyYXksXG4gICAgICAgICAgICBkZWZhdWx0OiAoKSA9PiB7IHJldHVybiBbXTsgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIChhcnJheSkgQW4gYXJyYXkgb2YgdGFibGUgY29sdW1uXG4gICAgICAgIC8vIFt7aWQ6ICdkYXRhYmFzZV9pZCcsIG5hbWU6ICdEYXRhYmFzZSBpZCcsIHdpZHRoOiAnMjAlJ31dXG4gICAgICAgIGNvbHVtbnM6IHtcbiAgICAgICAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgICAgICAgZGVmYXVsdDogKCkgPT4geyByZXR1cm4gW107IH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyAoc3RyaW5nKSBUaGUgdGFibGUgaGVhZGluZ1xuICAgICAgICBoZWFkaW5nOiBTdHJpbmcsXG5cbiAgICAgICAgLy8gKHN0cmluZykgQWRkIHRhYmxlLWhvdmVyIHRvIHRoZSB0YWJsZSBlbGVtZW50XG4gICAgICAgIGhvdmVyOiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIChzdHJpbmcpIFRoZSB0YWJsZSBkZXNjcmlwdGlvblxuICAgICAgICBkZXNjcmlwdGlvbjogU3RyaW5nLFxuXG4gICAgICAgIC8vIChib29sKSBTaG91bGQgc2hvdyB0aGUgcGFnaW5hdGlvbiBmb3IgdGhpcyB0YWJsZVxuICAgICAgICBwYWdpbmF0ZToge1xuICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICAvLyAob2JqZWN0KSBUaGUgSFRUUCByZXNwb25zZSB0cmFuc2Zvcm1lciBpbnN0YW5jZVxuICAgICAgICB0cmFuc2Zvcm1lcjoge1xuICAgICAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICAgICAgdmFsaWRhdGU6ICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFRhYmxlVmlld1RyYW5zZm9ybWVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIHRhYmxlQ29sdW1ucygpIHtcbiAgICAgICAgICAgIGxldCBjb2x1bW5zID0gdGhpcy5jb2x1bW5zO1xuXG4gICAgICAgICAgICBpZighY29sdW1ucyB8fCAhY29sdW1ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb2x1bW5zID0ga2V5cyh0aGlzLmRhdGFbMF0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY29sdW1ucy5tYXAoY29sdW1uID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNPYmplY3QoY29sdW1uKSA/IGNvbHVtbiA6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogY29sdW1uXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1ldGhvZHM6IHtcblxuICAgICAgICBvcmRlckJ5KG9yZGVyKSB7XG4gICAgICAgICAgICBjb25zdCBkZWZhdWx0U29ydCA9ICdkZXNjJztcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRTb3J0ID0gdGhpcy5nZXRSZXF1ZXN0UGFyYW0oJ3NvcnQnKTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRPcmRlciA9IHRoaXMuZ2V0UmVxdWVzdFBhcmFtKCdvcmRlcicpO1xuXG4gICAgICAgICAgICB0aGlzLmFkZFJlcXVlc3RQYXJhbSgnb3JkZXInLCBvcmRlcik7XG4gICAgICAgICAgICB0aGlzLmFkZFJlcXVlc3RQYXJhbSgnc29ydCcsXG4gICAgICAgICAgICAgICAgY3VycmVudE9yZGVyICE9PSBvcmRlciB8fCAhY3VycmVudFNvcnQgPyBkZWZhdWx0U29ydCA6IChcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFNvcnQgPT09IGRlZmF1bHRTb3J0ID8gJ2FzYycgOiBudWxsXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgdGhpcy5mZXRjaCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdC5oZWFkZXJzW2tleV0gfHwgdmFsdWVcbiAgICAgICAgfSxcblxuICAgICAgICBhZGRSZXF1ZXN0SGVhZGVyKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmKCF0aGlzLnJlcXVlc3QuaGVhZGVycykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdC5oZWFkZXJzID0ge307XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucmVxdWVzdC5oZWFkZXJzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRSZXF1ZXN0UGFyYW0oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdC5wYXJhbXNba2V5XSB8fCB2YWx1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIGFkZFJlcXVlc3RQYXJhbShrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICBpZighdGhpcy5yZXF1ZXN0LnBhcmFtcykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdC5wYXJhbXMgPSB7fTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0LnBhcmFtc1trZXldID0gdmFsdWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmV0Y2goKSB7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFJlcXVlc3QodGhpcy51cmwsIHRoaXMucmVxdWVzdCk7XG5cbiAgICAgICAgICAgIHRoaXMubG9hZGluZyA9IHRydWU7XG5cbiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0LmdldCgpLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybWVyID0gdGhpcy50cmFuc2Zvcm1lciB8fCBuZXcgVGFibGVWaWV3VHJhbnNmb3JtZXIocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzcG9uc2UgPSB0cmFuc2Zvcm1lci5yZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YSA9IHRyYW5zZm9ybWVyLmRhdGEoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH0sIGVycm9ycyA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBoZWlnaHQobWluKSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50cyA9IFtcbiAgICAgICAgICAgICAgICAvLyB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yKCd0aGVhZCcpLFxuICAgICAgICAgICAgICAgIHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3IoJ3Rib2R5JylcbiAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgIGxldCBoZWlnaHQgPSAwO1xuXG4gICAgICAgICAgICBlYWNoKGVsZW1lbnRzLCBlbCA9PiB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ICs9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gdW5pdChNYXRoLm1heChtaW4sIGhlaWdodCkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uUGFnaW5hdGUocGFnZSwgZXZlbnQpIHtcbiAgICAgICAgICAgIGlmKCF0aGlzLnJlcXVlc3QucGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0LnBhcmFtcyA9IHt9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnJlcXVlc3QucGFyYW1zLnBhZ2UgPSBwYWdlO1xuICAgICAgICAgICAgdGhpcy5mZXRjaCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAvLyAoYXJyYXkpIFRoZSBkYXRhc2V0IGZvciB0aGUgdGFibGVcbiAgICAgICAgICAgIGRhdGE6IHRoaXMuJGF0dHJzLmRhdGEgfHwgW10sXG5cbiAgICAgICAgICAgIC8vIChib29sKSBJcyB0aGUgdGFibGUgY3VycmVudGx5IGxvYWRpbmcgZGF0YVxuICAgICAgICAgICAgbG9hZGluZzogZmFsc2UsXG5cbiAgICAgICAgICAgIC8vIChudWxsfG9iamVjdCkgVGhlIHJlc3BvbnNlIG9iamVjdFxuICAgICAgICAgICAgcmVzcG9uc2U6IG51bGwsXG5cbiAgICAgICAgICAgIC8vIChvYmplY3QpIFRoZSBIVFRQIHJlcXVlc3Qgb2JqZWN0XG4gICAgICAgICAgICByZXF1ZXN0OiBleHRlbmQoe1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgICAgICBwYWdlOiB0aGlzLnBhZ2UsXG4gICAgICAgICAgICAgICAgICAgIGxpbWl0OiB0aGlzLmxpbWl0LFxuICAgICAgICAgICAgICAgICAgICBvcmRlcjogdGhpcy5vcmRlcixcbiAgICAgICAgICAgICAgICAgICAgc29ydDogdGhpcy5zb3J0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcy4kYXR0cnMucmVxdWVzdClcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgbW91bnRlZCgpIHtcbiAgICAgICAgdGhpcy5mZXRjaCgpO1xuICAgIH0sXG5cbiAgICAvKlxuICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiBleHRlbmQoe1xuICAgICAgICAgICAgYnV0dG9uczogW10sXG5cbiAgICAgICAgICAgIGNvbHVtbnM6IFtdLFxuXG4gICAgICAgICAgICBoZWFkZXI6IGZhbHNlLFxuXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogZmFsc2UsXG5cbiAgICAgICAgICAgIC8vIChib29sKSBTaG91bGQgc2hvdyB0aGUgcGFnaW5hdGlvbiBmb3IgdGhpcyB0YWJsZVxuICAgICAgICAgICAgcGFnaW5hdGU6IHRydWUsXG5cbiAgICAgICAgICAgIC8vIChib29sKSBJcyB0aGUgdGFibGUgY3VycmVudGx5IGxvYWRpbmcgZGF0YVxuICAgICAgICAgICAgbG9hZGluZzogZmFsc2UsXG5cbiAgICAgICAgICAgIC8vIChvYmplY3QpIEFuIG9iamVjdCB3aXRoIGtleS92YWx1ZSBwYWlycyBmb3IgY29tcG9uZW50cyB1c2VkIGluIHRoZSB0ZW1wbGF0ZVxuICAgICAgICAgICAgY29tcG9uZW50czoge1xuICAgICAgICAgICAgICAgIC8vIChzdHJpbmcpIFRoZSBuYW1lIG9mIHRoZSBjb21wb25lbnQgdXNlZCBmb3IgdGhlIHRhYmxlIGhlYWRlclxuICAgICAgICAgICAgICAgIGhlYWRlcjogJ3RhYmxlLXZpZXctaGVhZGVyJyxcblxuICAgICAgICAgICAgICAgIC8vIChzdHJpbmcpIFRoZSBuYW1lIG9mIHRoZSBjb21wb25lbnQgdXNlZCBmb3IgdGhlIHRhYmxlIHJvd1xuICAgICAgICAgICAgICAgIHJvdzogJ3RhYmxlLXZpZXctcm93JyxcblxuICAgICAgICAgICAgICAgIC8vIChzdHJpbmcpIFRoZSBuYW1lIG9mIHRoZSBjb21wb25lbnQgdXNlZCBmb3IgdGhlIHRhYmxlIHJvd1xuICAgICAgICAgICAgICAgIGZvb3RlcjogJ3RhYmxlLXZpZXctZm9vdGVyJ1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gKGludCkgVGhlIHN0YXJ0aW5nIHBhZ2VcbiAgICAgICAgICAgIC8vIHBhZ2U6IDEsXG5cbiAgICAgICAgICAgIC8vIChzdHJpbmcpIFRoZSBvcmRlciBvZiB0aGUgZGF0ZSBiZWluZyByZXR1cm5lZFxuICAgICAgICAgICAgLy8gb3JkZXI6IG51bGwsXG5cbiAgICAgICAgICAgIC8vIChzdHJpbmcpIEVpdGhlciBhc2Mgb3IgZGVzYyBzb3J0aW5nIG9yZGVyXG4gICAgICAgICAgICAvLyBzb3J0OiBudWxsLFxuXG4gICAgICAgICAgICAvLyAoaW50KSBUaGUgbnVtYmVycyBvZiByb3dzIHBlciBwYWdlXG4gICAgICAgICAgICAvLyBsaW1pdDogMjAsXG5cbiAgICAgICAgICAgIC8vIChib29sKSBGZXRjaCB0aGUgZGF0YSB3aGVuIHRhYmxlIGlzIHNob3duXG4gICAgICAgICAgICAvLyBmZXRjaE9uUmVuZGVyOiB0cnVlLFxuXG4gICAgICAgICAgICAvLyAoYXJyYXkpIEFuIGFycmF5IG9mIGhlYWRlcnMgYXBwZW5kZWQgdG8gdGhlIHJlcXVlc3RcbiAgICAgICAgICAgIC8vIHJlcXVlc3RIZWFkZXJzOiBbXSxcblxuICAgICAgICAgICAgLy8gKGFycmF5KSBUaGUgZGVmYXVsdCBvcHRpb25zIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIHF1ZXJ5IHN0cmluZ1xuICAgICAgICAgICAgLy8gZGVmYXVsdFJlcXVlc3REYXRhT3B0aW9uczogW1xuICAgICAgICAgICAgLy8gICAgJ3BhZ2UnLFxuICAgICAgICAgICAgLy8gICAgJ2xpbWl0JyxcbiAgICAgICAgICAgIC8vICAgICdvcmRlcicsXG4gICAgICAgICAgICAvLyAgICAnc29ydCdcbiAgICAgICAgICAgIC8vIF0sXG5cbiAgICAgICAgICAgIC8vIChvYmplY3QpIEFuIG9wdGlvbiB0byBwYXNzIGFuIG9iamVjdCB3aXRoIHJlcXVlc3QgZGF0YVxuICAgICAgICAgICAgLy8gcmVxdWVzdERhdGE6IHt9LFxuXG4gICAgICAgICAgICAvLyAoYXJyYXkpIEFkZGl0aW9uYWwgb3B0aW9ucyB1c2VkIHRvIGdlbmVyYXRlIHRoZSBxdWVyeSBzdHJpbmdcbiAgICAgICAgICAgIC8vIHJlcXVlc3REYXRhT3B0aW9uczogW10sXG5cbiAgICAgICAgICAgIC8vIChvYmplY3QpIFRoZSBib2R5IHZpZXcgb3B0aW9ucyBvYmplY3RcbiAgICAgICAgICAgIC8vIGJvZHlWaWV3T3B0aW9uczogZmFsc2UsXG5cbiAgICAgICAgICAgIC8vIChvYmplY3QpIFRoZSBwYWdpbmF0aW9uIHZpZXcgY2xhc3NcbiAgICAgICAgICAgIC8vIGZvb3RlclZpZXc6ICdwYWdpbmF0aW9uJyxcblxuICAgICAgICAgICAgLy8gKG9iamVjdCkgVGhlIHBhZ2luYXRpb24gdmlldyBvcHRpb25zIG9iamVjdFxuICAgICAgICAgICAgLy8gZm9vdGVyVmlld09wdGlvbnM6IGZhbHNlLFxuXG4gICAgICAgICAgICAvLyAoc3RyaW5nKSBUaGUgdGFibGUgZm9vdGVyIGNsYXNzIG5hbWVcbiAgICAgICAgICAgIC8vIGZvb3RlckNsYXNzTmFtZTogJ3RhYmxlLWhlYWRlcicsXG5cbiAgICAgICAgICAgIC8vIChzdHJpbmcpIFRoZSB0YWJsZSBoZWFkZXJcbiAgICAgICAgICAgIC8vIGhlYWRlcjogZmFsc2UsXG5cbiAgICAgICAgICAgIC8vIChzdHJpbmcpIFRoZSB0YWJsZSBoZWFkZXIgdGFnIG5hbWVcbiAgICAgICAgICAgIC8vIGhlYWRlclRhZ05hbWU6ICdoMycsXG5cbiAgICAgICAgICAgIC8vIChzdHJpbmcpIFRoZSB0YWJsZSBoZWFkZXIgY2xhc3MgbmFtZVxuICAgICAgICAgICAgLy8gaGVhZGVyQ2xhc3NOYW1lOiAndGFibGUtaGVhZGVyJyxcblxuICAgICAgICAgICAgLy8gKG9iamVjdCkgVGhlIGhlYWRlciB2aWV3IGNsYXNzXG4gICAgICAgICAgICAvLyBoZWFkZXJWaWV3OiBmYWxzZSxcblxuICAgICAgICAgICAgLy8gKG9iamVjdCkgVGhlIGhlYWRlciB2aWV3IG9wdGlvbnMgb2JqZWN0XG4gICAgICAgICAgICAvLyBoZWFkZXJWaWV3T3B0aW9uczogZmFsc2UsXG5cbiAgICAgICAgICAgIC8vIChzdHJpbmcpIFRoZSB0YWJsZSBkZXNjcmlwdGlvblxuICAgICAgICAgICAgLy8gZGVzY3JpcHRpb246IGZhbHNlLFxuXG4gICAgICAgICAgICAvLyAoc3RyaW5nKSBUaGUgdGFibGUgZGVzY3JpcHRpb24gdGFnXG4gICAgICAgICAgICAvLyBkZXNjcmlwdGlvblRhZzogJ3AnLFxuXG4gICAgICAgICAgICAvLyAoc3RyaW5nKSBUaGUgdGFibGUgZGVzY3JpcHRpb24gdGFnXG4gICAgICAgICAgICAvLyBkZXNjcmlwdGlvbkNsYXNzTmFtZTogJ2Rlc2NyaXB0aW9uIHJvdyBjb2wtc20tNicsXG5cbiAgICAgICAgICAgIC8vIChzdHJpbmcpIFRoZSB0YWJsZSBjbGFzcyBuYW1lXG4gICAgICAgICAgICAvLyB0YWJsZUNsYXNzTmFtZTogJ3RhYmxlJyxcblxuICAgICAgICAgICAgLy8gKHN0cmluZykgVGhlIGxvYWRpbmcgY2xhc3MgbmFtZVxuICAgICAgICAgICAgLy8gbG9hZGluZ0NsYXNzTmFtZTogJ2xvYWRpbmcnLFxuXG4gICAgICAgICAgICAvLyAoc3RyaW5nKSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgaW4gdGhlIG1vZGVsIHN0b3JpbmcgdGhlIGNvbHVtbnNcbiAgICAgICAgICAgIC8vIGNoaWxkVmlld0NvbHVtbnNQcm9wZXJ0eTogJ2NvbHVtbnMnLFxuXG4gICAgICAgICAgICAvLyAob2JqZWN0KSBUaGUgYWN0aXZpdHkgaW5kaWNhdG9yIG9wdGlvbnNcbiAgICAgICAgICAgIC8vIGluZGljYXRvck9wdGlvbnM6IHtcbiAgICAgICAgICAgIC8vICAgICBpbmRpY2F0b3I6ICdzbWFsbCdcbiAgICAgICAgICAgIC8vIH0sXG5cbiAgICAgICAgICAgIC8vIChzdHJpbmcpIFRoZSBtZXNzYWdlIHRvIGRpc3BsYXkgaWYgdGhlcmUgYXJlIG5vIHRhYmxlIHJvd3NcbiAgICAgICAgICAgIC8vIGVtcHR5TWVzc2FnZTogJ05vIHJvd3MgZm91bmQnLFxuXG4gICAgICAgICAgICAvLyAoc3RyaW5nKSBUaGUgbmFtZSBvZiB0aGUgY2xhc3MgYXBwZW5kZWQgdG8gdGhlIGJ1dHRvbnNcbiAgICAgICAgICAgIC8vIGJ1dHRvbkNsYXNzTmFtZTogJ2J0biBidG4tZGVmYXVsdCcsXG4gICAgICAgIH0sIHRoaXMuJGF0dHJzKTtcbiAgICB9LFxuICAgICovXG5cbiAgICBiZWZvcmVEZXN0cm95KCkge1xuICAgICAgICB0aGlzLiRvZmYoKTtcbiAgICB9XG59XG5cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IFRhYmxlVmlldyBmcm9tICcuL1RhYmxlVmlldyc7XG5pbXBvcnQgVnVlSW5zdGFsbGVyIGZyb20gJy4uLy4uL0hlbHBlcnMvVnVlSW5zdGFsbGVyL1Z1ZUluc3RhbGxlcic7XG5cbmNvbnN0IHBsdWdpbiA9IFZ1ZUluc3RhbGxlci51c2Uoe1xuXG4gICAgaW5zdGFsbChWdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgVnVlSW5zdGFsbGVyLmNvbXBvbmVudHMoe1xuICAgICAgICAgICAgVGFibGVWaWV3XG4gICAgICAgIH0pO1xuICAgIH1cblxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IFRhYmxlVmlldztcbiIsIjx0ZW1wbGF0ZT5cblxuICAgIDxmb3JtLWdyb3VwPlxuXG4gICAgICAgIDxzbG90IG5hbWU9XCJsYWJlbFwiPlxuICAgICAgICAgICAgPGZvcm0tbGFiZWwgdi1pZj1cImxhYmVsIHx8IGhhc0RlZmF1bHRTbG90XCIgOmZvcj1cImlkXCI+XG4gICAgICAgICAgICAgICAgPHNsb3Q+e3tsYWJlbH19PC9zbG90PlxuICAgICAgICAgICAgPC9mb3JtLWxhYmVsPlxuICAgICAgICA8L3Nsb3Q+XG5cbiAgICAgICAgPHNsb3QgbmFtZT1cImNvbnRyb2xcIj5cbiAgICAgICAgICAgIDx0ZXh0YXJlYVxuICAgICAgICAgICAgICAgIDppZD1cImlkXCJcbiAgICAgICAgICAgICAgICA6cm93cz1cInJvd3NcIlxuICAgICAgICAgICAgICAgIDp2YWx1ZT1cInZhbHVlXCJcbiAgICAgICAgICAgICAgICA6ZXJyb3JzPVwiZXJyb3JzXCJcbiAgICAgICAgICAgICAgICA6cGF0dGVybj1cInBhdHRlcm5cIlxuICAgICAgICAgICAgICAgIDpyZWFkb25seT1cInJlYWRvbmx5XCJcbiAgICAgICAgICAgICAgICA6cmVxdWlyZWQ9XCJyZXF1aXJlZFwiXG4gICAgICAgICAgICAgICAgOm1heGxlbmd0aD1cIm1heGxlbmd0aFwiXG4gICAgICAgICAgICAgICAgOnBsYWNlaG9sZGVyPVwicGxhY2Vob2xkZXJcIlxuICAgICAgICAgICAgICAgIDpkaXNhYmxlZD1cImRpc2FibGVkIHx8IHJlYWRvbmx5XCJcbiAgICAgICAgICAgICAgICA6Y2xhc3M9XCIkbWVyZ2VDbGFzc2VzKGNvbnRyb2xDbGFzc2VzLCBjb2xvcmFibGVDbGFzc2VzKVwiXG4gICAgICAgICAgICAgICAgdi1iaW5kLWV2ZW50cz1cImJpbmRFdmVudHNcIlxuICAgICAgICAgICAgICAgIHYtb246aW5wdXQ9XCJ1cGRhdGVkKCRldmVudC50YXJnZXQudmFsdWUpXCI+XG4gICAgICAgICAgICA8L3RleHRhcmVhPlxuICAgICAgICA8L3Nsb3Q+XG5cbiAgICAgICAgPHNsb3QgbmFtZT1cImhlbHBcIj5cbiAgICAgICAgICAgIDxoZWxwLXRleHQgdi1pZj1cImhlbHBUZXh0XCIgdi1odG1sPVwiaGVscFRleHRcIiAvPlxuICAgICAgICA8L3Nsb3Q+XG5cbiAgICAgICAgPHNsb3QgbmFtZT1cImZlZWRiYWNrXCI+XG4gICAgICAgICAgICA8Zm9ybS1mZWVkYmFjayB2LWlmPVwidmFsaWRGZWVkYmFja1wiIHYtaHRtbD1cInZhbGlkRmVlZGJhY2tcIiB2YWxpZCAvPlxuICAgICAgICAgICAgPGZvcm0tZmVlZGJhY2sgdi1pZj1cImludmFsaWRGZWVkYmFja1wiIHYtaHRtbD1cImludmFsaWRGZWVkYmFja1wiIGludmFsaWQgLz5cbiAgICAgICAgPC9zbG90PlxuXG4gICAgPC9mb3JtLWdyb3VwPlxuXG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IEhlbHBUZXh0IGZyb20gJy4uL0hlbHBUZXh0JztcbmltcG9ydCBGb3JtR3JvdXAgZnJvbSAnLi4vRm9ybUdyb3VwJztcbmltcG9ydCBGb3JtTGFiZWwgZnJvbSAnLi4vRm9ybUxhYmVsJztcbmltcG9ydCBGb3JtRmVlZGJhY2sgZnJvbSAnLi4vRm9ybUZlZWRiYWNrJztcbmltcG9ydCBDb2xvcmFibGUgZnJvbSAnLi4vLi4vTWl4aW5zL0NvbG9yYWJsZS9Db2xvcmFibGUnO1xuaW1wb3J0IEZvcm1Db250cm9sIGZyb20gJy4uLy4uL01peGlucy9Gb3JtQ29udHJvbC9Gb3JtQ29udHJvbCc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICd0ZXh0YXJlYS1maWVsZCcsXG5cbiAgICBjb21wb25lbnRzOiB7XG4gICAgICAgIEhlbHBUZXh0LFxuICAgICAgICBGb3JtR3JvdXAsXG4gICAgICAgIEZvcm1MYWJlbCxcbiAgICAgICAgRm9ybUZlZWRiYWNrXG4gICAgfSxcblxuICAgIG1peGluczogW1xuICAgICAgICBDb2xvcmFibGUsXG4gICAgICAgIEZvcm1Db250cm9sXG4gICAgXSxcblxuICAgIHByb3BzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdHlwZSBhdHRyaWJ1dGVcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJ3RleHQnXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSByb3dzIGF0dHJpYnV0ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICByb3dzOiBbTnVtYmVyLCBTdHJpbmddXG4gICAgfVxuXG59XG5cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IFRleHRhcmVhRmllbGQgZnJvbSAnLi9UZXh0YXJlYUZpZWxkJztcbmltcG9ydCBWdWVJbnN0YWxsZXIgZnJvbSAnLi4vLi4vSGVscGVycy9WdWVJbnN0YWxsZXIvVnVlSW5zdGFsbGVyJztcblxuY29uc3QgcGx1Z2luID0gVnVlSW5zdGFsbGVyLnVzZSh7XG5cbiAgICBpbnN0YWxsKFZ1ZSwgb3B0aW9ucykge1xuICAgICAgICBWdWVJbnN0YWxsZXIuY29tcG9uZW50cyh7XG4gICAgICAgICAgICBUZXh0YXJlYUZpZWxkXG4gICAgICAgIH0pO1xuICAgIH1cblxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IFRleHRhcmVhRmllbGQ7XG4iLCI8dGVtcGxhdGU+XG4gICAgPGRpdiBjbGFzcz1cInRodW1ibmFpbC1saXN0LWl0ZW1cIiA6c3R5bGU9XCJ7aGVpZ2h0OiB1bml0KGhlaWdodCksIHdpZHRoOiB1bml0KHdpZHRoKSwgbWluSGVpZ2h0OiB1bml0KG1pbkhlaWdodCksIG1heEhlaWdodDogdW5pdChtYXhIZWlnaHQpLCBtaW5XaWR0aDogdW5pdChtaW5XaWR0aCksIG1heFdpZHRoOiB1bml0KG1heFdpZHRoKX1cIj5cbiAgICAgICAgPGltZyB2LWlmPVwic3JjXCIgOnNyYz1cInNyY1wiIDphbHQ9XCJhbHRcIiA6Y2xhc3M9XCJ7J2ltZy1mbHVpZCc6IGZsdWlkfVwiIC8+XG4gICAgICAgIDxzbG90Lz5cbiAgICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgdW5pdCBmcm9tICcuLi8uLi9IZWxwZXJzL1VuaXQnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIGFsdDogU3RyaW5nLFxuXG4gICAgICAgIHNyYzogU3RyaW5nLFxuXG4gICAgICAgIHdpZHRoOiBbU3RyaW5nLCBOdW1iZXJdLFxuXG4gICAgICAgIGhlaWdodDogW1N0cmluZywgTnVtYmVyXSxcblxuICAgICAgICBtaW5IZWlnaHQ6IFtTdHJpbmcsIE51bWJlcl0sXG5cbiAgICAgICAgbWF4SGVpZ2h0OiBbU3RyaW5nLCBOdW1iZXJdLFxuXG4gICAgICAgIG1pbldpZHRoOiBbU3RyaW5nLCBOdW1iZXJdLFxuXG4gICAgICAgIG1heFdpZHRoOiBbU3RyaW5nLCBOdW1iZXJdLFxuXG4gICAgICAgIGZsdWlkOiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgbWV0aG9kczoge1xuXG4gICAgICAgIHVuaXQ6IHVuaXRcblxuICAgIH1cblxufVxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwic2Nzc1wiPlxuLnRodW1ibmFpbC1saXN0LWl0ZW0ge1xuICAgIG1heC13aWR0aDogMTAwJTtcbiAgICBtYXgtaGVpZ2h0OiAxMDAlO1xuXG4gICAgJiA+IGltZyB7XG4gICAgICAgIG1heC13aWR0aDogMTAwJTtcblxuICAgICAgICAmLmltZy1mbHVpZCB7XG4gICAgICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgJjpub3QoOm9ubHktY2hpbGQpIHtcbiAgICAgICAgbWFyZ2luLXJpZ2h0OiAxMHB4O1xuICAgICAgICBtYXJnaW4tYm90dG9tOiAxMHB4O1xuICAgIH1cblxuICAgICY6bnRoLWNoaWxkKDJuKSB7XG4gICAgICAgIG9wYWNpdHk6IC4yNTtcbiAgICB9XG4gICAgKi9cbn1cbjwvc3R5bGU+XG4iLCI8dGVtcGxhdGU+XG4gICAgPGRpdiBjbGFzcz1cInRodW1ibmFpbC1saXN0XCIgOmNsYXNzPVwiY2xhc3Nlc1wiPlxuICAgICAgICA8dGh1bWJuYWlsLWxpc3QtaXRlbSB2LWlmPVwiISFpbWFnZXNcIiB2LWZvcj1cImltYWdlIGluIGltYWdlc1wiIDpzcmM9XCJpbWFnZVwiIDp3aWR0aD1cIndpZHRoXCIgLz5cbiAgICAgICAgPHNsb3QvPlxuICAgIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBUaHVtYm5haWxMaXN0SXRlbSBmcm9tICcuL1RodW1ibmFpbExpc3RJdGVtJztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgY29tcG9uZW50czoge1xuICAgICAgICBUaHVtYm5haWxMaXN0SXRlbVxuICAgIH0sXG5cbiAgICBwcm9wczoge1xuXG4gICAgICAgIGZpbGw6IEJvb2xlYW4sXG5cbiAgICAgICAgZmxleDogQm9vbGVhbixcblxuICAgICAgICBub0ZsZXg6IEJvb2xlYW4sXG5cbiAgICAgICAgZ3JpZDogQm9vbGVhbixcblxuICAgICAgICB3cmFwOiBCb29sZWFuLFxuXG4gICAgICAgIGltYWdlczogQXJyYXksXG5cbiAgICAgICAgd2lkdGg6IHtcbiAgICAgICAgICAgIHR5cGU6IFtTdHJpbmcsIE51bWJlcl0sXG4gICAgICAgICAgICBkZWZhdWx0OiA3NVxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgY29tcHV0ZWQ6IHtcblxuICAgICAgICBjbGFzc2VzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAndGh1bWJuYWlsLWxpc3QtZmlsbCc6IHRoaXMuZmlsbCxcbiAgICAgICAgICAgICAgICAndGh1bWJuYWlsLWxpc3QtZmxleCc6IHRoaXMuZmxleCxcbiAgICAgICAgICAgICAgICAndGh1bWJuYWlsLWxpc3Qtbm9mbGV4JzogdGhpcy5ub0ZsZXgsXG4gICAgICAgICAgICAgICAgJ3RodW1ibmFpbC1saXN0LWdyaWQnOiB0aGlzLmdyaWQsXG4gICAgICAgICAgICAgICAgJ3RodW1ibmFpbC1saXN0LXdyYXAnOiB0aGlzLndyYXBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfVxuXG59XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJzY3NzXCI+XG4udGh1bWJuYWlsLWxpc3Qge1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGRpc3BsYXk6IGZsZXg7XG5cbiAgICAmOm5vdCgudGh1bWJuYWlsLWxpc3QtZ3JpZCkgPiAqIHtcbiAgICAgICAgcGFkZGluZy1yaWdodDogMTBweDtcbiAgICAgICAgcGFkZGluZy1ib3R0b206IDEwcHg7XG4gICAgfVxuXG4gICAgJi50aHVtYm5haWwtbGlzdC1maWxsLFxuICAgICYudGh1bWJuYWlsLWxpc3Qtd3JhcCB7XG4gICAgICAgIGZsZXgtZmxvdzogcm93IHdyYXA7XG4gICAgfVxuXG4gICAgJi50aHVtYm5haWwtbGlzdC1ub2ZsZXggPiAqIHtcbiAgICAgICAgZmxleDogMDtcbiAgICB9XG5cbiAgICAmLnRodW1ibmFpbC1saXN0LWZpbGwgPiAqIHtcbiAgICAgICAgZmxleDogMSAwIGF1dG87XG4gICAgfVxuXG4gICAgJi50aHVtYm5haWwtbGlzdC13cmFwID4gKiB7XG4gICAgICAgIGZsZXg6IDAgMCBhdXRvO1xuICAgIH1cblxuICAgICYudGh1bWJuYWlsLWxpc3QtZmxleCA+ICoge1xuICAgICAgICBmbGV4OiAxO1xuICAgIH1cblxufVxuPC9zdHlsZT5cbiIsImltcG9ydCBUaHVtYm5haWxMaXN0IGZyb20gJy4vVGh1bWJuYWlsTGlzdCc7XG5pbXBvcnQgVGh1bWJuYWlsTGlzdEl0ZW0gZnJvbSAnLi9UaHVtYm5haWxMaXN0SXRlbSc7XG5pbXBvcnQgVnVlSW5zdGFsbGVyIGZyb20gJy4uLy4uL0hlbHBlcnMvVnVlSW5zdGFsbGVyL1Z1ZUluc3RhbGxlcic7XG5cbmNvbnN0IHBsdWdpbiA9IFZ1ZUluc3RhbGxlci51c2Uoe1xuXG4gICAgaW5zdGFsbChWdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgVnVlSW5zdGFsbGVyLmNvbXBvbmVudHMoe1xuICAgICAgICAgICAgVGh1bWJuYWlsTGlzdFxuICAgICAgICB9KTtcbiAgICB9XG5cbn0pO1xuXG5leHBvcnQge1xuICAgIFRodW1ibmFpbExpc3RJdGVtXG59O1xuXG5leHBvcnQgZGVmYXVsdCBUaHVtYm5haWxMaXN0O1xuIiwiLyoqXG4gKiBHZXRzIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5sYXN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAzXG4gKi9cbmZ1bmN0aW9uIGxhc3QoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICByZXR1cm4gbGVuZ3RoID8gYXJyYXlbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGxhc3Q7XG4iLCJpbXBvcnQgYmFzZUdldCBmcm9tICcuL19iYXNlR2V0LmpzJztcbmltcG9ydCBiYXNlU2xpY2UgZnJvbSAnLi9fYmFzZVNsaWNlLmpzJztcblxuLyoqXG4gKiBHZXRzIHRoZSBwYXJlbnQgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fSBwYXRoIFRoZSBwYXRoIHRvIGdldCB0aGUgcGFyZW50IHZhbHVlIG9mLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHBhcmVudCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gcGFyZW50KG9iamVjdCwgcGF0aCkge1xuICByZXR1cm4gcGF0aC5sZW5ndGggPCAyID8gb2JqZWN0IDogYmFzZUdldChvYmplY3QsIGJhc2VTbGljZShwYXRoLCAwLCAtMSkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBwYXJlbnQ7XG4iLCJpbXBvcnQgY2FzdFBhdGggZnJvbSAnLi9fY2FzdFBhdGguanMnO1xuaW1wb3J0IGxhc3QgZnJvbSAnLi9sYXN0LmpzJztcbmltcG9ydCBwYXJlbnQgZnJvbSAnLi9fcGFyZW50LmpzJztcbmltcG9ydCB0b0tleSBmcm9tICcuL190b0tleS5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5zZXRgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHByb3BlcnR5IHBhdGggdG8gdW5zZXQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHByb3BlcnR5IGlzIGRlbGV0ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuc2V0KG9iamVjdCwgcGF0aCkge1xuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcbiAgb2JqZWN0ID0gcGFyZW50KG9iamVjdCwgcGF0aCk7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCB8fCBkZWxldGUgb2JqZWN0W3RvS2V5KGxhc3QocGF0aCkpXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVVuc2V0O1xuIiwiaW1wb3J0IGJhc2VVbnNldCBmcm9tICcuL19iYXNlVW5zZXQuanMnO1xuaW1wb3J0IGlzSW5kZXggZnJvbSAnLi9faXNJbmRleC5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wdWxsQXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaW5kaXZpZHVhbFxuICogaW5kZXhlcyBvciBjYXB0dXJpbmcgdGhlIHJlbW92ZWQgZWxlbWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge251bWJlcltdfSBpbmRleGVzIFRoZSBpbmRleGVzIG9mIGVsZW1lbnRzIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBiYXNlUHVsbEF0KGFycmF5LCBpbmRleGVzKSB7XG4gIHZhciBsZW5ndGggPSBhcnJheSA/IGluZGV4ZXMubGVuZ3RoIDogMCxcbiAgICAgIGxhc3RJbmRleCA9IGxlbmd0aCAtIDE7XG5cbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgdmFyIGluZGV4ID0gaW5kZXhlc1tsZW5ndGhdO1xuICAgIGlmIChsZW5ndGggPT0gbGFzdEluZGV4IHx8IGluZGV4ICE9PSBwcmV2aW91cykge1xuICAgICAgdmFyIHByZXZpb3VzID0gaW5kZXg7XG4gICAgICBpZiAoaXNJbmRleChpbmRleCkpIHtcbiAgICAgICAgc3BsaWNlLmNhbGwoYXJyYXksIGluZGV4LCAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhc2VVbnNldChhcnJheSwgaW5kZXgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VQdWxsQXQ7XG4iLCJpbXBvcnQgYmFzZUl0ZXJhdGVlIGZyb20gJy4vX2Jhc2VJdGVyYXRlZS5qcyc7XG5pbXBvcnQgYmFzZVB1bGxBdCBmcm9tICcuL19iYXNlUHVsbEF0LmpzJztcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBlbGVtZW50cyBmcm9tIGBhcnJheWAgdGhhdCBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3JcbiAqIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIHRoZSByZW1vdmVkIGVsZW1lbnRzLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWRcbiAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gKlxuICogKipOb3RlOioqIFVubGlrZSBgXy5maWx0ZXJgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuIFVzZSBgXy5wdWxsYFxuICogdG8gcHVsbCBlbGVtZW50cyBmcm9tIGFuIGFycmF5IGJ5IHZhbHVlLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi4wLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHJlbW92ZWQgZWxlbWVudHMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBhcnJheSA9IFsxLCAyLCAzLCA0XTtcbiAqIHZhciBldmVucyA9IF8ucmVtb3ZlKGFycmF5LCBmdW5jdGlvbihuKSB7XG4gKiAgIHJldHVybiBuICUgMiA9PSAwO1xuICogfSk7XG4gKlxuICogY29uc29sZS5sb2coYXJyYXkpO1xuICogLy8gPT4gWzEsIDNdXG4gKlxuICogY29uc29sZS5sb2coZXZlbnMpO1xuICogLy8gPT4gWzIsIDRdXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZShhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKCEoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBpbmRleGVzID0gW10sXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgcHJlZGljYXRlID0gYmFzZUl0ZXJhdGVlKHByZWRpY2F0ZSwgMyk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgIGluZGV4ZXMucHVzaChpbmRleCk7XG4gICAgfVxuICB9XG4gIGJhc2VQdWxsQXQoYXJyYXksIGluZGV4ZXMpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCByZW1vdmU7XG4iLCI8dGVtcGxhdGU+XG5cbiAgICA8Zm9ybS1ncm91cCBjbGFzcz1cInVwbG9hZC1maWVsZFwiIDpjbGFzcz1cInsnZW5hYmxlLWRyb3B6b25lJzogZHJvcHpvbmUsICdlbmFibGUtbXVsdGlwbGUnOiBtdWx0aXBsZX1cIj5cblxuICAgICAgICA8ZHJvcHpvbmUgQGRyb3A9XCJvbkRyb3BcIj5cblxuICAgICAgICAgICAgPGZpbGUtZmllbGRcbiAgICAgICAgICAgICAgICB2LWlmPVwibXVsdGlwbGUgJiYgKCFtYXhVcGxvYWRzIHx8IG1heFVwbG9hZHMgPiB2YWx1ZS5sZW5ndGgpIHx8ICFtdWx0aXBsZSAmJiAhdmFsdWVcIlxuICAgICAgICAgICAgICAgIDpuYW1lPVwibmFtZVwiXG4gICAgICAgICAgICAgICAgOmxhYmVsPVwibGFiZWxcIlxuICAgICAgICAgICAgICAgIDpwbGFjZWhvbGRlcj1cInBsYWNlaG9sZGVyXCJcbiAgICAgICAgICAgICAgICA6aGVscC10ZXh0PVwiaGVscFRleHRcIlxuICAgICAgICAgICAgICAgIDptdWx0aXBsZT1cIm11bHRpcGxlXCJcbiAgICAgICAgICAgICAgICA6ZXJyb3JzPVwiZXJyb3JzXCJcbiAgICAgICAgICAgICAgICBAY2hhbmdlPVwib25DaGFuZ2VcIlxuICAgICAgICAgICAgLz5cblxuICAgICAgICAgICAgPHRodW1ibmFpbC1saXN0IHYtaWY9XCJtdWx0aXBsZSAmJiB2YWx1ZSAmJiB2YWx1ZS5sZW5ndGhcIiBjbGFzcz1cIm10LTRcIiB3cmFwPlxuICAgICAgICAgICAgICAgIDx0aHVtYm5haWwtbGlzdC1pdGVtXG4gICAgICAgICAgICAgICAgICAgIHYtZm9yPVwiKGZpbGUsIGtleSkgaW4gdmFsdWVcIlxuICAgICAgICAgICAgICAgICAgICA6a2V5PVwiZmlsZS5pZCB8fCBrZXlcIlxuICAgICAgICAgICAgICAgICAgICA6d2lkdGg9XCJ3aWR0aFwiXG4gICAgICAgICAgICAgICAgICAgIDptaW4td2lkdGg9XCJtaW5XaWR0aFwiXG4gICAgICAgICAgICAgICAgICAgIDptYXgtd2lkdGg9XCJtYXhXaWR0aFwiXG4gICAgICAgICAgICAgICAgICAgIDpoZWlnaHQ9XCJoZWlnaHRcIlxuICAgICAgICAgICAgICAgICAgICA6bWluLWhlaWdodD1cIm1pbkhlaWdodFwiXG4gICAgICAgICAgICAgICAgICAgIDptYXgtaGVpZ2h0PVwibWF4SGVpZ2h0XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZmlsZS1wcmV2aWV3IDpmaWxlPVwiZmlsZVwiIEBjbG9zZT1cInJlbW92ZUZpbGUoZmlsZSlcIi8+XG4gICAgICAgICAgICAgICAgICAgICAgICA8c2xvdCA6ZmlsZT1cImZpbGVcIi8+XG4gICAgICAgICAgICAgICAgPHRodW1ibmFpbC1saXN0LWl0ZW0+XG4gICAgICAgICAgICA8L3RodW1ibmFpbC1saXN0PlxuXG4gICAgICAgICAgICA8dGh1bWJuYWlsLWxpc3Qgdi1lbHNlLWlmPVwiIW11bHRpcGxlICYmIHZhbHVlXCIgY2xhc3M9XCJtdC00XCIgd3JhcD5cbiAgICAgICAgICAgICAgICA8dGh1bWJuYWlsLWxpc3QtaXRlbVxuICAgICAgICAgICAgICAgICAgICA6d2lkdGg9XCJ3aWR0aFwiXG4gICAgICAgICAgICAgICAgICAgIDptaW4td2lkdGg9XCJtaW5XaWR0aFwiXG4gICAgICAgICAgICAgICAgICAgIDptYXgtd2lkdGg9XCJtYXhXaWR0aFwiXG4gICAgICAgICAgICAgICAgICAgIDpoZWlnaHQ9XCJoZWlnaHRcIlxuICAgICAgICAgICAgICAgICAgICA6bWluLWhlaWdodD1cIm1pbkhlaWdodFwiXG4gICAgICAgICAgICAgICAgICAgIDptYXgtaGVpZ2h0PVwibWF4SGVpZ2h0XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZmlsZS1wcmV2aWV3IDpmaWxlPVwidmFsdWVcIiBAY2xvc2U9XCJyZW1vdmVGaWxlKHZhbHVlKVwiLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzbG90IDpmaWxlPVwidmFsdWVcIi8+XG4gICAgICAgICAgICAgICAgPHRodW1ibmFpbC1saXN0LWl0ZW0+XG4gICAgICAgICAgICA8L3RodW1ibmFpbC1saXN0PlxuXG4gICAgICAgICAgICA8ZGl2IHYtaWY9XCJzaG93RHJvcEVsZW1lbnRcIiBjbGFzcz1cInVwbG9hZC1maWVsZC1kcm9wem9uZVwiIDpzdHlsZT1cInsnbWluLWhlaWdodCc6IGRyb3B6b25lTWluSGVpZ2h0fVwiIEBkcm9wLnByZXZlbnQ9XCJvbkRyb3BcIj5cbiAgICAgICAgICAgICAgICA8aSBjbGFzcz1cImZhIGZhLWNsb3VkLXVwbG9hZFwiPjwvaT5cbiAgICAgICAgICAgICAgICA8ZGl2PkRyYWcgYW5kIGRyb3AgZmlsZXMgdG8gdXBsb2FkPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8L2Ryb3B6b25lPlxuXG4gICAgPC9mb3JtLWdyb3VwPlxuXG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IHsgZWFjaCB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgeyByZW1vdmUgfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IHsgaXNBcnJheSB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgeyBmaW5kSW5kZXggfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IHsgaXNVbmRlZmluZWQgfSBmcm9tICdsb2Rhc2gtZXMnXG5pbXBvcnQgRm9ybUdyb3VwIGZyb20gJy4uL0Zvcm1Hcm91cCc7XG5pbXBvcnQgRHJvcHpvbmUgZnJvbSAnLi4vRHJvcHpvbmUvRHJvcHpvbmUnO1xuaW1wb3J0IEZvcm1Db250cm9sIGZyb20gJy4uLy4uL01peGlucy9Gb3JtQ29udHJvbC9Gb3JtQ29udHJvbCc7XG5pbXBvcnQgRmlsZUZpZWxkIGZyb20gJy4uL0ZpbGVGaWVsZC9GaWxlRmllbGQnO1xuaW1wb3J0IEZpbGVQcmV2aWV3IGZyb20gJy4uL0ZpbGVQcmV2aWV3L0ZpbGVQcmV2aWV3JztcbmltcG9ydCBUaHVtYm5haWxMaXN0IGZyb20gJy4uL1RodW1ibmFpbExpc3QvVGh1bWJuYWlsTGlzdCc7XG5pbXBvcnQgVGh1bWJuYWlsTGlzdEl0ZW0gZnJvbSAnLi4vVGh1bWJuYWlsTGlzdC9UaHVtYm5haWxMaXN0SXRlbSc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAgIG5hbWU6ICd1cGxvYWQtZmllbGQnLFxuXG4gICAgbWl4aW5zOiBbRm9ybUNvbnRyb2xdLFxuXG4gICAgY29tcG9uZW50czoge1xuICAgICAgICBEcm9wem9uZSxcbiAgICAgICAgRm9ybUdyb3VwLFxuICAgICAgICBGaWxlRmllbGQsXG4gICAgICAgIEZpbGVQcmV2aWV3LFxuICAgICAgICBUaHVtYm5haWxMaXN0LFxuICAgICAgICBUaHVtYm5haWxMaXN0SXRlbVxuICAgIH0sXG5cbiAgICBtb2RlbDoge1xuICAgICAgICBwcm9wOiAndmFsdWUnLFxuICAgICAgICBldmVudDogJ2NoYW5nZSdcbiAgICB9LFxuXG4gICAgcHJvcHM6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FuIHVzZXIgdXBsb2FkIG11bHRpcGxlIGZpbGVzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIG11bHRpcGxlOiBCb29sZWFuLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgZmlsZXMgdGhhdCBhIHVzZXIgY2FuIHVwbG9hZFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBtYXhVcGxvYWRzOiBOdW1iZXIsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBoZWlnaHQgYXR0cmlidXRlIGZvciB0aGUgY29udHJvbCBlbGVtZW50XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGhlaWdodDogW051bWJlciwgU3RyaW5nXSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1pbmltdW0gaGVpZ2h0IGF0dHJpYnV0ZSBmb3IgdGhlIGNvbnRyb2wgZWxlbWVudFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBtaW5IZWlnaHQ6IFtOdW1iZXIsIFN0cmluZ10sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtYXhpbXVtIGhlaWdodCBhdHRyaWJ1dGUgZm9yIHRoZSBjb250cm9sIGVsZW1lbnRcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgbWF4SGVpZ2h0OiBbTnVtYmVyLCBTdHJpbmddLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgd2lkdGggYXR0cmlidXRlIGZvciB0aGUgY29udHJvbCBlbGVtZW50XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHdpZHRoOiBbTnVtYmVyLCBTdHJpbmddLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWluaW11bSB3aWR0aCBhdHRyaWJ1dGUgZm9yIHRoZSBjb250cm9sIGVsZW1lbnRcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgbWluV2lkdGg6IFtOdW1iZXIsIFN0cmluZ10sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtYXhpbXVtIHdpZHRoIGF0dHJpYnV0ZSBmb3IgdGhlIGNvbnRyb2wgZWxlbWVudFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBtYXhXaWR0aDogW051bWJlciwgU3RyaW5nXSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FuIHVzZXIgZHJhZy9kcm9wIGZpbGVzIGludG8gYnJvd3NlciB0byB1cGxvYWQgdGhlbS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgZHJvcHpvbmVNaW5IZWlnaHQ6IFtOdW1iZXIsIFN0cmluZ10sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElzIHRoZSB1c2VyIGRyYWdnaW5nIGEgZmlsZSBvdmVyIHRoZSBkcm9wem9uZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBkcmFnZ2luZzoge1xuICAgICAgICAgICAgdHlwZTogW1N0cmluZywgQm9vbGVhbl0sXG4gICAgICAgICAgICBkZWZhdWx0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbiB1c2VyIGRyYWcvZHJvcCBmaWxlcyBpbnRvIGJyb3dzZXIgdG8gdXBsb2FkIHRoZW0uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGRyb3B6b25lOiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGF0YSBhdHRyaWJ1dGVcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IEZpbGV8RmlsZUxpc3R8QXJyYXlcbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICB0eXBlOiBbT2JqZWN0LCBGaWxlLCBGaWxlTGlzdCwgQXJyYXldLFxuICAgICAgICAgICAgZGVmYXVsdCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIXRoaXMubXVsdGlwbGUgPyBudWxsIDogW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBtZXRob2RzOiB7XG5cbiAgICAgICAgcmVtb3ZlRmlsZShkYXRhKSB7XG4gICAgICAgICAgICBpZih0aGlzLm11bHRpcGxlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsZXMgPSBpc0FycmF5KHRoaXMudmFsdWUpID8gdGhpcy52YWx1ZS5zbGljZSgwKSA6IFtdO1xuXG4gICAgICAgICAgICAgICAgaWYoZGF0YSBpbnN0YW5jZW9mIEZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlKGZpbGVzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBkYXRhLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplOiBkYXRhLnNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0TW9kaWZpZWQ6IGRhdGEubGFzdE1vZGlmaWVkXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlKGZpbGVzLCBkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnLCBmaWxlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBhZGRGaWxlKGZpbGUsIHN1YmplY3QpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogZmlsZS5uYW1lLFxuICAgICAgICAgICAgICAgIGxhc3RNb2RpZmllZDogZmlsZS5sYXN0TW9kaWZpZWQsXG4gICAgICAgICAgICAgICAgbGFzdE1vZGlmaWVkRGF0ZTogZmlsZS5sYXN0TW9kaWZpZWREYXRlLFxuICAgICAgICAgICAgICAgIHNpemU6IGZpbGUuc2l6ZSxcbiAgICAgICAgICAgICAgICB0eXBlOiBmaWxlLnR5cGVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYodGhpcy5tdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVzID0gc3ViamVjdCB8fCAoaXNBcnJheSh0aGlzLnZhbHVlKSA/IHRoaXMudmFsdWUuc2xpY2UoMCkgOiBbXSk7XG5cbiAgICAgICAgICAgICAgICBpZighdGhpcy5tYXhVcGxvYWRzIHx8IHRoaXMubWF4VXBsb2FkcyA+IGZpbGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpZihmaW5kSW5kZXgoZmlsZXMsIGRhdGEpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZXMucHVzaChmaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScsIGZpbGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnLCBmaWxlKVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGFkZEZpbGVzKGZpbGVzKSB7XG4gICAgICAgICAgICBjb25zdCBzdWJqZWN0ID0gaXNBcnJheSh0aGlzLnZhbHVlKSA/IHRoaXMudmFsdWUuc2xpY2UoMCkgOiBbXTtcblxuICAgICAgICAgICAgZWFjaChmaWxlcywgZmlsZSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRGaWxlKGZpbGUsIHN1YmplY3QpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGV2ZW50LnRhcmdldC52YWx1ZSA9IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25Ecm9wKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLm9uQ2hhbmdlKGV2ZW50LmRhdGFUcmFuc2Zlci5maWxlcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25DaGFuZ2UoZmlsZXMpIHtcbiAgICAgICAgICAgIGlmKGZpbGVzIGluc3RhbmNlb2YgRmlsZUxpc3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEZpbGVzKGZpbGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkRmlsZShmaWxlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBgZHJhZ292ZXJgIGV2ZW50IGNhbGxiYWNrLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBvbkRyYWdPdmVyKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmlzRHJhZ2dpbmdJbnNpZGUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgndXBkYXRlOmRyYWdnaW5nJywgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCdkcmFnOm92ZXInLCBldmVudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBgZHJhZ292ZXJgIGV2ZW50IGNhbGxiYWNrLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBvbkRyYWdFbnRlcihldmVudCkge1xuICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nSW5zaWRlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ3VwZGF0ZTpkcmFnZ2luZycsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgnZHJhZzplbnRlcicsIGV2ZW50KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGBkcmFnbGVhdmVgIGV2ZW50IGNhbGxiYWNrLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBvbkRyYWdMZWF2ZShldmVudCkge1xuICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nSW5zaWRlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCd1cGRhdGU6ZHJhZ2dpbmcnLCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCdkcmFnOmxlYXZlJywgZXZlbnQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYGRyb3BgIGV2ZW50IGNhbGxiYWNrLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBvbkRyb3AoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZ0luc2lkZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5hZGRGaWxlcyhldmVudC5kYXRhVHJhbnNmZXIuZmlsZXMpO1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgndXBkYXRlOmRyYWdnaW5nJywgZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgnZHJvcCcsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBjb21wdXRlZDoge1xuICAgICAgICBzaG93RHJvcEVsZW1lbnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gIWlzVW5kZWZpbmVkKHRoaXMuZHJhZ2dpbmcpID8gdGhpcy5kcmFnZ2luZyA6IHRoaXMuaXNEcmFnZ2luZ0luc2lkZVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpc0RyYWdnaW5nSW5zaWRlOiBmYWxzZVxuICAgICAgICB9O1xuICAgIH1cblxufVxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgVXBsb2FkRmllbGQgZnJvbSAnLi9VcGxvYWRGaWVsZCc7XG5pbXBvcnQgVnVlSW5zdGFsbGVyIGZyb20gJy4uLy4uL0hlbHBlcnMvVnVlSW5zdGFsbGVyL1Z1ZUluc3RhbGxlcic7XG5cbmNvbnN0IHBsdWdpbiA9IFZ1ZUluc3RhbGxlci51c2Uoe1xuXG4gICAgaW5zdGFsbChWdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgVnVlSW5zdGFsbGVyLmNvbXBvbmVudHMoe1xuICAgICAgICAgICAgVXBsb2FkRmllbGRcbiAgICAgICAgfSk7XG4gICAgfVxuXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgVXBsb2FkRmllbGQ7XG4iLCJjb25zdCBTVFlMRV9BVFRSSUJVVEVTID0gW1xuICAgICdmb250JyxcbiAgICAnZm9udEZhbWlseScsXG4gICAgJ2ZvbnRLZXJuaW5nJyxcbiAgICAnZm9udFNpemUnLFxuICAgICdmb250U3RyZXRjaCcsXG4gICAgJ2ZvbnRTdHlsZScsXG4gICAgJ2ZvbnRWYXJpYW50JyxcbiAgICAnZm9udFZhcmlhbnRMaWdhdHVyZXMnLFxuICAgICdmb250VmFyaWFudENhcHMnLFxuICAgICdmb250VmFyaWFudE51bWVyaWMnLFxuICAgICdmb250VmFyaWFudEVhc3RBc2lhbicsXG4gICAgJ2ZvbnRXZWlnaHQnLFxuICAgICdsaW5lSGVpZ2h0JyxcbiAgICAnbGV0dGVyU3BhY2luZycsXG4gICAgJ3BhZGRpbmcnLFxuICAgICdtYXJnaW4nLFxuICAgICd0ZXh0QWxpZ24nLFxuICAgICd0ZXh0QWxpZ25MYXN0JyxcbiAgICAndGV4dERlY29yYXRpb24nLFxuICAgICd0ZXh0RGVjb3JhdGlvbkxpbmUnLFxuICAgICd0ZXh0RGVjb3JhdGlvblN0eWxlJyxcbiAgICAndGV4dERlY29yYXRpb25Db2xvcicsXG4gICAgJ3RleHREZWNvcmF0aW9uU2tpcEluaycsXG4gICAgJ3RleHREZWNvcmF0aW9uUG9zaXRpb24nLFxuICAgICd0ZXh0SW5kZW50JyxcbiAgICAndGV4dFJlbmRlcmluZycsXG4gICAgJ3RleHRTaGFkb3cnLFxuICAgICd0ZXh0U2l6ZUFkanVzdCcsXG4gICAgJ3RleHRPdmVyZmxvdycsXG4gICAgJ3RleHRUcmFuc2Zvcm0nLFxuICAgICd3aWR0aCcsXG4gICAgJ3dvcmRCcmVhaycsXG4gICAgJ3dvcmRTcGFjaW5nJyxcbiAgICAnd29yZFdyYXAnXG5dO1xuXG5cbmZ1bmN0aW9uIGludChzdHIpIHtcbiAgICBpZih0eXBlb2Ygc3RyID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIGVsc2UgaWYoIXN0ciB8fCAhc3RyLnJlcGxhY2UpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlSW50KHN0ci5yZXBsYWNlKC9bXlxcZC5dKy9nLCAnJykpO1xufVxuXG5mdW5jdGlvbiBpbnB1dChkaXYsIGV2ZW50KSB7XG4gICAgZGl2LmlubmVySFRNTCA9IGV2ZW50LnRhcmdldC52YWx1ZS5yZXBsYWNlKC8oPzpcXHJcXG58XFxyfFxcbikvZywgJzxiciAvPicpO1xufVxuXG5mdW5jdGlvbiBoZWlnaHQoZWwpIHtcbiAgICByZXR1cm4gaW50KGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCk7XG59XG5cbmZ1bmN0aW9uIHN0eWxlKGVsLCBhdHRyKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKVthdHRyXTtcbn1cblxuZnVuY3Rpb24gcmVzaXplKHRhcmdldCwgZGl2LCBtaW5IZWlnaHQsIG1heEhlaWdodCkge1xuICAgIGNvbnN0IGR5bmFtaWNIZWlnaHQgPSBNYXRoLm1heChoZWlnaHQoZGl2KSArIGludChzdHlsZShkaXYsICdsaW5lSGVpZ2h0JykpLCBtaW5IZWlnaHQpO1xuICAgIHRhcmdldC5zdHlsZS5oZWlnaHQgPSAoKCFtYXhIZWlnaHQgfHwgZHluYW1pY0hlaWdodCA8IG1heEhlaWdodCkgPyBkeW5hbWljSGVpZ2h0IDogbWF4SGVpZ2h0KSArICdweCc7XG59XG5cbmZ1bmN0aW9uIHNldE1pbkhlaWdodChkaXYsIGVsKSB7XG4gICAgZGl2LnN0eWxlLm1pbkhlaWdodCA9IGhlaWdodChlbCkgKyAncHgnO1xufVxuXG5mdW5jdGlvbiBtaW1pYyhlbCkge1xuICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnN0IHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcblxuICAgIGZvcihsZXQgaSBpbiBTVFlMRV9BVFRSSUJVVEVTKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IFNUWUxFX0FUVFJJQlVURVNbaV07XG5cbiAgICAgICAgZGl2LnN0eWxlW2tleV0gPSBzdHlsZXNba2V5XTtcbiAgICB9XG5cbiAgICBkaXYuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGRpdi5zdHlsZS5ib3R0b20gPSAnMTAwJSc7XG4gICAgZGl2LnN0eWxlLnpJbmRleCA9IC0xO1xuICAgIGRpdi5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG5cbiAgICByZXR1cm4gZGl2O1xufVxuXG5mdW5jdGlvbiBpbml0KGVsLCBtYXhIZWlnaHQpIHtcbiAgICBjb25zdCBkaXYgPSBtaW1pYyhlbCk7XG4gICAgY29uc3QgbWluSGVpZ2h0ID0gaGVpZ2h0KGVsKTtcblxuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgZXZlbnQgPT4ge1xuICAgICAgICBpbnB1dChkaXYsIGV2ZW50KTtcbiAgICAgICAgcmVzaXplKGVsLCBkaXYsIG1pbkhlaWdodCwgbWF4SGVpZ2h0KTtcbiAgICB9KTtcblxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcblxuICAgIGVsLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdpbnB1dCcpKTtcbn1cblxuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBpbnNlcnRlZChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICAgICAgaWYoZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpICE9PSAndGV4dGFyZWEnKSB7XG4gICAgICAgICAgICBlbCA9IGVsLnF1ZXJ5U2VsZWN0b3IoJ3RleHRhcmVhJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZighZWwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQSB0ZXh0YXJlYSBpcyByZXF1aXJlZCBmb3IgdGhlIHYtYXV0b2dyb3cgZGlyZWN0aXZlLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5pdChlbCwgYmluZGluZy52YWx1ZSk7XG4gICAgfVxuXG59XG4iLCJpbXBvcnQgQXV0b2dyb3cgZnJvbSAnLi9BdXRvZ3Jvdyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKFZ1ZSwgb3B0aW9ucykge1xuICAgIFZ1ZS5kaXJlY3RpdmUoJ2F1dG9ncm93JywgQXV0b2dyb3cpO1xufTtcbiIsImltcG9ydCB7IGlzVW5kZWZpbmVkIH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCB0cmFuc2l0aW9uIGZyb20gJy4uLy4uL0hlbHBlcnMvVHJhbnNpdGlvbic7XG5cbmZ1bmN0aW9uIHNob3coZWwsIHRhcmdldCwgdm5vZGUpIHtcbiAgICB0YXJnZXQuY2xhc3NMaXN0LnJlbW92ZSgnY29sbGFwc2UnKTtcbiAgICB0YXJnZXQuY2xhc3NMaXN0LmFkZCgnc2hvdycpO1xuICAgIHRhcmdldC4kY29sbGFwc2VkSGVpZ2h0ID0gZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpLmhlaWdodDtcbiAgICB0YXJnZXQuY2xhc3NMaXN0LmFkZCgnY29sbGFwc2luZycpO1xuXG4gICAgdm5vZGUuY29udGV4dC4kbmV4dFRpY2soKCkgPT4ge1xuICAgICAgICB0YXJnZXQuc3R5bGUuaGVpZ2h0ID0gdGFyZ2V0LiRjb2xsYXBzZWRIZWlnaHQ7XG4gICAgfSk7XG5cbiAgICB0cmFuc2l0aW9uKHRhcmdldCkudGhlbihkZWxheSA9PiB7XG4gICAgICAgIHRhcmdldC5zdHlsZS5oZWlnaHQgPSBudWxsO1xuICAgICAgICB0YXJnZXQuY2xhc3NMaXN0LmFkZCgnY29sbGFwc2UnKTtcbiAgICAgICAgdGFyZ2V0LmNsYXNzTGlzdC5yZW1vdmUoJ2NvbGxhcHNpbmcnKTtcbiAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSgnY29sbGFwc2VkJyk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGhpZGUoZWwsIHRhcmdldCwgdm5vZGUpIHtcbiAgICB0YXJnZXQuc3R5bGUuaGVpZ2h0ID0gdGFyZ2V0LiRjb2xsYXBzZWRIZWlnaHQ7XG4gICAgdGFyZ2V0LmNsYXNzTGlzdC5hZGQoJ2NvbGxhcHNpbmcnKTtcbiAgICB0YXJnZXQuY2xhc3NMaXN0LnJlbW92ZSgnY29sbGFwc2UnKTtcblxuICAgIHZub2RlLmNvbnRleHQuJG5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgdGFyZ2V0LnN0eWxlLmhlaWdodCA9IDA7XG4gICAgfSk7XG5cbiAgICB0cmFuc2l0aW9uKHRhcmdldCkudGhlbihkZWxheSA9PiB7XG4gICAgICAgIHRhcmdldC5zdHlsZS5oZWlnaHQgPSBudWxsO1xuICAgICAgICB0YXJnZXQuY2xhc3NMaXN0LmFkZCgnY29sbGFwc2UnKTtcbiAgICAgICAgdGFyZ2V0LmNsYXNzTGlzdC5yZW1vdmUoJ3Nob3cnLCAnY29sbGFwc2luZycpO1xuICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKCdjb2xsYXBzZWQnKTtcbiAgICB9KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gICAgaW5zZXJ0ZWQoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgICAgIGlmKGlzVW5kZWZpbmVkKGJpbmRpbmcudmFsdWUpIHx8IGJpbmRpbmcudmFsdWUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoJ2NvbGxhcHNlZCcpO1xuICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdkYXRhLXRvZ2dsZScsICdjb2xsYXBzZScpO1xuXG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGFyZ2V0JykgfHwgZWwuZ2V0QXR0cmlidXRlKCdocmVmJyk7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwodGFyZ2V0KTtcblxuICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgZWxlbWVudHMuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYoIWVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdzaG93JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3coZWwsIGVsZW1lbnQsIHZub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpZGUoZWwsIGVsZW1lbnQsIHZub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgaWYoIWVsZW1lbnQuJGNvbGxhcHNlZEhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LiRjb2xsYXBzZWRIZWlnaHQgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLmhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICAgIGlmKCFlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnY29sbGFwc2UnKSkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2NvbGxhcHNlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbn1cbiIsImltcG9ydCBDb2xsYXBzZSBmcm9tICcuL0NvbGxhcHNlJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oVnVlLCBvcHRpb25zKSB7XG4gICAgVnVlLmRpcmVjdGl2ZSgnY29sbGFwc2UnLCBDb2xsYXBzZSk7XG59O1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYmxvYih1cmwsIHByb2dyZXNzKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIHVybCwgdHJ1ZSk7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYmxvYic7XG5cbiAgICAgICAgaWYoaXNGdW5jdGlvbihwcm9ncmVzcykpIHtcbiAgICAgICAgICAgIHhoci5vbnByb2dyZXNzID0gZSA9PiBwcm9ncmVzcyhlLCB4aHIpO1xuICAgICAgICB9XG5cbiAgICAgICAgeGhyLm9uZXJyb3IgPSBlID0+IHJlamVjdChlKTtcbiAgICAgICAgeGhyLm9uYWJvcnQgPSBlID0+IHJlamVjdChlKTtcbiAgICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLnJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB4aHIuc2VuZCgpO1xuICAgIH0pO1xufVxuIiwiaW1wb3J0ICogYXMgZmlsdGVycyBmcm9tICcuL0ZpbHRlcnMnO1xuaW1wb3J0ICogYXMgcGx1Z2lucyBmcm9tICcuL1BsdWdpbnMnO1xuaW1wb3J0ICogYXMgY29tcG9uZW50cyBmcm9tICcuL0NvbXBvbmVudHMnO1xuaW1wb3J0ICogYXMgZGlyZWN0aXZlcyBmcm9tICcuL0RpcmVjdGl2ZXMnO1xuaW1wb3J0IFZ1ZUluc3RhbGxlciBmcm9tICcuL0hlbHBlcnMvVnVlSW5zdGFsbGVyJztcblxuZXhwb3J0ICogZnJvbSAnLi9IdHRwJztcbmV4cG9ydCAqIGZyb20gJy4vTWl4aW5zJztcbmV4cG9ydCAqIGZyb20gJy4vUGx1Z2lucyc7XG5leHBvcnQgKiBmcm9tICcuL0NvbXBvbmVudHMnO1xuZXhwb3J0ICogZnJvbSAnLi9EaXJlY3RpdmVzJztcbmV4cG9ydCAqIGZyb20gJy4vRmlsdGVycyc7XG5leHBvcnQgKiBmcm9tICcuL0hlbHBlcnMnO1xuXG5leHBvcnQgZGVmYXVsdCBWdWVJbnN0YWxsZXIudXNlKHtcblxuICAgIGluc3RhbGwoVnVlKSB7XG5cbiAgICAgICAgLypcbiAgICAgICAgaWYocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICAgIGNvbnN0IGRvbWFpbiA9IChsb2NhdGlvbi5ob3N0IHx8ICdsb2NhbGhvc3QnKS5zcGxpdCgnOicpWzBdO1xuICAgICAgICAgICAgY29uc3QgcG9ydCA9IHByb2Nlc3MuZW52LkxJVkVSRUxPQURfT1BUSU9OUyAmJiBwcm9jZXNzLmVudi5MSVZFUkVMT0FEX09QVElPTlMucG9ydDtcbiAgICAgICAgICAgIFZ1ZUluc3RhbGxlci5zY3JpcHQoYGh0dHA6Ly8ke2RvbWFpbn06JHtwb3J0fS9saXZlcmVsb2FkLmpzP3NuaXB2ZXI9MWApO1xuICAgICAgICB9XG4gICAgICAgICovXG5cbiAgICAgICAgVnVlSW5zdGFsbGVyLnBsdWdpbnMoVnVlLCBwbHVnaW5zKTtcbiAgICAgICAgVnVlSW5zdGFsbGVyLmZpbHRlcnMoVnVlLCBmaWx0ZXJzKTtcbiAgICAgICAgVnVlSW5zdGFsbGVyLmRpcmVjdGl2ZXMoVnVlLCBkaXJlY3RpdmVzKTtcbiAgICAgICAgVnVlSW5zdGFsbGVyLmNvbXBvbmVudHMoVnVlLCBjb21wb25lbnRzKTtcbiAgICB9XG5cbn0pO1xuIl0sIm5hbWVzIjpbInZhbHVlIiwiZm9ybWF0IiwibW9tZW50IiwiU3RyaW5nIiwiVnVlIiwib3B0aW9ucyIsImZpbHRlciIsIkRhdGVGaWx0ZXIiLCJNb21lbnRGaWx0ZXIiLCJnbG9iYWwiLCJTeW1ib2wiLCJvYmplY3RQcm90byIsIm5hdGl2ZU9iamVjdFRvU3RyaW5nIiwic3ltVG9TdHJpbmdUYWciLCJpc0Z1bmN0aW9uIiwiZnVuY1Byb3RvIiwiZnVuY1RvU3RyaW5nIiwiaGFzT3duUHJvcGVydHkiLCJNQVhfU0FGRV9JTlRFR0VSIiwiYXJnc1RhZyIsImZ1bmNUYWciLCJmcmVlRXhwb3J0cyIsImZyZWVNb2R1bGUiLCJtb2R1bGVFeHBvcnRzIiwia2V5c0luIiwiTWFwIiwiSEFTSF9VTkRFRklORUQiLCJCdWZmZXIiLCJvYmplY3RUYWciLCJwcm90b3R5cGUiLCIkbWVyZ2VDbGFzc2VzIiwiY2xhc3NlcyIsInNsaWNlIiwiY2FsbCIsImFyZ3VtZW50cyIsIl9pc09iamVjdCIsImFyZyIsIl9pc0FycmF5Iiwic3RyaW5nVGFnIiwicnNDb21ib01hcmtzUmFuZ2UiLCJyZUNvbWJvSGFsZk1hcmtzUmFuZ2UiLCJyc0NvbWJvU3ltYm9sc1JhbmdlIiwicnNDb21ib1JhbmdlIiwicnNDb21ibyIsInJzQXBvcyIsInJlbmRlciIsInByb3BzIiwibm9kZXMiLCJ0eXBlIiwiTnVtYmVyIiwiZGVmYXVsdCIsInNpemUiLCJwcmVmaXgiLCJjb21wdXRlZCIsIiRvcHRpb25zIiwibmFtZSIsInJlcGxhY2UiLCJleHRlbmRzIiwiQmFzZVR5cGUiLCJfZXh0ZW5kIiwiaXNGaW5pdGUiLCJoZWlnaHQiLCJfaXNGaW5pdGUiLCJjZW50ZXIiLCJCb29sZWFuIiwiZml4ZWQiLCJyZWxhdGl2ZSIsIm1pbkhlaWdodCIsIm1pbldpZHRoIiwiY29tcG9uZW50cyIsIkFjdGl2aXR5SW5kaWNhdG9yRG90cyIsIkFjdGl2aXR5SW5kaWNhdG9yU3Bpbm5lciIsIm1ldGhvZHMiLCJ1bml0IiwiY29tcG9uZW50IiwiX2tlYmFiQ2FzZSIsImxvYWRlZCIsImVsZW1lbnQiLCJ1cmwiLCJzY3JpcHQiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJzZXRBdHRyaWJ1dGUiLCJhcHBlbmQiLCJxdWVyeVNlbGVjdG9yIiwiYXBwZW5kQ2hpbGQiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImFkZEV2ZW50TGlzdGVuZXIiLCJldmVudCIsImUiLCJWdWVJbnN0YWxsZXIiLCJ1c2UiLCJwbHVnaW4iLCJwbHVnaW5zIiwiZmlsdGVycyIsImRpcmVjdGl2ZSIsImRpcmVjdGl2ZXMiLCIkcGx1Z2lucyIsIiRmaWx0ZXJzIiwiJGRpcmVjdGl2ZXMiLCIkY29tcG9uZW50cyIsIndpbmRvdyIsImRlZiIsIl9pc0Z1bmN0aW9uIiwiaW5zdGFsbCIsIkFjdGl2aXR5SW5kaWNhdG9yIiwiY29udmVydEFuaW1hdGlvbkRlbGF5VG9JbnQiLCJkZWxheSIsIm51bSIsInBhcnNlRmxvYXQiLCJtYXRjaGVzIiwibWF0Y2giLCJtaWxsaXNlY29uZHMiLCJhbmltYXRlZCIsImVsIiwiY2FsbGJhY2siLCJkZWZhdWx0VmlldyIsIm93bmVyRG9jdW1lbnQiLCJzZXRUaW1lb3V0IiwiYXBwbHkiLCJnZXRDb21wdXRlZFN0eWxlIiwiYW5pbWF0aW9uRHVyYXRpb24iLCJhY3RpdmUiLCJhY3Rpdml0eSIsImJsb2NrIiwiZGlzYWJsZWQiLCJsYWJlbCIsImljb24iLCJ2YXJpYW50IiwiaW5kaWNhdG9yIiwib3JpZW50YXRpb24iLCJkaXNhYmxlIiwiJGVsIiwiZW5hYmxlIiwic2hvd0FjdGl2aXR5IiwiY2xhc3NMaXN0IiwiYWRkIiwiJGVtaXQiLCJoaWRlQWN0aXZpdHkiLCJyZW1vdmUiLCJvbkNsaWNrIiwid2F0Y2giLCJCdG5BY3Rpdml0eSIsImZhZGUiLCJzaG93IiwiTW9kYWxUaXRsZSIsImFyaWFMYWJlbCIsImNsb3NlYWJsZSIsImR1cmF0aW9uIiwidHJhbnNpdGlvbkR1cmF0aW9uIiwibnVtZXJpYyIsInRyYW5zaXRpb24iLCJ0YXJnZXQiLCJFbGVtZW50IiwidHJpZ2dlciIsIkFycmF5IiwiaW5pdGlhbGl6ZVRyaWdnZXIiLCJfaXNTdHJpbmciLCJzcGxpdCIsInRvZ2dsZSIsImZvY3VzIiwib3BlbiIsImlzRGlzcGxheWluZyIsIiRuZXh0VGljayIsInRoZW4iLCJpc1Nob3dpbmciLCJjbG9zZSIsInRyaWdnZXJhYmxlQ2xhc3NlcyIsIm1vdW50ZWQiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZm9yRWFjaCIsImRhdGEiLCJNb2RhbEJvZHkiLCJNb2RhbEJhY2tkcm9wIiwiTW9kYWxDb250ZW50IiwiTW9kYWxEaWFsb2ciLCJNb2RhbEhlYWRlciIsIk1vZGFsRm9vdGVyIiwibWl4aW5zIiwiVHJpZ2dlcmFibGUiLCJiYWNrZHJvcCIsImJhY2tkcm9wQ29tcG9uZW50IiwiZXh0ZW5kIiwiJG1vdW50IiwiYm9keSIsIiRkZXN0cm95IiwiZmx1c2giLCJva0xhYmVsIiwiY2FuY2VsTGFiZWwiLCJ0aXRsZSIsInZhbGlkYXRlIiwiaW5kZXhPZiIsImNhbmNlbCIsImNvbmZpcm0iLCJvbkVzYyIsImJlZm9yZVJvdXRlTGVhdmUiLCJ0byIsImZyb20iLCJuZXh0IiwibW9kYWwiLCJlbnN1cmUiLCJ2YWx1ZXMiLCJwcm9wc0RhdGEiLCJfZGVmYXVsdHNEZWVwIiwicHJvbWlzZSIsInByZXZlbnREZWZhdWx0IiwiJG9uIiwiY29uc29sZSIsImxvZyIsIiRtb2RhbCIsImNvbnRlbnQiLCJtb2RhbE9wdGlvbnMiLCJNb2RhbENvbXBvbmVudCIsInRlbXBsYXRlIiwidnVlIiwicm91dGUiLCIkcm91dGUiLCJyb3V0ZXIiLCIkcm91dGVyIiwiTW9kYWwiLCIkY29udGVudCIsIiRhbGVydCIsIiRjb25maXJtIiwiJHByb21wdCIsIkNvbnRhaW5lciIsIk92ZXJsYXlCb2R5IiwiT3ZlcmxheUNvbnRlbnQiLCJiYWNrZ3JvdW5kIiwiZml4ZWRDb250ZW50IiwiaGlkZUNsb3NlQnV0dG9uIiwib25DbGlja0Nsb3NlIiwiJG92ZXJsYXkiLCJDb250ZW50Q29tcG9uZW50Iiwib3ZlcmxheU9wdGlvbnMiLCJDdXN0b21PdmVybGF5Q29tcG9uZW50Iiwib3ZlcmxheSIsIk92ZXJsYXkiLCJpbnN0YW5jZSIsIkNvbXBvbmVudCIsImRlZmluZVByb3BlcnR5IiwiYm9vbFRhZyIsIkNPTVBBUkVfUEFSVElBTF9GTEFHIiwiQ09NUEFSRV9VTk9SREVSRURfRkxBRyIsImRhdGVUYWciLCJlcnJvclRhZyIsIm1hcFRhZyIsIm51bWJlclRhZyIsInJlZ2V4cFRhZyIsInNldFRhZyIsInN5bWJvbFRhZyIsImFycmF5QnVmZmVyVGFnIiwiZGF0YVZpZXdUYWciLCJzeW1ib2xQcm90byIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwid2Vha01hcFRhZyIsImFycmF5VGFnIiwiZ2V0VGFnIiwiSU5GSU5JVFkiLCJzdWJqZWN0IiwiZGVsaW1ldGVyIiwicHJlZml4ZXIiLCJrZXkiLCJzdHJpbmciLCJSZWdFeHAiLCJqb2luIiwiX2lzQm9vbGVhbiIsIl9pc051bGwiLCJfaXNVbmRlZmluZWQiLCJfbWFwS2V5cyIsImFuaW1hdGlvbiIsImJvdW5kYXJ5IiwiY29udGFpbmVyIiwiT2JqZWN0IiwiY29uc3RydWN0b3IiLCJmYWxsYmFja1BsYWNlbWVudCIsIm9mZnNldCIsInBsYWNlbWVudCIsIkZ1bmN0aW9uIiwic2VsZWN0b3IiLCJjcmVhdGVQb3BwZXIiLCJQb3BwZXIiLCJtb2RpZmllcnMiLCJmbGlwIiwiYm91bmRhcmllc0VsZW1lbnQiLCJiZWhhdmlvciIsImVuYWJsZWQiLCJhcnJvdyIsImdldEFycm93RWxlbWVudCIsImJlZm9yZUNyZWF0ZSIsIiRwb3BwZXJzIiwiaW5pdCIsInBvcHBlciIsInVwZGF0ZSIsInRhZyIsIlBvcG92ZXIiLCJQb3BvdmVyQm9keSIsIlBvcG92ZXJIZWFkZXIiLCIkcG9wb3ZlciIsInBvcG92ZXIiLCJ2YXJpYW50Q2xhc3NQcmVmaXgiLCJ2YXJpYW50Q2xhc3MiLCJWYXJpYW50IiwicmVxdWlyZWQiLCJzdHJpcGVkIiwibWluIiwibWF4Iiwib2Zmc2V0VmFsdWUiLCJmb3JtYXR0ZWRIZWlnaHQiLCJwcm9ncmVzc0NsYXNzZXMiLCJQcm9ncmVzc0JhciIsIkFsZXJ0Q2xvc2UiLCJBbGVydEhlYWRpbmciLCJkaXNtaXNzaWJsZSIsImhlYWRpbmciLCJkaXNtaXNzIiwiaXNWaXNpYmxlIiwiZGlzbWlzc0NvdW50IiwiaW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJBbGVydCIsIkFsZXJ0TGluayIsImFjY2Vzc2liaWxpdHkiLCJocmVmIiwicGlsbCIsInNlY29uZGFyeSIsIkJhZGdlIiwibmF0aXZlR2V0U3ltYm9scyIsInJzQXN0cmFsUmFuZ2UiLCJyc1ZhclJhbmdlIiwicnNaV0oiLCJyc0ZpdHoiLCJyc01vZGlmaWVyIiwicnNOb25Bc3RyYWwiLCJyc1JlZ2lvbmFsIiwicnNTdXJyUGFpciIsInJlT3B0TW9kIiwicnNPcHRWYXIiLCJyc09wdEpvaW4iLCJyc1NlcSIsInJzQXN0cmFsIiwicnNTeW1ib2wiLCJyZVVuaWNvZGUiLCJzeW1ib2xWYWx1ZU9mIiwiZmxvYXQzMlRhZyIsImZsb2F0NjRUYWciLCJpbnQ4VGFnIiwiaW50MTZUYWciLCJpbnQzMlRhZyIsInVpbnQ4VGFnIiwidWludDhDbGFtcGVkVGFnIiwidWludDE2VGFnIiwidWludDMyVGFnIiwiZ2VuVGFnIiwiQ0xPTkVfREVFUF9GTEFHIiwiQ0xPTkVfU1lNQk9MU19GTEFHIiwibmF0aXZlTWF4IiwiV1JBUF9CSU5EX0ZMQUciLCJXUkFQX0JJTkRfS0VZX0ZMQUciLCJXUkFQX0NVUlJZX0ZMQUciLCJXUkFQX1BBUlRJQUxfRkxBRyIsIldSQVBfUEFSVElBTF9SSUdIVF9GTEFHIiwiV1JBUF9DVVJSWV9SSUdIVF9GTEFHIiwiV1JBUF9BUllfRkxBRyIsIldSQVBfRkxJUF9GTEFHIiwiUExBQ0VIT0xERVIiLCJXUkFQX0NVUlJZX0JPVU5EX0ZMQUciLCJXUkFQX1JFQVJHX0ZMQUciLCJuYXRpdmVNaW4iLCJGVU5DX0VSUk9SX1RFWFQiLCJyZXNwb25zZVR5cGUiLCJ0cmFuc2Zvcm1SZXF1ZXN0IiwidHJhbnNmb3JtUmVzcG9uc2UiLCJ0cmFuc2Zvcm1lciIsImNvbnRleHQiLCJFcnJvciIsIlJlcXVlc3RPcHRpb25zIiwicHVzaCIsIlBST1hZX09QVElPTl9QUk9QRVJUSUVTIiwiUFJPWFlfT1BUSU9OX01FVEhPRFMiLCJnZXQiLCJwcm9wIiwic2V0IiwibWVyZ2UiLCJtZXRob2QiLCJhY3Rpb24iLCJfY2FtZWxDYXNlIiwiY2hhaW5hYmxlIiwiRm9ybURhdGEiLCJhcmdzIiwiaXRlbXMiLCJzcGxpY2UiLCJfZmlyc3QiLCJpIiwiX21lcmdlV2l0aCIsImNvbmNhdCIsIlJlcXVlc3QiLCJoZWFkZXJzIiwicGFyYW1zIiwiX2Nsb25lRGVlcCIsIl9iaW5kIiwicmVzZXQiLCIkZXJyb3IiLCIkc3RhdHVzIiwiJHN0YXR1c1RleHQiLCIkcmVzcG9uc2UiLCIkcmVxdWVzdFNlbnRBdCIsIiRyZXNwb25zZVJlY2VpdmVkQXQiLCJoYXNSZXNwb25zZSIsInNlbmQiLCJhZGRPcHRpb24iLCJheGlvcyIsInJlc3BvbnNlIiwic3RhdHVzIiwic3RhdHVzVGV4dCIsImVycm9yIiwic3VjY2VzcyIsImludGVyY2VwdG9ycyIsInJlcXVlc3QiLCJvcHRpb24iLCJNb2RlbCIsIiRrZXkiLCIkcHJvcGVydGllcyIsInByb3BlcnRpZXMiLCIkZmlsZXMiLCJmaWxlcyIsImluaXRpYWxpemUiLCIkZXhpc3RzIiwiJGNoYW5nZWQiLCIkYXR0cmlidXRlcyIsImZpbGwiLCIkaW5pdGlhbGl6ZWQiLCJfZmlsdGVyIiwiZW5kcG9pbnQiLCJleGlzdHMiLCJpZCIsInNldEF0dHJpYnV0ZXMiLCJnZXRBdHRyaWJ1dGVzIiwiZ2V0QXR0cmlidXRlIiwidW5kZWZpbmVkIiwiX2tleXMiLCJoYW5kbGVBdHRyaWJ1dGVDaGFuZ2UiLCJfc2l6ZSIsImNvdW50IiwidG90YWwiLCJfcmVkdWNlIiwiY2FycnkiLCJGaWxlIiwiRmlsZUxpc3QiLCJ0b0pTT04iLCJoYW5kbGVQcmltYXJ5S2V5Q2hhbmdlIiwiY29uZmlnIiwiY3JlYXRlIiwidXJpIiwiaGFzRmlsZXMiLCJ0b0pzb24iLCJ0b0Zvcm1EYXRhIiwicG9zdCIsImRlbGV0ZSIsImZvcm0iLCJpdGVtIiwiSlNPTiIsInN0cmluZ2lmeSIsIl9waWNrQnkiLCJsZW5ndGgiLCJtb2RlbCIsIl9tYXAiLCJlcnJvcnMiLCJpbmxpbmUiLCJub3ZhbGlkYXRlIiwicmVkaXJlY3QiLCJvblN1Ym1pdCIsInN1Ym1pdCIsIm9uU3VibWl0U3VjY2VzcyIsIm9uU3VibWl0RmFpbGVkIiwib25VcGxvYWRQcm9ncmVzcyIsIkJhc2VGb3JtIiwiQnJlYWRjcnVtYkl0ZW0iLCJCcmVhZGNydW1iIiwic2l6ZWFibGVDbGFzc1ByZWZpeCIsInNpemVhYmxlQ2xhc3MiLCJDT0xPUlMiLCJfZWFjaCIsImNvbG9yIiwibmFtZXNwYWNlIiwidGV4dENvbG9yIiwiYmdDb2xvciIsImJvcmRlckNvbG9yIiwiYmdHcmFkaWVudENvbG9yIiwidGV4dENvbG9yQ2xhc3NlcyIsInRyaW0iLCJib3JkZXJDb2xvckNsYXNzZXMiLCJiZ0NvbG9yQ2xhc3NlcyIsImJnR3JhZGllbnRDb2xvckNsYXNzZXMiLCJjb2xvcmFibGVDbGFzc2VzIiwiX29taXRCeSIsIlNpemVhYmxlIiwiQ29sb3JhYmxlIiwib3V0bGluZSIsIkJ0biIsInNyT25seSIsInNyT25seUZvY3VzYWJsZSIsInNjcmVlbnJlYWRlckNsYXNzZXMiLCJTY3JlZW5yZWFkZXJzIiwiSGVscFRleHQiLCJGb3JtR3JvdXAiLCJGb3JtTGFiZWwiLCJpbnZhbGlkIiwidmFsaWQiLCJGb3JtRmVlZGJhY2siLCJhdXRvY29tcGxldGUiLCJwbGFjZWhvbGRlciIsImdyb3VwIiwicGF0dGVybiIsImZlZWRiYWNrIiwiYmluZEV2ZW50cyIsImRlZmF1bHRDb250cm9sQ2xhc3MiLCJoaWRlTGFiZWwiLCJzcGFjaW5nIiwicGxhaW50ZXh0IiwicmVhZG9ubHkiLCJoZWxwVGV4dCIsIm1heGxlbmd0aCIsImJpbmQiLCJiaW5kaW5nIiwidm5vZGUiLCJldmVudHMiLCJnZXRJbnB1dEZpZWxkIiwiZ2V0RmllbGRFcnJvcnMiLCJ1cGRhdGVkIiwiY2FsbGJhY2tzIiwibWFwIiwiaW52YWxpZEZlZWRiYWNrIiwidmFsaWRGZWVkYmFjayIsImNvbnRyb2xDbGFzcyIsImNvbnRyb2xTaXplQ2xhc3MiLCJjb250cm9sQ2xhc3NlcyIsImhhc0RlZmF1bHRTbG90IiwiJHNsb3RzIiwiRm9ybUNvbnRyb2wiLCJJbnB1dEZpZWxkIiwiZXh0ZW5zaW9ucyIsIm11bHRpcGxlIiwid2lkdGgiLCJGaWxlRmllbGQiLCJCdG5GaWxlIiwiYnV0dG9ucyIsInZlcnRpY2FsIiwiQnRuR3JvdXAiLCJCdG5Hcm91cFRvZ2dsZSIsIkJ0blRvb2xiYXIiLCJ1dWlkIiwiciIsIk1hdGgiLCJyYW5kb20iLCJ2IiwiYyIsInRvU3RyaW5nIiwicHJveHkiLCJQcm94eSIsImJ1dHRvbiIsImhlYWRlciIsIkRyb3Bkb3duTWVudUl0ZW0iLCJEcm9wZG93bk1lbnVIZWFkZXIiLCJEcm9wZG93bk1lbnVEaXZpZGVyIiwiYWxpZ24iLCJ0b0xvd2VyQ2FzZSIsIm9uSXRlbUNsaWNrIiwiJGNoaWxkcmVuIiwiY2hpbGQiLCJEcm9wZG93bk1lbnUiLCJUQUJfS0VZQ09ERSIsIkxFRlRfQVJST1dfS0VZQ09ERSIsIlJJR0hUX0FSUk9XX0tFWUNPREUiLCJVUF9BUlJPV19LRVlDT0RFIiwiRE9XTl9BUlJPV19LRVlDT0RFIiwiaWdub3JlQmx1ckV2ZW50IiwiYXV0b2Nsb3NlIiwiZHJvcHVwIiwiZHJvcHJpZ2h0IiwiZHJvcGxlZnQiLCJxdWVyeUZvY3VzYWJsZSIsImlzRm9jdXNhYmxlIiwiaXNEcm9wZG93blNob3dpbmciLCJoaWRlIiwic2lkZSIsIm1lbnUiLCJwb3NpdGlvbiIsIm9uQmx1ciIsImNvbnRhaW5zIiwicmVsYXRlZFRhcmdldCIsIm9uTWVudUNsaWNrIiwiYWN0aW9uQ2xhc3NlcyIsInRvZ2dsZUNsYXNzZXMiLCJrZXlkb3duIiwiaWdub3JlIiwia2V5Q29kZSIsImJsdXIiLCJtb3VzZWRvd24iLCJCdG5Ecm9wZG93biIsImdldFNsb3QiLCJzbG90IiwiaGFzU2xvdCIsImhhc1Nsb3RzIiwic2xvdHMiLCJIYXNTbG90cyIsImNsYXNzTmFtZSIsIkNhcmQiLCJDYXJkSGVhZGVyIiwiYWx0IiwidGV4dFRydW5jYXRlIiwic3JjIiwiQ2FyZEltZyIsIkNhcmRCb2R5IiwiQ2FyZEJ0bkdyb3VwIiwiQ2FyZERlY2siLCJDYXJkRm9vdGVyIiwiQ2FyZEltZ1RvcCIsIkNhcmRJbWdCb3R0b20iLCJDYXJkSW1nT3ZlcmxheSIsIkNhcmRMaW5rIiwiQ2FyZFN1YnRpdGxlIiwiQ2FyZFRpdGxlIiwiY3VzdG9tIiwiY2hlY2tlZCIsImNoZWNrZWRWYWx1ZSIsImxhYmVsQ2xhc3MiLCJpbnB1dENsYXNzIiwiaW5saW5lQ2xhc3MiLCJjdXN0b21Db250cm9sQ2xhc3MiLCJSYWRpb0ZpZWxkIiwiY2hlY2tlZFZhbHVlcyIsImluZGV4IiwiQ2hlY2tib3hGaWVsZCIsIm9uRHJvcCIsImlzRHJhZ2dpbmciLCJvbkRyYWdvdmVyIiwib25EcmFnZW50ZXIiLCJvbkRyYWdsZWF2ZSIsIkRyb3B6b25lIiwicmVhZEZpbGUiLCJmaWxlIiwicHJvZ3Jlc3MiLCJyZWFkZXIiLCJGaWxlUmVhZGVyIiwib25sb2FkIiwib25lcnJvciIsIm9uYWJvcnQiLCJvbnByb2dyZXNzIiwicmVhZEFzRGF0YVVSTCIsInJlYWR5IiwiaW5zZXJ0ZWQiLCJoaWRlQ2xvc2UiLCJpbWFnZU1pbWVzIiwib3JpZ19maWxlbmFtZSIsImV4dGVuc2lvbiIsInBvcCIsImJ5dGVzVG9TaXplIiwiYnl0ZXMiLCJtaW1lIiwiaXNJbWFnZSIsImxhc3RNb2RpZmllZCIsImxhc3RNb2RpZmllZERhdGUiLCJzdGFydCIsImxlbmd0aENvbXB1dGFibGUiLCJwYXJzZUludCIsImltYWdlIiwicmVzdWx0IiwiZGlmZiIsInNpemVzIiwiZmxvb3IiLCJyb3VuZCIsInBvdyIsIkZpbGVQcmV2aWV3Iiwic2VsZWN0IiwidGhyZXNob2xkIiwic2Nyb2xsSW50b1ZpZXdwb3J0IiwiZW50cnkiLCJzY3JvbGxPdXRWaWV3cG9ydCIsImhlaWdodFVuaXQiLCJJbnRlcnNlY3Rpb25PYnNlcnZlciIsImVudHJpZXMiLCJvYnNlcnZlciIsImlzSW50ZXJzZWN0aW5nIiwiaGFzU2Nyb2xsZWRJbnRvVmlld3BvcnQiLCJvYnNlcnZlIiwidGV4dCIsIklucHV0R3JvdXBUZXh0IiwiSW5wdXRHcm91cEFwcGVuZCIsIklucHV0R3JvdXBQcmVwZW5kIiwicHJlcGVuZCIsIklucHV0R3JvdXAiLCJhY3RpdmVDbGFzcyIsIm9uVmFsdWUiLCJvZmZWYWx1ZSIsImlzQWN0aXZlIiwiZHJhZ2dpbmciLCJnZXRUcmFuc2l0aW9uSW5NaWxsaXNlY29uZHMiLCJMaWdodFN3aXRjaEZpZWxkIiwiYmFkZ2UiLCJpc0Rpc2FibGVkIiwiYmFkZ2VPcHRpb25zIiwiYWN0aXZhdGUiLCJkZWFjdGl2YXRlIiwicHJldlZhbHVlIiwiTGlzdEdyb3VwSXRlbSIsImFjdGl2YXRlYWJsZSIsImJpbmRFdmVudHNUb0NoaWxkcmVuIiwiJG9mZiIsIm9uQ2xpY2tJdGVtIiwib25BY3RpdmF0ZSIsIm9uRGVhY3RpdmF0ZSIsImFjdGl2ZUl0ZW0iLCJMaXN0R3JvdXAiLCJoMSIsImNvbGxhcHNlIiwiTmF2YmFyVG9nZ2xlckljb24iLCJleHBhbmRlZCIsIk5hdmJhckJyYW5kIiwiTmF2YmFyQ29sbGFwc2UiLCJOYXZiYXJUZXh0IiwiTmF2YmFyVG9nZ2xlciIsImV4cGFuZCIsInN0aWNreSIsImV4cGFuZGVkQ2xhc3MiLCJpc0l0ZW0iLCIkcGFyZW50IiwiTmF2aWdhdGlvbkxpbmsiLCJsaXN0IiwiTmF2aWdhdGlvbkl0ZW0iLCJjYXJkIiwianVzdGlmaWVkIiwicGlsbHMiLCJ0YWJzIiwicm9sZSIsImlzQ2FyZCIsIk5hdmlnYXRpb24iLCJOYXZpZ2F0aW9uRHJvcGRvd24iLCJOYXZiYXIiLCJOYXZiYXJOYXYiLCJwYWdlIiwidG90YWxQYWdlcyIsInNob3dQYWdlcyIsIm9uUGFnaW5hdGUiLCJwYWdpbmF0ZSIsImN1cnJlbnRQYWdlIiwicHJldiIsImN1cnJlbnRUYXJnZXQiLCJwYXJlbnROb2RlIiwic2V0QWN0aXZlUGFnZSIsImdlbmVyYXRlIiwicGFnZXMiLCJzdGFydFBhZ2UiLCJzdGFydE9mZnNldCIsImVuZFBhZ2UiLCJkaXZpZGVyIiwiUGFnaW5hdGlvbiIsIkNVU1RPTV9TRUxFQ1RfUFJFRklYIiwiY3VzdG9tU2VsZWN0Q2xhc3NlcyIsImN1c3RvbVNlbGVjdFNpemVDbGFzcyIsIlNlbGVjdEZpZWxkIiwiZnVuY3Rpb25hbCIsImVsbSIsImgiLCJmaW5kSW5kZXgiLCJzbGlkZXMiLCJzbGlkZSIsIlJFU0laRV9NT0RFUyIsImF1dG8iLCJjbGllbnRIZWlnaHQiLCJzdHlsZSIsImNsaWVudFdpZHRoIiwiaW5pdGlhbCIsIlNsaWRlIiwiU2xpZGVEZWNrQ29udHJvbHMiLCJmbGV4IiwiY29udHJvbHMiLCJyZXNpemVNb2RlIiwib2xkVmFsdWUiLCJjdXJyZW50U2xpZGUiLCJkaXJlY3Rpb24iLCJmaW5kU2xpZGVJbmRleCIsImZpbmRTbGlkZUJ5S2V5IiwiZmluZFNsaWRlQnlJbmRleCIsIl9maW5kSW5kZXgiLCJyZXNpemUiLCJvbkNsaWNrQ29udHJvbCIsIm9uU2xpZGVFbnRlciIsImRvbmUiLCJvblNsaWRlTGVhdmUiLCJwYXJlbnRFbGVtZW50Iiwib3ZlcmZsb3ciLCJTbGlkZURlY2siLCJUcmFuc2Zvcm1lciIsIiRvcmlnaW5hbFJlc3BvbnNlIiwiJHJlcXVpcmVkIiwiJHRyYW5zZm9ybWVkUmVzcG9uc2UiLCJ0cmFuc2Zvcm0iLCJUYWJsZVZpZXdUcmFuc2Zvcm1lciIsImxpbWl0Iiwib3JkZXIiLCJzb3J0IiwiY29sdW1ucyIsImhvdmVyIiwiZGVzY3JpcHRpb24iLCJ0YWJsZUNvbHVtbnMiLCJjb2x1bW4iLCJvcmRlckJ5IiwiZGVmYXVsdFNvcnQiLCJjdXJyZW50U29ydCIsImdldFJlcXVlc3RQYXJhbSIsImN1cnJlbnRPcmRlciIsImFkZFJlcXVlc3RQYXJhbSIsImZldGNoIiwiZ2V0UmVxdWVzdEhlYWRlciIsImFkZFJlcXVlc3RIZWFkZXIiLCJsb2FkaW5nIiwiZWxlbWVudHMiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCIkYXR0cnMiLCJiZWZvcmVEZXN0cm95IiwiVGFibGVWaWV3Iiwicm93cyIsIlRleHRhcmVhRmllbGQiLCJtYXhIZWlnaHQiLCJtYXhXaWR0aCIsImZsdWlkIiwiVGh1bWJuYWlsTGlzdEl0ZW0iLCJub0ZsZXgiLCJncmlkIiwid3JhcCIsImltYWdlcyIsIlRodW1ibmFpbExpc3QiLCJhcnJheVByb3RvIiwibWF4VXBsb2FkcyIsImRyb3B6b25lTWluSGVpZ2h0IiwiZHJvcHpvbmUiLCJyZW1vdmVGaWxlIiwiYWRkRmlsZSIsImFkZEZpbGVzIiwib25DaGFuZ2UiLCJkYXRhVHJhbnNmZXIiLCJvbkRyYWdPdmVyIiwiaXNEcmFnZ2luZ0luc2lkZSIsIm9uRHJhZ0VudGVyIiwib25EcmFnTGVhdmUiLCJzaG93RHJvcEVsZW1lbnQiLCJVcGxvYWRGaWVsZCIsIlNUWUxFX0FUVFJJQlVURVMiLCJpbnQiLCJzdHIiLCJpbnB1dCIsImRpdiIsImlubmVySFRNTCIsImF0dHIiLCJkeW5hbWljSGVpZ2h0IiwibWltaWMiLCJzdHlsZXMiLCJib3R0b20iLCJ6SW5kZXgiLCJ2aXNpYmlsaXR5IiwiZGlzcGF0Y2hFdmVudCIsIkV2ZW50IiwidGFnTmFtZSIsIkF1dG9ncm93IiwiJGNvbGxhcHNlZEhlaWdodCIsIkNvbGxhcHNlIiwiYmxvYiIsInhociIsIlhNTEh0dHBSZXF1ZXN0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7SUFFZSxxQkFBU0EsS0FBVCxFQUFnQkMsTUFBaEIsRUFBd0I7SUFDbkMsTUFBR0QsS0FBSCxFQUFVO0lBQ04sV0FBT0UsT0FBT0MsT0FBT0gsS0FBUCxDQUFQLEVBQXNCQyxNQUF0QixDQUE2QkEsTUFBN0IsQ0FBUDtJQUNIOztJQUVELFNBQU8sRUFBUDtJQUNIOztJQ05jLHVCQUFTRCxLQUFULEVBQWdCQyxNQUFoQixFQUF3QjtJQUNuQyxTQUFPRCxRQUFRRSxPQUFPQyxPQUFPSCxLQUFQLENBQVAsQ0FBUixHQUFnQyxJQUF2QztJQUNIOztJQ0ljLGdCQUFTSSxHQUFULEVBQWNDLE9BQWQsRUFBdUI7SUFDbENELE1BQUlFLE1BQUosQ0FBVyxNQUFYLEVBQW1CQyxVQUFuQjtJQUNBSCxNQUFJRSxNQUFKLENBQVcsUUFBWCxFQUFxQkUsWUFBckI7SUFDSDs7Ozs7Ozs7O0lDWEQ7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLFFBQVEsQ0FBQyxLQUFLLEVBQUU7SUFDekIsRUFBRSxJQUFJLElBQUksR0FBRyxPQUFPLEtBQUssQ0FBQztJQUMxQixFQUFFLE9BQU8sS0FBSyxJQUFJLElBQUksS0FBSyxJQUFJLElBQUksUUFBUSxJQUFJLElBQUksSUFBSSxVQUFVLENBQUMsQ0FBQztJQUNuRSxDQUFDOztJQzVCRDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJ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QUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO0lBQ2xDLEVBQUUsSUFBSSxLQUFLLElBQUksU0FBUyxFQUFFO0lBQzFCLElBQUksSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO0lBQ2YsR0FBRyxNQUFNO0lBQ1QsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDaEMsR0FBRztJQUNILEVBQUUsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDO0lBQ2QsRUFBRSxPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7O0lDOUJEO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsWUFBWSxDQUFDLEdBQUcsRUFBRTtJQUMzQixFQUFFLElBQUksSUFBSSxHQUFHLElBQUksQ0FBQyxRQUFRO0lBQzFCLE1BQU0sS0FBSyxHQUFHLFlBQVksQ0FBQyxJQUFJLEVBQUUsR0FBRyxDQUFDLENBQUM7O0lBRXRDLEVBQUUsT0FBTyxLQUFLLEdBQUcsQ0FBQyxHQUFHLFNBQVMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDaEQsQ0FBQzs7SUNkRDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLFlBQVksQ0FBQyxHQUFHLEVBQUU7SUFDM0IsRUFBRSxPQUFPLFlBQVksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQy9DLENBQUM7O0lDWEQ7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLFlBQVksQ0FBQyxHQUFHLEVBQUUsS0FBSyxFQUFFO0lBQ2xDLEVBQUUsSUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDLFFBQVE7SUFDMUIsTUFBTSxLQUFLLEdBQUcsWUFBWSxDQUFDLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQzs7SUFFdEMsRUFBRSxJQUFJ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LEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxHQUFHO0lBQy9FLEVBQUUsTUFBTSxFQUFFLEdBQUcsR0FBRyxNQUFNLEVBQUUsR0FBRztJQUMzQixFQUFFLE1BQU0sRUFBRSxHQUFHLEdBQUcsTUFBTSxFQUFFLEdBQUc7SUFDM0IsRUFBRSxNQUFNLEVBQUUsR0FBRyxHQUFHLE1BQU0sRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsR0FBRztJQUNyRCxFQUFFLE1BQU0sRUFBRSxHQUFHLEdBQUcsTUFBTSxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxHQUFHO0lBQ3JELEVBQUUsTUFBTSxFQUFFLEdBQUcsR0FBRyxNQUFNLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLEdBQUc7SUFDckQsRUFBRSxNQUFNLEVBQUUsR0FBRyxHQUFHLE1BQU0sRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsR0FBRztJQUNyRCxFQUFFLE1BQU0sRUFBRSxHQUFHLEdBQUcsTUFBTSxFQUFFLEdBQUc7SUFDM0IsRUFBRSxNQUFNLEVBQUUsR0FBRyxHQUFHLE1BQU0sRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLEdBQUc7SUFDL0UsRUFBRSxNQUFNLEVBQUUsR0FBRyxHQUFHLE1BQU0sRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLEdBQUc7SUFDL0UsRUFBRSxNQUFNLEVBQUUsR0FBRyxHQUFHLE1BQU0sRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsR0FBRztJQUNyRCxFQUFFLE1BQU0sRUFBRSxHQUFHLEdBQUcsTUFBTSxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxHQUFHO0lBQ3JELEVBQUUsTUFBTSxFQUFFLEdBQUcsR0FBRyxNQUFNLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxHQUFHO0lBQ3hDLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsSUFBSTtJQUM1QixFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLElBQUk7SUFDNUIsRUFBRSxNQUFNLEVBQUUsSUFBSTtJQUNkO0lBQ0EsRUFBRSxRQUFRLEVBQUUsR0FBRyxHQUFHLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUc7SUFDOUMsRUFBRSxRQUFRLEVBQUUsR0FBRyxHQUFHLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUc7SUFDOUMsRUFBRSxRQUFRLEVBQUUsR0FBRyxHQUFHLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRztJQUM3RCxFQUFFLFFBQVEsRUFBRSxHQUFHLEdBQUcsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHO0lBQzdELEVBQUUsUUFBUSxFQUFFLEdBQUcsR0FBRyxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUc7SUFDN0QsRUFBRSxRQUFRLEVBQUUsR0FBRyxHQUFHLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHO0lBQzVFLEVBQUUsUUFBUSxFQUFFLEdBQUcsR0FBRyxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRztJQUM1RSxFQUFFLFFBQVEsRUFBRSxHQUFHLEdBQUcsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHO0lBQzdELEVBQUUsUUFBUSxFQUFFLEdBQUcsR0FBRyxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUc7SUFDN0QsRUFBRSxRQUFRLEVBQUUsR0FBRyxHQUFHLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRztJQUM3RCxFQUFFLFFBQVEsRUFBRSxHQUFHLEdBQUcsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUc7SUFDNUUsRUFBRSxRQUFRLEVBQUUsR0FBRyxHQUFHLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHO0lBQzVFLEVBQUUsUUFBUSxFQUFFLEdBQUcsR0FBRyxRQUFRLEVBQUUsR0FBRztJQUMvQixFQUFFLFFBQVEsRUFBRSxHQUFHLEdBQUcsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRztJQUM5QyxFQUFFLFFBQVEsRUFBRSxHQUFHLEdBQUcsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUc7SUFDNUUsRUFBRSxRQUFRLEVBQUUsR0FBRyxHQUFHLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHO0lBQzVFLEVBQUUsUUFBUSxFQUFFLEdBQUcsR0FBRyxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUc7SUFDN0QsRUFBRSxRQUFRLEVBQUUsR0FBRyxHQUFHLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRztJQUM3RCxFQUFFLFFBQVEsRUFBRSxHQUFHLEdBQUcsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRztJQUM5QyxFQUFFLFFBQVEsRUFBRSxHQUFHLEdBQUcsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRztJQUM5QyxFQUFFLFFBQVEsRUFBRSxHQUFHLEdBQUcsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRztJQUM5QyxFQUFFLFFBQVEsRUFBRSxHQUFHLEdBQUcsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRztJQUM5QyxFQUFFLFFBQVEsRUFBRSxHQUFHLEdBQUcsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHO0lBQzdELEVBQUUsUUFBUSxFQUFFLEdBQUcsR0FBRyxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUc7SUFDN0QsRUFBRSxRQUFRLEVBQUUsR0FBRyxHQUFHLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUc7SUFDOUMsRUFBRSxRQUFRLEVBQUUsR0FBRyxHQUFHLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUc7SUFDOUMsRUFBRSxRQUFRLEVBQUUsR0FBRyxHQUFHLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUc7SUFDM0YsRUFBRSxRQUFRLEVBQUUsR0FBRyxHQUFHLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUc7SUFDM0YsRUFBRSxRQUFRLEVBQUUsR0FBRyxHQUFHLFFBQVEsRUFBRSxHQUFHO0lBQy9CLEVBQUUsUUFBUSxFQUFFLEdBQUcsR0FBRyxRQUFRLEVBQUUs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QyxDQUFDLENBQUM7SUFDdkMsTUFBTSxLQUFLLENBQUMsRUFBRSxPQUFPLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNoRCxNQUFNLEtBQUssQ0FBQyxFQUFFLE9BQU8sSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN6RCxNQUFNLEtBQUssQ0FBQyxFQUFFLE9BQU8sSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDbEUsTUFBTSxLQUFLLENBQUMsRUFBRSxPQUFPLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUMzRSxNQUFNLEtBQUssQ0FBQyxFQUFFLE9BQU8sSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNwRixNQUFNLEtBQUssQ0FBQyxFQUFFLE9BQU8sSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENB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SSxLQUFLLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3hCLEVBQUUsSUFBSSxLQUFLLEVBQUU7SUFDYixJQUFJLElBQUksUUFBUSxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUMzQixJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxRQUFRLEdBQUcsV0FBVyxDQUFDLFFBQVEsRUFBRSxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDO0lBQ3pFLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLFFBQVEsR0FBRyxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFRCxhQUFXLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDMUUsR0FBRztJQUNIO0lBQ0EsRUFBRSxLQUFLLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3BCLEVBQUUsSUFBSSxLQUFLLEVBQUU7SUFDYixJQUFJLFFBQVEsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDdkIsSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsUUFBUSxHQUFHLGdCQUFnQixDQUFDLFFBQVEsRUFBRSxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDO0lBQzlFLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLFFBQVEsR0FBRyxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFQSxhQUFXLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDMUUsR0FBRztJQUNIO0lBQ0EsRUFBRSxLQUFLLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3BCLEVBQUUsSUFBSSxLQUFLLEVBQUU7SUFDYixJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUM7SUFDcEIsR0FBRztJQUNIO0lBQ0EsRUFBRSxJQUFJLFVBQVUsR0FBR0YsZUFB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QUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxRQUFRLENBQUMsS0FBSyxFQUFFO0lBQ3pCLEVBQUUsSUFBSSxDQUFDLEtBQUssRUFBRTtJQUNkLElBQUksT0FBTyxLQUFLLEtBQUssQ0FBQyxHQUFHLEtBQUssR0FBRyxDQUFDLENBQUM7SUFDbkMsR0FBRztJQUNILEVBQUUsS0FBSyxHQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUMxQixFQUFFLElBQUksS0FBSyxLQUFLQSxVQUFRLElBQUksS0FBSyxLQUFLLENBQUNBLFVBQVEsRUFBRTtJQUNqRCxJQUFJLElBQUksSUFBSSxJQUFJLEtBQUssR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDcEMsSUFBSSxPQUFPLElBQUksR0FBRyxXQUFXLENBQUM7SUFDOUIsR0FBRztJQUNILEVBQUUsT0FBTyxLQUFLLEtBQUssS0FBSyxHQUFHLEtBQUssR0FBRyxDQUFDLENBQUM7SUFDckMsQ0FBQzs7SUNyQ0Q7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsU0FBUyxDQUFDLEtBQUssRUFBRTtJQUMxQixFQUFFLElBQUksTUFBTSxHQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUM7SUFDOUIsTUFBTSxTQUFTLEdBQUcsTUFBTSxHQUFHLENBQUMsQ0FBQzs7SUFFN0IsRUFBRSxPQUFPLE1BQU0sS0FBSyxNQUFNLElBQUksU0FBUyxHQUFHLE1BQU0sR0FBRyxTQUFTLEdBQUcsTUFBTSxJQUFJLENBQUMsQ0FBQztJQUMzRSxDQUFDOztJQ3RCRDtJQUNBLElBQUlnSCxpQkFBZSxHQUFHLHFCQUFxQixDQUFDOztJQUU1QztJ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
